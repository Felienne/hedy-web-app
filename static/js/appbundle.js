var hedyApp = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb2, mod) => function __require2() {
    return mod || (0, cb2[Object.keys(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // node_modules/jszip/dist/jszip.min.js
  var require_jszip_min = __commonJS({
    "node_modules/jszip/dist/jszip.min.js"(exports, module) {
      !function(e) {
        if (typeof exports == "object" && typeof module != "undefined")
          module.exports = e();
        else if (typeof define == "function" && define.amd)
          define([], e);
        else {
          (typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this).JSZip = e();
        }
      }(function() {
        return function s(a, o, h3) {
          function u(r, e2) {
            if (!o[r]) {
              if (!a[r]) {
                var t2 = typeof __require == "function" && __require;
                if (!e2 && t2)
                  return t2(r, true);
                if (l)
                  return l(r, true);
                var n = new Error("Cannot find module '" + r + "'");
                throw n.code = "MODULE_NOT_FOUND", n;
              }
              var i = o[r] = { exports: {} };
              a[r][0].call(i.exports, function(e3) {
                var t3 = a[r][1][e3];
                return u(t3 || e3);
              }, i, i.exports, s, a, o, h3);
            }
            return o[r].exports;
          }
          for (var l = typeof __require == "function" && __require, e = 0; e < h3.length; e++)
            u(h3[e]);
          return u;
        }({ 1: [function(e, t2, r) {
          "use strict";
          var d2 = e("./utils"), c2 = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          r.encode = function(e2) {
            for (var t3, r2, n, i, s, a, o, h3 = [], u = 0, l = e2.length, f = l, c3 = d2.getTypeOf(e2) !== "string"; u < e2.length; )
              f = l - u, n = c3 ? (t3 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t3 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t3 >> 2, s = (3 & t3) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h3.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
            return h3.join("");
          }, r.decode = function(e2) {
            var t3, r2, n, i, s, a, o = 0, h3 = 0, u = "data:";
            if (e2.substr(0, u.length) === u)
              throw new Error("Invalid base64 input, it looks like a data url.");
            var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
            if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
              throw new Error("Invalid base64 input, bad content length.");
            for (l = c2.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
              t3 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h3++] = t3, s !== 64 && (l[h3++] = r2), a !== 64 && (l[h3++] = n);
            return l;
          };
        }, { "./support": 30, "./utils": 32 }], 2: [function(e, t2, r) {
          "use strict";
          var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
          function o(e2, t3, r2, n2, i2) {
            this.compressedSize = e2, this.uncompressedSize = t3, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
          }
          o.prototype = { getContentWorker: function() {
            var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t3 = this;
            return e2.on("end", function() {
              if (this.streamInfo.data_length !== t3.uncompressedSize)
                throw new Error("Bug : uncompressed data size mismatch");
            }), e2;
          }, getCompressedWorker: function() {
            return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
          } }, o.createWorkerFrom = function(e2, t3, r2) {
            return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t3.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t3);
          }, t2.exports = o;
        }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t2, r) {
          "use strict";
          var n = e("./stream/GenericWorker");
          r.STORE = { magic: "\0\0", compressWorker: function() {
            return new n("STORE compression");
          }, uncompressWorker: function() {
            return new n("STORE decompression");
          } }, r.DEFLATE = e("./flate");
        }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t2, r) {
          "use strict";
          var n = e("./utils");
          var o = function() {
            for (var e2, t3 = [], r2 = 0; r2 < 256; r2++) {
              e2 = r2;
              for (var n2 = 0; n2 < 8; n2++)
                e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
              t3[r2] = e2;
            }
            return t3;
          }();
          t2.exports = function(e2, t3) {
            return e2 !== void 0 && e2.length ? n.getTypeOf(e2) !== "string" ? function(e3, t4, r2, n2) {
              var i = o, s = n2 + r2;
              e3 ^= -1;
              for (var a = n2; a < s; a++)
                e3 = e3 >>> 8 ^ i[255 & (e3 ^ t4[a])];
              return -1 ^ e3;
            }(0 | t3, e2, e2.length, 0) : function(e3, t4, r2, n2) {
              var i = o, s = n2 + r2;
              e3 ^= -1;
              for (var a = n2; a < s; a++)
                e3 = e3 >>> 8 ^ i[255 & (e3 ^ t4.charCodeAt(a))];
              return -1 ^ e3;
            }(0 | t3, e2, e2.length, 0) : 0;
          };
        }, { "./utils": 32 }], 5: [function(e, t2, r) {
          "use strict";
          r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
        }, {}], 6: [function(e, t2, r) {
          "use strict";
          var n = null;
          n = typeof Promise != "undefined" ? Promise : e("lie"), t2.exports = { Promise: n };
        }, { lie: 37 }], 7: [function(e, t2, r) {
          "use strict";
          var n = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Uint32Array != "undefined", i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
          function h3(e2, t3) {
            a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t3, this.meta = {};
          }
          r.magic = "\b\0", s.inherits(h3, a), h3.prototype.processChunk = function(e2) {
            this.meta = e2.meta, this._pako === null && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
          }, h3.prototype.flush = function() {
            a.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], true);
          }, h3.prototype.cleanUp = function() {
            a.prototype.cleanUp.call(this), this._pako = null;
          }, h3.prototype._createPako = function() {
            this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
            var t3 = this;
            this._pako.onData = function(e2) {
              t3.push({ data: e2, meta: t3.meta });
            };
          }, r.compressWorker = function(e2) {
            return new h3("Deflate", e2);
          }, r.uncompressWorker = function() {
            return new h3("Inflate", {});
          };
        }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t2, r) {
          "use strict";
          function A(e2, t3) {
            var r2, n2 = "";
            for (r2 = 0; r2 < t3; r2++)
              n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
            return n2;
          }
          function n(e2, t3, r2, n2, i2, s2) {
            var a, o, h3 = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h3.name)), c2 = I.transformTo("string", O.utf8encode(h3.name)), d2 = h3.comment, p = I.transformTo("string", s2(d2)), m = I.transformTo("string", O.utf8encode(d2)), _ = c2.length !== h3.name.length, g = m.length !== d2.length, b = "", v = "", y2 = "", w = h3.dir, k = h3.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
            t3 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
            var S = 0;
            t3 && (S |= 8), l || !_ && !g || (S |= 2048);
            var z2 = 0, C2 = 0;
            w && (z2 |= 16), i2 === "UNIX" ? (C2 = 798, z2 |= function(e3, t4) {
              var r3 = e3;
              return e3 || (r3 = t4 ? 16893 : 33204), (65535 & r3) << 16;
            }(h3.unixPermissions, w)) : (C2 = 20, z2 |= function(e3) {
              return 63 & (e3 || 0);
            }(h3.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c2, b += "up" + A(v.length, 2) + v), g && (y2 = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y2.length, 2) + y2);
            var E = "";
            return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C2, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z2, 4) + A(n2, 4) + f + b + p };
          }
          var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
          function s(e2, t3, r2, n2) {
            i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t3, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
          }
          I.inherits(s, i), s.prototype.push = function(e2) {
            var t3 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
            this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t3 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
          }, s.prototype.openedSource = function(e2) {
            this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
            var t3 = this.streamFiles && !e2.file.dir;
            if (t3) {
              var r2 = n(e2, t3, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
              this.push({ data: r2.fileRecord, meta: { percent: 0 } });
            } else
              this.accumulate = true;
          }, s.prototype.closedSource = function(e2) {
            this.accumulate = false;
            var t3 = this.streamFiles && !e2.file.dir, r2 = n(e2, t3, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            if (this.dirRecords.push(r2.dirRecord), t3)
              this.push({ data: function(e3) {
                return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
              }(e2), meta: { percent: 100 } });
            else
              for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
                this.push(this.contentBuffer.shift());
            this.currentFile = null;
          }, s.prototype.flush = function() {
            for (var e2 = this.bytesWritten, t3 = 0; t3 < this.dirRecords.length; t3++)
              this.push({ data: this.dirRecords[t3], meta: { percent: 100 } });
            var r2 = this.bytesWritten - e2, n2 = function(e3, t4, r3, n3, i2) {
              var s2 = I.transformTo("string", i2(n3));
              return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t4, 4) + A(r3, 4) + A(s2.length, 2) + s2;
            }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
            this.push({ data: n2, meta: { percent: 100 } });
          }, s.prototype.prepareNextSource = function() {
            this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
          }, s.prototype.registerPrevious = function(e2) {
            this._sources.push(e2);
            var t3 = this;
            return e2.on("data", function(e3) {
              t3.processChunk(e3);
            }), e2.on("end", function() {
              t3.closedSource(t3.previous.streamInfo), t3._sources.length ? t3.prepareNextSource() : t3.end();
            }), e2.on("error", function(e3) {
              t3.error(e3);
            }), this;
          }, s.prototype.resume = function() {
            return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
          }, s.prototype.error = function(e2) {
            var t3 = this._sources;
            if (!i.prototype.error.call(this, e2))
              return false;
            for (var r2 = 0; r2 < t3.length; r2++)
              try {
                t3[r2].error(e2);
              } catch (e3) {
              }
            return true;
          }, s.prototype.lock = function() {
            i.prototype.lock.call(this);
            for (var e2 = this._sources, t3 = 0; t3 < e2.length; t3++)
              e2[t3].lock();
          }, t2.exports = s;
        }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t2, r) {
          "use strict";
          var u = e("../compressions"), n = e("./ZipFileWorker");
          r.generateWorker = function(e2, a, t3) {
            var o = new n(a.streamFiles, t3, a.platform, a.encodeFileName), h3 = 0;
            try {
              e2.forEach(function(e3, t4) {
                h3++;
                var r2 = function(e4, t5) {
                  var r3 = e4 || t5, n3 = u[r3];
                  if (!n3)
                    throw new Error(r3 + " is not a valid compression method !");
                  return n3;
                }(t4.options.compression, a.compression), n2 = t4.options.compressionOptions || a.compressionOptions || {}, i = t4.dir, s = t4.date;
                t4._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t4.comment || "", unixPermissions: t4.unixPermissions, dosPermissions: t4.dosPermissions }).pipe(o);
              }), o.entriesCount = h3;
            } catch (e3) {
              o.error(e3);
            }
            return o;
          };
        }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t2, r) {
          "use strict";
          function n() {
            if (!(this instanceof n))
              return new n();
            if (arguments.length)
              throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
            this.files = Object.create(null), this.comment = null, this.root = "", this.clone = function() {
              var e2 = new n();
              for (var t3 in this)
                typeof this[t3] != "function" && (e2[t3] = this[t3]);
              return e2;
            };
          }
          (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t3) {
            return new n().loadAsync(e2, t3);
          }, n.external = e("./external"), t2.exports = n;
        }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t2, r) {
          "use strict";
          var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
          function f(n2) {
            return new i.Promise(function(e2, t3) {
              var r2 = n2.decompressed.getContentWorker().pipe(new a());
              r2.on("error", function(e3) {
                t3(e3);
              }).on("end", function() {
                r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t3(new Error("Corrupted zip : CRC32 mismatch")) : e2();
              }).resume();
            });
          }
          t2.exports = function(e2, o) {
            var h3 = this;
            return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
              var t3 = new s(o);
              return t3.load(e3), t3;
            }).then(function(e3) {
              var t3 = [i.Promise.resolve(e3)], r2 = e3.files;
              if (o.checkCRC32)
                for (var n2 = 0; n2 < r2.length; n2++)
                  t3.push(f(r2[n2]));
              return i.Promise.all(t3);
            }).then(function(e3) {
              for (var t3 = e3.shift(), r2 = t3.files, n2 = 0; n2 < r2.length; n2++) {
                var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
                h3.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h3.file(a2).unsafeOriginalName = s2);
              }
              return t3.zipComment.length && (h3.comment = t3.zipComment), h3;
            });
          };
        }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t2, r) {
          "use strict";
          var n = e("../utils"), i = e("../stream/GenericWorker");
          function s(e2, t3) {
            i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t3);
          }
          n.inherits(s, i), s.prototype._bindStream = function(e2) {
            var t3 = this;
            (this._stream = e2).pause(), e2.on("data", function(e3) {
              t3.push({ data: e3, meta: { percent: 0 } });
            }).on("error", function(e3) {
              t3.isPaused ? this.generatedError = e3 : t3.error(e3);
            }).on("end", function() {
              t3.isPaused ? t3._upstreamEnded = true : t3.end();
            });
          }, s.prototype.pause = function() {
            return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
          }, s.prototype.resume = function() {
            return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
          }, t2.exports = s;
        }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t2, r) {
          "use strict";
          var i = e("readable-stream").Readable;
          function n(e2, t3, r2) {
            i.call(this, t3), this._helper = e2;
            var n2 = this;
            e2.on("data", function(e3, t4) {
              n2.push(e3) || n2._helper.pause(), r2 && r2(t4);
            }).on("error", function(e3) {
              n2.emit("error", e3);
            }).on("end", function() {
              n2.push(null);
            });
          }
          e("../utils").inherits(n, i), n.prototype._read = function() {
            this._helper.resume();
          }, t2.exports = n;
        }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t2, r) {
          "use strict";
          t2.exports = { isNode: typeof Buffer != "undefined", newBufferFrom: function(e2, t3) {
            if (Buffer.from && Buffer.from !== Uint8Array.from)
              return Buffer.from(e2, t3);
            if (typeof e2 == "number")
              throw new Error('The "data" argument must not be a number');
            return new Buffer(e2, t3);
          }, allocBuffer: function(e2) {
            if (Buffer.alloc)
              return Buffer.alloc(e2);
            var t3 = new Buffer(e2);
            return t3.fill(0), t3;
          }, isBuffer: function(e2) {
            return Buffer.isBuffer(e2);
          }, isStream: function(e2) {
            return e2 && typeof e2.on == "function" && typeof e2.pause == "function" && typeof e2.resume == "function";
          } };
        }, {}], 15: [function(e, t2, r) {
          "use strict";
          function s(e2, t3, r2) {
            var n2, i2 = u.getTypeOf(t3), s2 = u.extend(r2 || {}, f);
            s2.date = s2.date || new Date(), s2.compression !== null && (s2.compression = s2.compression.toUpperCase()), typeof s2.unixPermissions == "string" && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
            var a2 = i2 === "string" && s2.binary === false && s2.base64 === false;
            r2 && r2.binary !== void 0 || (s2.binary = !a2), (t3 instanceof c2 && t3.uncompressedSize === 0 || s2.dir || !t3 || t3.length === 0) && (s2.base64 = false, s2.binary = true, t3 = "", s2.compression = "STORE", i2 = "string");
            var o2 = null;
            o2 = t3 instanceof c2 || t3 instanceof l ? t3 : p.isNode && p.isStream(t3) ? new m(e2, t3) : u.prepareContent(e2, t3, s2.binary, s2.optimizedBinaryString, s2.base64);
            var h4 = new d2(e2, o2, s2);
            this.files[e2] = h4;
          }
          var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c2 = e("./compressedObject"), d2 = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
            e2.slice(-1) === "/" && (e2 = e2.substring(0, e2.length - 1));
            var t3 = e2.lastIndexOf("/");
            return 0 < t3 ? e2.substring(0, t3) : "";
          }, g = function(e2) {
            return e2.slice(-1) !== "/" && (e2 += "/"), e2;
          }, b = function(e2, t3) {
            return t3 = t3 !== void 0 ? t3 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t3 }), this.files[e2];
          };
          function h3(e2) {
            return Object.prototype.toString.call(e2) === "[object RegExp]";
          }
          var n = { load: function() {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          }, forEach: function(e2) {
            var t3, r2, n2;
            for (t3 in this.files)
              n2 = this.files[t3], (r2 = t3.slice(this.root.length, t3.length)) && t3.slice(0, this.root.length) === this.root && e2(r2, n2);
          }, filter: function(r2) {
            var n2 = [];
            return this.forEach(function(e2, t3) {
              r2(e2, t3) && n2.push(t3);
            }), n2;
          }, file: function(e2, t3, r2) {
            if (arguments.length !== 1)
              return e2 = this.root + e2, s.call(this, e2, t3, r2), this;
            if (h3(e2)) {
              var n2 = e2;
              return this.filter(function(e3, t4) {
                return !t4.dir && n2.test(e3);
              });
            }
            var i2 = this.files[this.root + e2];
            return i2 && !i2.dir ? i2 : null;
          }, folder: function(r2) {
            if (!r2)
              return this;
            if (h3(r2))
              return this.filter(function(e3, t4) {
                return t4.dir && r2.test(e3);
              });
            var e2 = this.root + r2, t3 = b.call(this, e2), n2 = this.clone();
            return n2.root = t3.name, n2;
          }, remove: function(r2) {
            r2 = this.root + r2;
            var e2 = this.files[r2];
            if (e2 || (r2.slice(-1) !== "/" && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
              delete this.files[r2];
            else
              for (var t3 = this.filter(function(e3, t4) {
                return t4.name.slice(0, r2.length) === r2;
              }), n2 = 0; n2 < t3.length; n2++)
                delete this.files[t3[n2].name];
            return this;
          }, generate: function() {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          }, generateInternalStream: function(e2) {
            var t3, r2 = {};
            try {
              if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), r2.type === "binarystring" && (r2.type = "string"), !r2.type)
                throw new Error("No output type specified.");
              u.checkSupport(r2.type), r2.platform !== "darwin" && r2.platform !== "freebsd" && r2.platform !== "linux" && r2.platform !== "sunos" || (r2.platform = "UNIX"), r2.platform === "win32" && (r2.platform = "DOS");
              var n2 = r2.comment || this.comment || "";
              t3 = o.generateWorker(this, r2, n2);
            } catch (e3) {
              (t3 = new l("error")).error(e3);
            }
            return new a(t3, r2.type || "string", r2.mimeType);
          }, generateAsync: function(e2, t3) {
            return this.generateInternalStream(e2).accumulate(t3);
          }, generateNodeStream: function(e2, t3) {
            return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t3);
          } };
          t2.exports = n;
        }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t2, r) {
          "use strict";
          t2.exports = e("stream");
        }, { stream: void 0 }], 17: [function(e, t2, r) {
          "use strict";
          var n = e("./DataReader");
          function i(e2) {
            n.call(this, e2);
            for (var t3 = 0; t3 < this.data.length; t3++)
              e2[t3] = 255 & e2[t3];
          }
          e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
            return this.data[this.zero + e2];
          }, i.prototype.lastIndexOfSignature = function(e2) {
            for (var t3 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
              if (this.data[s] === t3 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
                return s - this.zero;
            return -1;
          }, i.prototype.readAndCheckSignature = function(e2) {
            var t3 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
            return t3 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
          }, i.prototype.readData = function(e2) {
            if (this.checkOffset(e2), e2 === 0)
              return [];
            var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
            return this.index += e2, t3;
          }, t2.exports = i;
        }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t2, r) {
          "use strict";
          var n = e("../utils");
          function i(e2) {
            this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
          }
          i.prototype = { checkOffset: function(e2) {
            this.checkIndex(this.index + e2);
          }, checkIndex: function(e2) {
            if (this.length < this.zero + e2 || e2 < 0)
              throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
          }, setIndex: function(e2) {
            this.checkIndex(e2), this.index = e2;
          }, skip: function(e2) {
            this.setIndex(this.index + e2);
          }, byteAt: function() {
          }, readInt: function(e2) {
            var t3, r2 = 0;
            for (this.checkOffset(e2), t3 = this.index + e2 - 1; t3 >= this.index; t3--)
              r2 = (r2 << 8) + this.byteAt(t3);
            return this.index += e2, r2;
          }, readString: function(e2) {
            return n.transformTo("string", this.readData(e2));
          }, readData: function() {
          }, lastIndexOfSignature: function() {
          }, readAndCheckSignature: function() {
          }, readDate: function() {
            var e2 = this.readInt(4);
            return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
          } }, t2.exports = i;
        }, { "../utils": 32 }], 19: [function(e, t2, r) {
          "use strict";
          var n = e("./Uint8ArrayReader");
          function i(e2) {
            n.call(this, e2);
          }
          e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
            this.checkOffset(e2);
            var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
            return this.index += e2, t3;
          }, t2.exports = i;
        }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t2, r) {
          "use strict";
          var n = e("./DataReader");
          function i(e2) {
            n.call(this, e2);
          }
          e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
            return this.data.charCodeAt(this.zero + e2);
          }, i.prototype.lastIndexOfSignature = function(e2) {
            return this.data.lastIndexOf(e2) - this.zero;
          }, i.prototype.readAndCheckSignature = function(e2) {
            return e2 === this.readData(4);
          }, i.prototype.readData = function(e2) {
            this.checkOffset(e2);
            var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
            return this.index += e2, t3;
          }, t2.exports = i;
        }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t2, r) {
          "use strict";
          var n = e("./ArrayReader");
          function i(e2) {
            n.call(this, e2);
          }
          e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
            if (this.checkOffset(e2), e2 === 0)
              return new Uint8Array(0);
            var t3 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
            return this.index += e2, t3;
          }, t2.exports = i;
        }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t2, r) {
          "use strict";
          var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h3 = e("./Uint8ArrayReader");
          t2.exports = function(e2) {
            var t3 = n.getTypeOf(e2);
            return n.checkSupport(t3), t3 !== "string" || i.uint8array ? t3 === "nodebuffer" ? new o(e2) : i.uint8array ? new h3(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
          };
        }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t2, r) {
          "use strict";
          r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
        }, {}], 24: [function(e, t2, r) {
          "use strict";
          var n = e("./GenericWorker"), i = e("../utils");
          function s(e2) {
            n.call(this, "ConvertWorker to " + e2), this.destType = e2;
          }
          i.inherits(s, n), s.prototype.processChunk = function(e2) {
            this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
          }, t2.exports = s;
        }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t2, r) {
          "use strict";
          var n = e("./GenericWorker"), i = e("../crc32");
          function s() {
            n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
          }
          e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
            this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
          }, t2.exports = s;
        }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t2, r) {
          "use strict";
          var n = e("../utils"), i = e("./GenericWorker");
          function s(e2) {
            i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
          }
          n.inherits(s, i), s.prototype.processChunk = function(e2) {
            if (e2) {
              var t3 = this.streamInfo[this.propName] || 0;
              this.streamInfo[this.propName] = t3 + e2.data.length;
            }
            i.prototype.processChunk.call(this, e2);
          }, t2.exports = s;
        }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t2, r) {
          "use strict";
          var n = e("../utils"), i = e("./GenericWorker");
          function s(e2) {
            i.call(this, "DataWorker");
            var t3 = this;
            this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
              t3.dataIsReady = true, t3.data = e3, t3.max = e3 && e3.length || 0, t3.type = n.getTypeOf(e3), t3.isPaused || t3._tickAndRepeat();
            }, function(e3) {
              t3.error(e3);
            });
          }
          n.inherits(s, i), s.prototype.cleanUp = function() {
            i.prototype.cleanUp.call(this), this.data = null;
          }, s.prototype.resume = function() {
            return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
          }, s.prototype._tickAndRepeat = function() {
            this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
          }, s.prototype._tick = function() {
            if (this.isPaused || this.isFinished)
              return false;
            var e2 = null, t3 = Math.min(this.max, this.index + 16384);
            if (this.index >= this.max)
              return this.end();
            switch (this.type) {
              case "string":
                e2 = this.data.substring(this.index, t3);
                break;
              case "uint8array":
                e2 = this.data.subarray(this.index, t3);
                break;
              case "array":
              case "nodebuffer":
                e2 = this.data.slice(this.index, t3);
            }
            return this.index = t3, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
          }, t2.exports = s;
        }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t2, r) {
          "use strict";
          function n(e2) {
            this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
          }
          n.prototype = { push: function(e2) {
            this.emit("data", e2);
          }, end: function() {
            if (this.isFinished)
              return false;
            this.flush();
            try {
              this.emit("end"), this.cleanUp(), this.isFinished = true;
            } catch (e2) {
              this.emit("error", e2);
            }
            return true;
          }, error: function(e2) {
            return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
          }, on: function(e2, t3) {
            return this._listeners[e2].push(t3), this;
          }, cleanUp: function() {
            this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
          }, emit: function(e2, t3) {
            if (this._listeners[e2])
              for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
                this._listeners[e2][r2].call(this, t3);
          }, pipe: function(e2) {
            return e2.registerPrevious(this);
          }, registerPrevious: function(e2) {
            if (this.isLocked)
              throw new Error("The stream '" + this + "' has already been used.");
            this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
            var t3 = this;
            return e2.on("data", function(e3) {
              t3.processChunk(e3);
            }), e2.on("end", function() {
              t3.end();
            }), e2.on("error", function(e3) {
              t3.error(e3);
            }), this;
          }, pause: function() {
            return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
          }, resume: function() {
            if (!this.isPaused || this.isFinished)
              return false;
            var e2 = this.isPaused = false;
            return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
          }, flush: function() {
          }, processChunk: function(e2) {
            this.push(e2);
          }, withStreamInfo: function(e2, t3) {
            return this.extraStreamInfo[e2] = t3, this.mergeStreamInfo(), this;
          }, mergeStreamInfo: function() {
            for (var e2 in this.extraStreamInfo)
              Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
          }, lock: function() {
            if (this.isLocked)
              throw new Error("The stream '" + this + "' has already been used.");
            this.isLocked = true, this.previous && this.previous.lock();
          }, toString: function() {
            var e2 = "Worker " + this.name;
            return this.previous ? this.previous + " -> " + e2 : e2;
          } }, t2.exports = n;
        }, {}], 29: [function(e, t2, r) {
          "use strict";
          var h3 = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
          if (n.nodestream)
            try {
              o = e("../nodejs/NodejsStreamOutputAdapter");
            } catch (e2) {
            }
          function l(e2, o2) {
            return new a.Promise(function(t3, r2) {
              var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
              e2.on("data", function(e3, t4) {
                n2.push(e3), o2 && o2(t4);
              }).on("error", function(e3) {
                n2 = [], r2(e3);
              }).on("end", function() {
                try {
                  var e3 = function(e4, t4, r3) {
                    switch (e4) {
                      case "blob":
                        return h3.newBlob(h3.transformTo("arraybuffer", t4), r3);
                      case "base64":
                        return u.encode(t4);
                      default:
                        return h3.transformTo(e4, t4);
                    }
                  }(s2, function(e4, t4) {
                    var r3, n3 = 0, i3 = null, s3 = 0;
                    for (r3 = 0; r3 < t4.length; r3++)
                      s3 += t4[r3].length;
                    switch (e4) {
                      case "string":
                        return t4.join("");
                      case "array":
                        return Array.prototype.concat.apply([], t4);
                      case "uint8array":
                        for (i3 = new Uint8Array(s3), r3 = 0; r3 < t4.length; r3++)
                          i3.set(t4[r3], n3), n3 += t4[r3].length;
                        return i3;
                      case "nodebuffer":
                        return Buffer.concat(t4);
                      default:
                        throw new Error("concat : unsupported type '" + e4 + "'");
                    }
                  }(i2, n2), a2);
                  t3(e3);
                } catch (e4) {
                  r2(e4);
                }
                n2 = [];
              }).resume();
            });
          }
          function f(e2, t3, r2) {
            var n2 = t3;
            switch (t3) {
              case "blob":
              case "arraybuffer":
                n2 = "uint8array";
                break;
              case "base64":
                n2 = "string";
            }
            try {
              this._internalType = n2, this._outputType = t3, this._mimeType = r2, h3.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
            } catch (e3) {
              this._worker = new s("error"), this._worker.error(e3);
            }
          }
          f.prototype = { accumulate: function(e2) {
            return l(this, e2);
          }, on: function(e2, t3) {
            var r2 = this;
            return e2 === "data" ? this._worker.on(e2, function(e3) {
              t3.call(r2, e3.data, e3.meta);
            }) : this._worker.on(e2, function() {
              h3.delay(t3, arguments, r2);
            }), this;
          }, resume: function() {
            return h3.delay(this._worker.resume, [], this._worker), this;
          }, pause: function() {
            return this._worker.pause(), this;
          }, toNodejsStream: function(e2) {
            if (h3.checkSupport("nodestream"), this._outputType !== "nodebuffer")
              throw new Error(this._outputType + " is not supported by this method");
            return new o(this, { objectMode: this._outputType !== "nodebuffer" }, e2);
          } }, t2.exports = f;
        }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t2, r) {
          "use strict";
          if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = typeof ArrayBuffer != "undefined" && typeof Uint8Array != "undefined", r.nodebuffer = typeof Buffer != "undefined", r.uint8array = typeof Uint8Array != "undefined", typeof ArrayBuffer == "undefined")
            r.blob = false;
          else {
            var n = new ArrayBuffer(0);
            try {
              r.blob = new Blob([n], { type: "application/zip" }).size === 0;
            } catch (e2) {
              try {
                var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                i.append(n), r.blob = i.getBlob("application/zip").size === 0;
              } catch (e3) {
                r.blob = false;
              }
            }
          }
          try {
            r.nodestream = !!e("readable-stream").Readable;
          } catch (e2) {
            r.nodestream = false;
          }
        }, { "readable-stream": 16 }], 31: [function(e, t2, s) {
          "use strict";
          for (var o = e("./utils"), h3 = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
            u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
          u[254] = u[254] = 1;
          function a() {
            n.call(this, "utf-8 decode"), this.leftOver = null;
          }
          function l() {
            n.call(this, "utf-8 encode");
          }
          s.utf8encode = function(e2) {
            return h3.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
              var t3, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
              for (i2 = 0; i2 < a2; i2++)
                (64512 & (r2 = e3.charCodeAt(i2))) == 55296 && i2 + 1 < a2 && (64512 & (n2 = e3.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
              for (t3 = h3.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
                (64512 & (r2 = e3.charCodeAt(i2))) == 55296 && i2 + 1 < a2 && (64512 & (n2 = e3.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t3[s2++] = r2 : (r2 < 2048 ? t3[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t3[s2++] = 224 | r2 >>> 12 : (t3[s2++] = 240 | r2 >>> 18, t3[s2++] = 128 | r2 >>> 12 & 63), t3[s2++] = 128 | r2 >>> 6 & 63), t3[s2++] = 128 | 63 & r2);
              return t3;
            }(e2);
          }, s.utf8decode = function(e2) {
            return h3.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
              var t3, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
              for (t3 = r2 = 0; t3 < s2; )
                if ((n2 = e3[t3++]) < 128)
                  a2[r2++] = n2;
                else if (4 < (i2 = u[n2]))
                  a2[r2++] = 65533, t3 += i2 - 1;
                else {
                  for (n2 &= i2 === 2 ? 31 : i2 === 3 ? 15 : 7; 1 < i2 && t3 < s2; )
                    n2 = n2 << 6 | 63 & e3[t3++], i2--;
                  1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
                }
              return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
            }(e2 = o.transformTo(h3.uint8array ? "uint8array" : "array", e2));
          }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
            var t3 = o.transformTo(h3.uint8array ? "uint8array" : "array", e2.data);
            if (this.leftOver && this.leftOver.length) {
              if (h3.uint8array) {
                var r2 = t3;
                (t3 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t3.set(r2, this.leftOver.length);
              } else
                t3 = this.leftOver.concat(t3);
              this.leftOver = null;
            }
            var n2 = function(e3, t4) {
              var r3;
              for ((t4 = t4 || e3.length) > e3.length && (t4 = e3.length), r3 = t4 - 1; 0 <= r3 && (192 & e3[r3]) == 128; )
                r3--;
              return r3 < 0 ? t4 : r3 === 0 ? t4 : r3 + u[e3[r3]] > t4 ? r3 : t4;
            }(t3), i2 = t3;
            n2 !== t3.length && (h3.uint8array ? (i2 = t3.subarray(0, n2), this.leftOver = t3.subarray(n2, t3.length)) : (i2 = t3.slice(0, n2), this.leftOver = t3.slice(n2, t3.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
          }, a.prototype.flush = function() {
            this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
          }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
            this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
          }, s.Utf8EncodeWorker = l;
        }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t2, a) {
          "use strict";
          var o = e("./support"), h3 = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
          function n(e2) {
            return e2;
          }
          function l(e2, t3) {
            for (var r2 = 0; r2 < e2.length; ++r2)
              t3[r2] = 255 & e2.charCodeAt(r2);
            return t3;
          }
          e("setimmediate"), a.newBlob = function(t3, r2) {
            a.checkSupport("blob");
            try {
              return new Blob([t3], { type: r2 });
            } catch (e2) {
              try {
                var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                return n2.append(t3), n2.getBlob(r2);
              } catch (e3) {
                throw new Error("Bug : can't construct the Blob.");
              }
            }
          };
          var i = { stringifyByChunk: function(e2, t3, r2) {
            var n2 = [], i2 = 0, s2 = e2.length;
            if (s2 <= r2)
              return String.fromCharCode.apply(null, e2);
            for (; i2 < s2; )
              t3 === "array" || t3 === "nodebuffer" ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
            return n2.join("");
          }, stringifyByChar: function(e2) {
            for (var t3 = "", r2 = 0; r2 < e2.length; r2++)
              t3 += String.fromCharCode(e2[r2]);
            return t3;
          }, applyCanBeUsed: { uint8array: function() {
            try {
              return o.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch (e2) {
              return false;
            }
          }(), nodebuffer: function() {
            try {
              return o.nodebuffer && String.fromCharCode.apply(null, r.allocBuffer(1)).length === 1;
            } catch (e2) {
              return false;
            }
          }() } };
          function s(e2) {
            var t3 = 65536, r2 = a.getTypeOf(e2), n2 = true;
            if (r2 === "uint8array" ? n2 = i.applyCanBeUsed.uint8array : r2 === "nodebuffer" && (n2 = i.applyCanBeUsed.nodebuffer), n2)
              for (; 1 < t3; )
                try {
                  return i.stringifyByChunk(e2, r2, t3);
                } catch (e3) {
                  t3 = Math.floor(t3 / 2);
                }
            return i.stringifyByChar(e2);
          }
          function f(e2, t3) {
            for (var r2 = 0; r2 < e2.length; r2++)
              t3[r2] = e2[r2];
            return t3;
          }
          a.applyFromCharCode = s;
          var c2 = {};
          c2.string = { string: n, array: function(e2) {
            return l(e2, new Array(e2.length));
          }, arraybuffer: function(e2) {
            return c2.string.uint8array(e2).buffer;
          }, uint8array: function(e2) {
            return l(e2, new Uint8Array(e2.length));
          }, nodebuffer: function(e2) {
            return l(e2, r.allocBuffer(e2.length));
          } }, c2.array = { string: s, array: n, arraybuffer: function(e2) {
            return new Uint8Array(e2).buffer;
          }, uint8array: function(e2) {
            return new Uint8Array(e2);
          }, nodebuffer: function(e2) {
            return r.newBufferFrom(e2);
          } }, c2.arraybuffer = { string: function(e2) {
            return s(new Uint8Array(e2));
          }, array: function(e2) {
            return f(new Uint8Array(e2), new Array(e2.byteLength));
          }, arraybuffer: n, uint8array: function(e2) {
            return new Uint8Array(e2);
          }, nodebuffer: function(e2) {
            return r.newBufferFrom(new Uint8Array(e2));
          } }, c2.uint8array = { string: s, array: function(e2) {
            return f(e2, new Array(e2.length));
          }, arraybuffer: function(e2) {
            return e2.buffer;
          }, uint8array: n, nodebuffer: function(e2) {
            return r.newBufferFrom(e2);
          } }, c2.nodebuffer = { string: s, array: function(e2) {
            return f(e2, new Array(e2.length));
          }, arraybuffer: function(e2) {
            return c2.nodebuffer.uint8array(e2).buffer;
          }, uint8array: function(e2) {
            return f(e2, new Uint8Array(e2.length));
          }, nodebuffer: n }, a.transformTo = function(e2, t3) {
            if (t3 = t3 || "", !e2)
              return t3;
            a.checkSupport(e2);
            var r2 = a.getTypeOf(t3);
            return c2[r2][e2](t3);
          }, a.resolve = function(e2) {
            for (var t3 = e2.split("/"), r2 = [], n2 = 0; n2 < t3.length; n2++) {
              var i2 = t3[n2];
              i2 === "." || i2 === "" && n2 !== 0 && n2 !== t3.length - 1 || (i2 === ".." ? r2.pop() : r2.push(i2));
            }
            return r2.join("/");
          }, a.getTypeOf = function(e2) {
            return typeof e2 == "string" ? "string" : Object.prototype.toString.call(e2) === "[object Array]" ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
          }, a.checkSupport = function(e2) {
            if (!o[e2.toLowerCase()])
              throw new Error(e2 + " is not supported by this platform");
          }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
            var t3, r2, n2 = "";
            for (r2 = 0; r2 < (e2 || "").length; r2++)
              n2 += "\\x" + ((t3 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t3.toString(16).toUpperCase();
            return n2;
          }, a.delay = function(e2, t3, r2) {
            setImmediate(function() {
              e2.apply(r2 || null, t3 || []);
            });
          }, a.inherits = function(e2, t3) {
            function r2() {
            }
            r2.prototype = t3.prototype, e2.prototype = new r2();
          }, a.extend = function() {
            var e2, t3, r2 = {};
            for (e2 = 0; e2 < arguments.length; e2++)
              for (t3 in arguments[e2])
                Object.prototype.hasOwnProperty.call(arguments[e2], t3) && r2[t3] === void 0 && (r2[t3] = arguments[e2][t3]);
            return r2;
          }, a.prepareContent = function(r2, e2, n2, i2, s2) {
            return u.Promise.resolve(e2).then(function(n3) {
              return o.blob && (n3 instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3)) !== -1) && typeof FileReader != "undefined" ? new u.Promise(function(t3, r3) {
                var e3 = new FileReader();
                e3.onload = function(e4) {
                  t3(e4.target.result);
                }, e3.onerror = function(e4) {
                  r3(e4.target.error);
                }, e3.readAsArrayBuffer(n3);
              }) : n3;
            }).then(function(e3) {
              var t3 = a.getTypeOf(e3);
              return t3 ? (t3 === "arraybuffer" ? e3 = a.transformTo("uint8array", e3) : t3 === "string" && (s2 ? e3 = h3.decode(e3) : n2 && i2 !== true && (e3 = function(e4) {
                return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
              }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
            });
          };
        }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t2, r) {
          "use strict";
          var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
          function h3(e2) {
            this.files = [], this.loadOptions = e2;
          }
          h3.prototype = { checkSignature: function(e2) {
            if (!this.reader.readAndCheckSignature(e2)) {
              this.reader.index -= 4;
              var t3 = this.reader.readString(4);
              throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t3) + ", expected " + i.pretty(e2) + ")");
            }
          }, isSignature: function(e2, t3) {
            var r2 = this.reader.index;
            this.reader.setIndex(e2);
            var n2 = this.reader.readString(4) === t3;
            return this.reader.setIndex(r2), n2;
          }, readBlockEndOfCentral: function() {
            this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
            var e2 = this.reader.readData(this.zipCommentLength), t3 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t3, e2);
            this.zipComment = this.loadOptions.decodeFileName(r2);
          }, readBlockZip64EndOfCentral: function() {
            this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
            for (var e2, t3, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
              e2 = this.reader.readInt(2), t3 = this.reader.readInt(4), r2 = this.reader.readData(t3), this.zip64ExtensibleData[e2] = { id: e2, length: t3, value: r2 };
          }, readBlockZip64EndOfCentralLocator: function() {
            if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
              throw new Error("Multi-volumes zip are not supported");
          }, readLocalFiles: function() {
            var e2, t3;
            for (e2 = 0; e2 < this.files.length; e2++)
              t3 = this.files[e2], this.reader.setIndex(t3.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t3.readLocalPart(this.reader), t3.handleUTF8(), t3.processAttributes();
          }, readCentralDir: function() {
            var e2;
            for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
              (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
            if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
              throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
          }, readEndOfCentral: function() {
            var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
            if (e2 < 0)
              throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
            this.reader.setIndex(e2);
            var t3 = e2;
            if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
              if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
              if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
              this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
            }
            var r2 = this.centralDirOffset + this.centralDirSize;
            this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
            var n2 = t3 - r2;
            if (0 < n2)
              this.isSignature(t3, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
            else if (n2 < 0)
              throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
          }, prepareReader: function(e2) {
            this.reader = n(e2);
          }, load: function(e2) {
            this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
          } }, t2.exports = h3;
        }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t2, r) {
          "use strict";
          var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h3 = e("./compressions"), u = e("./support");
          function l(e2, t3) {
            this.options = e2, this.loadOptions = t3;
          }
          l.prototype = { isEncrypted: function() {
            return (1 & this.bitFlag) == 1;
          }, useUTF8: function() {
            return (2048 & this.bitFlag) == 2048;
          }, readLocalPart: function(e2) {
            var t3, r2;
            if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), this.compressedSize === -1 || this.uncompressedSize === -1)
              throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
            if ((t3 = function(e3) {
              for (var t4 in h3)
                if (Object.prototype.hasOwnProperty.call(h3, t4) && h3[t4].magic === e3)
                  return h3[t4];
              return null;
            }(this.compressionMethod)) === null)
              throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
            this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t3, e2.readData(this.compressedSize));
          }, readCentralPart: function(e2) {
            this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
            var t3 = e2.readInt(2);
            if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
              throw new Error("Encrypted zip are not supported");
            e2.skip(t3), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
          }, processAttributes: function() {
            this.unixPermissions = null, this.dosPermissions = null;
            var e2 = this.versionMadeBy >> 8;
            this.dir = !!(16 & this.externalFileAttributes), e2 == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), e2 == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = true);
          }, parseZIP64ExtraField: function() {
            if (this.extraFields[1]) {
              var e2 = n(this.extraFields[1].value);
              this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
            }
          }, readExtraFields: function(e2) {
            var t3, r2, n2, i2 = e2.index + this.extraFieldsLength;
            for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
              t3 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t3] = { id: t3, length: r2, value: n2 };
            e2.setIndex(i2);
          }, handleUTF8: function() {
            var e2 = u.uint8array ? "uint8array" : "array";
            if (this.useUTF8())
              this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
            else {
              var t3 = this.findExtraFieldUnicodePath();
              if (t3 !== null)
                this.fileNameStr = t3;
              else {
                var r2 = s.transformTo(e2, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(r2);
              }
              var n2 = this.findExtraFieldUnicodeComment();
              if (n2 !== null)
                this.fileCommentStr = n2;
              else {
                var i2 = s.transformTo(e2, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(i2);
              }
            }
          }, findExtraFieldUnicodePath: function() {
            var e2 = this.extraFields[28789];
            if (e2) {
              var t3 = n(e2.value);
              return t3.readInt(1) !== 1 ? null : a(this.fileName) !== t3.readInt(4) ? null : o.utf8decode(t3.readData(e2.length - 5));
            }
            return null;
          }, findExtraFieldUnicodeComment: function() {
            var e2 = this.extraFields[25461];
            if (e2) {
              var t3 = n(e2.value);
              return t3.readInt(1) !== 1 ? null : a(this.fileComment) !== t3.readInt(4) ? null : o.utf8decode(t3.readData(e2.length - 5));
            }
            return null;
          } }, t2.exports = l;
        }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t2, r) {
          "use strict";
          function n(e2, t3, r2) {
            this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t3, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
          }
          var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h3 = e("./stream/GenericWorker");
          n.prototype = { internalStream: function(e2) {
            var t3 = null, r2 = "string";
            try {
              if (!e2)
                throw new Error("No output type specified.");
              var n2 = (r2 = e2.toLowerCase()) === "string" || r2 === "text";
              r2 !== "binarystring" && r2 !== "text" || (r2 = "string"), t3 = this._decompressWorker();
              var i2 = !this._dataBinary;
              i2 && !n2 && (t3 = t3.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t3 = t3.pipe(new a.Utf8DecodeWorker()));
            } catch (e3) {
              (t3 = new h3("error")).error(e3);
            }
            return new s(t3, r2, "");
          }, async: function(e2, t3) {
            return this.internalStream(e2).accumulate(t3);
          }, nodeStream: function(e2, t3) {
            return this.internalStream(e2 || "nodebuffer").toNodejsStream(t3);
          }, _compressWorker: function(e2, t3) {
            if (this._data instanceof o && this._data.compression.magic === e2.magic)
              return this._data.getCompressedWorker();
            var r2 = this._decompressWorker();
            return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t3);
          }, _decompressWorker: function() {
            return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h3 ? this._data : new i(this._data);
          } };
          for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          }, f = 0; f < u.length; f++)
            n.prototype[u[f]] = l;
          t2.exports = n;
        }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t2) {
          (function(t3) {
            "use strict";
            var r, n, e2 = t3.MutationObserver || t3.WebKitMutationObserver;
            if (e2) {
              var i = 0, s = new e2(u), a = t3.document.createTextNode("");
              s.observe(a, { characterData: true }), r = function() {
                a.data = i = ++i % 2;
              };
            } else if (t3.setImmediate || t3.MessageChannel === void 0)
              r = "document" in t3 && "onreadystatechange" in t3.document.createElement("script") ? function() {
                var e3 = t3.document.createElement("script");
                e3.onreadystatechange = function() {
                  u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
                }, t3.document.documentElement.appendChild(e3);
              } : function() {
                setTimeout(u, 0);
              };
            else {
              var o = new t3.MessageChannel();
              o.port1.onmessage = u, r = function() {
                o.port2.postMessage(0);
              };
            }
            var h3 = [];
            function u() {
              var e3, t4;
              n = true;
              for (var r2 = h3.length; r2; ) {
                for (t4 = h3, h3 = [], e3 = -1; ++e3 < r2; )
                  t4[e3]();
                r2 = h3.length;
              }
              n = false;
            }
            l.exports = function(e3) {
              h3.push(e3) !== 1 || n || r();
            };
          }).call(this, typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
        }, {}], 37: [function(e, t2, r) {
          "use strict";
          var i = e("immediate");
          function u() {
          }
          var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
          function o(e2) {
            if (typeof e2 != "function")
              throw new TypeError("resolver must be a function");
            this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d2(this, e2);
          }
          function h3(e2, t3, r2) {
            this.promise = e2, typeof t3 == "function" && (this.onFulfilled = t3, this.callFulfilled = this.otherCallFulfilled), typeof r2 == "function" && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
          }
          function f(t3, r2, n2) {
            i(function() {
              var e2;
              try {
                e2 = r2(n2);
              } catch (e3) {
                return l.reject(t3, e3);
              }
              e2 === t3 ? l.reject(t3, new TypeError("Cannot resolve promise with itself")) : l.resolve(t3, e2);
            });
          }
          function c2(e2) {
            var t3 = e2 && e2.then;
            if (e2 && (typeof e2 == "object" || typeof e2 == "function") && typeof t3 == "function")
              return function() {
                t3.apply(e2, arguments);
              };
          }
          function d2(t3, e2) {
            var r2 = false;
            function n2(e3) {
              r2 || (r2 = true, l.reject(t3, e3));
            }
            function i2(e3) {
              r2 || (r2 = true, l.resolve(t3, e3));
            }
            var s2 = p(function() {
              e2(i2, n2);
            });
            s2.status === "error" && n2(s2.value);
          }
          function p(e2, t3) {
            var r2 = {};
            try {
              r2.value = e2(t3), r2.status = "success";
            } catch (e3) {
              r2.status = "error", r2.value = e3;
            }
            return r2;
          }
          (t2.exports = o).prototype.finally = function(t3) {
            if (typeof t3 != "function")
              return this;
            var r2 = this.constructor;
            return this.then(function(e2) {
              return r2.resolve(t3()).then(function() {
                return e2;
              });
            }, function(e2) {
              return r2.resolve(t3()).then(function() {
                throw e2;
              });
            });
          }, o.prototype.catch = function(e2) {
            return this.then(null, e2);
          }, o.prototype.then = function(e2, t3) {
            if (typeof e2 != "function" && this.state === a || typeof t3 != "function" && this.state === s)
              return this;
            var r2 = new this.constructor(u);
            this.state !== n ? f(r2, this.state === a ? e2 : t3, this.outcome) : this.queue.push(new h3(r2, e2, t3));
            return r2;
          }, h3.prototype.callFulfilled = function(e2) {
            l.resolve(this.promise, e2);
          }, h3.prototype.otherCallFulfilled = function(e2) {
            f(this.promise, this.onFulfilled, e2);
          }, h3.prototype.callRejected = function(e2) {
            l.reject(this.promise, e2);
          }, h3.prototype.otherCallRejected = function(e2) {
            f(this.promise, this.onRejected, e2);
          }, l.resolve = function(e2, t3) {
            var r2 = p(c2, t3);
            if (r2.status === "error")
              return l.reject(e2, r2.value);
            var n2 = r2.value;
            if (n2)
              d2(e2, n2);
            else {
              e2.state = a, e2.outcome = t3;
              for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
                e2.queue[i2].callFulfilled(t3);
            }
            return e2;
          }, l.reject = function(e2, t3) {
            e2.state = s, e2.outcome = t3;
            for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; )
              e2.queue[r2].callRejected(t3);
            return e2;
          }, o.resolve = function(e2) {
            if (e2 instanceof this)
              return e2;
            return l.resolve(new this(u), e2);
          }, o.reject = function(e2) {
            var t3 = new this(u);
            return l.reject(t3, e2);
          }, o.all = function(e2) {
            var r2 = this;
            if (Object.prototype.toString.call(e2) !== "[object Array]")
              return this.reject(new TypeError("must be an array"));
            var n2 = e2.length, i2 = false;
            if (!n2)
              return this.resolve([]);
            var s2 = new Array(n2), a2 = 0, t3 = -1, o2 = new this(u);
            for (; ++t3 < n2; )
              h4(e2[t3], t3);
            return o2;
            function h4(e3, t4) {
              r2.resolve(e3).then(function(e4) {
                s2[t4] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
              }, function(e4) {
                i2 || (i2 = true, l.reject(o2, e4));
              });
            }
          }, o.race = function(e2) {
            var t3 = this;
            if (Object.prototype.toString.call(e2) !== "[object Array]")
              return this.reject(new TypeError("must be an array"));
            var r2 = e2.length, n2 = false;
            if (!r2)
              return this.resolve([]);
            var i2 = -1, s2 = new this(u);
            for (; ++i2 < r2; )
              a2 = e2[i2], t3.resolve(a2).then(function(e3) {
                n2 || (n2 = true, l.resolve(s2, e3));
              }, function(e3) {
                n2 || (n2 = true, l.reject(s2, e3));
              });
            var a2;
            return s2;
          };
        }, { immediate: 36 }], 38: [function(e, t2, r) {
          "use strict";
          var n = {};
          (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t2.exports = n;
        }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t2, r) {
          "use strict";
          var a = e("./zlib/deflate"), o = e("./utils/common"), h3 = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c2 = 0, d2 = 8;
          function p(e2) {
            if (!(this instanceof p))
              return new p(e2);
            this.options = o.assign({ level: f, method: d2, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c2, to: "" }, e2 || {});
            var t3 = this.options;
            t3.raw && 0 < t3.windowBits ? t3.windowBits = -t3.windowBits : t3.gzip && 0 < t3.windowBits && t3.windowBits < 16 && (t3.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
            var r2 = a.deflateInit2(this.strm, t3.level, t3.method, t3.windowBits, t3.memLevel, t3.strategy);
            if (r2 !== l)
              throw new Error(i[r2]);
            if (t3.header && a.deflateSetHeader(this.strm, t3.header), t3.dictionary) {
              var n2;
              if (n2 = typeof t3.dictionary == "string" ? h3.string2buf(t3.dictionary) : u.call(t3.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(t3.dictionary) : t3.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
                throw new Error(i[r2]);
              this._dict_set = true;
            }
          }
          function n(e2, t3) {
            var r2 = new p(t3);
            if (r2.push(e2, true), r2.err)
              throw r2.msg || i[r2.err];
            return r2.result;
          }
          p.prototype.push = function(e2, t3) {
            var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
            if (this.ended)
              return false;
            n2 = t3 === ~~t3 ? t3 : t3 === true ? 4 : 0, typeof e2 == "string" ? i2.input = h3.string2buf(e2) : u.call(e2) === "[object ArrayBuffer]" ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
            do {
              if (i2.avail_out === 0 && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), (r2 = a.deflate(i2, n2)) !== 1 && r2 !== l)
                return this.onEnd(r2), !(this.ended = true);
              i2.avail_out !== 0 && (i2.avail_in !== 0 || n2 !== 4 && n2 !== 2) || (this.options.to === "string" ? this.onData(h3.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
            } while ((0 < i2.avail_in || i2.avail_out === 0) && r2 !== 1);
            return n2 === 4 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : n2 !== 2 || (this.onEnd(l), !(i2.avail_out = 0));
          }, p.prototype.onData = function(e2) {
            this.chunks.push(e2);
          }, p.prototype.onEnd = function(e2) {
            e2 === l && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
          }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t3) {
            return (t3 = t3 || {}).raw = true, n(e2, t3);
          }, r.gzip = function(e2, t3) {
            return (t3 = t3 || {}).gzip = true, n(e2, t3);
          };
        }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t2, r) {
          "use strict";
          var c2 = e("./zlib/inflate"), d2 = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
          function a(e2) {
            if (!(this instanceof a))
              return new a(e2);
            this.options = d2.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
            var t3 = this.options;
            t3.raw && 0 <= t3.windowBits && t3.windowBits < 16 && (t3.windowBits = -t3.windowBits, t3.windowBits === 0 && (t3.windowBits = -15)), !(0 <= t3.windowBits && t3.windowBits < 16) || e2 && e2.windowBits || (t3.windowBits += 32), 15 < t3.windowBits && t3.windowBits < 48 && (15 & t3.windowBits) == 0 && (t3.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
            var r2 = c2.inflateInit2(this.strm, t3.windowBits);
            if (r2 !== m.Z_OK)
              throw new Error(n[r2]);
            this.header = new s(), c2.inflateGetHeader(this.strm, this.header);
          }
          function o(e2, t3) {
            var r2 = new a(t3);
            if (r2.push(e2, true), r2.err)
              throw r2.msg || n[r2.err];
            return r2.result;
          }
          a.prototype.push = function(e2, t3) {
            var r2, n2, i2, s2, a2, o2, h3 = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
            if (this.ended)
              return false;
            n2 = t3 === ~~t3 ? t3 : t3 === true ? m.Z_FINISH : m.Z_NO_FLUSH, typeof e2 == "string" ? h3.input = p.binstring2buf(e2) : _.call(e2) === "[object ArrayBuffer]" ? h3.input = new Uint8Array(e2) : h3.input = e2, h3.next_in = 0, h3.avail_in = h3.input.length;
            do {
              if (h3.avail_out === 0 && (h3.output = new d2.Buf8(u), h3.next_out = 0, h3.avail_out = u), (r2 = c2.inflate(h3, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = typeof l == "string" ? p.string2buf(l) : _.call(l) === "[object ArrayBuffer]" ? new Uint8Array(l) : l, r2 = c2.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && f === true && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
                return this.onEnd(r2), !(this.ended = true);
              h3.next_out && (h3.avail_out !== 0 && r2 !== m.Z_STREAM_END && (h3.avail_in !== 0 || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || (this.options.to === "string" ? (i2 = p.utf8border(h3.output, h3.next_out), s2 = h3.next_out - i2, a2 = p.buf2string(h3.output, i2), h3.next_out = s2, h3.avail_out = u - s2, s2 && d2.arraySet(h3.output, h3.output, i2, s2, 0), this.onData(a2)) : this.onData(d2.shrinkBuf(h3.output, h3.next_out)))), h3.avail_in === 0 && h3.avail_out === 0 && (f = true);
            } while ((0 < h3.avail_in || h3.avail_out === 0) && r2 !== m.Z_STREAM_END);
            return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c2.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h3.avail_out = 0));
          }, a.prototype.onData = function(e2) {
            this.chunks.push(e2);
          }, a.prototype.onEnd = function(e2) {
            e2 === m.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = d2.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
          }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t3) {
            return (t3 = t3 || {}).raw = true, o(e2, t3);
          }, r.ungzip = o;
        }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t2, r) {
          "use strict";
          var n = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Int32Array != "undefined";
          r.assign = function(e2) {
            for (var t3 = Array.prototype.slice.call(arguments, 1); t3.length; ) {
              var r2 = t3.shift();
              if (r2) {
                if (typeof r2 != "object")
                  throw new TypeError(r2 + "must be non-object");
                for (var n2 in r2)
                  r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
              }
            }
            return e2;
          }, r.shrinkBuf = function(e2, t3) {
            return e2.length === t3 ? e2 : e2.subarray ? e2.subarray(0, t3) : (e2.length = t3, e2);
          };
          var i = { arraySet: function(e2, t3, r2, n2, i2) {
            if (t3.subarray && e2.subarray)
              e2.set(t3.subarray(r2, r2 + n2), i2);
            else
              for (var s2 = 0; s2 < n2; s2++)
                e2[i2 + s2] = t3[r2 + s2];
          }, flattenChunks: function(e2) {
            var t3, r2, n2, i2, s2, a;
            for (t3 = n2 = 0, r2 = e2.length; t3 < r2; t3++)
              n2 += e2[t3].length;
            for (a = new Uint8Array(n2), t3 = i2 = 0, r2 = e2.length; t3 < r2; t3++)
              s2 = e2[t3], a.set(s2, i2), i2 += s2.length;
            return a;
          } }, s = { arraySet: function(e2, t3, r2, n2, i2) {
            for (var s2 = 0; s2 < n2; s2++)
              e2[i2 + s2] = t3[r2 + s2];
          }, flattenChunks: function(e2) {
            return [].concat.apply([], e2);
          } };
          r.setTyped = function(e2) {
            e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
          }, r.setTyped(n);
        }, {}], 42: [function(e, t2, r) {
          "use strict";
          var h3 = e("./common"), i = true, s = true;
          try {
            String.fromCharCode.apply(null, [0]);
          } catch (e2) {
            i = false;
          }
          try {
            String.fromCharCode.apply(null, new Uint8Array(1));
          } catch (e2) {
            s = false;
          }
          for (var u = new h3.Buf8(256), n = 0; n < 256; n++)
            u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
          function l(e2, t3) {
            if (t3 < 65537 && (e2.subarray && s || !e2.subarray && i))
              return String.fromCharCode.apply(null, h3.shrinkBuf(e2, t3));
            for (var r2 = "", n2 = 0; n2 < t3; n2++)
              r2 += String.fromCharCode(e2[n2]);
            return r2;
          }
          u[254] = u[254] = 1, r.string2buf = function(e2) {
            var t3, r2, n2, i2, s2, a = e2.length, o = 0;
            for (i2 = 0; i2 < a; i2++)
              (64512 & (r2 = e2.charCodeAt(i2))) == 55296 && i2 + 1 < a && (64512 & (n2 = e2.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t3 = new h3.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
              (64512 & (r2 = e2.charCodeAt(i2))) == 55296 && i2 + 1 < a && (64512 & (n2 = e2.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t3[s2++] = r2 : (r2 < 2048 ? t3[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t3[s2++] = 224 | r2 >>> 12 : (t3[s2++] = 240 | r2 >>> 18, t3[s2++] = 128 | r2 >>> 12 & 63), t3[s2++] = 128 | r2 >>> 6 & 63), t3[s2++] = 128 | 63 & r2);
            return t3;
          }, r.buf2binstring = function(e2) {
            return l(e2, e2.length);
          }, r.binstring2buf = function(e2) {
            for (var t3 = new h3.Buf8(e2.length), r2 = 0, n2 = t3.length; r2 < n2; r2++)
              t3[r2] = e2.charCodeAt(r2);
            return t3;
          }, r.buf2string = function(e2, t3) {
            var r2, n2, i2, s2, a = t3 || e2.length, o = new Array(2 * a);
            for (r2 = n2 = 0; r2 < a; )
              if ((i2 = e2[r2++]) < 128)
                o[n2++] = i2;
              else if (4 < (s2 = u[i2]))
                o[n2++] = 65533, r2 += s2 - 1;
              else {
                for (i2 &= s2 === 2 ? 31 : s2 === 3 ? 15 : 7; 1 < s2 && r2 < a; )
                  i2 = i2 << 6 | 63 & e2[r2++], s2--;
                1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
              }
            return l(o, n2);
          }, r.utf8border = function(e2, t3) {
            var r2;
            for ((t3 = t3 || e2.length) > e2.length && (t3 = e2.length), r2 = t3 - 1; 0 <= r2 && (192 & e2[r2]) == 128; )
              r2--;
            return r2 < 0 ? t3 : r2 === 0 ? t3 : r2 + u[e2[r2]] > t3 ? r2 : t3;
          };
        }, { "./common": 41 }], 43: [function(e, t2, r) {
          "use strict";
          t2.exports = function(e2, t3, r2, n) {
            for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; r2 !== 0; ) {
              for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t3[n++] | 0) | 0, --a; )
                ;
              i %= 65521, s %= 65521;
            }
            return i | s << 16 | 0;
          };
        }, {}], 44: [function(e, t2, r) {
          "use strict";
          t2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
        }, {}], 45: [function(e, t2, r) {
          "use strict";
          var o = function() {
            for (var e2, t3 = [], r2 = 0; r2 < 256; r2++) {
              e2 = r2;
              for (var n = 0; n < 8; n++)
                e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
              t3[r2] = e2;
            }
            return t3;
          }();
          t2.exports = function(e2, t3, r2, n) {
            var i = o, s = n + r2;
            e2 ^= -1;
            for (var a = n; a < s; a++)
              e2 = e2 >>> 8 ^ i[255 & (e2 ^ t3[a])];
            return -1 ^ e2;
          };
        }, {}], 46: [function(e, t2, r) {
          "use strict";
          var h3, c2 = e("../utils/common"), u = e("./trees"), d2 = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y2 = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z2 = S + x + 1, C2 = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
          function R(e2, t3) {
            return e2.msg = n[t3], t3;
          }
          function T(e2) {
            return (e2 << 1) - (4 < e2 ? 9 : 0);
          }
          function D2(e2) {
            for (var t3 = e2.length; 0 <= --t3; )
              e2[t3] = 0;
          }
          function F2(e2) {
            var t3 = e2.state, r2 = t3.pending;
            r2 > e2.avail_out && (r2 = e2.avail_out), r2 !== 0 && (c2.arraySet(e2.output, t3.pending_buf, t3.pending_out, r2, e2.next_out), e2.next_out += r2, t3.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t3.pending -= r2, t3.pending === 0 && (t3.pending_out = 0));
          }
          function N(e2, t3) {
            u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t3), e2.block_start = e2.strstart, F2(e2.strm);
          }
          function U(e2, t3) {
            e2.pending_buf[e2.pending++] = t3;
          }
          function P(e2, t3) {
            e2.pending_buf[e2.pending++] = t3 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t3;
          }
          function L(e2, t3) {
            var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h4 = e2.strstart > e2.w_size - z2 ? e2.strstart - (e2.w_size - z2) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c3 = e2.strstart + S, d3 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
            e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
            do {
              if (u2[(r2 = t3) + a2] === p2 && u2[r2 + a2 - 1] === d3 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
                s2 += 2, r2++;
                do {
                } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c3);
                if (n2 = S - (c3 - s2), s2 = c3 - S, a2 < n2) {
                  if (e2.match_start = t3, o2 <= (a2 = n2))
                    break;
                  d3 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
                }
              }
            } while ((t3 = f2[t3 & l2]) > h4 && --i2 != 0);
            return a2 <= e2.lookahead ? a2 : e2.lookahead;
          }
          function j2(e2) {
            var t3, r2, n2, i2, s2, a2, o2, h4, u2, l2, f2 = e2.w_size;
            do {
              if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z2)) {
                for (c2.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t3 = r2 = e2.hash_size; n2 = e2.head[--t3], e2.head[t3] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                  ;
                for (t3 = r2 = f2; n2 = e2.prev[--t3], e2.prev[t3] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                  ;
                i2 += f2;
              }
              if (e2.strm.avail_in === 0)
                break;
              if (a2 = e2.strm, o2 = e2.window, h4 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = l2 === 0 ? 0 : (a2.avail_in -= l2, c2.arraySet(o2, a2.input, a2.next_in, l2, h4), a2.state.wrap === 1 ? a2.adler = d2(a2.adler, o2, l2, h4) : a2.state.wrap === 2 && (a2.adler = p(a2.adler, o2, l2, h4)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
                for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
                  ;
            } while (e2.lookahead < z2 && e2.strm.avail_in !== 0);
          }
          function Z(e2, t3) {
            for (var r2, n2; ; ) {
              if (e2.lookahead < z2) {
                if (j2(e2), e2.lookahead < z2 && t3 === l)
                  return A;
                if (e2.lookahead === 0)
                  break;
              }
              if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), r2 !== 0 && e2.strstart - r2 <= e2.w_size - z2 && (e2.match_length = L(e2, r2)), e2.match_length >= x)
                if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
                  for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, --e2.match_length != 0; )
                    ;
                  e2.strstart++;
                } else
                  e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
              else
                n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
              if (n2 && (N(e2, false), e2.strm.avail_out === 0))
                return A;
            }
            return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t3 === f ? (N(e2, true), e2.strm.avail_out === 0 ? O : B) : e2.last_lit && (N(e2, false), e2.strm.avail_out === 0) ? A : I;
          }
          function W2(e2, t3) {
            for (var r2, n2, i2; ; ) {
              if (e2.lookahead < z2) {
                if (j2(e2), e2.lookahead < z2 && t3 === l)
                  return A;
                if (e2.lookahead === 0)
                  break;
              }
              if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, r2 !== 0 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z2 && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (e2.strategy === 1 || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
                for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), --e2.prev_length != 0; )
                  ;
                if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), e2.strm.avail_out === 0))
                  return A;
              } else if (e2.match_available) {
                if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, e2.strm.avail_out === 0)
                  return A;
              } else
                e2.match_available = 1, e2.strstart++, e2.lookahead--;
            }
            return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t3 === f ? (N(e2, true), e2.strm.avail_out === 0 ? O : B) : e2.last_lit && (N(e2, false), e2.strm.avail_out === 0) ? A : I;
          }
          function M2(e2, t3, r2, n2, i2) {
            this.good_length = e2, this.max_lazy = t3, this.nice_length = r2, this.max_chain = n2, this.func = i2;
          }
          function H2() {
            this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c2.Buf16(2 * w), this.dyn_dtree = new c2.Buf16(2 * (2 * a + 1)), this.bl_tree = new c2.Buf16(2 * (2 * o + 1)), D2(this.dyn_ltree), D2(this.dyn_dtree), D2(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c2.Buf16(k + 1), this.heap = new c2.Buf16(2 * s + 1), D2(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c2.Buf16(2 * s + 1), D2(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
          }
          function G2(e2) {
            var t3;
            return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t3 = e2.state).pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? C2 : E, e2.adler = t3.wrap === 2 ? 0 : 1, t3.last_flush = l, u._tr_init(t3), m) : R(e2, _);
          }
          function K2(e2) {
            var t3 = G2(e2);
            return t3 === m && function(e3) {
              e3.window_size = 2 * e3.w_size, D2(e3.head), e3.max_lazy_match = h3[e3.level].max_lazy, e3.good_match = h3[e3.level].good_length, e3.nice_match = h3[e3.level].nice_length, e3.max_chain_length = h3[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
            }(e2.state), t3;
          }
          function Y(e2, t3, r2, n2, i2, s2) {
            if (!e2)
              return _;
            var a2 = 1;
            if (t3 === g && (t3 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y2 < i2 || r2 !== v || n2 < 8 || 15 < n2 || t3 < 0 || 9 < t3 || s2 < 0 || b < s2)
              return R(e2, _);
            n2 === 8 && (n2 = 9);
            var o2 = new H2();
            return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c2.Buf8(2 * o2.w_size), o2.head = new c2.Buf16(o2.hash_size), o2.prev = new c2.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c2.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t3, o2.strategy = s2, o2.method = r2, K2(e2);
          }
          h3 = [new M2(0, 0, 0, 0, function(e2, t3) {
            var r2 = 65535;
            for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
              if (e2.lookahead <= 1) {
                if (j2(e2), e2.lookahead === 0 && t3 === l)
                  return A;
                if (e2.lookahead === 0)
                  break;
              }
              e2.strstart += e2.lookahead, e2.lookahead = 0;
              var n2 = e2.block_start + r2;
              if ((e2.strstart === 0 || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), e2.strm.avail_out === 0))
                return A;
              if (e2.strstart - e2.block_start >= e2.w_size - z2 && (N(e2, false), e2.strm.avail_out === 0))
                return A;
            }
            return e2.insert = 0, t3 === f ? (N(e2, true), e2.strm.avail_out === 0 ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
          }), new M2(4, 4, 8, 4, Z), new M2(4, 5, 16, 8, Z), new M2(4, 6, 32, 32, Z), new M2(4, 4, 16, 16, W2), new M2(8, 16, 32, 32, W2), new M2(8, 16, 128, 128, W2), new M2(8, 32, 128, 256, W2), new M2(32, 128, 258, 1024, W2), new M2(32, 258, 258, 4096, W2)], r.deflateInit = function(e2, t3) {
            return Y(e2, t3, v, 15, 8, 0);
          }, r.deflateInit2 = Y, r.deflateReset = K2, r.deflateResetKeep = G2, r.deflateSetHeader = function(e2, t3) {
            return e2 && e2.state ? e2.state.wrap !== 2 ? _ : (e2.state.gzhead = t3, m) : _;
          }, r.deflate = function(e2, t3) {
            var r2, n2, i2, s2;
            if (!e2 || !e2.state || 5 < t3 || t3 < 0)
              return e2 ? R(e2, _) : _;
            if (n2 = e2.state, !e2.output || !e2.input && e2.avail_in !== 0 || n2.status === 666 && t3 !== f)
              return R(e2, e2.avail_out === 0 ? -5 : _);
            if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t3, n2.status === C2)
              if (n2.wrap === 2)
                e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, n2.level === 9 ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, n2.level === 9 ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
              else {
                var a2 = v + (n2.w_bits - 8 << 4) << 8;
                a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : n2.level === 6 ? 2 : 3) << 6, n2.strstart !== 0 && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), n2.strstart !== 0 && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
              }
            if (n2.status === 69)
              if (n2.gzhead.extra) {
                for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F2(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
                  U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
                n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
              } else
                n2.status = 73;
            if (n2.status === 73)
              if (n2.gzhead.name) {
                i2 = n2.pending;
                do {
                  if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F2(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                    s2 = 1;
                    break;
                  }
                  s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
                } while (s2 !== 0);
                n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), s2 === 0 && (n2.gzindex = 0, n2.status = 91);
              } else
                n2.status = 91;
            if (n2.status === 91)
              if (n2.gzhead.comment) {
                i2 = n2.pending;
                do {
                  if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F2(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                    s2 = 1;
                    break;
                  }
                  s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
                } while (s2 !== 0);
                n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), s2 === 0 && (n2.status = 103);
              } else
                n2.status = 103;
            if (n2.status === 103 && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F2(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), n2.pending !== 0) {
              if (F2(e2), e2.avail_out === 0)
                return n2.last_flush = -1, m;
            } else if (e2.avail_in === 0 && T(t3) <= T(r2) && t3 !== f)
              return R(e2, -5);
            if (n2.status === 666 && e2.avail_in !== 0)
              return R(e2, -5);
            if (e2.avail_in !== 0 || n2.lookahead !== 0 || t3 !== l && n2.status !== 666) {
              var o2 = n2.strategy === 2 ? function(e3, t4) {
                for (var r3; ; ) {
                  if (e3.lookahead === 0 && (j2(e3), e3.lookahead === 0)) {
                    if (t4 === l)
                      return A;
                    break;
                  }
                  if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), e3.strm.avail_out === 0))
                    return A;
                }
                return e3.insert = 0, t4 === f ? (N(e3, true), e3.strm.avail_out === 0 ? O : B) : e3.last_lit && (N(e3, false), e3.strm.avail_out === 0) ? A : I;
              }(n2, t3) : n2.strategy === 3 ? function(e3, t4) {
                for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                  if (e3.lookahead <= S) {
                    if (j2(e3), e3.lookahead <= S && t4 === l)
                      return A;
                    if (e3.lookahead === 0)
                      break;
                  }
                  if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                    s3 = e3.strstart + S;
                    do {
                    } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                    e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                  }
                  if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), e3.strm.avail_out === 0))
                    return A;
                }
                return e3.insert = 0, t4 === f ? (N(e3, true), e3.strm.avail_out === 0 ? O : B) : e3.last_lit && (N(e3, false), e3.strm.avail_out === 0) ? A : I;
              }(n2, t3) : h3[n2.level].func(n2, t3);
              if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O)
                return e2.avail_out === 0 && (n2.last_flush = -1), m;
              if (o2 === I && (t3 === 1 ? u._tr_align(n2) : t3 !== 5 && (u._tr_stored_block(n2, 0, 0, false), t3 === 3 && (D2(n2.head), n2.lookahead === 0 && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F2(e2), e2.avail_out === 0))
                return n2.last_flush = -1, m;
            }
            return t3 !== f ? m : n2.wrap <= 0 ? 1 : (n2.wrap === 2 ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F2(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), n2.pending !== 0 ? m : 1);
          }, r.deflateEnd = function(e2) {
            var t3;
            return e2 && e2.state ? (t3 = e2.state.status) !== C2 && t3 !== 69 && t3 !== 73 && t3 !== 91 && t3 !== 103 && t3 !== E && t3 !== 666 ? R(e2, _) : (e2.state = null, t3 === E ? R(e2, -3) : m) : _;
          }, r.deflateSetDictionary = function(e2, t3) {
            var r2, n2, i2, s2, a2, o2, h4, u2, l2 = t3.length;
            if (!e2 || !e2.state)
              return _;
            if ((s2 = (r2 = e2.state).wrap) === 2 || s2 === 1 && r2.status !== C2 || r2.lookahead)
              return _;
            for (s2 === 1 && (e2.adler = d2(e2.adler, t3, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (s2 === 0 && (D2(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c2.Buf8(r2.w_size), c2.arraySet(u2, t3, l2 - r2.w_size, r2.w_size, 0), t3 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h4 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t3, j2(r2); r2.lookahead >= x; ) {
              for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
                ;
              r2.strstart = n2, r2.lookahead = x - 1, j2(r2);
            }
            return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h4, e2.avail_in = a2, r2.wrap = s2, m;
          }, r.deflateInfo = "pako deflate (from Nodeca project)";
        }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t2, r) {
          "use strict";
          t2.exports = function() {
            this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
          };
        }, {}], 48: [function(e, t2, r) {
          "use strict";
          t2.exports = function(e2, t3) {
            var r2, n, i, s, a, o, h3, u, l, f, c2, d2, p, m, _, g, b, v, y2, w, k, x, S, z2, C2;
            r2 = e2.state, n = e2.next_in, z2 = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C2 = e2.output, a = s - (t3 - e2.avail_out), o = s + (e2.avail_out - 257), h3 = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c2 = r2.window, d2 = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
            e:
              do {
                p < 15 && (d2 += z2[n++] << p, p += 8, d2 += z2[n++] << p, p += 8), v = m[d2 & g];
                t:
                  for (; ; ) {
                    if (d2 >>>= y2 = v >>> 24, p -= y2, (y2 = v >>> 16 & 255) === 0)
                      C2[s++] = 65535 & v;
                    else {
                      if (!(16 & y2)) {
                        if ((64 & y2) == 0) {
                          v = m[(65535 & v) + (d2 & (1 << y2) - 1)];
                          continue t;
                        }
                        if (32 & y2) {
                          r2.mode = 12;
                          break e;
                        }
                        e2.msg = "invalid literal/length code", r2.mode = 30;
                        break e;
                      }
                      w = 65535 & v, (y2 &= 15) && (p < y2 && (d2 += z2[n++] << p, p += 8), w += d2 & (1 << y2) - 1, d2 >>>= y2, p -= y2), p < 15 && (d2 += z2[n++] << p, p += 8, d2 += z2[n++] << p, p += 8), v = _[d2 & b];
                      r:
                        for (; ; ) {
                          if (d2 >>>= y2 = v >>> 24, p -= y2, !(16 & (y2 = v >>> 16 & 255))) {
                            if ((64 & y2) == 0) {
                              v = _[(65535 & v) + (d2 & (1 << y2) - 1)];
                              continue r;
                            }
                            e2.msg = "invalid distance code", r2.mode = 30;
                            break e;
                          }
                          if (k = 65535 & v, p < (y2 &= 15) && (d2 += z2[n++] << p, (p += 8) < y2 && (d2 += z2[n++] << p, p += 8)), h3 < (k += d2 & (1 << y2) - 1)) {
                            e2.msg = "invalid distance too far back", r2.mode = 30;
                            break e;
                          }
                          if (d2 >>>= y2, p -= y2, (y2 = s - a) < k) {
                            if (l < (y2 = k - y2) && r2.sane) {
                              e2.msg = "invalid distance too far back", r2.mode = 30;
                              break e;
                            }
                            if (S = c2, (x = 0) === f) {
                              if (x += u - y2, y2 < w) {
                                for (w -= y2; C2[s++] = c2[x++], --y2; )
                                  ;
                                x = s - k, S = C2;
                              }
                            } else if (f < y2) {
                              if (x += u + f - y2, (y2 -= f) < w) {
                                for (w -= y2; C2[s++] = c2[x++], --y2; )
                                  ;
                                if (x = 0, f < w) {
                                  for (w -= y2 = f; C2[s++] = c2[x++], --y2; )
                                    ;
                                  x = s - k, S = C2;
                                }
                              }
                            } else if (x += f - y2, y2 < w) {
                              for (w -= y2; C2[s++] = c2[x++], --y2; )
                                ;
                              x = s - k, S = C2;
                            }
                            for (; 2 < w; )
                              C2[s++] = S[x++], C2[s++] = S[x++], C2[s++] = S[x++], w -= 3;
                            w && (C2[s++] = S[x++], 1 < w && (C2[s++] = S[x++]));
                          } else {
                            for (x = s - k; C2[s++] = C2[x++], C2[s++] = C2[x++], C2[s++] = C2[x++], 2 < (w -= 3); )
                              ;
                            w && (C2[s++] = C2[x++], 1 < w && (C2[s++] = C2[x++]));
                          }
                          break;
                        }
                    }
                    break;
                  }
              } while (n < i && s < o);
            n -= w = p >> 3, d2 &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d2, r2.bits = p;
          };
        }, {}], 49: [function(e, t2, r) {
          "use strict";
          var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D2 = 1, F2 = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
          function L(e2) {
            return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
          }
          function s() {
            this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
          }
          function a(e2) {
            var t3;
            return e2 && e2.state ? (t3 = e2.state, e2.total_in = e2.total_out = t3.total = 0, e2.msg = "", t3.wrap && (e2.adler = 1 & t3.wrap), t3.mode = P, t3.last = 0, t3.havedict = 0, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new I.Buf32(n), t3.distcode = t3.distdyn = new I.Buf32(i), t3.sane = 1, t3.back = -1, N) : U;
          }
          function o(e2) {
            var t3;
            return e2 && e2.state ? ((t3 = e2.state).wsize = 0, t3.whave = 0, t3.wnext = 0, a(e2)) : U;
          }
          function h3(e2, t3) {
            var r2, n2;
            return e2 && e2.state ? (n2 = e2.state, t3 < 0 ? (r2 = 0, t3 = -t3) : (r2 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || 15 < t3) ? U : (n2.window !== null && n2.wbits !== t3 && (n2.window = null), n2.wrap = r2, n2.wbits = t3, o(e2))) : U;
          }
          function u(e2, t3) {
            var r2, n2;
            return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h3(e2, t3)) !== N && (e2.state = null), r2) : U;
          }
          var l, f, c2 = true;
          function j2(e2) {
            if (c2) {
              var t3;
              for (l = new I.Buf32(512), f = new I.Buf32(32), t3 = 0; t3 < 144; )
                e2.lens[t3++] = 8;
              for (; t3 < 256; )
                e2.lens[t3++] = 9;
              for (; t3 < 280; )
                e2.lens[t3++] = 7;
              for (; t3 < 288; )
                e2.lens[t3++] = 8;
              for (T(D2, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t3 = 0; t3 < 32; )
                e2.lens[t3++] = 5;
              T(F2, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c2 = false;
            }
            e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
          }
          function Z(e2, t3, r2, n2) {
            var i2, s2 = e2.state;
            return s2.window === null && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t3, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t3, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t3, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
          }
          r.inflateReset = o, r.inflateReset2 = h3, r.inflateResetKeep = a, r.inflateInit = function(e2) {
            return u(e2, 15);
          }, r.inflateInit2 = u, r.inflate = function(e2, t3) {
            var r2, n2, i2, s2, a2, o2, h4, u2, l2, f2, c3, d2, p, m, _, g, b, v, y2, w, k, x, S, z2, C2 = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
            if (!e2 || !e2.state || !e2.output || !e2.input && e2.avail_in !== 0)
              return U;
            (r2 = e2.state).mode === 12 && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h4 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c3 = h4, x = N;
            e:
              for (; ; )
                switch (r2.mode) {
                  case P:
                    if (r2.wrap === 0) {
                      r2.mode = 13;
                      break;
                    }
                    for (; l2 < 16; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (2 & r2.wrap && u2 === 35615) {
                      E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                      break;
                    }
                    if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                      e2.msg = "incorrect header check", r2.mode = 30;
                      break;
                    }
                    if ((15 & u2) != 8) {
                      e2.msg = "unknown compression method", r2.mode = 30;
                      break;
                    }
                    if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), r2.wbits === 0)
                      r2.wbits = k;
                    else if (k > r2.wbits) {
                      e2.msg = "invalid window size", r2.mode = 30;
                      break;
                    }
                    r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                    break;
                  case 2:
                    for (; l2 < 16; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (r2.flags = u2, (255 & r2.flags) != 8) {
                      e2.msg = "unknown compression method", r2.mode = 30;
                      break;
                    }
                    if (57344 & r2.flags) {
                      e2.msg = "unknown header flags set", r2.mode = 30;
                      break;
                    }
                    r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
                  case 3:
                    for (; l2 < 32; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
                  case 4:
                    for (; l2 < 16; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
                  case 5:
                    if (1024 & r2.flags) {
                      for (; l2 < 16; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                    } else
                      r2.head && (r2.head.extra = null);
                    r2.mode = 6;
                  case 6:
                    if (1024 & r2.flags && (o2 < (d2 = r2.length) && (d2 = o2), d2 && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d2, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d2, s2)), o2 -= d2, s2 += d2, r2.length -= d2), r2.length))
                      break e;
                    r2.length = 0, r2.mode = 7;
                  case 7:
                    if (2048 & r2.flags) {
                      if (o2 === 0)
                        break e;
                      for (d2 = 0; k = n2[s2 + d2++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d2 < o2; )
                        ;
                      if (512 & r2.flags && (r2.check = B(r2.check, n2, d2, s2)), o2 -= d2, s2 += d2, k)
                        break e;
                    } else
                      r2.head && (r2.head.name = null);
                    r2.length = 0, r2.mode = 8;
                  case 8:
                    if (4096 & r2.flags) {
                      if (o2 === 0)
                        break e;
                      for (d2 = 0; k = n2[s2 + d2++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d2 < o2; )
                        ;
                      if (512 & r2.flags && (r2.check = B(r2.check, n2, d2, s2)), o2 -= d2, s2 += d2, k)
                        break e;
                    } else
                      r2.head && (r2.head.comment = null);
                    r2.mode = 9;
                  case 9:
                    if (512 & r2.flags) {
                      for (; l2 < 16; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      if (u2 !== (65535 & r2.check)) {
                        e2.msg = "header crc mismatch", r2.mode = 30;
                        break;
                      }
                      l2 = u2 = 0;
                    }
                    r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                    break;
                  case 10:
                    for (; l2 < 32; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
                  case 11:
                    if (r2.havedict === 0)
                      return e2.next_out = a2, e2.avail_out = h4, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                    e2.adler = r2.check = 1, r2.mode = 12;
                  case 12:
                    if (t3 === 5 || t3 === 6)
                      break e;
                  case 13:
                    if (r2.last) {
                      u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                      break;
                    }
                    for (; l2 < 3; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                      case 0:
                        r2.mode = 14;
                        break;
                      case 1:
                        if (j2(r2), r2.mode = 20, t3 !== 6)
                          break;
                        u2 >>>= 2, l2 -= 2;
                        break e;
                      case 2:
                        r2.mode = 17;
                        break;
                      case 3:
                        e2.msg = "invalid block type", r2.mode = 30;
                    }
                    u2 >>>= 2, l2 -= 2;
                    break;
                  case 14:
                    for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                      e2.msg = "invalid stored block lengths", r2.mode = 30;
                      break;
                    }
                    if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, t3 === 6)
                      break e;
                  case 15:
                    r2.mode = 16;
                  case 16:
                    if (d2 = r2.length) {
                      if (o2 < d2 && (d2 = o2), h4 < d2 && (d2 = h4), d2 === 0)
                        break e;
                      I.arraySet(i2, n2, s2, d2, a2), o2 -= d2, s2 += d2, h4 -= d2, a2 += d2, r2.length -= d2;
                      break;
                    }
                    r2.mode = 12;
                    break;
                  case 17:
                    for (; l2 < 14; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                      e2.msg = "too many length or distance symbols", r2.mode = 30;
                      break;
                    }
                    r2.have = 0, r2.mode = 18;
                  case 18:
                    for (; r2.have < r2.ncode; ) {
                      for (; l2 < 3; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                    }
                    for (; r2.have < 19; )
                      r2.lens[A[r2.have++]] = 0;
                    if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                      e2.msg = "invalid code lengths set", r2.mode = 30;
                      break;
                    }
                    r2.have = 0, r2.mode = 19;
                  case 19:
                    for (; r2.have < r2.nlen + r2.ndist; ) {
                      for (; g = (C2 = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C2, !((_ = C2 >>> 24) <= l2); ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      if (b < 16)
                        u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                      else {
                        if (b === 16) {
                          for (z2 = _ + 2; l2 < z2; ) {
                            if (o2 === 0)
                              break e;
                            o2--, u2 += n2[s2++] << l2, l2 += 8;
                          }
                          if (u2 >>>= _, l2 -= _, r2.have === 0) {
                            e2.msg = "invalid bit length repeat", r2.mode = 30;
                            break;
                          }
                          k = r2.lens[r2.have - 1], d2 = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                        } else if (b === 17) {
                          for (z2 = _ + 3; l2 < z2; ) {
                            if (o2 === 0)
                              break e;
                            o2--, u2 += n2[s2++] << l2, l2 += 8;
                          }
                          l2 -= _, k = 0, d2 = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                        } else {
                          for (z2 = _ + 7; l2 < z2; ) {
                            if (o2 === 0)
                              break e;
                            o2--, u2 += n2[s2++] << l2, l2 += 8;
                          }
                          l2 -= _, k = 0, d2 = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                        }
                        if (r2.have + d2 > r2.nlen + r2.ndist) {
                          e2.msg = "invalid bit length repeat", r2.mode = 30;
                          break;
                        }
                        for (; d2--; )
                          r2.lens[r2.have++] = k;
                      }
                    }
                    if (r2.mode === 30)
                      break;
                    if (r2.lens[256] === 0) {
                      e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                      break;
                    }
                    if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D2, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                      e2.msg = "invalid literal/lengths set", r2.mode = 30;
                      break;
                    }
                    if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F2, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                      e2.msg = "invalid distances set", r2.mode = 30;
                      break;
                    }
                    if (r2.mode = 20, t3 === 6)
                      break e;
                  case 20:
                    r2.mode = 21;
                  case 21:
                    if (6 <= o2 && 258 <= h4) {
                      e2.next_out = a2, e2.avail_out = h4, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c3), a2 = e2.next_out, i2 = e2.output, h4 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, r2.mode === 12 && (r2.back = -1);
                      break;
                    }
                    for (r2.back = 0; g = (C2 = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C2, !((_ = C2 >>> 24) <= l2); ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (g && (240 & g) == 0) {
                      for (v = _, y2 = g, w = b; g = (C2 = r2.lencode[w + ((u2 & (1 << v + y2) - 1) >> v)]) >>> 16 & 255, b = 65535 & C2, !(v + (_ = C2 >>> 24) <= l2); ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      u2 >>>= v, l2 -= v, r2.back += v;
                    }
                    if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, g === 0) {
                      r2.mode = 26;
                      break;
                    }
                    if (32 & g) {
                      r2.back = -1, r2.mode = 12;
                      break;
                    }
                    if (64 & g) {
                      e2.msg = "invalid literal/length code", r2.mode = 30;
                      break;
                    }
                    r2.extra = 15 & g, r2.mode = 22;
                  case 22:
                    if (r2.extra) {
                      for (z2 = r2.extra; l2 < z2; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                    }
                    r2.was = r2.length, r2.mode = 23;
                  case 23:
                    for (; g = (C2 = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C2, !((_ = C2 >>> 24) <= l2); ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if ((240 & g) == 0) {
                      for (v = _, y2 = g, w = b; g = (C2 = r2.distcode[w + ((u2 & (1 << v + y2) - 1) >> v)]) >>> 16 & 255, b = 65535 & C2, !(v + (_ = C2 >>> 24) <= l2); ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      u2 >>>= v, l2 -= v, r2.back += v;
                    }
                    if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                      e2.msg = "invalid distance code", r2.mode = 30;
                      break;
                    }
                    r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
                  case 24:
                    if (r2.extra) {
                      for (z2 = r2.extra; l2 < z2; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                    }
                    if (r2.offset > r2.dmax) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break;
                    }
                    r2.mode = 25;
                  case 25:
                    if (h4 === 0)
                      break e;
                    if (d2 = c3 - h4, r2.offset > d2) {
                      if ((d2 = r2.offset - d2) > r2.whave && r2.sane) {
                        e2.msg = "invalid distance too far back", r2.mode = 30;
                        break;
                      }
                      p = d2 > r2.wnext ? (d2 -= r2.wnext, r2.wsize - d2) : r2.wnext - d2, d2 > r2.length && (d2 = r2.length), m = r2.window;
                    } else
                      m = i2, p = a2 - r2.offset, d2 = r2.length;
                    for (h4 < d2 && (d2 = h4), h4 -= d2, r2.length -= d2; i2[a2++] = m[p++], --d2; )
                      ;
                    r2.length === 0 && (r2.mode = 21);
                    break;
                  case 26:
                    if (h4 === 0)
                      break e;
                    i2[a2++] = r2.length, h4--, r2.mode = 21;
                    break;
                  case 27:
                    if (r2.wrap) {
                      for (; l2 < 32; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 |= n2[s2++] << l2, l2 += 8;
                      }
                      if (c3 -= h4, e2.total_out += c3, r2.total += c3, c3 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c3, a2 - c3) : O(r2.check, i2, c3, a2 - c3)), c3 = h4, (r2.flags ? u2 : L(u2)) !== r2.check) {
                        e2.msg = "incorrect data check", r2.mode = 30;
                        break;
                      }
                      l2 = u2 = 0;
                    }
                    r2.mode = 28;
                  case 28:
                    if (r2.wrap && r2.flags) {
                      for (; l2 < 32; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      if (u2 !== (4294967295 & r2.total)) {
                        e2.msg = "incorrect length check", r2.mode = 30;
                        break;
                      }
                      l2 = u2 = 0;
                    }
                    r2.mode = 29;
                  case 29:
                    x = 1;
                    break e;
                  case 30:
                    x = -3;
                    break e;
                  case 31:
                    return -4;
                  case 32:
                  default:
                    return U;
                }
            return e2.next_out = a2, e2.avail_out = h4, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c3 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || t3 !== 4)) && Z(e2, e2.output, e2.next_out, c3 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c3 -= e2.avail_out, e2.total_in += f2, e2.total_out += c3, r2.total += c3, r2.wrap && c3 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c3, e2.next_out - c3) : O(r2.check, i2, c3, e2.next_out - c3)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (r2.mode === 12 ? 128 : 0) + (r2.mode === 20 || r2.mode === 15 ? 256 : 0), (f2 == 0 && c3 === 0 || t3 === 4) && x === N && (x = -5), x);
          }, r.inflateEnd = function(e2) {
            if (!e2 || !e2.state)
              return U;
            var t3 = e2.state;
            return t3.window && (t3.window = null), e2.state = null, N;
          }, r.inflateGetHeader = function(e2, t3) {
            var r2;
            return e2 && e2.state ? (2 & (r2 = e2.state).wrap) == 0 ? U : ((r2.head = t3).done = false, N) : U;
          }, r.inflateSetDictionary = function(e2, t3) {
            var r2, n2 = t3.length;
            return e2 && e2.state ? (r2 = e2.state).wrap !== 0 && r2.mode !== 11 ? U : r2.mode === 11 && O(1, t3, n2, 0) !== r2.check ? -3 : Z(e2, t3, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
          }, r.inflateInfo = "pako inflate (from Nodeca project)";
        }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t2, r) {
          "use strict";
          var D2 = e("../utils/common"), F2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
          t2.exports = function(e2, t3, r2, n, i, s, a, o) {
            var h3, u, l, f, c2, d2, p, m, _, g = o.bits, b = 0, v = 0, y2 = 0, w = 0, k = 0, x = 0, S = 0, z2 = 0, C2 = 0, E = 0, A = null, I = 0, O = new D2.Buf16(16), B = new D2.Buf16(16), R = null, T = 0;
            for (b = 0; b <= 15; b++)
              O[b] = 0;
            for (v = 0; v < n; v++)
              O[t3[r2 + v]]++;
            for (k = g, w = 15; 1 <= w && O[w] === 0; w--)
              ;
            if (w < k && (k = w), w === 0)
              return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
            for (y2 = 1; y2 < w && O[y2] === 0; y2++)
              ;
            for (k < y2 && (k = y2), b = z2 = 1; b <= 15; b++)
              if (z2 <<= 1, (z2 -= O[b]) < 0)
                return -1;
            if (0 < z2 && (e2 === 0 || w !== 1))
              return -1;
            for (B[1] = 0, b = 1; b < 15; b++)
              B[b + 1] = B[b] + O[b];
            for (v = 0; v < n; v++)
              t3[r2 + v] !== 0 && (a[B[t3[r2 + v]]++] = v);
            if (d2 = e2 === 0 ? (A = R = a, 19) : e2 === 1 ? (A = F2, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y2, c2 = s, S = v = E = 0, l = -1, f = (C2 = 1 << (x = k)) - 1, e2 === 1 && 852 < C2 || e2 === 2 && 592 < C2)
              return 1;
            for (; ; ) {
              for (p = b - S, _ = a[v] < d2 ? (m = 0, a[v]) : a[v] > d2 ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h3 = 1 << b - S, y2 = u = 1 << x; i[c2 + (E >> S) + (u -= h3)] = p << 24 | m << 16 | _ | 0, u !== 0; )
                ;
              for (h3 = 1 << b - 1; E & h3; )
                h3 >>= 1;
              if (h3 !== 0 ? (E &= h3 - 1, E += h3) : E = 0, v++, --O[b] == 0) {
                if (b === w)
                  break;
                b = t3[r2 + a[v]];
              }
              if (k < b && (E & f) !== l) {
                for (S === 0 && (S = k), c2 += y2, z2 = 1 << (x = b - S); x + S < w && !((z2 -= O[x + S]) <= 0); )
                  x++, z2 <<= 1;
                if (C2 += 1 << x, e2 === 1 && 852 < C2 || e2 === 2 && 592 < C2)
                  return 1;
                i[l = E & f] = k << 24 | x << 16 | c2 - s | 0;
              }
            }
            return E !== 0 && (i[c2 + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
          };
        }, { "../utils/common": 41 }], 51: [function(e, t2, r) {
          "use strict";
          t2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
        }, {}], 52: [function(e, t2, r) {
          "use strict";
          var i = e("../utils/common"), o = 0, h3 = 1;
          function n(e2) {
            for (var t3 = e2.length; 0 <= --t3; )
              e2[t3] = 0;
          }
          var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c2 = 19, _ = 2 * l + 1, g = 15, d2 = 16, p = 7, m = 256, b = 16, v = 17, y2 = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z2 = new Array(2 * (l + 2));
          n(z2);
          var C2 = new Array(2 * f);
          n(C2);
          var E = new Array(512);
          n(E);
          var A = new Array(256);
          n(A);
          var I = new Array(a);
          n(I);
          var O, B, R, T = new Array(f);
          function D2(e2, t3, r2, n2, i2) {
            this.static_tree = e2, this.extra_bits = t3, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
          }
          function F2(e2, t3) {
            this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t3;
          }
          function N(e2) {
            return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
          }
          function U(e2, t3) {
            e2.pending_buf[e2.pending++] = 255 & t3, e2.pending_buf[e2.pending++] = t3 >>> 8 & 255;
          }
          function P(e2, t3, r2) {
            e2.bi_valid > d2 - r2 ? (e2.bi_buf |= t3 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t3 >> d2 - e2.bi_valid, e2.bi_valid += r2 - d2) : (e2.bi_buf |= t3 << e2.bi_valid & 65535, e2.bi_valid += r2);
          }
          function L(e2, t3, r2) {
            P(e2, r2[2 * t3], r2[2 * t3 + 1]);
          }
          function j2(e2, t3) {
            for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t3; )
              ;
            return r2 >>> 1;
          }
          function Z(e2, t3, r2) {
            var n2, i2, s2 = new Array(g + 1), a2 = 0;
            for (n2 = 1; n2 <= g; n2++)
              s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
            for (i2 = 0; i2 <= t3; i2++) {
              var o2 = e2[2 * i2 + 1];
              o2 !== 0 && (e2[2 * i2] = j2(s2[o2]++, o2));
            }
          }
          function W2(e2) {
            var t3;
            for (t3 = 0; t3 < l; t3++)
              e2.dyn_ltree[2 * t3] = 0;
            for (t3 = 0; t3 < f; t3++)
              e2.dyn_dtree[2 * t3] = 0;
            for (t3 = 0; t3 < c2; t3++)
              e2.bl_tree[2 * t3] = 0;
            e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
          }
          function M2(e2) {
            8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
          }
          function H2(e2, t3, r2, n2) {
            var i2 = 2 * t3, s2 = 2 * r2;
            return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t3] <= n2[r2];
          }
          function G2(e2, t3, r2) {
            for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H2(t3, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H2(t3, n2, e2.heap[i2], e2.depth)); )
              e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
            e2.heap[r2] = n2;
          }
          function K2(e2, t3, r2) {
            var n2, i2, s2, a2, o2 = 0;
            if (e2.last_lit !== 0)
              for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, n2 === 0 ? L(e2, i2, t3) : (L(e2, (s2 = A[i2]) + u + 1, t3), (a2 = w[s2]) !== 0 && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), (a2 = k[s2]) !== 0 && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; )
                ;
            L(e2, m, t3);
          }
          function Y(e2, t3) {
            var r2, n2, i2, s2 = t3.dyn_tree, a2 = t3.stat_desc.static_tree, o2 = t3.stat_desc.has_stree, h4 = t3.stat_desc.elems, u2 = -1;
            for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h4; r2++)
              s2[2 * r2] !== 0 ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
            for (; e2.heap_len < 2; )
              s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
            for (t3.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
              G2(e2, s2, r2);
            for (i2 = h4; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G2(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G2(e2, s2, 1), 2 <= e2.heap_len; )
              ;
            e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t4) {
              var r3, n3, i3, s3, a3, o3, h5 = t4.dyn_tree, u3 = t4.max_code, l2 = t4.stat_desc.static_tree, f2 = t4.stat_desc.has_stree, c3 = t4.stat_desc.extra_bits, d3 = t4.stat_desc.extra_base, p2 = t4.stat_desc.max_length, m2 = 0;
              for (s3 = 0; s3 <= g; s3++)
                e3.bl_count[s3] = 0;
              for (h5[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
                p2 < (s3 = h5[2 * h5[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h5[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d3 <= n3 && (a3 = c3[n3 - d3]), o3 = h5[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
              if (m2 !== 0) {
                do {
                  for (s3 = p2 - 1; e3.bl_count[s3] === 0; )
                    s3--;
                  e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
                } while (0 < m2);
                for (s3 = p2; s3 !== 0; s3--)
                  for (n3 = e3.bl_count[s3]; n3 !== 0; )
                    u3 < (i3 = e3.heap[--r3]) || (h5[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h5[2 * i3 + 1]) * h5[2 * i3], h5[2 * i3 + 1] = s3), n3--);
              }
            }(e2, t3), Z(s2, u2, e2.bl_count);
          }
          function X2(e2, t3, r2) {
            var n2, i2, s2 = -1, a2 = t3[1], o2 = 0, h4 = 7, u2 = 4;
            for (a2 === 0 && (h4 = 138, u2 = 3), t3[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
              i2 = a2, a2 = t3[2 * (n2 + 1) + 1], ++o2 < h4 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : i2 !== 0 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y2]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h4 = 138, 3) : i2 === a2 ? (h4 = 6, 3) : (h4 = 7, 4));
          }
          function V2(e2, t3, r2) {
            var n2, i2, s2 = -1, a2 = t3[1], o2 = 0, h4 = 7, u2 = 4;
            for (a2 === 0 && (h4 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
              if (i2 = a2, a2 = t3[2 * (n2 + 1) + 1], !(++o2 < h4 && i2 === a2)) {
                if (o2 < u2)
                  for (; L(e2, i2, e2.bl_tree), --o2 != 0; )
                    ;
                else
                  i2 !== 0 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y2, e2.bl_tree), P(e2, o2 - 11, 7));
                s2 = i2, u2 = (o2 = 0) === a2 ? (h4 = 138, 3) : i2 === a2 ? (h4 = 6, 3) : (h4 = 7, 4);
              }
          }
          n(T);
          var q2 = false;
          function J2(e2, t3, r2, n2) {
            P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t4, r3, n3) {
              M2(e3), n3 && (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t4, r3, e3.pending), e3.pending += r3;
            }(e2, t3, r2, true);
          }
          r._tr_init = function(e2) {
            q2 || (function() {
              var e3, t3, r2, n2, i2, s2 = new Array(g + 1);
              for (n2 = r2 = 0; n2 < a - 1; n2++)
                for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++)
                  A[r2++] = n2;
              for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
                for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++)
                  E[i2++] = n2;
              for (i2 >>= 7; n2 < f; n2++)
                for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++)
                  E[256 + i2++] = n2;
              for (t3 = 0; t3 <= g; t3++)
                s2[t3] = 0;
              for (e3 = 0; e3 <= 143; )
                z2[2 * e3 + 1] = 8, e3++, s2[8]++;
              for (; e3 <= 255; )
                z2[2 * e3 + 1] = 9, e3++, s2[9]++;
              for (; e3 <= 279; )
                z2[2 * e3 + 1] = 7, e3++, s2[7]++;
              for (; e3 <= 287; )
                z2[2 * e3 + 1] = 8, e3++, s2[8]++;
              for (Z(z2, l + 1, s2), e3 = 0; e3 < f; e3++)
                C2[2 * e3 + 1] = 5, C2[2 * e3] = j2(e3, 5);
              O = new D2(z2, w, u + 1, l, g), B = new D2(C2, k, 0, f, g), R = new D2(new Array(0), x, 0, c2, p);
            }(), q2 = true), e2.l_desc = new F2(e2.dyn_ltree, O), e2.d_desc = new F2(e2.dyn_dtree, B), e2.bl_desc = new F2(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W2(e2);
          }, r._tr_stored_block = J2, r._tr_flush_block = function(e2, t3, r2, n2) {
            var i2, s2, a2 = 0;
            0 < e2.level ? (e2.strm.data_type === 2 && (e2.strm.data_type = function(e3) {
              var t4, r3 = 4093624447;
              for (t4 = 0; t4 <= 31; t4++, r3 >>>= 1)
                if (1 & r3 && e3.dyn_ltree[2 * t4] !== 0)
                  return o;
              if (e3.dyn_ltree[18] !== 0 || e3.dyn_ltree[20] !== 0 || e3.dyn_ltree[26] !== 0)
                return h3;
              for (t4 = 32; t4 < u; t4++)
                if (e3.dyn_ltree[2 * t4] !== 0)
                  return h3;
              return o;
            }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
              var t4;
              for (X2(e3, e3.dyn_ltree, e3.l_desc.max_code), X2(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t4 = c2 - 1; 3 <= t4 && e3.bl_tree[2 * S[t4] + 1] === 0; t4--)
                ;
              return e3.opt_len += 3 * (t4 + 1) + 5 + 5 + 4, t4;
            }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && t3 !== -1 ? J2(e2, t3, r2, n2) : e2.strategy === 4 || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K2(e2, z2, C2)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t4, r3, n3) {
              var i3;
              for (P(e3, t4 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
                P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
              V2(e3, e3.dyn_ltree, t4 - 1), V2(e3, e3.dyn_dtree, r3 - 1);
            }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K2(e2, e2.dyn_ltree, e2.dyn_dtree)), W2(e2), n2 && M2(e2);
          }, r._tr_tally = function(e2, t3, r2) {
            return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t3 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t3, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, t3 === 0 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t3--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t3)]++), e2.last_lit === e2.lit_bufsize - 1;
          }, r._tr_align = function(e2) {
            P(e2, 2, 3), L(e2, m, z2), function(e3) {
              e3.bi_valid === 16 ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
            }(e2);
          };
        }, { "../utils/common": 41 }], 53: [function(e, t2, r) {
          "use strict";
          t2.exports = function() {
            this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
          };
        }, {}], 54: [function(e, t2, r) {
          (function(e2) {
            !function(r2, n) {
              "use strict";
              if (!r2.setImmediate) {
                var i, s, t3, a, o = 1, h3 = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
                e3 = e3 && e3.setTimeout ? e3 : r2, i = {}.toString.call(r2.process) === "[object process]" ? function(e4) {
                  process.nextTick(function() {
                    c2(e4);
                  });
                } : function() {
                  if (r2.postMessage && !r2.importScripts) {
                    var e4 = true, t4 = r2.onmessage;
                    return r2.onmessage = function() {
                      e4 = false;
                    }, r2.postMessage("", "*"), r2.onmessage = t4, e4;
                  }
                }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d2, false) : r2.attachEvent("onmessage", d2), function(e4) {
                  r2.postMessage(a + e4, "*");
                }) : r2.MessageChannel ? ((t3 = new MessageChannel()).port1.onmessage = function(e4) {
                  c2(e4.data);
                }, function(e4) {
                  t3.port2.postMessage(e4);
                }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                  var t4 = l.createElement("script");
                  t4.onreadystatechange = function() {
                    c2(e4), t4.onreadystatechange = null, s.removeChild(t4), t4 = null;
                  }, s.appendChild(t4);
                }) : function(e4) {
                  setTimeout(c2, 0, e4);
                }, e3.setImmediate = function(e4) {
                  typeof e4 != "function" && (e4 = new Function("" + e4));
                  for (var t4 = new Array(arguments.length - 1), r3 = 0; r3 < t4.length; r3++)
                    t4[r3] = arguments[r3 + 1];
                  var n2 = { callback: e4, args: t4 };
                  return h3[o] = n2, i(o), o++;
                }, e3.clearImmediate = f;
              }
              function f(e4) {
                delete h3[e4];
              }
              function c2(e4) {
                if (u)
                  setTimeout(c2, 0, e4);
                else {
                  var t4 = h3[e4];
                  if (t4) {
                    u = true;
                    try {
                      !function(e5) {
                        var t5 = e5.callback, r3 = e5.args;
                        switch (r3.length) {
                          case 0:
                            t5();
                            break;
                          case 1:
                            t5(r3[0]);
                            break;
                          case 2:
                            t5(r3[0], r3[1]);
                            break;
                          case 3:
                            t5(r3[0], r3[1], r3[2]);
                            break;
                          default:
                            t5.apply(n, r3);
                        }
                      }(t4);
                    } finally {
                      f(e4), u = false;
                    }
                  }
                }
              }
              function d2(e4) {
                e4.source === r2 && typeof e4.data == "string" && e4.data.indexOf(a) === 0 && c2(+e4.data.slice(a.length));
              }
            }(typeof self == "undefined" ? e2 === void 0 ? this : e2 : self);
          }).call(this, typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
        }, {}] }, {}, [10])(10);
      });
    }
  });

  // node_modules/@babel/runtime/helpers/arrayWithHoles.js
  var require_arrayWithHoles = __commonJS({
    "node_modules/@babel/runtime/helpers/arrayWithHoles.js"(exports, module) {
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/iterableToArrayLimit.js
  var require_iterableToArrayLimit = __commonJS({
    "node_modules/@babel/runtime/helpers/iterableToArrayLimit.js"(exports, module) {
      function _iterableToArrayLimit(r, l) {
        var t2 = r == null ? null : typeof Symbol != "undefined" && r[Symbol.iterator] || r["@@iterator"];
        if (t2 != null) {
          var e, n, i, u, a = [], f = true, o = false;
          try {
            if (i = (t2 = t2.call(r)).next, l === 0) {
              if (Object(t2) !== t2)
                return;
              f = false;
            } else
              for (; !(f = (e = i.call(t2)).done) && (a.push(e.value), a.length !== l); f = true)
                ;
          } catch (r2) {
            o = true, n = r2;
          } finally {
            try {
              if (!f && t2["return"] != null && (u = t2["return"](), Object(u) !== u))
                return;
            } finally {
              if (o)
                throw n;
            }
          }
          return a;
        }
      }
      module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/arrayLikeToArray.js
  var require_arrayLikeToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports, module) {
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++)
          arr2[i] = arr[i];
        return arr2;
      }
      module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
  var require_unsupportedIterableToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports, module) {
      var arrayLikeToArray = require_arrayLikeToArray();
      function _unsupportedIterableToArray(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return arrayLikeToArray(o, minLen);
      }
      module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/nonIterableRest.js
  var require_nonIterableRest = __commonJS({
    "node_modules/@babel/runtime/helpers/nonIterableRest.js"(exports, module) {
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/slicedToArray.js
  var require_slicedToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/slicedToArray.js"(exports, module) {
      var arrayWithHoles = require_arrayWithHoles();
      var iterableToArrayLimit = require_iterableToArrayLimit();
      var unsupportedIterableToArray = require_unsupportedIterableToArray();
      var nonIterableRest = require_nonIterableRest();
      function _slicedToArray(arr, i) {
        return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
      }
      module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/classCallCheck.js
  var require_classCallCheck = __commonJS({
    "node_modules/@babel/runtime/helpers/classCallCheck.js"(exports, module) {
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/typeof.js
  var require_typeof = __commonJS({
    "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
      function _typeof2(o) {
        "@babel/helpers - typeof";
        return module.exports = _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o);
      }
      module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/toPrimitive.js
  var require_toPrimitive = __commonJS({
    "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports, module) {
      var _typeof2 = require_typeof()["default"];
      function toPrimitive(t2, r) {
        if (_typeof2(t2) != "object" || !t2)
          return t2;
        var e = t2[Symbol.toPrimitive];
        if (e !== void 0) {
          var i = e.call(t2, r || "default");
          if (_typeof2(i) != "object")
            return i;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (r === "string" ? String : Number)(t2);
      }
      module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/toPropertyKey.js
  var require_toPropertyKey = __commonJS({
    "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports, module) {
      var _typeof2 = require_typeof()["default"];
      var toPrimitive = require_toPrimitive();
      function toPropertyKey(t2) {
        var i = toPrimitive(t2, "string");
        return _typeof2(i) == "symbol" ? i : String(i);
      }
      module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/createClass.js
  var require_createClass = __commonJS({
    "node_modules/@babel/runtime/helpers/createClass.js"(exports, module) {
      var toPropertyKey = require_toPropertyKey();
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
          writable: false
        });
        return Constructor;
      }
      module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/automation-events/build/es5/bundle.js
  var require_bundle = __commonJS({
    "node_modules/automation-events/build/es5/bundle.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_slicedToArray(), require_classCallCheck(), require_createClass()) : typeof define === "function" && define.amd ? define(["exports", "@babel/runtime/helpers/slicedToArray", "@babel/runtime/helpers/classCallCheck", "@babel/runtime/helpers/createClass"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.automationEvents = {}, global2._slicedToArray, global2._classCallCheck, global2._createClass));
      })(exports, function(exports2, _slicedToArray, _classCallCheck, _createClass) {
        "use strict";
        var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent2(value, endTime, insertTime) {
          return {
            endTime,
            insertTime,
            type: "exponentialRampToValue",
            value
          };
        };
        var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent2(value, endTime, insertTime) {
          return {
            endTime,
            insertTime,
            type: "linearRampToValue",
            value
          };
        };
        var createSetValueAutomationEvent2 = function createSetValueAutomationEvent3(value, startTime) {
          return {
            startTime,
            type: "setValue",
            value
          };
        };
        var createSetValueCurveAutomationEvent2 = function createSetValueCurveAutomationEvent3(values, startTime, duration) {
          return {
            duration,
            startTime,
            type: "setValueCurve",
            values
          };
        };
        var getTargetValueAtTime = function getTargetValueAtTime2(time, valueAtStartTime, _ref) {
          var startTime = _ref.startTime, target = _ref.target, timeConstant = _ref.timeConstant;
          return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);
        };
        var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent2(automationEvent) {
          return automationEvent.type === "exponentialRampToValue";
        };
        var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent2(automationEvent) {
          return automationEvent.type === "linearRampToValue";
        };
        var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent2(automationEvent) {
          return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);
        };
        var isSetValueAutomationEvent = function isSetValueAutomationEvent2(automationEvent) {
          return automationEvent.type === "setValue";
        };
        var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent2(automationEvent) {
          return automationEvent.type === "setValueCurve";
        };
        var getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime2(automationEvents, index3, time, defaultValue) {
          var automationEvent = automationEvents[index3];
          return automationEvent === void 0 ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime2(automationEvents, index3 - 1, automationEvent.startTime, defaultValue), automationEvent);
        };
        var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent2(automationEvents, index3, currentAutomationEvent, nextAutomationEvent, defaultValue) {
          return currentAutomationEvent === void 0 ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, getValueOfAutomationEventAtIndexAtTime(automationEvents, index3 - 1, currentAutomationEvent.startTime, defaultValue)];
        };
        var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent2(automationEvent) {
          return automationEvent.type === "cancelAndHold";
        };
        var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent2(automationEvent) {
          return automationEvent.type === "cancelScheduledValues";
        };
        var getEventTime = function getEventTime2(automationEvent) {
          if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {
            return automationEvent.cancelTime;
          }
          if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {
            return automationEvent.endTime;
          }
          return automationEvent.startTime;
        };
        var getExponentialRampValueAtTime = function getExponentialRampValueAtTime2(time, startTime, valueAtStartTime, _ref) {
          var endTime = _ref.endTime, value = _ref.value;
          if (valueAtStartTime === value) {
            return value;
          }
          if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {
            return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));
          }
          return 0;
        };
        var getLinearRampValueAtTime = function getLinearRampValueAtTime2(time, startTime, valueAtStartTime, _ref) {
          var endTime = _ref.endTime, value = _ref.value;
          return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);
        };
        var interpolateValue = function interpolateValue2(values, theoreticIndex) {
          var lowerIndex = Math.floor(theoreticIndex);
          var upperIndex = Math.ceil(theoreticIndex);
          if (lowerIndex === upperIndex) {
            return values[lowerIndex];
          }
          return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];
        };
        var getValueCurveValueAtTime = function getValueCurveValueAtTime2(time, _ref) {
          var duration = _ref.duration, startTime = _ref.startTime, values = _ref.values;
          var theoreticIndex = (time - startTime) / duration * (values.length - 1);
          return interpolateValue(values, theoreticIndex);
        };
        var isSetTargetAutomationEvent = function isSetTargetAutomationEvent2(automationEvent) {
          return automationEvent.type === "setTarget";
        };
        var AutomationEventList2 = /* @__PURE__ */ function(_Symbol$iterator) {
          function AutomationEventList3(defaultValue) {
            _classCallCheck(this, AutomationEventList3);
            this._automationEvents = [];
            this._currenTime = 0;
            this._defaultValue = defaultValue;
          }
          _createClass(AutomationEventList3, [{
            key: _Symbol$iterator,
            value: function value() {
              return this._automationEvents[Symbol.iterator]();
            }
          }, {
            key: "add",
            value: function add17(automationEvent) {
              var eventTime = getEventTime(automationEvent);
              if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {
                var index3 = this._automationEvents.findIndex(function(currentAutomationEvent) {
                  if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {
                    return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;
                  }
                  return getEventTime(currentAutomationEvent) >= eventTime;
                });
                var removedAutomationEvent = this._automationEvents[index3];
                if (index3 !== -1) {
                  this._automationEvents = this._automationEvents.slice(0, index3);
                }
                if (isCancelAndHoldAutomationEvent(automationEvent)) {
                  var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];
                  if (removedAutomationEvent !== void 0 && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {
                    if (lastAutomationEvent !== void 0 && isSetTargetAutomationEvent(lastAutomationEvent)) {
                      throw new Error("The internal list is malformed.");
                    }
                    var startTime = lastAutomationEvent === void 0 ? removedAutomationEvent.insertTime : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);
                    var startValue = lastAutomationEvent === void 0 ? this._defaultValue : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;
                    var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);
                    var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);
                    this._automationEvents.push(truncatedAutomationEvent);
                  }
                  if (lastAutomationEvent !== void 0 && isSetTargetAutomationEvent(lastAutomationEvent)) {
                    this._automationEvents.push(createSetValueAutomationEvent2(this.getValue(eventTime), eventTime));
                  }
                  if (lastAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {
                    var duration = eventTime - lastAutomationEvent.startTime;
                    var ratio = (lastAutomationEvent.values.length - 1) / lastAutomationEvent.duration;
                    var length = Math.max(2, 1 + Math.ceil(duration * ratio));
                    var fraction = duration / (length - 1) * ratio;
                    var values = lastAutomationEvent.values.slice(0, length);
                    if (fraction < 1) {
                      for (var i = 1; i < length; i += 1) {
                        var factor = fraction * i % 1;
                        values[i] = lastAutomationEvent.values[i - 1] * (1 - factor) + lastAutomationEvent.values[i] * factor;
                      }
                    }
                    this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent2(values, lastAutomationEvent.startTime, duration);
                  }
                }
              } else {
                var _index = this._automationEvents.findIndex(function(currentAutomationEvent) {
                  return getEventTime(currentAutomationEvent) > eventTime;
                });
                var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];
                if (previousAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {
                  return false;
                }
                var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;
                if (_index === -1) {
                  this._automationEvents.push(persistentAutomationEvent);
                } else {
                  if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {
                    return false;
                  }
                  this._automationEvents.splice(_index, 0, persistentAutomationEvent);
                }
              }
              return true;
            }
          }, {
            key: "flush",
            value: function flush(time) {
              var index3 = this._automationEvents.findIndex(function(currentAutomationEvent) {
                return getEventTime(currentAutomationEvent) > time;
              });
              if (index3 > 1) {
                var remainingAutomationEvents = this._automationEvents.slice(index3 - 1);
                var firstRemainingAutomationEvent = remainingAutomationEvents[0];
                if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {
                  remainingAutomationEvents.unshift(createSetValueAutomationEvent2(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index3 - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));
                }
                this._automationEvents = remainingAutomationEvents;
              }
            }
          }, {
            key: "getValue",
            value: function getValue(time) {
              if (this._automationEvents.length === 0) {
                return this._defaultValue;
              }
              var indexOfNextEvent = this._automationEvents.findIndex(function(automationEvent) {
                return getEventTime(automationEvent) > time;
              });
              var nextAutomationEvent = this._automationEvents[indexOfNextEvent];
              var indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;
              var currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];
              if (currentAutomationEvent !== void 0 && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {
                return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);
              }
              if (currentAutomationEvent !== void 0 && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {
                return currentAutomationEvent.value;
              }
              if (currentAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {
                if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {
                  return getValueCurveValueAtTime(time, currentAutomationEvent);
                }
                return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];
              }
              if (currentAutomationEvent !== void 0 && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {
                return currentAutomationEvent.value;
              }
              if (nextAutomationEvent !== void 0 && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {
                var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue), _getEndTimeAndValueOf2 = _slicedToArray(_getEndTimeAndValueOf, 2), startTime = _getEndTimeAndValueOf2[0], value = _getEndTimeAndValueOf2[1];
                return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);
              }
              if (nextAutomationEvent !== void 0 && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {
                var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue), _getEndTimeAndValueOf4 = _slicedToArray(_getEndTimeAndValueOf3, 2), _startTime = _getEndTimeAndValueOf4[0], _value = _getEndTimeAndValueOf4[1];
                return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);
              }
              return this._defaultValue;
            }
          }]);
          return AutomationEventList3;
        }(Symbol.iterator);
        var createCancelAndHoldAutomationEvent2 = function createCancelAndHoldAutomationEvent3(cancelTime) {
          return {
            cancelTime,
            type: "cancelAndHold"
          };
        };
        var createCancelScheduledValuesAutomationEvent2 = function createCancelScheduledValuesAutomationEvent3(cancelTime) {
          return {
            cancelTime,
            type: "cancelScheduledValues"
          };
        };
        var createExponentialRampToValueAutomationEvent2 = function createExponentialRampToValueAutomationEvent3(value, endTime) {
          return {
            endTime,
            type: "exponentialRampToValue",
            value
          };
        };
        var createLinearRampToValueAutomationEvent2 = function createLinearRampToValueAutomationEvent3(value, endTime) {
          return {
            endTime,
            type: "linearRampToValue",
            value
          };
        };
        var createSetTargetAutomationEvent2 = function createSetTargetAutomationEvent3(target, startTime, timeConstant) {
          return {
            startTime,
            target,
            timeConstant,
            type: "setTarget"
          };
        };
        exports2.AutomationEventList = AutomationEventList2;
        exports2.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent2;
        exports2.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent2;
        exports2.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent2;
        exports2.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent2;
        exports2.createSetTargetAutomationEvent = createSetTargetAutomationEvent2;
        exports2.createSetValueAutomationEvent = createSetValueAutomationEvent2;
        exports2.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent2;
      });
    }
  });

  // node_modules/dompurify/dist/purify.js
  var require_purify = __commonJS({
    "node_modules/dompurify/dist/purify.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.DOMPurify = factory());
      })(exports, function() {
        "use strict";
        function _toConsumableArray(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          } else {
            return Array.from(arr);
          }
        }
        var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var freeze = Object.freeze, seal = Object.seal, create = Object.create;
        var _ref = typeof Reflect !== "undefined" && Reflect, apply = _ref.apply, construct = _ref.construct;
        if (!apply) {
          apply = function apply2(fun, thisValue, args) {
            return fun.apply(thisValue, args);
          };
        }
        if (!freeze) {
          freeze = function freeze2(x) {
            return x;
          };
        }
        if (!seal) {
          seal = function seal2(x) {
            return x;
          };
        }
        if (!construct) {
          construct = function construct2(Func, args) {
            return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
          };
        }
        var arrayForEach = unapply(Array.prototype.forEach);
        var arrayPop = unapply(Array.prototype.pop);
        var arrayPush = unapply(Array.prototype.push);
        var stringToLowerCase = unapply(String.prototype.toLowerCase);
        var stringMatch = unapply(String.prototype.match);
        var stringReplace = unapply(String.prototype.replace);
        var stringIndexOf = unapply(String.prototype.indexOf);
        var stringTrim = unapply(String.prototype.trim);
        var regExpTest = unapply(RegExp.prototype.test);
        var typeErrorCreate = unconstruct(TypeError);
        function unapply(func) {
          return function(thisArg) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return apply(func, thisArg, args);
          };
        }
        function unconstruct(func) {
          return function() {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            return construct(func, args);
          };
        }
        function addToSet(set2, array) {
          if (setPrototypeOf) {
            setPrototypeOf(set2, null);
          }
          var l = array.length;
          while (l--) {
            var element = array[l];
            if (typeof element === "string") {
              var lcElement = stringToLowerCase(element);
              if (lcElement !== element) {
                if (!isFrozen(array)) {
                  array[l] = lcElement;
                }
                element = lcElement;
              }
            }
            set2[element] = true;
          }
          return set2;
        }
        function clone3(object) {
          var newObject = create(null);
          var property = void 0;
          for (property in object) {
            if (apply(hasOwnProperty, object, [property])) {
              newObject[property] = object[property];
            }
          }
          return newObject;
        }
        function lookupGetter(object, prop) {
          while (object !== null) {
            var desc = getOwnPropertyDescriptor(object, prop);
            if (desc) {
              if (desc.get) {
                return unapply(desc.get);
              }
              if (typeof desc.value === "function") {
                return unapply(desc.value);
              }
            }
            object = getPrototypeOf(object);
          }
          function fallbackValue(element) {
            console.warn("fallback value for", element);
            return null;
          }
          return fallbackValue;
        }
        var html = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
        var svg = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
        var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
        var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
        var mathMl = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
        var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
        var text = freeze(["#text"]);
        var html$1 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
        var svg$1 = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
        var mathMl$1 = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
        var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
        var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm);
        var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
        var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
        var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
        var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
        var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
        var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
        var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        function _toConsumableArray$1(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          } else {
            return Array.from(arr);
          }
        }
        var getGlobal = function getGlobal2() {
          return typeof window === "undefined" ? null : window;
        };
        var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
          if ((typeof trustedTypes === "undefined" ? "undefined" : _typeof2(trustedTypes)) !== "object" || typeof trustedTypes.createPolicy !== "function") {
            return null;
          }
          var suffix = null;
          var ATTR_NAME = "data-tt-policy-suffix";
          if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
            suffix = document2.currentScript.getAttribute(ATTR_NAME);
          }
          var policyName = "dompurify" + (suffix ? "#" + suffix : "");
          try {
            return trustedTypes.createPolicy(policyName, {
              createHTML: function createHTML(html$$1) {
                return html$$1;
              }
            });
          } catch (_) {
            console.warn("TrustedTypes policy " + policyName + " could not be created.");
            return null;
          }
        };
        function createDOMPurify() {
          var window3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
          var DOMPurify2 = function DOMPurify3(root) {
            return createDOMPurify(root);
          };
          DOMPurify2.version = "2.3.5";
          DOMPurify2.removed = [];
          if (!window3 || !window3.document || window3.document.nodeType !== 9) {
            DOMPurify2.isSupported = false;
            return DOMPurify2;
          }
          var originalDocument = window3.document;
          var document2 = window3.document;
          var DocumentFragment = window3.DocumentFragment, HTMLTemplateElement = window3.HTMLTemplateElement, Node2 = window3.Node, Element3 = window3.Element, NodeFilter = window3.NodeFilter, _window$NamedNodeMap = window3.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window3.NamedNodeMap || window3.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window3.HTMLFormElement, DOMParser = window3.DOMParser, trustedTypes = window3.trustedTypes;
          var ElementPrototype = Element3.prototype;
          var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
          var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
          var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
          var getParentNode = lookupGetter(ElementPrototype, "parentNode");
          if (typeof HTMLTemplateElement === "function") {
            var template = document2.createElement("template");
            if (template.content && template.content.ownerDocument) {
              document2 = template.content.ownerDocument;
            }
          }
          var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
          var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
          var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
          var importNode = originalDocument.importNode;
          var documentMode = {};
          try {
            documentMode = clone3(document2).documentMode ? document2.documentMode : {};
          } catch (_) {
          }
          var hooks = {};
          DOMPurify2.isSupported = typeof getParentNode === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
          var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR, ERB_EXPR$$1 = ERB_EXPR, DATA_ATTR$$1 = DATA_ATTR, ARIA_ATTR$$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
          var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;
          var ALLOWED_TAGS = null;
          var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));
          var ALLOWED_ATTR = null;
          var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));
          var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
            tagNameCheck: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: null
            },
            attributeNameCheck: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: null
            },
            allowCustomizedBuiltInElements: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: false
            }
          }));
          var FORBID_TAGS = null;
          var FORBID_ATTR = null;
          var ALLOW_ARIA_ATTR = true;
          var ALLOW_DATA_ATTR = true;
          var ALLOW_UNKNOWN_PROTOCOLS = false;
          var SAFE_FOR_TEMPLATES = false;
          var WHOLE_DOCUMENT = false;
          var SET_CONFIG = false;
          var FORCE_BODY = false;
          var RETURN_DOM = false;
          var RETURN_DOM_FRAGMENT = false;
          var RETURN_TRUSTED_TYPE = false;
          var SANITIZE_DOM = true;
          var KEEP_CONTENT = true;
          var IN_PLACE = false;
          var USE_PROFILES = {};
          var FORBID_CONTENTS = null;
          var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
          var DATA_URI_TAGS = null;
          var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
          var URI_SAFE_ATTRIBUTES = null;
          var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
          var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
          var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
          var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
          var NAMESPACE = HTML_NAMESPACE;
          var IS_EMPTY_INPUT = false;
          var PARSER_MEDIA_TYPE = void 0;
          var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
          var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
          var transformCaseFunc = void 0;
          var CONFIG = null;
          var formElement = document2.createElement("form");
          var isRegexOrFunction = function isRegexOrFunction2(testValue) {
            return testValue instanceof RegExp || testValue instanceof Function;
          };
          var _parseConfig = function _parseConfig2(cfg) {
            if (CONFIG && CONFIG === cfg) {
              return;
            }
            if (!cfg || (typeof cfg === "undefined" ? "undefined" : _typeof2(cfg)) !== "object") {
              cfg = {};
            }
            cfg = clone3(cfg);
            ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
            ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
            URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone3(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
            DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone3(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
            FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
            FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
            FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
            USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
            ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
            ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
            ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
            SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
            WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
            RETURN_DOM = cfg.RETURN_DOM || false;
            RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
            RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
            FORCE_BODY = cfg.FORCE_BODY || false;
            SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
            KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
            IN_PLACE = cfg.IN_PLACE || false;
            IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
            NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
            if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
              CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
            }
            if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
              CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
            }
            if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
              CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
            }
            PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
            transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x) {
              return x;
            } : stringToLowerCase;
            if (SAFE_FOR_TEMPLATES) {
              ALLOW_DATA_ATTR = false;
            }
            if (RETURN_DOM_FRAGMENT) {
              RETURN_DOM = true;
            }
            if (USE_PROFILES) {
              ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
              ALLOWED_ATTR = [];
              if (USE_PROFILES.html === true) {
                addToSet(ALLOWED_TAGS, html);
                addToSet(ALLOWED_ATTR, html$1);
              }
              if (USE_PROFILES.svg === true) {
                addToSet(ALLOWED_TAGS, svg);
                addToSet(ALLOWED_ATTR, svg$1);
                addToSet(ALLOWED_ATTR, xml);
              }
              if (USE_PROFILES.svgFilters === true) {
                addToSet(ALLOWED_TAGS, svgFilters);
                addToSet(ALLOWED_ATTR, svg$1);
                addToSet(ALLOWED_ATTR, xml);
              }
              if (USE_PROFILES.mathMl === true) {
                addToSet(ALLOWED_TAGS, mathMl);
                addToSet(ALLOWED_ATTR, mathMl$1);
                addToSet(ALLOWED_ATTR, xml);
              }
            }
            if (cfg.ADD_TAGS) {
              if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
                ALLOWED_TAGS = clone3(ALLOWED_TAGS);
              }
              addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
            }
            if (cfg.ADD_ATTR) {
              if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
                ALLOWED_ATTR = clone3(ALLOWED_ATTR);
              }
              addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
            }
            if (cfg.ADD_URI_SAFE_ATTR) {
              addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
            }
            if (cfg.FORBID_CONTENTS) {
              if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
                FORBID_CONTENTS = clone3(FORBID_CONTENTS);
              }
              addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
            }
            if (KEEP_CONTENT) {
              ALLOWED_TAGS["#text"] = true;
            }
            if (WHOLE_DOCUMENT) {
              addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
            }
            if (ALLOWED_TAGS.table) {
              addToSet(ALLOWED_TAGS, ["tbody"]);
              delete FORBID_TAGS.tbody;
            }
            if (freeze) {
              freeze(cfg);
            }
            CONFIG = cfg;
          };
          var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
          var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
          var ALL_SVG_TAGS = addToSet({}, svg);
          addToSet(ALL_SVG_TAGS, svgFilters);
          addToSet(ALL_SVG_TAGS, svgDisallowed);
          var ALL_MATHML_TAGS = addToSet({}, mathMl);
          addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
          var _checkValidNamespace = function _checkValidNamespace2(element) {
            var parent = getParentNode(element);
            if (!parent || !parent.tagName) {
              parent = {
                namespaceURI: HTML_NAMESPACE,
                tagName: "template"
              };
            }
            var tagName = stringToLowerCase(element.tagName);
            var parentTagName = stringToLowerCase(parent.tagName);
            if (element.namespaceURI === SVG_NAMESPACE) {
              if (parent.namespaceURI === HTML_NAMESPACE) {
                return tagName === "svg";
              }
              if (parent.namespaceURI === MATHML_NAMESPACE) {
                return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
              }
              return Boolean(ALL_SVG_TAGS[tagName]);
            }
            if (element.namespaceURI === MATHML_NAMESPACE) {
              if (parent.namespaceURI === HTML_NAMESPACE) {
                return tagName === "math";
              }
              if (parent.namespaceURI === SVG_NAMESPACE) {
                return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
              }
              return Boolean(ALL_MATHML_TAGS[tagName]);
            }
            if (element.namespaceURI === HTML_NAMESPACE) {
              if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
                return false;
              }
              if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
                return false;
              }
              var commonSvgAndHTMLElements = addToSet({}, ["title", "style", "font", "a", "script"]);
              return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
            }
            return false;
          };
          var _forceRemove = function _forceRemove2(node) {
            arrayPush(DOMPurify2.removed, { element: node });
            try {
              node.parentNode.removeChild(node);
            } catch (_) {
              try {
                node.outerHTML = emptyHTML;
              } catch (_2) {
                node.remove();
              }
            }
          };
          var _removeAttribute = function _removeAttribute2(name2, node) {
            try {
              arrayPush(DOMPurify2.removed, {
                attribute: node.getAttributeNode(name2),
                from: node
              });
            } catch (_) {
              arrayPush(DOMPurify2.removed, {
                attribute: null,
                from: node
              });
            }
            node.removeAttribute(name2);
            if (name2 === "is" && !ALLOWED_ATTR[name2]) {
              if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
                try {
                  _forceRemove(node);
                } catch (_) {
                }
              } else {
                try {
                  node.setAttribute(name2, "");
                } catch (_) {
                }
              }
            }
          };
          var _initDocument = function _initDocument2(dirty) {
            var doc2 = void 0;
            var leadingWhitespace = void 0;
            if (FORCE_BODY) {
              dirty = "<remove></remove>" + dirty;
            } else {
              var matches2 = stringMatch(dirty, /^[\r\n\t ]+/);
              leadingWhitespace = matches2 && matches2[0];
            }
            if (PARSER_MEDIA_TYPE === "application/xhtml+xml") {
              dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
            }
            var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
            if (NAMESPACE === HTML_NAMESPACE) {
              try {
                doc2 = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
              } catch (_) {
              }
            }
            if (!doc2 || !doc2.documentElement) {
              doc2 = implementation.createDocument(NAMESPACE, "template", null);
              try {
                doc2.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
              } catch (_) {
              }
            }
            var body = doc2.body || doc2.documentElement;
            if (dirty && leadingWhitespace) {
              body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
            }
            if (NAMESPACE === HTML_NAMESPACE) {
              return getElementsByTagName.call(doc2, WHOLE_DOCUMENT ? "html" : "body")[0];
            }
            return WHOLE_DOCUMENT ? doc2.documentElement : body;
          };
          var _createIterator = function _createIterator2(root) {
            return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
          };
          var _isClobbered = function _isClobbered2(elm) {
            return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function");
          };
          var _isNode = function _isNode2(object) {
            return (typeof Node2 === "undefined" ? "undefined" : _typeof2(Node2)) === "object" ? object instanceof Node2 : object && (typeof object === "undefined" ? "undefined" : _typeof2(object)) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
          };
          var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
            if (!hooks[entryPoint]) {
              return;
            }
            arrayForEach(hooks[entryPoint], function(hook) {
              hook.call(DOMPurify2, currentNode, data, CONFIG);
            });
          };
          var _sanitizeElements = function _sanitizeElements2(currentNode) {
            var content2 = void 0;
            _executeHook("beforeSanitizeElements", currentNode, null);
            if (_isClobbered(currentNode)) {
              _forceRemove(currentNode);
              return true;
            }
            if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
              _forceRemove(currentNode);
              return true;
            }
            var tagName = transformCaseFunc(currentNode.nodeName);
            _executeHook("uponSanitizeElement", currentNode, {
              tagName,
              allowedTags: ALLOWED_TAGS
            });
            if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
              _forceRemove(currentNode);
              return true;
            }
            if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
              _forceRemove(currentNode);
              return true;
            }
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
                var parentNode = getParentNode(currentNode) || currentNode.parentNode;
                var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
                if (childNodes && parentNode) {
                  var childCount = childNodes.length;
                  for (var i = childCount - 1; i >= 0; --i) {
                    parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
                  }
                }
              }
              if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
                  return false;
                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
                  return false;
              }
              _forceRemove(currentNode);
              return true;
            }
            if (currentNode instanceof Element3 && !_checkValidNamespace(currentNode)) {
              _forceRemove(currentNode);
              return true;
            }
            if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
              _forceRemove(currentNode);
              return true;
            }
            if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
              content2 = currentNode.textContent;
              content2 = stringReplace(content2, MUSTACHE_EXPR$$1, " ");
              content2 = stringReplace(content2, ERB_EXPR$$1, " ");
              if (currentNode.textContent !== content2) {
                arrayPush(DOMPurify2.removed, { element: currentNode.cloneNode() });
                currentNode.textContent = content2;
              }
            }
            _executeHook("afterSanitizeElements", currentNode, null);
            return false;
          };
          var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
            if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
              return false;
            }
            if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName))
              ;
            else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName))
              ;
            else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
              if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)))
                ;
              else {
                return false;
              }
            } else if (URI_SAFE_ATTRIBUTES[lcName])
              ;
            else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, "")))
              ;
            else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
              ;
            else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, "")))
              ;
            else if (!value)
              ;
            else {
              return false;
            }
            return true;
          };
          var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
            return tagName.indexOf("-") > 0;
          };
          var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
            var attr = void 0;
            var value = void 0;
            var lcName = void 0;
            var l = void 0;
            _executeHook("beforeSanitizeAttributes", currentNode, null);
            var attributes = currentNode.attributes;
            if (!attributes) {
              return;
            }
            var hookEvent = {
              attrName: "",
              attrValue: "",
              keepAttr: true,
              allowedAttributes: ALLOWED_ATTR
            };
            l = attributes.length;
            while (l--) {
              attr = attributes[l];
              var _attr = attr, name2 = _attr.name, namespaceURI = _attr.namespaceURI;
              value = stringTrim(attr.value);
              lcName = transformCaseFunc(name2);
              hookEvent.attrName = lcName;
              hookEvent.attrValue = value;
              hookEvent.keepAttr = true;
              hookEvent.forceKeepAttr = void 0;
              _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
              value = hookEvent.attrValue;
              if (hookEvent.forceKeepAttr) {
                continue;
              }
              _removeAttribute(name2, currentNode);
              if (!hookEvent.keepAttr) {
                continue;
              }
              if (regExpTest(/\/>/i, value)) {
                _removeAttribute(name2, currentNode);
                continue;
              }
              if (SAFE_FOR_TEMPLATES) {
                value = stringReplace(value, MUSTACHE_EXPR$$1, " ");
                value = stringReplace(value, ERB_EXPR$$1, " ");
              }
              var lcTag = transformCaseFunc(currentNode.nodeName);
              if (!_isValidAttribute(lcTag, lcName, value)) {
                continue;
              }
              try {
                if (namespaceURI) {
                  currentNode.setAttributeNS(namespaceURI, name2, value);
                } else {
                  currentNode.setAttribute(name2, value);
                }
                arrayPop(DOMPurify2.removed);
              } catch (_) {
              }
            }
            _executeHook("afterSanitizeAttributes", currentNode, null);
          };
          var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
            var shadowNode = void 0;
            var shadowIterator = _createIterator(fragment);
            _executeHook("beforeSanitizeShadowDOM", fragment, null);
            while (shadowNode = shadowIterator.nextNode()) {
              _executeHook("uponSanitizeShadowNode", shadowNode, null);
              if (_sanitizeElements(shadowNode)) {
                continue;
              }
              if (shadowNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM2(shadowNode.content);
              }
              _sanitizeAttributes(shadowNode);
            }
            _executeHook("afterSanitizeShadowDOM", fragment, null);
          };
          DOMPurify2.sanitize = function(dirty, cfg) {
            var body = void 0;
            var importedNode = void 0;
            var currentNode = void 0;
            var oldNode = void 0;
            var returnNode = void 0;
            IS_EMPTY_INPUT = !dirty;
            if (IS_EMPTY_INPUT) {
              dirty = "<!-->";
            }
            if (typeof dirty !== "string" && !_isNode(dirty)) {
              if (typeof dirty.toString !== "function") {
                throw typeErrorCreate("toString is not a function");
              } else {
                dirty = dirty.toString();
                if (typeof dirty !== "string") {
                  throw typeErrorCreate("dirty is not a string, aborting");
                }
              }
            }
            if (!DOMPurify2.isSupported) {
              if (_typeof2(window3.toStaticHTML) === "object" || typeof window3.toStaticHTML === "function") {
                if (typeof dirty === "string") {
                  return window3.toStaticHTML(dirty);
                }
                if (_isNode(dirty)) {
                  return window3.toStaticHTML(dirty.outerHTML);
                }
              }
              return dirty;
            }
            if (!SET_CONFIG) {
              _parseConfig(cfg);
            }
            DOMPurify2.removed = [];
            if (typeof dirty === "string") {
              IN_PLACE = false;
            }
            if (IN_PLACE) {
              if (dirty.nodeName) {
                var tagName = transformCaseFunc(dirty.nodeName);
                if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                  throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
                }
              }
            } else if (dirty instanceof Node2) {
              body = _initDocument("<!---->");
              importedNode = body.ownerDocument.importNode(dirty, true);
              if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
                body = importedNode;
              } else if (importedNode.nodeName === "HTML") {
                body = importedNode;
              } else {
                body.appendChild(importedNode);
              }
            } else {
              if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
                return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
              }
              body = _initDocument(dirty);
              if (!body) {
                return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
              }
            }
            if (body && FORCE_BODY) {
              _forceRemove(body.firstChild);
            }
            var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
            while (currentNode = nodeIterator.nextNode()) {
              if (currentNode.nodeType === 3 && currentNode === oldNode) {
                continue;
              }
              if (_sanitizeElements(currentNode)) {
                continue;
              }
              if (currentNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(currentNode.content);
              }
              _sanitizeAttributes(currentNode);
              oldNode = currentNode;
            }
            oldNode = null;
            if (IN_PLACE) {
              return dirty;
            }
            if (RETURN_DOM) {
              if (RETURN_DOM_FRAGMENT) {
                returnNode = createDocumentFragment.call(body.ownerDocument);
                while (body.firstChild) {
                  returnNode.appendChild(body.firstChild);
                }
              } else {
                returnNode = body;
              }
              if (ALLOWED_ATTR.shadowroot) {
                returnNode = importNode.call(originalDocument, returnNode, true);
              }
              return returnNode;
            }
            var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
            if (SAFE_FOR_TEMPLATES) {
              serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, " ");
              serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, " ");
            }
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
          };
          DOMPurify2.setConfig = function(cfg) {
            _parseConfig(cfg);
            SET_CONFIG = true;
          };
          DOMPurify2.clearConfig = function() {
            CONFIG = null;
            SET_CONFIG = false;
          };
          DOMPurify2.isValidAttribute = function(tag, attr, value) {
            if (!CONFIG) {
              _parseConfig({});
            }
            var lcTag = transformCaseFunc(tag);
            var lcName = transformCaseFunc(attr);
            return _isValidAttribute(lcTag, lcName, value);
          };
          DOMPurify2.addHook = function(entryPoint, hookFunction) {
            if (typeof hookFunction !== "function") {
              return;
            }
            hooks[entryPoint] = hooks[entryPoint] || [];
            arrayPush(hooks[entryPoint], hookFunction);
          };
          DOMPurify2.removeHook = function(entryPoint) {
            if (hooks[entryPoint]) {
              arrayPop(hooks[entryPoint]);
            }
          };
          DOMPurify2.removeHooks = function(entryPoint) {
            if (hooks[entryPoint]) {
              hooks[entryPoint] = [];
            }
          };
          DOMPurify2.removeAllHooks = function() {
            hooks = {};
          };
          return DOMPurify2;
        }
        var purify = createDOMPurify();
        return purify;
      });
    }
  });

  // static/js/index.ts
  var js_exports = {};
  __export(js_exports, {
    InitLineChart: () => InitLineChart,
    add_account_placeholder: () => add_account_placeholder,
    append_classname: () => append_classname,
    changeUserEmail: () => changeUserEmail,
    change_language: () => change_language,
    change_password_student: () => change_password_student,
    clearUnsavedChanges: () => clearUnsavedChanges,
    closeAchievement: () => closeAchievement,
    closeContainingModal: () => closeContainingModal,
    comeBackHereAfterLogin: () => comeBackHereAfterLogin,
    confetti_cannon: () => confetti_cannon,
    copy_join_link: () => copy_join_link,
    copy_to_clipboard: () => copy_to_clipboard,
    create_accounts: () => create_accounts,
    create_class: () => create_class,
    delete_adventure: () => delete_adventure,
    delete_class: () => delete_class,
    delete_program: () => delete_program,
    destroy: () => destroy2,
    destroy_public: () => destroy_public,
    downloadSlides: () => downloadSlides,
    duplicate_class: () => duplicate_class,
    edit_user_tags: () => edit_user_tags,
    enable_level: () => enable_level,
    error: () => error,
    filter_admin: () => filter_admin,
    generate_passwords: () => generate_passwords,
    getEditorContents: () => getEditorContents,
    getHighlighter: () => getHighlighter,
    getPreviousAndNext: () => getPreviousAndNext,
    get_active_and_trimmed_code: () => get_active_and_trimmed_code,
    goToLevel: () => goToLevel,
    hasUnsavedChanges: () => hasUnsavedChanges,
    hide_editor: () => hide_editor,
    incrementDebugLine: () => incrementDebugLine,
    initialize: () => initialize,
    initializeApp: () => initializeApp,
    initializeClassOverviewPage: () => initializeClassOverviewPage,
    initializeCodePage: () => initializeCodePage,
    initializeCustomizeClassPage: () => initializeCustomizeClassPage,
    initializeDebugger: () => initializeDebugger,
    initializeFormSubmits: () => initializeFormSubmits,
    initializeHighlightedCodeBlocks: () => initializeHighlightedCodeBlocks,
    initializeLoginLinks: () => initializeLoginLinks,
    initializeTeacherPage: () => initializeTeacherPage,
    initializeTutorial: () => initializeTutorial,
    initializeViewProgramPage: () => initializeViewProgramPage,
    invite_student: () => invite_student,
    join_class: () => join_class,
    loadParsonsExercise: () => loadParsonsExercise,
    load_quiz: () => load_quiz,
    load_variables: () => load_variables,
    logout: () => logout,
    logs: () => logs,
    markAsTeacher: () => markAsTeacher,
    markUnsavedChanges: () => markUnsavedChanges,
    modal: () => modal,
    modalStepOne: () => modalStepOne,
    preview_adventure: () => preview_adventure,
    pushAchievement: () => pushAchievement,
    remove_student: () => remove_student,
    remove_student_invite: () => remove_student_invite,
    rename_class: () => rename_class,
    report_program: () => report_program,
    request_teacher_account: () => request_teacher_account,
    resetDebug: () => resetDebug,
    resolve_student: () => resolve_student,
    restore_customization_to_default: () => restore_customization_to_default,
    runPythonProgram: () => runPythonProgram,
    runit: () => runit,
    saveMachineFiles: () => saveMachineFiles,
    save_customizations: () => save_customizations,
    select_profile_image: () => select_profile_image,
    setDateLevelInputColor: () => setDateLevelInputColor,
    set_explore_favourite: () => set_explore_favourite,
    set_favourite_program: () => set_favourite_program,
    share_program: () => share_program,
    showAchievements: () => showAchievements,
    showVariableView: () => showVariableView,
    show_doc_section: () => show_doc_section,
    show_editor: () => show_editor,
    show_variables: () => show_variables,
    sleep: () => sleep17,
    startDebug: () => startDebug,
    startIntroTutorial: () => startIntroTutorial,
    startLevelTutorial: () => startLevelTutorial,
    startTeacherTutorial: () => startTeacherTutorial,
    stopDebug: () => stopDebug,
    stopit: () => stopit,
    store_parsons_attempt: () => store_parsons_attempt,
    submit_program: () => submit_program,
    success: () => success,
    theGlobalDebugger: () => theGlobalDebugger,
    theGlobalEditor: () => theGlobalEditor,
    theGlobalSourcemap: () => theGlobalSourcemap,
    theKeywordLanguage: () => theKeywordLanguage,
    theLanguage: () => theLanguage2,
    theLevel: () => theLevel,
    theLocalSaveWarning: () => theLocalSaveWarning,
    theModalEditor: () => theModalEditor,
    toggleDevelopersMode: () => toggleDevelopersMode,
    toggle_blur_code: () => toggle_blur_code,
    toggle_keyword_language: () => toggle_keyword_language,
    toggle_show_students_class_overview: () => toggle_show_students_class_overview,
    triggerAutomaticSave: () => triggerAutomaticSave,
    tryCatchErrorBox: () => tryCatchErrorBox,
    tryCatchPopup: () => tryCatchPopup,
    tryPaletteCode: () => tryPaletteCode,
    update_adventure: () => update_adventure,
    update_user_tags: () => update_user_tags,
    viewProgramLink: () => viewProgramLink
  });

  // highlighting/highlighting.json
  var highlighting_default = [
    {
      name: "level1",
      rules: {
        start: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^ *)(__ask__)",
            token: [
              "text",
              "keyword"
            ],
            next: "value",
            unicode: true
          },
          {
            regex: "(^ *)(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "value",
            unicode: true
          },
          {
            regex: "(^ *)(__echo__)",
            token: [
              "text",
              "keyword"
            ],
            next: "value",
            unicode: true
          },
          {
            regex: "(^ *)(__play__)",
            token: [
              "text",
              "keyword"
            ],
            next: "value",
            unicode: true
          },
          {
            regex: "(^ *)(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "value",
            unicode: true
          },
          {
            regex: "(^ *)(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "direction",
            unicode: true
          },
          {
            regex: "(^ *)(__color__)",
            token: [
              "text",
              "keyword"
            ],
            next: "color",
            unicode: true
          }
        ],
        value: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "value"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "value"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          }
        ],
        color: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "color"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "color"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          },
          {
            regex: "(__black__|__gray__|__white__|__green__|__blue__|__purple__|__brown__|__pink__|__red__|__orange__|__yellow__)",
            token: [
              "text"
            ],
            unicode: true
          }
        ],
        direction: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "direction"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "direction"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          },
          {
            regex: "(__right__|__left__)",
            token: [
              "text"
            ],
            unicode: true
          }
        ]
      }
    },
    {
      name: "level2",
      rules: {
        start: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^ *)(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "value",
            unicode: true
          },
          {
            regex: "(^ *)([\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7]+)( +)(__is__)( +)(__ask__)",
            token: [
              "text",
              "text",
              "text",
              "keyword",
              "text",
              "keyword"
            ],
            next: "value",
            unicode: true
          },
          {
            regex: "(^ *)([\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7]+)( +)(__is__)",
            token: [
              "text",
              "text",
              "text",
              "keyword"
            ],
            next: "value",
            unicode: true
          },
          {
            regex: "(^ *)(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "value",
            unicode: true
          },
          {
            regex: "(^ *)(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "value",
            unicode: true
          },
          {
            regex: "(^ *)(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "value",
            unicode: true
          },
          {
            regex: "(^ *)(__color__)",
            token: [
              "text",
              "keyword"
            ],
            next: "value",
            unicode: true
          }
        ],
        value: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "value"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "value"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          },
          {
            regex: "(__black__|__blue__|__brown__|__gray__|__green__|__orange__|__pink__|__purple__|__red__|__white__|__yellow__)",
            token: [
              "text"
            ],
            unicode: true
          }
        ]
      }
    },
    {
      name: "level3",
      rules: {
        start: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^ *)([\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7]+)( +)(__is__)( *)(__ask__)",
            token: [
              "text",
              "text",
              "text",
              "keyword",
              "text",
              "keyword"
            ],
            next: "valueExpr",
            unicode: true
          },
          {
            regex: "(^ *)([\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7]+)( +)(__is__)",
            token: [
              "text",
              "text",
              "text",
              "keyword"
            ],
            next: "value",
            unicode: true
          },
          {
            regex: "(^ *)(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "valueExpr",
            unicode: true
          },
          {
            regex: "(^ *)(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "valueExpr",
            unicode: true
          },
          {
            regex: "(^ *)(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "valueExpr",
            unicode: true
          },
          {
            regex: "(^ *)(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "valueExpr",
            unicode: true
          },
          {
            regex: "(^ *)(__add__)",
            token: [
              "text",
              "keyword"
            ],
            next: "valAdd",
            unicode: true
          },
          {
            regex: "(^ *)(__remove__)",
            token: [
              "text",
              "keyword"
            ],
            next: "valRemove",
            unicode: true
          },
          {
            regex: "(^ *)(__color__)",
            token: [
              "text",
              "keyword"
            ],
            next: "value",
            unicode: true
          }
        ],
        value: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "value"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "value"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          },
          {
            regex: "(^| )(__at__)( +)(__random__)",
            token: [
              "text",
              "keyword",
              "keyword",
              "keyword"
            ],
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            unicode: true
          },
          {
            regex: "(__comma__)",
            token: [
              "keyword"
            ],
            unicode: true
          },
          {
            regex: "(__black__|__blue__|__brown__|__gray__|__green__|__orange__|__pink__|__purple__|__red__|__white__|__yellow__)",
            token: [
              "text"
            ],
            unicode: true
          }
        ],
        valueExpr: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "valueExpr"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "valueExpr"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          },
          {
            regex: "(^| )(__at__)( +)(__random__)",
            token: [
              "text",
              "keyword",
              "keyword",
              "keyword"
            ],
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            unicode: true
          }
        ],
        valAdd: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "valAdd"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "valAdd"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          },
          {
            regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "valueTo",
            unicode: true
          },
          {
            regex: "(__black__|__blue__|__brown__|__gray__|__green__|__orange__|__pink__|__purple__|__red__|__white__|__yellow__)",
            token: [
              "text"
            ],
            unicode: true
          }
        ],
        valueTo: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "valueTo"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "valueTo"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          }
        ],
        valRemove: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "valRemove"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "valRemove"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          },
          {
            regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "valueFrom",
            unicode: true
          },
          {
            regex: "(__black__|__blue__|__brown__|__gray__|__green__|__orange__|__pink__|__purple__|__red__|__white__|__yellow__)",
            token: [
              "text"
            ],
            unicode: true
          }
        ],
        valueFrom: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "valueFrom"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "valueFrom"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          }
        ]
      }
    },
    {
      name: "level4",
      rules: {
        start: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^ *)([\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7]+)( +)(__is__)( *)(__ask__)",
            token: [
              "text",
              "text",
              "text",
              "keyword",
              "text",
              "keyword"
            ],
            next: "valueExpr",
            unicode: true
          },
          {
            regex: "(^ *)([\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7]+)( +)(__is__)",
            token: [
              "text",
              "text",
              "text",
              "keyword"
            ],
            next: "value",
            unicode: true
          },
          {
            regex: "(^ *)(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "valueExpr",
            unicode: true
          },
          {
            regex: "(^ *)(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "valueSimple",
            unicode: true
          },
          {
            regex: "(^ *)(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "valueSimple",
            unicode: true
          },
          {
            regex: "(^ *)(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "valueSimple",
            unicode: true
          },
          {
            regex: "(^ *)(__color__)",
            token: [
              "text",
              "keyword"
            ],
            next: "valueSimple",
            unicode: true
          },
          {
            regex: "(^ *)(__add__)",
            token: [
              "text",
              "keyword"
            ],
            next: "valAdd",
            unicode: true
          },
          {
            regex: "(^ *)(__remove__)",
            token: [
              "text",
              "keyword"
            ],
            next: "valRemove",
            unicode: true
          },
          {
            regex: "(^ *)(__clear__)",
            token: [
              "text",
              "event"
            ],
            unicode: true
          }
        ],
        value: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "value"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "value"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          },
          {
            regex: "(^| )(__at__)( +)(__random__)",
            token: [
              "text",
              "keyword",
              "keyword",
              "keyword"
            ],
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            unicode: true
          },
          {
            regex: "(__comma__)",
            token: [
              "keyword"
            ],
            unicode: true
          },
          {
            regex: "(__black__|__blue__|__brown__|__gray__|__green__|__orange__|__pink__|__purple__|__red__|__white__|__yellow__)",
            token: [
              "text"
            ],
            unicode: true
          }
        ],
        valueExpr: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "valueExpr"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "valueExpr"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          },
          {
            regex: "(^| )(__at__)( +)(__random__)",
            token: [
              "text",
              "keyword",
              "keyword",
              "keyword"
            ],
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            unicode: true
          },
          {
            regex: '"[^"]*"',
            token: "constant.character",
            unicode: true
          },
          {
            regex: "'[^']*'",
            token: "constant.character",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*\xBB",
            token: "constant.character",
            unicode: true
          },
          {
            regex: '"[^"]*$',
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*$",
            token: "text",
            next: "start",
            unicode: true
          }
        ],
        valueSimple: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "valueSimple"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "valueSimple"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          },
          {
            regex: "(^| )(__at__)( +)(__random__)",
            token: [
              "text",
              "keyword",
              "keyword",
              "keyword"
            ],
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            unicode: true
          },
          {
            regex: "(__black__|__blue__|__brown__|__gray__|__green__|__orange__|__pink__|__purple__|__red__|__white__|__yellow__)",
            token: [
              "text"
            ],
            unicode: true
          }
        ],
        valAdd: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "valAdd"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "valAdd"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          },
          {
            regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "valueTo",
            unicode: true
          },
          {
            regex: "(__black__|__blue__|__brown__|__gray__|__green__|__orange__|__pink__|__purple__|__red__|__white__|__yellow__)",
            token: [
              "text"
            ],
            unicode: true
          }
        ],
        valueTo: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "valueTo"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "valueTo"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          }
        ],
        valRemove: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "valRemove"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "valRemove"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          },
          {
            regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "valueFrom",
            unicode: true
          },
          {
            regex: "(__black__|__blue__|__brown__|__gray__|__green__|__orange__|__pink__|__purple__|__red__|__white__|__yellow__)",
            token: [
              "text"
            ],
            unicode: true
          }
        ],
        valueFrom: [
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "valueFrom"
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "valueFrom"
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start"
          },
          {
            regex: "(^|$)",
            token: [
              "text"
            ],
            next: "start"
          }
        ]
      }
    },
    {
      name: "level5",
      rules: {
        start: [
          {
            regex: "(^| )(__is__)( +)(__ask__)",
            token: [
              "text",
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*"',
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*'",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*\xBB",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*$',
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          }
        ]
      }
    },
    {
      name: "level6",
      rules: {
        start: [
          {
            regex: "(^| )(__is__)( +)(__ask__)",
            token: [
              "text",
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "(=)( +)(__ask__)",
            token: [
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*"',
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*'",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*\xBB",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*$',
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          }
        ]
      }
    },
    {
      name: "level7",
      rules: {
        start: [
          {
            regex: "(^| )(__is__)( +)(__ask__)",
            token: [
              "text",
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "(=)( +)(__ask__)",
            token: [
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*"',
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*'",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*\xBB",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*$',
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          }
        ]
      }
    },
    {
      name: "level8",
      rules: {
        start: [
          {
            regex: "(^| )(__is__)( +)(__ask__)",
            token: [
              "text",
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "(=)( +)(__ask__)",
            token: [
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*"',
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*'",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*\xBB",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*$',
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          }
        ]
      }
    },
    {
      name: "level9",
      rules: {
        start: [
          {
            regex: "(^| )(__is__)( +)(__ask__)",
            token: [
              "text",
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "(=)( +)(__ask__)",
            token: [
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*"',
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*'",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*\xBB",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*$',
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          }
        ]
      }
    },
    {
      name: "level10",
      rules: {
        start: [
          {
            regex: "(^| )(__is__)( +)(__ask__)",
            token: [
              "text",
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "(=)( +)(__ask__)",
            token: [
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*"',
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*'",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*\xBB",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*$',
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          }
        ]
      }
    },
    {
      name: "level11",
      rules: {
        start: [
          {
            regex: "(^| )(__is__)( +)(__ask__)",
            token: [
              "text",
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "(=)( +)(__ask__)",
            token: [
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*"',
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*'",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*\xBB",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*$',
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__range__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          }
        ]
      }
    },
    {
      name: "level12",
      rules: {
        start: [
          {
            regex: "(^| )(__is__)( +)(__ask__)",
            token: [
              "text",
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "(=)( +)(__ask__)",
            token: [
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*"',
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*'",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*\xBB",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*$',
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__range__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__define__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "support.function"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__call__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "support.function"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__with__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__return__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          }
        ]
      }
    },
    {
      name: "level13",
      rules: {
        start: [
          {
            regex: "(^| )(__is__)( +)(__ask__)",
            token: [
              "text",
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "(=)( +)(__ask__)",
            token: [
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*"',
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*'",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*\xBB",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*$',
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__range__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__and__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__or__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__define__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "support.function"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__call__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "support.function"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__with__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__return__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          }
        ]
      }
    },
    {
      name: "level14",
      rules: {
        start: [
          {
            regex: "(^| )(__is__)( +)(__ask__)",
            token: [
              "text",
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "(=)( +)(__ask__)",
            token: [
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*"',
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*'",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*\xBB",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*$',
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(<)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(>)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(!)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__range__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__and__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__or__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__define__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "support.function"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__call__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "support.function"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__with__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__return__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(<)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(>)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(!)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          }
        ]
      }
    },
    {
      name: "level15",
      rules: {
        start: [
          {
            regex: "(^| )(__is__)( +)(__ask__)",
            token: [
              "text",
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "(=)( +)(__ask__)",
            token: [
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*"',
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*'",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*\xBB",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*$',
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(<)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(>)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(!)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__range__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__and__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__or__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__while__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__define__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "support.function"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__call__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "support.function"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__with__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__return__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(<)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(>)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(!)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          }
        ]
      }
    },
    {
      name: "level16",
      rules: {
        start: [
          {
            regex: "(^| )(__is__)( +)(__ask__)",
            token: [
              "text",
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "(=)( +)(__ask__)",
            token: [
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*"',
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*'",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*\xBB",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*$',
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(<)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(>)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(!)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\[)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\])([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__range__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__and__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__or__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__while__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__define__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "support.function"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__call__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "support.function"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__with__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__return__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(<)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(>)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(!)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\[)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\])",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          }
        ]
      }
    },
    {
      name: "level17",
      rules: {
        start: [
          {
            regex: "(^| )(__is__)( +)(__ask__)",
            token: [
              "text",
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "(=)( +)(__ask__)",
            token: [
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*"',
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*'",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*\xBB",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*$',
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(<)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(>)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(!)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\[)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\])([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(:)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__range__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__and__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__or__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__while__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__define__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "support.function"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__call__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "support.function"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__with__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__return__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(<)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(>)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(!)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\[)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\])",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(:)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__elif__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          }
        ]
      }
    },
    {
      name: "level18",
      rules: {
        start: [
          {
            regex: "(^| )(__is__)( +)(__ask__)",
            token: [
              "text",
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "(=)( +)(__ask__)",
            token: [
              "keyword",
              "text",
              "keyword"
            ]
          },
          {
            regex: "#.*$",
            token: "comment",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*"',
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*'",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*\xBB",
            token: "constant.character",
            next: "start",
            unicode: true
          },
          {
            regex: '"[^"]*$',
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "'[^']*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "\xAB[^\xBB]*$",
            token: "text",
            next: "start",
            unicode: true
          },
          {
            regex: "_\\?_",
            token: "invalid",
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(_)(?= |$)",
            token: [
              "text",
              "invalid"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(<)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(>)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(!)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\[)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\])([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(:)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\()([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\))([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword",
              "variable"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__else__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__range__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__to__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__and__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__or__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__while__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__input__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__def__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "support.function"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__return__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__comma__)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(-)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(=)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(/)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\*)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\+)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(<)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(>)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(!)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\[)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\])",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(:)",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\()",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(\\))",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__print__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__sleep__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__forward__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__turn__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__random__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__times__)",
            token: [
              "text",
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(__elif__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "keyword"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "text"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          },
          {
            regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
            token: [
              "text",
              "event"
            ],
            next: "start",
            unicode: true
          }
        ]
      }
    }
  ];

  // highlighting/highlighting-trad.json
  var ar = {
    add: "\u0640*\u0627\u0640*\u0636\u0640*\u0641\u0640*|add",
    and: "\u0640*\u0648\u0640*|and",
    ask: "\u0640*\u0627\u0640*\u0633\u0640*\u0623\u0640*\u0644\u0640*|ask",
    at: "\u0640*\u0628\u0640*\u0634\u0640*\u0643\u0640*\u0644\u0640*|at",
    black: "\u0640*\u0627\u0640*\u0633\u0640*\u0648\u0640*\u062F\u0640*|black",
    blue: "\u0640*\u0627\u0640*\u0632\u0640*\u0631\u0640*\u0642\u0640*|blue",
    brown: "\u0640*\u0628\u0640*\u0646\u0640*\u064A\u0640*|brown",
    call: "\u0640*c\u0640*a\u0640*l\u0640*l\u0640*|call",
    clear: "\u0640*c\u0640*l\u0640*e\u0640*a\u0640*r\u0640*|clear",
    color: "\u0640*\u0644\u0640*\u0648\u0640*\u0646\u0640*|color",
    comma: "\u0640*\u060C\u0640*|,",
    def: "\u0640*d\u0640*e\u0640*f\u0640*|def",
    define: "\u0640*d\u0640*e\u0640*f\u0640*i\u0640*n\u0640*e\u0640*|define",
    echo: "\u0640*\u0631\u0640*\u062F\u0640*\u062F\u0640*|echo",
    elif: "\u0640*\u0648\u0640*\u0625\u0640*\u0644\u0640*\u0627\u0640* \u0640*\u0627\u0640*\u0630\u0640*\u0627\u0640*|elif",
    else: "\u0640*\u0648\u0640*\u0625\u0640*\u0644\u0640*\u0627\u0640*|else",
    for: "\u0640*\u0644\u0640*\u0643\u0640*\u0644\u0640*|for",
    forward: "\u0640*\u062A\u0640*\u0642\u0640*\u062F\u0640*\u0645\u0640*|forward",
    from: "\u0640*\u0645\u0640*\u0646\u0640*|from",
    gray: "\u0640*\u0631\u0640*\u0645\u0640*\u0627\u0640*\u062F\u0640*\u064A\u0640*|gray",
    green: "\u0640*\u0627\u0640*\u062E\u0640*\u0636\u0640*\u0631\u0640*|green",
    if: "\u0640*\u0627\u0640*\u0630\u0640*\u0627\u0640*|if",
    in: "\u0640*\u0641\u0640*\u064A\u0640*|in",
    input: "\u0640*\u0627\u0640*\u062F\u0640*\u062E\u0640*\u0644\u0640*|input",
    is: "\u0640*\u0647\u0640*\u0648\u0640*|\u0640*\u0647\u0640*\u064A\u0640*|is",
    left: "\u0640*\u064A\u0640*\u0633\u0640*\u0627\u0640*\u0631\u0640*|left",
    length: "\u0640*\u0637\u0640*\u0648\u0640*\u0644\u0640*|length",
    or: "\u0640*\u0623\u0640*\u0648\u0640*|or",
    orange: "\u0640*\u0628\u0640*\u0631\u0640*\u062A\u0640*\u0642\u0640*\u0627\u0640*\u0644\u0640*\u064A\u0640*|orange",
    pink: "\u0640*\u0632\u0640*\u0647\u0640*\u0631\u0640*\u064A\u0640*|pink",
    play: "\u0640*p\u0640*l\u0640*a\u0640*y\u0640*|play",
    pressed: "\u0640*p\u0640*r\u0640*e\u0640*s\u0640*s\u0640*e\u0640*d\u0640*|pressed",
    print: "\u0640*\u0642\u0640*\u0648\u0640*\u0644\u0640*|print",
    purple: "\u0640*\u0628\u0640*\u0646\u0640*\u0641\u0640*\u0633\u0640*\u062C\u0640*\u064A\u0640*|purple",
    random: "\u0640*\u0639\u0640*\u0634\u0640*\u0648\u0640*\u0627\u0640*\u0626\u0640*\u064A\u0640*|random",
    range: "\u0640*\u0646\u0640*\u0637\u0640*\u0627\u0640*\u0642\u0640*|range",
    red: "\u0640*\u0627\u0640*\u062D\u0640*\u0645\u0640*\u0631\u0640*|red",
    remove: "\u0640*\u0627\u0640*\u0632\u0640*\u0644\u0640*|remove",
    repeat: "\u0640*\u0643\u0640*\u0631\u0640*\u0631\u0640*|repeat",
    return: "\u0640*r\u0640*e\u0640*t\u0640*u\u0640*r\u0640*n\u0640*|return",
    right: "\u0640*\u064A\u0640*\u0645\u0640*\u064A\u0640*\u0646\u0640*|right",
    sleep: "\u0640*\u0627\u0640*\u0646\u0640*\u062A\u0640*\u0638\u0640*\u0631\u0640*|sleep",
    step: "\u0640*\u062E\u0640*\u0637\u0640*\u0648\u0640*\u0629\u0640*|step",
    times: "\u0640*\u0645\u0640*\u0631\u0640*\u0629\u0640*|times",
    to: "\u0640*\u0627\u0640*\u0644\u0640*\u0649\u0640*|to",
    to_list: "\u0640*\u0627\u0640*\u0644\u0640*\u0649\u0640*|to",
    turn: "\u0640*\u0627\u0640*\u0633\u0640*\u062A\u0640*\u062F\u0640*\u0631\u0640*|turn",
    while: "\u0640*\u0628\u0640*\u064A\u0640*\u0646\u0640*\u0645\u0640*\u0627\u0640*|while",
    white: "\u0640*\u0627\u0640*\u0628\u0640*\u064A\u0640*\u0636\u0640*|white",
    with: "\u0640*w\u0640*i\u0640*t\u0640*h\u0640*|with",
    yellow: "\u0640*\u0627\u0640*\u0635\u0640*\u0641\u0640*\u0631\u0640*|yellow",
    DIGIT: "0\u06601\u06612\u06623\u06634\u06645\u06656\u06667\u06678\u06689\u0669"
  };
  var bg = {
    add: "\u0434\u043E\u0431\u0430\u0432\u0438|add",
    and: "\u0438|and",
    ask: "\u043F\u043E\u043F\u0438\u0442\u0430\u0439|ask",
    at: "\u0432|at",
    black: "\u0447\u0435\u0440\u043D\u043E|black",
    blue: "\u0441\u0438\u043D\u044C\u043E|blue",
    brown: "\u043A\u0430\u0444\u044F\u0432\u043E|brown",
    call: "\u0438\u0437\u0432\u0438\u043A\u0430\u0439|call",
    clear: "\u0438\u0437\u0447\u0438\u0441\u0442\u0438|clear",
    color: "\u0446\u0432\u044F\u0442|color",
    comma: ",",
    def: "\u0434\u0435\u0444|def",
    define: "\u0434\u0435\u0444\u0438\u043D\u0438\u0440\u0430\u0439|define",
    echo: "\u043F\u043E\u043A\u0430\u0436\u0438|echo",
    elif: "\u0438\u043D\u0430\u0447\u0435 \u0430\u043A\u043E|elif",
    else: "\u0438\u043D\u0430\u0447\u0435|else",
    for: "\u0437\u0430|for",
    forward: "\u043D\u0430\u043F\u0440\u0435\u0434|forward",
    from: "\u043E\u0442|from",
    gray: "\u0441\u0438\u0432\u043E|gray",
    green: "\u0437\u0435\u043B\u0435\u043D\u043E|green",
    if: "\u0430\u043A\u043E|if",
    in: "\u0432|in",
    input: "\u0432\u044A\u0432\u0435\u0436\u0434\u0430\u043D\u0435|input",
    is: "\u0435|is",
    left: "\u043B\u044F\u0432\u043E|left",
    length: "\u0434\u044A\u043B\u0436\u0438\u043D\u0430|length",
    or: "\u0438\u043B\u0438|or",
    orange: "\u043E\u0440\u0430\u043D\u0436\u0435\u0432\u043E|orange",
    pink: "\u0440\u043E\u0437\u043E\u0432\u043E|pink",
    play: "play",
    pressed: "\u043D\u0430\u0442\u0438\u0441\u043D\u0430\u0442|pressed",
    print: "\u043F\u0440\u0438\u043D\u0442\u0438\u0440\u0430\u0439|print",
    purple: "\u043B\u0438\u043B\u0430\u0432\u043E|purple",
    random: "\u043F\u0440\u043E\u0438\u0437\u0432\u043E\u043B\u043D\u043E|random",
    range: "\u043E\u0431\u0445\u0432\u0430\u0442|range",
    red: "\u0447\u0435\u0440\u0432\u0435\u043D\u043E|red",
    remove: "\u043F\u0440\u0435\u043C\u0430\u0445\u043D\u0438|remove",
    repeat: "\u043F\u043E\u0432\u0442\u043E\u0440\u0438|repeat",
    return: "\u0432\u044A\u0440\u043D\u0438|return",
    right: "\u0434\u044F\u0441\u043D\u043E|right",
    sleep: "\u0441\u043F\u0438|sleep",
    step: "\u0441\u0442\u044A\u043F\u043A\u0430|step",
    times: "\u043F\u044A\u0442\u0438|times",
    to: "\u0434\u043E|to",
    to_list: "\u0434\u043E|to",
    turn: "\u0437\u0430\u0432\u0438\u0439|turn",
    while: "\u0434\u043E\u043A\u0430\u0442\u043E|while",
    white: "\u0431\u044F\u043B\u043E|white",
    with: "\u0441/\u0441\u044A\u0441|with",
    yellow: "\u0436\u044A\u043B\u0442\u043E|yellow",
    DIGIT: "0123456789"
  };
  var bn = {
    add: "add",
    and: "and",
    ask: "ask",
    at: "at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "forward",
    from: "from",
    gray: "gray",
    green: "green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "left",
    length: "length",
    or: "or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "print",
    purple: "purple",
    random: "random",
    range: "range",
    red: "red",
    remove: "remove",
    repeat: "repeat",
    return: "return",
    right: "right",
    sleep: "sleep",
    step: "step",
    times: "times",
    to: "to",
    to_list: "to",
    turn: "turn",
    while: "while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var ca = {
    add: "afegeix|add",
    and: "i|and",
    ask: "pregunta|ask",
    at: "a|at",
    black: "negre|black",
    blue: "blau|blue",
    brown: "marr\xF3|brown",
    call: "crida|call",
    clear: "neteja|clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "defineix|define",
    echo: "eco|echo",
    elif: "sinosi|elif",
    else: "sino|else",
    for: "per|for",
    forward: "avan\xE7a|forward",
    from: "de|from",
    gray: "gris|gray",
    green: "verd|green",
    if: "si|if",
    in: "dins|in",
    input: "entra|input",
    is: "\xE9s|is",
    left: "esquerra|left",
    length: "mida|length",
    or: "o|or",
    orange: "taronja|orange",
    pink: "rosa|pink",
    play: "play",
    pressed: "pressionat|pressed",
    print: "imprimeix|print",
    purple: "lila|purple",
    random: "aleatori|random",
    range: "rang|range",
    red: "vermell|red",
    remove: "esborra|remove",
    repeat: "repeteix|repeat",
    return: "retorna|return",
    right: "dreta|right",
    sleep: "dorm|sleep",
    step: "pas|step",
    times: "vegades|times",
    to: "fins|to",
    to_list: "a|to",
    turn: "gira|turn",
    while: "mentre|while",
    white: "blanc|white",
    with: "amb|with",
    yellow: "groc|yellow",
    DIGIT: "0123456789"
  };
  var cs = {
    add: "add",
    and: "and",
    ask: "ask",
    at: "at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "forward",
    from: "from",
    gray: "gray",
    green: "green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "left",
    length: "length",
    or: "or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "print",
    purple: "purple",
    random: "random",
    range: "range",
    red: "red",
    remove: "remove",
    repeat: "repeat",
    return: "return",
    right: "right",
    sleep: "sleep",
    step: "step",
    times: "times",
    to: "to",
    to_list: "to",
    turn: "turn",
    while: "while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var cy = {
    add: "adio|add",
    and: "a|and",
    ask: "gofyn|ask",
    at: "ar|at",
    black: "du|black",
    blue: "glas|blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "lliw|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "adleisio|echo",
    elif: "elif",
    else: "arall|else",
    for: "ar gyfer|for",
    forward: "ymlaen|forward",
    from: "o|from",
    gray: "llwyd|gray",
    green: "gwyrdd|green",
    if: "os|if",
    in: "mewn|in",
    input: "mewnbwn|input",
    is: "yw|is",
    left: "chwith|left",
    length: "hyd|length",
    or: "neu|or",
    orange: "oren|orange",
    pink: "pinc|pink",
    play: "play",
    pressed: "gwasgu|pressed",
    print: "argraffu|print",
    purple: "porffor|purple",
    random: "hap|random",
    range: "ystod|range",
    red: "coch|red",
    remove: "dileu|remove",
    repeat: "ailadrodd|repeat",
    return: "return",
    right: "dde|right",
    sleep: "cysgu|sleep",
    step: "cam|step",
    times: "gwaith|times",
    to: "i|to",
    to_list: "i|to",
    turn: "troi|turn",
    while: "tra|while",
    white: "gwyn|white",
    with: "with",
    yellow: "melyn|yellow",
    DIGIT: "0123456789"
  };
  var da = {
    add: "add",
    and: "and",
    ask: "sp\xF8rg|ask",
    at: "at",
    black: "sort|black",
    blue: "bl\xE5|blue",
    brown: "brun|brown",
    call: "call",
    clear: "clear",
    color: "farve|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "ekko|echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "fremad|forward",
    from: "from",
    gray: "gr\xE5|gray",
    green: "gr\xF8n|green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "left",
    length: "length",
    or: "or",
    orange: "orange",
    pink: "lyser\xF8d|pink",
    play: "play",
    pressed: "pressed",
    print: "print",
    purple: "lila|purple",
    random: "random",
    range: "range",
    red: "red",
    remove: "remove",
    repeat: "repeat",
    return: "return",
    right: "right",
    sleep: "sleep",
    step: "step",
    times: "times",
    to: "to",
    to_list: "to",
    turn: "drej|turn",
    while: "while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var de = {
    add: "addiere|add",
    and: "und|and",
    ask: "frage|ask",
    at: "an|at",
    black: "Schwarz|black",
    blue: "Blau|blue",
    brown: "Braun|brown",
    call: "call",
    clear: "abwischen|clear",
    color: "farbe|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "echo",
    elif: "sofalls|elif",
    else: "sonst|else",
    for: "f\xFCr|for",
    forward: "vorw\xE4rts|forward",
    from: "aus|from",
    gray: "Grau|gray",
    green: "Gr\xFCn|green",
    if: "falls|if",
    in: "in",
    input: "eingabe|input",
    is: "ist|is",
    left: "links|left",
    length: "l\xE4nge|length",
    or: "oder|or",
    orange: "Orange|orange",
    pink: "Pink|pink",
    play: "play",
    pressed: "gedr\xFCckt|pressed",
    print: "drucke|print",
    purple: "Lila|purple",
    random: "zuf\xE4llig|random",
    range: "bereich|range",
    red: "Rot|red",
    remove: "entferne|remove",
    repeat: "wiederhole|repeat",
    return: "return",
    right: "rechts|right",
    sleep: "schlafe|sleep",
    step: "schritt|step",
    times: "mal|times",
    to: "bis|to",
    to_list: "zu|to",
    turn: "drehe|turn",
    while: "solange|while",
    white: "Wei\xDF|white",
    with: "with",
    yellow: "Gelb|yellow",
    DIGIT: "0123456789"
  };
  var el = {
    add: "add",
    and: "and",
    ask: "ask",
    at: "at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "forward",
    from: "from",
    gray: "gray",
    green: "green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "left",
    length: "length",
    or: "or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "print",
    purple: "purple",
    random: "random",
    range: "range",
    red: "red",
    remove: "remove",
    repeat: "repeat",
    return: "return",
    right: "right",
    sleep: "sleep",
    step: "step",
    times: "times",
    to: "to",
    to_list: "to",
    turn: "turn",
    while: "while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var en = {
    add: "add",
    and: "and",
    ask: "ask",
    at: "at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "forward",
    from: "from",
    gray: "gray",
    green: "green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "left",
    length: "length",
    or: "or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "print",
    purple: "purple",
    random: "random",
    range: "range",
    red: "red",
    remove: "remove",
    repeat: "repeat",
    return: "return",
    right: "right",
    sleep: "sleep",
    step: "step",
    times: "times",
    to: "to",
    to_list: "to",
    turn: "turn",
    while: "while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var eo = {
    add: "aldonu|add",
    and: "kaj|and",
    ask: "demandu|ask",
    at: "la\u016D|at",
    black: "nigra|black",
    blue: "blua|blue",
    brown: "bruna|brown",
    call: "call",
    clear: "clear",
    color: "koloro|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "e\u0125u|echo",
    elif: "alie se|elif",
    else: "alie|else",
    for: "por|for",
    forward: "anta\u016Den|forward",
    from: "el|from",
    gray: "griza|gray",
    green: "verda|green",
    if: "se|if",
    in: "en|in",
    input: "enigu|input",
    is: "estas|is",
    left: "maldekstren|left",
    length: "longo|length",
    or: "a\u016D|or",
    orange: "oran\u011Da|orange",
    pink: "rozkolora|pink",
    play: "play",
    pressed: "pressed",
    print: "presu|print",
    purple: "purpura|purple",
    random: "hazardo|random",
    range: "intervalo|range",
    red: "ru\u011Da|red",
    remove: "forigu|remove",
    repeat: "ripetu|repeat",
    return: "return",
    right: "dekstren|right",
    sleep: "dormu|sleep",
    step: "pa\u015Do|step",
    times: "fojojn|times",
    to: "\u011Dis|to",
    to_list: "al|to",
    turn: "turnu|turn",
    while: "dum|while",
    white: "blanka|white",
    with: "with",
    yellow: "flava|yellow",
    DIGIT: "0123456789"
  };
  var es = {
    add: "a\xF1adir|add",
    and: "y|and",
    ask: "preguntar|ask",
    at: "en|at",
    black: "negro|black",
    blue: "azul|blue",
    brown: "marr\xF3n|brown",
    call: "llamar|call",
    clear: "limpiar|clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "definir|define",
    echo: "eco|echo",
    elif: "sinosi|elif",
    else: "sino|else",
    for: "para|for",
    forward: "adelante|forward",
    from: "de|from",
    gray: "gris|gray",
    green: "verde|green",
    if: "si|if",
    in: "en|in",
    input: "entrada|input",
    is: "es|is",
    left: "izquierda|left",
    length: "longitud|length",
    or: "o|or",
    orange: "naranja|orange",
    pink: "rosa|pink",
    play: "play",
    pressed: "presionada|pressed",
    print: "imprimir|print",
    purple: "p\xFArpura|purple",
    random: "aleatorio|random",
    range: "rango|range",
    red: "rojo|red",
    remove: "borrar|remove",
    repeat: "repetir|repeat",
    return: "retornar|return",
    right: "derecha|right",
    sleep: "dormir|sleep",
    step: "paso|step",
    times: "veces|times",
    to: "a|to",
    to_list: "a|to",
    turn: "girar|turn",
    while: "mientras|while",
    white: "blanco|white",
    with: "con|with",
    yellow: "amarillo|yellow",
    DIGIT: "0123456789"
  };
  var et = {
    add: "lisa|add",
    and: "ja|and",
    ask: "k\xFCsi|ask",
    at: "t\xE4itsa|at",
    black: "must|black",
    blue: "sinine|blue",
    brown: "pruun|brown",
    call: "call",
    clear: "clear",
    color: "v\xE4rv|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "peegelda|echo",
    elif: "muidukui|elif",
    else: "muidu|else",
    for: "jaoks|for",
    forward: "edasi|forward",
    from: "nimistust|from",
    gray: "hall|gray",
    green: "roheline|green",
    if: "kui|if",
    in: "nimistus|in",
    input: "sisesta|input",
    is: "on|is",
    left: "vasakule|left",
    length: "pikkus|length",
    or: "v\xF5i|or",
    orange: "oran\u017E|orange",
    pink: "roosa|pink",
    play: "play",
    pressed: "pressed",
    print: "prindi|print",
    purple: "lilla|purple",
    random: "juhuslikult|random",
    range: "vahemik|range",
    red: "punane|red",
    remove: "kustuta|remove",
    repeat: "korda|repeat",
    return: "return",
    right: "paremale|right",
    sleep: "oota|sleep",
    step: "sammuga|step",
    times: "korda|times",
    to: "kuni|to",
    to_list: "nimistusse|to",
    turn: "p\xF6\xF6ra|turn",
    while: "senikui|while",
    white: "valge|white",
    with: "with",
    yellow: "kollane|yellow",
    DIGIT: "0123456789"
  };
  var fa = {
    add: "add",
    and: "and",
    ask: "\u0628\u067E\u0631\u0633|ask",
    at: "at",
    black: "\u0633\u06CC\u0627\u0647|black",
    blue: "\u0622\u0628\u06CC|blue",
    brown: "\u0642\u0647\u0648\u0647 \u0627\u06CC|brown",
    call: "call",
    clear: "clear",
    color: "\u0631\u0646\u06AF|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "\u0628\u0647 \u062C\u0644\u0648|forward",
    from: "from",
    gray: "\u062E\u0627\u06A9\u0633\u062A\u0631\u06CC|gray",
    green: "\u0633\u0628\u0632|green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "\u0686\u067E|left",
    length: "length",
    or: "or",
    orange: "\u0646\u0627\u0631\u0646\u062C\u06CC|orange",
    pink: "\u0635\u0648\u0631\u062A\u06CC|pink",
    play: "play",
    pressed: "pressed",
    print: "\u0686\u0627\u067E|print",
    purple: "\u0628\u0646\u0641\u0634|purple",
    random: "random",
    range: "range",
    red: "\u0642\u0631\u0645\u0632|red",
    remove: "remove",
    repeat: "repeat",
    return: "return",
    right: "\u0631\u0627\u0633\u062A|right",
    sleep: "sleep",
    step: "step",
    times: "times",
    to: "to",
    to_list: "to",
    turn: "\u062F\u0648\u0631 \u0628\u0632\u0646|turn",
    while: "while",
    white: "\u0633\u0641\u06CC\u062F|white",
    with: "with",
    yellow: "\u0632\u0631\u062F|yellow",
    DIGIT: "0123456789"
  };
  var fi = {
    add: "lis\xE4\xE4|add",
    and: "ja|and",
    ask: "kysy|ask",
    at: "ota|at",
    black: "musta|black",
    blue: "sininen|blue",
    brown: "ruskea|brown",
    call: "call",
    clear: "nollaa|clear",
    color: "v\xE4ri|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "kaiku|echo",
    elif: "muutenjos|elif",
    else: "muuten|else",
    for: "jokaiselle|for",
    forward: "eteenp\xE4in|forward",
    from: "listasta|from",
    gray: "harmaa|gray",
    green: "vihre\xE4|green",
    if: "jos|if",
    in: "listassa|in",
    input: "sy\xF6te|input",
    is: "on|is",
    left: "vasen|left",
    length: "pituus|length",
    or: "tai|or",
    orange: "oranssi|orange",
    pink: "vaaleanpunainen|pink",
    play: "play",
    pressed: "painettu|pressed",
    print: "tulosta|print",
    purple: "violetti|purple",
    random: "satunnainen|random",
    range: "v\xE4li|range",
    red: "punainen|red",
    remove: "poista|remove",
    repeat: "toista|repeat",
    return: "return",
    right: "oikea|right",
    sleep: "nuku|sleep",
    step: "askel|step",
    times: "kertaa|times",
    to: "asti|to",
    to_list: "listaksi|to",
    turn: "k\xE4\xE4nny|turn",
    while: "kun|while",
    white: "valkoinen|white",
    with: "with",
    yellow: "keltainen|yellow",
    DIGIT: "0123456789"
  };
  var fr = {
    add: "ajoute|add",
    and: "et|and",
    ask: "demande|ask",
    at: "au|at",
    black: "noir|black",
    blue: "bleu|blue",
    brown: "marron|brown",
    call: "call",
    clear: "effacer|clear",
    color: "couleur|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "r\xE9ponds|echo",
    elif: "sinon si|elif",
    else: "sinon|else",
    for: "pour|for",
    forward: "avance|forward",
    from: "de|from",
    gray: "gris|gray",
    green: "vert|green",
    if: "si|if",
    in: "dans|in",
    input: "demande|input",
    is: "est|is",
    left: "gauche|left",
    length: "longueur|length",
    or: "ou|or",
    orange: "orange",
    pink: "rose|pink",
    play: "play",
    pressed: "press\xE9|pressed",
    print: "affiche|print",
    purple: "violet|purple",
    random: "hasard|random",
    range: "intervalle|range",
    red: "rouge|red",
    remove: "supprime|remove",
    repeat: "r\xE9p\xE8te|repete|repeat",
    return: "return",
    right: "droite|right",
    sleep: "dors|sleep",
    step: "pas|step",
    times: "fois|times",
    to: "\xE0|to",
    to_list: "\xE0|to",
    turn: "tourne|turn",
    while: "tant que|while",
    white: "blanc|white",
    with: "with",
    yellow: "jaune|yellow",
    DIGIT: "0123456789"
  };
  var fy = {
    add: "add",
    and: "and",
    ask: "ask",
    at: "at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "forward",
    from: "from",
    gray: "gray",
    green: "green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "left",
    length: "length",
    or: "or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "print",
    purple: "purple",
    random: "random",
    range: "range",
    red: "red",
    remove: "remove",
    repeat: "repeat",
    return: "return",
    right: "right",
    sleep: "sleep",
    step: "step",
    times: "times",
    to: "to",
    to_list: "to",
    turn: "turn",
    while: "while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var he = {
    add: "\u05D4\u05D5\u05E1\u05E3|add",
    and: "\u05D5\u05D2\u05DD|and",
    ask: "\u05E9\u05D0\u05DC|ask",
    at: "\u05D1|at",
    black: "\u05E9\u05D7\u05D5\u05E8|black",
    blue: "\u05DB\u05D7\u05D5\u05DC|blue",
    brown: "\u05D7\u05D5\u05DD|brown",
    call: "call",
    clear: "clear",
    color: "\u05E6\u05D1\u05E2|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "\u05D4\u05D3\u05D4\u05D3|echo",
    elif: "\u05D0\u05D7\u05E8\u05EA\u05D0\u05DD|elif",
    else: "\u05D0\u05D7\u05E8\u05EA|else",
    for: "\u05DC\u05DB\u05DC|for",
    forward: "\u05E7\u05D3\u05D9\u05DE\u05D4|forward",
    from: "\u05DE|from",
    gray: "\u05D0\u05E4\u05D5\u05E8|gray",
    green: "\u05D9\u05E8\u05D5\u05E7|green",
    if: "\u05D0\u05DD|if",
    in: "\u05D1\u05EA\u05D5\u05DA|in",
    input: "\u05E7\u05DC\u05D8|input",
    is: "\u05D4\u05D5\u05D0|is",
    left: "\u05E9\u05DE\u05D0\u05DC\u05D4|left",
    length: "\u05D0\u05D5\u05E8\u05DA|length",
    or: "\u05D0\u05D5|or",
    orange: "\u05DB\u05EA\u05D5\u05DD|orange",
    pink: "\u05D5\u05E8\u05D5\u05D3|pink",
    play: "play",
    pressed: "pressed",
    print: "\u05D4\u05D3\u05E4\u05E1|print",
    purple: "\u05E1\u05D2\u05D5\u05DC|purple",
    random: "\u05D0\u05E7\u05E8\u05D0\u05D9|random",
    range: "\u05D8\u05D5\u05D5\u05D7|range",
    red: "\u05D0\u05D3\u05D5\u05DD|red",
    remove: "\u05D4\u05E1\u05E8|remove",
    repeat: "\u05D7\u05D6\u05D5\u05E8|repeat",
    return: "return",
    right: "\u05D9\u05DE\u05D9\u05E0\u05D4|right",
    sleep: "\u05D4\u05DE\u05EA\u05DF|sleep",
    step: "\u05E6\u05E2\u05D3|step",
    times: "\u05E4\u05E2\u05DE\u05D9\u05DD|times",
    to: "\u05E2\u05D3|to",
    to_list: "\u05D0\u05DC|to",
    turn: "\u05E4\u05E0\u05D4|turn",
    while: "\u05DB\u05DC\u05E2\u05D5\u05D3|while",
    white: "\u05DC\u05D1\u05DF|white",
    with: "with",
    yellow: "\u05E6\u05D4\u05D5\u05D1|yellow",
    DIGIT: "0123456789"
  };
  var hi = {
    add: "\u091C\u094B\u0921\u093C\u0928\u093E|add",
    and: "\u0914\u0930|and",
    ask: "\u092A\u0942\u091B\u0947\u0902|ask",
    at: "\u092A\u0930|at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "\u0917\u0942\u0902\u091C|echo",
    elif: "\u090F\u0932\u093F\u092B|elif",
    else: "\u0905\u0928\u094D\u092F\u0925\u093E|else",
    for: "\u0915\u0947 \u0932\u093F\u092F\u0947|for",
    forward: "\u0906\u0917\u0947|forward",
    from: "\u0938\u0947|from",
    gray: "gray",
    green: "green",
    if: "\u0905\u0917\u0930|if",
    in: "\u092E\u0947\u0902|in",
    input: "\u0907\u0928\u092A\u0941\u091F|input",
    is: "\u0939\u0948|is",
    left: "left",
    length: "\u0932\u0902\u092C\u093E\u0908|length",
    or: "\u092F\u093E|or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "\u092A\u094D\u0930\u093F\u0902\u091F|print",
    purple: "purple",
    random: "\u0905\u0928\u093F\u092F\u092E\u093F\u0924|random",
    range: "\u0936\u094D\u0930\u0947\u0923\u0940|range",
    red: "red",
    remove: "\u0939\u091F\u093E\u0928\u093E|remove",
    repeat: "\u0926\u094B\u0939\u0930\u093E\u0928\u093E|repeat",
    return: "return",
    right: "right",
    sleep: "\u0928\u0940\u0902\u0926|sleep",
    step: "\u0915\u093C\u0926\u092E|step",
    times: "\u092C\u093E\u0930|times",
    to: "\u0938\u0947|to",
    to_list: "\u0938\u0947|to",
    turn: "\u092E\u094B\u0921\u093C|turn",
    while: "\u0935\u094D\u0939\u093E\u0907\u0932|while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var hu = {
    add: "besz\xFAr|add",
    and: "\xE9s|and",
    ask: "k\xE9rdez|ask",
    at: "list\xE1b\xF3l|at",
    black: "fekete|black",
    blue: "k\xE9k|blue",
    brown: "barna|brown",
    call: "call",
    clear: "t\xF6rl\xE9s|clear",
    color: "sz\xEDn|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "ut\xE1noz|echo",
    elif: "egybk-ha|elif",
    else: "egy\xE9bk\xE9nt|else",
    for: "minden|for",
    forward: "el\u0151re|forward",
    from: "ebb\u0151l|from",
    gray: "sz\xFCrke|gray",
    green: "z\xF6ld|green",
    if: "ha|if",
    in: "eleme|in",
    input: "bek\xE9r|input",
    is: "egyenl\u0151|is",
    left: "balra|left",
    length: "hossz|length",
    or: "vagy|or",
    orange: "narancs|orange",
    pink: "pink",
    play: "play",
    pressed: "lenyomva|pressed",
    print: "ki\xEDr|print",
    purple: "lila|purple",
    random: "random",
    range: "szakasz|range",
    red: "piros|red",
    remove: "kivesz|remove",
    repeat: "ism\xE9teld|repeat",
    return: "return",
    right: "jobbra|right",
    sleep: "szundi|sleep",
    step: "l\xE9p\xE9senk\xE9nt|step",
    times: "alkalommal|times",
    to: "t\u0151l|to",
    to_list: "ebbe|to",
    turn: "fordul|turn",
    while: "am\xEDg|while",
    white: "feh\xE9r|white",
    with: "with",
    yellow: "s\xE1rga|yellow",
    DIGIT: "0123456789"
  };
  var id = {
    add: "tambah|add",
    and: "dan|and",
    ask: "tanya|ask",
    at: "secara|at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "warna|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "gaungkan|echo",
    elif: "lain_jika|elif",
    else: "lainnya|else",
    for: "untuk|for",
    forward: "maju|forward",
    from: "dari|from",
    gray: "gray",
    green: "green",
    if: "jika|if",
    in: "dalam|in",
    input: "masukan|input",
    is: "adalah|is",
    left: "kiri|left",
    length: "panjang|length",
    or: "atau|or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "cetak|print",
    purple: "purple",
    random: "acak|random",
    range: "batasan|range",
    red: "red",
    remove: "hapus|remove",
    repeat: "ulangi|repeat",
    return: "return",
    right: "kanan|right",
    sleep: "tidur|sleep",
    step: "langkah|step",
    times: "kali|times",
    to: "ke|to",
    to_list: "ke|to",
    turn: "belok|turn",
    while: "selama|while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var it = {
    add: "add",
    and: "e|and",
    ask: "chiedi|ask",
    at: "at",
    black: "nero|black",
    blue: "blu|blue",
    brown: "marrone|brown",
    call: "call",
    clear: "Elimina|clear",
    color: "colore|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "eco|echo",
    elif: "altrimenti se|elif",
    else: "altrimenti|else",
    for: "for",
    forward: "avanti|forward",
    from: "da|from",
    gray: "grigio|gray",
    green: "verde|green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "sinistra|left",
    length: "lunghezza|length",
    or: "or",
    orange: "arancione|orange",
    pink: "rosa|pink",
    play: "play",
    pressed: "Premuto|pressed",
    print: "stampa|print",
    purple: "viola|purple",
    random: "a caso|random",
    range: "intervallo|range",
    red: "rosso|red",
    remove: "rimuovi|remove",
    repeat: "ripeti|repeat",
    return: "return",
    right: "right",
    sleep: "dormi|sleep",
    step: "passo|step",
    times: "volte|times",
    to: "to",
    to_list: "to",
    turn: "gira|turn",
    while: "mentre|while",
    white: "bianco|white",
    with: "with",
    yellow: "giallo|yellow",
    DIGIT: "0123456789"
  };
  var ja = {
    add: "\u305F\u3059|add",
    and: "and",
    ask: "\u304D\u3051|ask",
    at: "at",
    black: "\u304F\u308D|black",
    blue: "\u3042\u304A|blue",
    brown: "\u3061\u3083\u3044\u308D|brown",
    call: "call",
    clear: "clear",
    color: "\u3044\u308D|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "\u307E\u306D|echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "\u3059\u3059\u3081|forward",
    from: "from",
    gray: "\u306F\u3044\u3044\u308D|gray",
    green: "\u307F\u3069\u308A|green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "\u3072\u3060\u308A|left",
    length: "length",
    or: "or",
    orange: "\u304A\u308C\u3093\u3058|orange",
    pink: "\u3074\u3093\u304F|pink",
    play: "play",
    pressed: "pressed",
    print: "\u304B\u3051|print",
    purple: "\u3080\u3089\u3055\u304D|purple",
    random: "random",
    range: "range",
    red: "\u3042\u304B|red",
    remove: "remove",
    repeat: "repeat",
    return: "return",
    right: "\u307F\u304E|right",
    sleep: "\u3084\u3059\u3081|sleep",
    step: "step",
    times: "\u304B\u3044|times",
    to: "to",
    to_list: "to",
    turn: "\u307E\u308F\u308C|turn",
    while: "while",
    white: "\u3057\u308D|white",
    with: "with",
    yellow: "\u304D\u3044\u308D|yellow",
    DIGIT: "0123456789"
  };
  var kmr = {
    add: "add",
    and: "and",
    ask: "ask",
    at: "at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "forward",
    from: "from",
    gray: "gray",
    green: "green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "left",
    length: "length",
    or: "or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "print",
    purple: "purple",
    random: "random",
    range: "range",
    red: "red",
    remove: "remove",
    repeat: "repeat",
    return: "return",
    right: "right",
    sleep: "sleep",
    step: "step",
    times: "times",
    to: "to",
    to_list: "to",
    turn: "turn",
    while: "while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var ko = {
    add: "add",
    and: "and",
    ask: "ask",
    at: "at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "forward",
    from: "from",
    gray: "gray",
    green: "green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "left",
    length: "length",
    or: "or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "print",
    purple: "purple",
    random: "random",
    range: "range",
    red: "red",
    remove: "remove",
    repeat: "repeat",
    return: "return",
    right: "right",
    sleep: "sleep",
    step: "step",
    times: "times",
    to: "to",
    to_list: "to",
    turn: "turn",
    while: "while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var mi = {
    add: "add",
    and: "and",
    ask: "ask",
    at: "at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "forward",
    from: "from",
    gray: "gray",
    green: "green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "left",
    length: "length",
    or: "or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "print",
    purple: "purple",
    random: "random",
    range: "range",
    red: "red",
    remove: "remove",
    repeat: "repeat",
    return: "return",
    right: "right",
    sleep: "sleep",
    step: "step",
    times: "times",
    to: "to",
    to_list: "to",
    turn: "turn",
    while: "while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var nb_NO = {
    add: "legg|add",
    and: "og|and",
    ask: "sp\xF8r|ask",
    at: "p\xE5|at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "ekko|echo",
    elif: "elhvis|elif",
    else: "ellers|else",
    for: "for",
    forward: "frem|forward",
    from: "fra|from",
    gray: "gray",
    green: "green",
    if: "hvis|if",
    in: "i|in",
    input: "inndata|input",
    is: "er|is",
    left: "venstre|left",
    length: "lengde|length",
    or: "eller|or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "skriv|print",
    purple: "purple",
    random: "tilfeldig|random",
    range: "sekvens|range",
    red: "red",
    remove: "fjern|remove",
    repeat: "gjenta|repeat",
    return: "return",
    right: "h\xF8yre|right",
    sleep: "sov|sleep",
    step: "steg|step",
    times: "ganger|times",
    to: "til|to",
    to_list: "til|to",
    turn: "snu|turn",
    while: "mens|while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var nl = {
    add: "voeg|add",
    and: "en|and",
    ask: "vraag|ask",
    at: "op|at",
    black: "zwart|black",
    blue: "blauw|blue",
    brown: "bruin|brown",
    call: "roep|call",
    clear: "wis|clear",
    color: "kleur|color",
    comma: ",",
    def: "def",
    define: "definieer|define",
    echo: "echo",
    elif: "alsanders|elif",
    else: "anders|else",
    for: "voor|for",
    forward: "vooruit|forward",
    from: "uit|from",
    gray: "grijs|gray",
    green: "groen|green",
    if: "als|if",
    in: "in",
    input: "invoer|input",
    is: "is",
    left: "links|left",
    length: "lengte|length",
    or: "of|or",
    orange: "oranje|orange",
    pink: "roze|pink",
    play: "speel|play",
    pressed: "ingedrukt|pressed",
    print: "print",
    purple: "paars|purple",
    random: "willekeurig|random",
    range: "bereik|range",
    red: "rood|red",
    remove: "verwijder|remove",
    repeat: "herhaal|repeat",
    return: "return",
    right: "rechts|right",
    sleep: "slaap|sleep",
    step: "stap|step",
    times: "keer|times",
    to: "tot|to",
    to_list: "toe aan|to",
    turn: "draai|turn",
    while: "zolang|while",
    white: "wit|white",
    with: "met|with",
    yellow: "geel|yellow",
    DIGIT: "0123456789"
  };
  var pa_PK = {
    add: "\u062F\u06BE\u0646|add",
    and: "\u062A\u06D2|and",
    ask: "\u0633\u0648\u0627\u0644|ask",
    at: "\u0633\u062A\u06BE\u062A\u06CC|at",
    black: "\u06A9\u0627\u0644\u0627|black",
    blue: "\u0646\u06CC\u0644\u0627|blue",
    brown: "\u0628\u06BE\u0648\u0631\u0627|brown",
    call: "call",
    clear: "clear",
    color: "\u0631\u0646\u06AF|color",
    comma: "\u060C|,",
    def: "def",
    define: "define",
    echo: "\u0641\u06CC\u0631|echo",
    elif: "\u06C1\u0648\u0631|elif",
    else: "\u0648\u06A9\u06BE\u0631\u0627|else",
    for: "\u062C\u062F\u0648\u06BA|for",
    forward: "\u0627\u06AF\u06D2|forward",
    from: "\u0633\u0631\u0648\u062A|from",
    gray: "\u0633\u0644\u06CC\u0679\u06CC|gray",
    green: "\u06C1\u0631\u0627|green",
    if: "\u062C\u06D2|if",
    in: "\u0627\u0646\u062F\u0631|in",
    input: "\u0627\u06CC\u0646\u067E\u0679|input",
    is: "\u0633\u0645\u0627\u0646|is",
    left: "\u06A9\u06BE\u0628\u06D2|left",
    length: "\u0644\u0645\u0628\u0627\u0626\u06CC|length",
    or: "\u06CC\u0627|or",
    orange: "\u0633\u0646\u062A\u0631\u0627|orange",
    pink: "\u06AF\u0644\u0627\u0628\u06CC|pink",
    play: "play",
    pressed: "pressed",
    print: "\u0686\u067E\u0627\u0626\u06CC|print",
    purple: "\u062C\u0627\u0645\u0646\u06CC|purple",
    random: "\u0631\u0644\u0648\u0627\u0646|random",
    range: "\u0633\u0644\u0633\u0644\u06C1|range",
    red: "\u0644\u0627\u0644|red",
    remove: "\u0645\u0679\u0627\u06A9\u06D2|remove",
    repeat: "\u062F\u06C1\u0631\u0627|repeat",
    return: "return",
    right: "\u0633\u062C\u06D2|right",
    sleep: "\u0646\u06CC\u0646\u062F|sleep",
    step: "\u0633\u0637\u0631|step",
    times: "\u0636\u0631\u0628|times",
    to: "\u0645\u0646\u0632\u0644|to",
    to_list: "\u0645\u0646\u0632\u0644|to",
    turn: "\u0645\u0648\u0691\u0646|turn",
    while: "\u062C\u062F\u06A9\u06C1|while",
    white: "\u0686\u0679\u0627|white",
    with: "with",
    yellow: "\u067E\u06CC\u0644\u0627|yellow",
    DIGIT: "0\u06F01\u06F12\u06F23\u06F34\u06F45\u06F56\u06F67\u06F78\u06F89\u06F9"
  };
  var pap = {
    add: "add",
    and: "and",
    ask: "ask",
    at: "at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "forward",
    from: "from",
    gray: "gray",
    green: "green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "left",
    length: "length",
    or: "or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "print",
    purple: "purple",
    random: "random",
    range: "range",
    red: "red",
    remove: "remove",
    repeat: "repeat",
    return: "return",
    right: "right",
    sleep: "sleep",
    step: "step",
    times: "times",
    to: "to",
    to_list: "to",
    turn: "turn",
    while: "while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var pl = {
    add: "dodaj|add",
    and: "i|and",
    ask: "zapytaj|ask",
    at: "pozycja|at",
    black: "czarny|black",
    blue: "niebieski|blue",
    brown: "br\u0105zowy|brown",
    call: "call",
    clear: "wyczy\u015B\u0107|clear",
    color: "kolor|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "do\u0142\u0105cz|echo",
    elif: "albo|elif",
    else: "inaczej|else",
    for: "dla|for",
    forward: "naprz\xF3d|forward",
    from: "z|from",
    gray: "szary|gray",
    green: "zielony|green",
    if: "je\u017Celi|if",
    in: "w|in",
    input: "wprowad\u017A|input",
    is: "to|is",
    left: "lewo|left",
    length: "d\u0142ugo\u015B\u0107|length",
    or: "lub|or",
    orange: "pomara\u0144czowy|orange",
    pink: "r\xF3\u017Cowy|pink",
    play: "play",
    pressed: "naci\u015Bni\u0119ty|pressed",
    print: "napisz|print",
    purple: "fioletowy|purple",
    random: "losowa|random",
    range: "zakres|range",
    red: "czerwony|red",
    remove: "usu\u0144|remove",
    repeat: "powt\xF3rz|repeat",
    return: "return",
    right: "prawo|right",
    sleep: "\u015Bpij|sleep",
    step: "krok|step",
    times: "razy|times",
    to: "do|to",
    to_list: "do|to",
    turn: "obr\xF3\u0107|turn",
    while: "dop\xF3ki|while",
    white: "bia\u0142y|white",
    with: "with",
    yellow: "\u017C\xF3\u0142ty|yellow",
    DIGIT: "0123456789"
  };
  var pt_BR = {
    add: "some|add",
    and: "e|and",
    ask: "pergunte|ask",
    at: "em|at",
    black: "preto|black",
    blue: "azul|blue",
    brown: "marrom|brown",
    call: "call",
    clear: "limpar|clear",
    color: "cor|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "eco|echo",
    elif: "sen\xE3ose|elif",
    else: "sen\xE3o|else",
    for: "para|for",
    forward: "adiante|forward",
    from: "de|from",
    gray: "cinza|gray",
    green: "verde|green",
    if: "se|if",
    in: "em|in",
    input: "entrada|input",
    is: "\xE9|is",
    left: "esquerda|left",
    length: "comprimento|length",
    or: "ou|or",
    orange: "laranja|orange",
    pink: "rosa|pink",
    play: "play",
    pressed: "apertado|pressed",
    print: "imprima|print",
    purple: "roxo|purple",
    random: "aleat\xF3rio|random",
    range: "intervalo|range",
    red: "vermelho|red",
    remove: "remova|remove",
    repeat: "repita|repeat",
    return: "return",
    right: "direita|right",
    sleep: "durma|sleep",
    step: "passo|step",
    times: "vezes|times",
    to: "para|to",
    to_list: "at\xE9|to",
    turn: "gire|turn",
    while: "enquanto|while",
    white: "branco|white",
    with: "with",
    yellow: "amarelo|yellow",
    DIGIT: "0123456789"
  };
  var pt_PT = {
    add: "adicionar|add",
    and: "e|and",
    ask: "perguntar|ask",
    at: "em|at",
    black: "preto|black",
    blue: "azul|blue",
    brown: "castanho|brown",
    call: "call",
    clear: "clear",
    color: "cor|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "eco|echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "avan\xE7ar|forward",
    from: "de|from",
    gray: "cinzento|gray",
    green: "verde|green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "esquerda|left",
    length: "comprimento|length",
    or: "or",
    orange: "cor de laranja|orange",
    pink: "cor de rosa|pink",
    play: "play",
    pressed: "pressed",
    print: "imprimir|print",
    purple: "roxo|purple",
    random: "random",
    range: "intervalo|range",
    red: "vermelho|red",
    remove: "remover|remove",
    repeat: "repetir|repeat",
    return: "return",
    right: "direita|right",
    sleep: "dormir|sleep",
    step: "passo|step",
    times: "vezes|times",
    to: "to",
    to_list: "para|to",
    turn: "virar|turn",
    while: "enquanto|while",
    white: "branco|white",
    with: "with",
    yellow: "amarelo|yellow",
    DIGIT: "0123456789"
  };
  var ro = {
    add: "adun\u0103|add",
    and: "si|and",
    ask: "\xEEntreab\u0103|ask",
    at: "la|at",
    black: "negru|black",
    blue: "albastru|blue",
    brown: "maro|brown",
    call: "call",
    clear: "\u0219terge|clear",
    color: "culoare|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "echo",
    elif: "altfel dac\u0103|elif",
    else: "else",
    for: "pentru|for",
    forward: "\xEEnainte|forward",
    from: "de la|from",
    gray: "gri|gray",
    green: "verde|green",
    if: "if",
    in: "in",
    input: "intrare|input",
    is: "is",
    left: "st\xE2nga|left",
    length: "lungime|length",
    or: "sau|or",
    orange: "portocaliu|orange",
    pink: "roz|pink",
    play: "play",
    pressed: "ap\u0103sat|pressed",
    print: "print",
    purple: "mov|purple",
    random: "aleatoriu|random",
    range: "interval|range",
    red: "ro\u0219u|red",
    remove: "elimin\u0103|remove",
    repeat: "repet\u0103|repeat",
    return: "return",
    right: "dreapta|right",
    sleep: "sleep",
    step: "pas|step",
    times: "inmul\u021Bit|times",
    to: "c\u0103tre|to",
    to_list: "c\u0103tre|to",
    turn: "intoarce|turn",
    while: "\xEEn timp ce|while",
    white: "alb|white",
    with: "with",
    yellow: "galben|yellow",
    DIGIT: "0123456789"
  };
  var ru = {
    add: "\u0434\u043E\u0431\u0430\u0432\u0438\u0442\u044C|add",
    and: "\u0438|and",
    ask: "\u0437\u0430\u043F\u0440\u043E\u0441\u0438\u0442\u044C|ask",
    at: "\u0432|at",
    black: "\u0447\u0451\u0440\u043D\u044B\u0439|black",
    blue: "\u0441\u0438\u043D\u0438\u0439|blue",
    brown: "\u043A\u043E\u0440\u0438\u0447\u043D\u0435\u0432\u044B\u0439|brown",
    call: "call",
    clear: "\u043E\u0447\u0438\u0441\u0442\u0438\u0442\u044C|clear",
    color: "\u0446\u0432\u0435\u0442|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "\u043F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C|echo",
    elif: "\u0438\u043D\u0430\u0447\u0435, \u0435\u0441\u043B\u0438|elif",
    else: "\u0438\u043D\u0430\u0447\u0435|else",
    for: "\u0434\u043B\u044F|for",
    forward: "\u0432\u043F\u0435\u0440\u0451\u0434|forward",
    from: "\u0438\u0437|from",
    gray: "\u0441\u0435\u0440\u044B\u0439|gray",
    green: "\u0437\u0435\u043B\u0451\u043D\u044B\u0439|green",
    if: "\u0435\u0441\u043B\u0438|if",
    in: "\u0432|in",
    input: "\u0432\u0432\u043E\u0434|input",
    is: "\u044D\u0442\u043E|is",
    left: "\u043D\u0430\u043B\u0435\u0432\u043E|left",
    length: "\u0434\u043B\u0438\u043D\u0430|length",
    or: "\u0438\u043B\u0438|or",
    orange: "\u043E\u0440\u0430\u043D\u0436\u0435\u0432\u044B\u0439|orange",
    pink: "\u0440\u043E\u0437\u043E\u0432\u044B\u0439|pink",
    play: "play",
    pressed: "\u043D\u0430\u0436\u043C\u0438\u0442\u0435|pressed",
    print: "\u043F\u0435\u0447\u0430\u0442\u0430\u0442\u044C|print",
    purple: "\u043F\u0443\u0440\u043F\u0443\u0440\u043D\u044B\u0439|purple",
    random: "\u0441\u043B\u0443\u0447\u0430\u0439\u043D\u043E\u043C|random",
    range: "\u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A|range",
    red: "\u043A\u0440\u0430\u0441\u043D\u044B\u0439|red",
    remove: "\u0443\u0434\u0430\u043B\u0438\u0442\u044C|remove",
    repeat: "\u043F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C|repeat",
    return: "return",
    right: "\u043D\u0430\u043F\u0440\u0430\u0432\u043E|right",
    sleep: "\u0437\u0430\u0441\u043D\u0443\u0442\u044C|sleep",
    step: "\u0448\u0430\u0433|step",
    times: "\u0440\u0430\u0437|times",
    to: "\u0434\u043E|to",
    to_list: "\u0432|to",
    turn: "\u043F\u043E\u0432\u0435\u0440\u043D\u0443\u0442\u044C|turn",
    while: "\u043F\u043E\u043A\u0430|while",
    white: "\u0431\u0435\u043B\u044B\u0439|white",
    with: "with",
    yellow: "\u0436\u0451\u043B\u0442\u044B\u0439|yellow",
    DIGIT: "0123456789"
  };
  var sq = {
    add: "shtoni|add",
    and: "dhe|and",
    ask: "pyet|ask",
    at: "n\xEB|at",
    black: "zez\xEB|black",
    blue: "blu|blue",
    brown: "kafe|brown",
    call: "thirr|call",
    clear: "pastro|clear",
    color: "ngjyr\xEB|color",
    comma: ",",
    def: "def",
    define: "defino|define",
    echo: "p\xEBrs\xEBrit|echo",
    elif: "nendryshe|elif",
    else: "ndryshe|else",
    for: "p\xEBr|for",
    forward: "p\xEBrpara|forward",
    from: "nga|from",
    gray: "gri|gray",
    green: "jeshile|green",
    if: "n\xEBse|if",
    in: "n\xEB|in",
    input: "hyrje|input",
    is: "\xEBsht\xEB|is",
    left: "majtas|left",
    length: "gjat\xEBsia|length",
    or: "ose|or",
    orange: "portokalli|orange",
    pink: "roz\xEB|pink",
    play: "play",
    pressed: "shtypur|pressed",
    print: "printo|print",
    purple: "vjollc\xEB|purple",
    random: "rast\xEBsi|random",
    range: "varg|range",
    red: "kuqe|red",
    remove: "hiqni|remove",
    repeat: "p\xEBrs\xEBrit|repeat",
    return: "rikthe|return",
    right: "drejt\xEB|right",
    sleep: "fle|sleep",
    step: "hap|step",
    times: "her|times",
    to: "deri|to",
    to_list: "deri|to",
    turn: "kthes\xEB|turn",
    while: "derisa|while",
    white: "bardh\xEB|white",
    with: "me|with",
    yellow: "verdh\xEB|yellow",
    DIGIT: "0123456789"
  };
  var sr = {
    add: "dodaj|add",
    and: "i|and",
    ask: "pitaj|ask",
    at: "na|at",
    black: "crna|black",
    blue: "plava|blue",
    brown: "braon|brown",
    call: "call",
    clear: "o\u010Disti|clear",
    color: "boja|color",
    comma: ",",
    def: "def",
    define: "defini\u0161i|define",
    echo: "poka\u017Ei|echo",
    elif: "ina\u010De ako|elif",
    else: "ina\u010De|else",
    for: "za|for",
    forward: "napred|forward",
    from: "od|from",
    gray: "siva|gray",
    green: "zelena|green",
    if: "ako|if",
    in: "u|in",
    input: "ulaz|input",
    is: "je|is",
    left: "levo|left",
    length: "du\u017Eina|length",
    or: "ili|or",
    orange: "narand\u017Easta|orange",
    pink: "roze|pink",
    play: "play",
    pressed: "pritisnuto|pressed",
    print: "\u0161tampaj|print",
    purple: "ljubi\u010Dasta|purple",
    random: "nasumi\u010Dno|random",
    range: "opseg|range",
    red: "crvena|red",
    remove: "obri\u0161i|remove",
    repeat: "ponovi|repeat",
    return: "vrati|return",
    right: "desno|right",
    sleep: "spavanje|sleep",
    step: "korak|step",
    times: "vremena|times",
    to: "u|to",
    to_list: "u|to",
    turn: "okreni|turn",
    while: "dok|while",
    white: "bela|white",
    with: "sa|with",
    yellow: "\u017Euta|yellow",
    DIGIT: "0123456789"
  };
  var sv = {
    add: "addera|add",
    and: "och|and",
    ask: "fr\xE5ga|ask",
    at: "vid|at",
    black: "svart|black",
    blue: "bl\xE5|blue",
    brown: "brun|brown",
    call: "anropa|call",
    clear: "rensa|clear",
    color: "f\xE4rg|color",
    comma: ",",
    def: "def",
    define: "definiera|define",
    echo: "eko|echo",
    elif: "anom|elif",
    else: "annars|else",
    for: "f\xF6r|for",
    forward: "fram\xE5t|forward",
    from: "fr\xE5n|from",
    gray: "gr\xE5|gray",
    green: "gr\xF6n|green",
    if: "om|if",
    in: "i|in",
    input: "inmatning|input",
    is: "\xE4r|is",
    left: "v\xE4nster|left",
    length: "l\xE4ngd|length",
    or: "eller|or",
    orange: "orange",
    pink: "rosa|pink",
    play: "play",
    pressed: "nedtryckt|pressed",
    print: "skriv|print",
    purple: "lila|purple",
    random: "slump|random",
    range: "intervall|range",
    red: "r\xF6d|red",
    remove: "radera|remove",
    repeat: "upprepa|repeat",
    return: "returnera|return",
    right: "h\xF6ger|right",
    sleep: "sov|sleep",
    step: "steg|step",
    times: "g\xE5nger|times",
    to: "till|to",
    to_list: "till|to",
    turn: "sv\xE4ng|turn",
    while: "medan|while",
    white: "vit|white",
    with: "med|with",
    yellow: "gul|yellow",
    DIGIT: "0123456789"
  };
  var sw = {
    add: "add",
    and: "and",
    ask: "ask",
    at: "at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "forward",
    from: "from",
    gray: "gray",
    green: "green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "left",
    length: "length",
    or: "or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "print",
    purple: "purple",
    random: "random",
    range: "range",
    red: "red",
    remove: "remove",
    repeat: "repeat",
    return: "return",
    right: "right",
    sleep: "sleep",
    step: "step",
    times: "times",
    to: "to",
    to_list: "to",
    turn: "turn",
    while: "while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var te = {
    add: "\u0C1C\u0C4B\u0C21\u0C3F\u0C02\u0C1A\u0C41|add",
    and: "\u0C2E\u0C30\u0C3F\u0C2F\u0C41|and",
    ask: "\u0C05\u0C21\u0C17\u0C02\u0C21\u0C3F|ask",
    at: "\u0C35\u0C26\u0C4D\u0C26|at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "\u0C24\u0C41\u0C21\u0C3F\u0C1A\u0C3F\u0C35\u0C47\u0C2F\u0C3F|clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "\u0C2A\u0C4D\u0C30\u0C24\u0C3F\u0C27\u0C4D\u0C35\u0C28\u0C3F|echo",
    elif: "\u0C2E\u0C30\u0C4A\u0C15\u0C1F\u0C3F \u0C09\u0C02\u0C1F\u0C47|elif",
    else: "\u0C32\u0C47\u0C15\u0C2A\u0C4B\u0C24\u0C47|else",
    for: "\u0C15\u0C4B\u0C38\u0C02|for",
    forward: "\u0C2E\u0C41\u0C02\u0C26\u0C41\u0C15\u0C41|forward",
    from: "\u0C28\u0C41\u0C02\u0C21\u0C3F|from",
    gray: "gray",
    green: "green",
    if: "\u0C09\u0C02\u0C1F\u0C47|if",
    in: "\u092E\u0947\u0C32\u0C4B|in",
    input: "\u0C07\u0C28\u0C4D\u0C2A\u0C41\u0C1F\u0C4D|input",
    is: "\u0C09\u0C02\u0C26\u0C3F|is",
    left: "left",
    length: "\u0C2A\u0C4A\u0C21\u0C35\u0C41|length",
    or: "\u0C32\u0C47\u0C26\u0C3E|or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "\u0C2E\u0C41\u0C26\u0C4D\u0C30\u0C23|print",
    purple: "purple",
    random: "\u0C2F\u0C3E\u0C26\u0C43\u0C1A\u0C4D\u0C1B\u0C3F\u0C15\u0C02\u0C17\u0C3E|random",
    range: "\u0C2A\u0C30\u0C3F\u0C27\u0C3F|range",
    red: "red",
    remove: "\u0C24\u0C4A\u0C32\u0C17\u0C3F\u0C02\u0C1A\u0C41|remove",
    repeat: "\u0C2A\u0C41\u0C28\u0C30\u0C3E\u0C35\u0C43\u0C24\u0C02|repeat",
    return: "return",
    right: "right",
    sleep: "\u0C28\u0C3F\u0C26\u0C4D\u0C30|sleep",
    step: "\u0C05\u0C21\u0C41\u0C17\u0C41|step",
    times: "\u0C38\u0C3E\u0C30\u0C4D\u0C32\u0C41|times",
    to: "\u0C15\u0C41|to",
    to_list: "\u0C15\u0C41|to",
    turn: "\u0C2E\u0C32\u0C41\u0C2A\u0C41|turn",
    while: "\u0C05\u0C2F\u0C3F\u0C24\u0C47|while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var th = {
    add: "\u0E40\u0E1E\u0E34\u0E48\u0E21|add",
    and: "\u0E41\u0E25\u0E30|and",
    ask: "\u0E16\u0E32\u0E21\u0E27\u0E48\u0E32|ask",
    at: "\u0E41\u0E1A\u0E1A|at",
    black: "\u0E14\u0E33|black",
    blue: "\u0E19\u0E49\u0E33\u0E40\u0E07\u0E34\u0E19|blue",
    brown: "\u0E19\u0E49\u0E33\u0E15\u0E32\u0E25|brown",
    call: "call",
    clear: "\u0E25\u0E1A\u0E01\u0E23\u0E30\u0E14\u0E32\u0E19|clear",
    color: "\u0E2A\u0E35|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "\u0E1E\u0E39\u0E14|echo",
    elif: "\u0E2B\u0E23\u0E37\u0E2D\u0E16\u0E49\u0E32|elif",
    else: "\u0E44\u0E21\u0E48\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E31\u0E49\u0E19|else",
    for: "\u0E43\u0E2B\u0E49|for",
    forward: "\u0E40\u0E14\u0E34\u0E19\u0E2B\u0E19\u0E49\u0E32|forward",
    from: "\u0E08\u0E32\u0E01|from",
    gray: "\u0E40\u0E17\u0E32|gray",
    green: "\u0E40\u0E02\u0E35\u0E22\u0E27|green",
    if: "\u0E16\u0E49\u0E32|if",
    in: "\u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19|in",
    input: "\u0E23\u0E31\u0E1A\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25|input",
    is: "\u0E04\u0E37\u0E2D|is",
    left: "\u0E0B\u0E49\u0E32\u0E22|left",
    length: "\u0E04\u0E27\u0E32\u0E21\u0E22\u0E32\u0E27|length",
    or: "\u0E2B\u0E23\u0E37\u0E2D|or",
    orange: "\u0E2A\u0E49\u0E21|orange",
    pink: "\u0E0A\u0E21\u0E1E\u0E39|pink",
    play: "play",
    pressed: "\u0E1B\u0E38\u0E48\u0E21\u0E17\u0E35\u0E48\u0E16\u0E39\u0E01\u0E01\u0E14|pressed",
    print: "\u0E41\u0E2A\u0E14\u0E07|print",
    purple: "\u0E21\u0E48\u0E27\u0E07|purple",
    random: "\u0E2A\u0E38\u0E48\u0E21|random",
    range: "\u0E0A\u0E48\u0E27\u0E07|range",
    red: "\u0E41\u0E14\u0E07|red",
    remove: "\u0E25\u0E1A|remove",
    repeat: "\u0E17\u0E33\u0E0B\u0E49\u0E33|repeat",
    return: "return",
    right: "\u0E02\u0E27\u0E32|right",
    sleep: "\u0E23\u0E2D|sleep",
    step: "\u0E40\u0E14\u0E34\u0E19|step",
    times: "\u0E04\u0E23\u0E31\u0E49\u0E07|times",
    to: "\u0E08\u0E19\u0E16\u0E36\u0E07|to",
    to_list: "\u0E44\u0E1B\u0E22\u0E31\u0E07|to",
    turn: "\u0E40\u0E25\u0E35\u0E49\u0E22\u0E27|turn",
    while: "\u0E40\u0E21\u0E37\u0E48\u0E2D\u0E44\u0E2B\u0E23\u0E48\u0E01\u0E47\u0E15\u0E32\u0E21\u0E17\u0E35\u0E48|while",
    white: "\u0E02\u0E32\u0E27|white",
    with: "with",
    yellow: "\u0E40\u0E2B\u0E25\u0E37\u0E2D\u0E07|yellow",
    DIGIT: "0123456789"
  };
  var tl = {
    add: "add",
    and: "and",
    ask: "ask",
    at: "at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "forward",
    from: "from",
    gray: "gray",
    green: "green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "left",
    length: "length",
    or: "or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "print",
    purple: "purple",
    random: "random",
    range: "range",
    red: "red",
    remove: "remove",
    repeat: "repeat",
    return: "return",
    right: "right",
    sleep: "sleep",
    step: "step",
    times: "times",
    to: "to",
    to_list: "to",
    turn: "turn",
    while: "while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var tn = {
    add: "tsenya|add",
    and: "and",
    ask: "botsa|ask",
    at: "at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "echo",
    elif: "elif",
    else: "faese|else",
    for: "for",
    forward: "forward",
    from: "from",
    gray: "gray",
    green: "green",
    if: "fa|if",
    in: "in",
    input: "input",
    is: "ke|is",
    left: "left",
    length: "length",
    or: "or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "gatisa|print",
    purple: "purple",
    random: "random",
    range: "range",
    red: "red",
    remove: "ntsha|remove",
    repeat: "repeat",
    return: "return",
    right: "right",
    sleep: "sleep",
    step: "step",
    times: "times",
    to: "to",
    to_list: "to",
    turn: "turn",
    while: "while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var tr = {
    add: "ekle|add",
    and: "ve|and",
    ask: "sor|ask",
    at: "i\xE7inden|at",
    black: "siyah|black",
    blue: "mavi|blue",
    brown: "kahverengi|brown",
    call: "\xE7a\u011F\u0131r|call",
    clear: "temizle|clear",
    color: "renk|color",
    comma: ",",
    def: "tan\u0131|def",
    define: "tan\u0131mla|define",
    echo: "yank\u0131la|echo",
    elif: "de\u011File\u011Fer|elif",
    else: "de\u011Filse|else",
    for: "\u015Funun i\xE7in|for",
    forward: "ileri|forward",
    from: "\u015Furadan|from",
    gray: "gri|gray",
    green: "ye\u015Fil|green",
    if: "e\u011Fer|if",
    in: "\u015Funda|in",
    input: "girdi|input",
    is: "e\u015Fit|is",
    left: "sol|left",
    length: "uzunluk|length",
    or: "veya|or",
    orange: "turuncu|orange",
    pink: "pembe|pink",
    play: "play",
    pressed: "bas\u0131l\u0131|pressed",
    print: "yazd\u0131r|print",
    purple: "mor|purple",
    random: "rastgele|random",
    range: "aral\u0131k|range",
    red: "k\u0131rm\u0131z\u0131|red",
    remove: "kald\u0131r|remove",
    repeat: "tekrarla|repeat",
    return: "gerid\xF6n|return",
    right: "sa\u011F|right",
    sleep: "uyu|sleep",
    step: "ad\u0131m|step",
    times: "kere|times",
    to: "\u015Furaya|to",
    to_list: "\u015Furaya|to",
    turn: "d\xF6nd\xFCr|turn",
    while: "\u015Fu iken|while",
    white: "beyaz|white",
    with: "ile|with",
    yellow: "sar\u0131|yellow",
    DIGIT: "0123456789"
  };
  var uk = {
    add: "\u0434\u043E\u0434\u0430\u0439|add",
    and: "\u0456|and",
    ask: "\u0437\u0430\u043F\u0438\u0442\u0430\u0439|ask",
    at: "\u043D\u0430 \u043F\u043E\u0437\u0438\u0446\u0456\u0457|at",
    black: "\u0447\u043E\u0440\u043D\u0438\u0439|black",
    blue: "\u0441\u0438\u043D\u0456\u0439|blue",
    brown: "\u043A\u043E\u0440\u0438\u0447\u043D\u0435\u0432\u0438\u0439|brown",
    call: "call",
    clear: "\u043E\u0447\u0438\u0441\u0442\u0438\u0442\u0438|clear",
    color: "\u043A\u043E\u043B\u0456\u0440|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "\u0435\u0445\u043E|echo",
    elif: "\u0456\u043D\u0430\u043A\u0448\u0435 \u044F\u043A\u0449\u043E|elif",
    else: "\u0456\u043D\u0430\u043A\u0448\u0435|else",
    for: "\u0434\u043B\u044F|for",
    forward: "\u0432\u043F\u0435\u0440\u0435\u0434|forward",
    from: "i\u0437|\u0437|from",
    gray: "\u0441\u0456\u0440\u0438\u0439|gray",
    green: "\u0437\u0435\u043B\u0435\u043D\u0438\u0439|green",
    if: "\u044F\u043A\u0449\u043E|if",
    in: "\u0432|in",
    input: "\u0432\u0432\u0435\u0434\u0438|input",
    is: "\u0446\u0435|is",
    left: "\u0432\u043B\u0456\u0432\u043E|left",
    length: "\u0434\u043E\u0432\u0436\u0438\u043D\u0430|length",
    or: "\u0430\u0431\u043E|or",
    orange: "\u043E\u0440\u0430\u043D\u0436\u0435\u0432\u0438\u0439|orange",
    pink: "\u0440\u043E\u0436\u0435\u0432\u0438\u0439|pink",
    play: "play",
    pressed: "\u043D\u0430\u0442\u0438\u0441\u043D\u0443\u0432|pressed",
    print: "\u0434\u0440\u0443\u043A\u0443\u0439|print",
    purple: "\u0444\u0456\u043E\u043B\u0435\u0442\u043E\u0432\u0438\u0439|purple",
    random: "\u0432\u0438\u043F\u0430\u0434\u043A\u043E\u0432\u0438\u0439|\u0432\u0438\u043F\u0430\u0434\u043A\u043E\u0432\u0456\u0439|random",
    range: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D|\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043Di|range",
    red: "\u0447\u0435\u0440\u0432\u043E\u043D\u0438\u0439|red",
    remove: "\u0432\u0438\u0434\u0430\u043B\u0438|remove",
    repeat: "\u043F\u043E\u0432\u0442\u043E\u0440\u0438|repeat",
    return: "return",
    right: "\u0432\u043F\u0440\u0430\u0432\u043E|right",
    sleep: "\u043F\u043E\u0447\u0435\u043A\u0430\u0439|sleep",
    step: "\u043A\u0440\u043E\u043A|step",
    times: "\u0440\u0430\u0437\u0456\u0432|\u0440\u0430\u0437\u0438|\u0440\u0430\u0437|times",
    to: "\u0434\u043E|to",
    to_list: "\u0434\u043E|to",
    turn: "\u043F\u043E\u0432\u0435\u0440\u043D\u0438|turn",
    while: "\u0442\u043E\u0434\u0456 \u044F\u043A|while",
    white: "\u0431\u0456\u043B\u0438\u0439|white",
    with: "with",
    yellow: "\u0436\u043E\u0432\u0442\u0438\u0439|yellow",
    DIGIT: "0123456789"
  };
  var ur = {
    add: "\u0634\u0627\u0645\u0644|add",
    and: "\u0627\u0648\u0631|and",
    ask: "\u0628\u062A\u0627\u0624|ask",
    at: "\u06A9\u0648\u0626\u06CC|at",
    black: "\u06A9\u0627\u0644\u0627|black",
    blue: "\u0646\u06CC\u0644\u0627|blue",
    brown: "\u0628\u0631\u0627\u0624\u0646|brown",
    call: "call",
    clear: "\u0635\u0627\u0641|clear",
    color: "\u0631\u0646\u06AF|color",
    comma: "\u060C|,",
    def: "def",
    define: "define",
    echo: "\u067E\u06A9\u0627\u0631|echo",
    elif: "\u06CC\u0627\u0627\u06AF\u0631|elif",
    else: "\u0648\u0631\u0646\u06C1|else",
    for: "\u0641\u06CC|for",
    forward: "\u0622\u06AF\u06D2|forward",
    from: "\u0633\u06D2|from",
    gray: "\u06AF\u0631\u06D2|gray",
    green: "\u0633\u0628\u0632|green",
    if: "\u0627\u06AF\u0631|if",
    in: "\u0645\u06CC\u06BA|in",
    input: "\u0628\u062A\u0627\u0624|input",
    is: "\u06C1\u06D2|is",
    left: "\u0628\u0627\u0626\u06CC\u06BA|left",
    length: "\u0644\u0645\u0628\u0627\u0626\u06CC|length",
    or: "\u06CC\u0627|or",
    orange: "\u0627\u0648\u0631\u06CC\u0646\u062C|orange",
    pink: "\u06AF\u0644\u0627\u0628\u06CC|pink",
    play: "play",
    pressed: "\u062F\u0628\u0627 \u06C1\u0648\u0627|pressed",
    print: "\u062F\u06A9\u06BE\u0627\u0624|print",
    purple: "\u062C\u0627\u0645\u0646\u06CC|purple",
    random: "\u0633\u0627|random",
    range: "\u062D\u062F|range",
    red: "\u0633\u0631\u062E|red",
    remove: "\u0646\u06A9\u0627\u0644\u0648|remove",
    repeat: "\u0645\u06A9\u0631\u0631|repeat",
    return: "return",
    right: "\u062F\u0627\u0626\u06CC\u06BA|right",
    sleep: "\u0622\u0631\u0627\u0645|sleep",
    step: "\u0642\u062F\u0645|step",
    times: "\u062F\u0641\u0639\u06C1|times",
    to: "\u0633\u06D2|to",
    to_list: "\u0627\u0646\u062F\u0631|to",
    turn: "\u0645\u0691\u0648|turn",
    while: "\u062C\u0628\u062A\u06A9|while",
    white: "\u0633\u0641\u06CC\u062F|white",
    with: "with",
    yellow: "\u067E\u06CC\u0644\u0627|yellow",
    DIGIT: "0123456789"
  };
  var vi = {
    add: "add",
    and: "v\xE0|and",
    ask: "h\u1ECFi|ask",
    at: "at",
    black: "\u0111en|black",
    blue: "lam|blue",
    brown: "n\xE2u|brown",
    call: "call",
    clear: "clear",
    color: "m\xE0u|color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "\u0111\xE1p|echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "ti\u1EBFn|forward",
    from: "from",
    gray: "x\xE1m|gray",
    green: "l\u1EE5c|green",
    if: "n\u1EBFu|if",
    in: "in",
    input: "input",
    is: "l\xE0|is",
    left: "tr\xE1i|left",
    length: "length",
    or: "ho\u1EB7c|or",
    orange: "cam|orange",
    pink: "h\u1ED3ng|pink",
    play: "play",
    pressed: "pressed",
    print: "xu\u1EA5t|print",
    purple: "t\xEDm|purple",
    random: "ng\u1EABu_nhi\xEAn|random",
    range: "range",
    red: "\u0111\u1ECF|red",
    remove: "remove",
    repeat: "repeat",
    return: "return",
    right: "ph\u1EA3i|right",
    sleep: "sleep",
    step: "step",
    times: "times",
    to: "to",
    to_list: "to",
    turn: "quay|turn",
    while: "while",
    white: "tr\u1EAFng|white",
    with: "with",
    yellow: "v\xE0ng|yellow",
    DIGIT: "0123456789"
  };
  var zh_Hans = {
    add: "\u52A0|add",
    and: "\u5E76\u4E14|and",
    ask: "\u63D0\u95EE|ask",
    at: "\u5728|at",
    black: "\u9ED1\u8272|black",
    blue: "\u84DD\u8272|blue",
    brown: "\u68D5\u8272|brown",
    call: "call",
    clear: "\u6E05\u9664|clear",
    color: "\u989C\u8272|color",
    comma: "\uFF0C|\u3001|,",
    def: "def",
    define: "define",
    echo: "\u56DE\u58F0|echo",
    elif: "\u5426\u5219\u5982\u679C|elif",
    else: "\u5426\u5219|else",
    for: "\u53D6|for",
    forward: "\u5411\u524D|forward",
    from: "\u4ECE|from",
    gray: "\u7070\u8272|gray",
    green: "\u7EFF\u8272|green",
    if: "\u5982\u679C|if",
    in: "\u5728\u91CC\u9762|in",
    input: "\u8F93\u5165|input",
    is: "\u662F|is",
    left: "\u5DE6|left",
    length: "\u957F\u5EA6|length",
    or: "\u6216|or",
    orange: "\u6A59\u8272|orange",
    pink: "\u7C89\u7EA2\u8272|pink",
    play: "play",
    pressed: "\u6309\u4E0B|pressed",
    print: "\u6253\u5370|print",
    purple: "\u7D2B\u8272|purple",
    random: "\u968F\u673A|random",
    range: "\u8303\u56F4|range",
    red: "\u7EA2\u8272|red",
    remove: "\u79FB\u9664|remove",
    repeat: "\u91CD\u590D|repeat",
    return: "return",
    right: "\u53F3|right",
    sleep: "\u7761\u7720|sleep",
    step: "\u6B65|step",
    times: "\u6B21|times",
    to: "\u5230|to",
    to_list: "\u5230|to",
    turn: "\u65CB\u8F6C|turn",
    while: "\u5F53\u7684\u65F6\u5019|while",
    white: "\u767D\u8272|white",
    with: "with",
    yellow: "\u9EC4\u8272|yellow",
    DIGIT: "0123456789"
  };
  var zh_Hant = {
    add: "add",
    and: "and",
    ask: "ask",
    at: "at",
    black: "black",
    blue: "blue",
    brown: "brown",
    call: "call",
    clear: "clear",
    color: "color",
    comma: ",",
    def: "def",
    define: "define",
    echo: "echo",
    elif: "elif",
    else: "else",
    for: "for",
    forward: "forward",
    from: "from",
    gray: "gray",
    green: "green",
    if: "if",
    in: "in",
    input: "input",
    is: "is",
    left: "left",
    length: "length",
    or: "or",
    orange: "orange",
    pink: "pink",
    play: "play",
    pressed: "pressed",
    print: "print",
    purple: "purple",
    random: "random",
    range: "range",
    red: "red",
    remove: "remove",
    repeat: "repeat",
    return: "return",
    right: "right",
    sleep: "sleep",
    step: "step",
    times: "times",
    to: "to",
    to_list: "to",
    turn: "turn",
    while: "while",
    white: "white",
    with: "with",
    yellow: "yellow",
    DIGIT: "0123456789"
  };
  var highlighting_trad_default = {
    ar,
    bg,
    bn,
    ca,
    cs,
    cy,
    da,
    de,
    el,
    en,
    eo,
    es,
    et,
    fa,
    fi,
    fr,
    fy,
    he,
    hi,
    hu,
    id,
    it,
    ja,
    kmr,
    ko,
    mi,
    nb_NO,
    nl,
    pa_PK,
    pap,
    pl,
    pt_BR,
    pt_PT,
    ro,
    ru,
    sq,
    sr,
    sv,
    sw,
    te,
    th,
    tl,
    tn,
    tr,
    uk,
    ur,
    vi,
    zh_Hans,
    zh_Hant
  };

  // static/js/syntaxModesRules.ts
  function initializeSyntaxHighlighter(options) {
    let TRADUCTIONS = convert(highlighting_trad_default);
    let lang = options.keywordLanguage;
    if (!TRADUCTIONS.has(lang)) {
      lang = "en";
    }
    var TRADUCTION3 = TRADUCTIONS.get(lang);
    var data = JSON.stringify(highlighting_default);
    var data_tr = convertReg(data, TRADUCTION3);
    var LEVELS = JSON.parse(data_tr);
    if (window.define) {
      for (const level3 of LEVELS) {
        define("ace/mode/" + level3.name, [], function(require2, exports, _module) {
          var oop = require2("ace/lib/oop");
          var TextMode = require2("ace/mode/text").Mode;
          var TextHighlightRules = require2("ace/mode/text_highlight_rules").TextHighlightRules;
          function ThisLevelHighlightRules() {
            this.$rules = level3.rules;
            this.normalizeRules();
          }
          ;
          oop.inherits(ThisLevelHighlightRules, TextHighlightRules);
          function Mode() {
            this.HighlightRules = ThisLevelHighlightRules;
          }
          ;
          oop.inherits(Mode, TextMode);
          exports.Mode = Mode;
        });
      }
    }
  }
  function convert(o) {
    if (typeof o === "object") {
      let tmp = new Map(Object.entries(o));
      let ret = new Map();
      tmp.forEach((value, key) => {
        ret.set(key, convert(value));
      });
      return ret;
    } else {
      return o;
    }
  }
  function convertReg(oldReg, TRAD) {
    var newReg = oldReg;
    TRAD.forEach((value, key) => {
      key = key;
      var reg = new RegExp("__" + key + "__", "g");
      newReg = newReg.replace(reg, value);
    });
    return newReg;
  }

  // static/js/message-translations.ts
  var TRANSLATIONS = {
    "ar": {
      "CheckInternet": "\u0623\u0644\u0642\u064A \u0646\u0638\u0631\u0629 \u0625\u0630\u0627 \u0643\u0627\u0646 \u0627\u062A\u0635\u0627\u0644\u0643 \u0628\u0627\u0644\u0625\u0646\u062A\u0631\u0646\u062A \u064A\u0639\u0645\u0644 \u0628\u0634\u0643\u0644 \u0635\u062D\u064A\u062D.",
      "Connection_error": "\u0644\u0645 \u0646\u062A\u0645\u0643\u0646 \u0645\u0646 \u0627\u0644\u0648\u0635\u0648\u0644 \u0625\u0644\u0649 \u0627\u0644\u062E\u0627\u062F\u0645.",
      "Empty_output": "\u0647\u0630\u0627 \u0627\u0644\u0631\u0645\u0632 \u064A\u0639\u0645\u0644 \u0648\u0644\u0643\u0646 \u0644\u0627 \u064A\u0637\u0628\u0639 \u0623\u064A \u0634\u064A\u0621. \u0623\u0636\u0641 \u0623\u0645\u0631 \u0637\u0628\u0627\u0639\u0629 \u0625\u0644\u0649 \u0627\u0644\u0643\u0648\u062F \u0627\u0644\u062E\u0627\u0635 \u0628\u0643 \u0623\u0648 \u0627\u0633\u062A\u062E\u062F\u0645 \u0627\u0644\u0633\u0644\u062D\u0641\u0627\u0629 \u0644\u0637\u0628\u0627\u0639\u0629 \u0634\u064A\u0621 \u0645\u0627.",
      "Errors_found": "\u0644\u0642\u062F \u0642\u0645\u062A \u0628\u062E\u0637\u0623! \u0644\u0627 \u062A\u0642\u0644\u0642\u060C \u0644\u0642\u062F \u0642\u0645\u0646\u0627 \u0628\u062A\u0634\u063A\u064A\u0644 \u0627\u0644\u0628\u0631\u0646\u0627\u0645\u062C",
      "Execute_error": "\u062D\u062F\u062B \u062E\u0637\u0623 \u0645\u0627 \u0623\u062B\u0646\u0627\u0621 \u062A\u0634\u063A\u064A\u0644 \u0627\u0644\u0628\u0631\u0646\u0627\u0645\u062C.",
      "Other_error": "\u0639\u0641\u0648\u0627! \u0631\u0628\u0645\u0627 \u0627\u0631\u062A\u0643\u0628\u0646\u0627 \u062E\u0637\u0623 \u0628\u0633\u064A\u0637\u0627.",
      "Program_repair": "\u0642\u062F \u064A\u0643\u0648\u0646 \u0647\u0630\u0627 \u0647\u0648 \u0627\u0644\u0631\u0645\u0632 \u0627\u0644\u0635\u062D\u064A\u062D \u060C \u0647\u0644 \u064A\u0645\u0643\u0646\u0643 \u0625\u0635\u0644\u0627\u062D\u0647\u061F",
      "Program_too_long": "\u064A\u0633\u062A\u063A\u0631\u0642 \u0628\u0631\u0646\u0627\u0645\u062C\u0643 \u0648\u0642\u062A\u064B\u0627 \u0637\u0648\u064A\u0644\u0627\u064B \u0644\u0644\u062A\u0634\u063A\u064A\u0644.",
      "ServerError": "\u0644\u0642\u062F \u0643\u062A\u0628\u062A \u0628\u0631\u0646\u0627\u0645\u062C\u0627 \u0644\u0645 \u0646\u0643\u0646 \u0646\u062A\u0648\u0642\u0639\u0647. \u0625\u0630\u0627 \u0643\u0646\u062A \u062A\u0631\u063A\u0628 \u0641\u064A \u0627\u0644\u0645\u0633\u0627\u0639\u062F\u0629 \u060C \u0641\u0623\u0631\u0633\u0644 \u0644\u0646\u0627 \u0628\u0631\u064A\u062F\u0627 \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A\u0627 \u064A\u062D\u062A\u0648\u064A \u0639\u0644\u0649 \u0627\u0644\u0645\u0633\u062A\u0648\u0649 \u0648\u0627\u0644\u0628\u0631\u0646\u0627\u0645\u062C \u0627\u0644\u062E\u0627\u0635 \u0628\u0643 \u0639\u0644\u0649 hello@hedy.org. \u0641\u064A \u063A\u0636\u0648\u0646 \u0630\u0644\u0643 \u060C \u062C\u0631\u0628 \u0634\u064A\u0626\u0627 \u0645\u062E\u062A\u0644\u0641\u0627 \u0642\u0644\u064A\u0644\u0627 \u0648\u0623\u0644\u0642 \u0646\u0638\u0631\u0629 \u0623\u062E\u0631\u0649 \u0639\u0644\u0649 \u0627\u0644\u0623\u0645\u062B\u0644\u0629. \u0634\u0643\u0631\u0627!",
      "Transpile_error": "\u0644\u0627 \u064A\u0645\u0643\u0646\u0646\u0627 \u062A\u0634\u063A\u064A\u0644 \u0628\u0631\u0646\u0627\u0645\u062C\u0643.",
      "Transpile_success": "\u0623\u062D\u0633\u0646\u062A!\n\u0631\u0627\u0626\u0639!\n\u0623\u062D\u0633\u0646\u062A!\n\u0645\u0645\u062A\u0627\u0632!\n\u0644\u0642\u062F \u0642\u0645\u062A \u0628\u0639\u0645\u0644 \u0631\u0627\u0626\u0639!",
      "Transpile_warning": "\u062A\u062D\u0630\u064A\u0631!",
      "Unsaved_Changes": "\u0644\u062F\u064A\u0643 \u0628\u0631\u0646\u0627\u0645\u062C \u063A\u064A\u0631 \u0645\u062D\u0641\u0648\u0638. \u0647\u0644 \u062A\u0631\u064A\u062F \u0627\u0644\u0645\u063A\u0627\u062F\u0631\u0629 \u062F\u0648\u0646 \u062D\u0641\u0638\u0647\u061F",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "\u0627\u0646\u0633\u062E \u0627\u0644\u0631\u0627\u0628\u0637 \u0644\u0645\u0634\u0627\u0631\u0643\u062A\u0647",
      "customization_deleted": "\u062A\u0645 \u062D\u0630\u0641 \u0627\u0644\u062A\u062E\u0635\u064A\u0635\u0627\u062A \u0628\u0646\u062C\u0627\u062D.",
      "dice": "\u{1F3B2}",
      "directly_available": "\u0627\u0641\u062A\u062A\u062D \u0645\u0628\u0627\u0634\u0631\u0629",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "\u0645\u0633\u062A\u0648\u0649",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "\u0645\u0631\u062D\u0628\u0627\u064B \u0641\u064A \u0647\u064A\u062F\u064A! \u0628\u0643\u0644 \u0641\u062E\u0631 \u0623\u0646\u062A \u0627\u0644\u0622\u0646 \u062A\u0645\u062A\u0644\u0643 \u062D\u0633\u0627\u0628\u0627\u064B \u0643\u0645\u0639\u0644\u0645 \u0648\u0630\u0627 \u064A\u0633\u0645\u062D \u0644\u0643 \u0628\u0627\u0646\u0634\u0627\u0621 \u0635\u0641\u0648\u0641 \u0648\u062F\u0639\u0648\u0629 \u062A\u0644\u0627\u0645\u064A\u0630.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "bg": {
      "CheckInternet": "\u041F\u0440\u043E\u0431\u043B\u0435\u043C\u0438 \u0441 \u0438\u043D\u0442\u0435\u0440\u043D\u0435\u0442\u043D\u0430\u0442\u0430 \u0442\u0438 \u0432\u0440\u044A\u0437\u043A\u0430. \u0429\u0435 \u044F \u043F\u0440\u043E\u0432\u0435\u0440\u0438\u0448 \u043B\u0438.",
      "Connection_error": "\u0418\u0437\u0433\u0443\u0431\u0438\u0445\u043C\u0435 \u0432\u0440\u044A\u0437\u043A\u0430 \u0441\u044A\u0441 \u0441\u044A\u0440\u0432\u044A\u0440\u0430.",
      "Empty_output": "\u041A\u043E\u0434\u044A\u0442 \u0440\u0430\u0431\u043E\u0442\u0438, \u043D\u043E \u043D\u044F\u043C\u0430 \u043D\u0438\u0449\u043E \u0437\u0430 \u043F\u0440\u0438\u043D\u0442\u0438\u0440\u0430\u043D\u0435.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "\u041D\u0435\u0449\u043E \u0441\u0435 \u043E\u0431\u044A\u0440\u043A\u0430 \u043F\u0440\u0438 \u0438\u0437\u043F\u044A\u043B\u043D\u0435\u043D\u0438\u0435\u0442\u043E \u043D\u0430 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0430\u0442\u0430.",
      "Other_error": "\u041E\u0439! \u041C\u0430\u0439 \u0438\u043C\u0430\u043C\u0435 \u043D\u044F\u043A\u0430\u043A\u0432\u0430 \u0433\u0440\u0435\u0448\u043A\u0430 \u0432 \u043A\u043E\u0434\u0430.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "\u041F\u0442\u043E\u0433\u0440\u0430\u043C\u0430\u0442\u0430 \u0442\u0438 \u0441\u0435 \u0438\u0437\u043F\u044A\u043B\u043D\u044F\u0432\u0430 \u043F\u0440\u0435\u043A\u0430\u043B\u0435\u043D\u043E \u0434\u044A\u043B\u0433\u043E \u0432\u0440\u0435\u043C\u0435...",
      "ServerError": "\u041D\u0430\u043F\u0438\u0441\u0430\u043B(\u0430) \u0441\u0438 \u043A\u043E\u0434, \u043A\u043E\u0439\u0442\u043E \u043D\u0435 \u043E\u0447\u0430\u043A\u0432\u0430\u0445\u043C\u0435. \u041F\u043E\u043C\u043E\u0433\u043D\u0438 \u043D\u0438 \u0438 \u043D\u0438 \u0438\u0437\u043F\u0440\u0430\u0442\u0438 \u0438\u043C\u0435\u0439\u043B \u043D\u0430 hello@hedy.org \u0441 \u0438\u043C\u0435\u0442\u043E \u043D\u0430 \u043D\u0438\u0432\u043E\u0442\u043E, \u0432 \u043A\u043E\u0435\u0442\u043E \u0437\u0430\u0441\u0435\u0434\u043D\u0430. \u041F\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043B\u043D\u043E \u0431\u043B\u0430\u0433\u043E\u0434\u0430\u0440\u0438\u043C!",
      "Transpile_error": "\u041F\u0440\u043E\u0433\u0440\u0430\u043C\u0430\u0442\u0430 \u0442\u0438 \u043D\u0435 \u043C\u043E\u0436\u0435 \u0434\u0430 \u0431\u044A\u0434\u0435 \u0438\u0437\u043F\u044A\u043B\u043D\u0435\u043D\u0430.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "\u0412\u043D\u0438\u043C\u0430\u043D\u0438\u0435!",
      "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "\u041D\u0438\u0432\u043E",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "bn": {
      "CheckInternet": "Check whether your Internet connection is working.",
      "Connection_error": "We couldn't reach the server.",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Something went wrong while running the program.",
      "Other_error": "Oops! Maybe we made a little mistake.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "We can't run your program.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "Warning!",
      "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "ca": {
      "CheckInternet": "Mireu si la vostra connexi\xF3 a Internet funciona correctament.",
      "Connection_error": "No hem pogut arribar al servidor.",
      "Empty_output": "Aquest codi funciona, per\xF2 no imprimeix res. Afegiu una comanda d'impressi\xF3 al vostre codi o utilitzeu la tortuga per obtenir la sortida.",
      "Errors_found": "Has com\xE8s un error! No et preocupis, encara podem executar el programa",
      "Execute_error": "S'ha produ\xEFt un error en executar el programa.",
      "Other_error": "Vaja! Potser ens hem equivocat una mica.",
      "Program_repair": "Aquest podria ser el codi correcte, el pots arreglar?",
      "Program_too_long": "El vostre programa triga massa a executar-se.",
      "ServerError": "Has escrit un programa que no esper\xE0vem. Si vols ajudar, envia'ns un correu amb el nivell i el teu programa a hello@hedy.org. Mentrestant, proveu alguna cosa una mica diferent i feu una altra ullada als exemples. Gr\xE0cies!",
      "Transpile_error": "No podem executar el vostre programa.",
      "Transpile_success": "Ben fet!\nIncre\xEFble!\nBen fet!\nExcel\xB7lent!\nHo has fet genial!",
      "Transpile_warning": "Vigila!",
      "Unsaved_Changes": "Tens un programa sense desar. Vols marxar sense desar-lo?",
      "adventures_restored": "Les aventures per defecte han estat restaurades.",
      "copy_link_to_share": "Copia l'enlla\xE7 per compartir",
      "customization_deleted": "Personalitzacions esborrades correctament.",
      "dice": "\u{1F3B2}",
      "directly_available": "Obrir directament",
      "disabled": "Desactivat",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Nivell",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5}, \u{1F3B6}",
      "teacher_welcome": "Benvinguda a Hedy! El teu compte s'ha actualitzat a compte de professorat. Aix\xF2 et permetr\xE0 crear classes i convidar alumnes.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "Hi ha canvis no guardats, segur que voleu sortir d'aquesta p\xE0gina?"
    },
    "cs": {
      "CheckInternet": "Pros\xEDm, zkontroluj sv\xE9 p\u0159ipojen\xED k Internetu.",
      "Connection_error": "Nelze se p\u0159ipojit k serveru.",
      "Empty_output": "Tento k\xF3d funguje, ale nem\xE1 \u017E\xE1dn\xFD v\xFDstup. Pou\u017Eij p\u0159\xEDkaz print do k\xF3du nebo pou\u017Eij \u017Eelvu k z\xEDsk\xE1n\xED v\xFDstupu.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "P\u0159i prov\xE1d\u011Bn\xED programu se n\u011Bco pokazilo.",
      "Other_error": "Jejda! Asi jsme n\u011Bkde ud\u011Blali men\u0161\xED chybu.",
      "Program_repair": "Tohle by mohl b\xFDt spr\xE1vn\xFD z\xE1pis k\xF3du, m\u016F\u017Ee\u0161 to opravit?",
      "Program_too_long": "Tv\u016Fj program b\u011B\u017E\xED p\u0159\xEDl\xED\u0161 dlouho.",
      "ServerError": "Napsal*a jsi program, kter\xFD jsme ne\u010Dekali. Pokud pot\u0159ebuje\u0161 pomoc, po\u0161li n\xE1m e-mail s \u010D\xEDslem \xFArovn\u011B a sv\xFDm k\xF3dem na hello@hedy.org. Mezit\xEDm m\u016F\u017Ee\u0161 zkusit \xFAkol vy\u0159e\u0161it n\u011Bjak jinak nebo se znova pod\xEDvat na p\u0159\xEDklady. D\xEDky!",
      "Transpile_error": "Nelze spustit tv\u016Fj program.",
      "Transpile_success": "Dobr\xE1 pr\xE1ce!\n\xDA\u017Easn\xE9!\nSkv\u011Bl\xE9!\nV\xFDte\u010Dn\xE9!\nVede\u0161 si v\xFDborn\u011B!",
      "Transpile_warning": "Pozor!",
      "Unsaved_Changes": "Tv\u016Fj program nen\xED ulo\u017Een\xFD. Chce\u0161 odej\xEDt bez ulo\u017Een\xED?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Zkop\xEDrovat odkaz ke sd\xEDlen\xED",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "\xDArove\u0148",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "cy": {
      "CheckInternet": "Edrychwch os yw eich cysylltiad rhyngrwyd yn gweithio'n iawn.",
      "Connection_error": "Ni allem gyrraedd y gweinydd.",
      "Empty_output": "Mae'r cod hwn yn gweithio ond nid yw'n argraffu unrhyw beth. Ychwanegwch orchymyn argraffu i'ch cod neu defnyddiwch y crwban i gael allbwn.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Aeth rhywbeth o'i le wrth redeg y rhaglen.",
      "Other_error": "\u0174ps! Efallai ein bod wedi gwneud camgymeriad bach.",
      "Program_repair": "Gallai hwn fod y cod cywir, allwch chi ei drwsio?",
      "Program_too_long": "Mae eich rhaglen yn cymryd gormod o amser i'w rhedeg.",
      "ServerError": "Fe wnaethoch chi ysgrifennu rhaglen nad oeddem yn ei disgwyl. Os ydych chi eisiau helpu, anfonwch e-bost atom gyda'r lefel a'ch rhaglen yn hello@hedy.org. Yn y cyfamser, rhowch gynnig ar rywbeth ychydig yn wahanol ac edrychwch eto ar yr enghreifftiau. Diolch!",
      "Transpile_error": "Ni allwn redeg eich rhaglen.",
      "Transpile_success": "Gwaith da!\nAnhygoel!\nDa iawn!\nArdderchog!\nFe wnaethoch chi waith gwych!",
      "Transpile_warning": "Rhybudd!",
      "Unsaved_Changes": "Mae gennych raglen heb ei chadw. Ydych chi eisiau gadael heb ei arbed?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "da": {
      "CheckInternet": "Check whether your Internet connection is working.",
      "Connection_error": "We couldn't reach the server.",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Something went wrong while running the program.",
      "Other_error": "Oops! Maybe we made a little mistake.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "We can't run your program.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "Warning!",
      "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "de": {
      "CheckInternet": "Funktioniert deine Internetverbindung.",
      "Connection_error": "Wir konnten den Server nicht erreichen.",
      "Empty_output": "Dieses Programm funktioniert aber gibt nichts aus. F\xFCge ein `print` Befehl hinzu oder benutz die Schildkr\xF6t um eine Ausgabe zu bekommen.",
      "Errors_found": "Du hast einen Fehler gemacht! Keine Sorge, wir haben das Programm trotzdem ausgef\xFChrt",
      "Execute_error": "Etwas ist beim Ausf\xFChren des Programms schiefgegangen.",
      "Other_error": "Hoppla! Vielleicht haben wir einen kleinen Fehler gemacht.",
      "Program_repair": "Das k\xF6nnte der korrekte Code sein, kannst du es beheben?",
      "Program_too_long": "Dein Programm ist zu lang um es auszuf\xFChren.",
      "ServerError": "Du hast ein Programm geschrieben das wir nicht erwartet haben. Wenn du uns hlefen m\xF6chtest, dann sende eine Email an hello@hedy.org und gib darin das Level an in dem du dieses Programm geschrieben hast und f\xFCge den Programmcode hinzu. In der Zwischenzeit, probiere aus es ein bisschen anders zu formulieren und schau nochmal in die Beispiele. Danke!",
      "Transpile_error": "Wir konnten Ihr Hedy-Programm nicht lesen.",
      "Transpile_success": "Gut gemacht!\nToll!\nSehr gut gemacht!\nAusgezeichnet!\nDas hast du gro\xDFartig gemacht!",
      "Transpile_warning": "Warnung!",
      "Unsaved_Changes": "Du hast ein nicht gespeichertes Programm. M\xF6chtest du es verwerfen, ohne zu speichern?",
      "adventures_restored": "Die Standardabenteuer wurden wiederhergestellt.",
      "copy_link_to_share": "Kopiere Link zum Weitergeben",
      "customization_deleted": "Anpassungen erfolgreich gel\xF6scht.",
      "dice": "\u{1F3B2}",
      "directly_available": "Direkt \xF6ffnen",
      "disabled": "Deaktiviert",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Willkommen bei Hedy! Du bist nun eine stolze BesitzerIn eines LehrerIn Kontos, welches dir erlaubt Klassen zu erstellen und Sch\xFCler einzuladen.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "Es gibt ungespeicherte \xC4nderungen, bist du dir sicher, dass du diese Seite verlassen m\xF6chtest?"
    },
    "el": {
      "CheckInternet": "\u03A1\u03AF\u03BE\u03B5 \u03BC\u03B9\u03B1 \u03BC\u03B1\u03C4\u03B9\u03AC \u03B1\u03BD \u03B7 \u03C3\u03CD\u03BD\u03B4\u03B5\u03C3\u03B7 \u03C3\u03BF\u03C5 \u03C3\u03C4\u03BF \u0394\u03B9\u03B1\u03B4\u03AF\u03BA\u03C4\u03C5\u03BF \u03B4\u03BF\u03C5\u03BB\u03B5\u03CD\u03B5\u03B9 \u03C3\u03C9\u03C3\u03C4\u03AC.",
      "Connection_error": "\u0394\u03B5\u03BD \u03BC\u03C0\u03BF\u03C1\u03AD\u03C3\u03B1\u03BC\u03B5 \u03BD\u03B1 \u03B2\u03C1\u03BF\u03CD\u03BC\u03B5 \u03C4\u03BF \u03B4\u03B9\u03B1\u03BA\u03BF\u03BC\u03B9\u03C3\u03C4\u03AE.",
      "Empty_output": "\u0391\u03C5\u03C4\u03CC\u03C2 \u03BF \u03BA\u03CE\u03B4\u03B9\u03BA\u03B1\u03C2 \u03BB\u03B5\u03B9\u03C4\u03BF\u03C5\u03C1\u03B3\u03B5\u03AF \u03B1\u03BB\u03BB\u03AC \u03B4\u03B5\u03BD \u03B5\u03BC\u03C6\u03B1\u03BD\u03AF\u03B6\u03B5\u03B9 \u03BA\u03AC\u03C4\u03B9. \u03A0\u03C1\u03CC\u03C3\u03B8\u03B5\u03C3\u03B5 \u03BC\u03B9\u03B1 \u03B5\u03BD\u03C4\u03BF\u03BB\u03AE \u03B5\u03BC\u03C6\u03AC\u03BD\u03B9\u03C3\u03B7\u03C2 \u03C3\u03C4\u03BF\u03BD \u03BA\u03CE\u03B4\u03B9\u03BA\u03AC \u03C3\u03BF\u03C5 \u03AE \u03C7\u03C1\u03B7\u03C3\u03B9\u03BC\u03BF\u03C0\u03BF\u03AF\u03B7\u03C3\u03B5 \u03C4\u03B7 \u03C7\u03B5\u03BB\u03CE\u03BD\u03B1 \u03B3\u03B9\u03B1 \u03BD\u03B1 \u03AD\u03C7\u03B5\u03B9\u03C2 \u03AD\u03BE\u03BF\u03B4\u03BF.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "\u039A\u03AC\u03C4\u03B9 \u03C0\u03AE\u03B3\u03B5 \u03C3\u03C4\u03C1\u03B1\u03B2\u03AC \u03CC\u03C3\u03BF \u03B5\u03BA\u03C4\u03B5\u03BB\u03BF\u03CD\u03C3\u03B1\u03BC\u03B5 \u03C4\u03BF \u03C0\u03C1\u03CC\u03B3\u03C1\u03B1\u03BC\u03BC\u03B1.",
      "Other_error": "\u039F\u03C5\u03C0\u03C2! \u038A\u03C3\u03C9\u03C2 \u03BD\u03B1 \u03BA\u03AC\u03BD\u03B1\u03BC\u03B5 \u03BA\u03AC\u03C0\u03BF\u03B9\u03BF \u03BB\u03B1\u03B8\u03AC\u03BA\u03B9.",
      "Program_repair": "\u0391\u03C5\u03C4\u03CC\u03C2 \u03BC\u03C0\u03BF\u03C1\u03B5\u03AF \u03BD\u03B1 \u03B5\u03AF\u03BD\u03B1\u03B9 \u03BF \u03C3\u03C9\u03C3\u03C4\u03CC\u03C2 \u03BA\u03CE\u03B4\u03B9\u03BA\u03B1\u03C2, \u03BC\u03C0\u03BF\u03C1\u03B5\u03AF\u03C2 \u03BD\u03B1 \u03C4\u03BF\u03BD \u03B4\u03B9\u03BF\u03C1\u03B8\u03CE\u03C3\u03B5\u03B9\u03C2;",
      "Program_too_long": "\u03A4\u03BF \u03C0\u03C1\u03CC\u03B3\u03C1\u03B1\u03BC\u03BC\u03AC \u03C3\u03BF\u03C5 \u03C0\u03B1\u03AF\u03C1\u03BD\u03B5\u03B9 \u03C0\u03BF\u03BB\u03CD \u03C7\u03C1\u03CC\u03BD\u03BF \u03B3\u03B9\u03B1 \u03BD\u03B1 \u03B5\u03BA\u03C4\u03B5\u03BB\u03B5\u03C3\u03C4\u03B5\u03AF.",
      "ServerError": "\u0388\u03B3\u03C1\u03B1\u03C8\u03B5\u03C2 \u03AD\u03BD\u03B1 \u03C0\u03C1\u03CC\u03B3\u03C1\u03B1\u03BC\u03BC\u03B1 \u03C0\u03BF\u03C5 \u03B4\u03B5\u03BD \u03C0\u03B5\u03C1\u03B9\u03BC\u03AD\u03BD\u03B1\u03BC\u03B5. \u0391\u03BD \u03B8\u03AD\u03BB\u03B5\u03C4\u03B5 \u03BD\u03B1 \u03B2\u03BF\u03B7\u03B8\u03AE\u03C3\u03B5\u03B9\u03C2, \u03C3\u03C4\u03B5\u03AF\u03BB\u03B5 \u03BC\u03B1\u03C2 \u03AD\u03BD\u03B1 email \u03BC\u03B5 \u03C4\u03BF \u03B5\u03C0\u03AF\u03C0\u03B5\u03B4\u03BF \u03BA\u03B1\u03B9 \u03C4\u03BF \u03C0\u03C1\u03CC\u03B3\u03C1\u03B1\u03BC\u03BC\u03AC \u03C3\u03BF\u03C5 at hello@hedy.org. \u0395\u03BD \u03C4\u03C9 \u03BC\u03B5\u03C4\u03B1\u03BE\u03CD, \u03B4\u03BF\u03BA\u03AF\u03BC\u03B1\u03C3\u03B5 \u03BA\u03AC\u03C4\u03B9 \u03BB\u03AF\u03B3\u03BF \u03B4\u03B9\u03B1\u03C6\u03BF\u03C1\u03B5\u03C4\u03B9\u03BA\u03CC \u03BA\u03B1\u03B9 \u03C1\u03AF\u03BE\u03B5 \u03AC\u03BB\u03BB\u03B7 \u03BC\u03B9\u03B1 \u03BC\u03B1\u03C4\u03B9\u03AC \u03C3\u03C4\u03B1 \u03C0\u03B1\u03C1\u03B1\u03B4\u03B5\u03AF\u03B3\u03BC\u03B1\u03C4\u03B1. \u0395\u03C5\u03C7\u03B1\u03C1\u03B9\u03C3\u03C4\u03CE!",
      "Transpile_error": "\u0394\u03B5\u03BD \u03BC\u03C0\u03BF\u03C1\u03BF\u03CD\u03BC\u03B5 \u03BD\u03B1 \u03B5\u03BA\u03C4\u03B5\u03BB\u03AD\u03C3\u03BF\u03C5\u03BC\u03B5 \u03C4\u03BF \u03C0\u03C1\u03CC\u03B3\u03C1\u03B1\u03BC\u03BC\u03AC \u03C3\u03BF\u03C5.",
      "Transpile_success": "\u039A\u03B1\u03BB\u03AE \u03B4\u03BF\u03C5\u03BB\u03B5\u03B9\u03AC!\n\u0395\u03BE\u03B1\u03B9\u03C1\u03B5\u03C4\u03B9\u03BA\u03AC!\n\u039C\u03C0\u03C1\u03AC\u03B2\u03BF!\n\u03A5\u03C0\u03AD\u03C1\u03BF\u03C7\u03B1!\n\u03A4\u03B1 \u03C0\u03AE\u03B3\u03B5\u03C2 \u03C5\u03C0\u03AD\u03C1\u03BF\u03C7\u03B1!",
      "Transpile_warning": "\u03A0\u03C1\u03BF\u03C3\u03BF\u03C7\u03AE!",
      "Unsaved_Changes": "\u0388\u03C7\u03B5\u03B9\u03C2 \u03AD\u03BD\u03B1 \u03BC\u03B7 \u03B1\u03C0\u03BF\u03B8\u03B7\u03BA\u03B5\u03C5\u03BC\u03AD\u03BD\u03BF \u03C0\u03C1\u03CC\u03B3\u03C1\u03B1\u03BC\u03BC\u03B1. \u0398\u03AD\u03BB\u03B5\u03B9\u03C2 \u03BD\u03B1 \u03B1\u03C0\u03BF\u03C7\u03C9\u03C1\u03AE\u03C3\u03B5\u03B9\u03C2 \u03C7\u03C9\u03C1\u03AF\u03C2 \u03BD\u03B1 \u03C4\u03BF \u03B1\u03C0\u03BF\u03B8\u03B7\u03BA\u03B5\u03CD\u03C3\u03B5\u03B9\u03C2;",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "\u0391\u03BD\u03C4\u03AF\u03B3\u03C1\u03B1\u03C8\u03B5 \u03C4\u03BF\u03BD \u03C3\u03CD\u03BD\u03B4\u03B5\u03C3\u03BC\u03BF \u03B3\u03B9\u03B1 \u03BA\u03BF\u03B9\u03BD\u03AE \u03C7\u03C1\u03AE\u03C3\u03B7",
      "customization_deleted": "\u039F\u03B9 \u03C0\u03C1\u03BF\u03C3\u03B1\u03C1\u03BC\u03BF\u03B3\u03AD\u03C2 \u03B4\u03B9\u03B1\u03B3\u03C1\u03AC\u03C6\u03B7\u03C3\u03B1\u03BD \u03BC\u03B5 \u03B5\u03C0\u03B9\u03C4\u03C5\u03C7\u03AF\u03B1.",
      "dice": "\u{1F3B2}",
      "directly_available": "\u0386\u03BC\u03B5\u03C3\u03B1 \u03B1\u03BD\u03BF\u03B9\u03C7\u03C4\u03CC",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "\u0395\u03C0\u03AF\u03C0\u03B5\u03B4\u03BF",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "\u039A\u03B1\u03BB\u03CE\u03C2 \u03AE\u03C1\u03B8\u03B5\u03C2 \u03C3\u03C4\u03B7 Hedy! \u0395\u03AF\u03C3\u03B1\u03B9 \u03C0\u03BB\u03AD\u03BF\u03BD \u03C0\u03B5\u03C1\u03AE\u03C6\u03B1\u03BD\u03BF\u03C2 \u03BA\u03AC\u03C4\u03BF\u03C7\u03BF\u03C2 \u03B5\u03BD\u03CC\u03C2 \u03BB\u03BF\u03B3\u03B1\u03C1\u03B9\u03B1\u03C3\u03BC\u03BF\u03CD \u03BA\u03B1\u03B8\u03B7\u03B3\u03B7\u03C4\u03AE \u03C0\u03BF\u03C5 \u03C3\u03BF\u03C5 \u03B5\u03C0\u03B9\u03C4\u03C1\u03AD\u03C0\u03B5\u03B9 \u03BD\u03B1 \u03B4\u03B7\u03BC\u03B9\u03BF\u03C5\u03C1\u03B3\u03B5\u03AF\u03C2 \u03BC\u03B1\u03B8\u03AE\u03BC\u03B1\u03C4\u03B1 \u03BA\u03B1\u03B9 \u03BD\u03B1 \u03C0\u03C1\u03BF\u03C3\u03BA\u03B1\u03BB\u03B5\u03AF\u03C2 \u03BC\u03B1\u03B8\u03B7\u03C4\u03AD\u03C2.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "en": {
      "CheckInternet": "Check whether your Internet connection is working.",
      "Connection_error": "We couldn't reach the server.",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, we still ran the program",
      "Execute_error": "Something went wrong while running the program.",
      "Other_error": "Oops! Maybe we made a little mistake.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "We can't run your program.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "Warning!",
      "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
      "adventures_restored": "The default adventures have been restored.",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "eo": {
      "CheckInternet": "Kontrolu, \u0109u via Interreta konekto funkcias \u011Duste.",
      "Connection_error": "Ni ne povis atingi la servilon.",
      "Empty_output": "Tiu kodo funkcias sed presas nenion. Enmetu presan komandon en vian kodon, a\u016D uzu la testudon por vidi ion.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Io misfunkciis dum rulado de la programo.",
      "Other_error": "Ho! Eble ni iomete eraris.",
      "Program_repair": "Tio povus esti la \u011Dusta kodo; \u0109u vi povas ripari \u011Din?",
      "Program_too_long": "Ruli vian programon bezonas troon da tempo.",
      "ServerError": "Vi verkis programon, kiun ni ne atendis. Se vi volas helpi, sendu al ni retmesa\u011Don menciantan la nivelon kaj vian programon \u0109e hello@hedy.org. Dume, provu ion alietan, kaj rerigardu la ekzemplojn. Dankon!",
      "Transpile_error": "Ni ne povas ruli vian programon.",
      "Transpile_success": "Bona laboro!\nMirinda!\nBone farita!\nBonega!\nVi bonege faris!",
      "Transpile_warning": "Atentu!",
      "Unsaved_Changes": "Via programo estas ne konservita. \u0108u vi volas foriri sen konservi \u011Din?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Rekte malfermi",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Nivelo",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "es": {
      "CheckInternet": "Comprueba si tu conexi\xF3n a Internet funciona.",
      "Connection_error": "No se ha podido conectar con el servidor.",
      "Empty_output": "Este c\xF3digo funciona pero no imprime nada. Agrega un comando print a tu c\xF3digo o usa una tortuga para mostrar salida.",
      "Errors_found": "\xA1Has cometido un error! No te preocupes, seguimos ejecutando el programa",
      "Execute_error": "Algo sali\xF3 mal mientras se ejecutaba el programa.",
      "Other_error": "\xA1Ups! Quiz\xE1s hemos cometido un peque\xF1o error.",
      "Program_repair": "Este podr\xEDa ser c\xF3digo correcto, \xBFlo puedes arreglar?",
      "Program_too_long": "Tu programa toma demasiado tiempo en ejecutarse.",
      "ServerError": "Escribiste un programa que no esper\xE1bamos. Si quieres ayudar, env\xEDanos un email con el nivel y tu programa a hello@hedy.org. Mientras tanto, intenta algo un poco diferente y \xE9chale otro vistazo a los ejemplos. \xA1Gracias!",
      "Transpile_error": "No podemos ejecutar este programa.",
      "Transpile_success": "\xA1Buen trabajo!\n\xA1Increible!\n\xA1Bien hecho!\n\xA1Excelente!\n\xA1Lo hiciste genial!",
      "Transpile_warning": "\xA1Cuidado!",
      "Unsaved_Changes": "Tu programa no se ha guardado. \xBFDeseas irte sin guardarlo?",
      "adventures_restored": "Se han restaurado las aventuras por defecto.",
      "copy_link_to_share": "Copiar enlace para compartir",
      "customization_deleted": "Personalizaci\xF3n eliminada.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directamente abierto",
      "disabled": "Deshabilitado",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Nivel",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "\xA1Bienvenido/a a Hedy! Tu cuenta es de tipo profesor, por lo que puedes crear clases e invitar estudiantes.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "Hay cambios sin guardar, \xBFest\xE1s seguro de que quieres abandonar esta p\xE1gina?"
    },
    "et": {
      "CheckInternet": "Kontrolli kas su interneti\xFChendus t\xF6\xF6tab korralikult.",
      "Connection_error": "Me ei saanud serveriga \xFChendust.",
      "Empty_output": "See programm t\xF6\xF6tab, aga ei kirjuta midagi ekraanile. Lisa printimise k\xE4sk oma koodi v\xF5i kasuta kilpkonna, et saada v\xE4ljundit.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Midagi l\xE4ks programmi k\xE4ivitamisel valesti.",
      "Other_error": "Oih! V\xF5ib-olla me tegime programmis v\xE4ikese vea.",
      "Program_repair": "See programm saaks olla \xF5ige, kas sa oskad seda parandada?",
      "Program_too_long": "Sinu programm v\xF5tab p\xE4rast k\xE4ivitamist liiga kaua aega.",
      "ServerError": "Sa oled kirjutanud sellise programmi, mida me ei oodanud. Kui sa tahad meid aidata, siis saada meil aadressile hello@hedy.org. Kirjuta meili oma tase ja programm. Samal ajal proovi oma programmi natukene muuta, et sa saaksid edasi minna. Vaata uuesti n\xE4idiseid, kui on vaja. Suur t\xE4nu!",
      "Transpile_error": "Me ei saa sinu programmi k\xE4ivitada.",
      "Transpile_success": "Tubli!\nV\xE4ga tubli!\nSuurep\xE4rane!\nSuper!\nV\xE4ga v\xE4ga tubli!",
      "Transpile_warning": "Hoiatus!",
      "Unsaved_Changes": "Sinu programm ei ole salvestatud. Kas sa tahad lahkuda ilma seda salvestamata?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Tere tulemast Hedy juurde! Sul on n\xFC\xFCd \xF5petaja konto. See annab sulle v\xF5imaluse klasse luua ja \xF5pilasi \xFChinema kutsuda.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "fa": {
      "CheckInternet": "\u0628\u0628\u06CC\u0646 \u0622\u06CC\u0627 \u0627\u062A\u0635\u0627\u0644 \u0627\u06CC\u0646\u062A\u0631\u0646\u062A \u0634\u0645\u0627 \u0628\u0647 \u062F\u0631\u0633\u062A\u06CC \u06A9\u0627\u0631 \u0645\u06CC \u06A9\u0646\u062F.",
      "Connection_error": "\u0646\u0645\u06CC\u062A\u0648\u0646\u06CC\u0645 \u0628\u0647 \u0633\u0631\u0648\u0631 \u062F\u0633\u062A\u0631\u0633\u06CC \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u06CC\u0645.",
      "Empty_output": "\u0627\u06CC\u0646 \u06A9\u062F \u06A9\u0627\u0631 \u0645\u06CC \u06A9\u0646\u062F \u0627\u0645\u0627 \u0686\u06CC\u0632\u06CC \u0631\u0627 \u0686\u0627\u067E \u0646\u0645\u06CC \u06A9\u0646\u062F. \u06CC\u06A9 \u062F\u0633\u062A\u0648\u0631 \u0686\u0627\u067E \u0631\u0627 \u0628\u0647 \u06A9\u062F \u062E\u0648\u062F \u0627\u0636\u0627\u0641\u0647 \u06A9\u0646 \u06CC\u0627 \u0627\u0632 \u0644\u0627\u06A9 \u067E\u0634\u062A \u0628\u0631\u0627\u06CC \u062E\u0631\u0648\u062C\u06CC \u0627\u0633\u062A\u0641\u0627\u062F\u0647 \u06A9\u0646.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "\u0647\u0646\u06AF\u0627\u0645 \u0627\u062C\u0631\u0627\u06CC \u0628\u0631\u0646\u0627\u0645\u0647 \u0645\u0634\u06A9\u0644\u06CC \u067E\u06CC\u0634 \u0622\u0645\u062F.",
      "Other_error": "\u0627\u0648\u0647! \u0645\u0645\u06A9\u0646\u0647 \u0645\u0627 \u06CC\u06A9 \u0627\u0634\u062A\u0628\u0627\u0647 \u06A9\u0648\u0686\u06A9\u06CC \u06A9\u0631\u062F\u06CC\u0645.",
      "Program_repair": "\u0627\u06CC\u0646 \u0645\u06CC\u062A\u0648\u0646\u0647 \u06A9\u062F \u0635\u062D\u06CC\u062D \u0628\u0627\u0634\u0647\u060C \u0645\u06CC\u062A\u0648\u0646\u06CC \u062F\u0631\u0633\u062A\u0634 \u06A9\u0646\u06CC\u061F",
      "Program_too_long": "\u0627\u062C\u0631\u0627\u06CC \u0628\u0631\u0646\u0627\u0645\u0647 \u0627\u062A \u062E\u06CC\u0644\u06CC \u0637\u0648\u0644 \u0645\u06CC \u06A9\u0634\u0647.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "\u0646\u0645\u06CC\u062A\u0648\u0646\u06CC \u0628\u0631\u0646\u0627\u0645\u0647 \u0627\u062A \u0631\u0627 \u0627\u062C\u0631\u0627 \u06A9\u0646\u06CC.",
      "Transpile_success": "\u0622\u0641\u0631\u06CC\u0646!\n\u0634\u06AF\u0641\u062A \u0627\u0646\u06AF\u064A\u0632\u0647!\n\u0622\u0641\u0631\u06CC\u0646!\n\u0639\u0627\u0644\u06CC!\n\u06A9\u0627\u0631\u062A \u0639\u0627\u0644\u06CC \u0628\u0648\u062F!",
      "Transpile_warning": "\u0647\u0634\u062F\u0627\u0631!",
      "Unsaved_Changes": "\u06CC\u06A9 \u0628\u0631\u0646\u0627\u0645\u0647 \u0630\u062E\u06CC\u0631\u0647 \u0646\u0634\u062F\u0647 \u062F\u0627\u0631\u06CC. \u0622\u06CC\u0627 \u0645\u06CC \u062E\u0648\u0627\u0647\u06CC \u0628\u062F\u0648\u0646 \u0630\u062E\u06CC\u0631\u0647 \u0622\u0646 \u0631\u0627 \u062A\u0631\u06A9 \u06A9\u0646\u06CC\u061F",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "fi": {
      "CheckInternet": "Check whether your Internet connection is working.",
      "Connection_error": "We couldn't reach the server.",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Something went wrong while running the program.",
      "Other_error": "Oops! Maybe we made a little mistake.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "We can't run your program.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "Warning!",
      "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "fr": {
      "CheckInternet": "V\xE9rifie que ta connexion Internet fonctionne correctement.",
      "Connection_error": "Nous n\u2019avons pas r\xE9ussi \xE0 contacter le serveur.",
      "Empty_output": "Ce code fonctionne mais n'imprime rien. Ajoute une commande d'affichage \xE0 ton code ou utilise la tortue pour obtenir un r\xE9sultat.",
      "Errors_found": "Tu as fait une erreur\xA0! Ne t'inqui\xE8te pas, nous avons ex\xE9cut\xE9 quand m\xEAme le programme",
      "Execute_error": "Quelque chose s\u2019est mal pass\xE9 en ex\xE9cutant ce programme.",
      "Other_error": "Oups\xA0! Peut-\xEAtre que nous faisons une petite erreur.",
      "Program_repair": "Ceci pourrait \xEAtre le bon code, peux-tu le r\xE9parer\xA0?",
      "Program_too_long": "Ton programme prend trop de temps \xE0 s'ex\xE9cuter.",
      "ServerError": "Tu as \xE9crit un programme que nous n'attendions pas. Si tu veux nous aider, envoie-nous un email avec le niveau et ton programme \xE0 hello@hedy.org. En attendant, essaye quelque chose d'un peu diff\xE9rent et regarde \xE0 nouveau les exemples. Merci\xA0!",
      "Transpile_error": "Nous ne pouvons pas ex\xE9cuter ton programme.",
      "Transpile_success": "Bon travail\xA0!\nFantastique\xA0!\nBien jou\xE9\xA0!\nExcellent\xA0!\nTu as fait du bon travail\xA0!",
      "Transpile_warning": "Attention\xA0!",
      "Unsaved_Changes": "Le programme en cours n'a pas \xE9t\xE9 sauvegard\xE9. Souhaites-tu vraiment quitter sans le sauvegarder\xA0?",
      "adventures_restored": "Les aventures par d\xE9faut ont \xE9t\xE9 r\xE9tablies.",
      "copy_link_to_share": "Copier le lien \xE0 partager",
      "customization_deleted": "Modifications effac\xE9es avec succ\xE8s.",
      "dice": "\u{1F3B2}",
      "directly_available": "Ouvrir imm\xE9diatement",
      "disabled": "D\xE9sactiv\xE9",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Niveau",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Bienvenue chez Hedy ! Vous \xEAtes maintenant l'heureux propri\xE9taire d'un compte enseignant qui vous permet de cr\xE9er des cours et d'inviter des \xE9tudiants.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "Il y a des changements non pris en comptes, es-tu sur de vouloir quitter la page ?"
    },
    "fy": {
      "CheckInternet": "Wolst eefkes kontrolearje oft dyn internet it noch wol docht.",
      "Connection_error": "Der is in ferbiningsprobleem. It leit f\xEAst oan \xFAs, mar miskien docht dyn internet it eefkes net.",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "It draaien fan de koade gong niet hielendal goed.",
      "Other_error": "Krammele! Dat gong net goed, wy ha sels f\xEAst in programmearflater makke.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "Hast in programma skreaun dat wy net ferwachte hienen. Ast \xFAs helpe wolst, stjoer \xFAs dan in mailtsje mei in level en dyn programma nei hello@hedy.org. Besykje dyn programma in bytsje oan te passen om fierder te gean en sjochris nei de foarbylden. Dankewol!",
      "Transpile_error": "Dyn koade wie net hielendal goed.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "Tink derom!",
      "Unsaved_Changes": "Dyn programma is net bewarre. Wolst fuortgean s\xFBnder it te bewarjen?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Diellink kopi\xEBare",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "he": {
      "CheckInternet": "\u05D1\u05D3\u05E7\u05D5 \u05D0\u05DD \u05D7\u05D9\u05D1\u05D5\u05E8 \u05D4\u05D0\u05D9\u05E0\u05D8\u05E8\u05E0\u05D8 \u05E9\u05DC\u05DB\u05DD.\u05DF \u05E4\u05D5\u05E2\u05DC \u05DB\u05E8\u05D0\u05D5\u05D9.",
      "Connection_error": "\u05DC\u05D0 \u05D4\u05E6\u05DC\u05D7\u05E0\u05D5 \u05DC\u05D4\u05D2\u05D9\u05E2 \u05DC\u05E9\u05E8\u05EA.",
      "Empty_output": "\u05D4\u05E7\u05D5\u05D3 \u05D4\u05D6\u05D4 \u05E2\u05D5\u05D1\u05D3 \u05D0\u05D1\u05DC \u05DC\u05D0 \u05DE\u05D3\u05E4\u05D9\u05E1 \u05E9\u05D5\u05DD \u05D3\u05D1\u05E8. \u05D4\u05D5\u05E1\u05D9\u05E4\u05D5 \u05E4\u05E7\u05D5\u05D3\u05EA \u05D4\u05D3\u05E4\u05E1\u05D4 \u05DC\u05E7\u05D5\u05D3 \u05D0\u05D5 \u05D4\u05E9\u05EA\u05DE\u05E9\u05D5 \u05D1\u05E6\u05D1 \u05D1\u05E9\u05D1\u05D9\u05DC \u05DC\u05E7\u05D1\u05DC \u05E4\u05DC\u05D8.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "\u05DE\u05E9\u05D4\u05D5 \u05D4\u05E9\u05EA\u05D1\u05E9 \u05D1\u05DE\u05D4\u05DC\u05DA \u05D4\u05E8\u05E6\u05EA \u05D4\u05EA\u05DB\u05E0\u05D9\u05EA.",
      "Other_error": "\u05D0\u05D5\u05E4\u05E1! \u05D0\u05D5\u05DC\u05D9 \u05E2\u05E9\u05D9\u05E0\u05D5 \u05D8\u05E2\u05D5\u05EA \u05E7\u05D8\u05E0\u05D4.",
      "Program_repair": "\u05D4\u05E7\u05D5\u05D3 \u05D4\u05D6\u05D4 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05D5\u05EA \u05E0\u05DB\u05D5\u05DF, \u05D4\u05D0\u05DD \u05EA\u05D5\u05DB\u05DC\u05D5 \u05DC\u05EA\u05E7\u05DF \u05D0\u05D5\u05EA\u05D5?",
      "Program_too_long": "\u05DC\u05EA\u05D5\u05DB\u05E0\u05D9\u05EA \u05E9\u05DC\u05DA \u05DC\u05D5\u05E7\u05D7 \u05D9\u05D5\u05EA\u05E8 \u05DE\u05D3\u05D9 \u05D6\u05DE\u05DF \u05DC\u05E8\u05D5\u05E5.",
      "ServerError": "\u05DB\u05EA\u05D1\u05EA \u05EA\u05D5\u05DB\u05E0\u05D9\u05EA \u05E9\u05DC\u05D0 \u05E6\u05D9\u05E4\u05D9\u05E0\u05D5 \u05DC\u05D4. \u05D0\u05DD \u05D0\u05EA.\u05D4 \u05E8\u05D5\u05E6\u05D4 \u05E2\u05D6\u05E8\u05D4, \u05E9\u05DC\u05D7.\u05D9 \u05DC\u05E0\u05D5 \u05DE\u05D9\u05D9\u05DC \u05E2\u05DD \u05DE\u05E1\u05E4\u05E8 \u05D4\u05E8\u05DE\u05D4 \u05D5\u05D4\u05EA\u05D5\u05DB\u05E0\u05D9\u05EA \u05E9\u05DC\u05DA \u05DC- hello@hedy.org. \u05D1\u05D9\u05E0\u05EA\u05D9\u05D9\u05DD, \u05E0\u05E1\u05D4.\u05D9 \u05DE\u05E9\u05D4\u05D5 \u05E7\u05E6\u05EA \u05E9\u05D5\u05E0\u05D4 \u05D5\u05D4\u05E1\u05EA\u05DB\u05DC.\u05D9 \u05E2\u05DC \u05D4\u05D3\u05D5\u05D2\u05DE\u05D0\u05D5\u05EA. \u05EA\u05D5\u05D3\u05D4!",
      "Transpile_error": "\u05D0\u05D9\u05E0\u05E0\u05D5 \u05D9\u05DB\u05D5\u05DC\u05D9\u05DD.\u05D5\u05EA \u05DC\u05D4\u05E8\u05D9\u05E5 \u05D0\u05EA \u05D4\u05EA\u05D5\u05DB\u05E0\u05D9\u05EA \u05E9\u05DC\u05DA.",
      "Transpile_success": "\u05E2\u05D1\u05D5\u05D3\u05D4 \u05D8\u05D5\u05D1\u05D4!\n\u05DE\u05D3\u05D4\u05D9\u05DD!\n\u05DB\u05DC \u05D4\u05DB\u05D1\u05D5\u05D3!\n\u05DE\u05E6\u05D5\u05D9\u05DF!\n\u05D4\u05D9\u05D9\u05EA \u05DE\u05E2\u05D5\u05DC\u05D4!",
      "Transpile_warning": "\u05D0\u05D6\u05D4\u05E8\u05D4!",
      "Unsaved_Changes": "\u05D9\u05E9 \u05DC\u05DA \u05EA\u05DB\u05E0\u05D9\u05EA \u05E9\u05DC\u05D0 \u05E0\u05E9\u05DE\u05E8\u05D4. \u05D4\u05D0\u05DD \u05D1\u05E8\u05E6\u05D5\u05E0\u05DA \u05DC\u05E2\u05D6\u05D5\u05D1 \u05D1\u05DC\u05D9 \u05DC\u05E9\u05DE\u05D5\u05E8 \u05D0\u05D5\u05EA\u05D4?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "\u05E8\u05DE\u05D4",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "hi": {
      "CheckInternet": "\u0926\u0947\u0916\u0947\u0902 \u0915\u093F \u0906\u092A\u0915\u093E \u0907\u0902\u091F\u0930\u0928\u0947\u091F \u0915\u0928\u0947\u0915\u094D\u0936\u0928 \u0920\u0940\u0915 \u0938\u0947 \u0915\u093E\u092E \u0915\u0930 \u0930\u0939\u093E \u0939\u0948 \u092F\u093E \u0928\u0939\u0940\u0902.",
      "Connection_error": "\u0939\u092E \u0938\u0930\u094D\u0935\u0930 \u0924\u0915 \u0928\u0939\u0940\u0902 \u092A\u0939\u0941\u0902\u091A \u0938\u0915\u0947|",
      "Empty_output": "\u092F\u0939 \u0915\u094B\u0921 \u0915\u093E\u092E \u0915\u0930\u0924\u093E \u0939\u0948 \u0932\u0947\u0915\u093F\u0928 \u0915\u0941\u091B \u092D\u0940 \u092A\u094D\u0930\u093F\u0902\u091F \u0928\u0939\u0940\u0902 \u0915\u0930\u0924\u093E \u0939\u0948\u0964 \u0905\u092A\u0928\u0947 \u0915\u094B\u0921 \u092E\u0947\u0902 \u090F\u0915 \u092A\u094D\u0930\u093F\u0902\u091F \u0915\u092E\u093E\u0902\u0921 \u091C\u094B\u0921\u093C\u0947\u0902 \u092F\u093E \u0906\u0909\u091F\u092A\u0941\u091F \u092A\u094D\u0930\u093E\u092A\u094D\u0924 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u091F\u0930\u094D\u091F\u0932 \u0915\u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0947\u0902|",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "\u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E \u091A\u0932\u093E\u0924\u0947 \u0938\u092E\u092F \u0915\u0941\u091B \u0917\u0932\u0924 \u0939\u094B \u0917\u092F\u093E|",
      "Other_error": "\u0909\u092B\u093C! \u0936\u093E\u092F\u0926 \u0939\u092E\u0928\u0947 \u0925\u094B\u0921\u093C\u0940 \u0938\u0940 \u0917\u0932\u0924\u0940 \u0915\u0930 \u0926\u0940\u0964",
      "Program_repair": "\u092F\u0939 \u0938\u0939\u0940 \u0915\u094B\u0921 \u0939\u094B \u0938\u0915\u0924\u093E \u0939\u0948, \u0915\u094D\u092F\u093E \u0906\u092A \u0907\u0938\u0947 \u0920\u0940\u0915 \u0915\u0930 \u0938\u0915\u0924\u0947 \u0939\u0948\u0902?",
      "Program_too_long": "\u0906\u092A\u0915\u093E \u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E \u091A\u0932\u0928\u0947 \u092E\u0947\u0902 \u092C\u0939\u0941\u0924 \u0905\u0927\u093F\u0915 \u0938\u092E\u092F \u0932\u0947\u0924\u093E \u0939\u0948\u0964",
      "ServerError": "\u0906\u092A\u0928\u0947 \u090F\u0915 \u0910\u0938\u093E \u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E \u0932\u093F\u0916\u093E \u091C\u093F\u0938\u0915\u0940 \u0939\u092E \u0905\u092A\u0947\u0915\u094D\u0937\u093E \u0928\u0939\u0940\u0902 \u0915\u0930 \u0930\u0939\u0947 \u0925\u0947\u0964 \u092F\u0926\u093F \u0906\u092A \u092E\u0926\u0926 \u0915\u0930\u0928\u093E \u091A\u093E\u0939\u0924\u0947 \u0939\u0948\u0902, \u0924\u094B \u0939\u092E\u0947\u0902 hello@hedy.org \u092A\u0930 \u0938\u094D\u0924\u0930 \u0914\u0930 \u0905\u092A\u0928\u0947 \u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E \u0915\u0947 \u0938\u093E\u0925 \u090F\u0915 \u0908\u092E\u0947\u0932 \u092D\u0947\u091C\u0947\u0902\u0964 \u0907\u0938 \u092C\u0940\u091A, \u0915\u0941\u091B \u0905\u0932\u0917 \u0915\u0930\u0928\u0947 \u0915\u0940 \u0915\u094B\u0936\u093F\u0936 \u0915\u0930\u0947\u0902 \u0914\u0930 \u0909\u0926\u093E\u0939\u0930\u0923\u094B\u0902 \u092A\u0930 \u090F\u0915 \u0914\u0930 \u0928\u091C\u093C\u0930 \u0921\u093E\u0932\u0947\u0902\u0964 \u0927\u0928\u094D\u092F\u0935\u093E\u0926!",
      "Transpile_error": "\u0939\u092E \u0906\u092A\u0915\u093E \u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E \u0928\u0939\u0940\u0902 \u091A\u0932\u093E \u0938\u0915\u0924\u0947\u0964",
      "Transpile_success": "\u0905\u091A\u094D\u091B\u093E \u0915\u093E\u0930\u094D\u092F!\n\u0905\u0926\u094D\u092D\u0941\u0924!\n\u092C\u0939\u0941\u0924 \u092C\u0922\u093C\u093F\u092F\u093E!\n\u0909\u0924\u094D\u0915\u0943\u0937\u094D\u091F!\n\u0906\u092A\u0928\u0947 \u092C\u0939\u0941\u0924 \u0905\u091A\u094D\u091B\u093E \u0915\u093F\u092F\u093E!",
      "Transpile_warning": "\u091A\u0947\u0924\u093E\u0935\u0928\u0940!",
      "Unsaved_Changes": "\u0906\u092A\u0915\u0947 \u092A\u093E\u0938 \u090F\u0915 \u0938\u0939\u0947\u091C\u093E \u0928\u0939\u0940\u0902 \u0917\u092F\u093E \u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E \u0939\u0948\u0964 \u0915\u094D\u092F\u093E \u0906\u092A \u0907\u0938\u0947 \u0938\u0939\u0947\u091C\u0947 \u092C\u093F\u0928\u093E \u091B\u094B\u0921\u093C\u0928\u093E \u091A\u093E\u0939\u0924\u0947 \u0939\u0948\u0902?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "\u0936\u0947\u092F\u0930 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u0932\u093F\u0902\u0915 \u0915\u0949\u092A\u0940 \u0915\u0930\u0947\u0902",
      "customization_deleted": "\u0905\u0928\u0941\u0915\u0942\u0932\u0928 \u0938\u092B\u0932\u0924\u093E\u092A\u0942\u0930\u094D\u0935\u0915 \u0939\u091F\u093E \u0926\u093F\u090F \u0917\u090F\u0964",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "\u0938\u094D\u0924\u0930",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "\u0939\u0947\u0921\u0940 \u092E\u0947\u0902 \u0906\u092A\u0915\u093E \u0938\u094D\u0935\u093E\u0917\u0924 \u0939\u0948! \u0905\u092C \u0906\u092A \u090F\u0915 \u0936\u093F\u0915\u094D\u0937\u0915 \u0916\u093E\u0924\u0947 \u0915\u0947 \u0917\u0930\u094D\u0935\u093F\u0924 \u0938\u094D\u0935\u093E\u092E\u0940 \u0939\u0948\u0902 \u091C\u094B \u0906\u092A\u0915\u094B \u0915\u0915\u094D\u0937\u093E\u090F\u0902 \u092C\u0928\u093E\u0928\u0947 \u0914\u0930 \u091B\u093E\u0924\u094D\u0930\u094B\u0902 \u0915\u094B \u0906\u092E\u0902\u0924\u094D\u0930\u093F\u0924 \u0915\u0930\u0928\u0947 \u0915\u0940 \u0905\u0928\u0941\u092E\u0924\u093F \u0926\u0947\u0924\u093E \u0939\u0948\u0964",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "hu": {
      "CheckInternet": "Ellen\u0151rizd, hogy az internetkapcsolat megfelel\u0151en m\u0171k\xF6dik-e.",
      "Connection_error": "Nem tudjuk el\xE9rni a szervert.",
      "Empty_output": "M\u0171k\xF6dik a program, de nem \xEDr ki semmit. Helyezz el egy ki\xEDr\xE1st a k\xF3dban, vagy haszn\xE1ld a tekn\u0151st, hogy kimenetet kapj!",
      "Errors_found": "Hib\xE1t k\xF6vett\xE9l el! Ne agg\xF3djon, m\xE9g mindig futtatjuk a programot",
      "Execute_error": "Hiba t\xF6rt\xE9nt a program futtat\xE1sa k\xF6zben.",
      "Other_error": "Hopp\xE1! Tal\xE1n elk\xF6vett\xFCnk egy kis hib\xE1t.",
      "Program_repair": "Ez lehet a helyes k\xF3d, meg tudod jav\xEDtani?",
      "Program_too_long": "T\xFAl hossz\xFA ideig tart programod futtat\xE1sa.",
      "ServerError": "Olyan programot \xEDrt\xE1l, amire nem sz\xE1m\xEDtottunk. Ha seg\xEDteni szeretn\xE9l, k\xFCldj nek\xFCnk egy emailt a szinttel \xE9s a programmal a hello@hedy.org c\xEDmre! Id\u0151k\xF6zben pr\xF3b\xE1ld ki egy kicsit m\xE1sk\xE9pp, \xE9s n\xE9zd meg a p\xE9ld\xE1kat! K\xF6sz\xF6nj\xFCk!",
      "Transpile_error": "Nem tudjuk futtatni a k\xF3dodat.",
      "Transpile_success": "Sz\xE9p munka!\nLeny\u0171g\xF6z\u0151!\n\xDCgyes!\nKit\u0171n\u0151!\nRemek\xFCl csin\xE1ltad!",
      "Transpile_warning": "Vigy\xE1zat!",
      "Unsaved_Changes": "Nem mentett programod van. El akarsz menni ment\xE9s n\xE9lk\xFCl?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Link m\xE1sol\xE1sa a megoszt\xE1shoz",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Szint",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u{1F5FB}, \u{1F4DC}, \u2702\uFE0F",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "Biztosan elhagyod ezt az oldalt? Mentetlen v\xE1ltoztat\xE1said vannak, amik \xEDgy elveszhetnek."
    },
    "id": {
      "CheckInternet": "Cobalah cek apakah internet kamu berjalan dengan baik.",
      "Connection_error": "Kami tidak bisa terhubung dengan server.",
      "Empty_output": "Kode ini berfungsi tetapi tidak mencetak apa pun. Tambahkan print command ke dalam kode Anda atau gunakan turtle untuk mendapatkan hasil keluaran.",
      "Errors_found": "Kamu membuat kesalahan! Tidak perlu khawatir, program tetap berjalan",
      "Execute_error": "Sesuatu berjalan tidak seharusnya ketika program sedang dijalankan.",
      "Other_error": "Ups! Mungkin kamu membuat kesalahan kecil.",
      "Program_repair": "Apakah ini bisa menjadi kode yang benar, bisakah kamu memperbaikinya?",
      "Program_too_long": "Program Anda memakan waktu terlalu lama untuk berjalan.",
      "ServerError": "Kamu menuliskan sebuah program yang tidak kami duga. Jika kamu butuh bantuan, kirimkan email dengan informasi level dan program kamu ke hello@hedy.org. Sembari menunggu respon, cobalah cara lain atau lihat kembali contoh-contoh yang disediakan. Terima kasih!",
      "Transpile_error": "Kami tidak bisa menjalankan kode kamu.",
      "Transpile_success": "Kerja bagus!\nKeren!\nBagus sekali!\nBagus sekali!\nKamu sudah bagus!",
      "Transpile_warning": "Peringatan!",
      "Unsaved_Changes": "Kamu memiliki program yang belum disimpan. Apakah kamu mau keluar tanpa menyimpannya?",
      "adventures_restored": "Petualangan default telah dipulihkan.",
      "copy_link_to_share": "Salin tautan untuk berbagi",
      "customization_deleted": "Penyesuaian berhasil dihapus.",
      "dice": "\u{1F3B2}",
      "directly_available": "Terbuka langsung",
      "disabled": "Dinonaktifkan",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Selamat datang di Hedy! Anda sekarang bangga menjadi pemilik akun guru yang memungkinkan Anda membuat kelas dan mengundang siswa.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "Ada perubahan yang belum disimpan, yakin ingin meninggalkan halaman ini?"
    },
    "it": {
      "CheckInternet": "Dai un'occhiata se la tua connessione Internet funziona correttamente.",
      "Connection_error": "Non siamo riuscito a contattare il server.",
      "Empty_output": "Questo codice funziona ma non stampa nulla. Aggiungi un comando print al tuo codice o usa la tartaruga per ottenere l'output.",
      "Errors_found": "Hai fatto un errore! Non preoccuparti, abbiamo comunque eseguito il programma",
      "Execute_error": "Qualcosa \xE8 andato storto nell'esecuzione del tuo codice.",
      "Other_error": "Ops! Forse abbiamo fatto un errore.",
      "Program_repair": "Questo potrebbe essere il codice corretto, puoi risolverlo?",
      "Program_too_long": "Il tuo programma impiega troppo tempo per essere eseguito.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "Non possiamo eseguire il tuo programma.",
      "Transpile_success": "Ottimo lavoro!\nFantastico!\nBen fatto!\nEccellente!\nSei stato bravissimo!",
      "Transpile_warning": "Attenzione!",
      "Unsaved_Changes": "Hai un programma non salvato. Vuoi uscire senza salvare?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "Dado",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "fortuna",
      "haunted": "infestato",
      "level_title": "Livello",
      "restaurant": "Ristorante",
      "rock": "Roccia",
      "songs": "Suono",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "Tartaruga",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "ja": {
      "CheckInternet": "\u30A4\u30F3\u30BF\u30FC\u30CD\u30C3\u30C8\u306E\u63A5\u7D9A\u3092\u8ABF\u3079\u3066\u304F\u3060\u3055\u3044\u3002",
      "Connection_error": "\u30B5\u30FC\u30D0\u306B\u63A5\u7D9A\u3067\u304D\u307E\u305B\u3093\u3002",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Something went wrong while running the program.",
      "Other_error": "\u3042\uFF01\u591A\u5206\u3001\u79C1\u305F\u3061\u306F\u9593\u9055\u3044\u3057\u307E\u3057\u305F\u3002\u3054\u3081\u3093\u306A\u3055\u3044\u3002",
      "Program_repair": "\u3053\u306E\u30B3\u30FC\u30C9\u306F\u6B63\u89E3\u304C\u3067\u304D\u307E\u3059\u3002\u76F4\u305B\u307E\u3059\u304B\uFF1F",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "\u30D7\u30ED\u30B0\u30E9\u30E0\u3092\u5B9F\u884C\u304C\u3067\u304D\u307E\u305B\u3093\u3002",
      "Transpile_success": "\u3088\u304F\u3067\u304D\u305F\uFF01\n\u3059\u3054\u3044\uFF01\n\u3088\u304F\u3084\u3063\u305F\uFF01\n\u3048\u3089\u3044\uFF01\n\u9811\u5F35\u3063\u305F\u306D\uFF01",
      "Transpile_warning": "\u8B66\u544A\uFF01",
      "Unsaved_Changes": "\u975E\u4FDD\u5B58\u30D7\u30ED\u30B0\u30E9\u30E0\u304C\u3042\u308A\u307E\u3059\u3002\u305D\u308C\u3067\u3082\u3001\u7D42\u4E86\u3057\u307E\u3059\u304B\uFF1F",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "kmr": {
      "CheckInternet": "Check whether your Internet connection is working.",
      "Connection_error": "We couldn't reach the server.",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Something went wrong while running the program.",
      "Other_error": "Oops! Maybe we made a little mistake.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "We can't run your program.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "Warning!",
      "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "ko": {
      "CheckInternet": "\uC778\uD130\uB137 \uC5F0\uACB0\uC774 \uC81C\uB300\uB85C \uC791\uB3D9\uD558\uB294\uC9C0 \uD655\uC778\uD574 \uBCF4\uC138\uC694.",
      "Connection_error": "\uC11C\uBC84\uC5D0 \uC5F0\uACB0\uC774 \uC548 \uB410\uC5B4\uC694.",
      "Empty_output": "\uC774 \uCF54\uB4DC\uB294 \uC791\uB3D9\uD558\uC9C0\uB9CC \uC544\uBB34\uAC83\uB3C4 \uC778\uC1C4\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4. \uCF54\uB4DC\uC5D0 \uC778\uC1C4 \uBA85\uB839\uC744 \uCD94\uAC00\uD558\uAC70\uB098 \uAC70\uBD81\uC774\uB97C \uC0AC\uC6A9\uD558\uC5EC \uCD9C\uB825\uC744 \uC5BB\uC73C\uC2ED\uC2DC\uC624.",
      "Errors_found": "\uD2C0\uB9B0\uAC83 \uAC19\uC544\uC694! \uAC71\uC815 \uB9C8\uC138\uC694, hedy\uB294 \uC2E4\uC218\uB97C \uCC3E\uC73C\uB824 \uD558\uACE0 \uC788\uC5B4\uC694",
      "Execute_error": "\uD504\uB85C\uADF8\uB7A8\uC744 \uC2E4\uD589\uD558\uB294 \uB3D9\uC548 \uBB38\uC81C\uAC00 \uC0DD\uACBC\uC5B4\uC694.",
      "Other_error": "\uC774\uB7F0! \uC800\uD76C\uAC00 \uC791\uC740 \uC2E4\uC218\uB97C \uD588\uB098\uBD10\uC694.",
      "Program_repair": "\uC774\uAC8C \uB9DE\uB294 \uCF54\uB4DC\uC77C \uC218\uB3C4 \uC788\uB294\uB370 \uC218\uC815 \uD574\uC8FC\uC2E4 \uC218 \uC788\uB098\uC694?",
      "Program_too_long": "\uD504\uB85C\uADF8\uB7A8\uC744 \uC2E4\uD589\uD558\uB294 \uB370 \uC2DC\uAC04\uC774 \uB108\uBB34 \uC624\uB798 \uAC78\uB9AC\uB124\uC694.",
      "ServerError": "\uB2F9\uC2E0\uC740 \uC800\uD76C\uAC00 \uC608\uC0C1\uD558\uC9C0 \uBABB\uD588\uB358 \uD504\uB85C\uADF8\uB7A8\uC744 \uC791\uC131\uD588\uC2B5\uB2C8\uB2E4. \uB9CC\uC57D \uB3C4\uC6C0\uC744 \uC8FC\uACE0 \uC2F6\uB2E4\uBA74, \uC6B0\uB9AC\uC5D0\uAC8C \uB808\uBCA8\uACFC hello@hedy.org \uC5D0 \uC788\uB294 \uB2F9\uC2E0\uC758 \uD504\uB85C\uADF8\uB7A8\uACFC \uD568\uAED8 \uC774\uBA54\uC77C\uC744 \uBCF4\uB0B4\uC8FC\uC138\uC694. \uADF8 \uB3D9\uC548, \uC870\uAE08 \uB2E4\uB978 \uAC83\uC744 \uC2DC\uB3C4\uD574\uBCF4\uACE0 \uC0AC\uB840\uB97C \uB2E4\uC2DC \uC0B4\uD3B4\uBCF4\uC138\uC694. \uAC10\uC0AC\uD569\uB2C8\uB2E4!",
      "Transpile_error": "\uD504\uB85C\uADF8\uB7A8\uC744 \uC2E4\uD589\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.",
      "Transpile_success": "\uC218\uACE0\uD558\uC168\uC5B4\uC694!\n\uCD5C\uACE0\uC5D0\uC694!\n\uC815\uB9D0 \uC798\uD558\uC168\uC5B4\uC694!\n\uD6CC\uB96D\uD574\uC694!\n\uB300\uB2E8\uD574\uC694!",
      "Transpile_warning": "\uACBD\uACE0!",
      "Unsaved_Changes": "\uC800\uC7A5\uD558\uC9C0 \uC54A\uC740 \uD504\uB85C\uADF8\uB7A8\uC774 \uC788\uC2B5\uB2C8\uB2E4. \uC800\uC7A5\uD558\uC9C0 \uC54A\uACE0 \uB098\uAC00\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
      "adventures_restored": "\uAE30\uBCF8 \uBAA8\uD5D8\uC774 \uBCF5\uAD6C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.",
      "copy_link_to_share": "\uACF5\uC720\uD560 \uB9C1\uD06C \uBCF5\uC0AC",
      "customization_deleted": "\uC0AC\uC6A9\uC790 \uC9C0\uC815\uC744 \uC131\uACF5\uC801\uC73C\uB85C \uC0AD\uC81C\uD588\uC2B5\uB2C8\uB2E4.",
      "dice": "\u{1F3B2}",
      "directly_available": "\uC9C1\uC811 \uC5F4\uB9BC",
      "disabled": "\uBE44\uD65C\uC131\uD654\uB428",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "\uB808\uBCA8",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "mi": {
      "CheckInternet": "Check whether your Internet connection is working.",
      "Connection_error": "We couldn't reach the server.",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, we still ran the program",
      "Execute_error": "Something went wrong while running the program.",
      "Other_error": "Oops! Maybe we made a little mistake.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "We can't run your program.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "Warning!",
      "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
      "adventures_restored": "The default adventures have been restored.",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "nl": {
      "CheckInternet": "Controleer even of je internetverbinding het nog doet.",
      "Connection_error": "We konden niet goed met de server praten.",
      "Empty_output": "Deze code werkt wel, maar print niks. Voeg een print commando toe aan je code of gebruik de schildpad om output te krijgen.",
      "Errors_found": "Je hebt een foutje gemaakt! Maak je geen zorgen, Hedy probeert de fouten te vinden",
      "Execute_error": "Er ging iets fout bij het uitvoeren van het programma.",
      "Other_error": "Oeps! Misschien hebben wij een klein programmeerfoutje gemaakt.",
      "Program_repair": "Dit kan de correcte code zijn, kan je jouw code repareren?",
      "Program_too_long": "Jouw programma duurt te lang bij het uitvoeren.",
      "ServerError": "Je hebt een programma geschreven dat we niet verwacht hadden. Als je wilt helpen, stuur ons dan een mailtje met het level en je programma op hello@hedy.org. Probeer om verder te gaan je programma een beetje aan te passen en kijk nog eens goed naar de voorbeelden. Bedankt!",
      "Transpile_error": "We konden je code niet goed lezen.",
      "Transpile_success": "Goed gedaan!\nGa zo door!\nTopper!\nSuper!\nBravo!",
      "Transpile_warning": "Let op!",
      "Unsaved_Changes": "Jouw programma is niet opgeslagen. Wil je weggaan zonder het op te slaan?",
      "adventures_restored": "De standaardavonturen zijn terug gezet.",
      "copy_link_to_share": "Kopieer link voor delen",
      "customization_deleted": "Personalisatie succesvol verwijderd.",
      "dice": "\u{1F3B2}",
      "directly_available": "Gelijk open",
      "disabled": "Gedeactiveerd",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welkom bij Hedy! Jouw account is omgezet naar een leerkrachtenaccount. Je kan nu klassen maken en er leerlingen in uitnodigen.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "Er zijn wijzigingen nog niet opgeslagen, weet je zeker dat je terug wilt gaan?"
    },
    "no_NB": {
      "CheckInternet": "Sjekk internetttilkoblingen din, fungerer den.",
      "Connection_error": "Vi fikk ikke kontakt med serveren.",
      "Empty_output": "Denne koden virker men den skriver ikke ut noe. Legg til en print kommando til koden din eller bruk skipadden til \xE5 f\xE5 noe output.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Noe gikk feil mens vi kj\xF8rte programmet.",
      "Other_error": "Oops! Kanskje vi gjorde en liten feil.",
      "Program_repair": "Dette kan v\xE6re det korrekte programmet, kan du fikse det?",
      "Program_too_long": "Programmet ditt tok for lang tid \xE5 kj\xF8re.",
      "ServerError": "Du skrev et program vi ikke forventet oss. Om du trenger hjelp, send en epost med niv\xE5et du er p\xE5 og programmet til hello@hedy.org. I mellomtiden, pr\xF8v noe annet og ta en titt p\xE5 eksemplene. Takk!",
      "Transpile_error": "Vi kan ikke kj\xF8re programmet ditt.",
      "Transpile_success": "Godt jobbet!\nFantastisk!\nVeldig bra!\nSupert!\nDette fikk du til!",
      "Transpile_warning": "Advarsel!",
      "Unsaved_Changes": "Du har ulagrede endringer i programmet. Vil du g\xE5 uten \xE5 lagre de?",
      "adventures_restored": "The default adventures have been restored.",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "pa_PK": {
      "CheckInternet": "Check whether your Internet connection is working.",
      "Connection_error": "We couldn't reach the server.",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Something went wrong while running the program.",
      "Other_error": "Oops! Maybe we made a little mistake.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "We can't run your program.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "Warning!",
      "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "pap": {
      "CheckInternet": "Check whether your Internet connection is working.",
      "Connection_error": "We couldn't reach the server.",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, we still ran the program",
      "Execute_error": "Something went wrong while running the program.",
      "Other_error": "Oops! Maybe we made a little mistake.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "We can't run your program.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "Warning!",
      "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
      "adventures_restored": "The default adventures have been restored.",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "pl": {
      "CheckInternet": "Upewnij si\u0119, \u017Ce masz po\u0142\u0105czenie z Internetem.",
      "Connection_error": "B\u0142\u0105d po\u0142\u0105czenia z serwerem.",
      "Empty_output": "Ten kod dzia\u0142a, ale niczego nie wypisuje. Dodaj komend\u0119 'napisz' lub u\u017Cyj \u017C\xF3\u0142wia, by otrzyma\u0107 dane wyj\u015Bciowe.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Co\u015B posz\u0142o nie tak w trakcie wykonywania programu.",
      "Other_error": "Ups! Mo\u017Ce pope\u0142nili\u015Bmy ma\u0142y b\u0142\u0105d.",
      "Program_repair": "To mo\u017Ce by\u0107 poprawny kod, czy mo\u017Cesz go naprawi\u0107?",
      "Program_too_long": "Tw\xF3j program dzia\u0142a zbyt d\u0142ugo.",
      "ServerError": "Napisa\u0142e\u015B program, jakiego si\u0119 nie spodziewali\u015Bmy. Je\u017Celi chcesz nam pom\xF3c, wy\u015Blij wiadomo\u015B\u0107 na adres e-mail hello@hedy.org i wska\u017C poziom, na kt\xF3rym napisa\u0142e\u015B ten program oraz za\u0142\u0105cz jego kod. W mi\u0119dzyczasie spr\xF3buj czego\u015B innego i ponownie sp\xF3jrz na przyk\u0142ady. Dzi\u0119ki!",
      "Transpile_error": "Program nie mo\u017Ce zosta\u0107 uruchomiony.",
      "Transpile_success": "Dobra robota!\nWspaniale!\n\u015Awietnie!\nDoskonale!\nDobrze Ci posz\u0142o!",
      "Transpile_warning": "Ostrze\u017Cenie!",
      "Unsaved_Changes": "Tw\xF3j program nie zosta\u0142 zapisany. Chcesz wyj\u015B\u0107 mimo to?",
      "adventures_restored": "Domy\u015Blne przygody zosta\u0142y przywr\xF3cone.",
      "copy_link_to_share": "Skopiuj udost\u0119pniaj\u0105cy link",
      "customization_deleted": "Personalizacje zostaly usuni\u0119te pomy\u015Blnie.",
      "dice": "\u{1F3B2}",
      "directly_available": "Zawsze dost\u0119pne",
      "disabled": "Wy\u0142\u0105czono",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Poziom",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Witaj w Hedy! Jeste\u015B teraz dumnym posiadaczem konta nauczyciela, kt\xF3re pozwala Ci na tworzenie klas i zapraszanie uczni\xF3w.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "Strona zawiera niezapisane zmiany. Czy jeste\u015B pewien, \u017Ce chcesz wyj\u015B\u0107 bez zapisania zmian?"
    },
    "pt_BR": {
      "CheckInternet": "Verifique se sua conex\xE3o com a Internet est\xE1 funcionando.",
      "Connection_error": "N\xF3s n\xE3o conseguimos conectar ao servidor.",
      "Empty_output": "Este c\xF3digo funciona mas n\xE3o imprime nada. Adicione um comando de impress\xE3o ou use a tartaruga para ter alguma sa\xEDda.",
      "Errors_found": "Voc\xEA cometeu um erro! N\xE3o se preocupe, ainda executamos o programa",
      "Execute_error": "Alguma coisa deu errado enquanto o programa era executado.",
      "Other_error": "Opa! Talvez n\xF3s fizemos alguma coisa errada.",
      "Program_repair": "Este poderia ser o c\xF3digo correto, voc\xEA poderia corrigir ele?",
      "Program_too_long": "O seu programa leva muito tempo para executar.",
      "ServerError": "Voc\xEA escreveu um programa que n\xE3o est\xE1vamos esperando. Se voc\xEA quiser ajudar, envie-nos um email com o n\xEDvel e seu programa para hello@hedy.org. Enquanto isso, tente algo um pouco diferente e d\xEA uma outra olhada nos exemplos. Obrigado!",
      "Transpile_error": "N\xE3o conseguimos executar o seu programa.",
      "Transpile_success": "Bom trabalho!\nImpressionante!\nMuito bem!\nExcelente!\n\xD3timo!",
      "Transpile_warning": "Aviso!",
      "Unsaved_Changes": "Voc\xEA tem um programa n\xE3o salvo. Voc\xEA deseja sair sem salv\xE1-lo?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copiar link para compartilhar",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "N\xEDvel",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "pt_PT": {
      "CheckInternet": "Verifica se a tua liga\xE7\xE3o de Internet est\xE1 a funcionar correctamente.",
      "Connection_error": "N\xE3o conseguimos contactar o servidor.",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Alguma coisa correu mal enquanto execut\xE1vamos o programa.",
      "Other_error": "Oops! Talvez cometemos um pequeno erro.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "Escreveste um programa que n\xE3o est\xE1vamos \xE0 espera. Se queres ajudar, envia-nos um email com o n\xEDvel e o teu programa para hello@hedy.org. Entretanto, experimenta alguma coisa um pouco diferente e volta a olhar para os exemplos. Obrigado!",
      "Transpile_error": "N\xE3o conseguimos executar o teu programa.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "Aviso!",
      "Unsaved_Changes": "Tens um programa por guardar. Queres sair sem o guardar?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copiar liga\xE7\xE3o de partilha",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "N\xEDvel",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "tartaruga\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "ro": {
      "CheckInternet": "Verific\u0103 dac\u0103 ai semnal la internet.",
      "Connection_error": "Nu am putut contacta serverul.",
      "Empty_output": "Acest program func\u021Bioneaz\u0103 dar nu printeaz\u0103 nimic. Adaug\u0103 o comand\u0103 de printare sau folose\u0219te \u021Bestoasa s\u0103 ob\u021Bii un rezultat.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Ceva nu a func\u021Bionat corect in timpul rul\u0103rii programului.",
      "Other_error": "Opa! Este posibil s\u0103 fi f\u0103cut vreo gre\u0219eal\u0103.",
      "Program_repair": "Probabil a\u0219a arat\u0103 programul corect, po\u021Bi corecta?",
      "Program_too_long": "Rularea programului t\u0103u dureaz\u0103 prea mult.",
      "ServerError": "Ai scris un program nea\u0219teptat. Dac\u0103 ai nevoie de ajutor trimite-ne un email la: hello@hedy.org \u0219i specific\u0103 nivelul. Intre timp incearc\u0103 ceva diferit \u0219i incearc\u0103 din nou exemplele. Mul\u021Bumim!",
      "Transpile_error": "Nu putem rula program t\u0103u.",
      "Transpile_success": "Excelent!\nExtraordinar!\nFoarte bine!\nExcelent!\nFoarte bine!",
      "Transpile_warning": "Aten\u021Bie!",
      "Unsaved_Changes": "Ai un program care nu este salvat. Dore\u0219ti s\u0103 ie\u0219i f\u0103r\u0103 salvare?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "ru": {
      "CheckInternet": "\u041F\u0440\u043E\u0432\u0435\u0440\u044C \u0441\u0432\u043E\u0451 \u0438\u043D\u0442\u0435\u0440\u043D\u0435\u0442 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435.",
      "Connection_error": "\u041D\u0435 \u043C\u043E\u0433\u0443 \u043D\u0430\u0439\u0442\u0438 \u0441\u0435\u0440\u0432\u0435\u0440.",
      "Empty_output": "\u042D\u0442\u043E\u0442 \u043A\u043E\u0434 \u0440\u0430\u0431\u043E\u0442\u0430\u0435\u0442, \u043D\u043E \u043D\u0435 \u0432\u044B\u0432\u043E\u0434\u0438\u0442 \u043D\u0438\u0447\u0435\u0433\u043E. \u0414\u043E\u0431\u0430\u0432\u044C \u043A\u043E\u043C\u0430\u043D\u0434\u0443 \u043F\u0435\u0447\u0430\u0442\u044C \u0432 \u0442\u0432\u043E\u0439 \u043A\u043E\u0434 \u0438\u043B\u0438 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439 \u0447\u0435\u0440\u0435\u043F\u0430\u0448\u043A\u0435 \u0447\u0442\u043E\u0431\u044B \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0432\u044B\u0432\u043E\u0434.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "\u0427\u0442\u043E-\u0442\u043E \u043F\u043E\u0448\u043B\u043E \u043D\u0435 \u0442\u0430\u043A \u043F\u0440\u0438 \u0437\u0430\u043F\u0443\u0441\u043A\u0435 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u044B.",
      "Other_error": "\u0423\u043F\u0441, \u043A\u0430\u0436\u0435\u0442\u0441\u044F \u0432\u044B\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043E\u0447\u043A\u0430.",
      "Program_repair": "\u042D\u0442\u043E \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u044B\u0439 \u043A\u043E\u0434, \u043C\u043E\u0436\u0435\u0442\u0435 \u043B\u0438 \u0432\u044B \u0435\u0433\u043E \u0438\u0441\u043F\u0440\u0430\u0432\u0438\u0442\u044C?",
      "Program_too_long": "\u0412\u0430\u0448\u0430 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0430 \u0432\u044B\u043F\u043E\u043B\u043D\u044F\u0435\u0442\u0441\u044F \u0441\u043B\u0438\u0448\u043A\u043E\u043C \u0434\u043E\u043B\u0433\u043E.",
      "ServerError": "\u0412\u044B \u043D\u0430\u043F\u0438\u0441\u0430\u043B\u0438 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0443, \u043A\u043E\u0442\u043E\u0440\u0443\u044E \u043C\u044B \u043D\u0435 \u043E\u0436\u0438\u0434\u0430\u043B\u0438. \u0415\u0441\u043B\u0438 \u0432\u044B \u0445\u043E\u0442\u0438\u0442\u0435 \u043F\u043E\u043C\u043E\u0447\u044C, \u043F\u0440\u0438\u0448\u043B\u0438\u0442\u0435 \u043D\u0430\u043C \u043F\u0438\u0441\u044C\u043C\u043E \u0441 \u0443\u043A\u0430\u0437\u0430\u043D\u0438\u0435\u043C \u0443\u0440\u043E\u0432\u043D\u044F \u0438 \u0432\u0430\u0448\u0435\u0439 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u044B \u043F\u043E \u0430\u0434\u0440\u0435\u0441\u0443 hello@hedy.org. \u0410 \u043F\u043E\u043A\u0430 \u043F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0441\u0434\u0435\u043B\u0430\u0442\u044C \u0447\u0442\u043E-\u0442\u043E \u0434\u0440\u0443\u0433\u043E\u0435 \u0438 \u043F\u043E\u0441\u043C\u043E\u0442\u0440\u0438\u0442\u0435 \u0435\u0449\u0435 \u0440\u0430\u0437 \u043D\u0430 \u043F\u0440\u0438\u043C\u0435\u0440\u044B. \u0421\u043F\u0430\u0441\u0438\u0431\u043E!",
      "Transpile_error": "\u041C\u044B \u043D\u0435 \u043C\u043E\u0436\u0435\u043C \u0437\u0430\u043F\u0443\u0441\u0442\u0438\u0442\u044C \u0442\u0432\u043E\u044E \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0443.",
      "Transpile_success": "\u041E\u0442\u043B\u0438\u0447\u043D\u0430\u044F \u0440\u0430\u0431\u043E\u0442\u0430!\n\u041F\u043E\u0442\u0440\u044F\u0441\u0430\u044E\u0449\u0435!\n\u041E\u0442\u043B\u0438\u0447\u043D\u043E \u043F\u043E\u043B\u0443\u0447\u0438\u043B\u043E\u0441\u044C!\n\u041F\u0440\u0435\u043A\u0440\u0430\u0441\u043D\u043E!\n\u0423 \u0442\u0435\u0431\u044F \u043E\u0442\u043B\u0438\u0447\u043D\u043E \u043F\u043E\u043B\u0443\u0447\u0430\u0435\u0442\u0441\u044F!",
      "Transpile_warning": "\u0412\u043D\u0438\u043C\u0430\u043D\u0438\u0435!",
      "Unsaved_Changes": "\u0423 \u0442\u0435\u0431\u044F \u043D\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0430 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0430. \u0425\u043E\u0447\u0435\u0448\u044C \u0432\u044B\u0439\u0442\u0438 \u0431\u0435\u0437 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "\u0421\u043A\u043E\u043F\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u0441\u044B\u043B\u043A\u0443, \u0447\u0442\u043E\u0431\u044B \u043F\u043E\u0434\u0435\u043B\u0438\u0442\u044C\u0441\u044F",
      "customization_deleted": "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0443\u0434\u0430\u043B\u0435\u043D\u044B.",
      "dice": "\u{1F3B2}",
      "directly_available": "\u041F\u0440\u044F\u043C\u043E\u0435 \u043E\u0442\u043A\u0440\u044B\u0442\u0438\u0435",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "\u0423\u0440\u043E\u0432\u0435\u043D\u044C",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "\u0414\u043E\u0431\u0440\u043E \u043F\u043E\u0436\u0430\u043B\u043E\u0432\u0430\u0442\u044C \u0432 Hedy! \u0422\u0435\u043F\u0435\u0440\u044C \u0432\u044B \u044F\u0432\u043B\u044F\u0435\u0442\u0435\u0441\u044C \u0433\u043E\u0440\u0434\u044B\u043C \u0432\u043B\u0430\u0434\u0435\u043B\u044C\u0446\u0435\u043C \u0443\u0447\u0435\u0442\u043D\u043E\u0439 \u0437\u0430\u043F\u0438\u0441\u0438 \u0443\u0447\u0438\u0442\u0435\u043B\u044F, \u043A\u043E\u0442\u043E\u0440\u0430\u044F \u043F\u043E\u0437\u0432\u043E\u043B\u044F\u0435\u0442 \u0432\u0430\u043C \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C \u043A\u043B\u0430\u0441\u0441\u044B \u0438 \u043F\u0440\u0438\u0433\u043B\u0430\u0448\u0430\u0442\u044C \u0443\u0447\u0435\u043D\u0438\u043A\u043E\u0432.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "\u0415\u0441\u0442\u044C \u043D\u0435\u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u043D\u044B\u0435 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F, \u0432\u044B \u0443\u0432\u0435\u0440\u0435\u043D\u044B, \u0447\u0442\u043E \u0445\u043E\u0442\u0438\u0442\u0435 \u043F\u043E\u043A\u0438\u043D\u0443\u0442\u044C \u044D\u0442\u0443 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0443?"
    },
    "sq": {
      "CheckInternet": "Shikoni n\xEBse lidhja juaj e internetit po funksionon si\xE7 duhet.",
      "Connection_error": "Nuk arrit\xEBm dot te serveri.",
      "Empty_output": "Ky kod funksionon, por nuk printon asgj\xEB. Shtoni komand\xEBn print n\xEB kodin tuaj ose p\xEBrdorni breshk\xEBn p\xEBr t\xEB marr\xEB rezultatin.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Di\xE7ka shkoi keq gjat\xEB ekzekutimit t\xEB programit.",
      "Other_error": "Oops! Ndoshta kemi b\xEBr\xEB nj\xEB gabim t\xEB vog\xEBl.",
      "Program_repair": "Ky mund t\xEB jet\xEB kodi i duhur, a mund ta rregulloni?",
      "Program_too_long": "Programi juaj merr shum\xEB koh\xEB p\xEBr t\xEB ekzekutuar.",
      "ServerError": "Ke shkruar nj\xEB program q\xEB nuk e prisnim. N\xEBse d\xEBshironi t\xEB ndihmoni, na d\xEBrgoni nj\xEB email me nivelin dhe programin tuaj n\xEB hello@hedy.org. Nd\xEBrkoh\xEB, provoni di\xE7ka pak m\xEB ndryshe dhe hidhini nj\xEB sy shembujve. Faleminderit!",
      "Transpile_error": "Ne nuk mund ta ekzekutojm\xEB programin tuaj.",
      "Transpile_success": "Pun\xEB e mir\xEB!\nE mahnitshme!\nTe lumte!\nE shk\xEBlqyeshme!\nJu dol\xEBt shum\xEB mir\xEB!",
      "Transpile_warning": "Paralajm\xEBrim!",
      "Unsaved_Changes": "Ju keni nj\xEB program t\xEB paruajtur. D\xEBshiron t\xEB largohesh pa e ruajtur?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "sr": {
      "CheckInternet": "Proveri da li ima\u0161 internet konekciju.",
      "Connection_error": "Ne mogu dostignuti server.",
      "Empty_output": "Ovaj kod radi, ali ne prikazuje ni\u0161ta. Dodaj komandu za prikazivanje u kodu ili koristi turtle da prika\u017Ee\u0161 rezultat.",
      "Errors_found": "Napravio si gre\u0161ku! Ne brini, i dalje smo uspeli da pokrenemo program",
      "Execute_error": "Ne\u0161to se pokvarilo dok je program radio.",
      "Other_error": "Ups! Mo\u017Eda smo napravili malu gre\u0161ku.",
      "Program_repair": "Mo\u017Eda je ovo ispravan kod, mo\u017Ee\u0161 li ga popraviti?",
      "Program_too_long": "Tvoj program zahteva mnogo vremena za pokretanje.",
      "ServerError": "Napisali ste program koji nismo o\u010Dekivali. Ako \u017Eelite da pomognete, po\u0161aljite nam mejl sa nivoom i va\u0161im programom na hello@hedy.org. U me\u0111uvremenu, poku\u0161ajte ne\u0161to malo druga\u010Dije i pogledajte jo\u0161 jednom primere. Hvala!",
      "Transpile_error": "Ne mo\u017Eemo da pokrenemo tvoj program.",
      "Transpile_success": "Dobar posao!\nNeverovatno!\nDobro ura\u0111eno!\nOdli\u010Dno!\nBio si odli\u010Dan!",
      "Transpile_warning": "Upozorenje!",
      "Unsaved_Changes": "Nisi sa\u010Duvao program. \u017Deli\u0161 li da iza\u0111e\u0161 bez \u010Duvanja?",
      "adventures_restored": "Podrazumevane avanture su vra\u0107ene.",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Nivo",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "sv": {
      "CheckInternet": "Kontrollera att din internetanslutning fungerar.",
      "Connection_error": "Vi kunde inte n\xE5 servern.",
      "Empty_output": "Den h\xE4r koden fungerar men skriver inget. L\xE4gg till ett utskriftskommando till din kod eller anv\xE4nd sk\xF6ldpaddan f\xF6r att f\xE5 n\xE5got resultat.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "N\xE5got gick fel n\xE4r programmet k\xF6rdes.",
      "Other_error": "Hoppsan! Vi gjorde nog ett litet misstag.",
      "Program_repair": "Detta kan vara r\xE4tt kod; kan du laga den?",
      "Program_too_long": "Ditt program tar f\xF6r l\xE5ng tid att k\xF6ra.",
      "ServerError": "Du skrev ett program som vi inte v\xE4ntade oss. Om du vill hj\xE4lpa oss, skicka ett mejl med niv\xE5n och ditt program till hello@hedy.org. Under tiden kan du testa att \xE4ndra lite och ta en ny titt p\xE5 exemplen. Tack!",
      "Transpile_error": "Vi kan inte k\xF6ra ditt program.",
      "Transpile_success": "Bra jobbat!\nFantastiskt!\nBra jobbat!\nUtm\xE4rkt!\nBra jobbat!",
      "Transpile_warning": "Varning!",
      "Unsaved_Changes": "Ditt program \xE4r inte sparat. Vill du l\xE4mna utan att spara det?",
      "adventures_restored": "Standard\xE4ventyren har \xE5terst\xE4llts.",
      "copy_link_to_share": "Kopiera l\xE4nken f\xF6r att dela den",
      "customization_deleted": "Anpassningarna har tagits bort.",
      "dice": "\u{1F3B2}",
      "directly_available": "\xD6ppna direkt",
      "disabled": "Inaktiverad",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Niv\xE5",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "V\xE4lkommen till Hedy! Du \xE4r nu den stolta \xE4garen av ett l\xE4rarkonto som ger dig m\xF6jlighet att skapa klasser och bjuda in elever.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "Det finns osparade \xE4ndringar; \xE4r du s\xE4ker p\xE5 att du vill l\xE4mna sidan?"
    },
    "sw": {
      "CheckInternet": "Check whether your Internet connection is working.",
      "Connection_error": "Hatukuweza kufikia seva.",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Matatizo fulani ilitokea wakati wa kuendesha programu.",
      "Other_error": "Oops! Labda tulifanya makosa kidogo.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "Hatuwezi kuendesha programu yako.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "Onyo!",
      "Unsaved_Changes": "Una programu ambao haujahifadhiwa. Je! Unataka kuondoka bila kuiokoa?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Kiwango",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "te": {
      "CheckInternet": "Check whether your Internet connection is working.",
      "Connection_error": "We couldn't reach the server.",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Something went wrong while running the program.",
      "Other_error": "Oops! Maybe we made a little mistake.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "We can't run your program.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "Warning!",
      "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "th": {
      "CheckInternet": "\u0E40\u0E2D\u0E4B \u0E2D\u0E34\u0E19\u0E40\u0E15\u0E2D\u0E23\u0E4C\u0E40\u0E19\u0E47\u0E15\u0E21\u0E35\u0E1B\u0E31\u0E0D\u0E2B\u0E32\u0E2B\u0E23\u0E37\u0E2D\u0E40\u0E1B\u0E25\u0E48\u0E32",
      "Connection_error": "\u0E40\u0E23\u0E32\u0E15\u0E34\u0E14\u0E15\u0E48\u0E2D\u0E01\u0E31\u0E1A\u0E40\u0E0B\u0E34\u0E1F\u0E40\u0E27\u0E2D\u0E23\u0E4C\u0E44\u0E21\u0E48\u0E44\u0E14\u0E49.",
      "Empty_output": "\u0E42\u0E04\u0E49\u0E14\u0E19\u0E35\u0E49\u0E23\u0E31\u0E19\u0E44\u0E14\u0E49\u0E1B\u0E01\u0E15\u0E34\u0E19\u0E30 \u0E41\u0E15\u0E48\u0E27\u0E48\u0E32\u0E44\u0E21\u0E48\u0E44\u0E14\u0E49\u0E1E\u0E34\u0E21\u0E1E\u0E4C\u0E2D\u0E30\u0E44\u0E23\u0E2D\u0E2D\u0E01\u0E21\u0E32\u0E40\u0E25\u0E22 \u0E19\u0E48\u0E32\u0E08\u0E30\u0E25\u0E37\u0E21\u0E43\u0E0A\u0E49\u0E04\u0E33\u0E2A\u0E31\u0E48\u0E07\u0E41\u0E2A\u0E14\u0E07\u0E2B\u0E23\u0E37\u0E2D\u0E43\u0E0A\u0E49\u0E43\u0E2B\u0E49\u0E40\u0E15\u0E48\u0E32\u0E27\u0E32\u0E14\u0E23\u0E39\u0E1B\u0E2B\u0E23\u0E37\u0E2D\u0E40\u0E1B\u0E25\u0E48\u0E32",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "\u0E40\u0E01\u0E34\u0E14\u0E02\u0E49\u0E2D\u0E1C\u0E34\u0E14\u0E1E\u0E25\u0E32\u0E14\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E23\u0E31\u0E19\u0E42\u0E1B\u0E23\u0E41\u0E01\u0E23\u0E21",
      "Other_error": "\u0E2D\u0E38\u0E49\u0E22\u0E22! \u0E19\u0E48\u0E32\u0E08\u0E30\u0E1C\u0E34\u0E14\u0E1E\u0E25\u0E32\u0E14\u0E2D\u0E30\u0E44\u0E23\u0E40\u0E25\u0E47\u0E01\u0E19\u0E49\u0E2D\u0E22\u0E2B\u0E23\u0E37\u0E2D\u0E40\u0E1B\u0E25\u0E48\u0E32",
      "Program_repair": "\u0E42\u0E04\u0E49\u0E14\u0E19\u0E35\u0E49\u0E2D\u0E32\u0E08\u0E08\u0E30\u0E16\u0E39\u0E01\u0E41\u0E25\u0E49\u0E27 \u0E41\u0E15\u0E48\u0E04\u0E38\u0E13\u0E25\u0E2D\u0E07\u0E41\u0E01\u0E49\u0E2B\u0E19\u0E48\u0E2D\u0E22\u0E44\u0E14\u0E49\u0E21\u0E31\u0E49\u0E22?",
      "Program_too_long": "\u0E42\u0E1B\u0E23\u0E41\u0E01\u0E23\u0E21\u0E19\u0E35\u0E49\u0E43\u0E0A\u0E49\u0E40\u0E27\u0E25\u0E32\u0E23\u0E31\u0E19\u0E19\u0E32\u0E19\u0E40\u0E01\u0E34\u0E19\u0E44\u0E1B\u0E19\u0E30",
      "ServerError": "\u0E04\u0E38\u0E13\u0E40\u0E02\u0E35\u0E22\u0E19\u0E42\u0E1B\u0E23\u0E41\u0E01\u0E23\u0E21\u0E17\u0E35\u0E48\u0E40\u0E23\u0E32\u0E44\u0E21\u0E48\u0E04\u0E34\u0E14\u0E27\u0E48\u0E32\u0E08\u0E30\u0E21\u0E35\u0E04\u0E19\u0E40\u0E02\u0E35\u0E22\u0E19\u0E21\u0E32 \u0E40\u0E23\u0E32\u0E08\u0E30\u0E02\u0E2D\u0E1A\u0E04\u0E38\u0E13\u0E21\u0E32\u0E01\u0E16\u0E49\u0E32\u0E04\u0E38\u0E13\u0E0A\u0E48\u0E27\u0E22\u0E2A\u0E48\u0E07\u0E42\u0E1B\u0E23\u0E41\u0E01\u0E23\u0E21\u0E41\u0E25\u0E30\u0E40\u0E25\u0E40\u0E27\u0E25\u0E17\u0E35\u0E48\u0E04\u0E38\u0E13\u0E2D\u0E22\u0E39\u0E48\u0E21\u0E32\u0E17\u0E32\u0E07\u0E2D\u0E35\u0E40\u0E21\u0E25 hello@hedy.org \u0E41\u0E25\u0E30\u0E43\u0E19\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E19\u0E35\u0E49 \u0E25\u0E2D\u0E07\u0E14\u0E39\u0E15\u0E31\u0E27\u0E2D\u0E22\u0E48\u0E32\u0E07 \u0E2B\u0E23\u0E37\u0E2D\u0E25\u0E2D\u0E07\u0E40\u0E02\u0E35\u0E22\u0E19\u0E14\u0E49\u0E27\u0E22\u0E27\u0E34\u0E18\u0E35\u0E2D\u0E37\u0E48\u0E19\u0E14\u0E39\u0E01\u0E48\u0E2D\u0E19\u0E19\u0E30 \u0E02\u0E2D\u0E1A\u0E04\u0E38\u0E13\u0E21\u0E32\u0E01!",
      "Transpile_error": "\u0E42\u0E1B\u0E23\u0E41\u0E01\u0E23\u0E21\u0E19\u0E35\u0E49\u0E44\u0E21\u0E48\u0E2A\u0E32\u0E21\u0E32\u0E23\u0E16\u0E23\u0E31\u0E19\u0E44\u0E14\u0E49",
      "Transpile_success": "\u0E40\u0E01\u0E48\u0E07\u0E21\u0E32\u0E01!\n\u0E2A\u0E38\u0E14\u0E22\u0E2D\u0E14!\n\u0E22\u0E2D\u0E14\u0E40\u0E22\u0E35\u0E48\u0E22\u0E21!\n\u0E40\u0E25\u0E34\u0E28\u0E21\u0E32\u0E01!\n\u0E17\u0E33\u0E44\u0E14\u0E49\u0E14\u0E35\u0E21\u0E32\u0E01!",
      "Transpile_warning": "\u0E04\u0E33\u0E40\u0E15\u0E37\u0E2D\u0E19!",
      "Unsaved_Changes": "\u0E42\u0E1B\u0E23\u0E41\u0E01\u0E23\u0E21\u0E17\u0E35\u0E48\u0E40\u0E02\u0E35\u0E22\u0E19\u0E22\u0E31\u0E07\u0E44\u0E21\u0E48\u0E44\u0E14\u0E49\u0E40\u0E0B\u0E1F\u0E19\u0E30 \u0E08\u0E30\u0E2D\u0E2D\u0E01\u0E08\u0E32\u0E01\u0E2B\u0E19\u0E49\u0E32\u0E19\u0E35\u0E49\u0E40\u0E25\u0E22 \u0E42\u0E14\u0E22\u0E44\u0E21\u0E48\u0E40\u0E0B\u0E1F\u0E01\u0E48\u0E2D\u0E19\u0E2B\u0E23\u0E2D?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "tl": {
      "CheckInternet": "Check whether your Internet connection is working.",
      "Connection_error": "We couldn't reach the server.",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Something went wrong while running the program.",
      "Other_error": "Oops! Maybe we made a little mistake.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "We can't run your program.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "Warning!",
      "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "tn": {
      "CheckInternet": "Check whether your Internet connection is working.",
      "Connection_error": "We couldn't reach the server.",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Something went wrong while running the program.",
      "Other_error": "Oops! Maybe we made a little mistake.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "We can't run your program.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "Warning!",
      "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "tr": {
      "CheckInternet": "\u0130nternet ba\u011Flant\u0131n\u0131z do\u011Fru \xE7al\u0131\u015F\u0131yor mu diye bir g\xF6z at\u0131n.",
      "Connection_error": "Sunucuya ula\u015Famad\u0131k.",
      "Empty_output": "Bu kod \xE7al\u0131\u015F\u0131yor ama hi\xE7bir \u015Fey yazd\u0131rm\u0131yor. Kodunuzda bir yazd\u0131rma komutu kullan\u0131n veya bir \xE7\u0131kt\u0131 almak i\xE7in kaplumba\u011Fay\u0131 kullan\u0131n.",
      "Errors_found": "Bir hata yapt\u0131n\u0131z! Endi\u015Felenmeyin, program\u0131 yine de \xE7al\u0131\u015Ft\u0131rd\u0131k",
      "Execute_error": "Program\u0131 \xE7al\u0131\u015Ft\u0131r\u0131rken bir \u015Feyler ters gitti.",
      "Other_error": "Oops! Belki k\xFC\xE7\xFCk bir hata yapm\u0131\u015F olabiliriz.",
      "Program_repair": "Bu do\u011Fru kod olabilirdi, onu d\xFCzeltebilir misin?",
      "Program_too_long": "Program\u0131n\u0131z\u0131n \xE7al\u0131\u015Fmas\u0131 \xE7ok uzun s\xFCr\xFCyor.",
      "ServerError": "Bizim beklemedi\u011Fimiz bir program yazd\u0131n\u0131z. E\u011Fer yard\u0131m etmek isterseniz, bize hello@hedy.org adresinden ilgili seviye ve program\u0131n\u0131zla birlikte bir e-posta g\xF6nderin. Bu arada, biraz farkl\u0131 bir \u015Fey deneyin ve \xF6rneklere bir kez daha g\xF6z at\u0131n. Te\u015Fekk\xFCrler!",
      "Transpile_error": "Program\u0131n\u0131 \xE7al\u0131\u015Ft\u0131ram\u0131yoruz.",
      "Transpile_success": "Aferin!\n\u0130nan\u0131lmaz!\n\u0130yi i\u015Fti, Aferin!\nM\xFCkemmel!\n\xC7ok iyiydin!",
      "Transpile_warning": "Uyar\u0131!",
      "Unsaved_Changes": "Kaydedilmemi\u015F bir program\u0131n var. Kaydetmeden ayr\u0131lmak m\u0131 istiyorsun?",
      "adventures_restored": "Varsay\u0131lan maceralar geri y\xFCklendi.",
      "copy_link_to_share": "Payla\u015Fmak i\xE7in ba\u011Flant\u0131y\u0131 kopyalay\u0131n",
      "customization_deleted": "\xD6zelle\u015Ftirmeler ba\u015Far\u0131yla silindi.",
      "dice": "\u{1F3B2}",
      "directly_available": "Do\u011Frudan a\xE7\u0131n",
      "disabled": "Devre d\u0131\u015F\u0131",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Seviye",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Hedy'ye ho\u015F geldiniz! Art\u0131k s\u0131n\u0131flar olu\u015Fturman\u0131za ve \xF6\u011Frencileri davet etmenize olanak tan\u0131yan bir \xF6\u011Fretmen hesab\u0131n\u0131n gururlu sahibisiniz.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "Kaydedilmemi\u015F de\u011Fi\u015Fiklikler var, bu sayfadan ayr\u0131lmak istedi\u011Finize emin misiniz?"
    },
    "uk": {
      "CheckInternet": "\u041F\u0435\u0440\u0435\u0432\u0456\u0440\u0442\u0435, \u0447\u0438 \u0432\u0430\u0448\u0435 \u043F\u0456\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044F \u0434\u043E \u0406\u043D\u0442\u0435\u0440\u043D\u0435\u0442\u0443 \u043F\u0440\u0430\u0446\u044E\u0454 \u043D\u0430\u043B\u0435\u0436\u043D\u0438\u043C \u0447\u0438\u043D\u043E\u043C.",
      "Connection_error": "\u041D\u0435 \u0432\u0434\u0430\u043B\u043E\u0441\u044F \u043F\u0456\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u0438\u0441\u044F \u0434\u043E \u0441\u0435\u0440\u0432\u0435\u0440\u0430.",
      "Empty_output": "\u0426\u0435\u0439 \u043A\u043E\u0434 \u043F\u0440\u0430\u0446\u044E\u0454, \u0430\u043B\u0435 \u043D\u0456\u0447\u043E\u0433\u043E \u043D\u0435 \u0434\u0440\u0443\u043A\u0443\u0454. \u0414\u043E\u0434\u0430\u0439\u0442\u0435 \u043A\u043E\u043C\u0430\u043D\u0434\u0443 \u0434\u0440\u0443\u043A\u0443 \u0434\u043E \u0441\u0432\u043E\u0433\u043E \u043A\u043E\u0434\u0443 \u0430\u0431\u043E \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0439\u0442\u0435 \u0447\u0435\u0440\u0435\u043F\u0430\u0445\u0443, \u0449\u043E\u0431 \u043E\u0442\u0440\u0438\u043C\u0430\u0442\u0438 \u0432\u0438\u0432\u0456\u0434.",
      "Errors_found": "\u0412\u0438 \u0437\u0440\u043E\u0431\u0438\u043B\u0438 \u043F\u043E\u043C\u0438\u043B\u043A\u0443! \u041D\u0435 \u0442\u0443\u0440\u0431\u0443\u0439\u0442\u0435\u0441\u044F, \u043C\u0438 \u043F\u0440\u043E\u0434\u043E\u0432\u0438\u043C\u043E \u0432\u0438\u043A\u043E\u043D\u0443\u0432\u0430\u0442\u0438 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0443",
      "Execute_error": "\u0429\u043E\u0441\u044C \u043F\u0456\u0448\u043B\u043E \u043D\u0435 \u0442\u0430\u043A \u043F\u0456\u0434 \u0447\u0430\u0441 \u0437\u0430\u043F\u0443\u0441\u043A\u0443 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0438.",
      "Other_error": "\u041E\u0439! \u041C\u043E\u0436\u043B\u0438\u0432\u043E, \u043C\u0438 \u0442\u0440\u043E\u0445\u0438 \u043F\u043E\u043C\u0438\u043B\u0438\u043B\u0438\u0441\u044F.",
      "Program_repair": "\u0426\u0435 \u043C\u043E\u0436\u0435 \u0431\u0443\u0442\u0438 \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043E\u0434, \u0432\u0438 \u043C\u043E\u0436\u0435\u0442\u0435 \u0439\u043E\u0433\u043E \u0432\u0438\u043F\u0440\u0430\u0432\u0438\u0442\u0438?",
      "Program_too_long": "\u0412\u0430\u0448\u0430 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0430 \u0432\u0438\u043A\u043E\u043D\u0443\u0454\u0442\u044C\u0441\u044F \u043D\u0430\u0434\u0442\u043E \u0434\u043E\u0432\u0433\u043E.",
      "ServerError": "\u0412\u0438 \u043D\u0430\u043F\u0438\u0441\u0430\u043B\u0438 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0443, \u044F\u043A\u0443 \u043C\u0438 \u043D\u0435 \u043E\u0447\u0456\u043A\u0443\u0432\u0430\u043B\u0438. \u042F\u043A\u0449\u043E \u0432\u0438 \u0445\u043E\u0447\u0435\u0442\u0435 \u0434\u043E\u043F\u043E\u043C\u043E\u0433\u0442\u0438, \u043D\u0430\u0434\u0456\u0448\u043B\u0456\u0442\u044C \u043D\u0430\u043C \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u0438\u0439 \u043B\u0438\u0441\u0442 \u0456\u0437 \u0437\u0430\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F\u043C \u0440\u0456\u0432\u043D\u044F \u0442\u0430 \u0432\u0430\u0448\u043E\u0457 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0438 \u043D\u0430 hello@hedy.org. \u0422\u0438\u043C \u0447\u0430\u0441\u043E\u043C \u0441\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0449\u043E\u0441\u044C \u0442\u0440\u043E\u0445\u0438 \u0456\u043D\u0448\u0435 \u0442\u0430 \u0449\u0435 \u0440\u0430\u0437 \u043F\u043E\u0434\u0438\u0432\u0456\u0442\u044C\u0441\u044F \u043D\u0430 \u043F\u0440\u0438\u043A\u043B\u0430\u0434\u0438. \u0414\u044F\u043A\u0443\u044E!",
      "Transpile_error": "\u041C\u0438 \u043D\u0435 \u043C\u043E\u0436\u0435\u043C\u043E \u0437\u0430\u043F\u0443\u0441\u0442\u0438\u0442\u0438 \u0432\u0430\u0448\u0443 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0443.",
      "Transpile_success": "\u0413\u0430\u0440\u043D\u0430 \u0440\u043E\u0431\u043E\u0442\u0430!\n\u0414\u0438\u0432\u043E\u0432\u0438\u0436\u043D\u043E!\n\u0427\u0443\u0434\u043E\u0432\u0430 \u0440\u043E\u0431\u043E\u0442\u0430!\n\u0427\u0443\u0434\u043E\u0432\u043E!\n\u0412\u0438 \u0447\u0443\u0434\u043E\u0432\u043E \u0432\u043F\u043E\u0440\u0430\u043B\u0438\u0441\u044F!",
      "Transpile_warning": "\u041F\u043E\u043F\u0435\u0440\u0435\u0434\u0436\u0435\u043D\u043D\u044F!",
      "Unsaved_Changes": "\u0412\u0438 \u043C\u0430\u0454\u0442\u0435 \u043D\u0435\u0437\u0431\u0435\u0440\u0435\u0436\u0435\u043D\u0443 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0443. \u0412\u0438 \u0445\u043E\u0447\u0435\u0442\u0435 \u0432\u0438\u0439\u0442\u0438, \u043D\u0435 \u0437\u0431\u0435\u0440\u0456\u0433\u0448\u0438 \u0457\u0457?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "\u0421\u043A\u043E\u043F\u0456\u044E\u0439\u0442\u0435 \u043F\u043E\u0441\u0438\u043B\u0430\u043D\u043D\u044F, \u0449\u043E\u0431 \u043F\u043E\u0434\u0456\u043B\u0438\u0442\u0438\u0441\u044F",
      "customization_deleted": "\u041D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F \u0443\u0441\u043F\u0456\u0448\u043D\u043E \u0432\u0438\u0434\u0430\u043B\u0435\u043D\u043E.",
      "dice": "\u{1F3B2}",
      "directly_available": "\u0411\u0435\u0437\u043F\u043E\u0441\u0435\u0440\u0435\u0434\u043D\u044C\u043E \u0432\u0456\u0434\u043A\u0440\u0438\u0442\u0438",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "\u0420\u0456\u0432\u0435\u043D\u044C",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "ur": {
      "CheckInternet": "Check whether your Internet connection is working.",
      "Connection_error": "We couldn't reach the server.",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Something went wrong while running the program.",
      "Other_error": "Oops! Maybe we made a little mistake.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "We can't run your program.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "Warning!",
      "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "vi": {
      "CheckInternet": "H\xE3y xem k\u1EBFt n\u1ED1i Internet c\u1EE7a b\u1EA1n c\xF3 ho\u1EA1t \u0111\u1ED9ng b\xECnh th\u01B0\u1EDDng kh\xF4ng.",
      "Connection_error": "Ch\xFAng t\xF4i kh\xF4ng th\u1EC3 k\u1EBFt n\u1ED1i t\u1EDBi server.",
      "Empty_output": "Ch\u01B0\u01A1ng tr\xECnh n\xE0y ho\u1EA1t \u0111\u1ED9ng nh\u01B0ng kh\xF4ng in ra g\xEC c\u1EA3. Th\xEAm l\u1EC7nh in v\xE0o ch\u01B0\u01A1ng tr\xECnh ho\u1EB7c s\u1EED d\u1EE5ng con r\xF9a \u0111\u1EC3 c\xF3 \u0111\u1EA7u ra nh\xE9.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "\u0110\xE3 x\u1EA3y ra s\u1EF1 c\u1ED1 khi ch\u1EA1y ch\u01B0\u01A1ng tr\xECnh.",
      "Other_error": "R\u1EA5t ti\u1EBFc! C\xF3 l\u1EBD ch\xFAng t\xF4i \u0111\xE3 ph\u1EA1m m\u1ED9t sai l\u1EA7m nh\u1ECF.",
      "Program_repair": "\u0110\xE2y c\xF3 th\u1EC3 l\xE0 ch\u01B0\u01A1ng tr\xECnh ch\xEDnh x\xE1c, b\u1EA1n c\xF3 th\u1EC3 s\u1EEDa n\xF3 kh\xF4ng?",
      "Program_too_long": "Ch\u01B0\u01A1ng tr\xECnh c\u1EE7a b\u1EA1n t\u1ED1n qu\xE1 nhi\u1EC1u th\u1EDDi gian \u0111\u1EC3 ch\u1EA1y.",
      "ServerError": "B\u1EA1n \u0111\xE3 vi\u1EBFt m\u1ED9t ch\u01B0\u01A1ng tr\xECnh m\xE0 ch\xFAng t\xF4i kh\xF4ng mong \u0111\u1EE3i. N\u1EBFu b\u1EA1n mu\u1ED1n tr\u1EE3 gi\xFAp, h\xE3y g\u1EEDi email cho ch\xFAng t\xF4i v\u1EC1 c\u1EA5p \u0111\u1ED9 v\xE0 ch\u01B0\u01A1ng tr\xECnh c\u1EE7a b\u1EA1n t\u1EA1i hello@hedy.org. Trong th\u1EDDi gian ch\u1EDD \u0111\u1EE3i, h\xE3y th\u1EED l\xE0m g\xEC \u0111\xF3 kh\xE1c bi\u1EC7t m\u1ED9t ch\xFAt v\xE0 xem l\u1EA1i c\xE1c v\xED d\u1EE5. Xin c\u1EA3m \u01A1n!",
      "Transpile_error": "Ch\xFAng t\xF4i kh\xF4ng th\u1EC3 ch\u1EA1y ch\u01B0\u01A1ng tr\xECnh c\u1EE7a b\u1EA1n.",
      "Transpile_success": "L\xE0m t\u1ED1t l\u1EAFm!\nR\u1EA5t tuy\u1EC7t v\u1EDDi!\nT\u1ED1t l\u1EAFm!\nHay qu\xE1!\nB\u1EA1n l\xE0m r\u1EA5t t\u1ED1t!",
      "Transpile_warning": "C\u1EA3nh b\xE1o!",
      "Unsaved_Changes": "B\u1EA1n c\xF3 m\u1ED9t ch\u01B0\u01A1ng tr\xECnh ch\u01B0a \u0111\u01B0\u1EE3c l\u01B0u. B\u1EA1n c\xF3 mu\u1ED1n tho\xE1t m\xE0 kh\xF4ng l\u01B0u n\xF3 kh\xF4ng?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F528},\u{1F4DC}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "zh_Hans": {
      "CheckInternet": "\u67E5\u770B\u4E00\u4E0B\u4F60\u7684\u7F51\u7EDC\u8FDE\u63A5\u662F\u5426\u6B63\u5E38.",
      "Connection_error": "\u6211\u4EEC\u65E0\u6CD5\u8FDE\u63A5\u5230\u670D\u52A1\u5668\u3002",
      "Empty_output": "\u8FD9\u6BB5\u4EE3\u7801\u53EF\u4EE5\u5DE5\u4F5C\uFF0C\u4F46\u6CA1\u6709\u6253\u5370\u4EFB\u4F55\u4E1C\u897F\u3002\u5728\u4F60\u7684\u4EE3\u7801\u4E2D\u6DFB\u52A0\u4E00\u4E2A\u6253\u5370\u547D\u4EE4\uFF0C\u6216\u8005\u4F7F\u7528\u4E4C\u9F9F\u6765\u83B7\u5F97\u8F93\u51FA\u3002",
      "Errors_found": "\u4F60\u641E\u9519\u4E86\uFF01\u4E0D\u8981\u7740\u6025\uFF0C\u6211\u4EEC\u4ECD\u7136\u8FD0\u884C\u8BE5\u7A0B\u5E8F",
      "Execute_error": "\u5728\u8FD0\u884C\u7A0B\u5E8F\u65F6\u51FA\u4E86\u70B9\u95EE\u9898\u3002",
      "Other_error": "\u7CDF\u7CD5\uFF01 \u4E5F\u8BB8\u6211\u4EEC\u72AF\u4E86\u4E00\u4E2A\u5C0F\u9519\u8BEF\u3002",
      "Program_repair": "\u8FD9\u53EF\u80FD\u662F\u6B63\u786E\u7684\u4EE3\u7801\uFF0C\u4F60\u80FD\u4FEE\u590D\u5B83\u5417\uFF1F",
      "Program_too_long": "\u4F60\u7684\u7A0B\u5E8F\u8FD0\u884C\u7684\u65F6\u95F4\u592A\u957F\u4E86\u3002",
      "ServerError": "\u4F60\u5199\u4E86\u4E00\u4E2A\u51FA\u4E4E\u6211\u4EEC\u610F\u6599\u7684\u7A0B\u5E8F\u3002\u5982\u679C\u60A8\u60F3\u63D0\u4F9B\u5E2E\u52A9\uFF0C\u8BF7\u901A\u8FC7 hello@hedy.org \u5411\u6211\u4EEC\u53D1\u9001\u4E00\u5C01\u7535\u5B50\u90AE\u4EF6\uFF0C\u5176\u4E2D\u5305\u542B\u7EA7\u522B\u548C\u60A8\u7684\u7A0B\u5E8F\u3002\u4E0E\u6B64\u540C\u65F6\uFF0C\u5C1D\u8BD5\u4E00\u4E9B\u4E0D\u540C\u7684\u4E1C\u897F\uFF0C\u518D\u770B\u770B\u8FD9\u4E9B\u4F8B\u5B50\u3002\u8C22\u8C22\uFF01",
      "Transpile_error": "\u6211\u4EEC\u65E0\u6CD5\u8FD0\u884C\u4F60\u7684\u7A0B\u5E8F\u3002",
      "Transpile_success": "\u597D\u6837\u7684\uFF01\n\u4E86\u4E0D\u8D77\uFF01\n\u505A\u7684\u5F88\u597D\uFF01\n\u68D2\u6781\u4E86\uFF01\n\u505A\u7684\u771F\u68D2\uFF01",
      "Transpile_warning": "\u8B66\u544A\uFF01",
      "Unsaved_Changes": "\u4F60\u6709\u4E00\u4E2A\u672A\u4FDD\u5B58\u7684\u7A0B\u5E8F\u3002\u4F60\u60F3\u4E0D\u4FDD\u5B58\u5C31\u79BB\u5F00\u5417\uFF1F",
      "adventures_restored": "\u9ED8\u8BA4\u7684\u5192\u9669\u5DF2\u7ECF\u6062\u590D\uFF01",
      "copy_link_to_share": "\u590D\u5236\u94FE\u63A5\u4EE5\u5206\u4EAB",
      "customization_deleted": "\u5DF2\u6210\u529F\u5220\u9664\u81EA\u5B9A\u4E49\u9879\u3002",
      "dice": "\u{1F3B2}",
      "directly_available": "\u76F4\u63A5\u6253\u5F00",
      "disabled": "\u7981\u7528\u7684",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "\u7EA7\u522B",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    },
    "zh_Hant": {
      "CheckInternet": "Check whether your Internet connection is working.",
      "Connection_error": "We couldn't reach the server.",
      "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
      "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
      "Execute_error": "Something went wrong while running the program.",
      "Other_error": "Oops! Maybe we made a little mistake.",
      "Program_repair": "This could be the correct code, can you fix it?",
      "Program_too_long": "Your program takes too long to run.",
      "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
      "Transpile_error": "We can't run your program.",
      "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
      "Transpile_warning": "Warning!",
      "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
      "adventures_restored": "The default adventures have been restored!",
      "copy_link_to_share": "Copy link to share",
      "customization_deleted": "Customizations successfully deleted.",
      "dice": "\u{1F3B2}",
      "directly_available": "Directly open",
      "disabled": "Disabled",
      "fortune": "\u{1F52E}, \u2728",
      "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
      "level_title": "Level",
      "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
      "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
      "songs": "\u{1F3B5},\u{1F3B6}",
      "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
      "turtle": "\u{1F422}",
      "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
    }
  };

  // static/js/client-messages.ts
  var ClientMessages = Object.assign({}, TRANSLATIONS["en"]);
  function setClientMessageLanguage(key) {
    var _a3;
    Object.assign(ClientMessages, (_a3 = TRANSLATIONS[key]) != null ? _a3 : TRANSLATIONS["en"]);
  }

  // static/js/modal.ts
  var Modal = class {
    constructor() {
      $("#modal-confirm-button").on("click", () => this.hide());
      $("#modal-no-button").on("click", () => this.hide());
      $("#modal-cancel-button").on("click", () => this.hide());
      $("#modal-copy-ok-button").on("click", () => this.hide());
      $("#modal-copy-close-button").on("click", () => this.hide());
      $("#modal-repair-button").on("click", () => this.hide());
      $("#modal-preview-button").on("click", () => this.hide());
      $("#modal-alert-button").on("click", () => this.hide_alert());
    }
    show() {
      $("#modal-mask").show();
      $("#modal-content").show();
      window.scrollTo(0, 0);
    }
    hide() {
      $("#modal-mask").hide();
      $("#modal-content").hide();
      $("#modal-prompt").hide();
      $("#modal-confirm").hide();
      $("#modal-copy").hide();
      $("#modal-repair").hide();
      $("#modal-preview").hide();
    }
    hide_alert() {
      $("#modal-alert").fadeOut(500);
    }
    notifySuccess(message, timeoutMs = 3e3) {
      return this.alert(message, timeoutMs);
    }
    notifyError(message, timeoutMs = 5e3) {
      return this.alert(message, timeoutMs, true);
    }
    alert(message, timeoutMs, error2) {
      $("#modal_alert_container").toggleClass("bg-red-100 border-red-400 text-red-700", !!error2);
      $("#modal_alert_container").toggleClass("bg-green-100 border-green-400 text-green-700", !error2);
      $("#modal-alert-button").toggleClass("text-red-500", !!error2);
      $("#modal-alert-button").toggleClass("text-green-500", !error2);
      $("#modal_alert_text").html(message);
      $("#modal-alert").fadeIn(500);
      if (this._alert_timeout) {
        clearTimeout(this._alert_timeout);
        this._alert_timeout = void 0;
      }
      if (timeoutMs)
        this._alert_timeout = setTimeout(() => this.hide_alert(), timeoutMs);
    }
    copy_alert(message, timeoutMs, title = "") {
      this.hide();
      if (title != "") {
        $("#modal-copy-title").html(title);
        $("#modal-copy-title").removeClass("hidden");
      } else {
        $("#modal-copy-title").html("");
        $("#modal-copy-title").addClass("hidden");
      }
      $("#modal-copy-text").html(message);
      this.show();
      $("#modal-copy").show();
      if (this._timeout) {
        clearTimeout(this._timeout);
        this._timeout = void 0;
      }
      if (timeoutMs)
        this._timeout = setTimeout(() => this.hide(), timeoutMs);
    }
    preview(content2, title) {
      this.hide();
      $("#modal-preview-title").html(title);
      const target = $("#modal-preview-content");
      content2.attr("id", "modal-preview-content");
      target.replaceWith(content2);
      this.show();
      $("#modal-preview").show();
      if (this._timeout) {
        clearTimeout(this._timeout);
        this._timeout = void 0;
      }
    }
    repair(message, timeoutMs, title = "") {
      this.hide();
      if (title != "") {
        $("#modal-repair-title").html(title);
        $("#modal-repair-title").removeClass("hidden");
      } else {
        $("#modal-repair-title").html("");
        $("#modal-repair-title").addClass("hidden");
      }
      $("#modal-repair-text").html(message);
      this.show();
      $("#modal-repair").show();
      if (timeoutMs)
        setTimeout(() => this.hide(), timeoutMs);
      if (this._timeout) {
        clearTimeout(this._timeout);
        this._timeout = void 0;
      }
      if (timeoutMs)
        this._timeout = setTimeout(() => this.hide(), timeoutMs);
    }
    confirmP(message) {
      return new Promise((ok) => this.confirm(message, ok));
    }
    confirm(message, confirmCb, declineCb = function() {
    }) {
      this.hide();
      $("#modal-confirm-text").text(message);
      this.show();
      $("#modal-confirm").show();
      if (this._timeout) {
        clearTimeout(this._timeout);
        this._timeout = void 0;
      }
      $("#modal-yes-button").off("click").on("click", () => {
        this.hide();
        confirmCb();
      });
      $("#modal-no-button").off("click").on("click", () => {
        this.hide();
        declineCb();
      });
    }
    prompt(message, defaultValue, confirmCb) {
      this.hide();
      $("#modal-prompt-text").text(message);
      this.show();
      $("#modal-prompt").show();
      if (defaultValue)
        $("#modal-prompt-input").val(defaultValue);
      if (this._timeout) {
        clearTimeout(this._timeout);
        this._timeout = void 0;
      }
      $("#modal-ok-button").off("click").on("click", () => {
        this.hide();
        const value = $("#modal-prompt-input").val();
        if (typeof value === "string") {
          $("#modal-prompt-input").val("");
          confirmCb(value);
        }
      });
    }
  };
  var success = {
    hide: function() {
      $("#okbox").hide();
    },
    showWarning(caption, message) {
      $("#okbox .caption").text(caption);
      $("#okbox .details").text(message);
      $("#okbox").show();
    },
    show(caption) {
      $("#okbox .caption").text(caption);
      $("#okbox").show();
      setTimeout(function() {
        $("#okbox").hide();
      }, 3e3);
    }
  };
  var error = {
    hide() {
      $("#errorbox").hide();
      $("#warningbox").hide();
    },
    showWarning(caption, message) {
      this.hide();
      $("#warningbox .caption").text(caption);
      $("#warningbox .details").text(message);
      $("#warningbox").show();
    },
    show(caption, message) {
      $("#errorbox .caption").text(caption);
      $("#errorbox .details").html(message);
      $("#errorbox").show();
    },
    showFadingWarning(caption, message) {
      error.showWarning(caption, message);
      setTimeout(function() {
        $("#warningbox").fadeOut();
      }, 1e4);
    }
  };
  var modal = new Modal();
  async function tryCatchPopup(cb2) {
    try {
      return await cb2();
    } catch (e) {
      console.log("Error", e);
      modal.notifyError(e.message);
    }
  }

  // static/js/app.ts
  var import_jszip = __toModule(require_jszip_min());

  // node_modules/tone/build/esm/version.js
  var version = "14.7.77";

  // node_modules/standardized-audio-context/build/es2019/module.js
  var import_automation_events2 = __toModule(require_bundle());

  // node_modules/standardized-audio-context/build/es2019/factories/abort-error.js
  var createAbortError = () => new DOMException("", "AbortError");

  // node_modules/standardized-audio-context/build/es2019/factories/add-active-input-connection-to-audio-node.js
  var createAddActiveInputConnectionToAudioNode = (insertElementInSet2) => {
    return (activeInputs, source, [output, input2, eventListener], ignoreDuplicates) => {
      insertElementInSet2(activeInputs[input2], [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/add-audio-node-connections.js
  var createAddAudioNodeConnections = (audioNodeConnectionsStore) => {
    return (audioNode, audioNodeRenderer, nativeAudioNode) => {
      const activeInputs = [];
      for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {
        activeInputs.push(new Set());
      }
      audioNodeConnectionsStore.set(audioNode, {
        activeInputs,
        outputs: new Set(),
        passiveInputs: new WeakMap(),
        renderer: audioNodeRenderer
      });
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/add-audio-param-connections.js
  var createAddAudioParamConnections = (audioParamConnectionsStore) => {
    return (audioParam, audioParamRenderer) => {
      audioParamConnectionsStore.set(audioParam, { activeInputs: new Set(), passiveInputs: new WeakMap(), renderer: audioParamRenderer });
    };
  };

  // node_modules/standardized-audio-context/build/es2019/globals.js
  var ACTIVE_AUDIO_NODE_STORE = new WeakSet();
  var AUDIO_NODE_CONNECTIONS_STORE = new WeakMap();
  var AUDIO_NODE_STORE = new WeakMap();
  var AUDIO_PARAM_CONNECTIONS_STORE = new WeakMap();
  var AUDIO_PARAM_STORE = new WeakMap();
  var CONTEXT_STORE = new WeakMap();
  var EVENT_LISTENERS = new WeakMap();
  var CYCLE_COUNTERS = new WeakMap();
  var NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = new WeakMap();
  var NODE_TO_PROCESSOR_MAPS = new WeakMap();

  // node_modules/standardized-audio-context/build/es2019/helpers/is-constructible.js
  var handler = {
    construct() {
      return handler;
    }
  };
  var isConstructible = (constructible) => {
    try {
      const proxy = new Proxy(constructible, handler);
      new proxy();
    } catch (e) {
      return false;
    }
    return true;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/split-import-statements.js
  var IMPORT_STATEMENT_REGEX = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/;
  var splitImportStatements = (source, url) => {
    const importStatements = [];
    let sourceWithoutImportStatements = source.replace(/^[\s]+/, "");
    let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);
    while (result !== null) {
      const unresolvedUrl = result[1].slice(1, -1);
      const importStatementWithResolvedUrl = result[0].replace(/([\s]+)?;?$/, "").replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());
      importStatements.push(importStatementWithResolvedUrl);
      sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\s]+/, "");
      result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);
    }
    return [importStatements.join(";"), sourceWithoutImportStatements];
  };

  // node_modules/standardized-audio-context/build/es2019/factories/add-audio-worklet-module.js
  var verifyParameterDescriptors = (parameterDescriptors) => {
    if (parameterDescriptors !== void 0 && !Array.isArray(parameterDescriptors)) {
      throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.");
    }
  };
  var verifyProcessorCtor = (processorCtor) => {
    if (!isConstructible(processorCtor)) {
      throw new TypeError("The given value for processorCtor should be a constructor.");
    }
    if (processorCtor.prototype === null || typeof processorCtor.prototype !== "object") {
      throw new TypeError("The given value for processorCtor should have a prototype.");
    }
  };
  var createAddAudioWorkletModule = (cacheTestResult2, createNotSupportedError2, evaluateSource, exposeCurrentFrameAndCurrentTime2, fetchSource, getNativeContext2, getOrCreateBackupOfflineAudioContext2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2, ongoingRequests, resolvedRequests, testAudioWorkletProcessorPostMessageSupport, window3) => {
    let index3 = 0;
    return (context2, moduleURL, options = { credentials: "omit" }) => {
      const resolvedRequestsOfContext = resolvedRequests.get(context2);
      if (resolvedRequestsOfContext !== void 0 && resolvedRequestsOfContext.has(moduleURL)) {
        return Promise.resolve();
      }
      const ongoingRequestsOfContext = ongoingRequests.get(context2);
      if (ongoingRequestsOfContext !== void 0) {
        const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);
        if (promiseOfOngoingRequest !== void 0) {
          return promiseOfOngoingRequest;
        }
      }
      const nativeContext = getNativeContext2(context2);
      const promise = nativeContext.audioWorklet === void 0 ? fetchSource(moduleURL).then(([source, absoluteUrl]) => {
        const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);
        const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}
})})(window,'_AWGS')`;
        return evaluateSource(wrappedSource);
      }).then(() => {
        const evaluateAudioWorkletGlobalScope = window3._AWGS.pop();
        if (evaluateAudioWorkletGlobalScope === void 0) {
          throw new SyntaxError();
        }
        exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {
        }, void 0, (name2, processorCtor) => {
          if (name2.trim() === "") {
            throw createNotSupportedError2();
          }
          const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);
          if (nodeNameToProcessorConstructorMap !== void 0) {
            if (nodeNameToProcessorConstructorMap.has(name2)) {
              throw createNotSupportedError2();
            }
            verifyProcessorCtor(processorCtor);
            verifyParameterDescriptors(processorCtor.parameterDescriptors);
            nodeNameToProcessorConstructorMap.set(name2, processorCtor);
          } else {
            verifyProcessorCtor(processorCtor);
            verifyParameterDescriptors(processorCtor.parameterDescriptors);
            NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name2, processorCtor]]));
          }
        }, nativeContext.sampleRate, void 0, void 0));
      }) : Promise.all([
        fetchSource(moduleURL),
        Promise.resolve(cacheTestResult2(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport))
      ]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {
        const currentIndex = index3 + 1;
        index3 = currentIndex;
        const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);
        const patchedAudioWorkletProcessor = isSupportingPostMessage ? "AudioWorkletProcessor" : "class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}";
        const memberDefinition = isSupportingPostMessage ? "" : "__c = (a) => a.forEach(e=>this.__b.add(e.buffer));";
        const bufferRegistration = isSupportingPostMessage ? "" : "i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));";
        const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}
})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;
        const blob = new Blob([wrappedSource], { type: "application/javascript; charset=utf-8" });
        const url = URL.createObjectURL(blob);
        return nativeContext.audioWorklet.addModule(url, options).then(() => {
          if (isNativeOfflineAudioContext2(nativeContext)) {
            return nativeContext;
          }
          const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext2(nativeContext);
          return backupOfflineAudioContext.audioWorklet.addModule(url, options).then(() => backupOfflineAudioContext);
        }).then((nativeContextOrBackupOfflineAudioContext) => {
          if (nativeAudioWorkletNodeConstructor2 === null) {
            throw new SyntaxError();
          }
          try {
            new nativeAudioWorkletNodeConstructor2(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`);
          } catch (e) {
            throw new SyntaxError();
          }
        }).finally(() => URL.revokeObjectURL(url));
      });
      if (ongoingRequestsOfContext === void 0) {
        ongoingRequests.set(context2, new Map([[moduleURL, promise]]));
      } else {
        ongoingRequestsOfContext.set(moduleURL, promise);
      }
      promise.then(() => {
        const updatedResolvedRequestsOfContext = resolvedRequests.get(context2);
        if (updatedResolvedRequestsOfContext === void 0) {
          resolvedRequests.set(context2, new Set([moduleURL]));
        } else {
          updatedResolvedRequestsOfContext.add(moduleURL);
        }
      }).finally(() => {
        const updatedOngoingRequestsOfContext = ongoingRequests.get(context2);
        if (updatedOngoingRequestsOfContext !== void 0) {
          updatedOngoingRequestsOfContext.delete(moduleURL);
        }
      });
      return promise;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js
  var getValueForKey = (map3, key) => {
    const value = map3.get(key);
    if (value === void 0) {
      throw new Error("A value with the given key could not be found.");
    }
    return value;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/pick-element-from-set.js
  var pickElementFromSet = (set2, predicate) => {
    const matchingElements = Array.from(set2).filter(predicate);
    if (matchingElements.length > 1) {
      throw Error("More than one element was found.");
    }
    if (matchingElements.length === 0) {
      throw Error("No element was found.");
    }
    const [matchingElement] = matchingElements;
    set2.delete(matchingElement);
    return matchingElement;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-node.js
  var deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output, input2) => {
    const passiveInputConnections = getValueForKey(passiveInputs, source);
    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input2);
    if (passiveInputConnections.size === 0) {
      passiveInputs.delete(source);
    }
    return matchingConnection;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/get-event-listeners-of-audio-node.js
  var getEventListenersOfAudioNode = (audioNode) => {
    return getValueForKey(EVENT_LISTENERS, audioNode);
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-active.js
  var setInternalStateToActive = (audioNode) => {
    if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {
      throw new Error("The AudioNode is already stored.");
    }
    ACTIVE_AUDIO_NODE_STORE.add(audioNode);
    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(true));
  };

  // node_modules/standardized-audio-context/build/es2019/guards/audio-worklet-node.js
  var isAudioWorkletNode = (audioNode) => {
    return "port" in audioNode;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive.js
  var setInternalStateToPassive = (audioNode) => {
    if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {
      throw new Error("The AudioNode is not stored.");
    }
    ACTIVE_AUDIO_NODE_STORE.delete(audioNode);
    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(false));
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive-when-necessary.js
  var setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {
    if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => connections.size === 0)) {
      setInternalStateToPassive(audioNode);
    }
  };

  // node_modules/standardized-audio-context/build/es2019/factories/add-connection-to-audio-node.js
  var createAddConnectionToAudioNode = (addActiveInputConnectionToAudioNode2, addPassiveInputConnectionToAudioNode2, connectNativeAudioNodeToNativeAudioNode2, deleteActiveInputConnectionToAudioNode2, disconnectNativeAudioNodeFromNativeAudioNode2, getAudioNodeConnections2, getAudioNodeTailTime2, getEventListenersOfAudioNode2, getNativeAudioNode2, insertElementInSet2, isActiveAudioNode2, isPartOfACycle2, isPassiveAudioNode2) => {
    const tailTimeTimeoutIds = new WeakMap();
    return (source, destination, output, input2, isOffline) => {
      const { activeInputs, passiveInputs } = getAudioNodeConnections2(destination);
      const { outputs } = getAudioNodeConnections2(source);
      const eventListeners = getEventListenersOfAudioNode2(source);
      const eventListener = (isActive) => {
        const nativeDestinationAudioNode = getNativeAudioNode2(destination);
        const nativeSourceAudioNode = getNativeAudioNode2(source);
        if (isActive) {
          const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input2);
          addActiveInputConnectionToAudioNode2(activeInputs, source, partialConnection, false);
          if (!isOffline && !isPartOfACycle2(source)) {
            connectNativeAudioNodeToNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output, input2);
          }
          if (isPassiveAudioNode2(destination)) {
            setInternalStateToActive(destination);
          }
        } else {
          const partialConnection = deleteActiveInputConnectionToAudioNode2(activeInputs, source, output, input2);
          addPassiveInputConnectionToAudioNode2(passiveInputs, input2, partialConnection, false);
          if (!isOffline && !isPartOfACycle2(source)) {
            disconnectNativeAudioNodeFromNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output, input2);
          }
          const tailTime = getAudioNodeTailTime2(destination);
          if (tailTime === 0) {
            if (isActiveAudioNode2(destination)) {
              setInternalStateToPassiveWhenNecessary(destination, activeInputs);
            }
          } else {
            const tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);
            if (tailTimeTimeoutId !== void 0) {
              clearTimeout(tailTimeTimeoutId);
            }
            tailTimeTimeoutIds.set(destination, setTimeout(() => {
              if (isActiveAudioNode2(destination)) {
                setInternalStateToPassiveWhenNecessary(destination, activeInputs);
              }
            }, tailTime * 1e3));
          }
        }
      };
      if (insertElementInSet2(outputs, [destination, output, input2], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input2, true)) {
        eventListeners.add(eventListener);
        if (isActiveAudioNode2(source)) {
          addActiveInputConnectionToAudioNode2(activeInputs, source, [output, input2, eventListener], true);
        } else {
          addPassiveInputConnectionToAudioNode2(passiveInputs, input2, [source, output, eventListener], true);
        }
        return true;
      }
      return false;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/add-passive-input-connection-to-audio-node.js
  var createAddPassiveInputConnectionToAudioNode = (insertElementInSet2) => {
    return (passiveInputs, input2, [source, output, eventListener], ignoreDuplicates) => {
      const passiveInputConnections = passiveInputs.get(source);
      if (passiveInputConnections === void 0) {
        passiveInputs.set(source, new Set([[output, input2, eventListener]]));
      } else {
        insertElementInSet2(passiveInputConnections, [output, input2, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input2, ignoreDuplicates);
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/add-silent-connection.js
  var createAddSilentConnection = (createNativeGainNode2) => {
    return (nativeContext, nativeAudioScheduledSourceNode) => {
      const nativeGainNode = createNativeGainNode2(nativeContext, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        gain: 0
      });
      nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);
      const disconnect2 = () => {
        nativeAudioScheduledSourceNode.removeEventListener("ended", disconnect2);
        nativeAudioScheduledSourceNode.disconnect(nativeGainNode);
        nativeGainNode.disconnect();
      };
      nativeAudioScheduledSourceNode.addEventListener("ended", disconnect2);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/add-unrendered-audio-worklet-node.js
  var createAddUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes2) => {
    return (nativeContext, audioWorkletNode) => {
      getUnrenderedAudioWorkletNodes2(nativeContext).add(audioWorkletNode);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/analyser-node-constructor.js
  var DEFAULT_OPTIONS = {
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    fftSize: 2048,
    maxDecibels: -30,
    minDecibels: -100,
    smoothingTimeConstant: 0.8
  };
  var createAnalyserNodeConstructor = (audionNodeConstructor, createAnalyserNodeRenderer2, createIndexSizeError2, createNativeAnalyserNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
    return class AnalyserNode extends audionNodeConstructor {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS), options);
        const nativeAnalyserNode = createNativeAnalyserNode2(nativeContext, mergedOptions);
        const analyserNodeRenderer = isNativeOfflineAudioContext2(nativeContext) ? createAnalyserNodeRenderer2() : null;
        super(context2, false, nativeAnalyserNode, analyserNodeRenderer);
        this._nativeAnalyserNode = nativeAnalyserNode;
      }
      get fftSize() {
        return this._nativeAnalyserNode.fftSize;
      }
      set fftSize(value) {
        this._nativeAnalyserNode.fftSize = value;
      }
      get frequencyBinCount() {
        return this._nativeAnalyserNode.frequencyBinCount;
      }
      get maxDecibels() {
        return this._nativeAnalyserNode.maxDecibels;
      }
      set maxDecibels(value) {
        const maxDecibels = this._nativeAnalyserNode.maxDecibels;
        this._nativeAnalyserNode.maxDecibels = value;
        if (!(value > this._nativeAnalyserNode.minDecibels)) {
          this._nativeAnalyserNode.maxDecibels = maxDecibels;
          throw createIndexSizeError2();
        }
      }
      get minDecibels() {
        return this._nativeAnalyserNode.minDecibels;
      }
      set minDecibels(value) {
        const minDecibels = this._nativeAnalyserNode.minDecibels;
        this._nativeAnalyserNode.minDecibels = value;
        if (!(this._nativeAnalyserNode.maxDecibels > value)) {
          this._nativeAnalyserNode.minDecibels = minDecibels;
          throw createIndexSizeError2();
        }
      }
      get smoothingTimeConstant() {
        return this._nativeAnalyserNode.smoothingTimeConstant;
      }
      set smoothingTimeConstant(value) {
        this._nativeAnalyserNode.smoothingTimeConstant = value;
      }
      getByteFrequencyData(array) {
        this._nativeAnalyserNode.getByteFrequencyData(array);
      }
      getByteTimeDomainData(array) {
        this._nativeAnalyserNode.getByteTimeDomainData(array);
      }
      getFloatFrequencyData(array) {
        this._nativeAnalyserNode.getFloatFrequencyData(array);
      }
      getFloatTimeDomainData(array) {
        this._nativeAnalyserNode.getFloatTimeDomainData(array);
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js
  var isOwnedByContext = (nativeAudioNode, nativeContext) => {
    return nativeAudioNode.context === nativeContext;
  };

  // node_modules/standardized-audio-context/build/es2019/factories/analyser-node-renderer-factory.js
  var createAnalyserNodeRendererFactory = (createNativeAnalyserNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeAnalyserNodes = new WeakMap();
      const createAnalyserNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeAnalyserNode = getNativeAudioNode2(proxy);
        const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);
        if (!nativeAnalyserNodeIsOwnedByContext) {
          const options = {
            channelCount: nativeAnalyserNode.channelCount,
            channelCountMode: nativeAnalyserNode.channelCountMode,
            channelInterpretation: nativeAnalyserNode.channelInterpretation,
            fftSize: nativeAnalyserNode.fftSize,
            maxDecibels: nativeAnalyserNode.maxDecibels,
            minDecibels: nativeAnalyserNode.minDecibels,
            smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant
          };
          nativeAnalyserNode = createNativeAnalyserNode2(nativeOfflineAudioContext, options);
        }
        renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAnalyserNode);
        return nativeAnalyserNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);
          if (renderedNativeAnalyserNode !== void 0) {
            return Promise.resolve(renderedNativeAnalyserNode);
          }
          return createAnalyserNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js
  var testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer) => {
    try {
      nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);
    } catch (e) {
      return false;
    }
    return true;
  };

  // node_modules/standardized-audio-context/build/es2019/factories/index-size-error.js
  var createIndexSizeError = () => new DOMException("", "IndexSizeError");

  // node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-get-channel-data-method.js
  var wrapAudioBufferGetChannelDataMethod = (audioBuffer) => {
    audioBuffer.getChannelData = ((getChannelData) => {
      return (channel) => {
        try {
          return getChannelData.call(audioBuffer, channel);
        } catch (err) {
          if (err.code === 12) {
            throw createIndexSizeError();
          }
          throw err;
        }
      };
    })(audioBuffer.getChannelData);
  };

  // node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-constructor.js
  var DEFAULT_OPTIONS2 = {
    numberOfChannels: 1
  };
  var createAudioBufferConstructor = (audioBufferStore2, cacheTestResult2, createNotSupportedError2, nativeAudioBufferConstructor2, nativeOfflineAudioContextConstructor2, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods2, wrapAudioBufferCopyChannelMethodsOutOfBounds2) => {
    let nativeOfflineAudioContext = null;
    return class AudioBuffer2 {
      constructor(options) {
        if (nativeOfflineAudioContextConstructor2 === null) {
          throw new Error("Missing the native OfflineAudioContext constructor.");
        }
        const { length, numberOfChannels, sampleRate } = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS2), options);
        if (nativeOfflineAudioContext === null) {
          nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);
        }
        const audioBuffer = nativeAudioBufferConstructor2 !== null && cacheTestResult2(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport) ? new nativeAudioBufferConstructor2({ length, numberOfChannels, sampleRate }) : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);
        if (audioBuffer.numberOfChannels === 0) {
          throw createNotSupportedError2();
        }
        if (typeof audioBuffer.copyFromChannel !== "function") {
          wrapAudioBufferCopyChannelMethods2(audioBuffer);
          wrapAudioBufferGetChannelDataMethod(audioBuffer);
        } else if (!cacheTestResult2(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {
          wrapAudioBufferCopyChannelMethodsOutOfBounds2(audioBuffer);
        }
        audioBufferStore2.add(audioBuffer);
        return audioBuffer;
      }
      static [Symbol.hasInstance](instance) {
        return instance !== null && typeof instance === "object" && Object.getPrototypeOf(instance) === AudioBuffer2.prototype || audioBufferStore2.has(instance);
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/constants.js
  var MOST_NEGATIVE_SINGLE_FLOAT = -34028234663852886e22;
  var MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;

  // node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js
  var isActiveAudioNode = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);

  // node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-constructor.js
  var DEFAULT_OPTIONS3 = {
    buffer: null,
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    loop: false,
    loopEnd: 0,
    loopStart: 0,
    playbackRate: 1
  };
  var createAudioBufferSourceNodeConstructor = (audioNodeConstructor2, createAudioBufferSourceNodeRenderer2, createAudioParam2, createInvalidStateError2, createNativeAudioBufferSourceNode2, getNativeContext2, isNativeOfflineAudioContext2, wrapEventListener2) => {
    return class AudioBufferSourceNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS3), options);
        const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const audioBufferSourceNodeRenderer = isOffline ? createAudioBufferSourceNodeRenderer2() : null;
        super(context2, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);
        this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;
        this._isBufferNullified = false;
        this._isBufferSet = mergedOptions.buffer !== null;
        this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;
        this._onended = null;
        this._playbackRate = createAudioParam2(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      }
      get buffer() {
        if (this._isBufferNullified) {
          return null;
        }
        return this._nativeAudioBufferSourceNode.buffer;
      }
      set buffer(value) {
        this._nativeAudioBufferSourceNode.buffer = value;
        if (value !== null) {
          if (this._isBufferSet) {
            throw createInvalidStateError2();
          }
          this._isBufferSet = true;
        }
      }
      get loop() {
        return this._nativeAudioBufferSourceNode.loop;
      }
      set loop(value) {
        this._nativeAudioBufferSourceNode.loop = value;
      }
      get loopEnd() {
        return this._nativeAudioBufferSourceNode.loopEnd;
      }
      set loopEnd(value) {
        this._nativeAudioBufferSourceNode.loopEnd = value;
      }
      get loopStart() {
        return this._nativeAudioBufferSourceNode.loopStart;
      }
      set loopStart(value) {
        this._nativeAudioBufferSourceNode.loopStart = value;
      }
      get onended() {
        return this._onended;
      }
      set onended(value) {
        const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
        this._nativeAudioBufferSourceNode.onended = wrappedListener;
        const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;
        this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
      }
      get playbackRate() {
        return this._playbackRate;
      }
      start(when = 0, offset = 0, duration) {
        this._nativeAudioBufferSourceNode.start(when, offset, duration);
        if (this._audioBufferSourceNodeRenderer !== null) {
          this._audioBufferSourceNodeRenderer.start = duration === void 0 ? [when, offset] : [when, offset, duration];
        }
        if (this.context.state !== "closed") {
          setInternalStateToActive(this);
          const resetInternalStateToPassive = () => {
            this._nativeAudioBufferSourceNode.removeEventListener("ended", resetInternalStateToPassive);
            if (isActiveAudioNode(this)) {
              setInternalStateToPassive(this);
            }
          };
          this._nativeAudioBufferSourceNode.addEventListener("ended", resetInternalStateToPassive);
        }
      }
      stop(when = 0) {
        this._nativeAudioBufferSourceNode.stop(when);
        if (this._audioBufferSourceNodeRenderer !== null) {
          this._audioBufferSourceNodeRenderer.stop = when;
        }
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-renderer-factory.js
  var createAudioBufferSourceNodeRendererFactory = (connectAudioParam2, createNativeAudioBufferSourceNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeAudioBufferSourceNodes = new WeakMap();
      let start2 = null;
      let stop = null;
      const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeAudioBufferSourceNode = getNativeAudioNode2(proxy);
        const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);
        if (!nativeAudioBufferSourceNodeIsOwnedByContext) {
          const options = {
            buffer: nativeAudioBufferSourceNode.buffer,
            channelCount: nativeAudioBufferSourceNode.channelCount,
            channelCountMode: nativeAudioBufferSourceNode.channelCountMode,
            channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,
            loop: nativeAudioBufferSourceNode.loop,
            loopEnd: nativeAudioBufferSourceNode.loopEnd,
            loopStart: nativeAudioBufferSourceNode.loopStart,
            playbackRate: nativeAudioBufferSourceNode.playbackRate.value
          };
          nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, options);
          if (start2 !== null) {
            nativeAudioBufferSourceNode.start(...start2);
          }
          if (stop !== null) {
            nativeAudioBufferSourceNode.stop(stop);
          }
        }
        renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);
        if (!nativeAudioBufferSourceNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);
        return nativeAudioBufferSourceNode;
      };
      return {
        set start(value) {
          start2 = value;
        },
        set stop(value) {
          stop = value;
        },
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);
          if (renderedNativeAudioBufferSourceNode !== void 0) {
            return Promise.resolve(renderedNativeAudioBufferSourceNode);
          }
          return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/guards/audio-buffer-source-node.js
  var isAudioBufferSourceNode = (audioNode) => {
    return "playbackRate" in audioNode;
  };

  // node_modules/standardized-audio-context/build/es2019/guards/biquad-filter-node.js
  var isBiquadFilterNode = (audioNode) => {
    return "frequency" in audioNode && "gain" in audioNode;
  };

  // node_modules/standardized-audio-context/build/es2019/guards/constant-source-node.js
  var isConstantSourceNode = (audioNode) => {
    return "offset" in audioNode;
  };

  // node_modules/standardized-audio-context/build/es2019/guards/gain-node.js
  var isGainNode = (audioNode) => {
    return !("frequency" in audioNode) && "gain" in audioNode;
  };

  // node_modules/standardized-audio-context/build/es2019/guards/oscillator-node.js
  var isOscillatorNode = (audioNode) => {
    return "detune" in audioNode && "frequency" in audioNode;
  };

  // node_modules/standardized-audio-context/build/es2019/guards/stereo-panner-node.js
  var isStereoPannerNode = (audioNode) => {
    return "pan" in audioNode;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/get-audio-node-connections.js
  var getAudioNodeConnections = (audioNode) => {
    return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/get-audio-param-connections.js
  var getAudioParamConnections = (audioParam) => {
    return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/deactivate-active-audio-node-input-connections.js
  var deactivateActiveAudioNodeInputConnections = (audioNode, trace) => {
    const { activeInputs } = getAudioNodeConnections(audioNode);
    activeInputs.forEach((connections) => connections.forEach(([source]) => {
      if (!trace.includes(audioNode)) {
        deactivateActiveAudioNodeInputConnections(source, [...trace, audioNode]);
      }
    }));
    const audioParams = isAudioBufferSourceNode(audioNode) ? [
      audioNode.playbackRate
    ] : isAudioWorkletNode(audioNode) ? Array.from(audioNode.parameters.values()) : isBiquadFilterNode(audioNode) ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain] : isConstantSourceNode(audioNode) ? [audioNode.offset] : isGainNode(audioNode) ? [audioNode.gain] : isOscillatorNode(audioNode) ? [audioNode.detune, audioNode.frequency] : isStereoPannerNode(audioNode) ? [audioNode.pan] : [];
    for (const audioParam of audioParams) {
      const audioParamConnections = getAudioParamConnections(audioParam);
      if (audioParamConnections !== void 0) {
        audioParamConnections.activeInputs.forEach(([source]) => deactivateActiveAudioNodeInputConnections(source, trace));
      }
    }
    if (isActiveAudioNode(audioNode)) {
      setInternalStateToPassive(audioNode);
    }
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/deactivate-audio-graph.js
  var deactivateAudioGraph = (context2) => {
    deactivateActiveAudioNodeInputConnections(context2.destination, []);
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/is-valid-latency-hint.js
  var isValidLatencyHint = (latencyHint) => {
    return latencyHint === void 0 || typeof latencyHint === "number" || typeof latencyHint === "string" && (latencyHint === "balanced" || latencyHint === "interactive" || latencyHint === "playback");
  };

  // node_modules/standardized-audio-context/build/es2019/factories/audio-context-constructor.js
  var createAudioContextConstructor = (baseAudioContextConstructor2, createInvalidStateError2, createNotSupportedError2, createUnknownError2, mediaElementAudioSourceNodeConstructor2, mediaStreamAudioDestinationNodeConstructor2, mediaStreamAudioSourceNodeConstructor2, mediaStreamTrackAudioSourceNodeConstructor2, nativeAudioContextConstructor2) => {
    return class AudioContext extends baseAudioContextConstructor2 {
      constructor(options = {}) {
        if (nativeAudioContextConstructor2 === null) {
          throw new Error("Missing the native AudioContext constructor.");
        }
        let nativeAudioContext;
        try {
          nativeAudioContext = new nativeAudioContextConstructor2(options);
        } catch (err) {
          if (err.code === 12 && err.message === "sampleRate is not in range") {
            throw createNotSupportedError2();
          }
          throw err;
        }
        if (nativeAudioContext === null) {
          throw createUnknownError2();
        }
        if (!isValidLatencyHint(options.latencyHint)) {
          throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
        }
        if (options.sampleRate !== void 0 && nativeAudioContext.sampleRate !== options.sampleRate) {
          throw createNotSupportedError2();
        }
        super(nativeAudioContext, 2);
        const { latencyHint } = options;
        const { sampleRate } = nativeAudioContext;
        this._baseLatency = typeof nativeAudioContext.baseLatency === "number" ? nativeAudioContext.baseLatency : latencyHint === "balanced" ? 512 / sampleRate : latencyHint === "interactive" || latencyHint === void 0 ? 256 / sampleRate : latencyHint === "playback" ? 1024 / sampleRate : Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate;
        this._nativeAudioContext = nativeAudioContext;
        if (nativeAudioContextConstructor2.name === "webkitAudioContext") {
          this._nativeGainNode = nativeAudioContext.createGain();
          this._nativeOscillatorNode = nativeAudioContext.createOscillator();
          this._nativeGainNode.gain.value = 1e-37;
          this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);
          this._nativeOscillatorNode.start();
        } else {
          this._nativeGainNode = null;
          this._nativeOscillatorNode = null;
        }
        this._state = null;
        if (nativeAudioContext.state === "running") {
          this._state = "suspended";
          const revokeState = () => {
            if (this._state === "suspended") {
              this._state = null;
            }
            nativeAudioContext.removeEventListener("statechange", revokeState);
          };
          nativeAudioContext.addEventListener("statechange", revokeState);
        }
      }
      get baseLatency() {
        return this._baseLatency;
      }
      get state() {
        return this._state !== null ? this._state : this._nativeAudioContext.state;
      }
      close() {
        if (this.state === "closed") {
          return this._nativeAudioContext.close().then(() => {
            throw createInvalidStateError2();
          });
        }
        if (this._state === "suspended") {
          this._state = null;
        }
        return this._nativeAudioContext.close().then(() => {
          if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {
            this._nativeOscillatorNode.stop();
            this._nativeGainNode.disconnect();
            this._nativeOscillatorNode.disconnect();
          }
          deactivateAudioGraph(this);
        });
      }
      createMediaElementSource(mediaElement) {
        return new mediaElementAudioSourceNodeConstructor2(this, { mediaElement });
      }
      createMediaStreamDestination() {
        return new mediaStreamAudioDestinationNodeConstructor2(this);
      }
      createMediaStreamSource(mediaStream) {
        return new mediaStreamAudioSourceNodeConstructor2(this, { mediaStream });
      }
      createMediaStreamTrackSource(mediaStreamTrack) {
        return new mediaStreamTrackAudioSourceNodeConstructor2(this, { mediaStreamTrack });
      }
      resume() {
        if (this._state === "suspended") {
          return new Promise((resolve2, reject) => {
            const resolvePromise = () => {
              this._nativeAudioContext.removeEventListener("statechange", resolvePromise);
              if (this._nativeAudioContext.state === "running") {
                resolve2();
              } else {
                this.resume().then(resolve2, reject);
              }
            };
            this._nativeAudioContext.addEventListener("statechange", resolvePromise);
          });
        }
        return this._nativeAudioContext.resume().catch((err) => {
          if (err === void 0 || err.code === 15) {
            throw createInvalidStateError2();
          }
          throw err;
        });
      }
      suspend() {
        return this._nativeAudioContext.suspend().catch((err) => {
          if (err === void 0) {
            throw createInvalidStateError2();
          }
          throw err;
        });
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-constructor.js
  var createAudioDestinationNodeConstructor = (audioNodeConstructor2, createAudioDestinationNodeRenderer2, createIndexSizeError2, createInvalidStateError2, createNativeAudioDestinationNode, getNativeContext2, isNativeOfflineAudioContext2, renderInputsOfAudioNode2) => {
    return class AudioDestinationNode extends audioNodeConstructor2 {
      constructor(context2, channelCount) {
        const nativeContext = getNativeContext2(context2);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);
        const audioDestinationNodeRenderer = isOffline ? createAudioDestinationNodeRenderer2(renderInputsOfAudioNode2) : null;
        super(context2, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);
        this._isNodeOfNativeOfflineAudioContext = isOffline;
        this._nativeAudioDestinationNode = nativeAudioDestinationNode;
      }
      get channelCount() {
        return this._nativeAudioDestinationNode.channelCount;
      }
      set channelCount(value) {
        if (this._isNodeOfNativeOfflineAudioContext) {
          throw createInvalidStateError2();
        }
        if (value > this._nativeAudioDestinationNode.maxChannelCount) {
          throw createIndexSizeError2();
        }
        this._nativeAudioDestinationNode.channelCount = value;
      }
      get channelCountMode() {
        return this._nativeAudioDestinationNode.channelCountMode;
      }
      set channelCountMode(value) {
        if (this._isNodeOfNativeOfflineAudioContext) {
          throw createInvalidStateError2();
        }
        this._nativeAudioDestinationNode.channelCountMode = value;
      }
      get maxChannelCount() {
        return this._nativeAudioDestinationNode.maxChannelCount;
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-renderer-factory.js
  var createAudioDestinationNodeRenderer = (renderInputsOfAudioNode2) => {
    const renderedNativeAudioDestinationNodes = new WeakMap();
    const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext) => {
      const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;
      renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);
      return nativeAudioDestinationNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);
        if (renderedNativeAudioDestinationNode !== void 0) {
          return Promise.resolve(renderedNativeAudioDestinationNode);
        }
        return createAudioDestinationNode(proxy, nativeOfflineAudioContext);
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/audio-listener-factory.js
  var createAudioListenerFactory = (createAudioParam2, createNativeChannelMergerNode2, createNativeConstantSourceNode2, createNativeScriptProcessorNode2, createNotSupportedError2, getFirstSample2, isNativeOfflineAudioContext2, overwriteAccessors2) => {
    return (context2, nativeContext) => {
      const nativeListener = nativeContext.listener;
      const createFakeAudioParams = () => {
        const buffer = new Float32Array(1);
        const channelMergerNode = createNativeChannelMergerNode2(nativeContext, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "speakers",
          numberOfInputs: 9
        });
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        let isScriptProcessorNodeCreated = false;
        let lastOrientation = [0, 0, -1, 0, 1, 0];
        let lastPosition = [0, 0, 0];
        const createScriptProcessorNode = () => {
          if (isScriptProcessorNodeCreated) {
            return;
          }
          isScriptProcessorNodeCreated = true;
          const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, 256, 9, 0);
          scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {
            const orientation = [
              getFirstSample2(inputBuffer, buffer, 0),
              getFirstSample2(inputBuffer, buffer, 1),
              getFirstSample2(inputBuffer, buffer, 2),
              getFirstSample2(inputBuffer, buffer, 3),
              getFirstSample2(inputBuffer, buffer, 4),
              getFirstSample2(inputBuffer, buffer, 5)
            ];
            if (orientation.some((value, index3) => value !== lastOrientation[index3])) {
              nativeListener.setOrientation(...orientation);
              lastOrientation = orientation;
            }
            const positon = [
              getFirstSample2(inputBuffer, buffer, 6),
              getFirstSample2(inputBuffer, buffer, 7),
              getFirstSample2(inputBuffer, buffer, 8)
            ];
            if (positon.some((value, index3) => value !== lastPosition[index3])) {
              nativeListener.setPosition(...positon);
              lastPosition = positon;
            }
          };
          channelMergerNode.connect(scriptProcessorNode);
        };
        const createSetOrientation = (index3) => (value) => {
          if (value !== lastOrientation[index3]) {
            lastOrientation[index3] = value;
            nativeListener.setOrientation(...lastOrientation);
          }
        };
        const createSetPosition = (index3) => (value) => {
          if (value !== lastPosition[index3]) {
            lastPosition[index3] = value;
            nativeListener.setPosition(...lastPosition);
          }
        };
        const createFakeAudioParam = (input2, initialValue, setValue) => {
          const constantSourceNode = createNativeConstantSourceNode2(nativeContext, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "discrete",
            offset: initialValue
          });
          constantSourceNode.connect(channelMergerNode, 0, input2);
          constantSourceNode.start();
          Object.defineProperty(constantSourceNode.offset, "defaultValue", {
            get() {
              return initialValue;
            }
          });
          const audioParam = createAudioParam2({ context: context2 }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
          overwriteAccessors2(audioParam, "value", (get) => () => get.call(audioParam), (set2) => (value) => {
            try {
              set2.call(audioParam, value);
            } catch (err) {
              if (err.code !== 9) {
                throw err;
              }
            }
            createScriptProcessorNode();
            if (isOffline) {
              setValue(value);
            }
          });
          audioParam.cancelAndHoldAtTime = ((cancelAndHoldAtTime) => {
            if (isOffline) {
              return () => {
                throw createNotSupportedError2();
              };
            }
            return (...args) => {
              const value = cancelAndHoldAtTime.apply(audioParam, args);
              createScriptProcessorNode();
              return value;
            };
          })(audioParam.cancelAndHoldAtTime);
          audioParam.cancelScheduledValues = ((cancelScheduledValues) => {
            if (isOffline) {
              return () => {
                throw createNotSupportedError2();
              };
            }
            return (...args) => {
              const value = cancelScheduledValues.apply(audioParam, args);
              createScriptProcessorNode();
              return value;
            };
          })(audioParam.cancelScheduledValues);
          audioParam.exponentialRampToValueAtTime = ((exponentialRampToValueAtTime) => {
            if (isOffline) {
              return () => {
                throw createNotSupportedError2();
              };
            }
            return (...args) => {
              const value = exponentialRampToValueAtTime.apply(audioParam, args);
              createScriptProcessorNode();
              return value;
            };
          })(audioParam.exponentialRampToValueAtTime);
          audioParam.linearRampToValueAtTime = ((linearRampToValueAtTime) => {
            if (isOffline) {
              return () => {
                throw createNotSupportedError2();
              };
            }
            return (...args) => {
              const value = linearRampToValueAtTime.apply(audioParam, args);
              createScriptProcessorNode();
              return value;
            };
          })(audioParam.linearRampToValueAtTime);
          audioParam.setTargetAtTime = ((setTargetAtTime) => {
            if (isOffline) {
              return () => {
                throw createNotSupportedError2();
              };
            }
            return (...args) => {
              const value = setTargetAtTime.apply(audioParam, args);
              createScriptProcessorNode();
              return value;
            };
          })(audioParam.setTargetAtTime);
          audioParam.setValueAtTime = ((setValueAtTime) => {
            if (isOffline) {
              return () => {
                throw createNotSupportedError2();
              };
            }
            return (...args) => {
              const value = setValueAtTime.apply(audioParam, args);
              createScriptProcessorNode();
              return value;
            };
          })(audioParam.setValueAtTime);
          audioParam.setValueCurveAtTime = ((setValueCurveAtTime) => {
            if (isOffline) {
              return () => {
                throw createNotSupportedError2();
              };
            }
            return (...args) => {
              const value = setValueCurveAtTime.apply(audioParam, args);
              createScriptProcessorNode();
              return value;
            };
          })(audioParam.setValueCurveAtTime);
          return audioParam;
        };
        return {
          forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),
          forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),
          forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),
          positionX: createFakeAudioParam(6, 0, createSetPosition(0)),
          positionY: createFakeAudioParam(7, 0, createSetPosition(1)),
          positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),
          upX: createFakeAudioParam(3, 0, createSetOrientation(3)),
          upY: createFakeAudioParam(4, 1, createSetOrientation(4)),
          upZ: createFakeAudioParam(5, 0, createSetOrientation(5))
        };
      };
      const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } = nativeListener.forwardX === void 0 ? createFakeAudioParams() : nativeListener;
      return {
        get forwardX() {
          return forwardX;
        },
        get forwardY() {
          return forwardY;
        },
        get forwardZ() {
          return forwardZ;
        },
        get positionX() {
          return positionX;
        },
        get positionY() {
          return positionY;
        },
        get positionZ() {
          return positionZ;
        },
        get upX() {
          return upX;
        },
        get upY() {
          return upY;
        },
        get upZ() {
          return upZ;
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/guards/audio-node.js
  var isAudioNode = (audioNodeOrAudioParam) => {
    return "context" in audioNodeOrAudioParam;
  };

  // node_modules/standardized-audio-context/build/es2019/guards/audio-node-output-connection.js
  var isAudioNodeOutputConnection = (outputConnection) => {
    return isAudioNode(outputConnection[0]);
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/insert-element-in-set.js
  var insertElementInSet = (set2, element, predicate, ignoreDuplicates) => {
    for (const lmnt of set2) {
      if (predicate(lmnt)) {
        if (ignoreDuplicates) {
          return false;
        }
        throw Error("The set contains at least one similar element.");
      }
    }
    set2.add(element);
    return true;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/add-active-input-connection-to-audio-param.js
  var addActiveInputConnectionToAudioParam = (activeInputs, source, [output, eventListener], ignoreDuplicates) => {
    insertElementInSet(activeInputs, [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/add-passive-input-connection-to-audio-param.js
  var addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output, eventListener], ignoreDuplicates) => {
    const passiveInputConnections = passiveInputs.get(source);
    if (passiveInputConnections === void 0) {
      passiveInputs.set(source, new Set([[output, eventListener]]));
    } else {
      insertElementInSet(passiveInputConnections, [output, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output, ignoreDuplicates);
    }
  };

  // node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js
  var isNativeAudioNodeFaker = (nativeAudioNodeOrNativeAudioNodeFaker) => {
    return "inputs" in nativeAudioNodeOrNativeAudioNodeFaker;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/connect-native-audio-node-to-native-audio-node.js
  var connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input2) => {
    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {
      const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input2];
      nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);
      return [fakeNativeDestinationAudioNode, output, 0];
    }
    nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input2);
    return [nativeDestinationAudioNode, output, input2];
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/delete-active-input-connection.js
  var deleteActiveInputConnection = (activeInputConnections, source, output) => {
    for (const activeInputConnection of activeInputConnections) {
      if (activeInputConnection[0] === source && activeInputConnection[1] === output) {
        activeInputConnections.delete(activeInputConnection);
        return activeInputConnection;
      }
    }
    return null;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/delete-active-input-connection-to-audio-param.js
  var deleteActiveInputConnectionToAudioParam = (activeInputs, source, output) => {
    return pickElementFromSet(activeInputs, (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/delete-event-listeners-of-audio-node.js
  var deleteEventListenerOfAudioNode = (audioNode, eventListener) => {
    const eventListeners = getEventListenersOfAudioNode(audioNode);
    if (!eventListeners.delete(eventListener)) {
      throw new Error("Missing the expected event listener.");
    }
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-param.js
  var deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output) => {
    const passiveInputConnections = getValueForKey(passiveInputs, source);
    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output);
    if (passiveInputConnections.size === 0) {
      passiveInputs.delete(source);
    }
    return matchingConnection;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/disconnect-native-audio-node-from-native-audio-node.js
  var disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input2) => {
    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {
      nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input2], output, 0);
    } else {
      nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input2);
    }
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-node.js
  var getNativeAudioNode = (audioNode) => {
    return getValueForKey(AUDIO_NODE_STORE, audioNode);
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-param.js
  var getNativeAudioParam = (audioParam) => {
    return getValueForKey(AUDIO_PARAM_STORE, audioParam);
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/is-part-of-a-cycle.js
  var isPartOfACycle = (audioNode) => {
    return CYCLE_COUNTERS.has(audioNode);
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/is-passive-audio-node.js
  var isPassiveAudioNode = (audioNode) => {
    return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/test-audio-node-disconnect-method-support.js
  var testAudioNodeDisconnectMethodSupport = (nativeAudioContext, nativeAudioWorkletNodeConstructor2) => {
    return new Promise((resolve2) => {
      if (nativeAudioWorkletNodeConstructor2 !== null) {
        resolve2(true);
      } else {
        const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1);
        const dummy = nativeAudioContext.createGain();
        const ones = nativeAudioContext.createBuffer(1, 2, 44100);
        const channelData = ones.getChannelData(0);
        channelData[0] = 1;
        channelData[1] = 1;
        const source = nativeAudioContext.createBufferSource();
        source.buffer = ones;
        source.loop = true;
        source.connect(analyzer).connect(nativeAudioContext.destination);
        source.connect(dummy);
        source.disconnect(dummy);
        analyzer.onaudioprocess = (event2) => {
          const chnnlDt = event2.inputBuffer.getChannelData(0);
          if (Array.prototype.some.call(chnnlDt, (sample2) => sample2 === 1)) {
            resolve2(true);
          } else {
            resolve2(false);
          }
          source.stop();
          analyzer.onaudioprocess = null;
          source.disconnect(analyzer);
          analyzer.disconnect(nativeAudioContext.destination);
        };
        source.start();
      }
    });
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/visit-each-audio-node-once.js
  var visitEachAudioNodeOnce = (cycles, visitor) => {
    const counts = new Map();
    for (const cycle of cycles) {
      for (const audioNode of cycle) {
        const count = counts.get(audioNode);
        counts.set(audioNode, count === void 0 ? 1 : count + 1);
      }
    }
    counts.forEach((count, audioNode) => visitor(audioNode, count));
  };

  // node_modules/standardized-audio-context/build/es2019/guards/native-audio-node.js
  var isNativeAudioNode = (nativeAudioNodeOrAudioParam) => {
    return "context" in nativeAudioNodeOrAudioParam;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-node-disconnect-method.js
  var wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {
    const connections = new Map();
    nativeAudioNode.connect = ((connect2) => {
      return (destination, output = 0, input2 = 0) => {
        const returnValue = isNativeAudioNode(destination) ? connect2(destination, output, input2) : connect2(destination, output);
        const connectionsToDestination = connections.get(destination);
        if (connectionsToDestination === void 0) {
          connections.set(destination, [{ input: input2, output }]);
        } else {
          if (connectionsToDestination.every((connection) => connection.input !== input2 || connection.output !== output)) {
            connectionsToDestination.push({ input: input2, output });
          }
        }
        return returnValue;
      };
    })(nativeAudioNode.connect.bind(nativeAudioNode));
    nativeAudioNode.disconnect = ((disconnect2) => {
      return (destinationOrOutput, output, input2) => {
        disconnect2.apply(nativeAudioNode);
        if (destinationOrOutput === void 0) {
          connections.clear();
        } else if (typeof destinationOrOutput === "number") {
          for (const [destination, connectionsToDestination] of connections) {
            const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);
            if (filteredConnections.length === 0) {
              connections.delete(destination);
            } else {
              connections.set(destination, filteredConnections);
            }
          }
        } else if (connections.has(destinationOrOutput)) {
          if (output === void 0) {
            connections.delete(destinationOrOutput);
          } else {
            const connectionsToDestination = connections.get(destinationOrOutput);
            if (connectionsToDestination !== void 0) {
              const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== output && (connection.input !== input2 || input2 === void 0));
              if (filteredConnections.length === 0) {
                connections.delete(destinationOrOutput);
              } else {
                connections.set(destinationOrOutput, filteredConnections);
              }
            }
          }
        }
        for (const [destination, connectionsToDestination] of connections) {
          connectionsToDestination.forEach((connection) => {
            if (isNativeAudioNode(destination)) {
              nativeAudioNode.connect(destination, connection.output, connection.input);
            } else {
              nativeAudioNode.connect(destination, connection.output);
            }
          });
        }
      };
    })(nativeAudioNode.disconnect);
  };

  // node_modules/standardized-audio-context/build/es2019/factories/audio-node-constructor.js
  var addConnectionToAudioParamOfAudioContext = (source, destination, output, isOffline) => {
    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);
    const { outputs } = getAudioNodeConnections(source);
    const eventListeners = getEventListenersOfAudioNode(source);
    const eventListener = (isActive) => {
      const nativeAudioNode = getNativeAudioNode(source);
      const nativeAudioParam = getNativeAudioParam(destination);
      if (isActive) {
        const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);
        addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);
        if (!isOffline && !isPartOfACycle(source)) {
          nativeAudioNode.connect(nativeAudioParam, output);
        }
      } else {
        const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);
        addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);
        if (!isOffline && !isPartOfACycle(source)) {
          nativeAudioNode.disconnect(nativeAudioParam, output);
        }
      }
    };
    if (insertElementInSet(outputs, [destination, output], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output, true)) {
      eventListeners.add(eventListener);
      if (isActiveAudioNode(source)) {
        addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);
      } else {
        addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);
      }
      return true;
    }
    return false;
  };
  var deleteInputConnectionOfAudioNode = (source, destination, output, input2) => {
    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);
    const activeInputConnection = deleteActiveInputConnection(activeInputs[input2], source, output);
    if (activeInputConnection === null) {
      const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input2);
      return [passiveInputConnection[2], false];
    }
    return [activeInputConnection[2], true];
  };
  var deleteInputConnectionOfAudioParam = (source, destination, output) => {
    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);
    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);
    if (activeInputConnection === null) {
      const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);
      return [passiveInputConnection[1], false];
    }
    return [activeInputConnection[2], true];
  };
  var deleteInputsOfAudioNode = (source, isOffline, destination, output, input2) => {
    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input2);
    if (listener !== null) {
      deleteEventListenerOfAudioNode(source, listener);
      if (isActive && !isOffline && !isPartOfACycle(source)) {
        disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input2);
      }
    }
    if (isActiveAudioNode(destination)) {
      const { activeInputs } = getAudioNodeConnections(destination);
      setInternalStateToPassiveWhenNecessary(destination, activeInputs);
    }
  };
  var deleteInputsOfAudioParam = (source, isOffline, destination, output) => {
    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);
    if (listener !== null) {
      deleteEventListenerOfAudioNode(source, listener);
      if (isActive && !isOffline && !isPartOfACycle(source)) {
        getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);
      }
    }
  };
  var deleteAnyConnection = (source, isOffline) => {
    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);
    const destinations = [];
    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {
      if (isAudioNodeOutputConnection(outputConnection)) {
        deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
      } else {
        deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
      }
      destinations.push(outputConnection[0]);
    }
    audioNodeConnectionsOfSource.outputs.clear();
    return destinations;
  };
  var deleteConnectionAtOutput = (source, isOffline, output) => {
    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);
    const destinations = [];
    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {
      if (outputConnection[1] === output) {
        if (isAudioNodeOutputConnection(outputConnection)) {
          deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
        } else {
          deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
        }
        destinations.push(outputConnection[0]);
        audioNodeConnectionsOfSource.outputs.delete(outputConnection);
      }
    }
    return destinations;
  };
  var deleteConnectionToDestination = (source, isOffline, destination, output, input2) => {
    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);
    return Array.from(audioNodeConnectionsOfSource.outputs).filter((outputConnection) => outputConnection[0] === destination && (output === void 0 || outputConnection[1] === output) && (input2 === void 0 || outputConnection[2] === input2)).map((outputConnection) => {
      if (isAudioNodeOutputConnection(outputConnection)) {
        deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
      } else {
        deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
      }
      audioNodeConnectionsOfSource.outputs.delete(outputConnection);
      return outputConnection[0];
    });
  };
  var createAudioNodeConstructor = (addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult2, createIncrementCycleCounter, createIndexSizeError2, createInvalidAccessError2, createNotSupportedError2, decrementCycleCounter, detectCycles, eventTargetConstructor2, getNativeContext2, isNativeAudioContext2, isNativeAudioNode3, isNativeAudioParam2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2) => {
    return class AudioNode extends eventTargetConstructor2 {
      constructor(context2, isActive, nativeAudioNode, audioNodeRenderer) {
        super(nativeAudioNode);
        this._context = context2;
        this._nativeAudioNode = nativeAudioNode;
        const nativeContext = getNativeContext2(context2);
        if (isNativeAudioContext2(nativeContext) && cacheTestResult2(testAudioNodeDisconnectMethodSupport, () => {
          return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor2);
        }) !== true) {
          wrapAudioNodeDisconnectMethod(nativeAudioNode);
        }
        AUDIO_NODE_STORE.set(this, nativeAudioNode);
        EVENT_LISTENERS.set(this, new Set());
        if (context2.state !== "closed" && isActive) {
          setInternalStateToActive(this);
        }
        addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);
      }
      get channelCount() {
        return this._nativeAudioNode.channelCount;
      }
      set channelCount(value) {
        this._nativeAudioNode.channelCount = value;
      }
      get channelCountMode() {
        return this._nativeAudioNode.channelCountMode;
      }
      set channelCountMode(value) {
        this._nativeAudioNode.channelCountMode = value;
      }
      get channelInterpretation() {
        return this._nativeAudioNode.channelInterpretation;
      }
      set channelInterpretation(value) {
        this._nativeAudioNode.channelInterpretation = value;
      }
      get context() {
        return this._context;
      }
      get numberOfInputs() {
        return this._nativeAudioNode.numberOfInputs;
      }
      get numberOfOutputs() {
        return this._nativeAudioNode.numberOfOutputs;
      }
      connect(destination, output = 0, input2 = 0) {
        if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {
          throw createIndexSizeError2();
        }
        const nativeContext = getNativeContext2(this._context);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        if (isNativeAudioNode3(destination) || isNativeAudioParam2(destination)) {
          throw createInvalidAccessError2();
        }
        if (isAudioNode(destination)) {
          const nativeDestinationAudioNode = getNativeAudioNode(destination);
          try {
            const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input2);
            const isPassive = isPassiveAudioNode(this);
            if (isOffline || isPassive) {
              this._nativeAudioNode.disconnect(...connection);
            }
            if (this.context.state !== "closed" && !isPassive && isPassiveAudioNode(destination)) {
              setInternalStateToActive(destination);
            }
          } catch (err) {
            if (err.code === 12) {
              throw createInvalidAccessError2();
            }
            throw err;
          }
          const isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input2, isOffline);
          if (isNewConnectionToAudioNode) {
            const cycles = detectCycles([this], destination);
            visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));
          }
          return destination;
        }
        const nativeAudioParam = getNativeAudioParam(destination);
        if (nativeAudioParam.name === "playbackRate" && nativeAudioParam.maxValue === 1024) {
          throw createNotSupportedError2();
        }
        try {
          this._nativeAudioNode.connect(nativeAudioParam, output);
          if (isOffline || isPassiveAudioNode(this)) {
            this._nativeAudioNode.disconnect(nativeAudioParam, output);
          }
        } catch (err) {
          if (err.code === 12) {
            throw createInvalidAccessError2();
          }
          throw err;
        }
        const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);
        if (isNewConnectionToAudioParam) {
          const cycles = detectCycles([this], destination);
          visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));
        }
      }
      disconnect(destinationOrOutput, output, input2) {
        let destinations;
        const nativeContext = getNativeContext2(this._context);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        if (destinationOrOutput === void 0) {
          destinations = deleteAnyConnection(this, isOffline);
        } else if (typeof destinationOrOutput === "number") {
          if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {
            throw createIndexSizeError2();
          }
          destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);
        } else {
          if (output !== void 0 && (output < 0 || output >= this.numberOfOutputs)) {
            throw createIndexSizeError2();
          }
          if (isAudioNode(destinationOrOutput) && input2 !== void 0 && (input2 < 0 || input2 >= destinationOrOutput.numberOfInputs)) {
            throw createIndexSizeError2();
          }
          destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input2);
          if (destinations.length === 0) {
            throw createInvalidAccessError2();
          }
        }
        for (const destination of destinations) {
          const cycles = detectCycles([this], destination);
          visitEachAudioNodeOnce(cycles, decrementCycleCounter);
        }
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/audio-param-factory.js
  var import_automation_events = __toModule(require_bundle());
  var createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore2, audioParamStore, createAudioParamRenderer2, createCancelAndHoldAutomationEvent2, createCancelScheduledValuesAutomationEvent2, createExponentialRampToValueAutomationEvent2, createLinearRampToValueAutomationEvent2, createSetTargetAutomationEvent2, createSetValueAutomationEvent2, createSetValueCurveAutomationEvent2, nativeAudioContextConstructor2, setValueAtTimeUntilPossible2) => {
    return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {
      const defaultValue = nativeAudioParam.value;
      const automationEventList = new import_automation_events.AutomationEventList(defaultValue);
      const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer2(automationEventList) : null;
      const audioParam = {
        get defaultValue() {
          return defaultValue;
        },
        get maxValue() {
          return maxValue === null ? nativeAudioParam.maxValue : maxValue;
        },
        get minValue() {
          return minValue === null ? nativeAudioParam.minValue : minValue;
        },
        get value() {
          return nativeAudioParam.value;
        },
        set value(value) {
          nativeAudioParam.value = value;
          audioParam.setValueAtTime(value, audioNode.context.currentTime);
        },
        cancelAndHoldAtTime(cancelTime) {
          if (typeof nativeAudioParam.cancelAndHoldAtTime === "function") {
            if (audioParamRenderer === null) {
              automationEventList.flush(audioNode.context.currentTime);
            }
            automationEventList.add(createCancelAndHoldAutomationEvent2(cancelTime));
            nativeAudioParam.cancelAndHoldAtTime(cancelTime);
          } else {
            const previousLastEvent = Array.from(automationEventList).pop();
            if (audioParamRenderer === null) {
              automationEventList.flush(audioNode.context.currentTime);
            }
            automationEventList.add(createCancelAndHoldAutomationEvent2(cancelTime));
            const currentLastEvent = Array.from(automationEventList).pop();
            nativeAudioParam.cancelScheduledValues(cancelTime);
            if (previousLastEvent !== currentLastEvent && currentLastEvent !== void 0) {
              if (currentLastEvent.type === "exponentialRampToValue") {
                nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);
              } else if (currentLastEvent.type === "linearRampToValue") {
                nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);
              } else if (currentLastEvent.type === "setValue") {
                nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);
              } else if (currentLastEvent.type === "setValueCurve") {
                nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);
              }
            }
          }
          return audioParam;
        },
        cancelScheduledValues(cancelTime) {
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }
          automationEventList.add(createCancelScheduledValuesAutomationEvent2(cancelTime));
          nativeAudioParam.cancelScheduledValues(cancelTime);
          return audioParam;
        },
        exponentialRampToValueAtTime(value, endTime) {
          if (value === 0) {
            throw new RangeError();
          }
          if (!Number.isFinite(endTime) || endTime < 0) {
            throw new RangeError();
          }
          const currentTime = audioNode.context.currentTime;
          if (audioParamRenderer === null) {
            automationEventList.flush(currentTime);
          }
          if (Array.from(automationEventList).length === 0) {
            automationEventList.add(createSetValueAutomationEvent2(defaultValue, currentTime));
            nativeAudioParam.setValueAtTime(defaultValue, currentTime);
          }
          automationEventList.add(createExponentialRampToValueAutomationEvent2(value, endTime));
          nativeAudioParam.exponentialRampToValueAtTime(value, endTime);
          return audioParam;
        },
        linearRampToValueAtTime(value, endTime) {
          const currentTime = audioNode.context.currentTime;
          if (audioParamRenderer === null) {
            automationEventList.flush(currentTime);
          }
          if (Array.from(automationEventList).length === 0) {
            automationEventList.add(createSetValueAutomationEvent2(defaultValue, currentTime));
            nativeAudioParam.setValueAtTime(defaultValue, currentTime);
          }
          automationEventList.add(createLinearRampToValueAutomationEvent2(value, endTime));
          nativeAudioParam.linearRampToValueAtTime(value, endTime);
          return audioParam;
        },
        setTargetAtTime(target, startTime, timeConstant) {
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }
          automationEventList.add(createSetTargetAutomationEvent2(target, startTime, timeConstant));
          nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);
          return audioParam;
        },
        setValueAtTime(value, startTime) {
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }
          automationEventList.add(createSetValueAutomationEvent2(value, startTime));
          nativeAudioParam.setValueAtTime(value, startTime);
          return audioParam;
        },
        setValueCurveAtTime(values, startTime, duration) {
          const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);
          if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === "webkitAudioContext") {
            const endTime = startTime + duration;
            const sampleRate = audioNode.context.sampleRate;
            const firstSample = Math.ceil(startTime * sampleRate);
            const lastSample = Math.floor(endTime * sampleRate);
            const numberOfInterpolatedValues = lastSample - firstSample;
            const interpolatedValues = new Float32Array(numberOfInterpolatedValues);
            for (let i = 0; i < numberOfInterpolatedValues; i += 1) {
              const theoreticIndex = (convertedValues.length - 1) / duration * ((firstSample + i) / sampleRate - startTime);
              const lowerIndex = Math.floor(theoreticIndex);
              const upperIndex = Math.ceil(theoreticIndex);
              interpolatedValues[i] = lowerIndex === upperIndex ? convertedValues[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];
            }
            if (audioParamRenderer === null) {
              automationEventList.flush(audioNode.context.currentTime);
            }
            automationEventList.add(createSetValueCurveAutomationEvent2(interpolatedValues, startTime, duration));
            nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);
            const timeOfLastSample = lastSample / sampleRate;
            if (timeOfLastSample < endTime) {
              setValueAtTimeUntilPossible2(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);
            }
            setValueAtTimeUntilPossible2(audioParam, convertedValues[convertedValues.length - 1], endTime);
          } else {
            if (audioParamRenderer === null) {
              automationEventList.flush(audioNode.context.currentTime);
            }
            automationEventList.add(createSetValueCurveAutomationEvent2(convertedValues, startTime, duration));
            nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);
          }
          return audioParam;
        }
      };
      audioParamStore.set(audioParam, nativeAudioParam);
      audioParamAudioNodeStore2.set(audioParam, audioNode);
      addAudioParamConnections(audioParam, audioParamRenderer);
      return audioParam;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/audio-param-renderer.js
  var createAudioParamRenderer = (automationEventList) => {
    return {
      replay(audioParam) {
        for (const automationEvent of automationEventList) {
          if (automationEvent.type === "exponentialRampToValue") {
            const { endTime, value } = automationEvent;
            audioParam.exponentialRampToValueAtTime(value, endTime);
          } else if (automationEvent.type === "linearRampToValue") {
            const { endTime, value } = automationEvent;
            audioParam.linearRampToValueAtTime(value, endTime);
          } else if (automationEvent.type === "setTarget") {
            const { startTime, target, timeConstant } = automationEvent;
            audioParam.setTargetAtTime(target, startTime, timeConstant);
          } else if (automationEvent.type === "setValue") {
            const { startTime, value } = automationEvent;
            audioParam.setValueAtTime(value, startTime);
          } else if (automationEvent.type === "setValueCurve") {
            const { duration, startTime, values } = automationEvent;
            audioParam.setValueCurveAtTime(values, startTime, duration);
          } else {
            throw new Error("Can't apply an unknown automation.");
          }
        }
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/read-only-map.js
  var ReadOnlyMap = class {
    constructor(parameters) {
      this._map = new Map(parameters);
    }
    get size() {
      return this._map.size;
    }
    entries() {
      return this._map.entries();
    }
    forEach(callback2, thisArg = null) {
      return this._map.forEach((value, key) => callback2.call(thisArg, value, key, this));
    }
    get(name2) {
      return this._map.get(name2);
    }
    has(name2) {
      return this._map.has(name2);
    }
    keys() {
      return this._map.keys();
    }
    values() {
      return this._map.values();
    }
  };

  // node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-constructor.js
  var DEFAULT_OPTIONS4 = {
    channelCount: 2,
    channelCountMode: "explicit",
    channelInterpretation: "speakers",
    numberOfInputs: 1,
    numberOfOutputs: 1,
    parameterData: {},
    processorOptions: {}
  };
  var createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode2, audioNodeConstructor2, createAudioParam2, createAudioWorkletNodeRenderer2, createNativeAudioWorkletNode2, getAudioNodeConnections2, getBackupOfflineAudioContext2, getNativeContext2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2, sanitizeAudioWorkletNodeOptions2, setActiveAudioWorkletNodeInputs2, testAudioWorkletNodeOptionsClonability2, wrapEventListener2) => {
    return class AudioWorkletNode extends audioNodeConstructor2 {
      constructor(context2, name2, options) {
        var _a3;
        const nativeContext = getNativeContext2(context2);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const mergedOptions = sanitizeAudioWorkletNodeOptions2(__spreadValues(__spreadValues({}, DEFAULT_OPTIONS4), options));
        testAudioWorkletNodeOptionsClonability2(mergedOptions);
        const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);
        const processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name2);
        const nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== "closed" ? nativeContext : (_a3 = getBackupOfflineAudioContext2(nativeContext)) !== null && _a3 !== void 0 ? _a3 : nativeContext;
        const nativeAudioWorkletNode = createNativeAudioWorkletNode2(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context2.baseLatency, nativeAudioWorkletNodeConstructor2, name2, processorConstructor, mergedOptions);
        const audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer2(name2, mergedOptions, processorConstructor) : null;
        super(context2, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);
        const parameters = [];
        nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {
          const audioParam = createAudioParam2(this, isOffline, nativeAudioParam);
          parameters.push([nm, audioParam]);
        });
        this._nativeAudioWorkletNode = nativeAudioWorkletNode;
        this._onprocessorerror = null;
        this._parameters = new ReadOnlyMap(parameters);
        if (isOffline) {
          addUnrenderedAudioWorkletNode2(nativeContext, this);
        }
        const { activeInputs } = getAudioNodeConnections2(this);
        setActiveAudioWorkletNodeInputs2(nativeAudioWorkletNode, activeInputs);
      }
      get onprocessorerror() {
        return this._onprocessorerror;
      }
      set onprocessorerror(value) {
        const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
        this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;
        const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;
        this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;
      }
      get parameters() {
        if (this._parameters === null) {
          return this._nativeAudioWorkletNode.parameters;
        }
        return this._parameters;
      }
      get port() {
        return this._nativeAudioWorkletNode.port;
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/copy-from-channel.js
  function copyFromChannel(audioBuffer, parent, key, channelNumber, bufferOffset) {
    if (typeof audioBuffer.copyFromChannel === "function") {
      if (parent[key].byteLength === 0) {
        parent[key] = new Float32Array(128);
      }
      audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);
    } else {
      const channelData = audioBuffer.getChannelData(channelNumber);
      if (parent[key].byteLength === 0) {
        parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);
      } else {
        const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);
        parent[key].set(slicedInput);
      }
    }
  }

  // node_modules/standardized-audio-context/build/es2019/helpers/copy-to-channel.js
  var copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {
    if (typeof audioBuffer.copyToChannel === "function") {
      if (parent[key].byteLength !== 0) {
        audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);
      }
    } else {
      if (parent[key].byteLength !== 0) {
        audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);
      }
    }
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/create-nested-arrays.js
  var createNestedArrays = (x, y2) => {
    const arrays = [];
    for (let i = 0; i < x; i += 1) {
      const array = [];
      const length = typeof y2 === "number" ? y2 : y2[i];
      for (let j2 = 0; j2 < length; j2 += 1) {
        array.push(new Float32Array(128));
      }
      arrays.push(array);
    }
    return arrays;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/get-audio-worklet-processor.js
  var getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {
    const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);
    const nativeAudioWorkletNode = getNativeAudioNode(proxy);
    return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);
  };

  // node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-renderer-factory.js
  var processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime2) => {
    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;
    const numberOfInputChannels = options.channelCount * options.numberOfInputs;
    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
    const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);
    if (processorConstructor === void 0) {
      throw new Error("Missing the processor constructor.");
    }
    const audioNodeConnections = getAudioNodeConnections(proxy);
    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);
    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);
    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);
    const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name2) => __spreadProps(__spreadValues({}, prmtrs), { [name2]: new Float32Array(128) }), {});
    for (let i = 0; i < length; i += 128) {
      if (options.numberOfInputs > 0 && renderedBuffer !== null) {
        for (let j2 = 0; j2 < options.numberOfInputs; j2 += 1) {
          for (let k = 0; k < options.channelCount; k += 1) {
            copyFromChannel(renderedBuffer, inputs[j2], k, k, i);
          }
        }
      }
      if (processorConstructor.parameterDescriptors !== void 0 && renderedBuffer !== null) {
        processorConstructor.parameterDescriptors.forEach(({ name: name2 }, index3) => {
          copyFromChannel(renderedBuffer, parameters, name2, numberOfInputChannels + index3, i);
        });
      }
      for (let j2 = 0; j2 < options.numberOfInputs; j2 += 1) {
        for (let k = 0; k < outputChannelCount[j2]; k += 1) {
          if (outputs[j2][k].byteLength === 0) {
            outputs[j2][k] = new Float32Array(128);
          }
        }
      }
      try {
        const potentiallyEmptyInputs = inputs.map((input2, index3) => {
          if (audioNodeConnections.activeInputs[index3].size === 0) {
            return [];
          }
          return input2;
        });
        const activeSourceFlag = exposeCurrentFrameAndCurrentTime2(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));
        if (processedBuffer !== null) {
          for (let j2 = 0, outputChannelSplitterNodeOutput = 0; j2 < options.numberOfOutputs; j2 += 1) {
            for (let k = 0; k < outputChannelCount[j2]; k += 1) {
              copyToChannel(processedBuffer, outputs[j2], k, outputChannelSplitterNodeOutput + k, i);
            }
            outputChannelSplitterNodeOutput += outputChannelCount[j2];
          }
        }
        if (!activeSourceFlag) {
          break;
        }
      } catch (error2) {
        proxy.dispatchEvent(new ErrorEvent("processorerror", {
          colno: error2.colno,
          filename: error2.filename,
          lineno: error2.lineno,
          message: error2.message
        }));
        break;
      }
    }
    return processedBuffer;
  };
  var createAudioWorkletNodeRendererFactory = (connectAudioParam2, connectMultipleOutputs2, createNativeAudioBufferSourceNode2, createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeConstantSourceNode2, createNativeGainNode2, deleteUnrenderedAudioWorkletNode2, disconnectMultipleOutputs2, exposeCurrentFrameAndCurrentTime2, getNativeAudioNode2, nativeAudioWorkletNodeConstructor2, nativeOfflineAudioContextConstructor2, renderAutomation2, renderInputsOfAudioNode2, renderNativeOfflineAudioContext2) => {
    return (name2, options, processorConstructor) => {
      const renderedNativeAudioNodes = new WeakMap();
      let processedBufferPromise = null;
      const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeAudioWorkletNode = getNativeAudioNode2(proxy);
        let nativeOutputNodes = null;
        const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);
        const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount);
        if (nativeAudioWorkletNodeConstructor2 === null) {
          const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
          const outputChannelSplitterNode = createNativeChannelSplitterNode2(nativeOfflineAudioContext, {
            channelCount: Math.max(1, numberOfOutputChannels),
            channelCountMode: "explicit",
            channelInterpretation: "discrete",
            numberOfOutputs: Math.max(1, numberOfOutputChannels)
          });
          const outputChannelMergerNodes = [];
          for (let i = 0; i < proxy.numberOfOutputs; i += 1) {
            outputChannelMergerNodes.push(createNativeChannelMergerNode2(nativeOfflineAudioContext, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "speakers",
              numberOfInputs: outputChannelCount[i]
            }));
          }
          const outputGainNode = createNativeGainNode2(nativeOfflineAudioContext, {
            channelCount: options.channelCount,
            channelCountMode: options.channelCountMode,
            channelInterpretation: options.channelInterpretation,
            gain: 1
          });
          outputGainNode.connect = connectMultipleOutputs2.bind(null, outputChannelMergerNodes);
          outputGainNode.disconnect = disconnectMultipleOutputs2.bind(null, outputChannelMergerNodes);
          nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];
        } else if (!nativeAudioWorkletNodeIsOwnedByContext) {
          nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor2(nativeOfflineAudioContext, name2);
        }
        renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);
        if (nativeOutputNodes !== null) {
          if (processedBufferPromise === null) {
            if (processorConstructor === void 0) {
              throw new Error("Missing the processor constructor.");
            }
            if (nativeOfflineAudioContextConstructor2 === null) {
              throw new Error("Missing the native OfflineAudioContext constructor.");
            }
            const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;
            const numberOfParameters = processorConstructor.parameterDescriptors === void 0 ? 0 : processorConstructor.parameterDescriptors.length;
            const numberOfChannels = numberOfInputChannels + numberOfParameters;
            const renderBuffer = async () => {
              const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor2(numberOfChannels, Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);
              const gainNodes = [];
              const inputChannelSplitterNodes = [];
              for (let i = 0; i < options.numberOfInputs; i += 1) {
                gainNodes.push(createNativeGainNode2(partialOfflineAudioContext, {
                  channelCount: options.channelCount,
                  channelCountMode: options.channelCountMode,
                  channelInterpretation: options.channelInterpretation,
                  gain: 1
                }));
                inputChannelSplitterNodes.push(createNativeChannelSplitterNode2(partialOfflineAudioContext, {
                  channelCount: options.channelCount,
                  channelCountMode: "explicit",
                  channelInterpretation: "discrete",
                  numberOfOutputs: options.channelCount
                }));
              }
              const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async (audioParam) => {
                const constantSourceNode = createNativeConstantSourceNode2(partialOfflineAudioContext, {
                  channelCount: 1,
                  channelCountMode: "explicit",
                  channelInterpretation: "discrete",
                  offset: audioParam.value
                });
                await renderAutomation2(partialOfflineAudioContext, audioParam, constantSourceNode.offset);
                return constantSourceNode;
              }));
              const inputChannelMergerNode = createNativeChannelMergerNode2(partialOfflineAudioContext, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "speakers",
                numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)
              });
              for (let i = 0; i < options.numberOfInputs; i += 1) {
                gainNodes[i].connect(inputChannelSplitterNodes[i]);
                for (let j2 = 0; j2 < options.channelCount; j2 += 1) {
                  inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j2, i * options.channelCount + j2);
                }
              }
              for (const [index3, constantSourceNode] of constantSourceNodes.entries()) {
                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index3);
                constantSourceNode.start(0);
              }
              inputChannelMergerNode.connect(partialOfflineAudioContext.destination);
              await Promise.all(gainNodes.map((gainNode) => renderInputsOfAudioNode2(proxy, partialOfflineAudioContext, gainNode)));
              return renderNativeOfflineAudioContext2(partialOfflineAudioContext);
            };
            processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime2);
          }
          const processedBuffer = await processedBufferPromise;
          const audioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, {
            buffer: null,
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            loop: false,
            loopEnd: 0,
            loopStart: 0,
            playbackRate: 1
          });
          const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;
          if (processedBuffer !== null) {
            audioBufferSourceNode.buffer = processedBuffer;
            audioBufferSourceNode.start(0);
          }
          audioBufferSourceNode.connect(outputChannelSplitterNode);
          for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {
            const outputChannelMergerNode = outputChannelMergerNodes[i];
            for (let j2 = 0; j2 < outputChannelCount[i]; j2 += 1) {
              outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j2, j2);
            }
            outputChannelSplitterNodeOutput += outputChannelCount[i];
          }
          return outputGainNode;
        }
        if (!nativeAudioWorkletNodeIsOwnedByContext) {
          for (const [nm, audioParam] of proxy.parameters.entries()) {
            await renderAutomation2(nativeOfflineAudioContext, audioParam, nativeAudioWorkletNode.parameters.get(nm));
          }
        } else {
          for (const [nm, audioParam] of proxy.parameters.entries()) {
            await connectAudioParam2(nativeOfflineAudioContext, audioParam, nativeAudioWorkletNode.parameters.get(nm));
          }
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);
        return nativeAudioWorkletNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          deleteUnrenderedAudioWorkletNode2(nativeOfflineAudioContext, proxy);
          const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
          if (renderedNativeAudioWorkletNodeOrGainNode !== void 0) {
            return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);
          }
          return createAudioNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/base-audio-context-constructor.js
  var createBaseAudioContextConstructor = (addAudioWorkletModule2, analyserNodeConstructor2, audioBufferConstructor2, audioBufferSourceNodeConstructor2, biquadFilterNodeConstructor2, channelMergerNodeConstructor2, channelSplitterNodeConstructor2, constantSourceNodeConstructor2, convolverNodeConstructor2, decodeAudioData2, delayNodeConstructor2, dynamicsCompressorNodeConstructor2, gainNodeConstructor2, iIRFilterNodeConstructor2, minimalBaseAudioContextConstructor2, oscillatorNodeConstructor2, pannerNodeConstructor2, periodicWaveConstructor2, stereoPannerNodeConstructor2, waveShaperNodeConstructor2) => {
    return class BaseAudioContext extends minimalBaseAudioContextConstructor2 {
      constructor(_nativeContext, numberOfChannels) {
        super(_nativeContext, numberOfChannels);
        this._nativeContext = _nativeContext;
        this._audioWorklet = addAudioWorkletModule2 === void 0 ? void 0 : {
          addModule: (moduleURL, options) => {
            return addAudioWorkletModule2(this, moduleURL, options);
          }
        };
      }
      get audioWorklet() {
        return this._audioWorklet;
      }
      createAnalyser() {
        return new analyserNodeConstructor2(this);
      }
      createBiquadFilter() {
        return new biquadFilterNodeConstructor2(this);
      }
      createBuffer(numberOfChannels, length, sampleRate) {
        return new audioBufferConstructor2({ length, numberOfChannels, sampleRate });
      }
      createBufferSource() {
        return new audioBufferSourceNodeConstructor2(this);
      }
      createChannelMerger(numberOfInputs = 6) {
        return new channelMergerNodeConstructor2(this, { numberOfInputs });
      }
      createChannelSplitter(numberOfOutputs = 6) {
        return new channelSplitterNodeConstructor2(this, { numberOfOutputs });
      }
      createConstantSource() {
        return new constantSourceNodeConstructor2(this);
      }
      createConvolver() {
        return new convolverNodeConstructor2(this);
      }
      createDelay(maxDelayTime = 1) {
        return new delayNodeConstructor2(this, { maxDelayTime });
      }
      createDynamicsCompressor() {
        return new dynamicsCompressorNodeConstructor2(this);
      }
      createGain() {
        return new gainNodeConstructor2(this);
      }
      createIIRFilter(feedforward, feedback) {
        return new iIRFilterNodeConstructor2(this, { feedback, feedforward });
      }
      createOscillator() {
        return new oscillatorNodeConstructor2(this);
      }
      createPanner() {
        return new pannerNodeConstructor2(this);
      }
      createPeriodicWave(real, imag, constraints = { disableNormalization: false }) {
        return new periodicWaveConstructor2(this, __spreadProps(__spreadValues({}, constraints), { imag, real }));
      }
      createStereoPanner() {
        return new stereoPannerNodeConstructor2(this);
      }
      createWaveShaper() {
        return new waveShaperNodeConstructor2(this);
      }
      decodeAudioData(audioData, successCallback, errorCallback) {
        return decodeAudioData2(this._nativeContext, audioData).then((audioBuffer) => {
          if (typeof successCallback === "function") {
            successCallback(audioBuffer);
          }
          return audioBuffer;
        }, (err) => {
          if (typeof errorCallback === "function") {
            errorCallback(err);
          }
          throw err;
        });
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-constructor.js
  var DEFAULT_OPTIONS5 = {
    Q: 1,
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    detune: 0,
    frequency: 350,
    gain: 0,
    type: "lowpass"
  };
  var createBiquadFilterNodeConstructor = (audioNodeConstructor2, createAudioParam2, createBiquadFilterNodeRenderer2, createInvalidAccessError2, createNativeBiquadFilterNode2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
    return class BiquadFilterNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS5), options);
        const nativeBiquadFilterNode = createNativeBiquadFilterNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const biquadFilterNodeRenderer = isOffline ? createBiquadFilterNodeRenderer2() : null;
        super(context2, false, nativeBiquadFilterNode, biquadFilterNodeRenderer);
        this._Q = createAudioParam2(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        this._detune = createAudioParam2(this, isOffline, nativeBiquadFilterNode.detune, 1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT), -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT));
        this._frequency = createAudioParam2(this, isOffline, nativeBiquadFilterNode.frequency, context2.sampleRate / 2, 0);
        this._gain = createAudioParam2(this, isOffline, nativeBiquadFilterNode.gain, 40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT), MOST_NEGATIVE_SINGLE_FLOAT);
        this._nativeBiquadFilterNode = nativeBiquadFilterNode;
        setAudioNodeTailTime2(this, 1);
      }
      get detune() {
        return this._detune;
      }
      get frequency() {
        return this._frequency;
      }
      get gain() {
        return this._gain;
      }
      get Q() {
        return this._Q;
      }
      get type() {
        return this._nativeBiquadFilterNode.type;
      }
      set type(value) {
        this._nativeBiquadFilterNode.type = value;
      }
      getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
        try {
          this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
        } catch (err) {
          if (err.code === 11) {
            throw createInvalidAccessError2();
          }
          throw err;
        }
        if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
          throw createInvalidAccessError2();
        }
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-renderer-factory.js
  var createBiquadFilterNodeRendererFactory = (connectAudioParam2, createNativeBiquadFilterNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeBiquadFilterNodes = new WeakMap();
      const createBiquadFilterNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeBiquadFilterNode = getNativeAudioNode2(proxy);
        const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);
        if (!nativeBiquadFilterNodeIsOwnedByContext) {
          const options = {
            Q: nativeBiquadFilterNode.Q.value,
            channelCount: nativeBiquadFilterNode.channelCount,
            channelCountMode: nativeBiquadFilterNode.channelCountMode,
            channelInterpretation: nativeBiquadFilterNode.channelInterpretation,
            detune: nativeBiquadFilterNode.detune.value,
            frequency: nativeBiquadFilterNode.frequency.value,
            gain: nativeBiquadFilterNode.gain.value,
            type: nativeBiquadFilterNode.type
          };
          nativeBiquadFilterNode = createNativeBiquadFilterNode2(nativeOfflineAudioContext, options);
        }
        renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);
        if (!nativeBiquadFilterNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);
          await renderAutomation2(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);
          await renderAutomation2(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);
          await renderAutomation2(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode);
        return nativeBiquadFilterNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);
          if (renderedNativeBiquadFilterNode !== void 0) {
            return Promise.resolve(renderedNativeBiquadFilterNode);
          }
          return createBiquadFilterNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/cache-test-result.js
  var createCacheTestResult = (ongoingTests, testResults) => {
    return (tester, test) => {
      const cachedTestResult = testResults.get(tester);
      if (cachedTestResult !== void 0) {
        return cachedTestResult;
      }
      const ongoingTest = ongoingTests.get(tester);
      if (ongoingTest !== void 0) {
        return ongoingTest;
      }
      try {
        const synchronousTestResult = test();
        if (synchronousTestResult instanceof Promise) {
          ongoingTests.set(tester, synchronousTestResult);
          return synchronousTestResult.catch(() => false).then((finalTestResult) => {
            ongoingTests.delete(tester);
            testResults.set(tester, finalTestResult);
            return finalTestResult;
          });
        }
        testResults.set(tester, synchronousTestResult);
        return synchronousTestResult;
      } catch (e) {
        testResults.set(tester, false);
        return false;
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-constructor.js
  var DEFAULT_OPTIONS6 = {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "speakers",
    numberOfInputs: 6
  };
  var createChannelMergerNodeConstructor = (audioNodeConstructor2, createChannelMergerNodeRenderer2, createNativeChannelMergerNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
    return class ChannelMergerNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS6), options);
        const nativeChannelMergerNode = createNativeChannelMergerNode2(nativeContext, mergedOptions);
        const channelMergerNodeRenderer = isNativeOfflineAudioContext2(nativeContext) ? createChannelMergerNodeRenderer2() : null;
        super(context2, false, nativeChannelMergerNode, channelMergerNodeRenderer);
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-renderer-factory.js
  var createChannelMergerNodeRendererFactory = (createNativeChannelMergerNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeAudioNodes = new WeakMap();
      const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeAudioNode = getNativeAudioNode2(proxy);
        const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);
        if (!nativeAudioNodeIsOwnedByContext) {
          const options = {
            channelCount: nativeAudioNode.channelCount,
            channelCountMode: nativeAudioNode.channelCountMode,
            channelInterpretation: nativeAudioNode.channelInterpretation,
            numberOfInputs: nativeAudioNode.numberOfInputs
          };
          nativeAudioNode = createNativeChannelMergerNode2(nativeOfflineAudioContext, options);
        }
        renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioNode);
        return nativeAudioNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
          if (renderedNativeAudioNode !== void 0) {
            return Promise.resolve(renderedNativeAudioNode);
          }
          return createAudioNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-constructor.js
  var DEFAULT_OPTIONS7 = {
    channelCount: 6,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    numberOfOutputs: 6
  };
  var createChannelSplitterNodeConstructor = (audioNodeConstructor2, createChannelSplitterNodeRenderer2, createNativeChannelSplitterNode2, getNativeContext2, isNativeOfflineAudioContext2, sanitizeChannelSplitterOptions2) => {
    return class ChannelSplitterNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = sanitizeChannelSplitterOptions2(__spreadValues(__spreadValues({}, DEFAULT_OPTIONS7), options));
        const nativeChannelSplitterNode = createNativeChannelSplitterNode2(nativeContext, mergedOptions);
        const channelSplitterNodeRenderer = isNativeOfflineAudioContext2(nativeContext) ? createChannelSplitterNodeRenderer2() : null;
        super(context2, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-renderer-factory.js
  var createChannelSplitterNodeRendererFactory = (createNativeChannelSplitterNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeAudioNodes = new WeakMap();
      const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeAudioNode = getNativeAudioNode2(proxy);
        const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);
        if (!nativeAudioNodeIsOwnedByContext) {
          const options = {
            channelCount: nativeAudioNode.channelCount,
            channelCountMode: nativeAudioNode.channelCountMode,
            channelInterpretation: nativeAudioNode.channelInterpretation,
            numberOfOutputs: nativeAudioNode.numberOfOutputs
          };
          nativeAudioNode = createNativeChannelSplitterNode2(nativeOfflineAudioContext, options);
        }
        renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioNode);
        return nativeAudioNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
          if (renderedNativeAudioNode !== void 0) {
            return Promise.resolve(renderedNativeAudioNode);
          }
          return createAudioNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/connect-audio-param.js
  var createConnectAudioParam = (renderInputsOfAudioParam2) => {
    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {
      return renderInputsOfAudioParam2(audioParam, nativeOfflineAudioContext, nativeAudioParam);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/connect-multiple-outputs.js
  var createConnectMultipleOutputs = (createIndexSizeError2) => {
    return (outputAudioNodes, destination, output = 0, input2 = 0) => {
      const outputAudioNode = outputAudioNodes[output];
      if (outputAudioNode === void 0) {
        throw createIndexSizeError2();
      }
      if (isNativeAudioNode(destination)) {
        return outputAudioNode.connect(destination, 0, input2);
      }
      return outputAudioNode.connect(destination, 0);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/connected-native-audio-buffer-source-node-factory.js
  var createConnectedNativeAudioBufferSourceNodeFactory = (createNativeAudioBufferSourceNode2) => {
    return (nativeContext, nativeAudioNode) => {
      const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, {
        buffer: null,
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers",
        loop: false,
        loopEnd: 0,
        loopStart: 0,
        playbackRate: 1
      });
      const nativeAudioBuffer = nativeContext.createBuffer(1, 2, 44100);
      nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
      nativeAudioBufferSourceNode.loop = true;
      nativeAudioBufferSourceNode.connect(nativeAudioNode);
      nativeAudioBufferSourceNode.start();
      return () => {
        nativeAudioBufferSourceNode.stop();
        nativeAudioBufferSourceNode.disconnect(nativeAudioNode);
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-constructor.js
  var DEFAULT_OPTIONS8 = {
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    offset: 1
  };
  var createConstantSourceNodeConstructor = (audioNodeConstructor2, createAudioParam2, createConstantSourceNodeRendererFactory2, createNativeConstantSourceNode2, getNativeContext2, isNativeOfflineAudioContext2, wrapEventListener2) => {
    return class ConstantSourceNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS8), options);
        const nativeConstantSourceNode = createNativeConstantSourceNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const constantSourceNodeRenderer = isOffline ? createConstantSourceNodeRendererFactory2() : null;
        super(context2, false, nativeConstantSourceNode, constantSourceNodeRenderer);
        this._constantSourceNodeRenderer = constantSourceNodeRenderer;
        this._nativeConstantSourceNode = nativeConstantSourceNode;
        this._offset = createAudioParam2(this, isOffline, nativeConstantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        this._onended = null;
      }
      get offset() {
        return this._offset;
      }
      get onended() {
        return this._onended;
      }
      set onended(value) {
        const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
        this._nativeConstantSourceNode.onended = wrappedListener;
        const nativeOnEnded = this._nativeConstantSourceNode.onended;
        this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
      }
      start(when = 0) {
        this._nativeConstantSourceNode.start(when);
        if (this._constantSourceNodeRenderer !== null) {
          this._constantSourceNodeRenderer.start = when;
        }
        if (this.context.state !== "closed") {
          setInternalStateToActive(this);
          const resetInternalStateToPassive = () => {
            this._nativeConstantSourceNode.removeEventListener("ended", resetInternalStateToPassive);
            if (isActiveAudioNode(this)) {
              setInternalStateToPassive(this);
            }
          };
          this._nativeConstantSourceNode.addEventListener("ended", resetInternalStateToPassive);
        }
      }
      stop(when = 0) {
        this._nativeConstantSourceNode.stop(when);
        if (this._constantSourceNodeRenderer !== null) {
          this._constantSourceNodeRenderer.stop = when;
        }
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-renderer-factory.js
  var createConstantSourceNodeRendererFactory = (connectAudioParam2, createNativeConstantSourceNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeConstantSourceNodes = new WeakMap();
      let start2 = null;
      let stop = null;
      const createConstantSourceNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeConstantSourceNode = getNativeAudioNode2(proxy);
        const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);
        if (!nativeConstantSourceNodeIsOwnedByContext) {
          const options = {
            channelCount: nativeConstantSourceNode.channelCount,
            channelCountMode: nativeConstantSourceNode.channelCountMode,
            channelInterpretation: nativeConstantSourceNode.channelInterpretation,
            offset: nativeConstantSourceNode.offset.value
          };
          nativeConstantSourceNode = createNativeConstantSourceNode2(nativeOfflineAudioContext, options);
          if (start2 !== null) {
            nativeConstantSourceNode.start(start2);
          }
          if (stop !== null) {
            nativeConstantSourceNode.stop(stop);
          }
        }
        renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);
        if (!nativeConstantSourceNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeConstantSourceNode);
        return nativeConstantSourceNode;
      };
      return {
        set start(value) {
          start2 = value;
        },
        set stop(value) {
          stop = value;
        },
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);
          if (renderedNativeConstantSourceNode !== void 0) {
            return Promise.resolve(renderedNativeConstantSourceNode);
          }
          return createConstantSourceNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/convert-number-to-unsigned-long.js
  var createConvertNumberToUnsignedLong = (unit32Array) => {
    return (value) => {
      unit32Array[0] = value;
      return unit32Array[0];
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/convolver-node-constructor.js
  var DEFAULT_OPTIONS9 = {
    buffer: null,
    channelCount: 2,
    channelCountMode: "clamped-max",
    channelInterpretation: "speakers",
    disableNormalization: false
  };
  var createConvolverNodeConstructor = (audioNodeConstructor2, createConvolverNodeRenderer2, createNativeConvolverNode2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
    return class ConvolverNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS9), options);
        const nativeConvolverNode = createNativeConvolverNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const convolverNodeRenderer = isOffline ? createConvolverNodeRenderer2() : null;
        super(context2, false, nativeConvolverNode, convolverNodeRenderer);
        this._isBufferNullified = false;
        this._nativeConvolverNode = nativeConvolverNode;
        if (mergedOptions.buffer !== null) {
          setAudioNodeTailTime2(this, mergedOptions.buffer.duration);
        }
      }
      get buffer() {
        if (this._isBufferNullified) {
          return null;
        }
        return this._nativeConvolverNode.buffer;
      }
      set buffer(value) {
        this._nativeConvolverNode.buffer = value;
        if (value === null && this._nativeConvolverNode.buffer !== null) {
          const nativeContext = this._nativeConvolverNode.context;
          this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);
          this._isBufferNullified = true;
          setAudioNodeTailTime2(this, 0);
        } else {
          this._isBufferNullified = false;
          setAudioNodeTailTime2(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);
        }
      }
      get normalize() {
        return this._nativeConvolverNode.normalize;
      }
      set normalize(value) {
        this._nativeConvolverNode.normalize = value;
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/convolver-node-renderer-factory.js
  var createConvolverNodeRendererFactory = (createNativeConvolverNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeConvolverNodes = new WeakMap();
      const createConvolverNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeConvolverNode = getNativeAudioNode2(proxy);
        const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);
        if (!nativeConvolverNodeIsOwnedByContext) {
          const options = {
            buffer: nativeConvolverNode.buffer,
            channelCount: nativeConvolverNode.channelCount,
            channelCountMode: nativeConvolverNode.channelCountMode,
            channelInterpretation: nativeConvolverNode.channelInterpretation,
            disableNormalization: !nativeConvolverNode.normalize
          };
          nativeConvolverNode = createNativeConvolverNode2(nativeOfflineAudioContext, options);
        }
        renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);
        if (isNativeAudioNodeFaker(nativeConvolverNode)) {
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0]);
        } else {
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeConvolverNode);
        }
        return nativeConvolverNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);
          if (renderedNativeConvolverNode !== void 0) {
            return Promise.resolve(renderedNativeConvolverNode);
          }
          return createConvolverNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/create-native-offline-audio-context.js
  var createCreateNativeOfflineAudioContext = (createNotSupportedError2, nativeOfflineAudioContextConstructor2) => {
    return (numberOfChannels, length, sampleRate) => {
      if (nativeOfflineAudioContextConstructor2 === null) {
        throw new Error("Missing the native OfflineAudioContext constructor.");
      }
      try {
        return new nativeOfflineAudioContextConstructor2(numberOfChannels, length, sampleRate);
      } catch (err) {
        if (err.name === "SyntaxError") {
          throw createNotSupportedError2();
        }
        throw err;
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/data-clone-error.js
  var createDataCloneError = () => new DOMException("", "DataCloneError");

  // node_modules/standardized-audio-context/build/es2019/helpers/detach-array-buffer.js
  var detachArrayBuffer = (arrayBuffer) => {
    const { port1, port2 } = new MessageChannel();
    return new Promise((resolve2) => {
      const closeAndResolve = () => {
        port2.onmessage = null;
        port1.close();
        port2.close();
        resolve2();
      };
      port2.onmessage = () => closeAndResolve();
      try {
        port1.postMessage(arrayBuffer, [arrayBuffer]);
      } catch (e) {
      } finally {
        closeAndResolve();
      }
    });
  };

  // node_modules/standardized-audio-context/build/es2019/factories/decode-audio-data.js
  var createDecodeAudioData = (audioBufferStore2, cacheTestResult2, createDataCloneError2, createEncodingError2, detachedArrayBuffers, getNativeContext2, isNativeContext2, testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, testPromiseSupport2, wrapAudioBufferCopyChannelMethods2, wrapAudioBufferCopyChannelMethodsOutOfBounds2) => {
    return (anyContext, audioData) => {
      const nativeContext = isNativeContext2(anyContext) ? anyContext : getNativeContext2(anyContext);
      if (detachedArrayBuffers.has(audioData)) {
        const err = createDataCloneError2();
        return Promise.reject(err);
      }
      try {
        detachedArrayBuffers.add(audioData);
      } catch (e) {
      }
      if (cacheTestResult2(testPromiseSupport2, () => testPromiseSupport2(nativeContext))) {
        return nativeContext.decodeAudioData(audioData).then((audioBuffer) => {
          detachArrayBuffer(audioData).catch(() => {
          });
          if (!cacheTestResult2(testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport2(audioBuffer))) {
            wrapAudioBufferCopyChannelMethodsOutOfBounds2(audioBuffer);
          }
          audioBufferStore2.add(audioBuffer);
          return audioBuffer;
        });
      }
      return new Promise((resolve2, reject) => {
        const complete = async () => {
          try {
            await detachArrayBuffer(audioData);
          } catch (e) {
          }
        };
        const fail = (err) => {
          reject(err);
          complete();
        };
        try {
          nativeContext.decodeAudioData(audioData, (audioBuffer) => {
            if (typeof audioBuffer.copyFromChannel !== "function") {
              wrapAudioBufferCopyChannelMethods2(audioBuffer);
              wrapAudioBufferGetChannelDataMethod(audioBuffer);
            }
            audioBufferStore2.add(audioBuffer);
            complete().then(() => resolve2(audioBuffer));
          }, (err) => {
            if (err === null) {
              fail(createEncodingError2());
            } else {
              fail(err);
            }
          });
        } catch (err) {
          fail(err);
        }
      });
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/decrement-cycle-counter.js
  var createDecrementCycleCounter = (connectNativeAudioNodeToNativeAudioNode2, cycleCounters, getAudioNodeConnections2, getNativeAudioNode2, getNativeAudioParam2, getNativeContext2, isActiveAudioNode2, isNativeOfflineAudioContext2) => {
    return (audioNode, count) => {
      const cycleCounter = cycleCounters.get(audioNode);
      if (cycleCounter === void 0) {
        throw new Error("Missing the expected cycle count.");
      }
      const nativeContext = getNativeContext2(audioNode.context);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      if (cycleCounter === count) {
        cycleCounters.delete(audioNode);
        if (!isOffline && isActiveAudioNode2(audioNode)) {
          const nativeSourceAudioNode = getNativeAudioNode2(audioNode);
          const { outputs } = getAudioNodeConnections2(audioNode);
          for (const output of outputs) {
            if (isAudioNodeOutputConnection(output)) {
              const nativeDestinationAudioNode = getNativeAudioNode2(output[0]);
              connectNativeAudioNodeToNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);
            } else {
              const nativeDestinationAudioParam = getNativeAudioParam2(output[0]);
              nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);
            }
          }
        }
      } else {
        cycleCounters.set(audioNode, cycleCounter - count);
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/delay-node-constructor.js
  var DEFAULT_OPTIONS10 = {
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    delayTime: 0,
    maxDelayTime: 1
  };
  var createDelayNodeConstructor = (audioNodeConstructor2, createAudioParam2, createDelayNodeRenderer2, createNativeDelayNode2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
    return class DelayNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS10), options);
        const nativeDelayNode = createNativeDelayNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const delayNodeRenderer = isOffline ? createDelayNodeRenderer2(mergedOptions.maxDelayTime) : null;
        super(context2, false, nativeDelayNode, delayNodeRenderer);
        this._delayTime = createAudioParam2(this, isOffline, nativeDelayNode.delayTime);
        setAudioNodeTailTime2(this, mergedOptions.maxDelayTime);
      }
      get delayTime() {
        return this._delayTime;
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/delay-node-renderer-factory.js
  var createDelayNodeRendererFactory = (connectAudioParam2, createNativeDelayNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
    return (maxDelayTime) => {
      const renderedNativeDelayNodes = new WeakMap();
      const createDelayNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeDelayNode = getNativeAudioNode2(proxy);
        const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);
        if (!nativeDelayNodeIsOwnedByContext) {
          const options = {
            channelCount: nativeDelayNode.channelCount,
            channelCountMode: nativeDelayNode.channelCountMode,
            channelInterpretation: nativeDelayNode.channelInterpretation,
            delayTime: nativeDelayNode.delayTime.value,
            maxDelayTime
          };
          nativeDelayNode = createNativeDelayNode2(nativeOfflineAudioContext, options);
        }
        renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);
        if (!nativeDelayNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeDelayNode);
        return nativeDelayNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);
          if (renderedNativeDelayNode !== void 0) {
            return Promise.resolve(renderedNativeDelayNode);
          }
          return createDelayNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/delete-active-input-connection-to-audio-node.js
  var createDeleteActiveInputConnectionToAudioNode = (pickElementFromSet2) => {
    return (activeInputs, source, output, input2) => {
      return pickElementFromSet2(activeInputs[input2], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/delete-unrendered-audio-worklet-node.js
  var createDeleteUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes2) => {
    return (nativeContext, audioWorkletNode) => {
      getUnrenderedAudioWorkletNodes2(nativeContext).delete(audioWorkletNode);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/guards/delay-node.js
  var isDelayNode = (audioNode) => {
    return "delayTime" in audioNode;
  };

  // node_modules/standardized-audio-context/build/es2019/factories/detect-cycles.js
  var createDetectCycles = (audioParamAudioNodeStore2, getAudioNodeConnections2, getValueForKey2) => {
    return function detectCycles(chain, nextLink) {
      const audioNode = isAudioNode(nextLink) ? nextLink : getValueForKey2(audioParamAudioNodeStore2, nextLink);
      if (isDelayNode(audioNode)) {
        return [];
      }
      if (chain[0] === audioNode) {
        return [chain];
      }
      if (chain.includes(audioNode)) {
        return [];
      }
      const { outputs } = getAudioNodeConnections2(audioNode);
      return Array.from(outputs).map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0])).reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/disconnect-multiple-outputs.js
  var getOutputAudioNodeAtIndex = (createIndexSizeError2, outputAudioNodes, output) => {
    const outputAudioNode = outputAudioNodes[output];
    if (outputAudioNode === void 0) {
      throw createIndexSizeError2();
    }
    return outputAudioNode;
  };
  var createDisconnectMultipleOutputs = (createIndexSizeError2) => {
    return (outputAudioNodes, destinationOrOutput = void 0, output = void 0, input2 = 0) => {
      if (destinationOrOutput === void 0) {
        return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect());
      }
      if (typeof destinationOrOutput === "number") {
        return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, destinationOrOutput).disconnect();
      }
      if (isNativeAudioNode(destinationOrOutput)) {
        if (output === void 0) {
          return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));
        }
        if (input2 === void 0) {
          return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output).disconnect(destinationOrOutput, 0);
        }
        return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input2);
      }
      if (output === void 0) {
        return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));
      }
      return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output).disconnect(destinationOrOutput, 0);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-constructor.js
  var DEFAULT_OPTIONS11 = {
    attack: 3e-3,
    channelCount: 2,
    channelCountMode: "clamped-max",
    channelInterpretation: "speakers",
    knee: 30,
    ratio: 12,
    release: 0.25,
    threshold: -24
  };
  var createDynamicsCompressorNodeConstructor = (audioNodeConstructor2, createAudioParam2, createDynamicsCompressorNodeRenderer2, createNativeDynamicsCompressorNode2, createNotSupportedError2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
    return class DynamicsCompressorNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS11), options);
        const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const dynamicsCompressorNodeRenderer = isOffline ? createDynamicsCompressorNodeRenderer2() : null;
        super(context2, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);
        this._attack = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.attack);
        this._knee = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.knee);
        this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;
        this._ratio = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.ratio);
        this._release = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.release);
        this._threshold = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.threshold);
        setAudioNodeTailTime2(this, 6e-3);
      }
      get attack() {
        return this._attack;
      }
      get channelCount() {
        return this._nativeDynamicsCompressorNode.channelCount;
      }
      set channelCount(value) {
        const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;
        this._nativeDynamicsCompressorNode.channelCount = value;
        if (value > 2) {
          this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;
          throw createNotSupportedError2();
        }
      }
      get channelCountMode() {
        return this._nativeDynamicsCompressorNode.channelCountMode;
      }
      set channelCountMode(value) {
        const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;
        this._nativeDynamicsCompressorNode.channelCountMode = value;
        if (value === "max") {
          this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;
          throw createNotSupportedError2();
        }
      }
      get knee() {
        return this._knee;
      }
      get ratio() {
        return this._ratio;
      }
      get reduction() {
        if (typeof this._nativeDynamicsCompressorNode.reduction.value === "number") {
          return this._nativeDynamicsCompressorNode.reduction.value;
        }
        return this._nativeDynamicsCompressorNode.reduction;
      }
      get release() {
        return this._release;
      }
      get threshold() {
        return this._threshold;
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-renderer-factory.js
  var createDynamicsCompressorNodeRendererFactory = (connectAudioParam2, createNativeDynamicsCompressorNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeDynamicsCompressorNodes = new WeakMap();
      const createDynamicsCompressorNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeDynamicsCompressorNode = getNativeAudioNode2(proxy);
        const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);
        if (!nativeDynamicsCompressorNodeIsOwnedByContext) {
          const options = {
            attack: nativeDynamicsCompressorNode.attack.value,
            channelCount: nativeDynamicsCompressorNode.channelCount,
            channelCountMode: nativeDynamicsCompressorNode.channelCountMode,
            channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,
            knee: nativeDynamicsCompressorNode.knee.value,
            ratio: nativeDynamicsCompressorNode.ratio.value,
            release: nativeDynamicsCompressorNode.release.value,
            threshold: nativeDynamicsCompressorNode.threshold.value
          };
          nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode2(nativeOfflineAudioContext, options);
        }
        renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);
        if (!nativeDynamicsCompressorNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);
          await renderAutomation2(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);
          await renderAutomation2(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);
          await renderAutomation2(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);
          await renderAutomation2(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode);
        return nativeDynamicsCompressorNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);
          if (renderedNativeDynamicsCompressorNode !== void 0) {
            return Promise.resolve(renderedNativeDynamicsCompressorNode);
          }
          return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/encoding-error.js
  var createEncodingError = () => new DOMException("", "EncodingError");

  // node_modules/standardized-audio-context/build/es2019/factories/evaluate-source.js
  var createEvaluateSource = (window3) => {
    return (source) => new Promise((resolve2, reject) => {
      if (window3 === null) {
        reject(new SyntaxError());
        return;
      }
      const head = window3.document.head;
      if (head === null) {
        reject(new SyntaxError());
      } else {
        const script = window3.document.createElement("script");
        const blob = new Blob([source], { type: "application/javascript" });
        const url = URL.createObjectURL(blob);
        const originalOnErrorHandler = window3.onerror;
        const removeErrorEventListenerAndRevokeUrl = () => {
          window3.onerror = originalOnErrorHandler;
          URL.revokeObjectURL(url);
        };
        window3.onerror = (message, src, lineno, colno, error2) => {
          if (src === url || src === window3.location.href && lineno === 1 && colno === 1) {
            removeErrorEventListenerAndRevokeUrl();
            reject(error2);
            return false;
          }
          if (originalOnErrorHandler !== null) {
            return originalOnErrorHandler(message, src, lineno, colno, error2);
          }
        };
        script.onerror = () => {
          removeErrorEventListenerAndRevokeUrl();
          reject(new SyntaxError());
        };
        script.onload = () => {
          removeErrorEventListenerAndRevokeUrl();
          resolve2();
        };
        script.src = url;
        script.type = "module";
        head.appendChild(script);
      }
    });
  };

  // node_modules/standardized-audio-context/build/es2019/factories/event-target-constructor.js
  var createEventTargetConstructor = (wrapEventListener2) => {
    return class EventTarget {
      constructor(_nativeEventTarget) {
        this._nativeEventTarget = _nativeEventTarget;
        this._listeners = new WeakMap();
      }
      addEventListener(type, listener, options) {
        if (listener !== null) {
          let wrappedEventListener = this._listeners.get(listener);
          if (wrappedEventListener === void 0) {
            wrappedEventListener = wrapEventListener2(this, listener);
            if (typeof listener === "function") {
              this._listeners.set(listener, wrappedEventListener);
            }
          }
          this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);
        }
      }
      dispatchEvent(event2) {
        return this._nativeEventTarget.dispatchEvent(event2);
      }
      removeEventListener(type, listener, options) {
        const wrappedEventListener = listener === null ? void 0 : this._listeners.get(listener);
        this._nativeEventTarget.removeEventListener(type, wrappedEventListener === void 0 ? null : wrappedEventListener, options);
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/expose-current-frame-and-current-time.js
  var createExposeCurrentFrameAndCurrentTime = (window3) => {
    return (currentTime, sampleRate, fn2) => {
      Object.defineProperties(window3, {
        currentFrame: {
          configurable: true,
          get() {
            return Math.round(currentTime * sampleRate);
          }
        },
        currentTime: {
          configurable: true,
          get() {
            return currentTime;
          }
        }
      });
      try {
        return fn2();
      } finally {
        if (window3 !== null) {
          delete window3.currentFrame;
          delete window3.currentTime;
        }
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/fetch-source.js
  var createFetchSource = (createAbortError2) => {
    return async (url) => {
      try {
        const response = await fetch(url);
        if (response.ok) {
          return [await response.text(), response.url];
        }
      } catch (e) {
      }
      throw createAbortError2();
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/gain-node-constructor.js
  var DEFAULT_OPTIONS12 = {
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    gain: 1
  };
  var createGainNodeConstructor = (audioNodeConstructor2, createAudioParam2, createGainNodeRenderer2, createNativeGainNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
    return class GainNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS12), options);
        const nativeGainNode = createNativeGainNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const gainNodeRenderer = isOffline ? createGainNodeRenderer2() : null;
        super(context2, false, nativeGainNode, gainNodeRenderer);
        this._gain = createAudioParam2(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      }
      get gain() {
        return this._gain;
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/gain-node-renderer-factory.js
  var createGainNodeRendererFactory = (connectAudioParam2, createNativeGainNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeGainNodes = new WeakMap();
      const createGainNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeGainNode = getNativeAudioNode2(proxy);
        const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);
        if (!nativeGainNodeIsOwnedByContext) {
          const options = {
            channelCount: nativeGainNode.channelCount,
            channelCountMode: nativeGainNode.channelCountMode,
            channelInterpretation: nativeGainNode.channelInterpretation,
            gain: nativeGainNode.gain.value
          };
          nativeGainNode = createNativeGainNode2(nativeOfflineAudioContext, options);
        }
        renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);
        if (!nativeGainNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeGainNode);
        return nativeGainNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);
          if (renderedNativeGainNode !== void 0) {
            return Promise.resolve(renderedNativeGainNode);
          }
          return createGainNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/get-active-audio-worklet-node-inputs.js
  var createGetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore2, getValueForKey2) => {
    return (nativeAudioWorkletNode) => getValueForKey2(activeAudioWorkletNodeInputsStore2, nativeAudioWorkletNode);
  };

  // node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-renderer.js
  var createGetAudioNodeRenderer = (getAudioNodeConnections2) => {
    return (audioNode) => {
      const audioNodeConnections = getAudioNodeConnections2(audioNode);
      if (audioNodeConnections.renderer === null) {
        throw new Error("Missing the renderer of the given AudioNode in the audio graph.");
      }
      return audioNodeConnections.renderer;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-tail-time.js
  var createGetAudioNodeTailTime = (audioNodeTailTimeStore2) => {
    return (audioNode) => {
      var _a3;
      return (_a3 = audioNodeTailTimeStore2.get(audioNode)) !== null && _a3 !== void 0 ? _a3 : 0;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/get-audio-param-renderer.js
  var createGetAudioParamRenderer = (getAudioParamConnections2) => {
    return (audioParam) => {
      const audioParamConnections = getAudioParamConnections2(audioParam);
      if (audioParamConnections.renderer === null) {
        throw new Error("Missing the renderer of the given AudioParam in the audio graph.");
      }
      return audioParamConnections.renderer;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/get-backup-offline-audio-context.js
  var createGetBackupOfflineAudioContext = (backupOfflineAudioContextStore2) => {
    return (nativeContext) => {
      return backupOfflineAudioContextStore2.get(nativeContext);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/invalid-state-error.js
  var createInvalidStateError = () => new DOMException("", "InvalidStateError");

  // node_modules/standardized-audio-context/build/es2019/factories/get-native-context.js
  var createGetNativeContext = (contextStore) => {
    return (context2) => {
      const nativeContext = contextStore.get(context2);
      if (nativeContext === void 0) {
        throw createInvalidStateError();
      }
      return nativeContext;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/get-or-create-backup-offline-audio-context.js
  var createGetOrCreateBackupOfflineAudioContext = (backupOfflineAudioContextStore2, nativeOfflineAudioContextConstructor2) => {
    return (nativeContext) => {
      let backupOfflineAudioContext = backupOfflineAudioContextStore2.get(nativeContext);
      if (backupOfflineAudioContext !== void 0) {
        return backupOfflineAudioContext;
      }
      if (nativeOfflineAudioContextConstructor2 === null) {
        throw new Error("Missing the native OfflineAudioContext constructor.");
      }
      backupOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);
      backupOfflineAudioContextStore2.set(nativeContext, backupOfflineAudioContext);
      return backupOfflineAudioContext;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/get-unrendered-audio-worklet-nodes.js
  var createGetUnrenderedAudioWorkletNodes = (unrenderedAudioWorkletNodeStore2) => {
    return (nativeContext) => {
      const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore2.get(nativeContext);
      if (unrenderedAudioWorkletNodes === void 0) {
        throw new Error("The context has no set of AudioWorkletNodes.");
      }
      return unrenderedAudioWorkletNodes;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/invalid-access-error.js
  var createInvalidAccessError = () => new DOMException("", "InvalidAccessError");

  // node_modules/standardized-audio-context/build/es2019/helpers/wrap-iir-filter-node-get-frequency-response-method.js
  var wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode) => {
    nativeIIRFilterNode.getFrequencyResponse = ((getFrequencyResponse) => {
      return (frequencyHz, magResponse, phaseResponse) => {
        if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
          throw createInvalidAccessError();
        }
        return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);
      };
    })(nativeIIRFilterNode.getFrequencyResponse);
  };

  // node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-constructor.js
  var DEFAULT_OPTIONS13 = {
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers"
  };
  var createIIRFilterNodeConstructor = (audioNodeConstructor2, createNativeIIRFilterNode2, createIIRFilterNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
    return class IIRFilterNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const mergedOptions = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS13), options);
        const nativeIIRFilterNode = createNativeIIRFilterNode2(nativeContext, isOffline ? null : context2.baseLatency, mergedOptions);
        const iirFilterNodeRenderer = isOffline ? createIIRFilterNodeRenderer2(mergedOptions.feedback, mergedOptions.feedforward) : null;
        super(context2, false, nativeIIRFilterNode, iirFilterNodeRenderer);
        wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);
        this._nativeIIRFilterNode = nativeIIRFilterNode;
        setAudioNodeTailTime2(this, 1);
      }
      getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
        return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/filter-buffer.js
  var filterBuffer = (feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input2, output) => {
    const inputLength = input2.length;
    let i = bufferIndex;
    for (let j2 = 0; j2 < inputLength; j2 += 1) {
      let y2 = feedforward[0] * input2[j2];
      for (let k = 1; k < minLength; k += 1) {
        const x = i - k & bufferLength - 1;
        y2 += feedforward[k] * xBuffer[x];
        y2 -= feedback[k] * yBuffer[x];
      }
      for (let k = minLength; k < feedforwardLength; k += 1) {
        y2 += feedforward[k] * xBuffer[i - k & bufferLength - 1];
      }
      for (let k = minLength; k < feedbackLength; k += 1) {
        y2 -= feedback[k] * yBuffer[i - k & bufferLength - 1];
      }
      xBuffer[i] = input2[j2];
      yBuffer[i] = y2;
      i = i + 1 & bufferLength - 1;
      output[j2] = y2;
    }
    return i;
  };

  // node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-renderer-factory.js
  var filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {
    const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);
    const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);
    const feedbackLength = convertedFeedback.length;
    const feedforwardLength = convertedFeedforward.length;
    const minLength = Math.min(feedbackLength, feedforwardLength);
    if (convertedFeedback[0] !== 1) {
      for (let i = 0; i < feedbackLength; i += 1) {
        convertedFeedforward[i] /= convertedFeedback[0];
      }
      for (let i = 1; i < feedforwardLength; i += 1) {
        convertedFeedback[i] /= convertedFeedback[0];
      }
    }
    const bufferLength = 32;
    const xBuffer = new Float32Array(bufferLength);
    const yBuffer = new Float32Array(bufferLength);
    const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);
    const numberOfChannels = renderedBuffer.numberOfChannels;
    for (let i = 0; i < numberOfChannels; i += 1) {
      const input2 = renderedBuffer.getChannelData(i);
      const output = filteredBuffer.getChannelData(i);
      xBuffer.fill(0);
      yBuffer.fill(0);
      filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input2, output);
    }
    return filteredBuffer;
  };
  var createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode2, getNativeAudioNode2, nativeOfflineAudioContextConstructor2, renderInputsOfAudioNode2, renderNativeOfflineAudioContext2) => {
    return (feedback, feedforward) => {
      const renderedNativeAudioNodes = new WeakMap();
      let filteredBufferPromise = null;
      const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeAudioBufferSourceNode = null;
        let nativeIIRFilterNode = getNativeAudioNode2(proxy);
        const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);
        if (nativeOfflineAudioContext.createIIRFilter === void 0) {
          nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, {
            buffer: null,
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            loop: false,
            loopEnd: 0,
            loopStart: 0,
            playbackRate: 1
          });
        } else if (!nativeIIRFilterNodeIsOwnedByContext) {
          nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(feedforward, feedback);
        }
        renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);
        if (nativeAudioBufferSourceNode !== null) {
          if (filteredBufferPromise === null) {
            if (nativeOfflineAudioContextConstructor2 === null) {
              throw new Error("Missing the native OfflineAudioContext constructor.");
            }
            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor2(proxy.context.destination.channelCount, proxy.context.length, nativeOfflineAudioContext.sampleRate);
            filteredBufferPromise = (async () => {
              await renderInputsOfAudioNode2(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);
              const renderedBuffer = await renderNativeOfflineAudioContext2(partialOfflineAudioContext);
              return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);
            })();
          }
          const filteredBuffer = await filteredBufferPromise;
          nativeAudioBufferSourceNode.buffer = filteredBuffer;
          nativeAudioBufferSourceNode.start(0);
          return nativeAudioBufferSourceNode;
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);
        return nativeIIRFilterNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
          if (renderedNativeAudioNode !== void 0) {
            return Promise.resolve(renderedNativeAudioNode);
          }
          return createAudioNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/increment-cycle-counter-factory.js
  var createIncrementCycleCounterFactory = (cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode2, getAudioNodeConnections2, getNativeAudioNode2, getNativeAudioParam2, isActiveAudioNode2) => {
    return (isOffline) => {
      return (audioNode, count) => {
        const cycleCounter = cycleCounters.get(audioNode);
        if (cycleCounter === void 0) {
          if (!isOffline && isActiveAudioNode2(audioNode)) {
            const nativeSourceAudioNode = getNativeAudioNode2(audioNode);
            const { outputs } = getAudioNodeConnections2(audioNode);
            for (const output of outputs) {
              if (isAudioNodeOutputConnection(output)) {
                const nativeDestinationAudioNode = getNativeAudioNode2(output[0]);
                disconnectNativeAudioNodeFromNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);
              } else {
                const nativeDestinationAudioParam = getNativeAudioParam2(output[0]);
                nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);
              }
            }
          }
          cycleCounters.set(audioNode, count);
        } else {
          cycleCounters.set(audioNode, cycleCounter + count);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-context.js
  var createIsAnyAudioContext = (contextStore, isNativeAudioContext2) => {
    return (anything) => {
      const nativeContext = contextStore.get(anything);
      return isNativeAudioContext2(nativeContext) || isNativeAudioContext2(anything);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-node.js
  var createIsAnyAudioNode = (audioNodeStore, isNativeAudioNode3) => {
    return (anything) => audioNodeStore.has(anything) || isNativeAudioNode3(anything);
  };

  // node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-param.js
  var createIsAnyAudioParam = (audioParamStore, isNativeAudioParam2) => {
    return (anything) => audioParamStore.has(anything) || isNativeAudioParam2(anything);
  };

  // node_modules/standardized-audio-context/build/es2019/factories/is-any-offline-audio-context.js
  var createIsAnyOfflineAudioContext = (contextStore, isNativeOfflineAudioContext2) => {
    return (anything) => {
      const nativeContext = contextStore.get(anything);
      return isNativeOfflineAudioContext2(nativeContext) || isNativeOfflineAudioContext2(anything);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-context.js
  var createIsNativeAudioContext = (nativeAudioContextConstructor2) => {
    return (anything) => {
      return nativeAudioContextConstructor2 !== null && anything instanceof nativeAudioContextConstructor2;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-node.js
  var createIsNativeAudioNode = (window3) => {
    return (anything) => {
      return window3 !== null && typeof window3.AudioNode === "function" && anything instanceof window3.AudioNode;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-param.js
  var createIsNativeAudioParam = (window3) => {
    return (anything) => {
      return window3 !== null && typeof window3.AudioParam === "function" && anything instanceof window3.AudioParam;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/is-native-context.js
  var createIsNativeContext = (isNativeAudioContext2, isNativeOfflineAudioContext2) => {
    return (anything) => {
      return isNativeAudioContext2(anything) || isNativeOfflineAudioContext2(anything);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/is-native-offline-audio-context.js
  var createIsNativeOfflineAudioContext = (nativeOfflineAudioContextConstructor2) => {
    return (anything) => {
      return nativeOfflineAudioContextConstructor2 !== null && anything instanceof nativeOfflineAudioContextConstructor2;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/is-secure-context.js
  var createIsSecureContext = (window3) => window3 !== null && window3.isSecureContext;

  // node_modules/standardized-audio-context/build/es2019/factories/media-element-audio-source-node-constructor.js
  var createMediaElementAudioSourceNodeConstructor = (audioNodeConstructor2, createNativeMediaElementAudioSourceNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
    return class MediaElementAudioSourceNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode2(nativeContext, options);
        if (isNativeOfflineAudioContext2(nativeContext)) {
          throw TypeError();
        }
        super(context2, true, nativeMediaElementAudioSourceNode, null);
        this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;
      }
      get mediaElement() {
        return this._nativeMediaElementAudioSourceNode.mediaElement;
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-destination-node-constructor.js
  var DEFAULT_OPTIONS14 = {
    channelCount: 2,
    channelCountMode: "explicit",
    channelInterpretation: "speakers"
  };
  var createMediaStreamAudioDestinationNodeConstructor = (audioNodeConstructor2, createNativeMediaStreamAudioDestinationNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
    return class MediaStreamAudioDestinationNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        if (isNativeOfflineAudioContext2(nativeContext)) {
          throw new TypeError();
        }
        const mergedOptions = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS14), options);
        const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode2(nativeContext, mergedOptions);
        super(context2, false, nativeMediaStreamAudioDestinationNode, null);
        this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;
      }
      get stream() {
        return this._nativeMediaStreamAudioDestinationNode.stream;
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-source-node-constructor.js
  var createMediaStreamAudioSourceNodeConstructor = (audioNodeConstructor2, createNativeMediaStreamAudioSourceNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
    return class MediaStreamAudioSourceNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode2(nativeContext, options);
        if (isNativeOfflineAudioContext2(nativeContext)) {
          throw new TypeError();
        }
        super(context2, true, nativeMediaStreamAudioSourceNode, null);
        this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;
      }
      get mediaStream() {
        return this._nativeMediaStreamAudioSourceNode.mediaStream;
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/media-stream-track-audio-source-node-constructor.js
  var createMediaStreamTrackAudioSourceNodeConstructor = (audioNodeConstructor2, createNativeMediaStreamTrackAudioSourceNode2, getNativeContext2) => {
    return class MediaStreamTrackAudioSourceNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode2(nativeContext, options);
        super(context2, true, nativeMediaStreamTrackAudioSourceNode, null);
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/minimal-audio-context-constructor.js
  var createMinimalAudioContextConstructor = (createInvalidStateError2, createNotSupportedError2, createUnknownError2, minimalBaseAudioContextConstructor2, nativeAudioContextConstructor2) => {
    return class MinimalAudioContext extends minimalBaseAudioContextConstructor2 {
      constructor(options = {}) {
        if (nativeAudioContextConstructor2 === null) {
          throw new Error("Missing the native AudioContext constructor.");
        }
        let nativeAudioContext;
        try {
          nativeAudioContext = new nativeAudioContextConstructor2(options);
        } catch (err) {
          if (err.code === 12 && err.message === "sampleRate is not in range") {
            throw createNotSupportedError2();
          }
          throw err;
        }
        if (nativeAudioContext === null) {
          throw createUnknownError2();
        }
        if (!isValidLatencyHint(options.latencyHint)) {
          throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
        }
        if (options.sampleRate !== void 0 && nativeAudioContext.sampleRate !== options.sampleRate) {
          throw createNotSupportedError2();
        }
        super(nativeAudioContext, 2);
        const { latencyHint } = options;
        const { sampleRate } = nativeAudioContext;
        this._baseLatency = typeof nativeAudioContext.baseLatency === "number" ? nativeAudioContext.baseLatency : latencyHint === "balanced" ? 512 / sampleRate : latencyHint === "interactive" || latencyHint === void 0 ? 256 / sampleRate : latencyHint === "playback" ? 1024 / sampleRate : Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate;
        this._nativeAudioContext = nativeAudioContext;
        if (nativeAudioContextConstructor2.name === "webkitAudioContext") {
          this._nativeGainNode = nativeAudioContext.createGain();
          this._nativeOscillatorNode = nativeAudioContext.createOscillator();
          this._nativeGainNode.gain.value = 1e-37;
          this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);
          this._nativeOscillatorNode.start();
        } else {
          this._nativeGainNode = null;
          this._nativeOscillatorNode = null;
        }
        this._state = null;
        if (nativeAudioContext.state === "running") {
          this._state = "suspended";
          const revokeState = () => {
            if (this._state === "suspended") {
              this._state = null;
            }
            nativeAudioContext.removeEventListener("statechange", revokeState);
          };
          nativeAudioContext.addEventListener("statechange", revokeState);
        }
      }
      get baseLatency() {
        return this._baseLatency;
      }
      get state() {
        return this._state !== null ? this._state : this._nativeAudioContext.state;
      }
      close() {
        if (this.state === "closed") {
          return this._nativeAudioContext.close().then(() => {
            throw createInvalidStateError2();
          });
        }
        if (this._state === "suspended") {
          this._state = null;
        }
        return this._nativeAudioContext.close().then(() => {
          if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {
            this._nativeOscillatorNode.stop();
            this._nativeGainNode.disconnect();
            this._nativeOscillatorNode.disconnect();
          }
          deactivateAudioGraph(this);
        });
      }
      resume() {
        if (this._state === "suspended") {
          return new Promise((resolve2, reject) => {
            const resolvePromise = () => {
              this._nativeAudioContext.removeEventListener("statechange", resolvePromise);
              if (this._nativeAudioContext.state === "running") {
                resolve2();
              } else {
                this.resume().then(resolve2, reject);
              }
            };
            this._nativeAudioContext.addEventListener("statechange", resolvePromise);
          });
        }
        return this._nativeAudioContext.resume().catch((err) => {
          if (err === void 0 || err.code === 15) {
            throw createInvalidStateError2();
          }
          throw err;
        });
      }
      suspend() {
        return this._nativeAudioContext.suspend().catch((err) => {
          if (err === void 0) {
            throw createInvalidStateError2();
          }
          throw err;
        });
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/minimal-base-audio-context-constructor.js
  var createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor2, createAudioListener2, eventTargetConstructor2, isNativeOfflineAudioContext2, unrenderedAudioWorkletNodeStore2, wrapEventListener2) => {
    return class MinimalBaseAudioContext extends eventTargetConstructor2 {
      constructor(_nativeContext, numberOfChannels) {
        super(_nativeContext);
        this._nativeContext = _nativeContext;
        CONTEXT_STORE.set(this, _nativeContext);
        if (isNativeOfflineAudioContext2(_nativeContext)) {
          unrenderedAudioWorkletNodeStore2.set(_nativeContext, new Set());
        }
        this._destination = new audioDestinationNodeConstructor2(this, numberOfChannels);
        this._listener = createAudioListener2(this, _nativeContext);
        this._onstatechange = null;
      }
      get currentTime() {
        return this._nativeContext.currentTime;
      }
      get destination() {
        return this._destination;
      }
      get listener() {
        return this._listener;
      }
      get onstatechange() {
        return this._onstatechange;
      }
      set onstatechange(value) {
        const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
        this._nativeContext.onstatechange = wrappedListener;
        const nativeOnStateChange = this._nativeContext.onstatechange;
        this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;
      }
      get sampleRate() {
        return this._nativeContext.sampleRate;
      }
      get state() {
        return this._nativeContext.state;
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/test-promise-support.js
  var testPromiseSupport = (nativeContext) => {
    const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
    try {
      const promise = nativeContext.decodeAudioData(uint32Array.buffer, () => {
      });
      if (promise === void 0) {
        return false;
      }
      promise.catch(() => {
      });
      return true;
    } catch (e) {
    }
    return false;
  };

  // node_modules/standardized-audio-context/build/es2019/factories/minimal-offline-audio-context-constructor.js
  var DEFAULT_OPTIONS15 = {
    numberOfChannels: 1
  };
  var createMinimalOfflineAudioContextConstructor = (cacheTestResult2, createInvalidStateError2, createNativeOfflineAudioContext2, minimalBaseAudioContextConstructor2, startRendering2) => {
    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor2 {
      constructor(options) {
        const { length, numberOfChannels, sampleRate } = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS15), options);
        const nativeOfflineAudioContext = createNativeOfflineAudioContext2(numberOfChannels, length, sampleRate);
        if (!cacheTestResult2(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {
          nativeOfflineAudioContext.addEventListener("statechange", (() => {
            let i = 0;
            const delayStateChangeEvent = (event2) => {
              if (this._state === "running") {
                if (i > 0) {
                  nativeOfflineAudioContext.removeEventListener("statechange", delayStateChangeEvent);
                  event2.stopImmediatePropagation();
                  this._waitForThePromiseToSettle(event2);
                } else {
                  i += 1;
                }
              }
            };
            return delayStateChangeEvent;
          })());
        }
        super(nativeOfflineAudioContext, numberOfChannels);
        this._length = length;
        this._nativeOfflineAudioContext = nativeOfflineAudioContext;
        this._state = null;
      }
      get length() {
        if (this._nativeOfflineAudioContext.length === void 0) {
          return this._length;
        }
        return this._nativeOfflineAudioContext.length;
      }
      get state() {
        return this._state === null ? this._nativeOfflineAudioContext.state : this._state;
      }
      startRendering() {
        if (this._state === "running") {
          return Promise.reject(createInvalidStateError2());
        }
        this._state = "running";
        return startRendering2(this.destination, this._nativeOfflineAudioContext).finally(() => {
          this._state = null;
          deactivateAudioGraph(this);
        });
      }
      _waitForThePromiseToSettle(event2) {
        if (this._state === null) {
          this._nativeOfflineAudioContext.dispatchEvent(event2);
        } else {
          setTimeout(() => this._waitForThePromiseToSettle(event2));
        }
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/monitor-connections.js
  var createMonitorConnections = (insertElementInSet2, isNativeAudioNode3) => {
    return (nativeAudioNode, whenConnected, whenDisconnected) => {
      const connections = new Set();
      nativeAudioNode.connect = ((connect2) => {
        return (destination, output = 0, input2 = 0) => {
          const wasDisconnected = connections.size === 0;
          if (isNativeAudioNode3(destination)) {
            connect2.call(nativeAudioNode, destination, output, input2);
            insertElementInSet2(connections, [destination, output, input2], (connection) => connection[0] === destination && connection[1] === output && connection[2] === input2, true);
            if (wasDisconnected) {
              whenConnected();
            }
            return destination;
          }
          connect2.call(nativeAudioNode, destination, output);
          insertElementInSet2(connections, [destination, output], (connection) => connection[0] === destination && connection[1] === output, true);
          if (wasDisconnected) {
            whenConnected();
          }
          return;
        };
      })(nativeAudioNode.connect);
      nativeAudioNode.disconnect = ((disconnect2) => {
        return (destinationOrOutput, output, input2) => {
          const wasConnected = connections.size > 0;
          if (destinationOrOutput === void 0) {
            disconnect2.apply(nativeAudioNode);
            connections.clear();
          } else if (typeof destinationOrOutput === "number") {
            disconnect2.call(nativeAudioNode, destinationOrOutput);
            for (const connection of connections) {
              if (connection[1] === destinationOrOutput) {
                connections.delete(connection);
              }
            }
          } else {
            if (isNativeAudioNode3(destinationOrOutput)) {
              disconnect2.call(nativeAudioNode, destinationOrOutput, output, input2);
            } else {
              disconnect2.call(nativeAudioNode, destinationOrOutput, output);
            }
            for (const connection of connections) {
              if (connection[0] === destinationOrOutput && (output === void 0 || connection[1] === output) && (input2 === void 0 || connection[2] === input2)) {
                connections.delete(connection);
              }
            }
          }
          const isDisconnected = connections.size === 0;
          if (wasConnected && isDisconnected) {
            whenDisconnected();
          }
        };
      })(nativeAudioNode.disconnect);
      return nativeAudioNode;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js
  var assignNativeAudioNodeOption = (nativeAudioNode, options, option2) => {
    const value = options[option2];
    if (value !== void 0 && value !== nativeAudioNode[option2]) {
      nativeAudioNode[option2] = value;
    }
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js
  var assignNativeAudioNodeOptions = (nativeAudioNode, options) => {
    assignNativeAudioNodeOption(nativeAudioNode, options, "channelCount");
    assignNativeAudioNodeOption(nativeAudioNode, options, "channelCountMode");
    assignNativeAudioNodeOption(nativeAudioNode, options, "channelInterpretation");
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/test-analyser-node-get-float-time-domain-data-method-support.js
  var testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode) => {
    return typeof nativeAnalyserNode.getFloatTimeDomainData === "function";
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/wrap-analyser-node-get-float-time-domain-data-method.js
  var wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode) => {
    nativeAnalyserNode.getFloatTimeDomainData = (array) => {
      const byteTimeDomainData = new Uint8Array(array.length);
      nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);
      const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);
      for (let i = 0; i < length; i += 1) {
        array[i] = (byteTimeDomainData[i] - 128) * 78125e-7;
      }
      return array;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-analyser-node-factory.js
  var createNativeAnalyserNodeFactory = (cacheTestResult2, createIndexSizeError2) => {
    return (nativeContext, options) => {
      const nativeAnalyserNode = nativeContext.createAnalyser();
      assignNativeAudioNodeOptions(nativeAnalyserNode, options);
      if (!(options.maxDecibels > options.minDecibels)) {
        throw createIndexSizeError2();
      }
      assignNativeAudioNodeOption(nativeAnalyserNode, options, "fftSize");
      assignNativeAudioNodeOption(nativeAnalyserNode, options, "maxDecibels");
      assignNativeAudioNodeOption(nativeAnalyserNode, options, "minDecibels");
      assignNativeAudioNodeOption(nativeAnalyserNode, options, "smoothingTimeConstant");
      if (!cacheTestResult2(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () => testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode))) {
        wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);
      }
      return nativeAnalyserNode;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-constructor.js
  var createNativeAudioBufferConstructor = (window3) => {
    if (window3 === null) {
      return null;
    }
    if (window3.hasOwnProperty("AudioBuffer")) {
      return window3.AudioBuffer;
    }
    return null;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js
  var assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options, audioParam) => {
    const value = options[audioParam];
    if (value !== void 0 && value !== nativeAudioNode[audioParam].value) {
      nativeAudioNode[audioParam].value = value;
    }
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js
  var wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode) => {
    nativeAudioBufferSourceNode.start = ((start2) => {
      let isScheduled = false;
      return (when = 0, offset = 0, duration) => {
        if (isScheduled) {
          throw createInvalidStateError();
        }
        start2.call(nativeAudioBufferSourceNode, when, offset, duration);
        isScheduled = true;
      };
    })(nativeAudioBufferSourceNode.start);
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js
  var wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {
    nativeAudioScheduledSourceNode.start = ((start2) => {
      return (when = 0, offset = 0, duration) => {
        if (typeof duration === "number" && duration < 0 || offset < 0 || when < 0) {
          throw new RangeError("The parameters can't be negative.");
        }
        start2.call(nativeAudioScheduledSourceNode, when, offset, duration);
      };
    })(nativeAudioScheduledSourceNode.start);
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js
  var wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {
    nativeAudioScheduledSourceNode.stop = ((stop) => {
      return (when = 0) => {
        if (when < 0) {
          throw new RangeError("The parameter can't be negative.");
        }
        stop.call(nativeAudioScheduledSourceNode, when);
      };
    })(nativeAudioScheduledSourceNode.stop);
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-source-node-factory.js
  var createNativeAudioBufferSourceNodeFactory = (addSilentConnection2, cacheTestResult2, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2, testAudioBufferSourceNodeStartMethodOffsetClampingSupport2, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2) => {
    return (nativeContext, options) => {
      const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
      assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);
      assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, "playbackRate");
      assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, "buffer");
      assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, "loop");
      assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, "loopEnd");
      assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, "loopStart");
      if (!cacheTestResult2(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2(nativeContext))) {
        wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);
      }
      if (!cacheTestResult2(testAudioBufferSourceNodeStartMethodOffsetClampingSupport2, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport2(nativeContext))) {
        wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);
      }
      if (!cacheTestResult2(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2(nativeContext))) {
        wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);
      }
      if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {
        wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);
      }
      if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2(nativeContext))) {
        wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2(nativeAudioBufferSourceNode, nativeContext);
      }
      if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {
        wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);
      }
      addSilentConnection2(nativeContext, nativeAudioBufferSourceNode);
      return nativeAudioBufferSourceNode;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-audio-context-constructor.js
  var createNativeAudioContextConstructor = (window3) => {
    if (window3 === null) {
      return null;
    }
    if (window3.hasOwnProperty("AudioContext")) {
      return window3.AudioContext;
    }
    return window3.hasOwnProperty("webkitAudioContext") ? window3.webkitAudioContext : null;
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-audio-destination-node.js
  var createNativeAudioDestinationNodeFactory = (createNativeGainNode2, overwriteAccessors2) => {
    return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {
      const nativeAudioDestinationNode = nativeContext.destination;
      if (nativeAudioDestinationNode.channelCount !== channelCount) {
        try {
          nativeAudioDestinationNode.channelCount = channelCount;
        } catch (e) {
        }
      }
      if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== "explicit") {
        nativeAudioDestinationNode.channelCountMode = "explicit";
      }
      if (nativeAudioDestinationNode.maxChannelCount === 0) {
        Object.defineProperty(nativeAudioDestinationNode, "maxChannelCount", {
          value: channelCount
        });
      }
      const gainNode = createNativeGainNode2(nativeContext, {
        channelCount,
        channelCountMode: nativeAudioDestinationNode.channelCountMode,
        channelInterpretation: nativeAudioDestinationNode.channelInterpretation,
        gain: 1
      });
      overwriteAccessors2(gainNode, "channelCount", (get) => () => get.call(gainNode), (set2) => (value) => {
        set2.call(gainNode, value);
        try {
          nativeAudioDestinationNode.channelCount = value;
        } catch (err) {
          if (value > nativeAudioDestinationNode.maxChannelCount) {
            throw err;
          }
        }
      });
      overwriteAccessors2(gainNode, "channelCountMode", (get) => () => get.call(gainNode), (set2) => (value) => {
        set2.call(gainNode, value);
        nativeAudioDestinationNode.channelCountMode = value;
      });
      overwriteAccessors2(gainNode, "channelInterpretation", (get) => () => get.call(gainNode), (set2) => (value) => {
        set2.call(gainNode, value);
        nativeAudioDestinationNode.channelInterpretation = value;
      });
      Object.defineProperty(gainNode, "maxChannelCount", {
        get: () => nativeAudioDestinationNode.maxChannelCount
      });
      gainNode.connect(nativeAudioDestinationNode);
      return gainNode;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-constructor.js
  var createNativeAudioWorkletNodeConstructor = (window3) => {
    if (window3 === null) {
      return null;
    }
    return window3.hasOwnProperty("AudioWorkletNode") ? window3.AudioWorkletNode : null;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/test-clonability-of-audio-worklet-node-options.js
  var testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {
    const { port1 } = new MessageChannel();
    try {
      port1.postMessage(audioWorkletNodeOptions);
    } finally {
      port1.close();
    }
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-factory.js
  var createNativeAudioWorkletNodeFactory = (createInvalidStateError2, createNativeAudioWorkletNodeFaker2, createNativeGainNode2, createNotSupportedError2, monitorConnections2) => {
    return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor2, name2, processorConstructor, options) => {
      if (nativeAudioWorkletNodeConstructor2 !== null) {
        try {
          const nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor2(nativeContext, name2, options);
          const patchedEventListeners = new Map();
          let onprocessorerror = null;
          Object.defineProperties(nativeAudioWorkletNode, {
            channelCount: {
              get: () => options.channelCount,
              set: () => {
                throw createInvalidStateError2();
              }
            },
            channelCountMode: {
              get: () => "explicit",
              set: () => {
                throw createInvalidStateError2();
              }
            },
            onprocessorerror: {
              get: () => onprocessorerror,
              set: (value) => {
                if (typeof onprocessorerror === "function") {
                  nativeAudioWorkletNode.removeEventListener("processorerror", onprocessorerror);
                }
                onprocessorerror = typeof value === "function" ? value : null;
                if (typeof onprocessorerror === "function") {
                  nativeAudioWorkletNode.addEventListener("processorerror", onprocessorerror);
                }
              }
            }
          });
          nativeAudioWorkletNode.addEventListener = ((addEventListener) => {
            return (...args) => {
              if (args[0] === "processorerror") {
                const unpatchedEventListener = typeof args[1] === "function" ? args[1] : typeof args[1] === "object" && args[1] !== null && typeof args[1].handleEvent === "function" ? args[1].handleEvent : null;
                if (unpatchedEventListener !== null) {
                  const patchedEventListener = patchedEventListeners.get(args[1]);
                  if (patchedEventListener !== void 0) {
                    args[1] = patchedEventListener;
                  } else {
                    args[1] = (event2) => {
                      if (event2.type === "error") {
                        Object.defineProperties(event2, {
                          type: { value: "processorerror" }
                        });
                        unpatchedEventListener(event2);
                      } else {
                        unpatchedEventListener(new ErrorEvent(args[0], __spreadValues({}, event2)));
                      }
                    };
                    patchedEventListeners.set(unpatchedEventListener, args[1]);
                  }
                }
              }
              addEventListener.call(nativeAudioWorkletNode, "error", args[1], args[2]);
              return addEventListener.call(nativeAudioWorkletNode, ...args);
            };
          })(nativeAudioWorkletNode.addEventListener);
          nativeAudioWorkletNode.removeEventListener = ((removeEventListener) => {
            return (...args) => {
              if (args[0] === "processorerror") {
                const patchedEventListener = patchedEventListeners.get(args[1]);
                if (patchedEventListener !== void 0) {
                  patchedEventListeners.delete(args[1]);
                  args[1] = patchedEventListener;
                }
              }
              removeEventListener.call(nativeAudioWorkletNode, "error", args[1], args[2]);
              return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);
            };
          })(nativeAudioWorkletNode.removeEventListener);
          if (options.numberOfOutputs !== 0) {
            const nativeGainNode = createNativeGainNode2(nativeContext, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              gain: 0
            });
            nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);
            const whenConnected = () => nativeGainNode.disconnect();
            const whenDisconnected = () => nativeGainNode.connect(nativeContext.destination);
            return monitorConnections2(nativeAudioWorkletNode, whenConnected, whenDisconnected);
          }
          return nativeAudioWorkletNode;
        } catch (err) {
          if (err.code === 11) {
            throw createNotSupportedError2();
          }
          throw err;
        }
      }
      if (processorConstructor === void 0) {
        throw createNotSupportedError2();
      }
      testClonabilityOfAudioWorkletNodeOptions(options);
      return createNativeAudioWorkletNodeFaker2(nativeContext, baseLatency, processorConstructor, options);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/compute-buffer-size.js
  var computeBufferSize = (baseLatency, sampleRate) => {
    if (baseLatency === null) {
      return 512;
    }
    return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/clone-audio-worklet-node-options.js
  var cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {
    return new Promise((resolve2, reject) => {
      const { port1, port2 } = new MessageChannel();
      port1.onmessage = ({ data }) => {
        port1.close();
        port2.close();
        resolve2(data);
      };
      port1.onmessageerror = ({ data }) => {
        port1.close();
        port2.close();
        reject(data);
      };
      port2.postMessage(audioWorkletNodeOptions);
    });
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor-promise.js
  var createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {
    const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);
    return new processorConstructor(clonedAudioWorkletNodeOptions);
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor.js
  var createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {
    let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);
    if (nodeToProcessorMap === void 0) {
      nodeToProcessorMap = new WeakMap();
      NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);
    }
    const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);
    nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);
    return audioWorkletProcessorPromise;
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-faker-factory.js
  var createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs2, createIndexSizeError2, createInvalidStateError2, createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeConstantSourceNode2, createNativeGainNode2, createNativeScriptProcessorNode2, createNotSupportedError2, disconnectMultipleOutputs2, exposeCurrentFrameAndCurrentTime2, getActiveAudioWorkletNodeInputs2, monitorConnections2) => {
    return (nativeContext, baseLatency, processorConstructor, options) => {
      if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {
        throw createNotSupportedError2();
      }
      const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount);
      if (outputChannelCount.some((channelCount) => channelCount < 1)) {
        throw createNotSupportedError2();
      }
      if (outputChannelCount.length !== options.numberOfOutputs) {
        throw createIndexSizeError2();
      }
      if (options.channelCountMode !== "explicit") {
        throw createNotSupportedError2();
      }
      const numberOfInputChannels = options.channelCount * options.numberOfInputs;
      const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
      const numberOfParameters = processorConstructor.parameterDescriptors === void 0 ? 0 : processorConstructor.parameterDescriptors.length;
      if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {
        throw createNotSupportedError2();
      }
      const messageChannel = new MessageChannel();
      const gainNodes = [];
      const inputChannelSplitterNodes = [];
      for (let i = 0; i < options.numberOfInputs; i += 1) {
        gainNodes.push(createNativeGainNode2(nativeContext, {
          channelCount: options.channelCount,
          channelCountMode: options.channelCountMode,
          channelInterpretation: options.channelInterpretation,
          gain: 1
        }));
        inputChannelSplitterNodes.push(createNativeChannelSplitterNode2(nativeContext, {
          channelCount: options.channelCount,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          numberOfOutputs: options.channelCount
        }));
      }
      const constantSourceNodes = [];
      if (processorConstructor.parameterDescriptors !== void 0) {
        for (const { defaultValue, maxValue, minValue, name: name2 } of processorConstructor.parameterDescriptors) {
          const constantSourceNode = createNativeConstantSourceNode2(nativeContext, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "discrete",
            offset: options.parameterData[name2] !== void 0 ? options.parameterData[name2] : defaultValue === void 0 ? 0 : defaultValue
          });
          Object.defineProperties(constantSourceNode.offset, {
            defaultValue: {
              get: () => defaultValue === void 0 ? 0 : defaultValue
            },
            maxValue: {
              get: () => maxValue === void 0 ? MOST_POSITIVE_SINGLE_FLOAT : maxValue
            },
            minValue: {
              get: () => minValue === void 0 ? MOST_NEGATIVE_SINGLE_FLOAT : minValue
            }
          });
          constantSourceNodes.push(constantSourceNode);
        }
      }
      const inputChannelMergerNode = createNativeChannelMergerNode2(nativeContext, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "speakers",
        numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)
      });
      const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);
      const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, Math.max(1, numberOfOutputChannels));
      const outputChannelSplitterNode = createNativeChannelSplitterNode2(nativeContext, {
        channelCount: Math.max(1, numberOfOutputChannels),
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        numberOfOutputs: Math.max(1, numberOfOutputChannels)
      });
      const outputChannelMergerNodes = [];
      for (let i = 0; i < options.numberOfOutputs; i += 1) {
        outputChannelMergerNodes.push(createNativeChannelMergerNode2(nativeContext, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "speakers",
          numberOfInputs: outputChannelCount[i]
        }));
      }
      for (let i = 0; i < options.numberOfInputs; i += 1) {
        gainNodes[i].connect(inputChannelSplitterNodes[i]);
        for (let j2 = 0; j2 < options.channelCount; j2 += 1) {
          inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j2, i * options.channelCount + j2);
        }
      }
      const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === void 0 ? [] : processorConstructor.parameterDescriptors.map(({ name: name2 }, index3) => {
        const constantSourceNode = constantSourceNodes[index3];
        constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index3);
        constantSourceNode.start(0);
        return [name2, constantSourceNode.offset];
      }));
      inputChannelMergerNode.connect(scriptProcessorNode);
      let channelInterpretation = options.channelInterpretation;
      let onprocessorerror = null;
      const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;
      const nativeAudioWorkletNodeFaker = {
        get bufferSize() {
          return bufferSize;
        },
        get channelCount() {
          return options.channelCount;
        },
        set channelCount(_) {
          throw createInvalidStateError2();
        },
        get channelCountMode() {
          return options.channelCountMode;
        },
        set channelCountMode(_) {
          throw createInvalidStateError2();
        },
        get channelInterpretation() {
          return channelInterpretation;
        },
        set channelInterpretation(value) {
          for (const gainNode of gainNodes) {
            gainNode.channelInterpretation = value;
          }
          channelInterpretation = value;
        },
        get context() {
          return scriptProcessorNode.context;
        },
        get inputs() {
          return gainNodes;
        },
        get numberOfInputs() {
          return options.numberOfInputs;
        },
        get numberOfOutputs() {
          return options.numberOfOutputs;
        },
        get onprocessorerror() {
          return onprocessorerror;
        },
        set onprocessorerror(value) {
          if (typeof onprocessorerror === "function") {
            nativeAudioWorkletNodeFaker.removeEventListener("processorerror", onprocessorerror);
          }
          onprocessorerror = typeof value === "function" ? value : null;
          if (typeof onprocessorerror === "function") {
            nativeAudioWorkletNodeFaker.addEventListener("processorerror", onprocessorerror);
          }
        },
        get parameters() {
          return parameterMap;
        },
        get port() {
          return messageChannel.port2;
        },
        addEventListener(...args) {
          return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);
        },
        connect: connectMultipleOutputs2.bind(null, outputAudioNodes),
        disconnect: disconnectMultipleOutputs2.bind(null, outputAudioNodes),
        dispatchEvent(...args) {
          return scriptProcessorNode.dispatchEvent(args[0]);
        },
        removeEventListener(...args) {
          return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);
        }
      };
      const patchedEventListeners = new Map();
      messageChannel.port1.addEventListener = ((addEventListener) => {
        return (...args) => {
          if (args[0] === "message") {
            const unpatchedEventListener = typeof args[1] === "function" ? args[1] : typeof args[1] === "object" && args[1] !== null && typeof args[1].handleEvent === "function" ? args[1].handleEvent : null;
            if (unpatchedEventListener !== null) {
              const patchedEventListener = patchedEventListeners.get(args[1]);
              if (patchedEventListener !== void 0) {
                args[1] = patchedEventListener;
              } else {
                args[1] = (event2) => {
                  exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event2));
                };
                patchedEventListeners.set(unpatchedEventListener, args[1]);
              }
            }
          }
          return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);
        };
      })(messageChannel.port1.addEventListener);
      messageChannel.port1.removeEventListener = ((removeEventListener) => {
        return (...args) => {
          if (args[0] === "message") {
            const patchedEventListener = patchedEventListeners.get(args[1]);
            if (patchedEventListener !== void 0) {
              patchedEventListeners.delete(args[1]);
              args[1] = patchedEventListener;
            }
          }
          return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);
        };
      })(messageChannel.port1.removeEventListener);
      let onmessage = null;
      Object.defineProperty(messageChannel.port1, "onmessage", {
        get: () => onmessage,
        set: (value) => {
          if (typeof onmessage === "function") {
            messageChannel.port1.removeEventListener("message", onmessage);
          }
          onmessage = typeof value === "function" ? value : null;
          if (typeof onmessage === "function") {
            messageChannel.port1.addEventListener("message", onmessage);
            messageChannel.port1.start();
          }
        }
      });
      processorConstructor.prototype.port = messageChannel.port1;
      let audioWorkletProcessor = null;
      const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);
      audioWorkletProcessorPromise.then((dWrkltPrcssr) => audioWorkletProcessor = dWrkltPrcssr);
      const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);
      const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);
      const parameters = processorConstructor.parameterDescriptors === void 0 ? [] : processorConstructor.parameterDescriptors.reduce((prmtrs, { name: name2 }) => __spreadProps(__spreadValues({}, prmtrs), { [name2]: new Float32Array(128) }), {});
      let isActive = true;
      const disconnectOutputsGraph = () => {
        if (options.numberOfOutputs > 0) {
          scriptProcessorNode.disconnect(outputChannelSplitterNode);
        }
        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {
          const outputChannelMergerNode = outputChannelMergerNodes[i];
          for (let j2 = 0; j2 < outputChannelCount[i]; j2 += 1) {
            outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j2, j2);
          }
          outputChannelSplitterNodeOutput += outputChannelCount[i];
        }
      };
      const activeInputIndexes = new Map();
      scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {
        if (audioWorkletProcessor !== null) {
          const activeInputs = getActiveAudioWorkletNodeInputs2(nativeAudioWorkletNodeFaker);
          for (let i = 0; i < bufferSize; i += 128) {
            for (let j2 = 0; j2 < options.numberOfInputs; j2 += 1) {
              for (let k = 0; k < options.channelCount; k += 1) {
                copyFromChannel(inputBuffer, inputs[j2], k, k, i);
              }
            }
            if (processorConstructor.parameterDescriptors !== void 0) {
              processorConstructor.parameterDescriptors.forEach(({ name: name2 }, index3) => {
                copyFromChannel(inputBuffer, parameters, name2, numberOfInputChannels + index3, i);
              });
            }
            for (let j2 = 0; j2 < options.numberOfInputs; j2 += 1) {
              for (let k = 0; k < outputChannelCount[j2]; k += 1) {
                if (outputs[j2][k].byteLength === 0) {
                  outputs[j2][k] = new Float32Array(128);
                }
              }
            }
            try {
              const potentiallyEmptyInputs = inputs.map((input2, index3) => {
                const activeInput = activeInputs[index3];
                if (activeInput.size > 0) {
                  activeInputIndexes.set(index3, bufferSize / 128);
                  return input2;
                }
                const count = activeInputIndexes.get(index3);
                if (count === void 0) {
                  return [];
                }
                if (input2.every((channelData) => channelData.every((sample2) => sample2 === 0))) {
                  if (count === 1) {
                    activeInputIndexes.delete(index3);
                  } else {
                    activeInputIndexes.set(index3, count - 1);
                  }
                }
                return input2;
              });
              const activeSourceFlag = exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));
              isActive = activeSourceFlag;
              for (let j2 = 0, outputChannelSplitterNodeOutput = 0; j2 < options.numberOfOutputs; j2 += 1) {
                for (let k = 0; k < outputChannelCount[j2]; k += 1) {
                  copyToChannel(outputBuffer, outputs[j2], k, outputChannelSplitterNodeOutput + k, i);
                }
                outputChannelSplitterNodeOutput += outputChannelCount[j2];
              }
            } catch (error2) {
              isActive = false;
              nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent("processorerror", {
                colno: error2.colno,
                filename: error2.filename,
                lineno: error2.lineno,
                message: error2.message
              }));
            }
            if (!isActive) {
              for (let j2 = 0; j2 < options.numberOfInputs; j2 += 1) {
                gainNodes[j2].disconnect(inputChannelSplitterNodes[j2]);
                for (let k = 0; k < options.channelCount; k += 1) {
                  inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j2 * options.channelCount + k);
                }
              }
              if (processorConstructor.parameterDescriptors !== void 0) {
                const length = processorConstructor.parameterDescriptors.length;
                for (let j2 = 0; j2 < length; j2 += 1) {
                  const constantSourceNode = constantSourceNodes[j2];
                  constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j2);
                  constantSourceNode.stop();
                }
              }
              inputChannelMergerNode.disconnect(scriptProcessorNode);
              scriptProcessorNode.onaudioprocess = null;
              if (isConnected) {
                disconnectOutputsGraph();
              } else {
                disconnectFakeGraph();
              }
              break;
            }
          }
        }
      };
      let isConnected = false;
      const nativeGainNode = createNativeGainNode2(nativeContext, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        gain: 0
      });
      const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);
      const disconnectFakeGraph = () => {
        scriptProcessorNode.disconnect(nativeGainNode);
        nativeGainNode.disconnect();
      };
      const whenConnected = () => {
        if (isActive) {
          disconnectFakeGraph();
          if (options.numberOfOutputs > 0) {
            scriptProcessorNode.connect(outputChannelSplitterNode);
          }
          for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {
            const outputChannelMergerNode = outputChannelMergerNodes[i];
            for (let j2 = 0; j2 < outputChannelCount[i]; j2 += 1) {
              outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j2, j2);
            }
            outputChannelSplitterNodeOutput += outputChannelCount[i];
          }
        }
        isConnected = true;
      };
      const whenDisconnected = () => {
        if (isActive) {
          connectFakeGraph();
          disconnectOutputsGraph();
        }
        isConnected = false;
      };
      connectFakeGraph();
      return monitorConnections2(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-biquad-filter-node.js
  var createNativeBiquadFilterNode = (nativeContext, options) => {
    const nativeBiquadFilterNode = nativeContext.createBiquadFilter();
    assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);
    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, "Q");
    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, "detune");
    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, "frequency");
    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, "gain");
    assignNativeAudioNodeOption(nativeBiquadFilterNode, options, "type");
    return nativeBiquadFilterNode;
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-channel-merger-node-factory.js
  var createNativeChannelMergerNodeFactory = (nativeAudioContextConstructor2, wrapChannelMergerNode2) => {
    return (nativeContext, options) => {
      const nativeChannelMergerNode = nativeContext.createChannelMerger(options.numberOfInputs);
      if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === "webkitAudioContext") {
        wrapChannelMergerNode2(nativeContext, nativeChannelMergerNode);
      }
      assignNativeAudioNodeOptions(nativeChannelMergerNode, options);
      return nativeChannelMergerNode;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/wrap-channel-splitter-node.js
  var wrapChannelSplitterNode = (channelSplitterNode) => {
    const channelCount = channelSplitterNode.numberOfOutputs;
    Object.defineProperty(channelSplitterNode, "channelCount", {
      get: () => channelCount,
      set: (value) => {
        if (value !== channelCount) {
          throw createInvalidStateError();
        }
      }
    });
    Object.defineProperty(channelSplitterNode, "channelCountMode", {
      get: () => "explicit",
      set: (value) => {
        if (value !== "explicit") {
          throw createInvalidStateError();
        }
      }
    });
    Object.defineProperty(channelSplitterNode, "channelInterpretation", {
      get: () => "discrete",
      set: (value) => {
        if (value !== "discrete") {
          throw createInvalidStateError();
        }
      }
    });
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-channel-splitter-node.js
  var createNativeChannelSplitterNode = (nativeContext, options) => {
    const nativeChannelSplitterNode = nativeContext.createChannelSplitter(options.numberOfOutputs);
    assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);
    wrapChannelSplitterNode(nativeChannelSplitterNode);
    return nativeChannelSplitterNode;
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-factory.js
  var createNativeConstantSourceNodeFactory = (addSilentConnection2, cacheTestResult2, createNativeConstantSourceNodeFaker2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2) => {
    return (nativeContext, options) => {
      if (nativeContext.createConstantSource === void 0) {
        return createNativeConstantSourceNodeFaker2(nativeContext, options);
      }
      const nativeConstantSourceNode = nativeContext.createConstantSource();
      assignNativeAudioNodeOptions(nativeConstantSourceNode, options);
      assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, "offset");
      if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {
        wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);
      }
      if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {
        wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);
      }
      addSilentConnection2(nativeContext, nativeConstantSourceNode);
      return nativeConstantSourceNode;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js
  var interceptConnections = (original, interceptor) => {
    original.connect = interceptor.connect.bind(interceptor);
    original.disconnect = interceptor.disconnect.bind(interceptor);
    return original;
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-faker-factory.js
  var createNativeConstantSourceNodeFakerFactory = (addSilentConnection2, createNativeAudioBufferSourceNode2, createNativeGainNode2, monitorConnections2) => {
    return (nativeContext, _a3) => {
      var _b = _a3, { offset } = _b, audioNodeOptions = __objRest(_b, ["offset"]);
      const audioBuffer = nativeContext.createBuffer(1, 2, 44100);
      const audioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, {
        buffer: null,
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers",
        loop: false,
        loopEnd: 0,
        loopStart: 0,
        playbackRate: 1
      });
      const gainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, audioNodeOptions), { gain: offset }));
      const channelData = audioBuffer.getChannelData(0);
      channelData[0] = 1;
      channelData[1] = 1;
      audioBufferSourceNode.buffer = audioBuffer;
      audioBufferSourceNode.loop = true;
      const nativeConstantSourceNodeFaker = {
        get bufferSize() {
          return void 0;
        },
        get channelCount() {
          return gainNode.channelCount;
        },
        set channelCount(value) {
          gainNode.channelCount = value;
        },
        get channelCountMode() {
          return gainNode.channelCountMode;
        },
        set channelCountMode(value) {
          gainNode.channelCountMode = value;
        },
        get channelInterpretation() {
          return gainNode.channelInterpretation;
        },
        set channelInterpretation(value) {
          gainNode.channelInterpretation = value;
        },
        get context() {
          return gainNode.context;
        },
        get inputs() {
          return [];
        },
        get numberOfInputs() {
          return audioBufferSourceNode.numberOfInputs;
        },
        get numberOfOutputs() {
          return gainNode.numberOfOutputs;
        },
        get offset() {
          return gainNode.gain;
        },
        get onended() {
          return audioBufferSourceNode.onended;
        },
        set onended(value) {
          audioBufferSourceNode.onended = value;
        },
        addEventListener(...args) {
          return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);
        },
        dispatchEvent(...args) {
          return audioBufferSourceNode.dispatchEvent(args[0]);
        },
        removeEventListener(...args) {
          return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);
        },
        start(when = 0) {
          audioBufferSourceNode.start.call(audioBufferSourceNode, when);
        },
        stop(when = 0) {
          audioBufferSourceNode.stop.call(audioBufferSourceNode, when);
        }
      };
      const whenConnected = () => audioBufferSourceNode.connect(gainNode);
      const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);
      addSilentConnection2(nativeContext, audioBufferSourceNode);
      return monitorConnections2(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-convolver-node-factory.js
  var createNativeConvolverNodeFactory = (createNotSupportedError2, overwriteAccessors2) => {
    return (nativeContext, options) => {
      const nativeConvolverNode = nativeContext.createConvolver();
      assignNativeAudioNodeOptions(nativeConvolverNode, options);
      if (options.disableNormalization === nativeConvolverNode.normalize) {
        nativeConvolverNode.normalize = !options.disableNormalization;
      }
      assignNativeAudioNodeOption(nativeConvolverNode, options, "buffer");
      if (options.channelCount > 2) {
        throw createNotSupportedError2();
      }
      overwriteAccessors2(nativeConvolverNode, "channelCount", (get) => () => get.call(nativeConvolverNode), (set2) => (value) => {
        if (value > 2) {
          throw createNotSupportedError2();
        }
        return set2.call(nativeConvolverNode, value);
      });
      if (options.channelCountMode === "max") {
        throw createNotSupportedError2();
      }
      overwriteAccessors2(nativeConvolverNode, "channelCountMode", (get) => () => get.call(nativeConvolverNode), (set2) => (value) => {
        if (value === "max") {
          throw createNotSupportedError2();
        }
        return set2.call(nativeConvolverNode, value);
      });
      return nativeConvolverNode;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-delay-node.js
  var createNativeDelayNode = (nativeContext, options) => {
    const nativeDelayNode = nativeContext.createDelay(options.maxDelayTime);
    assignNativeAudioNodeOptions(nativeDelayNode, options);
    assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, "delayTime");
    return nativeDelayNode;
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-dynamics-compressor-node-factory.js
  var createNativeDynamicsCompressorNodeFactory = (createNotSupportedError2) => {
    return (nativeContext, options) => {
      const nativeDynamicsCompressorNode = nativeContext.createDynamicsCompressor();
      assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options);
      if (options.channelCount > 2) {
        throw createNotSupportedError2();
      }
      if (options.channelCountMode === "max") {
        throw createNotSupportedError2();
      }
      assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, "attack");
      assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, "knee");
      assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, "ratio");
      assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, "release");
      assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, "threshold");
      return nativeDynamicsCompressorNode;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-gain-node.js
  var createNativeGainNode = (nativeContext, options) => {
    const nativeGainNode = nativeContext.createGain();
    assignNativeAudioNodeOptions(nativeGainNode, options);
    assignNativeAudioNodeAudioParamValue(nativeGainNode, options, "gain");
    return nativeGainNode;
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-factory.js
  var createNativeIIRFilterNodeFactory = (createNativeIIRFilterNodeFaker2) => {
    return (nativeContext, baseLatency, options) => {
      if (nativeContext.createIIRFilter === void 0) {
        return createNativeIIRFilterNodeFaker2(nativeContext, baseLatency, options);
      }
      const nativeIIRFilterNode = nativeContext.createIIRFilter(options.feedforward, options.feedback);
      assignNativeAudioNodeOptions(nativeIIRFilterNode, options);
      return nativeIIRFilterNode;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-faker-factory.js
  function divide(a, b) {
    const denominator = b[0] * b[0] + b[1] * b[1];
    return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];
  }
  function multiply(a, b) {
    return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];
  }
  function evaluatePolynomial(coefficient, z2) {
    let result = [0, 0];
    for (let i = coefficient.length - 1; i >= 0; i -= 1) {
      result = multiply(result, z2);
      result[0] += coefficient[i];
    }
    return result;
  }
  var createNativeIIRFilterNodeFakerFactory = (createInvalidAccessError2, createInvalidStateError2, createNativeScriptProcessorNode2, createNotSupportedError2) => {
    return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {
      const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);
      const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);
      const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);
      const feedbackLength = convertedFeedback.length;
      const feedforwardLength = convertedFeedforward.length;
      const minLength = Math.min(feedbackLength, feedforwardLength);
      if (feedbackLength === 0 || feedbackLength > 20) {
        throw createNotSupportedError2();
      }
      if (convertedFeedback[0] === 0) {
        throw createInvalidStateError2();
      }
      if (feedforwardLength === 0 || feedforwardLength > 20) {
        throw createNotSupportedError2();
      }
      if (convertedFeedforward[0] === 0) {
        throw createInvalidStateError2();
      }
      if (convertedFeedback[0] !== 1) {
        for (let i = 0; i < feedforwardLength; i += 1) {
          convertedFeedforward[i] /= convertedFeedback[0];
        }
        for (let i = 1; i < feedbackLength; i += 1) {
          convertedFeedback[i] /= convertedFeedback[0];
        }
      }
      const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, bufferSize, channelCount, channelCount);
      scriptProcessorNode.channelCount = channelCount;
      scriptProcessorNode.channelCountMode = channelCountMode;
      scriptProcessorNode.channelInterpretation = channelInterpretation;
      const bufferLength = 32;
      const bufferIndexes = [];
      const xBuffers = [];
      const yBuffers = [];
      for (let i = 0; i < channelCount; i += 1) {
        bufferIndexes.push(0);
        const xBuffer = new Float32Array(bufferLength);
        const yBuffer = new Float32Array(bufferLength);
        xBuffer.fill(0);
        yBuffer.fill(0);
        xBuffers.push(xBuffer);
        yBuffers.push(yBuffer);
      }
      scriptProcessorNode.onaudioprocess = (event2) => {
        const inputBuffer = event2.inputBuffer;
        const outputBuffer = event2.outputBuffer;
        const numberOfChannels = inputBuffer.numberOfChannels;
        for (let i = 0; i < numberOfChannels; i += 1) {
          const input2 = inputBuffer.getChannelData(i);
          const output = outputBuffer.getChannelData(i);
          bufferIndexes[i] = filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffers[i], yBuffers[i], bufferIndexes[i], bufferLength, input2, output);
        }
      };
      const nyquist = nativeContext.sampleRate / 2;
      const nativeIIRFilterNodeFaker = {
        get bufferSize() {
          return bufferSize;
        },
        get channelCount() {
          return scriptProcessorNode.channelCount;
        },
        set channelCount(value) {
          scriptProcessorNode.channelCount = value;
        },
        get channelCountMode() {
          return scriptProcessorNode.channelCountMode;
        },
        set channelCountMode(value) {
          scriptProcessorNode.channelCountMode = value;
        },
        get channelInterpretation() {
          return scriptProcessorNode.channelInterpretation;
        },
        set channelInterpretation(value) {
          scriptProcessorNode.channelInterpretation = value;
        },
        get context() {
          return scriptProcessorNode.context;
        },
        get inputs() {
          return [scriptProcessorNode];
        },
        get numberOfInputs() {
          return scriptProcessorNode.numberOfInputs;
        },
        get numberOfOutputs() {
          return scriptProcessorNode.numberOfOutputs;
        },
        addEventListener(...args) {
          return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);
        },
        dispatchEvent(...args) {
          return scriptProcessorNode.dispatchEvent(args[0]);
        },
        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
          if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
            throw createInvalidAccessError2();
          }
          const length = frequencyHz.length;
          for (let i = 0; i < length; i += 1) {
            const omega = -Math.PI * (frequencyHz[i] / nyquist);
            const z2 = [Math.cos(omega), Math.sin(omega)];
            const numerator = evaluatePolynomial(convertedFeedforward, z2);
            const denominator = evaluatePolynomial(convertedFeedback, z2);
            const response = divide(numerator, denominator);
            magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);
            phaseResponse[i] = Math.atan2(response[1], response[0]);
          }
        },
        removeEventListener(...args) {
          return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);
        }
      };
      return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-media-element-audio-source-node.js
  var createNativeMediaElementAudioSourceNode = (nativeAudioContext, options) => {
    return nativeAudioContext.createMediaElementSource(options.mediaElement);
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-destination-node.js
  var createNativeMediaStreamAudioDestinationNode = (nativeAudioContext, options) => {
    const nativeMediaStreamAudioDestinationNode = nativeAudioContext.createMediaStreamDestination();
    assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options);
    if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {
      Object.defineProperty(nativeMediaStreamAudioDestinationNode, "numberOfOutputs", { get: () => 0 });
    }
    return nativeMediaStreamAudioDestinationNode;
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-source-node.js
  var createNativeMediaStreamAudioSourceNode = (nativeAudioContext, { mediaStream }) => {
    const audioStreamTracks = mediaStream.getAudioTracks();
    audioStreamTracks.sort((a, b) => a.id < b.id ? -1 : a.id > b.id ? 1 : 0);
    const filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);
    const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));
    Object.defineProperty(nativeMediaStreamAudioSourceNode, "mediaStream", { value: mediaStream });
    return nativeMediaStreamAudioSourceNode;
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-track-audio-source-node-factory.js
  var createNativeMediaStreamTrackAudioSourceNodeFactory = (createInvalidStateError2, isNativeOfflineAudioContext2) => {
    return (nativeAudioContext, { mediaStreamTrack }) => {
      if (typeof nativeAudioContext.createMediaStreamTrackSource === "function") {
        return nativeAudioContext.createMediaStreamTrackSource(mediaStreamTrack);
      }
      const mediaStream = new MediaStream([mediaStreamTrack]);
      const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(mediaStream);
      if (mediaStreamTrack.kind !== "audio") {
        throw createInvalidStateError2();
      }
      if (isNativeOfflineAudioContext2(nativeAudioContext)) {
        throw new TypeError();
      }
      return nativeMediaStreamAudioSourceNode;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-offline-audio-context-constructor.js
  var createNativeOfflineAudioContextConstructor = (window3) => {
    if (window3 === null) {
      return null;
    }
    if (window3.hasOwnProperty("OfflineAudioContext")) {
      return window3.OfflineAudioContext;
    }
    return window3.hasOwnProperty("webkitOfflineAudioContext") ? window3.webkitOfflineAudioContext : null;
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-oscillator-node-factory.js
  var createNativeOscillatorNodeFactory = (addSilentConnection2, cacheTestResult2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2) => {
    return (nativeContext, options) => {
      const nativeOscillatorNode = nativeContext.createOscillator();
      assignNativeAudioNodeOptions(nativeOscillatorNode, options);
      assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, "detune");
      assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, "frequency");
      if (options.periodicWave !== void 0) {
        nativeOscillatorNode.setPeriodicWave(options.periodicWave);
      } else {
        assignNativeAudioNodeOption(nativeOscillatorNode, options, "type");
      }
      if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {
        wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);
      }
      if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2(nativeContext))) {
        wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2(nativeOscillatorNode, nativeContext);
      }
      if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {
        wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);
      }
      addSilentConnection2(nativeContext, nativeOscillatorNode);
      return nativeOscillatorNode;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-factory.js
  var createNativePannerNodeFactory = (createNativePannerNodeFaker2) => {
    return (nativeContext, options) => {
      const nativePannerNode = nativeContext.createPanner();
      if (nativePannerNode.orientationX === void 0) {
        return createNativePannerNodeFaker2(nativeContext, options);
      }
      assignNativeAudioNodeOptions(nativePannerNode, options);
      assignNativeAudioNodeAudioParamValue(nativePannerNode, options, "orientationX");
      assignNativeAudioNodeAudioParamValue(nativePannerNode, options, "orientationY");
      assignNativeAudioNodeAudioParamValue(nativePannerNode, options, "orientationZ");
      assignNativeAudioNodeAudioParamValue(nativePannerNode, options, "positionX");
      assignNativeAudioNodeAudioParamValue(nativePannerNode, options, "positionY");
      assignNativeAudioNodeAudioParamValue(nativePannerNode, options, "positionZ");
      assignNativeAudioNodeOption(nativePannerNode, options, "coneInnerAngle");
      assignNativeAudioNodeOption(nativePannerNode, options, "coneOuterAngle");
      assignNativeAudioNodeOption(nativePannerNode, options, "coneOuterGain");
      assignNativeAudioNodeOption(nativePannerNode, options, "distanceModel");
      assignNativeAudioNodeOption(nativePannerNode, options, "maxDistance");
      assignNativeAudioNodeOption(nativePannerNode, options, "panningModel");
      assignNativeAudioNodeOption(nativePannerNode, options, "refDistance");
      assignNativeAudioNodeOption(nativePannerNode, options, "rolloffFactor");
      return nativePannerNode;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-faker-factory.js
  var createNativePannerNodeFakerFactory = (connectNativeAudioNodeToNativeAudioNode2, createInvalidStateError2, createNativeChannelMergerNode2, createNativeGainNode2, createNativeScriptProcessorNode2, createNativeWaveShaperNode2, createNotSupportedError2, disconnectNativeAudioNodeFromNativeAudioNode2, getFirstSample2, monitorConnections2) => {
    return (nativeContext, _a3) => {
      var _b = _a3, { coneInnerAngle, coneOuterAngle, coneOuterGain, distanceModel, maxDistance, orientationX, orientationY, orientationZ, panningModel, positionX, positionY, positionZ, refDistance, rolloffFactor } = _b, audioNodeOptions = __objRest(_b, ["coneInnerAngle", "coneOuterAngle", "coneOuterGain", "distanceModel", "maxDistance", "orientationX", "orientationY", "orientationZ", "panningModel", "positionX", "positionY", "positionZ", "refDistance", "rolloffFactor"]);
      const pannerNode = nativeContext.createPanner();
      if (audioNodeOptions.channelCount > 2) {
        throw createNotSupportedError2();
      }
      if (audioNodeOptions.channelCountMode === "max") {
        throw createNotSupportedError2();
      }
      assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);
      const SINGLE_CHANNEL_OPTIONS = {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete"
      };
      const channelMergerNode = createNativeChannelMergerNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_OPTIONS), {
        channelInterpretation: "speakers",
        numberOfInputs: 6
      }));
      const inputGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, audioNodeOptions), { gain: 1 }));
      const orientationXGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_OPTIONS), { gain: 1 }));
      const orientationYGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_OPTIONS), { gain: 0 }));
      const orientationZGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_OPTIONS), { gain: 0 }));
      const positionXGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_OPTIONS), { gain: 0 }));
      const positionYGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_OPTIONS), { gain: 0 }));
      const positionZGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_OPTIONS), { gain: 0 }));
      const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, 256, 6, 1);
      const waveShaperNode = createNativeWaveShaperNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_OPTIONS), {
        curve: new Float32Array([1, 1]),
        oversample: "none"
      }));
      let lastOrientation = [orientationX, orientationY, orientationZ];
      let lastPosition = [positionX, positionY, positionZ];
      const buffer = new Float32Array(1);
      scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {
        const orientation = [
          getFirstSample2(inputBuffer, buffer, 0),
          getFirstSample2(inputBuffer, buffer, 1),
          getFirstSample2(inputBuffer, buffer, 2)
        ];
        if (orientation.some((value, index3) => value !== lastOrientation[index3])) {
          pannerNode.setOrientation(...orientation);
          lastOrientation = orientation;
        }
        const positon = [
          getFirstSample2(inputBuffer, buffer, 3),
          getFirstSample2(inputBuffer, buffer, 4),
          getFirstSample2(inputBuffer, buffer, 5)
        ];
        if (positon.some((value, index3) => value !== lastPosition[index3])) {
          pannerNode.setPosition(...positon);
          lastPosition = positon;
        }
      };
      Object.defineProperty(orientationYGainNode.gain, "defaultValue", { get: () => 0 });
      Object.defineProperty(orientationZGainNode.gain, "defaultValue", { get: () => 0 });
      Object.defineProperty(positionXGainNode.gain, "defaultValue", { get: () => 0 });
      Object.defineProperty(positionYGainNode.gain, "defaultValue", { get: () => 0 });
      Object.defineProperty(positionZGainNode.gain, "defaultValue", { get: () => 0 });
      const nativePannerNodeFaker = {
        get bufferSize() {
          return void 0;
        },
        get channelCount() {
          return pannerNode.channelCount;
        },
        set channelCount(value) {
          if (value > 2) {
            throw createNotSupportedError2();
          }
          inputGainNode.channelCount = value;
          pannerNode.channelCount = value;
        },
        get channelCountMode() {
          return pannerNode.channelCountMode;
        },
        set channelCountMode(value) {
          if (value === "max") {
            throw createNotSupportedError2();
          }
          inputGainNode.channelCountMode = value;
          pannerNode.channelCountMode = value;
        },
        get channelInterpretation() {
          return pannerNode.channelInterpretation;
        },
        set channelInterpretation(value) {
          inputGainNode.channelInterpretation = value;
          pannerNode.channelInterpretation = value;
        },
        get coneInnerAngle() {
          return pannerNode.coneInnerAngle;
        },
        set coneInnerAngle(value) {
          pannerNode.coneInnerAngle = value;
        },
        get coneOuterAngle() {
          return pannerNode.coneOuterAngle;
        },
        set coneOuterAngle(value) {
          pannerNode.coneOuterAngle = value;
        },
        get coneOuterGain() {
          return pannerNode.coneOuterGain;
        },
        set coneOuterGain(value) {
          if (value < 0 || value > 1) {
            throw createInvalidStateError2();
          }
          pannerNode.coneOuterGain = value;
        },
        get context() {
          return pannerNode.context;
        },
        get distanceModel() {
          return pannerNode.distanceModel;
        },
        set distanceModel(value) {
          pannerNode.distanceModel = value;
        },
        get inputs() {
          return [inputGainNode];
        },
        get maxDistance() {
          return pannerNode.maxDistance;
        },
        set maxDistance(value) {
          if (value < 0) {
            throw new RangeError();
          }
          pannerNode.maxDistance = value;
        },
        get numberOfInputs() {
          return pannerNode.numberOfInputs;
        },
        get numberOfOutputs() {
          return pannerNode.numberOfOutputs;
        },
        get orientationX() {
          return orientationXGainNode.gain;
        },
        get orientationY() {
          return orientationYGainNode.gain;
        },
        get orientationZ() {
          return orientationZGainNode.gain;
        },
        get panningModel() {
          return pannerNode.panningModel;
        },
        set panningModel(value) {
          pannerNode.panningModel = value;
        },
        get positionX() {
          return positionXGainNode.gain;
        },
        get positionY() {
          return positionYGainNode.gain;
        },
        get positionZ() {
          return positionZGainNode.gain;
        },
        get refDistance() {
          return pannerNode.refDistance;
        },
        set refDistance(value) {
          if (value < 0) {
            throw new RangeError();
          }
          pannerNode.refDistance = value;
        },
        get rolloffFactor() {
          return pannerNode.rolloffFactor;
        },
        set rolloffFactor(value) {
          if (value < 0) {
            throw new RangeError();
          }
          pannerNode.rolloffFactor = value;
        },
        addEventListener(...args) {
          return inputGainNode.addEventListener(args[0], args[1], args[2]);
        },
        dispatchEvent(...args) {
          return inputGainNode.dispatchEvent(args[0]);
        },
        removeEventListener(...args) {
          return inputGainNode.removeEventListener(args[0], args[1], args[2]);
        }
      };
      if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {
        nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;
      }
      if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {
        nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;
      }
      if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {
        nativePannerNodeFaker.coneOuterGain = coneOuterGain;
      }
      if (distanceModel !== nativePannerNodeFaker.distanceModel) {
        nativePannerNodeFaker.distanceModel = distanceModel;
      }
      if (maxDistance !== nativePannerNodeFaker.maxDistance) {
        nativePannerNodeFaker.maxDistance = maxDistance;
      }
      if (orientationX !== nativePannerNodeFaker.orientationX.value) {
        nativePannerNodeFaker.orientationX.value = orientationX;
      }
      if (orientationY !== nativePannerNodeFaker.orientationY.value) {
        nativePannerNodeFaker.orientationY.value = orientationY;
      }
      if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {
        nativePannerNodeFaker.orientationZ.value = orientationZ;
      }
      if (panningModel !== nativePannerNodeFaker.panningModel) {
        nativePannerNodeFaker.panningModel = panningModel;
      }
      if (positionX !== nativePannerNodeFaker.positionX.value) {
        nativePannerNodeFaker.positionX.value = positionX;
      }
      if (positionY !== nativePannerNodeFaker.positionY.value) {
        nativePannerNodeFaker.positionY.value = positionY;
      }
      if (positionZ !== nativePannerNodeFaker.positionZ.value) {
        nativePannerNodeFaker.positionZ.value = positionZ;
      }
      if (refDistance !== nativePannerNodeFaker.refDistance) {
        nativePannerNodeFaker.refDistance = refDistance;
      }
      if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {
        nativePannerNodeFaker.rolloffFactor = rolloffFactor;
      }
      if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {
        pannerNode.setOrientation(...lastOrientation);
      }
      if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {
        pannerNode.setPosition(...lastPosition);
      }
      const whenConnected = () => {
        inputGainNode.connect(pannerNode);
        connectNativeAudioNodeToNativeAudioNode2(inputGainNode, waveShaperNode, 0, 0);
        waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);
        waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);
        waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);
        waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);
        waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);
        waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);
        channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);
      };
      const whenDisconnected = () => {
        inputGainNode.disconnect(pannerNode);
        disconnectNativeAudioNodeFromNativeAudioNode2(inputGainNode, waveShaperNode, 0, 0);
        waveShaperNode.disconnect(orientationXGainNode);
        orientationXGainNode.disconnect(channelMergerNode);
        waveShaperNode.disconnect(orientationYGainNode);
        orientationYGainNode.disconnect(channelMergerNode);
        waveShaperNode.disconnect(orientationZGainNode);
        orientationZGainNode.disconnect(channelMergerNode);
        waveShaperNode.disconnect(positionXGainNode);
        positionXGainNode.disconnect(channelMergerNode);
        waveShaperNode.disconnect(positionYGainNode);
        positionYGainNode.disconnect(channelMergerNode);
        waveShaperNode.disconnect(positionZGainNode);
        positionZGainNode.disconnect(channelMergerNode);
        channelMergerNode.disconnect(scriptProcessorNode);
        scriptProcessorNode.disconnect(nativeContext.destination);
      };
      return monitorConnections2(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-periodic-wave-factory.js
  var createNativePeriodicWaveFactory = (createIndexSizeError2) => {
    return (nativeContext, { disableNormalization, imag, real }) => {
      const convertedImag = imag instanceof Float32Array ? imag : new Float32Array(imag);
      const convertedReal = real instanceof Float32Array ? real : new Float32Array(real);
      const nativePeriodicWave = nativeContext.createPeriodicWave(convertedReal, convertedImag, { disableNormalization });
      if (Array.from(imag).length < 2) {
        throw createIndexSizeError2();
      }
      return nativePeriodicWave;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-script-processor-node.js
  var createNativeScriptProcessorNode = (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {
    return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-factory.js
  var createNativeStereoPannerNodeFactory = (createNativeStereoPannerNodeFaker, createNotSupportedError2) => {
    return (nativeContext, options) => {
      const channelCountMode = options.channelCountMode;
      if (channelCountMode === "clamped-max") {
        throw createNotSupportedError2();
      }
      if (nativeContext.createStereoPanner === void 0) {
        return createNativeStereoPannerNodeFaker(nativeContext, options);
      }
      const nativeStereoPannerNode = nativeContext.createStereoPanner();
      assignNativeAudioNodeOptions(nativeStereoPannerNode, options);
      assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, "pan");
      Object.defineProperty(nativeStereoPannerNode, "channelCountMode", {
        get: () => channelCountMode,
        set: (value) => {
          if (value !== channelCountMode) {
            throw createNotSupportedError2();
          }
        }
      });
      return nativeStereoPannerNode;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-faker-factory.js
  var createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeGainNode2, createNativeWaveShaperNode2, createNotSupportedError2, monitorConnections2) => {
    const CURVE_SIZE = 16385;
    const DC_CURVE = new Float32Array([1, 1]);
    const HALF_PI2 = Math.PI / 2;
    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete" };
    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = __spreadProps(__spreadValues({}, SINGLE_CHANNEL_OPTIONS), { oversample: "none" });
    const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {
      const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);
      const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);
      for (let i = 0; i < CURVE_SIZE; i += 1) {
        const x = i / (CURVE_SIZE - 1) * HALF_PI2;
        leftWaveShaperCurve[i] = Math.cos(x);
        rightWaveShaperCurve[i] = Math.sin(x);
      }
      const leftGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_OPTIONS), { gain: 0 }));
      const leftWaveShaperNode = createNativeWaveShaperNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), { curve: leftWaveShaperCurve }));
      const panWaveShaperNode = createNativeWaveShaperNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), { curve: DC_CURVE }));
      const rightGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_OPTIONS), { gain: 0 }));
      const rightWaveShaperNode = createNativeWaveShaperNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), { curve: rightWaveShaperCurve }));
      return {
        connectGraph() {
          inputGainNode.connect(leftGainNode);
          inputGainNode.connect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
          inputGainNode.connect(rightGainNode);
          panWaveShaperNode.connect(panGainNode);
          panGainNode.connect(leftWaveShaperNode.inputs === void 0 ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);
          panGainNode.connect(rightWaveShaperNode.inputs === void 0 ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);
          leftWaveShaperNode.connect(leftGainNode.gain);
          rightWaveShaperNode.connect(rightGainNode.gain);
          leftGainNode.connect(channelMergerNode, 0, 0);
          rightGainNode.connect(channelMergerNode, 0, 1);
        },
        disconnectGraph() {
          inputGainNode.disconnect(leftGainNode);
          inputGainNode.disconnect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
          inputGainNode.disconnect(rightGainNode);
          panWaveShaperNode.disconnect(panGainNode);
          panGainNode.disconnect(leftWaveShaperNode.inputs === void 0 ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);
          panGainNode.disconnect(rightWaveShaperNode.inputs === void 0 ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);
          leftWaveShaperNode.disconnect(leftGainNode.gain);
          rightWaveShaperNode.disconnect(rightGainNode.gain);
          leftGainNode.disconnect(channelMergerNode, 0, 0);
          rightGainNode.disconnect(channelMergerNode, 0, 1);
        }
      };
    };
    const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {
      const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
      const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
      const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
      const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
      const centerIndex = Math.floor(CURVE_SIZE / 2);
      for (let i = 0; i < CURVE_SIZE; i += 1) {
        if (i > centerIndex) {
          const x = (i - centerIndex) / (CURVE_SIZE - 1 - centerIndex) * HALF_PI2;
          leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);
          leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);
          rightInputForLeftOutputWaveShaperCurve[i] = 0;
          rightInputForRightOutputWaveShaperCurve[i] = 1;
        } else {
          const x = i / (CURVE_SIZE - 1 - centerIndex) * HALF_PI2;
          leftInputForLeftOutputWaveShaperCurve[i] = 1;
          leftInputForRightOutputWaveShaperCurve[i] = 0;
          rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);
          rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);
        }
      }
      const channelSplitterNode = createNativeChannelSplitterNode2(nativeContext, {
        channelCount: 2,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        numberOfOutputs: 2
      });
      const leftInputForLeftOutputGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_OPTIONS), { gain: 0 }));
      const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {
        curve: leftInputForLeftOutputWaveShaperCurve
      }));
      const leftInputForRightOutputGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_OPTIONS), { gain: 0 }));
      const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {
        curve: leftInputForRightOutputWaveShaperCurve
      }));
      const panWaveShaperNode = createNativeWaveShaperNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), { curve: DC_CURVE }));
      const rightInputForLeftOutputGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_OPTIONS), { gain: 0 }));
      const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {
        curve: rightInputForLeftOutputWaveShaperCurve
      }));
      const rightInputForRightOutputGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_OPTIONS), { gain: 0 }));
      const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, __spreadProps(__spreadValues({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {
        curve: rightInputForRightOutputWaveShaperCurve
      }));
      return {
        connectGraph() {
          inputGainNode.connect(channelSplitterNode);
          inputGainNode.connect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
          channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);
          channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);
          channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);
          channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);
          panWaveShaperNode.connect(panGainNode);
          panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs === void 0 ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);
          panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs === void 0 ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);
          panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs === void 0 ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);
          panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs === void 0 ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);
          leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);
          leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);
          rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);
          rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);
          leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);
          rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);
          leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);
          rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);
        },
        disconnectGraph() {
          inputGainNode.disconnect(channelSplitterNode);
          inputGainNode.disconnect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
          channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);
          channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);
          channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);
          channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);
          panWaveShaperNode.disconnect(panGainNode);
          panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs === void 0 ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);
          panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs === void 0 ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);
          panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs === void 0 ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);
          panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs === void 0 ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);
          leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);
          leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);
          rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);
          rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);
          leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);
          rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);
          leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);
          rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);
        }
      };
    };
    const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {
      if (channelCount === 1) {
        return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);
      }
      if (channelCount === 2) {
        return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);
      }
      throw createNotSupportedError2();
    };
    return (nativeContext, _a3) => {
      var _b = _a3, { channelCount, channelCountMode, pan } = _b, audioNodeOptions = __objRest(_b, ["channelCount", "channelCountMode", "pan"]);
      if (channelCountMode === "max") {
        throw createNotSupportedError2();
      }
      const channelMergerNode = createNativeChannelMergerNode2(nativeContext, __spreadProps(__spreadValues({}, audioNodeOptions), {
        channelCount: 1,
        channelCountMode,
        numberOfInputs: 2
      }));
      const inputGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, audioNodeOptions), { channelCount, channelCountMode, gain: 1 }));
      const panGainNode = createNativeGainNode2(nativeContext, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        gain: pan
      });
      let { connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);
      Object.defineProperty(panGainNode.gain, "defaultValue", { get: () => 0 });
      Object.defineProperty(panGainNode.gain, "maxValue", { get: () => 1 });
      Object.defineProperty(panGainNode.gain, "minValue", { get: () => -1 });
      const nativeStereoPannerNodeFakerFactory2 = {
        get bufferSize() {
          return void 0;
        },
        get channelCount() {
          return inputGainNode.channelCount;
        },
        set channelCount(value) {
          if (inputGainNode.channelCount !== value) {
            if (isConnected) {
              disconnectGraph();
            }
            ({ connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode));
            if (isConnected) {
              connectGraph();
            }
          }
          inputGainNode.channelCount = value;
        },
        get channelCountMode() {
          return inputGainNode.channelCountMode;
        },
        set channelCountMode(value) {
          if (value === "clamped-max" || value === "max") {
            throw createNotSupportedError2();
          }
          inputGainNode.channelCountMode = value;
        },
        get channelInterpretation() {
          return inputGainNode.channelInterpretation;
        },
        set channelInterpretation(value) {
          inputGainNode.channelInterpretation = value;
        },
        get context() {
          return inputGainNode.context;
        },
        get inputs() {
          return [inputGainNode];
        },
        get numberOfInputs() {
          return inputGainNode.numberOfInputs;
        },
        get numberOfOutputs() {
          return inputGainNode.numberOfOutputs;
        },
        get pan() {
          return panGainNode.gain;
        },
        addEventListener(...args) {
          return inputGainNode.addEventListener(args[0], args[1], args[2]);
        },
        dispatchEvent(...args) {
          return inputGainNode.dispatchEvent(args[0]);
        },
        removeEventListener(...args) {
          return inputGainNode.removeEventListener(args[0], args[1], args[2]);
        }
      };
      let isConnected = false;
      const whenConnected = () => {
        connectGraph();
        isConnected = true;
      };
      const whenDisconnected = () => {
        disconnectGraph();
        isConnected = false;
      };
      return monitorConnections2(interceptConnections(nativeStereoPannerNodeFakerFactory2, channelMergerNode), whenConnected, whenDisconnected);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-factory.js
  var createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode2, createInvalidStateError2, createNativeWaveShaperNodeFaker2, isDCCurve2, monitorConnections2, nativeAudioContextConstructor2, overwriteAccessors2) => {
    return (nativeContext, options) => {
      const nativeWaveShaperNode = nativeContext.createWaveShaper();
      if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === "webkitAudioContext" && nativeContext.createGain().gain.automationRate === void 0) {
        return createNativeWaveShaperNodeFaker2(nativeContext, options);
      }
      assignNativeAudioNodeOptions(nativeWaveShaperNode, options);
      const curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve);
      if (curve !== null && curve.length < 2) {
        throw createInvalidStateError2();
      }
      assignNativeAudioNodeOption(nativeWaveShaperNode, { curve }, "curve");
      assignNativeAudioNodeOption(nativeWaveShaperNode, options, "oversample");
      let disconnectNativeAudioBufferSourceNode = null;
      let isConnected = false;
      overwriteAccessors2(nativeWaveShaperNode, "curve", (get) => () => get.call(nativeWaveShaperNode), (set2) => (value) => {
        set2.call(nativeWaveShaperNode, value);
        if (isConnected) {
          if (isDCCurve2(value) && disconnectNativeAudioBufferSourceNode === null) {
            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, nativeWaveShaperNode);
          } else if (!isDCCurve2(value) && disconnectNativeAudioBufferSourceNode !== null) {
            disconnectNativeAudioBufferSourceNode();
            disconnectNativeAudioBufferSourceNode = null;
          }
        }
        return value;
      });
      const whenConnected = () => {
        isConnected = true;
        if (isDCCurve2(nativeWaveShaperNode.curve)) {
          disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, nativeWaveShaperNode);
        }
      };
      const whenDisconnected = () => {
        isConnected = false;
        if (disconnectNativeAudioBufferSourceNode !== null) {
          disconnectNativeAudioBufferSourceNode();
          disconnectNativeAudioBufferSourceNode = null;
        }
      };
      return monitorConnections2(nativeWaveShaperNode, whenConnected, whenDisconnected);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-faker-factory.js
  var createNativeWaveShaperNodeFakerFactory = (createConnectedNativeAudioBufferSourceNode2, createInvalidStateError2, createNativeGainNode2, isDCCurve2, monitorConnections2) => {
    return (nativeContext, _a3) => {
      var _b = _a3, { curve, oversample } = _b, audioNodeOptions = __objRest(_b, ["curve", "oversample"]);
      const negativeWaveShaperNode = nativeContext.createWaveShaper();
      const positiveWaveShaperNode = nativeContext.createWaveShaper();
      assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);
      assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);
      const inputGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, audioNodeOptions), { gain: 1 }));
      const invertGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, audioNodeOptions), { gain: -1 }));
      const outputGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, audioNodeOptions), { gain: 1 }));
      const revertGainNode = createNativeGainNode2(nativeContext, __spreadProps(__spreadValues({}, audioNodeOptions), { gain: -1 }));
      let disconnectNativeAudioBufferSourceNode = null;
      let isConnected = false;
      let unmodifiedCurve = null;
      const nativeWaveShaperNodeFaker = {
        get bufferSize() {
          return void 0;
        },
        get channelCount() {
          return negativeWaveShaperNode.channelCount;
        },
        set channelCount(value) {
          inputGainNode.channelCount = value;
          invertGainNode.channelCount = value;
          negativeWaveShaperNode.channelCount = value;
          outputGainNode.channelCount = value;
          positiveWaveShaperNode.channelCount = value;
          revertGainNode.channelCount = value;
        },
        get channelCountMode() {
          return negativeWaveShaperNode.channelCountMode;
        },
        set channelCountMode(value) {
          inputGainNode.channelCountMode = value;
          invertGainNode.channelCountMode = value;
          negativeWaveShaperNode.channelCountMode = value;
          outputGainNode.channelCountMode = value;
          positiveWaveShaperNode.channelCountMode = value;
          revertGainNode.channelCountMode = value;
        },
        get channelInterpretation() {
          return negativeWaveShaperNode.channelInterpretation;
        },
        set channelInterpretation(value) {
          inputGainNode.channelInterpretation = value;
          invertGainNode.channelInterpretation = value;
          negativeWaveShaperNode.channelInterpretation = value;
          outputGainNode.channelInterpretation = value;
          positiveWaveShaperNode.channelInterpretation = value;
          revertGainNode.channelInterpretation = value;
        },
        get context() {
          return negativeWaveShaperNode.context;
        },
        get curve() {
          return unmodifiedCurve;
        },
        set curve(value) {
          if (value !== null && value.length < 2) {
            throw createInvalidStateError2();
          }
          if (value === null) {
            negativeWaveShaperNode.curve = value;
            positiveWaveShaperNode.curve = value;
          } else {
            const curveLength = value.length;
            const negativeCurve = new Float32Array(curveLength + 2 - curveLength % 2);
            const positiveCurve = new Float32Array(curveLength + 2 - curveLength % 2);
            negativeCurve[0] = value[0];
            positiveCurve[0] = -value[curveLength - 1];
            const length = Math.ceil((curveLength + 1) / 2);
            const centerIndex = (curveLength + 1) / 2 - 1;
            for (let i = 1; i < length; i += 1) {
              const theoreticIndex = i / length * centerIndex;
              const lowerIndex = Math.floor(theoreticIndex);
              const upperIndex = Math.ceil(theoreticIndex);
              negativeCurve[i] = lowerIndex === upperIndex ? value[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * value[upperIndex];
              positiveCurve[i] = lowerIndex === upperIndex ? -value[curveLength - 1 - lowerIndex] : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) - (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];
            }
            negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;
            negativeWaveShaperNode.curve = negativeCurve;
            positiveWaveShaperNode.curve = positiveCurve;
          }
          unmodifiedCurve = value;
          if (isConnected) {
            if (isDCCurve2(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {
              disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, inputGainNode);
            } else if (disconnectNativeAudioBufferSourceNode !== null) {
              disconnectNativeAudioBufferSourceNode();
              disconnectNativeAudioBufferSourceNode = null;
            }
          }
        },
        get inputs() {
          return [inputGainNode];
        },
        get numberOfInputs() {
          return negativeWaveShaperNode.numberOfInputs;
        },
        get numberOfOutputs() {
          return negativeWaveShaperNode.numberOfOutputs;
        },
        get oversample() {
          return negativeWaveShaperNode.oversample;
        },
        set oversample(value) {
          negativeWaveShaperNode.oversample = value;
          positiveWaveShaperNode.oversample = value;
        },
        addEventListener(...args) {
          return inputGainNode.addEventListener(args[0], args[1], args[2]);
        },
        dispatchEvent(...args) {
          return inputGainNode.dispatchEvent(args[0]);
        },
        removeEventListener(...args) {
          return inputGainNode.removeEventListener(args[0], args[1], args[2]);
        }
      };
      if (curve !== null) {
        nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);
      }
      if (oversample !== nativeWaveShaperNodeFaker.oversample) {
        nativeWaveShaperNodeFaker.oversample = oversample;
      }
      const whenConnected = () => {
        inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);
        inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);
        isConnected = true;
        if (isDCCurve2(unmodifiedCurve)) {
          disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, inputGainNode);
        }
      };
      const whenDisconnected = () => {
        inputGainNode.disconnect(negativeWaveShaperNode);
        negativeWaveShaperNode.disconnect(outputGainNode);
        inputGainNode.disconnect(invertGainNode);
        invertGainNode.disconnect(positiveWaveShaperNode);
        positiveWaveShaperNode.disconnect(revertGainNode);
        revertGainNode.disconnect(outputGainNode);
        isConnected = false;
        if (disconnectNativeAudioBufferSourceNode !== null) {
          disconnectNativeAudioBufferSourceNode();
          disconnectNativeAudioBufferSourceNode = null;
        }
      };
      return monitorConnections2(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/not-supported-error.js
  var createNotSupportedError = () => new DOMException("", "NotSupportedError");

  // node_modules/standardized-audio-context/build/es2019/factories/offline-audio-context-constructor.js
  var DEFAULT_OPTIONS16 = {
    numberOfChannels: 1
  };
  var createOfflineAudioContextConstructor = (baseAudioContextConstructor2, cacheTestResult2, createInvalidStateError2, createNativeOfflineAudioContext2, startRendering2) => {
    return class OfflineAudioContext extends baseAudioContextConstructor2 {
      constructor(a, b, c2) {
        let options;
        if (typeof a === "number" && b !== void 0 && c2 !== void 0) {
          options = { length: b, numberOfChannels: a, sampleRate: c2 };
        } else if (typeof a === "object") {
          options = a;
        } else {
          throw new Error("The given parameters are not valid.");
        }
        const { length, numberOfChannels, sampleRate } = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS16), options);
        const nativeOfflineAudioContext = createNativeOfflineAudioContext2(numberOfChannels, length, sampleRate);
        if (!cacheTestResult2(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {
          nativeOfflineAudioContext.addEventListener("statechange", (() => {
            let i = 0;
            const delayStateChangeEvent = (event2) => {
              if (this._state === "running") {
                if (i > 0) {
                  nativeOfflineAudioContext.removeEventListener("statechange", delayStateChangeEvent);
                  event2.stopImmediatePropagation();
                  this._waitForThePromiseToSettle(event2);
                } else {
                  i += 1;
                }
              }
            };
            return delayStateChangeEvent;
          })());
        }
        super(nativeOfflineAudioContext, numberOfChannels);
        this._length = length;
        this._nativeOfflineAudioContext = nativeOfflineAudioContext;
        this._state = null;
      }
      get length() {
        if (this._nativeOfflineAudioContext.length === void 0) {
          return this._length;
        }
        return this._nativeOfflineAudioContext.length;
      }
      get state() {
        return this._state === null ? this._nativeOfflineAudioContext.state : this._state;
      }
      startRendering() {
        if (this._state === "running") {
          return Promise.reject(createInvalidStateError2());
        }
        this._state = "running";
        return startRendering2(this.destination, this._nativeOfflineAudioContext).finally(() => {
          this._state = null;
          deactivateAudioGraph(this);
        });
      }
      _waitForThePromiseToSettle(event2) {
        if (this._state === null) {
          this._nativeOfflineAudioContext.dispatchEvent(event2);
        } else {
          setTimeout(() => this._waitForThePromiseToSettle(event2));
        }
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-constructor.js
  var DEFAULT_OPTIONS17 = {
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    detune: 0,
    frequency: 440,
    periodicWave: void 0,
    type: "sine"
  };
  var createOscillatorNodeConstructor = (audioNodeConstructor2, createAudioParam2, createNativeOscillatorNode2, createOscillatorNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, wrapEventListener2) => {
    return class OscillatorNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS17), options);
        const nativeOscillatorNode = createNativeOscillatorNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const oscillatorNodeRenderer = isOffline ? createOscillatorNodeRenderer2() : null;
        const nyquist = context2.sampleRate / 2;
        super(context2, false, nativeOscillatorNode, oscillatorNodeRenderer);
        this._detune = createAudioParam2(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);
        this._frequency = createAudioParam2(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);
        this._nativeOscillatorNode = nativeOscillatorNode;
        this._onended = null;
        this._oscillatorNodeRenderer = oscillatorNodeRenderer;
        if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== void 0) {
          this._oscillatorNodeRenderer.periodicWave = mergedOptions.periodicWave;
        }
      }
      get detune() {
        return this._detune;
      }
      get frequency() {
        return this._frequency;
      }
      get onended() {
        return this._onended;
      }
      set onended(value) {
        const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
        this._nativeOscillatorNode.onended = wrappedListener;
        const nativeOnEnded = this._nativeOscillatorNode.onended;
        this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
      }
      get type() {
        return this._nativeOscillatorNode.type;
      }
      set type(value) {
        this._nativeOscillatorNode.type = value;
        if (this._oscillatorNodeRenderer !== null) {
          this._oscillatorNodeRenderer.periodicWave = null;
        }
      }
      setPeriodicWave(periodicWave) {
        this._nativeOscillatorNode.setPeriodicWave(periodicWave);
        if (this._oscillatorNodeRenderer !== null) {
          this._oscillatorNodeRenderer.periodicWave = periodicWave;
        }
      }
      start(when = 0) {
        this._nativeOscillatorNode.start(when);
        if (this._oscillatorNodeRenderer !== null) {
          this._oscillatorNodeRenderer.start = when;
        }
        if (this.context.state !== "closed") {
          setInternalStateToActive(this);
          const resetInternalStateToPassive = () => {
            this._nativeOscillatorNode.removeEventListener("ended", resetInternalStateToPassive);
            if (isActiveAudioNode(this)) {
              setInternalStateToPassive(this);
            }
          };
          this._nativeOscillatorNode.addEventListener("ended", resetInternalStateToPassive);
        }
      }
      stop(when = 0) {
        this._nativeOscillatorNode.stop(when);
        if (this._oscillatorNodeRenderer !== null) {
          this._oscillatorNodeRenderer.stop = when;
        }
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-renderer-factory.js
  var createOscillatorNodeRendererFactory = (connectAudioParam2, createNativeOscillatorNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeOscillatorNodes = new WeakMap();
      let periodicWave = null;
      let start2 = null;
      let stop = null;
      const createOscillatorNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeOscillatorNode = getNativeAudioNode2(proxy);
        const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);
        if (!nativeOscillatorNodeIsOwnedByContext) {
          const options = {
            channelCount: nativeOscillatorNode.channelCount,
            channelCountMode: nativeOscillatorNode.channelCountMode,
            channelInterpretation: nativeOscillatorNode.channelInterpretation,
            detune: nativeOscillatorNode.detune.value,
            frequency: nativeOscillatorNode.frequency.value,
            periodicWave: periodicWave === null ? void 0 : periodicWave,
            type: nativeOscillatorNode.type
          };
          nativeOscillatorNode = createNativeOscillatorNode2(nativeOfflineAudioContext, options);
          if (start2 !== null) {
            nativeOscillatorNode.start(start2);
          }
          if (stop !== null) {
            nativeOscillatorNode.stop(stop);
          }
        }
        renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);
        if (!nativeOscillatorNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);
          await renderAutomation2(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);
        }
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeOscillatorNode);
        return nativeOscillatorNode;
      };
      return {
        set periodicWave(value) {
          periodicWave = value;
        },
        set start(value) {
          start2 = value;
        },
        set stop(value) {
          stop = value;
        },
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);
          if (renderedNativeOscillatorNode !== void 0) {
            return Promise.resolve(renderedNativeOscillatorNode);
          }
          return createOscillatorNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/panner-node-constructor.js
  var DEFAULT_OPTIONS18 = {
    channelCount: 2,
    channelCountMode: "clamped-max",
    channelInterpretation: "speakers",
    coneInnerAngle: 360,
    coneOuterAngle: 360,
    coneOuterGain: 0,
    distanceModel: "inverse",
    maxDistance: 1e4,
    orientationX: 1,
    orientationY: 0,
    orientationZ: 0,
    panningModel: "equalpower",
    positionX: 0,
    positionY: 0,
    positionZ: 0,
    refDistance: 1,
    rolloffFactor: 1
  };
  var createPannerNodeConstructor = (audioNodeConstructor2, createAudioParam2, createNativePannerNode2, createPannerNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
    return class PannerNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS18), options);
        const nativePannerNode = createNativePannerNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const pannerNodeRenderer = isOffline ? createPannerNodeRenderer2() : null;
        super(context2, false, nativePannerNode, pannerNodeRenderer);
        this._nativePannerNode = nativePannerNode;
        this._orientationX = createAudioParam2(this, isOffline, nativePannerNode.orientationX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        this._orientationY = createAudioParam2(this, isOffline, nativePannerNode.orientationY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        this._orientationZ = createAudioParam2(this, isOffline, nativePannerNode.orientationZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        this._positionX = createAudioParam2(this, isOffline, nativePannerNode.positionX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        this._positionY = createAudioParam2(this, isOffline, nativePannerNode.positionY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        this._positionZ = createAudioParam2(this, isOffline, nativePannerNode.positionZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        setAudioNodeTailTime2(this, 1);
      }
      get coneInnerAngle() {
        return this._nativePannerNode.coneInnerAngle;
      }
      set coneInnerAngle(value) {
        this._nativePannerNode.coneInnerAngle = value;
      }
      get coneOuterAngle() {
        return this._nativePannerNode.coneOuterAngle;
      }
      set coneOuterAngle(value) {
        this._nativePannerNode.coneOuterAngle = value;
      }
      get coneOuterGain() {
        return this._nativePannerNode.coneOuterGain;
      }
      set coneOuterGain(value) {
        this._nativePannerNode.coneOuterGain = value;
      }
      get distanceModel() {
        return this._nativePannerNode.distanceModel;
      }
      set distanceModel(value) {
        this._nativePannerNode.distanceModel = value;
      }
      get maxDistance() {
        return this._nativePannerNode.maxDistance;
      }
      set maxDistance(value) {
        this._nativePannerNode.maxDistance = value;
      }
      get orientationX() {
        return this._orientationX;
      }
      get orientationY() {
        return this._orientationY;
      }
      get orientationZ() {
        return this._orientationZ;
      }
      get panningModel() {
        return this._nativePannerNode.panningModel;
      }
      set panningModel(value) {
        this._nativePannerNode.panningModel = value;
      }
      get positionX() {
        return this._positionX;
      }
      get positionY() {
        return this._positionY;
      }
      get positionZ() {
        return this._positionZ;
      }
      get refDistance() {
        return this._nativePannerNode.refDistance;
      }
      set refDistance(value) {
        this._nativePannerNode.refDistance = value;
      }
      get rolloffFactor() {
        return this._nativePannerNode.rolloffFactor;
      }
      set rolloffFactor(value) {
        this._nativePannerNode.rolloffFactor = value;
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/panner-node-renderer-factory.js
  var createPannerNodeRendererFactory = (connectAudioParam2, createNativeChannelMergerNode2, createNativeConstantSourceNode2, createNativeGainNode2, createNativePannerNode2, getNativeAudioNode2, nativeOfflineAudioContextConstructor2, renderAutomation2, renderInputsOfAudioNode2, renderNativeOfflineAudioContext2) => {
    return () => {
      const renderedNativeAudioNodes = new WeakMap();
      let renderedBufferPromise = null;
      const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeGainNode = null;
        let nativePannerNode = getNativeAudioNode2(proxy);
        const commonAudioNodeOptions = {
          channelCount: nativePannerNode.channelCount,
          channelCountMode: nativePannerNode.channelCountMode,
          channelInterpretation: nativePannerNode.channelInterpretation
        };
        const commonNativePannerNodeOptions = __spreadProps(__spreadValues({}, commonAudioNodeOptions), {
          coneInnerAngle: nativePannerNode.coneInnerAngle,
          coneOuterAngle: nativePannerNode.coneOuterAngle,
          coneOuterGain: nativePannerNode.coneOuterGain,
          distanceModel: nativePannerNode.distanceModel,
          maxDistance: nativePannerNode.maxDistance,
          panningModel: nativePannerNode.panningModel,
          refDistance: nativePannerNode.refDistance,
          rolloffFactor: nativePannerNode.rolloffFactor
        });
        const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);
        if ("bufferSize" in nativePannerNode) {
          nativeGainNode = createNativeGainNode2(nativeOfflineAudioContext, __spreadProps(__spreadValues({}, commonAudioNodeOptions), { gain: 1 }));
        } else if (!nativePannerNodeIsOwnedByContext) {
          const options = __spreadProps(__spreadValues({}, commonNativePannerNodeOptions), {
            orientationX: nativePannerNode.orientationX.value,
            orientationY: nativePannerNode.orientationY.value,
            orientationZ: nativePannerNode.orientationZ.value,
            positionX: nativePannerNode.positionX.value,
            positionY: nativePannerNode.positionY.value,
            positionZ: nativePannerNode.positionZ.value
          });
          nativePannerNode = createNativePannerNode2(nativeOfflineAudioContext, options);
        }
        renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);
        if (nativeGainNode !== null) {
          if (renderedBufferPromise === null) {
            if (nativeOfflineAudioContextConstructor2 === null) {
              throw new Error("Missing the native OfflineAudioContext constructor.");
            }
            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor2(6, proxy.context.length, nativeOfflineAudioContext.sampleRate);
            const nativeChannelMergerNode = createNativeChannelMergerNode2(partialOfflineAudioContext, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "speakers",
              numberOfInputs: 6
            });
            nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);
            renderedBufferPromise = (async () => {
              const nativeConstantSourceNodes = await Promise.all([
                proxy.orientationX,
                proxy.orientationY,
                proxy.orientationZ,
                proxy.positionX,
                proxy.positionY,
                proxy.positionZ
              ].map(async (audioParam, index3) => {
                const nativeConstantSourceNode = createNativeConstantSourceNode2(partialOfflineAudioContext, {
                  channelCount: 1,
                  channelCountMode: "explicit",
                  channelInterpretation: "discrete",
                  offset: index3 === 0 ? 1 : 0
                });
                await renderAutomation2(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset);
                return nativeConstantSourceNode;
              }));
              for (let i = 0; i < 6; i += 1) {
                nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);
                nativeConstantSourceNodes[i].start(0);
              }
              return renderNativeOfflineAudioContext2(partialOfflineAudioContext);
            })();
          }
          const renderedBuffer = await renderedBufferPromise;
          const inputGainNode = createNativeGainNode2(nativeOfflineAudioContext, __spreadProps(__spreadValues({}, commonAudioNodeOptions), { gain: 1 }));
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, inputGainNode);
          const channelDatas = [];
          for (let i = 0; i < renderedBuffer.numberOfChannels; i += 1) {
            channelDatas.push(renderedBuffer.getChannelData(i));
          }
          let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];
          let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];
          let gateGainNode = createNativeGainNode2(nativeOfflineAudioContext, __spreadProps(__spreadValues({}, commonAudioNodeOptions), { gain: 1 }));
          let partialPannerNode = createNativePannerNode2(nativeOfflineAudioContext, __spreadProps(__spreadValues({}, commonNativePannerNodeOptions), {
            orientationX: lastOrientation[0],
            orientationY: lastOrientation[1],
            orientationZ: lastOrientation[2],
            positionX: lastPosition[0],
            positionY: lastPosition[1],
            positionZ: lastPosition[2]
          }));
          inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);
          partialPannerNode.connect(nativeGainNode);
          for (let i = 128; i < renderedBuffer.length; i += 128) {
            const orientation = [channelDatas[0][i], channelDatas[1][i], channelDatas[2][i]];
            const positon = [channelDatas[3][i], channelDatas[4][i], channelDatas[5][i]];
            if (orientation.some((value, index3) => value !== lastOrientation[index3]) || positon.some((value, index3) => value !== lastPosition[index3])) {
              lastOrientation = orientation;
              lastPosition = positon;
              const currentTime = i / nativeOfflineAudioContext.sampleRate;
              gateGainNode.gain.setValueAtTime(0, currentTime);
              gateGainNode = createNativeGainNode2(nativeOfflineAudioContext, __spreadProps(__spreadValues({}, commonAudioNodeOptions), { gain: 0 }));
              partialPannerNode = createNativePannerNode2(nativeOfflineAudioContext, __spreadProps(__spreadValues({}, commonNativePannerNodeOptions), {
                orientationX: lastOrientation[0],
                orientationY: lastOrientation[1],
                orientationZ: lastOrientation[2],
                positionX: lastPosition[0],
                positionY: lastPosition[1],
                positionZ: lastPosition[2]
              }));
              gateGainNode.gain.setValueAtTime(1, currentTime);
              inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);
              partialPannerNode.connect(nativeGainNode);
            }
          }
          return nativeGainNode;
        }
        if (!nativePannerNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);
          await renderAutomation2(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);
          await renderAutomation2(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);
          await renderAutomation2(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);
          await renderAutomation2(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);
          await renderAutomation2(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);
          await connectAudioParam2(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);
        }
        if (isNativeAudioNodeFaker(nativePannerNode)) {
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0]);
        } else {
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativePannerNode);
        }
        return nativePannerNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
          if (renderedNativeGainNodeOrNativePannerNode !== void 0) {
            return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);
          }
          return createAudioNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/periodic-wave-constructor.js
  var DEFAULT_OPTIONS19 = {
    disableNormalization: false
  };
  var createPeriodicWaveConstructor = (createNativePeriodicWave2, getNativeContext2, periodicWaveStore, sanitizePeriodicWaveOptions2) => {
    return class PeriodicWave {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = sanitizePeriodicWaveOptions2(__spreadValues(__spreadValues({}, DEFAULT_OPTIONS19), options));
        const periodicWave = createNativePeriodicWave2(nativeContext, mergedOptions);
        periodicWaveStore.add(periodicWave);
        return periodicWave;
      }
      static [Symbol.hasInstance](instance) {
        return instance !== null && typeof instance === "object" && Object.getPrototypeOf(instance) === PeriodicWave.prototype || periodicWaveStore.has(instance);
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/render-automation.js
  var createRenderAutomation = (getAudioParamRenderer, renderInputsOfAudioParam2) => {
    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {
      const audioParamRenderer = getAudioParamRenderer(audioParam);
      audioParamRenderer.replay(nativeAudioParam);
      return renderInputsOfAudioParam2(audioParam, nativeOfflineAudioContext, nativeAudioParam);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-node.js
  var createRenderInputsOfAudioNode = (getAudioNodeConnections2, getAudioNodeRenderer2, isPartOfACycle2) => {
    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {
      const audioNodeConnections = getAudioNodeConnections2(audioNode);
      await Promise.all(audioNodeConnections.activeInputs.map((connections, input2) => Array.from(connections).map(async ([source, output]) => {
        const audioNodeRenderer = getAudioNodeRenderer2(source);
        const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);
        const destination = audioNode.context.destination;
        if (!isPartOfACycle2(source) && (audioNode !== destination || !isPartOfACycle2(audioNode))) {
          renderedNativeAudioNode.connect(nativeAudioNode, output, input2);
        }
      })).reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-param.js
  var createRenderInputsOfAudioParam = (getAudioNodeRenderer2, getAudioParamConnections2, isPartOfACycle2) => {
    return async (audioParam, nativeOfflineAudioContext, nativeAudioParam) => {
      const audioParamConnections = getAudioParamConnections2(audioParam);
      await Promise.all(Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {
        const audioNodeRenderer = getAudioNodeRenderer2(source);
        const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);
        if (!isPartOfACycle2(source)) {
          renderedNativeAudioNode.connect(nativeAudioParam, output);
        }
      }));
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/render-native-offline-audio-context.js
  var createRenderNativeOfflineAudioContext = (cacheTestResult2, createNativeGainNode2, createNativeScriptProcessorNode2, testOfflineAudioContextCurrentTimeSupport) => {
    return (nativeOfflineAudioContext) => {
      if (cacheTestResult2(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {
        return Promise.resolve(cacheTestResult2(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)).then((isOfflineAudioContextCurrentTimeSupported) => {
          if (!isOfflineAudioContextCurrentTimeSupported) {
            const scriptProcessorNode = createNativeScriptProcessorNode2(nativeOfflineAudioContext, 512, 0, 1);
            nativeOfflineAudioContext.oncomplete = () => {
              scriptProcessorNode.onaudioprocess = null;
              scriptProcessorNode.disconnect();
            };
            scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime;
            scriptProcessorNode.connect(nativeOfflineAudioContext.destination);
          }
          return nativeOfflineAudioContext.startRendering();
        });
      }
      return new Promise((resolve2) => {
        const gainNode = createNativeGainNode2(nativeOfflineAudioContext, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          gain: 0
        });
        nativeOfflineAudioContext.oncomplete = (event2) => {
          gainNode.disconnect();
          resolve2(event2.renderedBuffer);
        };
        gainNode.connect(nativeOfflineAudioContext.destination);
        nativeOfflineAudioContext.startRendering();
      });
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/set-active-audio-worklet-node-inputs.js
  var createSetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore2) => {
    return (nativeAudioWorkletNode, activeInputs) => {
      activeAudioWorkletNodeInputsStore2.set(nativeAudioWorkletNode, activeInputs);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/set-audio-node-tail-time.js
  var createSetAudioNodeTailTime = (audioNodeTailTimeStore2) => {
    return (audioNode, tailTime) => audioNodeTailTimeStore2.set(audioNode, tailTime);
  };

  // node_modules/standardized-audio-context/build/es2019/factories/start-rendering.js
  var createStartRendering = (audioBufferStore2, cacheTestResult2, getAudioNodeRenderer2, getUnrenderedAudioWorkletNodes2, renderNativeOfflineAudioContext2, testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, wrapAudioBufferCopyChannelMethods2, wrapAudioBufferCopyChannelMethodsOutOfBounds2) => {
    return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer2(destination).render(destination, nativeOfflineAudioContext).then(() => Promise.all(Array.from(getUnrenderedAudioWorkletNodes2(nativeOfflineAudioContext)).map((audioWorkletNode) => getAudioNodeRenderer2(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext)))).then(() => renderNativeOfflineAudioContext2(nativeOfflineAudioContext)).then((audioBuffer) => {
      if (typeof audioBuffer.copyFromChannel !== "function") {
        wrapAudioBufferCopyChannelMethods2(audioBuffer);
        wrapAudioBufferGetChannelDataMethod(audioBuffer);
      } else if (!cacheTestResult2(testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport2(audioBuffer))) {
        wrapAudioBufferCopyChannelMethodsOutOfBounds2(audioBuffer);
      }
      audioBufferStore2.add(audioBuffer);
      return audioBuffer;
    });
  };

  // node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-constructor.js
  var DEFAULT_OPTIONS20 = {
    channelCount: 2,
    channelCountMode: "explicit",
    channelInterpretation: "speakers",
    pan: 0
  };
  var createStereoPannerNodeConstructor = (audioNodeConstructor2, createAudioParam2, createNativeStereoPannerNode2, createStereoPannerNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2) => {
    return class StereoPannerNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS20), options);
        const nativeStereoPannerNode = createNativeStereoPannerNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const stereoPannerNodeRenderer = isOffline ? createStereoPannerNodeRenderer2() : null;
        super(context2, false, nativeStereoPannerNode, stereoPannerNodeRenderer);
        this._pan = createAudioParam2(this, isOffline, nativeStereoPannerNode.pan);
      }
      get pan() {
        return this._pan;
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-renderer-factory.js
  var createStereoPannerNodeRendererFactory = (connectAudioParam2, createNativeStereoPannerNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeStereoPannerNodes = new WeakMap();
      const createStereoPannerNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeStereoPannerNode = getNativeAudioNode2(proxy);
        const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);
        if (!nativeStereoPannerNodeIsOwnedByContext) {
          const options = {
            channelCount: nativeStereoPannerNode.channelCount,
            channelCountMode: nativeStereoPannerNode.channelCountMode,
            channelInterpretation: nativeStereoPannerNode.channelInterpretation,
            pan: nativeStereoPannerNode.pan.value
          };
          nativeStereoPannerNode = createNativeStereoPannerNode2(nativeOfflineAudioContext, options);
        }
        renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);
        if (!nativeStereoPannerNodeIsOwnedByContext) {
          await renderAutomation2(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);
        } else {
          await connectAudioParam2(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);
        }
        if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0]);
        } else {
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeStereoPannerNode);
        }
        return nativeStereoPannerNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);
          if (renderedNativeStereoPannerNode !== void 0) {
            return Promise.resolve(renderedNativeStereoPannerNode);
          }
          return createStereoPannerNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-constructor-support.js
  var createTestAudioBufferConstructorSupport = (nativeAudioBufferConstructor2) => {
    return () => {
      if (nativeAudioBufferConstructor2 === null) {
        return false;
      }
      try {
        new nativeAudioBufferConstructor2({ length: 1, sampleRate: 44100 });
      } catch (e) {
        return false;
      }
      return true;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/test-audio-worklet-processor-post-message-support.js
  var createTestAudioWorkletProcessorPostMessageSupport = (nativeAudioWorkletNodeConstructor2, nativeOfflineAudioContextConstructor2) => {
    return async () => {
      if (nativeAudioWorkletNodeConstructor2 === null) {
        return true;
      }
      if (nativeOfflineAudioContextConstructor2 === null) {
        return false;
      }
      const blob = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'], {
        type: "application/javascript; charset=utf-8"
      });
      const offlineAudioContext = new nativeOfflineAudioContextConstructor2(1, 128, 44100);
      const url = URL.createObjectURL(blob);
      let isEmittingMessageEvents = false;
      let isEmittingProcessorErrorEvents = false;
      try {
        await offlineAudioContext.audioWorklet.addModule(url);
        const audioWorkletNode = new nativeAudioWorkletNodeConstructor2(offlineAudioContext, "a", { numberOfOutputs: 0 });
        const oscillator = offlineAudioContext.createOscillator();
        audioWorkletNode.port.onmessage = () => isEmittingMessageEvents = true;
        audioWorkletNode.onprocessorerror = () => isEmittingProcessorErrorEvents = true;
        oscillator.connect(audioWorkletNode);
        oscillator.start(0);
        await offlineAudioContext.startRendering();
        await new Promise((resolve2) => setTimeout(resolve2));
      } catch (e) {
      } finally {
        URL.revokeObjectURL(url);
      }
      return isEmittingMessageEvents && !isEmittingProcessorErrorEvents;
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/test-offline-audio-context-current-time-support.js
  var createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode2, nativeOfflineAudioContextConstructor2) => {
    return () => {
      if (nativeOfflineAudioContextConstructor2 === null) {
        return Promise.resolve(false);
      }
      const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);
      const gainNode = createNativeGainNode2(nativeOfflineAudioContext, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        gain: 0
      });
      return new Promise((resolve2) => {
        nativeOfflineAudioContext.oncomplete = () => {
          gainNode.disconnect();
          resolve2(nativeOfflineAudioContext.currentTime !== 0);
        };
        nativeOfflineAudioContext.startRendering();
      });
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/unknown-error.js
  var createUnknownError = () => new DOMException("", "UnknownError");

  // node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-constructor.js
  var DEFAULT_OPTIONS21 = {
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    curve: null,
    oversample: "none"
  };
  var createWaveShaperNodeConstructor = (audioNodeConstructor2, createInvalidStateError2, createNativeWaveShaperNode2, createWaveShaperNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
    return class WaveShaperNode extends audioNodeConstructor2 {
      constructor(context2, options) {
        const nativeContext = getNativeContext2(context2);
        const mergedOptions = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS21), options);
        const nativeWaveShaperNode = createNativeWaveShaperNode2(nativeContext, mergedOptions);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        const waveShaperNodeRenderer = isOffline ? createWaveShaperNodeRenderer2() : null;
        super(context2, true, nativeWaveShaperNode, waveShaperNodeRenderer);
        this._isCurveNullified = false;
        this._nativeWaveShaperNode = nativeWaveShaperNode;
        setAudioNodeTailTime2(this, 1);
      }
      get curve() {
        if (this._isCurveNullified) {
          return null;
        }
        return this._nativeWaveShaperNode.curve;
      }
      set curve(value) {
        if (value === null) {
          this._isCurveNullified = true;
          this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);
        } else {
          if (value.length < 2) {
            throw createInvalidStateError2();
          }
          this._isCurveNullified = false;
          this._nativeWaveShaperNode.curve = value;
        }
      }
      get oversample() {
        return this._nativeWaveShaperNode.oversample;
      }
      set oversample(value) {
        this._nativeWaveShaperNode.oversample = value;
      }
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-renderer-factory.js
  var createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
    return () => {
      const renderedNativeWaveShaperNodes = new WeakMap();
      const createWaveShaperNode = async (proxy, nativeOfflineAudioContext) => {
        let nativeWaveShaperNode = getNativeAudioNode2(proxy);
        const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);
        if (!nativeWaveShaperNodeIsOwnedByContext) {
          const options = {
            channelCount: nativeWaveShaperNode.channelCount,
            channelCountMode: nativeWaveShaperNode.channelCountMode,
            channelInterpretation: nativeWaveShaperNode.channelInterpretation,
            curve: nativeWaveShaperNode.curve,
            oversample: nativeWaveShaperNode.oversample
          };
          nativeWaveShaperNode = createNativeWaveShaperNode2(nativeOfflineAudioContext, options);
        }
        renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);
        if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);
        } else {
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);
        }
        return nativeWaveShaperNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);
          if (renderedNativeWaveShaperNode !== void 0) {
            return Promise.resolve(renderedNativeWaveShaperNode);
          }
          return createWaveShaperNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/window.js
  var createWindow = () => typeof window === "undefined" ? null : window;

  // node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods.js
  var createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong2, createIndexSizeError2) => {
    return (audioBuffer) => {
      audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
        const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
        const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
        if (channelNumber >= audioBuffer.numberOfChannels) {
          throw createIndexSizeError2();
        }
        const audioBufferLength = audioBuffer.length;
        const channelData = audioBuffer.getChannelData(channelNumber);
        const destinationLength = destination.length;
        for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {
          destination[i] = channelData[i + bufferOffset];
        }
      };
      audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
        const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
        const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
        if (channelNumber >= audioBuffer.numberOfChannels) {
          throw createIndexSizeError2();
        }
        const audioBufferLength = audioBuffer.length;
        const channelData = audioBuffer.getChannelData(channelNumber);
        const sourceLength = source.length;
        for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {
          channelData[i + bufferOffset] = source[i];
        }
      };
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js
  var createWrapAudioBufferCopyChannelMethodsOutOfBounds = (convertNumberToUnsignedLong2) => {
    return (audioBuffer) => {
      audioBuffer.copyFromChannel = ((copyFromChannel2) => {
        return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
          const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
          const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
          if (bufferOffset < audioBuffer.length) {
            return copyFromChannel2.call(audioBuffer, destination, channelNumber, bufferOffset);
          }
        };
      })(audioBuffer.copyFromChannel);
      audioBuffer.copyToChannel = ((copyToChannel2) => {
        return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
          const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
          const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
          if (bufferOffset < audioBuffer.length) {
            return copyToChannel2.call(audioBuffer, source, channelNumber, bufferOffset);
          }
        };
      })(audioBuffer.copyToChannel);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.js
  var createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = (overwriteAccessors2) => {
    return (nativeAudioBufferSourceNode, nativeContext) => {
      const nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);
      if (nativeAudioBufferSourceNode.buffer === null) {
        nativeAudioBufferSourceNode.buffer = nullifiedBuffer;
      }
      overwriteAccessors2(nativeAudioBufferSourceNode, "buffer", (get) => () => {
        const value = get.call(nativeAudioBufferSourceNode);
        return value === nullifiedBuffer ? null : value;
      }, (set2) => (value) => {
        return set2.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);
      });
    };
  };

  // node_modules/standardized-audio-context/build/es2019/factories/wrap-channel-merger-node.js
  var createWrapChannelMergerNode = (createInvalidStateError2, monitorConnections2) => {
    return (nativeContext, channelMergerNode) => {
      channelMergerNode.channelCount = 1;
      channelMergerNode.channelCountMode = "explicit";
      Object.defineProperty(channelMergerNode, "channelCount", {
        get: () => 1,
        set: () => {
          throw createInvalidStateError2();
        }
      });
      Object.defineProperty(channelMergerNode, "channelCountMode", {
        get: () => "explicit",
        set: () => {
          throw createInvalidStateError2();
        }
      });
      const audioBufferSourceNode = nativeContext.createBufferSource();
      const whenConnected = () => {
        const length = channelMergerNode.numberOfInputs;
        for (let i = 0; i < length; i += 1) {
          audioBufferSourceNode.connect(channelMergerNode, 0, i);
        }
      };
      const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);
      monitorConnections2(channelMergerNode, whenConnected, whenDisconnected);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/get-first-sample.js
  var getFirstSample = (audioBuffer, buffer, channelNumber) => {
    if (audioBuffer.copyFromChannel === void 0) {
      return audioBuffer.getChannelData(channelNumber)[0];
    }
    audioBuffer.copyFromChannel(buffer, channelNumber);
    return buffer[0];
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/is-dc-curve.js
  var isDCCurve = (curve) => {
    if (curve === null) {
      return false;
    }
    const length = curve.length;
    if (length % 2 !== 0) {
      return curve[Math.floor(length / 2)] !== 0;
    }
    return curve[length / 2 - 1] + curve[length / 2] !== 0;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/overwrite-accessors.js
  var overwriteAccessors = (object, property, createGetter, createSetter) => {
    let prototype = object;
    while (!prototype.hasOwnProperty(property)) {
      prototype = Object.getPrototypeOf(prototype);
    }
    const { get, set: set2 } = Object.getOwnPropertyDescriptor(prototype, property);
    Object.defineProperty(object, property, { get: createGetter(get), set: createSetter(set2) });
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/sanitize-audio-worklet-node-options.js
  var sanitizeAudioWorkletNodeOptions = (options) => {
    return __spreadProps(__spreadValues({}, options), {
      outputChannelCount: options.outputChannelCount !== void 0 ? options.outputChannelCount : options.numberOfInputs === 1 && options.numberOfOutputs === 1 ? [options.channelCount] : Array.from({ length: options.numberOfOutputs }, () => 1)
    });
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/sanitize-channel-splitter-options.js
  var sanitizeChannelSplitterOptions = (options) => {
    return __spreadProps(__spreadValues({}, options), { channelCount: options.numberOfOutputs });
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/sanitize-periodic-wave-options.js
  var sanitizePeriodicWaveOptions = (options) => {
    const { imag, real } = options;
    if (imag === void 0) {
      if (real === void 0) {
        return __spreadProps(__spreadValues({}, options), { imag: [0, 0], real: [0, 0] });
      }
      return __spreadProps(__spreadValues({}, options), { imag: Array.from(real, () => 0), real });
    }
    if (real === void 0) {
      return __spreadProps(__spreadValues({}, options), { imag, real: Array.from(imag, () => 0) });
    }
    return __spreadProps(__spreadValues({}, options), { imag, real });
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/set-value-at-time-until-possible.js
  var setValueAtTimeUntilPossible = (audioParam, value, startTime) => {
    try {
      audioParam.setValueAtTime(value, startTime);
    } catch (err) {
      if (err.code !== 9) {
        throw err;
      }
      setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);
    }
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support.js
  var testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (nativeContext) => {
    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
    nativeAudioBufferSourceNode.start();
    try {
      nativeAudioBufferSourceNode.start();
    } catch (e) {
      return true;
    }
    return false;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-start-method-offset-clamping-support.js
  var testAudioBufferSourceNodeStartMethodOffsetClampingSupport = (nativeContext) => {
    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);
    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
    try {
      nativeAudioBufferSourceNode.start(0, 1);
    } catch (e) {
      return false;
    }
    return true;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support.js
  var testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (nativeContext) => {
    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
    nativeAudioBufferSourceNode.start();
    try {
      nativeAudioBufferSourceNode.stop();
    } catch (e) {
      return false;
    }
    return true;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support.js
  var testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (nativeContext) => {
    const nativeAudioBufferSourceNode = nativeContext.createOscillator();
    try {
      nativeAudioBufferSourceNode.start(-1);
    } catch (err) {
      return err instanceof RangeError;
    }
    return false;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js
  var testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (nativeContext) => {
    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);
    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
    nativeAudioBufferSourceNode.start();
    nativeAudioBufferSourceNode.stop();
    try {
      nativeAudioBufferSourceNode.stop();
      return true;
    } catch (e) {
      return false;
    }
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js
  var testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (nativeContext) => {
    const nativeAudioBufferSourceNode = nativeContext.createOscillator();
    try {
      nativeAudioBufferSourceNode.stop(-1);
    } catch (err) {
      return err instanceof RangeError;
    }
    return false;
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/test-audio-worklet-node-options-clonability.js
  var testAudioWorkletNodeOptionsClonability = (audioWorkletNodeOptions) => {
    const { port1, port2 } = new MessageChannel();
    try {
      port1.postMessage(audioWorkletNodeOptions);
    } finally {
      port1.close();
      port2.close();
    }
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js
  var wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode) => {
    nativeAudioBufferSourceNode.start = ((start2) => {
      return (when = 0, offset = 0, duration) => {
        const buffer = nativeAudioBufferSourceNode.buffer;
        const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);
        if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {
          start2.call(nativeAudioBufferSourceNode, when, 0, 0);
        } else {
          start2.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);
        }
      };
    })(nativeAudioBufferSourceNode.start);
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js
  var wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (nativeAudioScheduledSourceNode, nativeContext) => {
    const nativeGainNode = nativeContext.createGain();
    nativeAudioScheduledSourceNode.connect(nativeGainNode);
    const disconnectGainNode = ((disconnect2) => {
      return () => {
        disconnect2.call(nativeAudioScheduledSourceNode, nativeGainNode);
        nativeAudioScheduledSourceNode.removeEventListener("ended", disconnectGainNode);
      };
    })(nativeAudioScheduledSourceNode.disconnect);
    nativeAudioScheduledSourceNode.addEventListener("ended", disconnectGainNode);
    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);
    nativeAudioScheduledSourceNode.stop = ((stop) => {
      let isStopped = false;
      return (when = 0) => {
        if (isStopped) {
          try {
            stop.call(nativeAudioScheduledSourceNode, when);
          } catch (e) {
            nativeGainNode.gain.setValueAtTime(0, when);
          }
        } else {
          stop.call(nativeAudioScheduledSourceNode, when);
          isStopped = true;
        }
      };
    })(nativeAudioScheduledSourceNode.stop);
  };

  // node_modules/standardized-audio-context/build/es2019/helpers/wrap-event-listener.js
  var wrapEventListener = (target, eventListener) => {
    return (event2) => {
      const descriptor = { value: target };
      Object.defineProperties(event2, {
        currentTarget: descriptor,
        target: descriptor
      });
      if (typeof eventListener === "function") {
        return eventListener.call(target, event2);
      }
      return eventListener.handleEvent.call(target, event2);
    };
  };

  // node_modules/standardized-audio-context/build/es2019/module.js
  var addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);
  var addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);
  var deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);
  var audioNodeTailTimeStore = new WeakMap();
  var getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);
  var cacheTestResult = createCacheTestResult(new Map(), new WeakMap());
  var window2 = createWindow();
  var createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError);
  var getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);
  var renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);
  var createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);
  var getNativeContext = createGetNativeContext(CONTEXT_STORE);
  var nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window2);
  var isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);
  var audioParamAudioNodeStore = new WeakMap();
  var eventTargetConstructor = createEventTargetConstructor(wrapEventListener);
  var nativeAudioContextConstructor = createNativeAudioContextConstructor(window2);
  var isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);
  var isNativeAudioNode2 = createIsNativeAudioNode(window2);
  var isNativeAudioParam = createIsNativeAudioParam(window2);
  var nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window2);
  var audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode), cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode2, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor);
  var analyserNodeConstructor = createAnalyserNodeConstructor(audioNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext);
  var audioBufferStore = new WeakSet();
  var nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window2);
  var convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));
  var wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);
  var wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);
  var audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
  var addSilentConnection = createAddSilentConnection(createNativeGainNode);
  var renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);
  var connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);
  var createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors), wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);
  var renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);
  var createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
  var createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, import_automation_events2.createCancelAndHoldAutomationEvent, import_automation_events2.createCancelScheduledValuesAutomationEvent, import_automation_events2.createExponentialRampToValueAutomationEvent, import_automation_events2.createLinearRampToValueAutomationEvent, import_automation_events2.createSetTargetAutomationEvent, import_automation_events2.createSetValueAutomationEvent, import_automation_events2.createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible);
  var audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);
  var audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);
  var createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
  var setAudioNodeTailTime = createSetAudioNodeTailTime(audioNodeTailTimeStore);
  var biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
  var monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode2);
  var wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, monitorConnections);
  var createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);
  var createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode);
  var channelMergerNodeConstructor = createChannelMergerNodeConstructor(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext);
  var createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode);
  var channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, sanitizeChannelSplitterOptions);
  var createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections);
  var createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);
  var createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
  var constantSourceNodeConstructor = createConstantSourceNodeConstructor(audioNodeConstructor, createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);
  var createNativeConvolverNode = createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors);
  var createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode);
  var convolverNodeConstructor = createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
  var createDelayNodeRenderer = createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
  var delayNodeConstructor = createDelayNodeConstructor(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
  var createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNotSupportedError);
  var createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
  var dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
  var createGainNodeRenderer = createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
  var gainNodeConstructor = createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext);
  var createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);
  var renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));
  var createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
  var createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker);
  var iIRFilterNodeConstructor = createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
  var createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors);
  var unrenderedAudioWorkletNodeStore = new WeakMap();
  var minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener);
  var createNativeOscillatorNode = createNativeOscillatorNodeFactory(addSilentConnection, cacheTestResult, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);
  var createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
  var oscillatorNodeConstructor = createOscillatorNodeConstructor(audioNodeConstructor, createAudioParam, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);
  var createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);
  var createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections);
  var createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors);
  var createNativePannerNodeFaker = createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, getFirstSample, monitorConnections);
  var createNativePannerNode = createNativePannerNodeFactory(createNativePannerNodeFaker);
  var createPannerNodeRenderer = createPannerNodeRendererFactory(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
  var pannerNodeConstructor = createPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
  var createNativePeriodicWave = createNativePeriodicWaveFactory(createIndexSizeError);
  var periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, new WeakSet(), sanitizePeriodicWaveOptions);
  var nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections);
  var createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory, createNotSupportedError);
  var createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
  var stereoPannerNodeConstructor = createStereoPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);
  var createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode);
  var waveShaperNodeConstructor = createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
  var isSecureContext = createIsSecureContext(window2);
  var exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window2);
  var backupOfflineAudioContextStore = new WeakMap();
  var getOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext(backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor);
  var addAudioWorkletModule = isSecureContext ? createAddAudioWorkletModule(cacheTestResult, createNotSupportedError, createEvaluateSource(window2), exposeCurrentFrameAndCurrentTime, createFetchSource(createAbortError), getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, new WeakMap(), new WeakMap(), createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), window2) : void 0;
  var isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);
  var decodeAudioData = createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, new WeakSet(), getNativeContext, isNativeContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
  var baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);
  var mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);
  var mediaStreamAudioDestinationNodeConstructor = createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext);
  var mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);
  var createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, isNativeOfflineAudioContext);
  var mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);
  var audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);
  var getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);
  var addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);
  var connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);
  var deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);
  var disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);
  var activeAudioWorkletNodeInputsStore = new WeakMap();
  var getActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey);
  var createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections);
  var createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections);
  var createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
  var getBackupOfflineAudioContext = createGetBackupOfflineAudioContext(backupOfflineAudioContextStore);
  var setActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore);
  var audioWorkletNodeConstructor = isSecureContext ? createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) : void 0;
  var minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);
  var createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor);
  var startRendering = createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
  var minimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering);
  var offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering);
  var isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);
  var isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode2);
  var isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);
  var isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);

  // node_modules/tone/build/esm/core/util/Debug.js
  function assert(statement, error2) {
    if (!statement) {
      throw new Error(error2);
    }
  }
  function assertRange(value, gte, lte = Infinity) {
    if (!(gte <= value && value <= lte)) {
      throw new RangeError(`Value must be within [${gte}, ${lte}], got: ${value}`);
    }
  }
  function assertContextRunning(context2) {
    if (!context2.isOffline && context2.state !== "running") {
      warn('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.');
    }
  }
  var defaultLogger = console;
  function log(...args) {
    defaultLogger.log(...args);
  }
  function warn(...args) {
    defaultLogger.warn(...args);
  }

  // node_modules/tone/build/esm/core/util/TypeCheck.js
  function isUndef(arg) {
    return typeof arg === "undefined";
  }
  function isDefined(arg) {
    return !isUndef(arg);
  }
  function isFunction(arg) {
    return typeof arg === "function";
  }
  function isNumber(arg) {
    return typeof arg === "number";
  }
  function isObject(arg) {
    return Object.prototype.toString.call(arg) === "[object Object]" && arg.constructor === Object;
  }
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  function isArray(arg) {
    return Array.isArray(arg);
  }
  function isString(arg) {
    return typeof arg === "string";
  }
  function isNote(arg) {
    return isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);
  }

  // node_modules/tone/build/esm/core/context/AudioContext.js
  function createAudioContext(options) {
    return new audioContextConstructor(options);
  }
  function createOfflineAudioContext(channels, length, sampleRate) {
    return new offlineAudioContextConstructor(channels, length, sampleRate);
  }
  var theWindow = typeof self === "object" ? self : null;
  var hasAudioContext = theWindow && (theWindow.hasOwnProperty("AudioContext") || theWindow.hasOwnProperty("webkitAudioContext"));
  function createAudioWorkletNode(context2, name2, options) {
    assert(isDefined(audioWorkletNodeConstructor), "This node only works in a secure context (https or localhost)");
    return new audioWorkletNodeConstructor(context2, name2, options);
  }

  // node_modules/tslib/tslib.es6.mjs
  function __decorate(decorators, target, key, desc) {
    var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d2 = decorators[i])
          r = (c2 < 3 ? d2(r) : c2 > 3 ? d2(target, key, r) : d2(target, key)) || r;
    return c2 > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }

  // node_modules/tone/build/esm/core/clock/Ticker.js
  var Ticker = class {
    constructor(callback2, type, updateInterval) {
      this._callback = callback2;
      this._type = type;
      this._updateInterval = updateInterval;
      this._createClock();
    }
    _createWorker() {
      const blob = new Blob([
        `
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval * 1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`
      ], { type: "text/javascript" });
      const blobUrl = URL.createObjectURL(blob);
      const worker = new Worker(blobUrl);
      worker.onmessage = this._callback.bind(this);
      this._worker = worker;
    }
    _createTimeout() {
      this._timeout = setTimeout(() => {
        this._createTimeout();
        this._callback();
      }, this._updateInterval * 1e3);
    }
    _createClock() {
      if (this._type === "worker") {
        try {
          this._createWorker();
        } catch (e) {
          this._type = "timeout";
          this._createClock();
        }
      } else if (this._type === "timeout") {
        this._createTimeout();
      }
    }
    _disposeClock() {
      if (this._timeout) {
        clearTimeout(this._timeout);
        this._timeout = 0;
      }
      if (this._worker) {
        this._worker.terminate();
        this._worker.onmessage = null;
      }
    }
    get updateInterval() {
      return this._updateInterval;
    }
    set updateInterval(interval) {
      this._updateInterval = Math.max(interval, 128 / 44100);
      if (this._type === "worker") {
        this._worker.postMessage(Math.max(interval * 1e3, 1));
      }
    }
    get type() {
      return this._type;
    }
    set type(type) {
      this._disposeClock();
      this._type = type;
      this._createClock();
    }
    dispose() {
      this._disposeClock();
    }
  };

  // node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js
  function isAudioParam(arg) {
    return isAnyAudioParam(arg);
  }
  function isAudioNode2(arg) {
    return isAnyAudioNode(arg);
  }
  function isOfflineAudioContext(arg) {
    return isAnyOfflineAudioContext(arg);
  }
  function isAudioContext(arg) {
    return isAnyAudioContext(arg);
  }
  function isAudioBuffer(arg) {
    return arg instanceof AudioBuffer;
  }

  // node_modules/tone/build/esm/core/util/Defaults.js
  function noCopy(key, arg) {
    return key === "value" || isAudioParam(arg) || isAudioNode2(arg) || isAudioBuffer(arg);
  }
  function deepMerge(target, ...sources) {
    if (!sources.length) {
      return target;
    }
    const source = sources.shift();
    if (isObject(target) && isObject(source)) {
      for (const key in source) {
        if (noCopy(key, source[key])) {
          target[key] = source[key];
        } else if (isObject(source[key])) {
          if (!target[key]) {
            Object.assign(target, { [key]: {} });
          }
          deepMerge(target[key], source[key]);
        } else {
          Object.assign(target, { [key]: source[key] });
        }
      }
    }
    return deepMerge(target, ...sources);
  }
  function deepEquals(arrayA, arrayB) {
    return arrayA.length === arrayB.length && arrayA.every((element, index3) => arrayB[index3] === element);
  }
  function optionsFromArguments(defaults4, argsArray, keys = [], objKey) {
    const opts = {};
    const args = Array.from(argsArray);
    if (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {
      const partOfDefaults = Object.keys(args[0]).some((key) => Reflect.has(defaults4, key));
      if (!partOfDefaults) {
        deepMerge(opts, { [objKey]: args[0] });
        keys.splice(keys.indexOf(objKey), 1);
        args.shift();
      }
    }
    if (args.length === 1 && isObject(args[0])) {
      deepMerge(opts, args[0]);
    } else {
      for (let i = 0; i < keys.length; i++) {
        if (isDefined(args[i])) {
          opts[keys[i]] = args[i];
        }
      }
    }
    return deepMerge(defaults4, opts);
  }
  function getDefaultsFromInstance(instance) {
    return instance.constructor.getDefaults();
  }
  function defaultArg(given, fallback) {
    if (isUndef(given)) {
      return fallback;
    } else {
      return given;
    }
  }
  function omitFromObject(obj, omit) {
    omit.forEach((prop) => {
      if (Reflect.has(obj, prop)) {
        delete obj[prop];
      }
    });
    return obj;
  }

  // node_modules/tone/build/esm/core/Tone.js
  var Tone = class {
    constructor() {
      this.debug = false;
      this._wasDisposed = false;
    }
    static getDefaults() {
      return {};
    }
    log(...args) {
      if (this.debug || theWindow && this.toString() === theWindow.TONE_DEBUG_CLASS) {
        log(this, ...args);
      }
    }
    dispose() {
      this._wasDisposed = true;
      return this;
    }
    get disposed() {
      return this._wasDisposed;
    }
    toString() {
      return this.name;
    }
  };
  Tone.version = version;

  // node_modules/tone/build/esm/core/util/Math.js
  var EPSILON = 1e-6;
  function GT(a, b) {
    return a > b + EPSILON;
  }
  function GTE(a, b) {
    return GT(a, b) || EQ(a, b);
  }
  function LT(a, b) {
    return a + EPSILON < b;
  }
  function EQ(a, b) {
    return Math.abs(a - b) < EPSILON;
  }
  function clamp(value, min, max) {
    return Math.max(Math.min(value, max), min);
  }

  // node_modules/tone/build/esm/core/util/Timeline.js
  var Timeline = class extends Tone {
    constructor() {
      super();
      this.name = "Timeline";
      this._timeline = [];
      const options = optionsFromArguments(Timeline.getDefaults(), arguments, ["memory"]);
      this.memory = options.memory;
      this.increasing = options.increasing;
    }
    static getDefaults() {
      return {
        memory: Infinity,
        increasing: false
      };
    }
    get length() {
      return this._timeline.length;
    }
    add(event2) {
      assert(Reflect.has(event2, "time"), "Timeline: events must have a time attribute");
      event2.time = event2.time.valueOf();
      if (this.increasing && this.length) {
        const lastValue = this._timeline[this.length - 1];
        assert(GTE(event2.time, lastValue.time), "The time must be greater than or equal to the last scheduled time");
        this._timeline.push(event2);
      } else {
        const index3 = this._search(event2.time);
        this._timeline.splice(index3 + 1, 0, event2);
      }
      if (this.length > this.memory) {
        const diff = this.length - this.memory;
        this._timeline.splice(0, diff);
      }
      return this;
    }
    remove(event2) {
      const index3 = this._timeline.indexOf(event2);
      if (index3 !== -1) {
        this._timeline.splice(index3, 1);
      }
      return this;
    }
    get(time, param = "time") {
      const index3 = this._search(time, param);
      if (index3 !== -1) {
        return this._timeline[index3];
      } else {
        return null;
      }
    }
    peek() {
      return this._timeline[0];
    }
    shift() {
      return this._timeline.shift();
    }
    getAfter(time, param = "time") {
      const index3 = this._search(time, param);
      if (index3 + 1 < this._timeline.length) {
        return this._timeline[index3 + 1];
      } else {
        return null;
      }
    }
    getBefore(time) {
      const len = this._timeline.length;
      if (len > 0 && this._timeline[len - 1].time < time) {
        return this._timeline[len - 1];
      }
      const index3 = this._search(time);
      if (index3 - 1 >= 0) {
        return this._timeline[index3 - 1];
      } else {
        return null;
      }
    }
    cancel(after) {
      if (this._timeline.length > 1) {
        let index3 = this._search(after);
        if (index3 >= 0) {
          if (EQ(this._timeline[index3].time, after)) {
            for (let i = index3; i >= 0; i--) {
              if (EQ(this._timeline[i].time, after)) {
                index3 = i;
              } else {
                break;
              }
            }
            this._timeline = this._timeline.slice(0, index3);
          } else {
            this._timeline = this._timeline.slice(0, index3 + 1);
          }
        } else {
          this._timeline = [];
        }
      } else if (this._timeline.length === 1) {
        if (GTE(this._timeline[0].time, after)) {
          this._timeline = [];
        }
      }
      return this;
    }
    cancelBefore(time) {
      const index3 = this._search(time);
      if (index3 >= 0) {
        this._timeline = this._timeline.slice(index3 + 1);
      }
      return this;
    }
    previousEvent(event2) {
      const index3 = this._timeline.indexOf(event2);
      if (index3 > 0) {
        return this._timeline[index3 - 1];
      } else {
        return null;
      }
    }
    _search(time, param = "time") {
      if (this._timeline.length === 0) {
        return -1;
      }
      let beginning = 0;
      const len = this._timeline.length;
      let end = len;
      if (len > 0 && this._timeline[len - 1][param] <= time) {
        return len - 1;
      }
      while (beginning < end) {
        let midPoint = Math.floor(beginning + (end - beginning) / 2);
        const event2 = this._timeline[midPoint];
        const nextEvent = this._timeline[midPoint + 1];
        if (EQ(event2[param], time)) {
          for (let i = midPoint; i < this._timeline.length; i++) {
            const testEvent = this._timeline[i];
            if (EQ(testEvent[param], time)) {
              midPoint = i;
            } else {
              break;
            }
          }
          return midPoint;
        } else if (LT(event2[param], time) && GT(nextEvent[param], time)) {
          return midPoint;
        } else if (GT(event2[param], time)) {
          end = midPoint;
        } else {
          beginning = midPoint + 1;
        }
      }
      return -1;
    }
    _iterate(callback2, lowerBound = 0, upperBound = this._timeline.length - 1) {
      this._timeline.slice(lowerBound, upperBound + 1).forEach(callback2);
    }
    forEach(callback2) {
      this._iterate(callback2);
      return this;
    }
    forEachBefore(time, callback2) {
      const upperBound = this._search(time);
      if (upperBound !== -1) {
        this._iterate(callback2, 0, upperBound);
      }
      return this;
    }
    forEachAfter(time, callback2) {
      const lowerBound = this._search(time);
      this._iterate(callback2, lowerBound + 1);
      return this;
    }
    forEachBetween(startTime, endTime, callback2) {
      let lowerBound = this._search(startTime);
      let upperBound = this._search(endTime);
      if (lowerBound !== -1 && upperBound !== -1) {
        if (this._timeline[lowerBound].time !== startTime) {
          lowerBound += 1;
        }
        if (this._timeline[upperBound].time === endTime) {
          upperBound -= 1;
        }
        this._iterate(callback2, lowerBound, upperBound);
      } else if (lowerBound === -1) {
        this._iterate(callback2, 0, upperBound);
      }
      return this;
    }
    forEachFrom(time, callback2) {
      let lowerBound = this._search(time);
      while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {
        lowerBound--;
      }
      this._iterate(callback2, lowerBound + 1);
      return this;
    }
    forEachAtTime(time, callback2) {
      const upperBound = this._search(time);
      if (upperBound !== -1 && EQ(this._timeline[upperBound].time, time)) {
        let lowerBound = upperBound;
        for (let i = upperBound; i >= 0; i--) {
          if (EQ(this._timeline[i].time, time)) {
            lowerBound = i;
          } else {
            break;
          }
        }
        this._iterate((event2) => {
          callback2(event2);
        }, lowerBound, upperBound);
      }
      return this;
    }
    dispose() {
      super.dispose();
      this._timeline = [];
      return this;
    }
  };

  // node_modules/tone/build/esm/core/context/ContextInitialization.js
  var notifyNewContext = [];
  function onContextInit(cb2) {
    notifyNewContext.push(cb2);
  }
  function initializeContext(ctx) {
    notifyNewContext.forEach((cb2) => cb2(ctx));
  }
  var notifyCloseContext = [];
  function onContextClose(cb2) {
    notifyCloseContext.push(cb2);
  }
  function closeContext(ctx) {
    notifyCloseContext.forEach((cb2) => cb2(ctx));
  }

  // node_modules/tone/build/esm/core/util/Emitter.js
  var Emitter = class extends Tone {
    constructor() {
      super(...arguments);
      this.name = "Emitter";
    }
    on(event2, callback2) {
      const events = event2.split(/\W+/);
      events.forEach((eventName) => {
        if (isUndef(this._events)) {
          this._events = {};
        }
        if (!this._events.hasOwnProperty(eventName)) {
          this._events[eventName] = [];
        }
        this._events[eventName].push(callback2);
      });
      return this;
    }
    once(event2, callback2) {
      const boundCallback = (...args) => {
        callback2(...args);
        this.off(event2, boundCallback);
      };
      this.on(event2, boundCallback);
      return this;
    }
    off(event2, callback2) {
      const events = event2.split(/\W+/);
      events.forEach((eventName) => {
        if (isUndef(this._events)) {
          this._events = {};
        }
        if (this._events.hasOwnProperty(event2)) {
          if (isUndef(callback2)) {
            this._events[event2] = [];
          } else {
            const eventList = this._events[event2];
            for (let i = eventList.length - 1; i >= 0; i--) {
              if (eventList[i] === callback2) {
                eventList.splice(i, 1);
              }
            }
          }
        }
      });
      return this;
    }
    emit(event2, ...args) {
      if (this._events) {
        if (this._events.hasOwnProperty(event2)) {
          const eventList = this._events[event2].slice(0);
          for (let i = 0, len = eventList.length; i < len; i++) {
            eventList[i].apply(this, args);
          }
        }
      }
      return this;
    }
    static mixin(constr) {
      ["on", "once", "off", "emit"].forEach((name2) => {
        const property = Object.getOwnPropertyDescriptor(Emitter.prototype, name2);
        Object.defineProperty(constr.prototype, name2, property);
      });
    }
    dispose() {
      super.dispose();
      this._events = void 0;
      return this;
    }
  };

  // node_modules/tone/build/esm/core/context/BaseContext.js
  var BaseContext = class extends Emitter {
    constructor() {
      super(...arguments);
      this.isOffline = false;
    }
    toJSON() {
      return {};
    }
  };

  // node_modules/tone/build/esm/core/context/Context.js
  var Context = class extends BaseContext {
    constructor() {
      super();
      this.name = "Context";
      this._constants = new Map();
      this._timeouts = new Timeline();
      this._timeoutIds = 0;
      this._initialized = false;
      this.isOffline = false;
      this._workletModules = new Map();
      const options = optionsFromArguments(Context.getDefaults(), arguments, [
        "context"
      ]);
      if (options.context) {
        this._context = options.context;
      } else {
        this._context = createAudioContext({
          latencyHint: options.latencyHint
        });
      }
      this._ticker = new Ticker(this.emit.bind(this, "tick"), options.clockSource, options.updateInterval);
      this.on("tick", this._timeoutLoop.bind(this));
      this._context.onstatechange = () => {
        this.emit("statechange", this.state);
      };
      this._setLatencyHint(options.latencyHint);
      this.lookAhead = options.lookAhead;
    }
    static getDefaults() {
      return {
        clockSource: "worker",
        latencyHint: "interactive",
        lookAhead: 0.1,
        updateInterval: 0.05
      };
    }
    initialize() {
      if (!this._initialized) {
        initializeContext(this);
        this._initialized = true;
      }
      return this;
    }
    createAnalyser() {
      return this._context.createAnalyser();
    }
    createOscillator() {
      return this._context.createOscillator();
    }
    createBufferSource() {
      return this._context.createBufferSource();
    }
    createBiquadFilter() {
      return this._context.createBiquadFilter();
    }
    createBuffer(numberOfChannels, length, sampleRate) {
      return this._context.createBuffer(numberOfChannels, length, sampleRate);
    }
    createChannelMerger(numberOfInputs) {
      return this._context.createChannelMerger(numberOfInputs);
    }
    createChannelSplitter(numberOfOutputs) {
      return this._context.createChannelSplitter(numberOfOutputs);
    }
    createConstantSource() {
      return this._context.createConstantSource();
    }
    createConvolver() {
      return this._context.createConvolver();
    }
    createDelay(maxDelayTime) {
      return this._context.createDelay(maxDelayTime);
    }
    createDynamicsCompressor() {
      return this._context.createDynamicsCompressor();
    }
    createGain() {
      return this._context.createGain();
    }
    createIIRFilter(feedForward, feedback) {
      return this._context.createIIRFilter(feedForward, feedback);
    }
    createPanner() {
      return this._context.createPanner();
    }
    createPeriodicWave(real, imag, constraints) {
      return this._context.createPeriodicWave(real, imag, constraints);
    }
    createStereoPanner() {
      return this._context.createStereoPanner();
    }
    createWaveShaper() {
      return this._context.createWaveShaper();
    }
    createMediaStreamSource(stream) {
      assert(isAudioContext(this._context), "Not available if OfflineAudioContext");
      const context2 = this._context;
      return context2.createMediaStreamSource(stream);
    }
    createMediaElementSource(element) {
      assert(isAudioContext(this._context), "Not available if OfflineAudioContext");
      const context2 = this._context;
      return context2.createMediaElementSource(element);
    }
    createMediaStreamDestination() {
      assert(isAudioContext(this._context), "Not available if OfflineAudioContext");
      const context2 = this._context;
      return context2.createMediaStreamDestination();
    }
    decodeAudioData(audioData) {
      return this._context.decodeAudioData(audioData);
    }
    get currentTime() {
      return this._context.currentTime;
    }
    get state() {
      return this._context.state;
    }
    get sampleRate() {
      return this._context.sampleRate;
    }
    get listener() {
      this.initialize();
      return this._listener;
    }
    set listener(l) {
      assert(!this._initialized, "The listener cannot be set after initialization.");
      this._listener = l;
    }
    get transport() {
      this.initialize();
      return this._transport;
    }
    set transport(t2) {
      assert(!this._initialized, "The transport cannot be set after initialization.");
      this._transport = t2;
    }
    get draw() {
      this.initialize();
      return this._draw;
    }
    set draw(d2) {
      assert(!this._initialized, "Draw cannot be set after initialization.");
      this._draw = d2;
    }
    get destination() {
      this.initialize();
      return this._destination;
    }
    set destination(d2) {
      assert(!this._initialized, "The destination cannot be set after initialization.");
      this._destination = d2;
    }
    createAudioWorkletNode(name2, options) {
      return createAudioWorkletNode(this.rawContext, name2, options);
    }
    addAudioWorkletModule(url, name2) {
      return __awaiter(this, void 0, void 0, function* () {
        assert(isDefined(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)");
        if (!this._workletModules.has(name2)) {
          this._workletModules.set(name2, this.rawContext.audioWorklet.addModule(url));
        }
        yield this._workletModules.get(name2);
      });
    }
    workletsAreReady() {
      return __awaiter(this, void 0, void 0, function* () {
        const promises = [];
        this._workletModules.forEach((promise) => promises.push(promise));
        yield Promise.all(promises);
      });
    }
    get updateInterval() {
      return this._ticker.updateInterval;
    }
    set updateInterval(interval) {
      this._ticker.updateInterval = interval;
    }
    get clockSource() {
      return this._ticker.type;
    }
    set clockSource(type) {
      this._ticker.type = type;
    }
    get latencyHint() {
      return this._latencyHint;
    }
    _setLatencyHint(hint) {
      let lookAheadValue = 0;
      this._latencyHint = hint;
      if (isString(hint)) {
        switch (hint) {
          case "interactive":
            lookAheadValue = 0.1;
            break;
          case "playback":
            lookAheadValue = 0.5;
            break;
          case "balanced":
            lookAheadValue = 0.25;
            break;
        }
      }
      this.lookAhead = lookAheadValue;
      this.updateInterval = lookAheadValue / 2;
    }
    get rawContext() {
      return this._context;
    }
    now() {
      return this._context.currentTime + this.lookAhead;
    }
    immediate() {
      return this._context.currentTime;
    }
    resume() {
      if (isAudioContext(this._context)) {
        return this._context.resume();
      } else {
        return Promise.resolve();
      }
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        if (isAudioContext(this._context)) {
          yield this._context.close();
        }
        if (this._initialized) {
          closeContext(this);
        }
      });
    }
    getConstant(val) {
      if (this._constants.has(val)) {
        return this._constants.get(val);
      } else {
        const buffer = this._context.createBuffer(1, 128, this._context.sampleRate);
        const arr = buffer.getChannelData(0);
        for (let i = 0; i < arr.length; i++) {
          arr[i] = val;
        }
        const constant = this._context.createBufferSource();
        constant.channelCount = 1;
        constant.channelCountMode = "explicit";
        constant.buffer = buffer;
        constant.loop = true;
        constant.start(0);
        this._constants.set(val, constant);
        return constant;
      }
    }
    dispose() {
      super.dispose();
      this._ticker.dispose();
      this._timeouts.dispose();
      Object.keys(this._constants).map((val) => this._constants[val].disconnect());
      return this;
    }
    _timeoutLoop() {
      const now = this.now();
      let firstEvent = this._timeouts.peek();
      while (this._timeouts.length && firstEvent && firstEvent.time <= now) {
        firstEvent.callback();
        this._timeouts.shift();
        firstEvent = this._timeouts.peek();
      }
    }
    setTimeout(fn2, timeout2) {
      this._timeoutIds++;
      const now = this.now();
      this._timeouts.add({
        callback: fn2,
        id: this._timeoutIds,
        time: now + timeout2
      });
      return this._timeoutIds;
    }
    clearTimeout(id2) {
      this._timeouts.forEach((event2) => {
        if (event2.id === id2) {
          this._timeouts.remove(event2);
        }
      });
      return this;
    }
    clearInterval(id2) {
      return this.clearTimeout(id2);
    }
    setInterval(fn2, interval) {
      const id2 = ++this._timeoutIds;
      const intervalFn = () => {
        const now = this.now();
        this._timeouts.add({
          callback: () => {
            fn2();
            intervalFn();
          },
          id: id2,
          time: now + interval
        });
      };
      intervalFn();
      return id2;
    }
  };

  // node_modules/tone/build/esm/core/context/DummyContext.js
  var DummyContext = class extends BaseContext {
    constructor() {
      super(...arguments);
      this.lookAhead = 0;
      this.latencyHint = 0;
      this.isOffline = false;
    }
    createAnalyser() {
      return {};
    }
    createOscillator() {
      return {};
    }
    createBufferSource() {
      return {};
    }
    createBiquadFilter() {
      return {};
    }
    createBuffer(_numberOfChannels, _length, _sampleRate) {
      return {};
    }
    createChannelMerger(_numberOfInputs) {
      return {};
    }
    createChannelSplitter(_numberOfOutputs) {
      return {};
    }
    createConstantSource() {
      return {};
    }
    createConvolver() {
      return {};
    }
    createDelay(_maxDelayTime) {
      return {};
    }
    createDynamicsCompressor() {
      return {};
    }
    createGain() {
      return {};
    }
    createIIRFilter(_feedForward, _feedback) {
      return {};
    }
    createPanner() {
      return {};
    }
    createPeriodicWave(_real, _imag, _constraints) {
      return {};
    }
    createStereoPanner() {
      return {};
    }
    createWaveShaper() {
      return {};
    }
    createMediaStreamSource(_stream) {
      return {};
    }
    createMediaElementSource(_element) {
      return {};
    }
    createMediaStreamDestination() {
      return {};
    }
    decodeAudioData(_audioData) {
      return Promise.resolve({});
    }
    createAudioWorkletNode(_name, _options) {
      return {};
    }
    get rawContext() {
      return {};
    }
    addAudioWorkletModule(_url, _name) {
      return __awaiter(this, void 0, void 0, function* () {
        return Promise.resolve();
      });
    }
    resume() {
      return Promise.resolve();
    }
    setTimeout(_fn, _timeout) {
      return 0;
    }
    clearTimeout(_id) {
      return this;
    }
    setInterval(_fn, _interval) {
      return 0;
    }
    clearInterval(_id) {
      return this;
    }
    getConstant(_val) {
      return {};
    }
    get currentTime() {
      return 0;
    }
    get state() {
      return {};
    }
    get sampleRate() {
      return 0;
    }
    get listener() {
      return {};
    }
    get transport() {
      return {};
    }
    get draw() {
      return {};
    }
    set draw(_d2) {
    }
    get destination() {
      return {};
    }
    set destination(_d2) {
    }
    now() {
      return 0;
    }
    immediate() {
      return 0;
    }
  };

  // node_modules/tone/build/esm/core/util/Interface.js
  function readOnly(target, property) {
    if (isArray(property)) {
      property.forEach((str) => readOnly(target, str));
    } else {
      Object.defineProperty(target, property, {
        enumerable: true,
        writable: false
      });
    }
  }
  function writable(target, property) {
    if (isArray(property)) {
      property.forEach((str) => writable(target, str));
    } else {
      Object.defineProperty(target, property, {
        writable: true
      });
    }
  }
  var noOp = () => {
  };

  // node_modules/tone/build/esm/core/context/ToneAudioBuffer.js
  var ToneAudioBuffer = class extends Tone {
    constructor() {
      super();
      this.name = "ToneAudioBuffer";
      this.onload = noOp;
      const options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, ["url", "onload", "onerror"]);
      this.reverse = options.reverse;
      this.onload = options.onload;
      if (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {
        this.set(options.url);
      } else if (isString(options.url)) {
        this.load(options.url).catch(options.onerror);
      }
    }
    static getDefaults() {
      return {
        onerror: noOp,
        onload: noOp,
        reverse: false
      };
    }
    get sampleRate() {
      if (this._buffer) {
        return this._buffer.sampleRate;
      } else {
        return getContext().sampleRate;
      }
    }
    set(buffer) {
      if (buffer instanceof ToneAudioBuffer) {
        if (buffer.loaded) {
          this._buffer = buffer.get();
        } else {
          buffer.onload = () => {
            this.set(buffer);
            this.onload(this);
          };
        }
      } else {
        this._buffer = buffer;
      }
      if (this._reversed) {
        this._reverse();
      }
      return this;
    }
    get() {
      return this._buffer;
    }
    load(url) {
      return __awaiter(this, void 0, void 0, function* () {
        const doneLoading = ToneAudioBuffer.load(url).then((audioBuffer) => {
          this.set(audioBuffer);
          this.onload(this);
        });
        ToneAudioBuffer.downloads.push(doneLoading);
        try {
          yield doneLoading;
        } finally {
          const index3 = ToneAudioBuffer.downloads.indexOf(doneLoading);
          ToneAudioBuffer.downloads.splice(index3, 1);
        }
        return this;
      });
    }
    dispose() {
      super.dispose();
      this._buffer = void 0;
      return this;
    }
    fromArray(array) {
      const isMultidimensional = isArray(array) && array[0].length > 0;
      const channels = isMultidimensional ? array.length : 1;
      const len = isMultidimensional ? array[0].length : array.length;
      const context2 = getContext();
      const buffer = context2.createBuffer(channels, len, context2.sampleRate);
      const multiChannelArray = !isMultidimensional && channels === 1 ? [array] : array;
      for (let c2 = 0; c2 < channels; c2++) {
        buffer.copyToChannel(multiChannelArray[c2], c2);
      }
      this._buffer = buffer;
      return this;
    }
    toMono(chanNum) {
      if (isNumber(chanNum)) {
        this.fromArray(this.toArray(chanNum));
      } else {
        let outputArray = new Float32Array(this.length);
        const numChannels = this.numberOfChannels;
        for (let channel = 0; channel < numChannels; channel++) {
          const channelArray = this.toArray(channel);
          for (let i = 0; i < channelArray.length; i++) {
            outputArray[i] += channelArray[i];
          }
        }
        outputArray = outputArray.map((sample2) => sample2 / numChannels);
        this.fromArray(outputArray);
      }
      return this;
    }
    toArray(channel) {
      if (isNumber(channel)) {
        return this.getChannelData(channel);
      } else if (this.numberOfChannels === 1) {
        return this.toArray(0);
      } else {
        const ret = [];
        for (let c2 = 0; c2 < this.numberOfChannels; c2++) {
          ret[c2] = this.getChannelData(c2);
        }
        return ret;
      }
    }
    getChannelData(channel) {
      if (this._buffer) {
        return this._buffer.getChannelData(channel);
      } else {
        return new Float32Array(0);
      }
    }
    slice(start2, end = this.duration) {
      const startSamples = Math.floor(start2 * this.sampleRate);
      const endSamples = Math.floor(end * this.sampleRate);
      assert(startSamples < endSamples, "The start time must be less than the end time");
      const length = endSamples - startSamples;
      const retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);
      for (let channel = 0; channel < this.numberOfChannels; channel++) {
        retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);
      }
      return new ToneAudioBuffer(retBuffer);
    }
    _reverse() {
      if (this.loaded) {
        for (let i = 0; i < this.numberOfChannels; i++) {
          this.getChannelData(i).reverse();
        }
      }
      return this;
    }
    get loaded() {
      return this.length > 0;
    }
    get duration() {
      if (this._buffer) {
        return this._buffer.duration;
      } else {
        return 0;
      }
    }
    get length() {
      if (this._buffer) {
        return this._buffer.length;
      } else {
        return 0;
      }
    }
    get numberOfChannels() {
      if (this._buffer) {
        return this._buffer.numberOfChannels;
      } else {
        return 0;
      }
    }
    get reverse() {
      return this._reversed;
    }
    set reverse(rev) {
      if (this._reversed !== rev) {
        this._reversed = rev;
        this._reverse();
      }
    }
    static fromArray(array) {
      return new ToneAudioBuffer().fromArray(array);
    }
    static fromUrl(url) {
      return __awaiter(this, void 0, void 0, function* () {
        const buffer = new ToneAudioBuffer();
        return yield buffer.load(url);
      });
    }
    static load(url) {
      return __awaiter(this, void 0, void 0, function* () {
        const matches2 = url.match(/\[([^\]\[]+\|.+)\]$/);
        if (matches2) {
          const extensions = matches2[1].split("|");
          let extension = extensions[0];
          for (const ext of extensions) {
            if (ToneAudioBuffer.supportsType(ext)) {
              extension = ext;
              break;
            }
          }
          url = url.replace(matches2[0], extension);
        }
        const baseUrl = ToneAudioBuffer.baseUrl === "" || ToneAudioBuffer.baseUrl.endsWith("/") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + "/";
        const response = yield fetch(baseUrl + url);
        if (!response.ok) {
          throw new Error(`could not load url: ${url}`);
        }
        const arrayBuffer = yield response.arrayBuffer();
        const audioBuffer = yield getContext().decodeAudioData(arrayBuffer);
        return audioBuffer;
      });
    }
    static supportsType(url) {
      const extensions = url.split(".");
      const extension = extensions[extensions.length - 1];
      const response = document.createElement("audio").canPlayType("audio/" + extension);
      return response !== "";
    }
    static loaded() {
      return __awaiter(this, void 0, void 0, function* () {
        yield Promise.resolve();
        while (ToneAudioBuffer.downloads.length) {
          yield ToneAudioBuffer.downloads[0];
        }
      });
    }
  };
  ToneAudioBuffer.baseUrl = "";
  ToneAudioBuffer.downloads = [];

  // node_modules/tone/build/esm/core/context/OfflineContext.js
  var OfflineContext = class extends Context {
    constructor() {
      super({
        clockSource: "offline",
        context: isOfflineAudioContext(arguments[0]) ? arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),
        lookAhead: 0,
        updateInterval: isOfflineAudioContext(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
      });
      this.name = "OfflineContext";
      this._currentTime = 0;
      this.isOffline = true;
      this._duration = isOfflineAudioContext(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];
    }
    now() {
      return this._currentTime;
    }
    get currentTime() {
      return this._currentTime;
    }
    _renderClock(asynchronous) {
      return __awaiter(this, void 0, void 0, function* () {
        let index3 = 0;
        while (this._duration - this._currentTime >= 0) {
          this.emit("tick");
          this._currentTime += 128 / this.sampleRate;
          index3++;
          const yieldEvery = Math.floor(this.sampleRate / 128);
          if (asynchronous && index3 % yieldEvery === 0) {
            yield new Promise((done) => setTimeout(done, 1));
          }
        }
      });
    }
    render(asynchronous = true) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.workletsAreReady();
        yield this._renderClock(asynchronous);
        const buffer = yield this._context.startRendering();
        return new ToneAudioBuffer(buffer);
      });
    }
    close() {
      return Promise.resolve();
    }
  };

  // node_modules/tone/build/esm/core/Global.js
  var dummyContext = new DummyContext();
  var globalContext = dummyContext;
  function getContext() {
    if (globalContext === dummyContext && hasAudioContext) {
      setContext(new Context());
    }
    return globalContext;
  }
  function setContext(context2) {
    if (isAudioContext(context2)) {
      globalContext = new Context(context2);
    } else if (isOfflineAudioContext(context2)) {
      globalContext = new OfflineContext(context2);
    } else {
      globalContext = context2;
    }
  }
  if (theWindow && !theWindow.TONE_SILENCE_LOGGING) {
    let prefix = "v";
    if (version === "dev") {
      prefix = "";
    }
    const printString = ` * Tone.js ${prefix}${version} * `;
    console.log(`%c${printString}`, "background: #000; color: #fff");
  }

  // node_modules/tone/build/esm/core/type/Conversions.js
  function dbToGain(db2) {
    return Math.pow(10, db2 / 20);
  }
  function gainToDb(gain) {
    return 20 * (Math.log(gain) / Math.LN10);
  }
  function intervalToFrequencyRatio(interval) {
    return Math.pow(2, interval / 12);
  }
  var A4 = 440;
  function getA4() {
    return A4;
  }
  function setA4(freq) {
    A4 = freq;
  }
  function ftom(frequency) {
    return Math.round(ftomf(frequency));
  }
  function ftomf(frequency) {
    return 69 + 12 * Math.log2(frequency / A4);
  }
  function mtof(midi) {
    return A4 * Math.pow(2, (midi - 69) / 12);
  }

  // node_modules/tone/build/esm/core/type/TimeBase.js
  var TimeBaseClass = class extends Tone {
    constructor(context2, value, units) {
      super();
      this.defaultUnits = "s";
      this._val = value;
      this._units = units;
      this.context = context2;
      this._expressions = this._getExpressions();
    }
    _getExpressions() {
      return {
        hz: {
          method: (value) => {
            return this._frequencyToUnits(parseFloat(value));
          },
          regexp: /^(\d+(?:\.\d+)?)hz$/i
        },
        i: {
          method: (value) => {
            return this._ticksToUnits(parseInt(value, 10));
          },
          regexp: /^(\d+)i$/i
        },
        m: {
          method: (value) => {
            return this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());
          },
          regexp: /^(\d+)m$/i
        },
        n: {
          method: (value, dot) => {
            const numericValue = parseInt(value, 10);
            const scalar = dot === "." ? 1.5 : 1;
            if (numericValue === 1) {
              return this._beatsToUnits(this._getTimeSignature()) * scalar;
            } else {
              return this._beatsToUnits(4 / numericValue) * scalar;
            }
          },
          regexp: /^(\d+)n(\.?)$/i
        },
        number: {
          method: (value) => {
            return this._expressions[this.defaultUnits].method.call(this, value);
          },
          regexp: /^(\d+(?:\.\d+)?)$/
        },
        s: {
          method: (value) => {
            return this._secondsToUnits(parseFloat(value));
          },
          regexp: /^(\d+(?:\.\d+)?)s$/
        },
        samples: {
          method: (value) => {
            return parseInt(value, 10) / this.context.sampleRate;
          },
          regexp: /^(\d+)samples$/
        },
        t: {
          method: (value) => {
            const numericValue = parseInt(value, 10);
            return this._beatsToUnits(8 / (Math.floor(numericValue) * 3));
          },
          regexp: /^(\d+)t$/i
        },
        tr: {
          method: (m, q2, s) => {
            let total = 0;
            if (m && m !== "0") {
              total += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));
            }
            if (q2 && q2 !== "0") {
              total += this._beatsToUnits(parseFloat(q2));
            }
            if (s && s !== "0") {
              total += this._beatsToUnits(parseFloat(s) / 4);
            }
            return total;
          },
          regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
        }
      };
    }
    valueOf() {
      if (this._val instanceof TimeBaseClass) {
        this.fromType(this._val);
      }
      if (isUndef(this._val)) {
        return this._noArg();
      } else if (isString(this._val) && isUndef(this._units)) {
        for (const units in this._expressions) {
          if (this._expressions[units].regexp.test(this._val.trim())) {
            this._units = units;
            break;
          }
        }
      } else if (isObject(this._val)) {
        let total = 0;
        for (const typeName2 in this._val) {
          if (isDefined(this._val[typeName2])) {
            const quantity = this._val[typeName2];
            const time = new this.constructor(this.context, typeName2).valueOf() * quantity;
            total += time;
          }
        }
        return total;
      }
      if (isDefined(this._units)) {
        const expr = this._expressions[this._units];
        const matching = this._val.toString().trim().match(expr.regexp);
        if (matching) {
          return expr.method.apply(this, matching.slice(1));
        } else {
          return expr.method.call(this, this._val);
        }
      } else if (isString(this._val)) {
        return parseFloat(this._val);
      } else {
        return this._val;
      }
    }
    _frequencyToUnits(freq) {
      return 1 / freq;
    }
    _beatsToUnits(beats) {
      return 60 / this._getBpm() * beats;
    }
    _secondsToUnits(seconds) {
      return seconds;
    }
    _ticksToUnits(ticks) {
      return ticks * this._beatsToUnits(1) / this._getPPQ();
    }
    _noArg() {
      return this._now();
    }
    _getBpm() {
      return this.context.transport.bpm.value;
    }
    _getTimeSignature() {
      return this.context.transport.timeSignature;
    }
    _getPPQ() {
      return this.context.transport.PPQ;
    }
    fromType(type) {
      this._units = void 0;
      switch (this.defaultUnits) {
        case "s":
          this._val = type.toSeconds();
          break;
        case "i":
          this._val = type.toTicks();
          break;
        case "hz":
          this._val = type.toFrequency();
          break;
        case "midi":
          this._val = type.toMidi();
          break;
      }
      return this;
    }
    toFrequency() {
      return 1 / this.toSeconds();
    }
    toSamples() {
      return this.toSeconds() * this.context.sampleRate;
    }
    toMilliseconds() {
      return this.toSeconds() * 1e3;
    }
  };

  // node_modules/tone/build/esm/core/type/Time.js
  var TimeClass = class extends TimeBaseClass {
    constructor() {
      super(...arguments);
      this.name = "TimeClass";
    }
    _getExpressions() {
      return Object.assign(super._getExpressions(), {
        now: {
          method: (capture) => {
            return this._now() + new this.constructor(this.context, capture).valueOf();
          },
          regexp: /^\+(.+)/
        },
        quantize: {
          method: (capture) => {
            const quantTo = new TimeClass(this.context, capture).valueOf();
            return this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));
          },
          regexp: /^@(.+)/
        }
      });
    }
    quantize(subdiv, percent = 1) {
      const subdivision = new this.constructor(this.context, subdiv).valueOf();
      const value = this.valueOf();
      const multiple = Math.round(value / subdivision);
      const ideal = multiple * subdivision;
      const diff = ideal - value;
      return value + diff * percent;
    }
    toNotation() {
      const time = this.toSeconds();
      const testNotations = ["1m"];
      for (let power = 1; power < 9; power++) {
        const subdiv = Math.pow(2, power);
        testNotations.push(subdiv + "n.");
        testNotations.push(subdiv + "n");
        testNotations.push(subdiv + "t");
      }
      testNotations.push("0");
      let closest2 = testNotations[0];
      let closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();
      testNotations.forEach((notation) => {
        const notationSeconds = new TimeClass(this.context, notation).toSeconds();
        if (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {
          closest2 = notation;
          closestSeconds = notationSeconds;
        }
      });
      return closest2;
    }
    toBarsBeatsSixteenths() {
      const quarterTime = this._beatsToUnits(1);
      let quarters = this.valueOf() / quarterTime;
      quarters = parseFloat(quarters.toFixed(4));
      const measures = Math.floor(quarters / this._getTimeSignature());
      let sixteenths = quarters % 1 * 4;
      quarters = Math.floor(quarters) % this._getTimeSignature();
      const sixteenthString = sixteenths.toString();
      if (sixteenthString.length > 3) {
        sixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));
      }
      const progress = [measures, quarters, sixteenths];
      return progress.join(":");
    }
    toTicks() {
      const quarterTime = this._beatsToUnits(1);
      const quarters = this.valueOf() / quarterTime;
      return Math.round(quarters * this._getPPQ());
    }
    toSeconds() {
      return this.valueOf();
    }
    toMidi() {
      return ftom(this.toFrequency());
    }
    _now() {
      return this.context.now();
    }
  };

  // node_modules/tone/build/esm/core/type/Frequency.js
  var FrequencyClass = class extends TimeClass {
    constructor() {
      super(...arguments);
      this.name = "Frequency";
      this.defaultUnits = "hz";
    }
    static get A4() {
      return getA4();
    }
    static set A4(freq) {
      setA4(freq);
    }
    _getExpressions() {
      return Object.assign({}, super._getExpressions(), {
        midi: {
          regexp: /^(\d+(?:\.\d+)?midi)/,
          method(value) {
            if (this.defaultUnits === "midi") {
              return value;
            } else {
              return FrequencyClass.mtof(value);
            }
          }
        },
        note: {
          regexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,
          method(pitch, octave) {
            const index3 = noteToScaleIndex[pitch.toLowerCase()];
            const noteNumber = index3 + (parseInt(octave, 10) + 1) * 12;
            if (this.defaultUnits === "midi") {
              return noteNumber;
            } else {
              return FrequencyClass.mtof(noteNumber);
            }
          }
        },
        tr: {
          regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
          method(m, q2, s) {
            let total = 1;
            if (m && m !== "0") {
              total *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));
            }
            if (q2 && q2 !== "0") {
              total *= this._beatsToUnits(parseFloat(q2));
            }
            if (s && s !== "0") {
              total *= this._beatsToUnits(parseFloat(s) / 4);
            }
            return total;
          }
        }
      });
    }
    transpose(interval) {
      return new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));
    }
    harmonize(intervals) {
      return intervals.map((interval) => {
        return this.transpose(interval);
      });
    }
    toMidi() {
      return ftom(this.valueOf());
    }
    toNote() {
      const freq = this.toFrequency();
      const log2 = Math.log2(freq / FrequencyClass.A4);
      let noteNumber = Math.round(12 * log2) + 57;
      const octave = Math.floor(noteNumber / 12);
      if (octave < 0) {
        noteNumber += -12 * octave;
      }
      const noteName = scaleIndexToNote[noteNumber % 12];
      return noteName + octave.toString();
    }
    toSeconds() {
      return 1 / super.toSeconds();
    }
    toTicks() {
      const quarterTime = this._beatsToUnits(1);
      const quarters = this.valueOf() / quarterTime;
      return Math.floor(quarters * this._getPPQ());
    }
    _noArg() {
      return 0;
    }
    _frequencyToUnits(freq) {
      return freq;
    }
    _ticksToUnits(ticks) {
      return 1 / (ticks * 60 / (this._getBpm() * this._getPPQ()));
    }
    _beatsToUnits(beats) {
      return 1 / super._beatsToUnits(beats);
    }
    _secondsToUnits(seconds) {
      return 1 / seconds;
    }
    static mtof(midi) {
      return mtof(midi);
    }
    static ftom(frequency) {
      return ftom(frequency);
    }
  };
  var noteToScaleIndex = {
    cbb: -2,
    cb: -1,
    c: 0,
    "c#": 1,
    cx: 2,
    dbb: 0,
    db: 1,
    d: 2,
    "d#": 3,
    dx: 4,
    ebb: 2,
    eb: 3,
    e: 4,
    "e#": 5,
    ex: 6,
    fbb: 3,
    fb: 4,
    f: 5,
    "f#": 6,
    fx: 7,
    gbb: 5,
    gb: 6,
    g: 7,
    "g#": 8,
    gx: 9,
    abb: 7,
    ab: 8,
    a: 9,
    "a#": 10,
    ax: 11,
    bbb: 9,
    bb: 10,
    b: 11,
    "b#": 12,
    bx: 13
  };
  var scaleIndexToNote = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

  // node_modules/tone/build/esm/core/type/TransportTime.js
  var TransportTimeClass = class extends TimeClass {
    constructor() {
      super(...arguments);
      this.name = "TransportTime";
    }
    _now() {
      return this.context.transport.seconds;
    }
  };

  // node_modules/tone/build/esm/core/context/ToneWithContext.js
  var ToneWithContext = class extends Tone {
    constructor() {
      super();
      const options = optionsFromArguments(ToneWithContext.getDefaults(), arguments, ["context"]);
      if (this.defaultContext) {
        this.context = this.defaultContext;
      } else {
        this.context = options.context;
      }
    }
    static getDefaults() {
      return {
        context: getContext()
      };
    }
    now() {
      return this.context.currentTime + this.context.lookAhead;
    }
    immediate() {
      return this.context.currentTime;
    }
    get sampleTime() {
      return 1 / this.context.sampleRate;
    }
    get blockTime() {
      return 128 / this.context.sampleRate;
    }
    toSeconds(time) {
      return new TimeClass(this.context, time).toSeconds();
    }
    toFrequency(freq) {
      return new FrequencyClass(this.context, freq).toFrequency();
    }
    toTicks(time) {
      return new TransportTimeClass(this.context, time).toTicks();
    }
    _getPartialProperties(props) {
      const options = this.get();
      Object.keys(options).forEach((name2) => {
        if (isUndef(props[name2])) {
          delete options[name2];
        }
      });
      return options;
    }
    get() {
      const defaults4 = getDefaultsFromInstance(this);
      Object.keys(defaults4).forEach((attribute) => {
        if (Reflect.has(this, attribute)) {
          const member = this[attribute];
          if (isDefined(member) && isDefined(member.value) && isDefined(member.setValueAtTime)) {
            defaults4[attribute] = member.value;
          } else if (member instanceof ToneWithContext) {
            defaults4[attribute] = member._getPartialProperties(defaults4[attribute]);
          } else if (isArray(member) || isNumber(member) || isString(member) || isBoolean(member)) {
            defaults4[attribute] = member;
          } else {
            delete defaults4[attribute];
          }
        }
      });
      return defaults4;
    }
    set(props) {
      Object.keys(props).forEach((attribute) => {
        if (Reflect.has(this, attribute) && isDefined(this[attribute])) {
          if (this[attribute] && isDefined(this[attribute].value) && isDefined(this[attribute].setValueAtTime)) {
            if (this[attribute].value !== props[attribute]) {
              this[attribute].value = props[attribute];
            }
          } else if (this[attribute] instanceof ToneWithContext) {
            this[attribute].set(props[attribute]);
          } else {
            this[attribute] = props[attribute];
          }
        }
      });
      return this;
    }
  };

  // node_modules/tone/build/esm/core/util/StateTimeline.js
  var StateTimeline = class extends Timeline {
    constructor(initial = "stopped") {
      super();
      this.name = "StateTimeline";
      this._initial = initial;
      this.setStateAtTime(this._initial, 0);
    }
    getValueAtTime(time) {
      const event2 = this.get(time);
      if (event2 !== null) {
        return event2.state;
      } else {
        return this._initial;
      }
    }
    setStateAtTime(state, time, options) {
      assertRange(time, 0);
      this.add(Object.assign({}, options, {
        state,
        time
      }));
      return this;
    }
    getLastState(state, time) {
      const index3 = this._search(time);
      for (let i = index3; i >= 0; i--) {
        const event2 = this._timeline[i];
        if (event2.state === state) {
          return event2;
        }
      }
    }
    getNextState(state, time) {
      const index3 = this._search(time);
      if (index3 !== -1) {
        for (let i = index3; i < this._timeline.length; i++) {
          const event2 = this._timeline[i];
          if (event2.state === state) {
            return event2;
          }
        }
      }
    }
  };

  // node_modules/tone/build/esm/core/context/Param.js
  var Param = class extends ToneWithContext {
    constructor() {
      super(optionsFromArguments(Param.getDefaults(), arguments, ["param", "units", "convert"]));
      this.name = "Param";
      this.overridden = false;
      this._minOutput = 1e-7;
      const options = optionsFromArguments(Param.getDefaults(), arguments, ["param", "units", "convert"]);
      assert(isDefined(options.param) && (isAudioParam(options.param) || options.param instanceof Param), "param must be an AudioParam");
      while (!isAudioParam(options.param)) {
        options.param = options.param._param;
      }
      this._swappable = isDefined(options.swappable) ? options.swappable : false;
      if (this._swappable) {
        this.input = this.context.createGain();
        this._param = options.param;
        this.input.connect(this._param);
      } else {
        this._param = this.input = options.param;
      }
      this._events = new Timeline(1e3);
      this._initialValue = this._param.defaultValue;
      this.units = options.units;
      this.convert = options.convert;
      this._minValue = options.minValue;
      this._maxValue = options.maxValue;
      if (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {
        this.setValueAtTime(options.value, 0);
      }
    }
    static getDefaults() {
      return Object.assign(ToneWithContext.getDefaults(), {
        convert: true,
        units: "number"
      });
    }
    get value() {
      const now = this.now();
      return this.getValueAtTime(now);
    }
    set value(value) {
      this.cancelScheduledValues(this.now());
      this.setValueAtTime(value, this.now());
    }
    get minValue() {
      if (isDefined(this._minValue)) {
        return this._minValue;
      } else if (this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples") {
        return 0;
      } else if (this.units === "audioRange") {
        return -1;
      } else if (this.units === "decibels") {
        return -Infinity;
      } else {
        return this._param.minValue;
      }
    }
    get maxValue() {
      if (isDefined(this._maxValue)) {
        return this._maxValue;
      } else if (this.units === "normalRange" || this.units === "audioRange") {
        return 1;
      } else {
        return this._param.maxValue;
      }
    }
    _is(arg, type) {
      return this.units === type;
    }
    _assertRange(value) {
      if (isDefined(this.maxValue) && isDefined(this.minValue)) {
        assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));
      }
      return value;
    }
    _fromType(val) {
      if (this.convert && !this.overridden) {
        if (this._is(val, "time")) {
          return this.toSeconds(val);
        } else if (this._is(val, "decibels")) {
          return dbToGain(val);
        } else if (this._is(val, "frequency")) {
          return this.toFrequency(val);
        } else {
          return val;
        }
      } else if (this.overridden) {
        return 0;
      } else {
        return val;
      }
    }
    _toType(val) {
      if (this.convert && this.units === "decibels") {
        return gainToDb(val);
      } else {
        return val;
      }
    }
    setValueAtTime(value, time) {
      const computedTime = this.toSeconds(time);
      const numericValue = this._fromType(value);
      assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);
      this._assertRange(numericValue);
      this.log(this.units, "setValueAtTime", value, computedTime);
      this._events.add({
        time: computedTime,
        type: "setValueAtTime",
        value: numericValue
      });
      this._param.setValueAtTime(numericValue, computedTime);
      return this;
    }
    getValueAtTime(time) {
      const computedTime = Math.max(this.toSeconds(time), 0);
      const after = this._events.getAfter(computedTime);
      const before = this._events.get(computedTime);
      let value = this._initialValue;
      if (before === null) {
        value = this._initialValue;
      } else if (before.type === "setTargetAtTime" && (after === null || after.type === "setValueAtTime")) {
        const previous = this._events.getBefore(before.time);
        let previousVal;
        if (previous === null) {
          previousVal = this._initialValue;
        } else {
          previousVal = previous.value;
        }
        if (before.type === "setTargetAtTime") {
          value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);
        }
      } else if (after === null) {
        value = before.value;
      } else if (after.type === "linearRampToValueAtTime" || after.type === "exponentialRampToValueAtTime") {
        let beforeValue = before.value;
        if (before.type === "setTargetAtTime") {
          const previous = this._events.getBefore(before.time);
          if (previous === null) {
            beforeValue = this._initialValue;
          } else {
            beforeValue = previous.value;
          }
        }
        if (after.type === "linearRampToValueAtTime") {
          value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);
        } else {
          value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);
        }
      } else {
        value = before.value;
      }
      return this._toType(value);
    }
    setRampPoint(time) {
      time = this.toSeconds(time);
      let currentVal = this.getValueAtTime(time);
      this.cancelAndHoldAtTime(time);
      if (this._fromType(currentVal) === 0) {
        currentVal = this._toType(this._minOutput);
      }
      this.setValueAtTime(currentVal, time);
      return this;
    }
    linearRampToValueAtTime(value, endTime) {
      const numericValue = this._fromType(value);
      const computedTime = this.toSeconds(endTime);
      assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);
      this._assertRange(numericValue);
      this._events.add({
        time: computedTime,
        type: "linearRampToValueAtTime",
        value: numericValue
      });
      this.log(this.units, "linearRampToValueAtTime", value, computedTime);
      this._param.linearRampToValueAtTime(numericValue, computedTime);
      return this;
    }
    exponentialRampToValueAtTime(value, endTime) {
      let numericValue = this._fromType(value);
      numericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;
      this._assertRange(numericValue);
      const computedTime = this.toSeconds(endTime);
      assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);
      this._events.add({
        time: computedTime,
        type: "exponentialRampToValueAtTime",
        value: numericValue
      });
      this.log(this.units, "exponentialRampToValueAtTime", value, computedTime);
      this._param.exponentialRampToValueAtTime(numericValue, computedTime);
      return this;
    }
    exponentialRampTo(value, rampTime, startTime) {
      startTime = this.toSeconds(startTime);
      this.setRampPoint(startTime);
      this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
      return this;
    }
    linearRampTo(value, rampTime, startTime) {
      startTime = this.toSeconds(startTime);
      this.setRampPoint(startTime);
      this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
      return this;
    }
    targetRampTo(value, rampTime, startTime) {
      startTime = this.toSeconds(startTime);
      this.setRampPoint(startTime);
      this.exponentialApproachValueAtTime(value, startTime, rampTime);
      return this;
    }
    exponentialApproachValueAtTime(value, time, rampTime) {
      time = this.toSeconds(time);
      rampTime = this.toSeconds(rampTime);
      const timeConstant = Math.log(rampTime + 1) / Math.log(200);
      this.setTargetAtTime(value, time, timeConstant);
      this.cancelAndHoldAtTime(time + rampTime * 0.9);
      this.linearRampToValueAtTime(value, time + rampTime);
      return this;
    }
    setTargetAtTime(value, startTime, timeConstant) {
      const numericValue = this._fromType(value);
      assert(isFinite(timeConstant) && timeConstant > 0, "timeConstant must be a number greater than 0");
      const computedTime = this.toSeconds(startTime);
      this._assertRange(numericValue);
      assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);
      this._events.add({
        constant: timeConstant,
        time: computedTime,
        type: "setTargetAtTime",
        value: numericValue
      });
      this.log(this.units, "setTargetAtTime", value, computedTime, timeConstant);
      this._param.setTargetAtTime(numericValue, computedTime, timeConstant);
      return this;
    }
    setValueCurveAtTime(values, startTime, duration, scaling = 1) {
      duration = this.toSeconds(duration);
      startTime = this.toSeconds(startTime);
      const startingValue = this._fromType(values[0]) * scaling;
      this.setValueAtTime(this._toType(startingValue), startTime);
      const segTime = duration / (values.length - 1);
      for (let i = 1; i < values.length; i++) {
        const numericValue = this._fromType(values[i]) * scaling;
        this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);
      }
      return this;
    }
    cancelScheduledValues(time) {
      const computedTime = this.toSeconds(time);
      assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);
      this._events.cancel(computedTime);
      this._param.cancelScheduledValues(computedTime);
      this.log(this.units, "cancelScheduledValues", computedTime);
      return this;
    }
    cancelAndHoldAtTime(time) {
      const computedTime = this.toSeconds(time);
      const valueAtTime = this._fromType(this.getValueAtTime(computedTime));
      assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);
      this.log(this.units, "cancelAndHoldAtTime", computedTime, "value=" + valueAtTime);
      const before = this._events.get(computedTime);
      const after = this._events.getAfter(computedTime);
      if (before && EQ(before.time, computedTime)) {
        if (after) {
          this._param.cancelScheduledValues(after.time);
          this._events.cancel(after.time);
        } else {
          this._param.cancelAndHoldAtTime(computedTime);
          this._events.cancel(computedTime + this.sampleTime);
        }
      } else if (after) {
        this._param.cancelScheduledValues(after.time);
        this._events.cancel(after.time);
        if (after.type === "linearRampToValueAtTime") {
          this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);
        } else if (after.type === "exponentialRampToValueAtTime") {
          this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);
        }
      }
      this._events.add({
        time: computedTime,
        type: "setValueAtTime",
        value: valueAtTime
      });
      this._param.setValueAtTime(valueAtTime, computedTime);
      return this;
    }
    rampTo(value, rampTime = 0.1, startTime) {
      if (this.units === "frequency" || this.units === "bpm" || this.units === "decibels") {
        this.exponentialRampTo(value, rampTime, startTime);
      } else {
        this.linearRampTo(value, rampTime, startTime);
      }
      return this;
    }
    apply(param) {
      const now = this.context.currentTime;
      param.setValueAtTime(this.getValueAtTime(now), now);
      const previousEvent = this._events.get(now);
      if (previousEvent && previousEvent.type === "setTargetAtTime") {
        const nextEvent = this._events.getAfter(previousEvent.time);
        const endTime = nextEvent ? nextEvent.time : now + 2;
        const subdivisions = (endTime - now) / 10;
        for (let i = now; i < endTime; i += subdivisions) {
          param.linearRampToValueAtTime(this.getValueAtTime(i), i);
        }
      }
      this._events.forEachAfter(this.context.currentTime, (event2) => {
        if (event2.type === "cancelScheduledValues") {
          param.cancelScheduledValues(event2.time);
        } else if (event2.type === "setTargetAtTime") {
          param.setTargetAtTime(event2.value, event2.time, event2.constant);
        } else {
          param[event2.type](event2.value, event2.time);
        }
      });
      return this;
    }
    setParam(param) {
      assert(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
      const input2 = this.input;
      input2.disconnect(this._param);
      this.apply(param);
      this._param = param;
      input2.connect(this._param);
      return this;
    }
    dispose() {
      super.dispose();
      this._events.dispose();
      return this;
    }
    get defaultValue() {
      return this._toType(this._param.defaultValue);
    }
    _exponentialApproach(t0, v0, v1, timeConstant, t2) {
      return v1 + (v0 - v1) * Math.exp(-(t2 - t0) / timeConstant);
    }
    _linearInterpolate(t0, v0, t1, v1, t2) {
      return v0 + (v1 - v0) * ((t2 - t0) / (t1 - t0));
    }
    _exponentialInterpolate(t0, v0, t1, v1, t2) {
      return v0 * Math.pow(v1 / v0, (t2 - t0) / (t1 - t0));
    }
  };

  // node_modules/tone/build/esm/core/context/ToneAudioNode.js
  var ToneAudioNode = class extends ToneWithContext {
    constructor() {
      super(...arguments);
      this.name = "ToneAudioNode";
      this._internalChannels = [];
    }
    get numberOfInputs() {
      if (isDefined(this.input)) {
        if (isAudioParam(this.input) || this.input instanceof Param) {
          return 1;
        } else {
          return this.input.numberOfInputs;
        }
      } else {
        return 0;
      }
    }
    get numberOfOutputs() {
      if (isDefined(this.output)) {
        return this.output.numberOfOutputs;
      } else {
        return 0;
      }
    }
    _isAudioNode(node) {
      return isDefined(node) && (node instanceof ToneAudioNode || isAudioNode2(node));
    }
    _getInternalNodes() {
      const nodeList = this._internalChannels.slice(0);
      if (this._isAudioNode(this.input)) {
        nodeList.push(this.input);
      }
      if (this._isAudioNode(this.output)) {
        if (this.input !== this.output) {
          nodeList.push(this.output);
        }
      }
      return nodeList;
    }
    _setChannelProperties(options) {
      const nodeList = this._getInternalNodes();
      nodeList.forEach((node) => {
        node.channelCount = options.channelCount;
        node.channelCountMode = options.channelCountMode;
        node.channelInterpretation = options.channelInterpretation;
      });
    }
    _getChannelProperties() {
      const nodeList = this._getInternalNodes();
      assert(nodeList.length > 0, "ToneAudioNode does not have any internal nodes");
      const node = nodeList[0];
      return {
        channelCount: node.channelCount,
        channelCountMode: node.channelCountMode,
        channelInterpretation: node.channelInterpretation
      };
    }
    get channelCount() {
      return this._getChannelProperties().channelCount;
    }
    set channelCount(channelCount) {
      const props = this._getChannelProperties();
      this._setChannelProperties(Object.assign(props, { channelCount }));
    }
    get channelCountMode() {
      return this._getChannelProperties().channelCountMode;
    }
    set channelCountMode(channelCountMode) {
      const props = this._getChannelProperties();
      this._setChannelProperties(Object.assign(props, { channelCountMode }));
    }
    get channelInterpretation() {
      return this._getChannelProperties().channelInterpretation;
    }
    set channelInterpretation(channelInterpretation) {
      const props = this._getChannelProperties();
      this._setChannelProperties(Object.assign(props, { channelInterpretation }));
    }
    connect(destination, outputNum = 0, inputNum = 0) {
      connect(this, destination, outputNum, inputNum);
      return this;
    }
    toDestination() {
      this.connect(this.context.destination);
      return this;
    }
    toMaster() {
      warn("toMaster() has been renamed toDestination()");
      return this.toDestination();
    }
    disconnect(destination, outputNum = 0, inputNum = 0) {
      disconnect(this, destination, outputNum, inputNum);
      return this;
    }
    chain(...nodes) {
      connectSeries(this, ...nodes);
      return this;
    }
    fan(...nodes) {
      nodes.forEach((node) => this.connect(node));
      return this;
    }
    dispose() {
      super.dispose();
      if (isDefined(this.input)) {
        if (this.input instanceof ToneAudioNode) {
          this.input.dispose();
        } else if (isAudioNode2(this.input)) {
          this.input.disconnect();
        }
      }
      if (isDefined(this.output)) {
        if (this.output instanceof ToneAudioNode) {
          this.output.dispose();
        } else if (isAudioNode2(this.output)) {
          this.output.disconnect();
        }
      }
      this._internalChannels = [];
      return this;
    }
  };
  function connectSeries(...nodes) {
    const first = nodes.shift();
    nodes.reduce((prev, current) => {
      if (prev instanceof ToneAudioNode) {
        prev.connect(current);
      } else if (isAudioNode2(prev)) {
        connect(prev, current);
      }
      return current;
    }, first);
  }
  function connect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {
    assert(isDefined(srcNode), "Cannot connect from undefined node");
    assert(isDefined(dstNode), "Cannot connect to undefined node");
    if (dstNode instanceof ToneAudioNode || isAudioNode2(dstNode)) {
      assert(dstNode.numberOfInputs > 0, "Cannot connect to node with no inputs");
    }
    assert(srcNode.numberOfOutputs > 0, "Cannot connect from node with no outputs");
    while (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {
      if (isDefined(dstNode.input)) {
        dstNode = dstNode.input;
      }
    }
    while (srcNode instanceof ToneAudioNode) {
      if (isDefined(srcNode.output)) {
        srcNode = srcNode.output;
      }
    }
    if (isAudioParam(dstNode)) {
      srcNode.connect(dstNode, outputNumber);
    } else {
      srcNode.connect(dstNode, outputNumber, inputNumber);
    }
  }
  function disconnect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {
    if (isDefined(dstNode)) {
      while (dstNode instanceof ToneAudioNode) {
        dstNode = dstNode.input;
      }
    }
    while (!isAudioNode2(srcNode)) {
      if (isDefined(srcNode.output)) {
        srcNode = srcNode.output;
      }
    }
    if (isAudioParam(dstNode)) {
      srcNode.disconnect(dstNode, outputNumber);
    } else if (isAudioNode2(dstNode)) {
      srcNode.disconnect(dstNode, outputNumber, inputNumber);
    } else {
      srcNode.disconnect();
    }
  }

  // node_modules/tone/build/esm/core/context/Gain.js
  var Gain = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Gain.getDefaults(), arguments, ["gain", "units"]));
      this.name = "Gain";
      this._gainNode = this.context.createGain();
      this.input = this._gainNode;
      this.output = this._gainNode;
      const options = optionsFromArguments(Gain.getDefaults(), arguments, ["gain", "units"]);
      this.gain = new Param({
        context: this.context,
        convert: options.convert,
        param: this._gainNode.gain,
        units: options.units,
        value: options.gain,
        minValue: options.minValue,
        maxValue: options.maxValue
      });
      readOnly(this, "gain");
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        convert: true,
        gain: 1,
        units: "gain"
      });
    }
    dispose() {
      super.dispose();
      this._gainNode.disconnect();
      this.gain.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/source/OneShotSource.js
  var OneShotSource = class extends ToneAudioNode {
    constructor(options) {
      super(options);
      this.onended = noOp;
      this._startTime = -1;
      this._stopTime = -1;
      this._timeout = -1;
      this.output = new Gain({
        context: this.context,
        gain: 0
      });
      this._gainNode = this.output;
      this.getStateAtTime = function(time) {
        const computedTime = this.toSeconds(time);
        if (this._startTime !== -1 && computedTime >= this._startTime && (this._stopTime === -1 || computedTime <= this._stopTime)) {
          return "started";
        } else {
          return "stopped";
        }
      };
      this._fadeIn = options.fadeIn;
      this._fadeOut = options.fadeOut;
      this._curve = options.curve;
      this.onended = options.onended;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        curve: "linear",
        fadeIn: 0,
        fadeOut: 0,
        onended: noOp
      });
    }
    _startGain(time, gain = 1) {
      assert(this._startTime === -1, "Source cannot be started more than once");
      const fadeInTime = this.toSeconds(this._fadeIn);
      this._startTime = time + fadeInTime;
      this._startTime = Math.max(this._startTime, this.context.currentTime);
      if (fadeInTime > 0) {
        this._gainNode.gain.setValueAtTime(0, time);
        if (this._curve === "linear") {
          this._gainNode.gain.linearRampToValueAtTime(gain, time + fadeInTime);
        } else {
          this._gainNode.gain.exponentialApproachValueAtTime(gain, time, fadeInTime);
        }
      } else {
        this._gainNode.gain.setValueAtTime(gain, time);
      }
      return this;
    }
    stop(time) {
      this.log("stop", time);
      this._stopGain(this.toSeconds(time));
      return this;
    }
    _stopGain(time) {
      assert(this._startTime !== -1, "'start' must be called before 'stop'");
      this.cancelStop();
      const fadeOutTime = this.toSeconds(this._fadeOut);
      this._stopTime = this.toSeconds(time) + fadeOutTime;
      this._stopTime = Math.max(this._stopTime, this.context.currentTime);
      if (fadeOutTime > 0) {
        if (this._curve === "linear") {
          this._gainNode.gain.linearRampTo(0, fadeOutTime, time);
        } else {
          this._gainNode.gain.targetRampTo(0, fadeOutTime, time);
        }
      } else {
        this._gainNode.gain.cancelAndHoldAtTime(time);
        this._gainNode.gain.setValueAtTime(0, time);
      }
      this.context.clearTimeout(this._timeout);
      this._timeout = this.context.setTimeout(() => {
        const additionalTail = this._curve === "exponential" ? fadeOutTime * 2 : 0;
        this._stopSource(this.now() + additionalTail);
        this._onended();
      }, this._stopTime - this.context.currentTime);
      return this;
    }
    _onended() {
      if (this.onended !== noOp) {
        this.onended(this);
        this.onended = noOp;
        if (!this.context.isOffline) {
          const disposeCallback = () => this.dispose();
          if (typeof window.requestIdleCallback !== "undefined") {
            window.requestIdleCallback(disposeCallback);
          } else {
            setTimeout(disposeCallback, 1e3);
          }
        }
      }
    }
    get state() {
      return this.getStateAtTime(this.now());
    }
    cancelStop() {
      this.log("cancelStop");
      assert(this._startTime !== -1, "Source is not started");
      this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);
      this.context.clearTimeout(this._timeout);
      this._stopTime = -1;
      return this;
    }
    dispose() {
      super.dispose();
      this._gainNode.disconnect();
      return this;
    }
  };

  // node_modules/tone/build/esm/signal/ToneConstantSource.js
  var ToneConstantSource = class extends OneShotSource {
    constructor() {
      super(optionsFromArguments(ToneConstantSource.getDefaults(), arguments, ["offset"]));
      this.name = "ToneConstantSource";
      this._source = this.context.createConstantSource();
      const options = optionsFromArguments(ToneConstantSource.getDefaults(), arguments, ["offset"]);
      connect(this._source, this._gainNode);
      this.offset = new Param({
        context: this.context,
        convert: options.convert,
        param: this._source.offset,
        units: options.units,
        value: options.offset,
        minValue: options.minValue,
        maxValue: options.maxValue
      });
    }
    static getDefaults() {
      return Object.assign(OneShotSource.getDefaults(), {
        convert: true,
        offset: 1,
        units: "number"
      });
    }
    start(time) {
      const computedTime = this.toSeconds(time);
      this.log("start", computedTime);
      this._startGain(computedTime);
      this._source.start(computedTime);
      return this;
    }
    _stopSource(time) {
      this._source.stop(time);
    }
    dispose() {
      super.dispose();
      if (this.state === "started") {
        this.stop();
      }
      this._source.disconnect();
      this.offset.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/signal/Signal.js
  var Signal = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Signal.getDefaults(), arguments, ["value", "units"]));
      this.name = "Signal";
      this.override = true;
      const options = optionsFromArguments(Signal.getDefaults(), arguments, ["value", "units"]);
      this.output = this._constantSource = new ToneConstantSource({
        context: this.context,
        convert: options.convert,
        offset: options.value,
        units: options.units,
        minValue: options.minValue,
        maxValue: options.maxValue
      });
      this._constantSource.start(0);
      this.input = this._param = this._constantSource.offset;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        convert: true,
        units: "number",
        value: 0
      });
    }
    connect(destination, outputNum = 0, inputNum = 0) {
      connectSignal(this, destination, outputNum, inputNum);
      return this;
    }
    dispose() {
      super.dispose();
      this._param.dispose();
      this._constantSource.dispose();
      return this;
    }
    setValueAtTime(value, time) {
      this._param.setValueAtTime(value, time);
      return this;
    }
    getValueAtTime(time) {
      return this._param.getValueAtTime(time);
    }
    setRampPoint(time) {
      this._param.setRampPoint(time);
      return this;
    }
    linearRampToValueAtTime(value, time) {
      this._param.linearRampToValueAtTime(value, time);
      return this;
    }
    exponentialRampToValueAtTime(value, time) {
      this._param.exponentialRampToValueAtTime(value, time);
      return this;
    }
    exponentialRampTo(value, rampTime, startTime) {
      this._param.exponentialRampTo(value, rampTime, startTime);
      return this;
    }
    linearRampTo(value, rampTime, startTime) {
      this._param.linearRampTo(value, rampTime, startTime);
      return this;
    }
    targetRampTo(value, rampTime, startTime) {
      this._param.targetRampTo(value, rampTime, startTime);
      return this;
    }
    exponentialApproachValueAtTime(value, time, rampTime) {
      this._param.exponentialApproachValueAtTime(value, time, rampTime);
      return this;
    }
    setTargetAtTime(value, startTime, timeConstant) {
      this._param.setTargetAtTime(value, startTime, timeConstant);
      return this;
    }
    setValueCurveAtTime(values, startTime, duration, scaling) {
      this._param.setValueCurveAtTime(values, startTime, duration, scaling);
      return this;
    }
    cancelScheduledValues(time) {
      this._param.cancelScheduledValues(time);
      return this;
    }
    cancelAndHoldAtTime(time) {
      this._param.cancelAndHoldAtTime(time);
      return this;
    }
    rampTo(value, rampTime, startTime) {
      this._param.rampTo(value, rampTime, startTime);
      return this;
    }
    get value() {
      return this._param.value;
    }
    set value(value) {
      this._param.value = value;
    }
    get convert() {
      return this._param.convert;
    }
    set convert(convert3) {
      this._param.convert = convert3;
    }
    get units() {
      return this._param.units;
    }
    get overridden() {
      return this._param.overridden;
    }
    set overridden(overridden) {
      this._param.overridden = overridden;
    }
    get maxValue() {
      return this._param.maxValue;
    }
    get minValue() {
      return this._param.minValue;
    }
    apply(param) {
      this._param.apply(param);
      return this;
    }
  };
  function connectSignal(signal, destination, outputNum, inputNum) {
    if (destination instanceof Param || isAudioParam(destination) || destination instanceof Signal && destination.override) {
      destination.cancelScheduledValues(0);
      destination.setValueAtTime(0, 0);
      if (destination instanceof Signal) {
        destination.overridden = true;
      }
    }
    connect(signal, destination, outputNum, inputNum);
  }

  // node_modules/tone/build/esm/core/clock/TickParam.js
  var TickParam = class extends Param {
    constructor() {
      super(optionsFromArguments(TickParam.getDefaults(), arguments, ["value"]));
      this.name = "TickParam";
      this._events = new Timeline(Infinity);
      this._multiplier = 1;
      const options = optionsFromArguments(TickParam.getDefaults(), arguments, ["value"]);
      this._multiplier = options.multiplier;
      this._events.cancel(0);
      this._events.add({
        ticks: 0,
        time: 0,
        type: "setValueAtTime",
        value: this._fromType(options.value)
      });
      this.setValueAtTime(options.value, 0);
    }
    static getDefaults() {
      return Object.assign(Param.getDefaults(), {
        multiplier: 1,
        units: "hertz",
        value: 1
      });
    }
    setTargetAtTime(value, time, constant) {
      time = this.toSeconds(time);
      this.setRampPoint(time);
      const computedValue = this._fromType(value);
      const prevEvent = this._events.get(time);
      const segments = Math.round(Math.max(1 / constant, 1));
      for (let i = 0; i <= segments; i++) {
        const segTime = constant * i + time;
        const rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);
        this.linearRampToValueAtTime(this._toType(rampVal), segTime);
      }
      return this;
    }
    setValueAtTime(value, time) {
      const computedTime = this.toSeconds(time);
      super.setValueAtTime(value, time);
      const event2 = this._events.get(computedTime);
      const previousEvent = this._events.previousEvent(event2);
      const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);
      event2.ticks = Math.max(ticksUntilTime, 0);
      return this;
    }
    linearRampToValueAtTime(value, time) {
      const computedTime = this.toSeconds(time);
      super.linearRampToValueAtTime(value, time);
      const event2 = this._events.get(computedTime);
      const previousEvent = this._events.previousEvent(event2);
      const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);
      event2.ticks = Math.max(ticksUntilTime, 0);
      return this;
    }
    exponentialRampToValueAtTime(value, time) {
      time = this.toSeconds(time);
      const computedVal = this._fromType(value);
      const prevEvent = this._events.get(time);
      const segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));
      const segmentDur = (time - prevEvent.time) / segments;
      for (let i = 0; i <= segments; i++) {
        const segTime = segmentDur * i + prevEvent.time;
        const rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);
        this.linearRampToValueAtTime(this._toType(rampVal), segTime);
      }
      return this;
    }
    _getTicksUntilEvent(event2, time) {
      if (event2 === null) {
        event2 = {
          ticks: 0,
          time: 0,
          type: "setValueAtTime",
          value: 0
        };
      } else if (isUndef(event2.ticks)) {
        const previousEvent = this._events.previousEvent(event2);
        event2.ticks = this._getTicksUntilEvent(previousEvent, event2.time);
      }
      const val0 = this._fromType(this.getValueAtTime(event2.time));
      let val1 = this._fromType(this.getValueAtTime(time));
      const onTheLineEvent = this._events.get(time);
      if (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === "setValueAtTime") {
        val1 = this._fromType(this.getValueAtTime(time - this.sampleTime));
      }
      return 0.5 * (time - event2.time) * (val0 + val1) + event2.ticks;
    }
    getTicksAtTime(time) {
      const computedTime = this.toSeconds(time);
      const event2 = this._events.get(computedTime);
      return Math.max(this._getTicksUntilEvent(event2, computedTime), 0);
    }
    getDurationOfTicks(ticks, time) {
      const computedTime = this.toSeconds(time);
      const currentTick = this.getTicksAtTime(time);
      return this.getTimeOfTick(currentTick + ticks) - computedTime;
    }
    getTimeOfTick(tick) {
      const before = this._events.get(tick, "ticks");
      const after = this._events.getAfter(tick, "ticks");
      if (before && before.ticks === tick) {
        return before.time;
      } else if (before && after && after.type === "linearRampToValueAtTime" && before.value !== after.value) {
        const val0 = this._fromType(this.getValueAtTime(before.time));
        const val1 = this._fromType(this.getValueAtTime(after.time));
        const delta = (val1 - val0) / (after.time - before.time);
        const k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));
        const sol1 = (-val0 + k) / delta;
        const sol2 = (-val0 - k) / delta;
        return (sol1 > 0 ? sol1 : sol2) + before.time;
      } else if (before) {
        if (before.value === 0) {
          return Infinity;
        } else {
          return before.time + (tick - before.ticks) / before.value;
        }
      } else {
        return tick / this._initialValue;
      }
    }
    ticksToTime(ticks, when) {
      return this.getDurationOfTicks(ticks, when);
    }
    timeToTicks(duration, when) {
      const computedTime = this.toSeconds(when);
      const computedDuration = this.toSeconds(duration);
      const startTicks = this.getTicksAtTime(computedTime);
      const endTicks = this.getTicksAtTime(computedTime + computedDuration);
      return endTicks - startTicks;
    }
    _fromType(val) {
      if (this.units === "bpm" && this.multiplier) {
        return 1 / (60 / val / this.multiplier);
      } else {
        return super._fromType(val);
      }
    }
    _toType(val) {
      if (this.units === "bpm" && this.multiplier) {
        return val / this.multiplier * 60;
      } else {
        return super._toType(val);
      }
    }
    get multiplier() {
      return this._multiplier;
    }
    set multiplier(m) {
      const currentVal = this.value;
      this._multiplier = m;
      this.cancelScheduledValues(0);
      this.setValueAtTime(currentVal, 0);
    }
  };

  // node_modules/tone/build/esm/core/clock/TickSignal.js
  var TickSignal = class extends Signal {
    constructor() {
      super(optionsFromArguments(TickSignal.getDefaults(), arguments, ["value"]));
      this.name = "TickSignal";
      const options = optionsFromArguments(TickSignal.getDefaults(), arguments, ["value"]);
      this.input = this._param = new TickParam({
        context: this.context,
        convert: options.convert,
        multiplier: options.multiplier,
        param: this._constantSource.offset,
        units: options.units,
        value: options.value
      });
    }
    static getDefaults() {
      return Object.assign(Signal.getDefaults(), {
        multiplier: 1,
        units: "hertz",
        value: 1
      });
    }
    ticksToTime(ticks, when) {
      return this._param.ticksToTime(ticks, when);
    }
    timeToTicks(duration, when) {
      return this._param.timeToTicks(duration, when);
    }
    getTimeOfTick(tick) {
      return this._param.getTimeOfTick(tick);
    }
    getDurationOfTicks(ticks, time) {
      return this._param.getDurationOfTicks(ticks, time);
    }
    getTicksAtTime(time) {
      return this._param.getTicksAtTime(time);
    }
    get multiplier() {
      return this._param.multiplier;
    }
    set multiplier(m) {
      this._param.multiplier = m;
    }
    dispose() {
      super.dispose();
      this._param.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/core/clock/TickSource.js
  var TickSource = class extends ToneWithContext {
    constructor() {
      super(optionsFromArguments(TickSource.getDefaults(), arguments, ["frequency"]));
      this.name = "TickSource";
      this._state = new StateTimeline();
      this._tickOffset = new Timeline();
      const options = optionsFromArguments(TickSource.getDefaults(), arguments, ["frequency"]);
      this.frequency = new TickSignal({
        context: this.context,
        units: options.units,
        value: options.frequency
      });
      readOnly(this, "frequency");
      this._state.setStateAtTime("stopped", 0);
      this.setTicksAtTime(0, 0);
    }
    static getDefaults() {
      return Object.assign({
        frequency: 1,
        units: "hertz"
      }, ToneWithContext.getDefaults());
    }
    get state() {
      return this.getStateAtTime(this.now());
    }
    start(time, offset) {
      const computedTime = this.toSeconds(time);
      if (this._state.getValueAtTime(computedTime) !== "started") {
        this._state.setStateAtTime("started", computedTime);
        if (isDefined(offset)) {
          this.setTicksAtTime(offset, computedTime);
        }
      }
      return this;
    }
    stop(time) {
      const computedTime = this.toSeconds(time);
      if (this._state.getValueAtTime(computedTime) === "stopped") {
        const event2 = this._state.get(computedTime);
        if (event2 && event2.time > 0) {
          this._tickOffset.cancel(event2.time);
          this._state.cancel(event2.time);
        }
      }
      this._state.cancel(computedTime);
      this._state.setStateAtTime("stopped", computedTime);
      this.setTicksAtTime(0, computedTime);
      return this;
    }
    pause(time) {
      const computedTime = this.toSeconds(time);
      if (this._state.getValueAtTime(computedTime) === "started") {
        this._state.setStateAtTime("paused", computedTime);
      }
      return this;
    }
    cancel(time) {
      time = this.toSeconds(time);
      this._state.cancel(time);
      this._tickOffset.cancel(time);
      return this;
    }
    getTicksAtTime(time) {
      const computedTime = this.toSeconds(time);
      const stopEvent = this._state.getLastState("stopped", computedTime);
      const tmpEvent = { state: "paused", time: computedTime };
      this._state.add(tmpEvent);
      let lastState = stopEvent;
      let elapsedTicks = 0;
      this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, (e) => {
        let periodStartTime = lastState.time;
        const offsetEvent = this._tickOffset.get(e.time);
        if (offsetEvent && offsetEvent.time >= lastState.time) {
          elapsedTicks = offsetEvent.ticks;
          periodStartTime = offsetEvent.time;
        }
        if (lastState.state === "started" && e.state !== "started") {
          elapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);
        }
        lastState = e;
      });
      this._state.remove(tmpEvent);
      return elapsedTicks;
    }
    get ticks() {
      return this.getTicksAtTime(this.now());
    }
    set ticks(t2) {
      this.setTicksAtTime(t2, this.now());
    }
    get seconds() {
      return this.getSecondsAtTime(this.now());
    }
    set seconds(s) {
      const now = this.now();
      const ticks = this.frequency.timeToTicks(s, now);
      this.setTicksAtTime(ticks, now);
    }
    getSecondsAtTime(time) {
      time = this.toSeconds(time);
      const stopEvent = this._state.getLastState("stopped", time);
      const tmpEvent = { state: "paused", time };
      this._state.add(tmpEvent);
      let lastState = stopEvent;
      let elapsedSeconds = 0;
      this._state.forEachBetween(stopEvent.time, time + this.sampleTime, (e) => {
        let periodStartTime = lastState.time;
        const offsetEvent = this._tickOffset.get(e.time);
        if (offsetEvent && offsetEvent.time >= lastState.time) {
          elapsedSeconds = offsetEvent.seconds;
          periodStartTime = offsetEvent.time;
        }
        if (lastState.state === "started" && e.state !== "started") {
          elapsedSeconds += e.time - periodStartTime;
        }
        lastState = e;
      });
      this._state.remove(tmpEvent);
      return elapsedSeconds;
    }
    setTicksAtTime(ticks, time) {
      time = this.toSeconds(time);
      this._tickOffset.cancel(time);
      this._tickOffset.add({
        seconds: this.frequency.getDurationOfTicks(ticks, time),
        ticks,
        time
      });
      return this;
    }
    getStateAtTime(time) {
      time = this.toSeconds(time);
      return this._state.getValueAtTime(time);
    }
    getTimeOfTick(tick, before = this.now()) {
      const offset = this._tickOffset.get(before);
      const event2 = this._state.get(before);
      const startTime = Math.max(offset.time, event2.time);
      const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;
      return this.frequency.getTimeOfTick(absoluteTicks);
    }
    forEachTickBetween(startTime, endTime, callback2) {
      let lastStateEvent = this._state.get(startTime);
      this._state.forEachBetween(startTime, endTime, (event2) => {
        if (lastStateEvent && lastStateEvent.state === "started" && event2.state !== "started") {
          this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event2.time - this.sampleTime, callback2);
        }
        lastStateEvent = event2;
      });
      let error2 = null;
      if (lastStateEvent && lastStateEvent.state === "started") {
        const maxStartTime = Math.max(lastStateEvent.time, startTime);
        const startTicks = this.frequency.getTicksAtTime(maxStartTime);
        const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);
        const diff = startTicks - ticksAtStart;
        let offset = Math.ceil(diff) - diff;
        offset = EQ(offset, 1) ? 0 : offset;
        let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);
        while (nextTickTime < endTime) {
          try {
            callback2(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));
          } catch (e) {
            error2 = e;
            break;
          }
          nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);
        }
      }
      if (error2) {
        throw error2;
      }
      return this;
    }
    dispose() {
      super.dispose();
      this._state.dispose();
      this._tickOffset.dispose();
      this.frequency.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/core/clock/Clock.js
  var Clock = class extends ToneWithContext {
    constructor() {
      super(optionsFromArguments(Clock.getDefaults(), arguments, ["callback", "frequency"]));
      this.name = "Clock";
      this.callback = noOp;
      this._lastUpdate = 0;
      this._state = new StateTimeline("stopped");
      this._boundLoop = this._loop.bind(this);
      const options = optionsFromArguments(Clock.getDefaults(), arguments, ["callback", "frequency"]);
      this.callback = options.callback;
      this._tickSource = new TickSource({
        context: this.context,
        frequency: options.frequency,
        units: options.units
      });
      this._lastUpdate = 0;
      this.frequency = this._tickSource.frequency;
      readOnly(this, "frequency");
      this._state.setStateAtTime("stopped", 0);
      this.context.on("tick", this._boundLoop);
    }
    static getDefaults() {
      return Object.assign(ToneWithContext.getDefaults(), {
        callback: noOp,
        frequency: 1,
        units: "hertz"
      });
    }
    get state() {
      return this._state.getValueAtTime(this.now());
    }
    start(time, offset) {
      assertContextRunning(this.context);
      const computedTime = this.toSeconds(time);
      this.log("start", computedTime);
      if (this._state.getValueAtTime(computedTime) !== "started") {
        this._state.setStateAtTime("started", computedTime);
        this._tickSource.start(computedTime, offset);
        if (computedTime < this._lastUpdate) {
          this.emit("start", computedTime, offset);
        }
      }
      return this;
    }
    stop(time) {
      const computedTime = this.toSeconds(time);
      this.log("stop", computedTime);
      this._state.cancel(computedTime);
      this._state.setStateAtTime("stopped", computedTime);
      this._tickSource.stop(computedTime);
      if (computedTime < this._lastUpdate) {
        this.emit("stop", computedTime);
      }
      return this;
    }
    pause(time) {
      const computedTime = this.toSeconds(time);
      if (this._state.getValueAtTime(computedTime) === "started") {
        this._state.setStateAtTime("paused", computedTime);
        this._tickSource.pause(computedTime);
        if (computedTime < this._lastUpdate) {
          this.emit("pause", computedTime);
        }
      }
      return this;
    }
    get ticks() {
      return Math.ceil(this.getTicksAtTime(this.now()));
    }
    set ticks(t2) {
      this._tickSource.ticks = t2;
    }
    get seconds() {
      return this._tickSource.seconds;
    }
    set seconds(s) {
      this._tickSource.seconds = s;
    }
    getSecondsAtTime(time) {
      return this._tickSource.getSecondsAtTime(time);
    }
    setTicksAtTime(ticks, time) {
      this._tickSource.setTicksAtTime(ticks, time);
      return this;
    }
    getTimeOfTick(tick, before = this.now()) {
      return this._tickSource.getTimeOfTick(tick, before);
    }
    getTicksAtTime(time) {
      return this._tickSource.getTicksAtTime(time);
    }
    nextTickTime(offset, when) {
      const computedTime = this.toSeconds(when);
      const currentTick = this.getTicksAtTime(computedTime);
      return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);
    }
    _loop() {
      const startTime = this._lastUpdate;
      const endTime = this.now();
      this._lastUpdate = endTime;
      this.log("loop", startTime, endTime);
      if (startTime !== endTime) {
        this._state.forEachBetween(startTime, endTime, (e) => {
          switch (e.state) {
            case "started":
              const offset = this._tickSource.getTicksAtTime(e.time);
              this.emit("start", e.time, offset);
              break;
            case "stopped":
              if (e.time !== 0) {
                this.emit("stop", e.time);
              }
              break;
            case "paused":
              this.emit("pause", e.time);
              break;
          }
        });
        this._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {
          this.callback(time, ticks);
        });
      }
    }
    getStateAtTime(time) {
      const computedTime = this.toSeconds(time);
      return this._state.getValueAtTime(computedTime);
    }
    dispose() {
      super.dispose();
      this.context.off("tick", this._boundLoop);
      this._tickSource.dispose();
      this._state.dispose();
      return this;
    }
  };
  Emitter.mixin(Clock);

  // node_modules/tone/build/esm/core/context/ToneAudioBuffers.js
  var ToneAudioBuffers = class extends Tone {
    constructor() {
      super();
      this.name = "ToneAudioBuffers";
      this._buffers = new Map();
      this._loadingCount = 0;
      const options = optionsFromArguments(ToneAudioBuffers.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
      this.baseUrl = options.baseUrl;
      Object.keys(options.urls).forEach((name2) => {
        this._loadingCount++;
        const url = options.urls[name2];
        this.add(name2, url, this._bufferLoaded.bind(this, options.onload), options.onerror);
      });
    }
    static getDefaults() {
      return {
        baseUrl: "",
        onerror: noOp,
        onload: noOp,
        urls: {}
      };
    }
    has(name2) {
      return this._buffers.has(name2.toString());
    }
    get(name2) {
      assert(this.has(name2), `ToneAudioBuffers has no buffer named: ${name2}`);
      return this._buffers.get(name2.toString());
    }
    _bufferLoaded(callback2) {
      this._loadingCount--;
      if (this._loadingCount === 0 && callback2) {
        callback2();
      }
    }
    get loaded() {
      return Array.from(this._buffers).every(([_, buffer]) => buffer.loaded);
    }
    add(name2, url, callback2 = noOp, onerror = noOp) {
      if (isString(url)) {
        this._buffers.set(name2.toString(), new ToneAudioBuffer(this.baseUrl + url, callback2, onerror));
      } else {
        this._buffers.set(name2.toString(), new ToneAudioBuffer(url, callback2, onerror));
      }
      return this;
    }
    dispose() {
      super.dispose();
      this._buffers.forEach((buffer) => buffer.dispose());
      this._buffers.clear();
      return this;
    }
  };

  // node_modules/tone/build/esm/core/type/Midi.js
  var MidiClass = class extends FrequencyClass {
    constructor() {
      super(...arguments);
      this.name = "MidiClass";
      this.defaultUnits = "midi";
    }
    _frequencyToUnits(freq) {
      return ftom(super._frequencyToUnits(freq));
    }
    _ticksToUnits(ticks) {
      return ftom(super._ticksToUnits(ticks));
    }
    _beatsToUnits(beats) {
      return ftom(super._beatsToUnits(beats));
    }
    _secondsToUnits(seconds) {
      return ftom(super._secondsToUnits(seconds));
    }
    toMidi() {
      return this.valueOf();
    }
    toFrequency() {
      return mtof(this.toMidi());
    }
    transpose(interval) {
      return new MidiClass(this.context, this.toMidi() + interval);
    }
  };

  // node_modules/tone/build/esm/core/type/Ticks.js
  var TicksClass = class extends TransportTimeClass {
    constructor() {
      super(...arguments);
      this.name = "Ticks";
      this.defaultUnits = "i";
    }
    _now() {
      return this.context.transport.ticks;
    }
    _beatsToUnits(beats) {
      return this._getPPQ() * beats;
    }
    _secondsToUnits(seconds) {
      return Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());
    }
    _ticksToUnits(ticks) {
      return ticks;
    }
    toTicks() {
      return this.valueOf();
    }
    toSeconds() {
      return this.valueOf() / this._getPPQ() * (60 / this._getBpm());
    }
  };

  // node_modules/tone/build/esm/core/util/Draw.js
  var Draw = class extends ToneWithContext {
    constructor() {
      super(...arguments);
      this.name = "Draw";
      this.expiration = 0.25;
      this.anticipation = 8e-3;
      this._events = new Timeline();
      this._boundDrawLoop = this._drawLoop.bind(this);
      this._animationFrame = -1;
    }
    schedule(callback2, time) {
      this._events.add({
        callback: callback2,
        time: this.toSeconds(time)
      });
      if (this._events.length === 1) {
        this._animationFrame = requestAnimationFrame(this._boundDrawLoop);
      }
      return this;
    }
    cancel(after) {
      this._events.cancel(this.toSeconds(after));
      return this;
    }
    _drawLoop() {
      const now = this.context.currentTime;
      while (this._events.length && this._events.peek().time - this.anticipation <= now) {
        const event2 = this._events.shift();
        if (event2 && now - event2.time <= this.expiration) {
          event2.callback();
        }
      }
      if (this._events.length > 0) {
        this._animationFrame = requestAnimationFrame(this._boundDrawLoop);
      }
    }
    dispose() {
      super.dispose();
      this._events.dispose();
      cancelAnimationFrame(this._animationFrame);
      return this;
    }
  };
  onContextInit((context2) => {
    context2.draw = new Draw({ context: context2 });
  });
  onContextClose((context2) => {
    context2.draw.dispose();
  });

  // node_modules/tone/build/esm/core/util/IntervalTimeline.js
  var IntervalTimeline = class extends Tone {
    constructor() {
      super(...arguments);
      this.name = "IntervalTimeline";
      this._root = null;
      this._length = 0;
    }
    add(event2) {
      assert(isDefined(event2.time), "Events must have a time property");
      assert(isDefined(event2.duration), "Events must have a duration parameter");
      event2.time = event2.time.valueOf();
      let node = new IntervalNode(event2.time, event2.time + event2.duration, event2);
      if (this._root === null) {
        this._root = node;
      } else {
        this._root.insert(node);
      }
      this._length++;
      while (node !== null) {
        node.updateHeight();
        node.updateMax();
        this._rebalance(node);
        node = node.parent;
      }
      return this;
    }
    remove(event2) {
      if (this._root !== null) {
        const results = [];
        this._root.search(event2.time, results);
        for (const node of results) {
          if (node.event === event2) {
            this._removeNode(node);
            this._length--;
            break;
          }
        }
      }
      return this;
    }
    get length() {
      return this._length;
    }
    cancel(after) {
      this.forEachFrom(after, (event2) => this.remove(event2));
      return this;
    }
    _setRoot(node) {
      this._root = node;
      if (this._root !== null) {
        this._root.parent = null;
      }
    }
    _replaceNodeInParent(node, replacement) {
      if (node.parent !== null) {
        if (node.isLeftChild()) {
          node.parent.left = replacement;
        } else {
          node.parent.right = replacement;
        }
        this._rebalance(node.parent);
      } else {
        this._setRoot(replacement);
      }
    }
    _removeNode(node) {
      if (node.left === null && node.right === null) {
        this._replaceNodeInParent(node, null);
      } else if (node.right === null) {
        this._replaceNodeInParent(node, node.left);
      } else if (node.left === null) {
        this._replaceNodeInParent(node, node.right);
      } else {
        const balance = node.getBalance();
        let replacement;
        let temp = null;
        if (balance > 0) {
          if (node.left.right === null) {
            replacement = node.left;
            replacement.right = node.right;
            temp = replacement;
          } else {
            replacement = node.left.right;
            while (replacement.right !== null) {
              replacement = replacement.right;
            }
            if (replacement.parent) {
              replacement.parent.right = replacement.left;
              temp = replacement.parent;
              replacement.left = node.left;
              replacement.right = node.right;
            }
          }
        } else if (node.right.left === null) {
          replacement = node.right;
          replacement.left = node.left;
          temp = replacement;
        } else {
          replacement = node.right.left;
          while (replacement.left !== null) {
            replacement = replacement.left;
          }
          if (replacement.parent) {
            replacement.parent.left = replacement.right;
            temp = replacement.parent;
            replacement.left = node.left;
            replacement.right = node.right;
          }
        }
        if (node.parent !== null) {
          if (node.isLeftChild()) {
            node.parent.left = replacement;
          } else {
            node.parent.right = replacement;
          }
        } else {
          this._setRoot(replacement);
        }
        if (temp) {
          this._rebalance(temp);
        }
      }
      node.dispose();
    }
    _rotateLeft(node) {
      const parent = node.parent;
      const isLeftChild = node.isLeftChild();
      const pivotNode = node.right;
      if (pivotNode) {
        node.right = pivotNode.left;
        pivotNode.left = node;
      }
      if (parent !== null) {
        if (isLeftChild) {
          parent.left = pivotNode;
        } else {
          parent.right = pivotNode;
        }
      } else {
        this._setRoot(pivotNode);
      }
    }
    _rotateRight(node) {
      const parent = node.parent;
      const isLeftChild = node.isLeftChild();
      const pivotNode = node.left;
      if (pivotNode) {
        node.left = pivotNode.right;
        pivotNode.right = node;
      }
      if (parent !== null) {
        if (isLeftChild) {
          parent.left = pivotNode;
        } else {
          parent.right = pivotNode;
        }
      } else {
        this._setRoot(pivotNode);
      }
    }
    _rebalance(node) {
      const balance = node.getBalance();
      if (balance > 1 && node.left) {
        if (node.left.getBalance() < 0) {
          this._rotateLeft(node.left);
        } else {
          this._rotateRight(node);
        }
      } else if (balance < -1 && node.right) {
        if (node.right.getBalance() > 0) {
          this._rotateRight(node.right);
        } else {
          this._rotateLeft(node);
        }
      }
    }
    get(time) {
      if (this._root !== null) {
        const results = [];
        this._root.search(time, results);
        if (results.length > 0) {
          let max = results[0];
          for (let i = 1; i < results.length; i++) {
            if (results[i].low > max.low) {
              max = results[i];
            }
          }
          return max.event;
        }
      }
      return null;
    }
    forEach(callback2) {
      if (this._root !== null) {
        const allNodes = [];
        this._root.traverse((node) => allNodes.push(node));
        allNodes.forEach((node) => {
          if (node.event) {
            callback2(node.event);
          }
        });
      }
      return this;
    }
    forEachAtTime(time, callback2) {
      if (this._root !== null) {
        const results = [];
        this._root.search(time, results);
        results.forEach((node) => {
          if (node.event) {
            callback2(node.event);
          }
        });
      }
      return this;
    }
    forEachFrom(time, callback2) {
      if (this._root !== null) {
        const results = [];
        this._root.searchAfter(time, results);
        results.forEach((node) => {
          if (node.event) {
            callback2(node.event);
          }
        });
      }
      return this;
    }
    dispose() {
      super.dispose();
      if (this._root !== null) {
        this._root.traverse((node) => node.dispose());
      }
      this._root = null;
      return this;
    }
  };
  var IntervalNode = class {
    constructor(low, high, event2) {
      this._left = null;
      this._right = null;
      this.parent = null;
      this.height = 0;
      this.event = event2;
      this.low = low;
      this.high = high;
      this.max = this.high;
    }
    insert(node) {
      if (node.low <= this.low) {
        if (this.left === null) {
          this.left = node;
        } else {
          this.left.insert(node);
        }
      } else if (this.right === null) {
        this.right = node;
      } else {
        this.right.insert(node);
      }
    }
    search(point, results) {
      if (point > this.max) {
        return;
      }
      if (this.left !== null) {
        this.left.search(point, results);
      }
      if (this.low <= point && this.high > point) {
        results.push(this);
      }
      if (this.low > point) {
        return;
      }
      if (this.right !== null) {
        this.right.search(point, results);
      }
    }
    searchAfter(point, results) {
      if (this.low >= point) {
        results.push(this);
        if (this.left !== null) {
          this.left.searchAfter(point, results);
        }
      }
      if (this.right !== null) {
        this.right.searchAfter(point, results);
      }
    }
    traverse(callback2) {
      callback2(this);
      if (this.left !== null) {
        this.left.traverse(callback2);
      }
      if (this.right !== null) {
        this.right.traverse(callback2);
      }
    }
    updateHeight() {
      if (this.left !== null && this.right !== null) {
        this.height = Math.max(this.left.height, this.right.height) + 1;
      } else if (this.right !== null) {
        this.height = this.right.height + 1;
      } else if (this.left !== null) {
        this.height = this.left.height + 1;
      } else {
        this.height = 0;
      }
    }
    updateMax() {
      this.max = this.high;
      if (this.left !== null) {
        this.max = Math.max(this.max, this.left.max);
      }
      if (this.right !== null) {
        this.max = Math.max(this.max, this.right.max);
      }
    }
    getBalance() {
      let balance = 0;
      if (this.left !== null && this.right !== null) {
        balance = this.left.height - this.right.height;
      } else if (this.left !== null) {
        balance = this.left.height + 1;
      } else if (this.right !== null) {
        balance = -(this.right.height + 1);
      }
      return balance;
    }
    isLeftChild() {
      return this.parent !== null && this.parent.left === this;
    }
    get left() {
      return this._left;
    }
    set left(node) {
      this._left = node;
      if (node !== null) {
        node.parent = this;
      }
      this.updateHeight();
      this.updateMax();
    }
    get right() {
      return this._right;
    }
    set right(node) {
      this._right = node;
      if (node !== null) {
        node.parent = this;
      }
      this.updateHeight();
      this.updateMax();
    }
    dispose() {
      this.parent = null;
      this._left = null;
      this._right = null;
      this.event = null;
    }
  };

  // node_modules/tone/build/esm/component/channel/Volume.js
  var Volume = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Volume.getDefaults(), arguments, ["volume"]));
      this.name = "Volume";
      const options = optionsFromArguments(Volume.getDefaults(), arguments, ["volume"]);
      this.input = this.output = new Gain({
        context: this.context,
        gain: options.volume,
        units: "decibels"
      });
      this.volume = this.output.gain;
      readOnly(this, "volume");
      this._unmutedVolume = options.volume;
      this.mute = options.mute;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        mute: false,
        volume: 0
      });
    }
    get mute() {
      return this.volume.value === -Infinity;
    }
    set mute(mute) {
      if (!this.mute && mute) {
        this._unmutedVolume = this.volume.value;
        this.volume.value = -Infinity;
      } else if (this.mute && !mute) {
        this.volume.value = this._unmutedVolume;
      }
    }
    dispose() {
      super.dispose();
      this.input.dispose();
      this.volume.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/core/context/Destination.js
  var Destination = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Destination.getDefaults(), arguments));
      this.name = "Destination";
      this.input = new Volume({ context: this.context });
      this.output = new Gain({ context: this.context });
      this.volume = this.input.volume;
      const options = optionsFromArguments(Destination.getDefaults(), arguments);
      connectSeries(this.input, this.output, this.context.rawContext.destination);
      this.mute = options.mute;
      this._internalChannels = [this.input, this.context.rawContext.destination, this.output];
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        mute: false,
        volume: 0
      });
    }
    get mute() {
      return this.input.mute;
    }
    set mute(mute) {
      this.input.mute = mute;
    }
    chain(...args) {
      this.input.disconnect();
      args.unshift(this.input);
      args.push(this.output);
      connectSeries(...args);
      return this;
    }
    get maxChannelCount() {
      return this.context.rawContext.destination.maxChannelCount;
    }
    dispose() {
      super.dispose();
      this.volume.dispose();
      return this;
    }
  };
  onContextInit((context2) => {
    context2.destination = new Destination({ context: context2 });
  });
  onContextClose((context2) => {
    context2.destination.dispose();
  });

  // node_modules/tone/build/esm/core/util/TimelineValue.js
  var TimelineValue = class extends Tone {
    constructor(initialValue) {
      super();
      this.name = "TimelineValue";
      this._timeline = new Timeline({ memory: 10 });
      this._initialValue = initialValue;
    }
    set(value, time) {
      this._timeline.add({
        value,
        time
      });
      return this;
    }
    get(time) {
      const event2 = this._timeline.get(time);
      if (event2) {
        return event2.value;
      } else {
        return this._initialValue;
      }
    }
  };

  // node_modules/tone/build/esm/core/clock/TransportEvent.js
  var TransportEvent = class {
    constructor(transport, opts) {
      this.id = TransportEvent._eventId++;
      const options = Object.assign(TransportEvent.getDefaults(), opts);
      this.transport = transport;
      this.callback = options.callback;
      this._once = options.once;
      this.time = options.time;
    }
    static getDefaults() {
      return {
        callback: noOp,
        once: false,
        time: 0
      };
    }
    invoke(time) {
      if (this.callback) {
        this.callback(time);
        if (this._once) {
          this.transport.clear(this.id);
        }
      }
    }
    dispose() {
      this.callback = void 0;
      return this;
    }
  };
  TransportEvent._eventId = 0;

  // node_modules/tone/build/esm/core/clock/TransportRepeatEvent.js
  var TransportRepeatEvent = class extends TransportEvent {
    constructor(transport, opts) {
      super(transport, opts);
      this._currentId = -1;
      this._nextId = -1;
      this._nextTick = this.time;
      this._boundRestart = this._restart.bind(this);
      const options = Object.assign(TransportRepeatEvent.getDefaults(), opts);
      this.duration = new TicksClass(transport.context, options.duration).valueOf();
      this._interval = new TicksClass(transport.context, options.interval).valueOf();
      this._nextTick = options.time;
      this.transport.on("start", this._boundRestart);
      this.transport.on("loopStart", this._boundRestart);
      this.context = this.transport.context;
      this._restart();
    }
    static getDefaults() {
      return Object.assign({}, TransportEvent.getDefaults(), {
        duration: Infinity,
        interval: 1,
        once: false
      });
    }
    invoke(time) {
      this._createEvents(time);
      super.invoke(time);
    }
    _createEvents(time) {
      const ticks = this.transport.getTicksAtTime(time);
      if (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {
        this._nextTick += this._interval;
        this._currentId = this._nextId;
        this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());
      }
    }
    _restart(time) {
      this.transport.clear(this._currentId);
      this.transport.clear(this._nextId);
      this._nextTick = this.time;
      const ticks = this.transport.getTicksAtTime(time);
      if (ticks > this.time) {
        this._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;
      }
      this._currentId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());
      this._nextTick += this._interval;
      this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());
    }
    dispose() {
      super.dispose();
      this.transport.clear(this._currentId);
      this.transport.clear(this._nextId);
      this.transport.off("start", this._boundRestart);
      this.transport.off("loopStart", this._boundRestart);
      return this;
    }
  };

  // node_modules/tone/build/esm/core/clock/Transport.js
  var Transport = class extends ToneWithContext {
    constructor() {
      super(optionsFromArguments(Transport.getDefaults(), arguments));
      this.name = "Transport";
      this._loop = new TimelineValue(false);
      this._loopStart = 0;
      this._loopEnd = 0;
      this._scheduledEvents = {};
      this._timeline = new Timeline();
      this._repeatedEvents = new IntervalTimeline();
      this._syncedSignals = [];
      this._swingAmount = 0;
      const options = optionsFromArguments(Transport.getDefaults(), arguments);
      this._ppq = options.ppq;
      this._clock = new Clock({
        callback: this._processTick.bind(this),
        context: this.context,
        frequency: 0,
        units: "bpm"
      });
      this._bindClockEvents();
      this.bpm = this._clock.frequency;
      this._clock.frequency.multiplier = options.ppq;
      this.bpm.setValueAtTime(options.bpm, 0);
      readOnly(this, "bpm");
      this._timeSignature = options.timeSignature;
      this._swingTicks = options.ppq / 2;
    }
    static getDefaults() {
      return Object.assign(ToneWithContext.getDefaults(), {
        bpm: 120,
        loopEnd: "4m",
        loopStart: 0,
        ppq: 192,
        swing: 0,
        swingSubdivision: "8n",
        timeSignature: 4
      });
    }
    _processTick(tickTime, ticks) {
      if (this._loop.get(tickTime)) {
        if (ticks >= this._loopEnd) {
          this.emit("loopEnd", tickTime);
          this._clock.setTicksAtTime(this._loopStart, tickTime);
          ticks = this._loopStart;
          this.emit("loopStart", tickTime, this._clock.getSecondsAtTime(tickTime));
          this.emit("loop", tickTime);
        }
      }
      if (this._swingAmount > 0 && ticks % this._ppq !== 0 && ticks % (this._swingTicks * 2) !== 0) {
        const progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);
        const amount = Math.sin(progress * Math.PI) * this._swingAmount;
        tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;
      }
      this._timeline.forEachAtTime(ticks, (event2) => event2.invoke(tickTime));
    }
    schedule(callback2, time) {
      const event2 = new TransportEvent(this, {
        callback: callback2,
        time: new TransportTimeClass(this.context, time).toTicks()
      });
      return this._addEvent(event2, this._timeline);
    }
    scheduleRepeat(callback2, interval, startTime, duration = Infinity) {
      const event2 = new TransportRepeatEvent(this, {
        callback: callback2,
        duration: new TimeClass(this.context, duration).toTicks(),
        interval: new TimeClass(this.context, interval).toTicks(),
        time: new TransportTimeClass(this.context, startTime).toTicks()
      });
      return this._addEvent(event2, this._repeatedEvents);
    }
    scheduleOnce(callback2, time) {
      const event2 = new TransportEvent(this, {
        callback: callback2,
        once: true,
        time: new TransportTimeClass(this.context, time).toTicks()
      });
      return this._addEvent(event2, this._timeline);
    }
    clear(eventId) {
      if (this._scheduledEvents.hasOwnProperty(eventId)) {
        const item = this._scheduledEvents[eventId.toString()];
        item.timeline.remove(item.event);
        item.event.dispose();
        delete this._scheduledEvents[eventId.toString()];
      }
      return this;
    }
    _addEvent(event2, timeline) {
      this._scheduledEvents[event2.id.toString()] = {
        event: event2,
        timeline
      };
      timeline.add(event2);
      return event2.id;
    }
    cancel(after = 0) {
      const computedAfter = this.toTicks(after);
      this._timeline.forEachFrom(computedAfter, (event2) => this.clear(event2.id));
      this._repeatedEvents.forEachFrom(computedAfter, (event2) => this.clear(event2.id));
      return this;
    }
    _bindClockEvents() {
      this._clock.on("start", (time, offset) => {
        offset = new TicksClass(this.context, offset).toSeconds();
        this.emit("start", time, offset);
      });
      this._clock.on("stop", (time) => {
        this.emit("stop", time);
      });
      this._clock.on("pause", (time) => {
        this.emit("pause", time);
      });
    }
    get state() {
      return this._clock.getStateAtTime(this.now());
    }
    start(time, offset) {
      let offsetTicks;
      if (isDefined(offset)) {
        offsetTicks = this.toTicks(offset);
      }
      this._clock.start(time, offsetTicks);
      return this;
    }
    stop(time) {
      this._clock.stop(time);
      return this;
    }
    pause(time) {
      this._clock.pause(time);
      return this;
    }
    toggle(time) {
      time = this.toSeconds(time);
      if (this._clock.getStateAtTime(time) !== "started") {
        this.start(time);
      } else {
        this.stop(time);
      }
      return this;
    }
    get timeSignature() {
      return this._timeSignature;
    }
    set timeSignature(timeSig) {
      if (isArray(timeSig)) {
        timeSig = timeSig[0] / timeSig[1] * 4;
      }
      this._timeSignature = timeSig;
    }
    get loopStart() {
      return new TimeClass(this.context, this._loopStart, "i").toSeconds();
    }
    set loopStart(startPosition) {
      this._loopStart = this.toTicks(startPosition);
    }
    get loopEnd() {
      return new TimeClass(this.context, this._loopEnd, "i").toSeconds();
    }
    set loopEnd(endPosition) {
      this._loopEnd = this.toTicks(endPosition);
    }
    get loop() {
      return this._loop.get(this.now());
    }
    set loop(loop) {
      this._loop.set(loop, this.now());
    }
    setLoopPoints(startPosition, endPosition) {
      this.loopStart = startPosition;
      this.loopEnd = endPosition;
      return this;
    }
    get swing() {
      return this._swingAmount;
    }
    set swing(amount) {
      this._swingAmount = amount;
    }
    get swingSubdivision() {
      return new TicksClass(this.context, this._swingTicks).toNotation();
    }
    set swingSubdivision(subdivision) {
      this._swingTicks = this.toTicks(subdivision);
    }
    get position() {
      const now = this.now();
      const ticks = this._clock.getTicksAtTime(now);
      return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();
    }
    set position(progress) {
      const ticks = this.toTicks(progress);
      this.ticks = ticks;
    }
    get seconds() {
      return this._clock.seconds;
    }
    set seconds(s) {
      const now = this.now();
      const ticks = this._clock.frequency.timeToTicks(s, now);
      this.ticks = ticks;
    }
    get progress() {
      if (this.loop) {
        const now = this.now();
        const ticks = this._clock.getTicksAtTime(now);
        return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);
      } else {
        return 0;
      }
    }
    get ticks() {
      return this._clock.ticks;
    }
    set ticks(t2) {
      if (this._clock.ticks !== t2) {
        const now = this.now();
        if (this.state === "started") {
          const ticks = this._clock.getTicksAtTime(now);
          const remainingTick = this._clock.frequency.getDurationOfTicks(Math.ceil(ticks) - ticks, now);
          const time = now + remainingTick;
          this.emit("stop", time);
          this._clock.setTicksAtTime(t2, time);
          this.emit("start", time, this._clock.getSecondsAtTime(time));
        } else {
          this._clock.setTicksAtTime(t2, now);
        }
      }
    }
    getTicksAtTime(time) {
      return Math.round(this._clock.getTicksAtTime(time));
    }
    getSecondsAtTime(time) {
      return this._clock.getSecondsAtTime(time);
    }
    get PPQ() {
      return this._clock.frequency.multiplier;
    }
    set PPQ(ppq) {
      this._clock.frequency.multiplier = ppq;
    }
    nextSubdivision(subdivision) {
      subdivision = this.toTicks(subdivision);
      if (this.state !== "started") {
        return 0;
      } else {
        const now = this.now();
        const transportPos = this.getTicksAtTime(now);
        const remainingTicks = subdivision - transportPos % subdivision;
        return this._clock.nextTickTime(remainingTicks, now);
      }
    }
    syncSignal(signal, ratio) {
      if (!ratio) {
        const now = this.now();
        if (signal.getValueAtTime(now) !== 0) {
          const bpm = this.bpm.getValueAtTime(now);
          const computedFreq = 1 / (60 / bpm / this.PPQ);
          ratio = signal.getValueAtTime(now) / computedFreq;
        } else {
          ratio = 0;
        }
      }
      const ratioSignal = new Gain(ratio);
      this.bpm.connect(ratioSignal);
      ratioSignal.connect(signal._param);
      this._syncedSignals.push({
        initial: signal.value,
        ratio: ratioSignal,
        signal
      });
      signal.value = 0;
      return this;
    }
    unsyncSignal(signal) {
      for (let i = this._syncedSignals.length - 1; i >= 0; i--) {
        const syncedSignal = this._syncedSignals[i];
        if (syncedSignal.signal === signal) {
          syncedSignal.ratio.dispose();
          syncedSignal.signal.value = syncedSignal.initial;
          this._syncedSignals.splice(i, 1);
        }
      }
      return this;
    }
    dispose() {
      super.dispose();
      this._clock.dispose();
      writable(this, "bpm");
      this._timeline.dispose();
      this._repeatedEvents.dispose();
      return this;
    }
  };
  Emitter.mixin(Transport);
  onContextInit((context2) => {
    context2.transport = new Transport({ context: context2 });
  });
  onContextClose((context2) => {
    context2.transport.dispose();
  });

  // node_modules/tone/build/esm/source/Source.js
  var Source = class extends ToneAudioNode {
    constructor(options) {
      super(options);
      this.input = void 0;
      this._state = new StateTimeline("stopped");
      this._synced = false;
      this._scheduled = [];
      this._syncedStart = noOp;
      this._syncedStop = noOp;
      this._state.memory = 100;
      this._state.increasing = true;
      this._volume = this.output = new Volume({
        context: this.context,
        mute: options.mute,
        volume: options.volume
      });
      this.volume = this._volume.volume;
      readOnly(this, "volume");
      this.onstop = options.onstop;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        mute: false,
        onstop: noOp,
        volume: 0
      });
    }
    get state() {
      if (this._synced) {
        if (this.context.transport.state === "started") {
          return this._state.getValueAtTime(this.context.transport.seconds);
        } else {
          return "stopped";
        }
      } else {
        return this._state.getValueAtTime(this.now());
      }
    }
    get mute() {
      return this._volume.mute;
    }
    set mute(mute) {
      this._volume.mute = mute;
    }
    _clampToCurrentTime(time) {
      if (this._synced) {
        return time;
      } else {
        return Math.max(time, this.context.currentTime);
      }
    }
    start(time, offset, duration) {
      let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);
      computedTime = this._clampToCurrentTime(computedTime);
      if (!this._synced && this._state.getValueAtTime(computedTime) === "started") {
        assert(GT(computedTime, this._state.get(computedTime).time), "Start time must be strictly greater than previous start time");
        this._state.cancel(computedTime);
        this._state.setStateAtTime("started", computedTime);
        this.log("restart", computedTime);
        this.restart(computedTime, offset, duration);
      } else {
        this.log("start", computedTime);
        this._state.setStateAtTime("started", computedTime);
        if (this._synced) {
          const event2 = this._state.get(computedTime);
          if (event2) {
            event2.offset = this.toSeconds(defaultArg(offset, 0));
            event2.duration = duration ? this.toSeconds(duration) : void 0;
          }
          const sched = this.context.transport.schedule((t2) => {
            this._start(t2, offset, duration);
          }, computedTime);
          this._scheduled.push(sched);
          if (this.context.transport.state === "started" && this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {
            this._syncedStart(this.now(), this.context.transport.seconds);
          }
        } else {
          assertContextRunning(this.context);
          this._start(computedTime, offset, duration);
        }
      }
      return this;
    }
    stop(time) {
      let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);
      computedTime = this._clampToCurrentTime(computedTime);
      if (this._state.getValueAtTime(computedTime) === "started" || isDefined(this._state.getNextState("started", computedTime))) {
        this.log("stop", computedTime);
        if (!this._synced) {
          this._stop(computedTime);
        } else {
          const sched = this.context.transport.schedule(this._stop.bind(this), computedTime);
          this._scheduled.push(sched);
        }
        this._state.cancel(computedTime);
        this._state.setStateAtTime("stopped", computedTime);
      }
      return this;
    }
    restart(time, offset, duration) {
      time = this.toSeconds(time);
      if (this._state.getValueAtTime(time) === "started") {
        this._state.cancel(time);
        this._restart(time, offset, duration);
      }
      return this;
    }
    sync() {
      if (!this._synced) {
        this._synced = true;
        this._syncedStart = (time, offset) => {
          if (offset > 0) {
            const stateEvent = this._state.get(offset);
            if (stateEvent && stateEvent.state === "started" && stateEvent.time !== offset) {
              const startOffset = offset - this.toSeconds(stateEvent.time);
              let duration;
              if (stateEvent.duration) {
                duration = this.toSeconds(stateEvent.duration) - startOffset;
              }
              this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);
            }
          }
        };
        this._syncedStop = (time) => {
          const seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));
          if (this._state.getValueAtTime(seconds) === "started") {
            this._stop(time);
          }
        };
        this.context.transport.on("start", this._syncedStart);
        this.context.transport.on("loopStart", this._syncedStart);
        this.context.transport.on("stop", this._syncedStop);
        this.context.transport.on("pause", this._syncedStop);
        this.context.transport.on("loopEnd", this._syncedStop);
      }
      return this;
    }
    unsync() {
      if (this._synced) {
        this.context.transport.off("stop", this._syncedStop);
        this.context.transport.off("pause", this._syncedStop);
        this.context.transport.off("loopEnd", this._syncedStop);
        this.context.transport.off("start", this._syncedStart);
        this.context.transport.off("loopStart", this._syncedStart);
      }
      this._synced = false;
      this._scheduled.forEach((id2) => this.context.transport.clear(id2));
      this._scheduled = [];
      this._state.cancel(0);
      this._stop(0);
      return this;
    }
    dispose() {
      super.dispose();
      this.onstop = noOp;
      this.unsync();
      this._volume.dispose();
      this._state.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/source/buffer/ToneBufferSource.js
  var ToneBufferSource = class extends OneShotSource {
    constructor() {
      super(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, ["url", "onload"]));
      this.name = "ToneBufferSource";
      this._source = this.context.createBufferSource();
      this._internalChannels = [this._source];
      this._sourceStarted = false;
      this._sourceStopped = false;
      const options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, ["url", "onload"]);
      connect(this._source, this._gainNode);
      this._source.onended = () => this._stopSource();
      this.playbackRate = new Param({
        context: this.context,
        param: this._source.playbackRate,
        units: "positive",
        value: options.playbackRate
      });
      this.loop = options.loop;
      this.loopStart = options.loopStart;
      this.loopEnd = options.loopEnd;
      this._buffer = new ToneAudioBuffer(options.url, options.onload, options.onerror);
      this._internalChannels.push(this._source);
    }
    static getDefaults() {
      return Object.assign(OneShotSource.getDefaults(), {
        url: new ToneAudioBuffer(),
        loop: false,
        loopEnd: 0,
        loopStart: 0,
        onload: noOp,
        onerror: noOp,
        playbackRate: 1
      });
    }
    get fadeIn() {
      return this._fadeIn;
    }
    set fadeIn(t2) {
      this._fadeIn = t2;
    }
    get fadeOut() {
      return this._fadeOut;
    }
    set fadeOut(t2) {
      this._fadeOut = t2;
    }
    get curve() {
      return this._curve;
    }
    set curve(t2) {
      this._curve = t2;
    }
    start(time, offset, duration, gain = 1) {
      assert(this.buffer.loaded, "buffer is either not set or not loaded");
      const computedTime = this.toSeconds(time);
      this._startGain(computedTime, gain);
      if (this.loop) {
        offset = defaultArg(offset, this.loopStart);
      } else {
        offset = defaultArg(offset, 0);
      }
      let computedOffset = Math.max(this.toSeconds(offset), 0);
      if (this.loop) {
        const loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;
        const loopStart = this.toSeconds(this.loopStart);
        const loopDuration = loopEnd - loopStart;
        if (GTE(computedOffset, loopEnd)) {
          computedOffset = (computedOffset - loopStart) % loopDuration + loopStart;
        }
        if (EQ(computedOffset, this.buffer.duration)) {
          computedOffset = 0;
        }
      }
      this._source.buffer = this.buffer.get();
      this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;
      if (LT(computedOffset, this.buffer.duration)) {
        this._sourceStarted = true;
        this._source.start(computedTime, computedOffset);
      }
      if (isDefined(duration)) {
        let computedDur = this.toSeconds(duration);
        computedDur = Math.max(computedDur, 0);
        this.stop(computedTime + computedDur);
      }
      return this;
    }
    _stopSource(time) {
      if (!this._sourceStopped && this._sourceStarted) {
        this._sourceStopped = true;
        this._source.stop(this.toSeconds(time));
        this._onended();
      }
    }
    get loopStart() {
      return this._source.loopStart;
    }
    set loopStart(loopStart) {
      this._source.loopStart = this.toSeconds(loopStart);
    }
    get loopEnd() {
      return this._source.loopEnd;
    }
    set loopEnd(loopEnd) {
      this._source.loopEnd = this.toSeconds(loopEnd);
    }
    get buffer() {
      return this._buffer;
    }
    set buffer(buffer) {
      this._buffer.set(buffer);
    }
    get loop() {
      return this._source.loop;
    }
    set loop(loop) {
      this._source.loop = loop;
      if (this._sourceStarted) {
        this.cancelStop();
      }
    }
    dispose() {
      super.dispose();
      this._source.onended = null;
      this._source.disconnect();
      this._buffer.dispose();
      this.playbackRate.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/source/Noise.js
  var BUFFER_LENGTH = 44100 * 5;

  // node_modules/tone/build/esm/source/oscillator/OscillatorInterface.js
  function generateWaveform(instance, length) {
    return __awaiter(this, void 0, void 0, function* () {
      const duration = length / instance.context.sampleRate;
      const context2 = new OfflineContext(1, duration, instance.context.sampleRate);
      const clone3 = new instance.constructor(Object.assign(instance.get(), {
        frequency: 2 / duration,
        detune: 0,
        context: context2
      })).toDestination();
      clone3.start(0);
      const buffer = yield context2.render();
      return buffer.getChannelData(0);
    });
  }

  // node_modules/tone/build/esm/source/oscillator/ToneOscillatorNode.js
  var ToneOscillatorNode = class extends OneShotSource {
    constructor() {
      super(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, ["frequency", "type"]));
      this.name = "ToneOscillatorNode";
      this._oscillator = this.context.createOscillator();
      this._internalChannels = [this._oscillator];
      const options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, ["frequency", "type"]);
      connect(this._oscillator, this._gainNode);
      this.type = options.type;
      this.frequency = new Param({
        context: this.context,
        param: this._oscillator.frequency,
        units: "frequency",
        value: options.frequency
      });
      this.detune = new Param({
        context: this.context,
        param: this._oscillator.detune,
        units: "cents",
        value: options.detune
      });
      readOnly(this, ["frequency", "detune"]);
    }
    static getDefaults() {
      return Object.assign(OneShotSource.getDefaults(), {
        detune: 0,
        frequency: 440,
        type: "sine"
      });
    }
    start(time) {
      const computedTime = this.toSeconds(time);
      this.log("start", computedTime);
      this._startGain(computedTime);
      this._oscillator.start(computedTime);
      return this;
    }
    _stopSource(time) {
      this._oscillator.stop(time);
    }
    setPeriodicWave(periodicWave) {
      this._oscillator.setPeriodicWave(periodicWave);
      return this;
    }
    get type() {
      return this._oscillator.type;
    }
    set type(type) {
      this._oscillator.type = type;
    }
    dispose() {
      super.dispose();
      if (this.state === "started") {
        this.stop();
      }
      this._oscillator.disconnect();
      this.frequency.dispose();
      this.detune.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/source/oscillator/Oscillator.js
  var Oscillator = class extends Source {
    constructor() {
      super(optionsFromArguments(Oscillator.getDefaults(), arguments, ["frequency", "type"]));
      this.name = "Oscillator";
      this._oscillator = null;
      const options = optionsFromArguments(Oscillator.getDefaults(), arguments, ["frequency", "type"]);
      this.frequency = new Signal({
        context: this.context,
        units: "frequency",
        value: options.frequency
      });
      readOnly(this, "frequency");
      this.detune = new Signal({
        context: this.context,
        units: "cents",
        value: options.detune
      });
      readOnly(this, "detune");
      this._partials = options.partials;
      this._partialCount = options.partialCount;
      this._type = options.type;
      if (options.partialCount && options.type !== "custom") {
        this._type = this.baseType + options.partialCount.toString();
      }
      this.phase = options.phase;
    }
    static getDefaults() {
      return Object.assign(Source.getDefaults(), {
        detune: 0,
        frequency: 440,
        partialCount: 0,
        partials: [],
        phase: 0,
        type: "sine"
      });
    }
    _start(time) {
      const computedTime = this.toSeconds(time);
      const oscillator = new ToneOscillatorNode({
        context: this.context,
        onended: () => this.onstop(this)
      });
      this._oscillator = oscillator;
      if (this._wave) {
        this._oscillator.setPeriodicWave(this._wave);
      } else {
        this._oscillator.type = this._type;
      }
      this._oscillator.connect(this.output);
      this.frequency.connect(this._oscillator.frequency);
      this.detune.connect(this._oscillator.detune);
      this._oscillator.start(computedTime);
    }
    _stop(time) {
      const computedTime = this.toSeconds(time);
      if (this._oscillator) {
        this._oscillator.stop(computedTime);
      }
    }
    _restart(time) {
      const computedTime = this.toSeconds(time);
      this.log("restart", computedTime);
      if (this._oscillator) {
        this._oscillator.cancelStop();
      }
      this._state.cancel(computedTime);
      return this;
    }
    syncFrequency() {
      this.context.transport.syncSignal(this.frequency);
      return this;
    }
    unsyncFrequency() {
      this.context.transport.unsyncSignal(this.frequency);
      return this;
    }
    _getCachedPeriodicWave() {
      if (this._type === "custom") {
        const oscProps = Oscillator._periodicWaveCache.find((description) => {
          return description.phase === this._phase && deepEquals(description.partials, this._partials);
        });
        return oscProps;
      } else {
        const oscProps = Oscillator._periodicWaveCache.find((description) => {
          return description.type === this._type && description.phase === this._phase;
        });
        this._partialCount = oscProps ? oscProps.partialCount : this._partialCount;
        return oscProps;
      }
    }
    get type() {
      return this._type;
    }
    set type(type) {
      this._type = type;
      const isBasicType = ["sine", "square", "sawtooth", "triangle"].indexOf(type) !== -1;
      if (this._phase === 0 && isBasicType) {
        this._wave = void 0;
        this._partialCount = 0;
        if (this._oscillator !== null) {
          this._oscillator.type = type;
        }
      } else {
        const cache = this._getCachedPeriodicWave();
        if (isDefined(cache)) {
          const { partials, wave } = cache;
          this._wave = wave;
          this._partials = partials;
          if (this._oscillator !== null) {
            this._oscillator.setPeriodicWave(this._wave);
          }
        } else {
          const [real, imag] = this._getRealImaginary(type, this._phase);
          const periodicWave = this.context.createPeriodicWave(real, imag);
          this._wave = periodicWave;
          if (this._oscillator !== null) {
            this._oscillator.setPeriodicWave(this._wave);
          }
          Oscillator._periodicWaveCache.push({
            imag,
            partialCount: this._partialCount,
            partials: this._partials,
            phase: this._phase,
            real,
            type: this._type,
            wave: this._wave
          });
          if (Oscillator._periodicWaveCache.length > 100) {
            Oscillator._periodicWaveCache.shift();
          }
        }
      }
    }
    get baseType() {
      return this._type.replace(this.partialCount.toString(), "");
    }
    set baseType(baseType) {
      if (this.partialCount && this._type !== "custom" && baseType !== "custom") {
        this.type = baseType + this.partialCount;
      } else {
        this.type = baseType;
      }
    }
    get partialCount() {
      return this._partialCount;
    }
    set partialCount(p) {
      assertRange(p, 0);
      let type = this._type;
      const partial = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);
      if (partial) {
        type = partial[1];
      }
      if (this._type !== "custom") {
        if (p === 0) {
          this.type = type;
        } else {
          this.type = type + p.toString();
        }
      } else {
        const fullPartials = new Float32Array(p);
        this._partials.forEach((v, i) => fullPartials[i] = v);
        this._partials = Array.from(fullPartials);
        this.type = this._type;
      }
    }
    _getRealImaginary(type, phase) {
      const fftSize = 4096;
      let periodicWaveSize = fftSize / 2;
      const real = new Float32Array(periodicWaveSize);
      const imag = new Float32Array(periodicWaveSize);
      let partialCount = 1;
      if (type === "custom") {
        partialCount = this._partials.length + 1;
        this._partialCount = this._partials.length;
        periodicWaveSize = partialCount;
        if (this._partials.length === 0) {
          return [real, imag];
        }
      } else {
        const partial = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(type);
        if (partial) {
          partialCount = parseInt(partial[2], 10) + 1;
          this._partialCount = parseInt(partial[2], 10);
          type = partial[1];
          partialCount = Math.max(partialCount, 2);
          periodicWaveSize = partialCount;
        } else {
          this._partialCount = 0;
        }
        this._partials = [];
      }
      for (let n = 1; n < periodicWaveSize; ++n) {
        const piFactor = 2 / (n * Math.PI);
        let b;
        switch (type) {
          case "sine":
            b = n <= partialCount ? 1 : 0;
            this._partials[n - 1] = b;
            break;
          case "square":
            b = n & 1 ? 2 * piFactor : 0;
            this._partials[n - 1] = b;
            break;
          case "sawtooth":
            b = piFactor * (n & 1 ? 1 : -1);
            this._partials[n - 1] = b;
            break;
          case "triangle":
            if (n & 1) {
              b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);
            } else {
              b = 0;
            }
            this._partials[n - 1] = b;
            break;
          case "custom":
            b = this._partials[n - 1];
            break;
          default:
            throw new TypeError("Oscillator: invalid type: " + type);
        }
        if (b !== 0) {
          real[n] = -b * Math.sin(phase * n);
          imag[n] = b * Math.cos(phase * n);
        } else {
          real[n] = 0;
          imag[n] = 0;
        }
      }
      return [real, imag];
    }
    _inverseFFT(real, imag, phase) {
      let sum = 0;
      const len = real.length;
      for (let i = 0; i < len; i++) {
        sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);
      }
      return sum;
    }
    getInitialValue() {
      const [real, imag] = this._getRealImaginary(this._type, 0);
      let maxValue = 0;
      const twoPi = Math.PI * 2;
      const testPositions = 32;
      for (let i = 0; i < testPositions; i++) {
        maxValue = Math.max(this._inverseFFT(real, imag, i / testPositions * twoPi), maxValue);
      }
      return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);
    }
    get partials() {
      return this._partials.slice(0, this.partialCount);
    }
    set partials(partials) {
      this._partials = partials;
      this._partialCount = this._partials.length;
      if (partials.length) {
        this.type = "custom";
      }
    }
    get phase() {
      return this._phase * (180 / Math.PI);
    }
    set phase(phase) {
      this._phase = phase * Math.PI / 180;
      this.type = this._type;
    }
    asArray(length = 1024) {
      return __awaiter(this, void 0, void 0, function* () {
        return generateWaveform(this, length);
      });
    }
    dispose() {
      super.dispose();
      if (this._oscillator !== null) {
        this._oscillator.dispose();
      }
      this._wave = void 0;
      this.frequency.dispose();
      this.detune.dispose();
      return this;
    }
  };
  Oscillator._periodicWaveCache = [];

  // node_modules/tone/build/esm/signal/SignalOperator.js
  var SignalOperator = class extends ToneAudioNode {
    constructor() {
      super(Object.assign(optionsFromArguments(SignalOperator.getDefaults(), arguments, ["context"])));
    }
    connect(destination, outputNum = 0, inputNum = 0) {
      connectSignal(this, destination, outputNum, inputNum);
      return this;
    }
  };

  // node_modules/tone/build/esm/signal/WaveShaper.js
  var WaveShaper = class extends SignalOperator {
    constructor() {
      super(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, ["mapping", "length"])));
      this.name = "WaveShaper";
      this._shaper = this.context.createWaveShaper();
      this.input = this._shaper;
      this.output = this._shaper;
      const options = optionsFromArguments(WaveShaper.getDefaults(), arguments, ["mapping", "length"]);
      if (isArray(options.mapping) || options.mapping instanceof Float32Array) {
        this.curve = Float32Array.from(options.mapping);
      } else if (isFunction(options.mapping)) {
        this.setMap(options.mapping, options.length);
      }
    }
    static getDefaults() {
      return Object.assign(Signal.getDefaults(), {
        length: 1024
      });
    }
    setMap(mapping, length = 1024) {
      const array = new Float32Array(length);
      for (let i = 0, len = length; i < len; i++) {
        const normalized = i / (len - 1) * 2 - 1;
        array[i] = mapping(normalized, i);
      }
      this.curve = array;
      return this;
    }
    get curve() {
      return this._shaper.curve;
    }
    set curve(mapping) {
      this._shaper.curve = mapping;
    }
    get oversample() {
      return this._shaper.oversample;
    }
    set oversample(oversampling) {
      const isOverSampleType = ["none", "2x", "4x"].some((str) => str.includes(oversampling));
      assert(isOverSampleType, "oversampling must be either 'none', '2x', or '4x'");
      this._shaper.oversample = oversampling;
    }
    dispose() {
      super.dispose();
      this._shaper.disconnect();
      return this;
    }
  };

  // node_modules/tone/build/esm/signal/AudioToGain.js
  var AudioToGain = class extends SignalOperator {
    constructor() {
      super(...arguments);
      this.name = "AudioToGain";
      this._norm = new WaveShaper({
        context: this.context,
        mapping: (x) => (x + 1) / 2
      });
      this.input = this._norm;
      this.output = this._norm;
    }
    dispose() {
      super.dispose();
      this._norm.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/signal/Multiply.js
  var Multiply = class extends Signal {
    constructor() {
      super(Object.assign(optionsFromArguments(Multiply.getDefaults(), arguments, ["value"])));
      this.name = "Multiply";
      this.override = false;
      const options = optionsFromArguments(Multiply.getDefaults(), arguments, ["value"]);
      this._mult = this.input = this.output = new Gain({
        context: this.context,
        minValue: options.minValue,
        maxValue: options.maxValue
      });
      this.factor = this._param = this._mult.gain;
      this.factor.setValueAtTime(options.value, 0);
    }
    static getDefaults() {
      return Object.assign(Signal.getDefaults(), {
        value: 0
      });
    }
    dispose() {
      super.dispose();
      this._mult.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/source/oscillator/AMOscillator.js
  var AMOscillator = class extends Source {
    constructor() {
      super(optionsFromArguments(AMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]));
      this.name = "AMOscillator";
      this._modulationScale = new AudioToGain({ context: this.context });
      this._modulationNode = new Gain({
        context: this.context
      });
      const options = optionsFromArguments(AMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
      this._carrier = new Oscillator({
        context: this.context,
        detune: options.detune,
        frequency: options.frequency,
        onstop: () => this.onstop(this),
        phase: options.phase,
        type: options.type
      });
      this.frequency = this._carrier.frequency, this.detune = this._carrier.detune;
      this._modulator = new Oscillator({
        context: this.context,
        phase: options.phase,
        type: options.modulationType
      });
      this.harmonicity = new Multiply({
        context: this.context,
        units: "positive",
        value: options.harmonicity
      });
      this.frequency.chain(this.harmonicity, this._modulator.frequency);
      this._modulator.chain(this._modulationScale, this._modulationNode.gain);
      this._carrier.chain(this._modulationNode, this.output);
      readOnly(this, ["frequency", "detune", "harmonicity"]);
    }
    static getDefaults() {
      return Object.assign(Oscillator.getDefaults(), {
        harmonicity: 1,
        modulationType: "square"
      });
    }
    _start(time) {
      this._modulator.start(time);
      this._carrier.start(time);
    }
    _stop(time) {
      this._modulator.stop(time);
      this._carrier.stop(time);
    }
    _restart(time) {
      this._modulator.restart(time);
      this._carrier.restart(time);
    }
    get type() {
      return this._carrier.type;
    }
    set type(type) {
      this._carrier.type = type;
    }
    get baseType() {
      return this._carrier.baseType;
    }
    set baseType(baseType) {
      this._carrier.baseType = baseType;
    }
    get partialCount() {
      return this._carrier.partialCount;
    }
    set partialCount(partialCount) {
      this._carrier.partialCount = partialCount;
    }
    get modulationType() {
      return this._modulator.type;
    }
    set modulationType(type) {
      this._modulator.type = type;
    }
    get phase() {
      return this._carrier.phase;
    }
    set phase(phase) {
      this._carrier.phase = phase;
      this._modulator.phase = phase;
    }
    get partials() {
      return this._carrier.partials;
    }
    set partials(partials) {
      this._carrier.partials = partials;
    }
    asArray(length = 1024) {
      return __awaiter(this, void 0, void 0, function* () {
        return generateWaveform(this, length);
      });
    }
    dispose() {
      super.dispose();
      this.frequency.dispose();
      this.detune.dispose();
      this.harmonicity.dispose();
      this._carrier.dispose();
      this._modulator.dispose();
      this._modulationNode.dispose();
      this._modulationScale.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/source/oscillator/FMOscillator.js
  var FMOscillator = class extends Source {
    constructor() {
      super(optionsFromArguments(FMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]));
      this.name = "FMOscillator";
      this._modulationNode = new Gain({
        context: this.context,
        gain: 0
      });
      const options = optionsFromArguments(FMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
      this._carrier = new Oscillator({
        context: this.context,
        detune: options.detune,
        frequency: 0,
        onstop: () => this.onstop(this),
        phase: options.phase,
        type: options.type
      });
      this.detune = this._carrier.detune;
      this.frequency = new Signal({
        context: this.context,
        units: "frequency",
        value: options.frequency
      });
      this._modulator = new Oscillator({
        context: this.context,
        phase: options.phase,
        type: options.modulationType
      });
      this.harmonicity = new Multiply({
        context: this.context,
        units: "positive",
        value: options.harmonicity
      });
      this.modulationIndex = new Multiply({
        context: this.context,
        units: "positive",
        value: options.modulationIndex
      });
      this.frequency.connect(this._carrier.frequency);
      this.frequency.chain(this.harmonicity, this._modulator.frequency);
      this.frequency.chain(this.modulationIndex, this._modulationNode);
      this._modulator.connect(this._modulationNode.gain);
      this._modulationNode.connect(this._carrier.frequency);
      this._carrier.connect(this.output);
      this.detune.connect(this._modulator.detune);
      readOnly(this, ["modulationIndex", "frequency", "detune", "harmonicity"]);
    }
    static getDefaults() {
      return Object.assign(Oscillator.getDefaults(), {
        harmonicity: 1,
        modulationIndex: 2,
        modulationType: "square"
      });
    }
    _start(time) {
      this._modulator.start(time);
      this._carrier.start(time);
    }
    _stop(time) {
      this._modulator.stop(time);
      this._carrier.stop(time);
    }
    _restart(time) {
      this._modulator.restart(time);
      this._carrier.restart(time);
      return this;
    }
    get type() {
      return this._carrier.type;
    }
    set type(type) {
      this._carrier.type = type;
    }
    get baseType() {
      return this._carrier.baseType;
    }
    set baseType(baseType) {
      this._carrier.baseType = baseType;
    }
    get partialCount() {
      return this._carrier.partialCount;
    }
    set partialCount(partialCount) {
      this._carrier.partialCount = partialCount;
    }
    get modulationType() {
      return this._modulator.type;
    }
    set modulationType(type) {
      this._modulator.type = type;
    }
    get phase() {
      return this._carrier.phase;
    }
    set phase(phase) {
      this._carrier.phase = phase;
      this._modulator.phase = phase;
    }
    get partials() {
      return this._carrier.partials;
    }
    set partials(partials) {
      this._carrier.partials = partials;
    }
    asArray(length = 1024) {
      return __awaiter(this, void 0, void 0, function* () {
        return generateWaveform(this, length);
      });
    }
    dispose() {
      super.dispose();
      this.frequency.dispose();
      this.harmonicity.dispose();
      this._carrier.dispose();
      this._modulator.dispose();
      this._modulationNode.dispose();
      this.modulationIndex.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/source/oscillator/PulseOscillator.js
  var PulseOscillator = class extends Source {
    constructor() {
      super(optionsFromArguments(PulseOscillator.getDefaults(), arguments, ["frequency", "width"]));
      this.name = "PulseOscillator";
      this._widthGate = new Gain({
        context: this.context,
        gain: 0
      });
      this._thresh = new WaveShaper({
        context: this.context,
        mapping: (val) => val <= 0 ? -1 : 1
      });
      const options = optionsFromArguments(PulseOscillator.getDefaults(), arguments, ["frequency", "width"]);
      this.width = new Signal({
        context: this.context,
        units: "audioRange",
        value: options.width
      });
      this._triangle = new Oscillator({
        context: this.context,
        detune: options.detune,
        frequency: options.frequency,
        onstop: () => this.onstop(this),
        phase: options.phase,
        type: "triangle"
      });
      this.frequency = this._triangle.frequency;
      this.detune = this._triangle.detune;
      this._triangle.chain(this._thresh, this.output);
      this.width.chain(this._widthGate, this._thresh);
      readOnly(this, ["width", "frequency", "detune"]);
    }
    static getDefaults() {
      return Object.assign(Source.getDefaults(), {
        detune: 0,
        frequency: 440,
        phase: 0,
        type: "pulse",
        width: 0.2
      });
    }
    _start(time) {
      time = this.toSeconds(time);
      this._triangle.start(time);
      this._widthGate.gain.setValueAtTime(1, time);
    }
    _stop(time) {
      time = this.toSeconds(time);
      this._triangle.stop(time);
      this._widthGate.gain.cancelScheduledValues(time);
      this._widthGate.gain.setValueAtTime(0, time);
    }
    _restart(time) {
      this._triangle.restart(time);
      this._widthGate.gain.cancelScheduledValues(time);
      this._widthGate.gain.setValueAtTime(1, time);
    }
    get phase() {
      return this._triangle.phase;
    }
    set phase(phase) {
      this._triangle.phase = phase;
    }
    get type() {
      return "pulse";
    }
    get baseType() {
      return "pulse";
    }
    get partials() {
      return [];
    }
    get partialCount() {
      return 0;
    }
    set carrierType(type) {
      this._triangle.type = type;
    }
    asArray(length = 1024) {
      return __awaiter(this, void 0, void 0, function* () {
        return generateWaveform(this, length);
      });
    }
    dispose() {
      super.dispose();
      this._triangle.dispose();
      this.width.dispose();
      this._widthGate.dispose();
      this._thresh.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/source/oscillator/FatOscillator.js
  var FatOscillator = class extends Source {
    constructor() {
      super(optionsFromArguments(FatOscillator.getDefaults(), arguments, ["frequency", "type", "spread"]));
      this.name = "FatOscillator";
      this._oscillators = [];
      const options = optionsFromArguments(FatOscillator.getDefaults(), arguments, ["frequency", "type", "spread"]);
      this.frequency = new Signal({
        context: this.context,
        units: "frequency",
        value: options.frequency
      });
      this.detune = new Signal({
        context: this.context,
        units: "cents",
        value: options.detune
      });
      this._spread = options.spread;
      this._type = options.type;
      this._phase = options.phase;
      this._partials = options.partials;
      this._partialCount = options.partialCount;
      this.count = options.count;
      readOnly(this, ["frequency", "detune"]);
    }
    static getDefaults() {
      return Object.assign(Oscillator.getDefaults(), {
        count: 3,
        spread: 20,
        type: "sawtooth"
      });
    }
    _start(time) {
      time = this.toSeconds(time);
      this._forEach((osc) => osc.start(time));
    }
    _stop(time) {
      time = this.toSeconds(time);
      this._forEach((osc) => osc.stop(time));
    }
    _restart(time) {
      this._forEach((osc) => osc.restart(time));
    }
    _forEach(iterator) {
      for (let i = 0; i < this._oscillators.length; i++) {
        iterator(this._oscillators[i], i);
      }
    }
    get type() {
      return this._type;
    }
    set type(type) {
      this._type = type;
      this._forEach((osc) => osc.type = type);
    }
    get spread() {
      return this._spread;
    }
    set spread(spread) {
      this._spread = spread;
      if (this._oscillators.length > 1) {
        const start2 = -spread / 2;
        const step = spread / (this._oscillators.length - 1);
        this._forEach((osc, i) => osc.detune.value = start2 + step * i);
      }
    }
    get count() {
      return this._oscillators.length;
    }
    set count(count) {
      assertRange(count, 1);
      if (this._oscillators.length !== count) {
        this._forEach((osc) => osc.dispose());
        this._oscillators = [];
        for (let i = 0; i < count; i++) {
          const osc = new Oscillator({
            context: this.context,
            volume: -6 - count * 1.1,
            type: this._type,
            phase: this._phase + i / count * 360,
            partialCount: this._partialCount,
            onstop: i === 0 ? () => this.onstop(this) : noOp
          });
          if (this.type === "custom") {
            osc.partials = this._partials;
          }
          this.frequency.connect(osc.frequency);
          this.detune.connect(osc.detune);
          osc.detune.overridden = false;
          osc.connect(this.output);
          this._oscillators[i] = osc;
        }
        this.spread = this._spread;
        if (this.state === "started") {
          this._forEach((osc) => osc.start());
        }
      }
    }
    get phase() {
      return this._phase;
    }
    set phase(phase) {
      this._phase = phase;
      this._forEach((osc, i) => osc.phase = this._phase + i / this.count * 360);
    }
    get baseType() {
      return this._oscillators[0].baseType;
    }
    set baseType(baseType) {
      this._forEach((osc) => osc.baseType = baseType);
      this._type = this._oscillators[0].type;
    }
    get partials() {
      return this._oscillators[0].partials;
    }
    set partials(partials) {
      this._partials = partials;
      this._partialCount = this._partials.length;
      if (partials.length) {
        this._type = "custom";
        this._forEach((osc) => osc.partials = partials);
      }
    }
    get partialCount() {
      return this._oscillators[0].partialCount;
    }
    set partialCount(partialCount) {
      this._partialCount = partialCount;
      this._forEach((osc) => osc.partialCount = partialCount);
      this._type = this._oscillators[0].type;
    }
    asArray(length = 1024) {
      return __awaiter(this, void 0, void 0, function* () {
        return generateWaveform(this, length);
      });
    }
    dispose() {
      super.dispose();
      this.frequency.dispose();
      this.detune.dispose();
      this._forEach((osc) => osc.dispose());
      return this;
    }
  };

  // node_modules/tone/build/esm/source/oscillator/PWMOscillator.js
  var PWMOscillator = class extends Source {
    constructor() {
      super(optionsFromArguments(PWMOscillator.getDefaults(), arguments, ["frequency", "modulationFrequency"]));
      this.name = "PWMOscillator";
      this.sourceType = "pwm";
      this._scale = new Multiply({
        context: this.context,
        value: 2
      });
      const options = optionsFromArguments(PWMOscillator.getDefaults(), arguments, ["frequency", "modulationFrequency"]);
      this._pulse = new PulseOscillator({
        context: this.context,
        frequency: options.modulationFrequency
      });
      this._pulse.carrierType = "sine";
      this.modulationFrequency = this._pulse.frequency;
      this._modulator = new Oscillator({
        context: this.context,
        detune: options.detune,
        frequency: options.frequency,
        onstop: () => this.onstop(this),
        phase: options.phase
      });
      this.frequency = this._modulator.frequency;
      this.detune = this._modulator.detune;
      this._modulator.chain(this._scale, this._pulse.width);
      this._pulse.connect(this.output);
      readOnly(this, ["modulationFrequency", "frequency", "detune"]);
    }
    static getDefaults() {
      return Object.assign(Source.getDefaults(), {
        detune: 0,
        frequency: 440,
        modulationFrequency: 0.4,
        phase: 0,
        type: "pwm"
      });
    }
    _start(time) {
      time = this.toSeconds(time);
      this._modulator.start(time);
      this._pulse.start(time);
    }
    _stop(time) {
      time = this.toSeconds(time);
      this._modulator.stop(time);
      this._pulse.stop(time);
    }
    _restart(time) {
      this._modulator.restart(time);
      this._pulse.restart(time);
    }
    get type() {
      return "pwm";
    }
    get baseType() {
      return "pwm";
    }
    get partials() {
      return [];
    }
    get partialCount() {
      return 0;
    }
    get phase() {
      return this._modulator.phase;
    }
    set phase(phase) {
      this._modulator.phase = phase;
    }
    asArray(length = 1024) {
      return __awaiter(this, void 0, void 0, function* () {
        return generateWaveform(this, length);
      });
    }
    dispose() {
      super.dispose();
      this._pulse.dispose();
      this._scale.dispose();
      this._modulator.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/source/oscillator/OmniOscillator.js
  var OmniOscillatorSourceMap = {
    am: AMOscillator,
    fat: FatOscillator,
    fm: FMOscillator,
    oscillator: Oscillator,
    pulse: PulseOscillator,
    pwm: PWMOscillator
  };
  var OmniOscillator = class extends Source {
    constructor() {
      super(optionsFromArguments(OmniOscillator.getDefaults(), arguments, ["frequency", "type"]));
      this.name = "OmniOscillator";
      const options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, ["frequency", "type"]);
      this.frequency = new Signal({
        context: this.context,
        units: "frequency",
        value: options.frequency
      });
      this.detune = new Signal({
        context: this.context,
        units: "cents",
        value: options.detune
      });
      readOnly(this, ["frequency", "detune"]);
      this.set(options);
    }
    static getDefaults() {
      return Object.assign(Oscillator.getDefaults(), FMOscillator.getDefaults(), AMOscillator.getDefaults(), FatOscillator.getDefaults(), PulseOscillator.getDefaults(), PWMOscillator.getDefaults());
    }
    _start(time) {
      this._oscillator.start(time);
    }
    _stop(time) {
      this._oscillator.stop(time);
    }
    _restart(time) {
      this._oscillator.restart(time);
      return this;
    }
    get type() {
      let prefix = "";
      if (["am", "fm", "fat"].some((p) => this._sourceType === p)) {
        prefix = this._sourceType;
      }
      return prefix + this._oscillator.type;
    }
    set type(type) {
      if (type.substr(0, 2) === "fm") {
        this._createNewOscillator("fm");
        this._oscillator = this._oscillator;
        this._oscillator.type = type.substr(2);
      } else if (type.substr(0, 2) === "am") {
        this._createNewOscillator("am");
        this._oscillator = this._oscillator;
        this._oscillator.type = type.substr(2);
      } else if (type.substr(0, 3) === "fat") {
        this._createNewOscillator("fat");
        this._oscillator = this._oscillator;
        this._oscillator.type = type.substr(3);
      } else if (type === "pwm") {
        this._createNewOscillator("pwm");
        this._oscillator = this._oscillator;
      } else if (type === "pulse") {
        this._createNewOscillator("pulse");
      } else {
        this._createNewOscillator("oscillator");
        this._oscillator = this._oscillator;
        this._oscillator.type = type;
      }
    }
    get partials() {
      return this._oscillator.partials;
    }
    set partials(partials) {
      if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm")) {
        this._oscillator.partials = partials;
      }
    }
    get partialCount() {
      return this._oscillator.partialCount;
    }
    set partialCount(partialCount) {
      if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm")) {
        this._oscillator.partialCount = partialCount;
      }
    }
    set(props) {
      if (Reflect.has(props, "type") && props.type) {
        this.type = props.type;
      }
      super.set(props);
      return this;
    }
    _createNewOscillator(oscType) {
      if (oscType !== this._sourceType) {
        this._sourceType = oscType;
        const OscConstructor = OmniOscillatorSourceMap[oscType];
        const now = this.now();
        if (this._oscillator) {
          const oldOsc = this._oscillator;
          oldOsc.stop(now);
          this.context.setTimeout(() => oldOsc.dispose(), this.blockTime);
        }
        this._oscillator = new OscConstructor({
          context: this.context
        });
        this.frequency.connect(this._oscillator.frequency);
        this.detune.connect(this._oscillator.detune);
        this._oscillator.connect(this.output);
        this._oscillator.onstop = () => this.onstop(this);
        if (this.state === "started") {
          this._oscillator.start(now);
        }
      }
    }
    get phase() {
      return this._oscillator.phase;
    }
    set phase(phase) {
      this._oscillator.phase = phase;
    }
    get sourceType() {
      return this._sourceType;
    }
    set sourceType(sType) {
      let baseType = "sine";
      if (this._oscillator.type !== "pwm" && this._oscillator.type !== "pulse") {
        baseType = this._oscillator.type;
      }
      if (sType === "fm") {
        this.type = "fm" + baseType;
      } else if (sType === "am") {
        this.type = "am" + baseType;
      } else if (sType === "fat") {
        this.type = "fat" + baseType;
      } else if (sType === "oscillator") {
        this.type = baseType;
      } else if (sType === "pulse") {
        this.type = "pulse";
      } else if (sType === "pwm") {
        this.type = "pwm";
      }
    }
    _getOscType(osc, sourceType) {
      return osc instanceof OmniOscillatorSourceMap[sourceType];
    }
    get baseType() {
      return this._oscillator.baseType;
    }
    set baseType(baseType) {
      if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && baseType !== "pulse" && baseType !== "pwm") {
        this._oscillator.baseType = baseType;
      }
    }
    get width() {
      if (this._getOscType(this._oscillator, "pulse")) {
        return this._oscillator.width;
      } else {
        return void 0;
      }
    }
    get count() {
      if (this._getOscType(this._oscillator, "fat")) {
        return this._oscillator.count;
      } else {
        return void 0;
      }
    }
    set count(count) {
      if (this._getOscType(this._oscillator, "fat") && isNumber(count)) {
        this._oscillator.count = count;
      }
    }
    get spread() {
      if (this._getOscType(this._oscillator, "fat")) {
        return this._oscillator.spread;
      } else {
        return void 0;
      }
    }
    set spread(spread) {
      if (this._getOscType(this._oscillator, "fat") && isNumber(spread)) {
        this._oscillator.spread = spread;
      }
    }
    get modulationType() {
      if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) {
        return this._oscillator.modulationType;
      } else {
        return void 0;
      }
    }
    set modulationType(mType) {
      if ((this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && isString(mType)) {
        this._oscillator.modulationType = mType;
      }
    }
    get modulationIndex() {
      if (this._getOscType(this._oscillator, "fm")) {
        return this._oscillator.modulationIndex;
      } else {
        return void 0;
      }
    }
    get harmonicity() {
      if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) {
        return this._oscillator.harmonicity;
      } else {
        return void 0;
      }
    }
    get modulationFrequency() {
      if (this._getOscType(this._oscillator, "pwm")) {
        return this._oscillator.modulationFrequency;
      } else {
        return void 0;
      }
    }
    asArray(length = 1024) {
      return __awaiter(this, void 0, void 0, function* () {
        return generateWaveform(this, length);
      });
    }
    dispose() {
      super.dispose();
      this.detune.dispose();
      this.frequency.dispose();
      this._oscillator.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/core/util/Decorator.js
  function range(min, max = Infinity) {
    const valueMap = new WeakMap();
    return function(target, propertyKey) {
      Reflect.defineProperty(target, propertyKey, {
        configurable: true,
        enumerable: true,
        get: function() {
          return valueMap.get(this);
        },
        set: function(newValue) {
          assertRange(newValue, min, max);
          valueMap.set(this, newValue);
        }
      });
    };
  }
  function timeRange(min, max = Infinity) {
    const valueMap = new WeakMap();
    return function(target, propertyKey) {
      Reflect.defineProperty(target, propertyKey, {
        configurable: true,
        enumerable: true,
        get: function() {
          return valueMap.get(this);
        },
        set: function(newValue) {
          assertRange(this.toSeconds(newValue), min, max);
          valueMap.set(this, newValue);
        }
      });
    };
  }

  // node_modules/tone/build/esm/source/buffer/Player.js
  var Player = class extends Source {
    constructor() {
      super(optionsFromArguments(Player.getDefaults(), arguments, ["url", "onload"]));
      this.name = "Player";
      this._activeSources = new Set();
      const options = optionsFromArguments(Player.getDefaults(), arguments, ["url", "onload"]);
      this._buffer = new ToneAudioBuffer({
        onload: this._onload.bind(this, options.onload),
        onerror: options.onerror,
        reverse: options.reverse,
        url: options.url
      });
      this.autostart = options.autostart;
      this._loop = options.loop;
      this._loopStart = options.loopStart;
      this._loopEnd = options.loopEnd;
      this._playbackRate = options.playbackRate;
      this.fadeIn = options.fadeIn;
      this.fadeOut = options.fadeOut;
    }
    static getDefaults() {
      return Object.assign(Source.getDefaults(), {
        autostart: false,
        fadeIn: 0,
        fadeOut: 0,
        loop: false,
        loopEnd: 0,
        loopStart: 0,
        onload: noOp,
        onerror: noOp,
        playbackRate: 1,
        reverse: false
      });
    }
    load(url) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this._buffer.load(url);
        this._onload();
        return this;
      });
    }
    _onload(callback2 = noOp) {
      callback2();
      if (this.autostart) {
        this.start();
      }
    }
    _onSourceEnd(source) {
      this.onstop(this);
      this._activeSources.delete(source);
      if (this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === "started") {
        this._state.cancel(this.now());
        this._state.setStateAtTime("stopped", this.now());
      }
    }
    start(time, offset, duration) {
      super.start(time, offset, duration);
      return this;
    }
    _start(startTime, offset, duration) {
      if (this._loop) {
        offset = defaultArg(offset, this._loopStart);
      } else {
        offset = defaultArg(offset, 0);
      }
      const computedOffset = this.toSeconds(offset);
      const origDuration = duration;
      duration = defaultArg(duration, Math.max(this._buffer.duration - computedOffset, 0));
      let computedDuration = this.toSeconds(duration);
      computedDuration = computedDuration / this._playbackRate;
      startTime = this.toSeconds(startTime);
      const source = new ToneBufferSource({
        url: this._buffer,
        context: this.context,
        fadeIn: this.fadeIn,
        fadeOut: this.fadeOut,
        loop: this._loop,
        loopEnd: this._loopEnd,
        loopStart: this._loopStart,
        onended: this._onSourceEnd.bind(this),
        playbackRate: this._playbackRate
      }).connect(this.output);
      if (!this._loop && !this._synced) {
        this._state.cancel(startTime + computedDuration);
        this._state.setStateAtTime("stopped", startTime + computedDuration, {
          implicitEnd: true
        });
      }
      this._activeSources.add(source);
      if (this._loop && isUndef(origDuration)) {
        source.start(startTime, computedOffset);
      } else {
        source.start(startTime, computedOffset, computedDuration - this.toSeconds(this.fadeOut));
      }
    }
    _stop(time) {
      const computedTime = this.toSeconds(time);
      this._activeSources.forEach((source) => source.stop(computedTime));
    }
    restart(time, offset, duration) {
      super.restart(time, offset, duration);
      return this;
    }
    _restart(time, offset, duration) {
      this._stop(time);
      this._start(time, offset, duration);
    }
    seek(offset, when) {
      const computedTime = this.toSeconds(when);
      if (this._state.getValueAtTime(computedTime) === "started") {
        const computedOffset = this.toSeconds(offset);
        this._stop(computedTime);
        this._start(computedTime, computedOffset);
      }
      return this;
    }
    setLoopPoints(loopStart, loopEnd) {
      this.loopStart = loopStart;
      this.loopEnd = loopEnd;
      return this;
    }
    get loopStart() {
      return this._loopStart;
    }
    set loopStart(loopStart) {
      this._loopStart = loopStart;
      if (this.buffer.loaded) {
        assertRange(this.toSeconds(loopStart), 0, this.buffer.duration);
      }
      this._activeSources.forEach((source) => {
        source.loopStart = loopStart;
      });
    }
    get loopEnd() {
      return this._loopEnd;
    }
    set loopEnd(loopEnd) {
      this._loopEnd = loopEnd;
      if (this.buffer.loaded) {
        assertRange(this.toSeconds(loopEnd), 0, this.buffer.duration);
      }
      this._activeSources.forEach((source) => {
        source.loopEnd = loopEnd;
      });
    }
    get buffer() {
      return this._buffer;
    }
    set buffer(buffer) {
      this._buffer.set(buffer);
    }
    get loop() {
      return this._loop;
    }
    set loop(loop) {
      if (this._loop === loop) {
        return;
      }
      this._loop = loop;
      this._activeSources.forEach((source) => {
        source.loop = loop;
      });
      if (loop) {
        const stopEvent = this._state.getNextState("stopped", this.now());
        if (stopEvent) {
          this._state.cancel(stopEvent.time);
        }
      }
    }
    get playbackRate() {
      return this._playbackRate;
    }
    set playbackRate(rate) {
      this._playbackRate = rate;
      const now = this.now();
      const stopEvent = this._state.getNextState("stopped", now);
      if (stopEvent && stopEvent.implicitEnd) {
        this._state.cancel(stopEvent.time);
        this._activeSources.forEach((source) => source.cancelStop());
      }
      this._activeSources.forEach((source) => {
        source.playbackRate.setValueAtTime(rate, now);
      });
    }
    get reverse() {
      return this._buffer.reverse;
    }
    set reverse(rev) {
      this._buffer.reverse = rev;
    }
    get loaded() {
      return this._buffer.loaded;
    }
    dispose() {
      super.dispose();
      this._activeSources.forEach((source) => source.dispose());
      this._activeSources.clear();
      this._buffer.dispose();
      return this;
    }
  };
  __decorate([
    timeRange(0)
  ], Player.prototype, "fadeIn", void 0);
  __decorate([
    timeRange(0)
  ], Player.prototype, "fadeOut", void 0);

  // node_modules/tone/build/esm/component/envelope/Envelope.js
  var Envelope = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Envelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]));
      this.name = "Envelope";
      this._sig = new Signal({
        context: this.context,
        value: 0
      });
      this.output = this._sig;
      this.input = void 0;
      const options = optionsFromArguments(Envelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
      this.attack = options.attack;
      this.decay = options.decay;
      this.sustain = options.sustain;
      this.release = options.release;
      this.attackCurve = options.attackCurve;
      this.releaseCurve = options.releaseCurve;
      this.decayCurve = options.decayCurve;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        attack: 0.01,
        attackCurve: "linear",
        decay: 0.1,
        decayCurve: "exponential",
        release: 1,
        releaseCurve: "exponential",
        sustain: 0.5
      });
    }
    get value() {
      return this.getValueAtTime(this.now());
    }
    _getCurve(curve, direction) {
      if (isString(curve)) {
        return curve;
      } else {
        let curveName;
        for (curveName in EnvelopeCurves) {
          if (EnvelopeCurves[curveName][direction] === curve) {
            return curveName;
          }
        }
        return curve;
      }
    }
    _setCurve(name2, direction, curve) {
      if (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {
        const curveDef = EnvelopeCurves[curve];
        if (isObject(curveDef)) {
          if (name2 !== "_decayCurve") {
            this[name2] = curveDef[direction];
          }
        } else {
          this[name2] = curveDef;
        }
      } else if (isArray(curve) && name2 !== "_decayCurve") {
        this[name2] = curve;
      } else {
        throw new Error("Envelope: invalid curve: " + curve);
      }
    }
    get attackCurve() {
      return this._getCurve(this._attackCurve, "In");
    }
    set attackCurve(curve) {
      this._setCurve("_attackCurve", "In", curve);
    }
    get releaseCurve() {
      return this._getCurve(this._releaseCurve, "Out");
    }
    set releaseCurve(curve) {
      this._setCurve("_releaseCurve", "Out", curve);
    }
    get decayCurve() {
      return this._decayCurve;
    }
    set decayCurve(curve) {
      assert(["linear", "exponential"].some((c2) => c2 === curve), `Invalid envelope curve: ${curve}`);
      this._decayCurve = curve;
    }
    triggerAttack(time, velocity = 1) {
      this.log("triggerAttack", time, velocity);
      time = this.toSeconds(time);
      const originalAttack = this.toSeconds(this.attack);
      let attack = originalAttack;
      const decay = this.toSeconds(this.decay);
      const currentValue = this.getValueAtTime(time);
      if (currentValue > 0) {
        const attackRate = 1 / attack;
        const remainingDistance = 1 - currentValue;
        attack = remainingDistance / attackRate;
      }
      if (attack < this.sampleTime) {
        this._sig.cancelScheduledValues(time);
        this._sig.setValueAtTime(velocity, time);
      } else if (this._attackCurve === "linear") {
        this._sig.linearRampTo(velocity, attack, time);
      } else if (this._attackCurve === "exponential") {
        this._sig.targetRampTo(velocity, attack, time);
      } else {
        this._sig.cancelAndHoldAtTime(time);
        let curve = this._attackCurve;
        for (let i = 1; i < curve.length; i++) {
          if (curve[i - 1] <= currentValue && currentValue <= curve[i]) {
            curve = this._attackCurve.slice(i);
            curve[0] = currentValue;
            break;
          }
        }
        this._sig.setValueCurveAtTime(curve, time, attack, velocity);
      }
      if (decay && this.sustain < 1) {
        const decayValue = velocity * this.sustain;
        const decayStart = time + attack;
        this.log("decay", decayStart);
        if (this._decayCurve === "linear") {
          this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);
        } else {
          this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);
        }
      }
      return this;
    }
    triggerRelease(time) {
      this.log("triggerRelease", time);
      time = this.toSeconds(time);
      const currentValue = this.getValueAtTime(time);
      if (currentValue > 0) {
        const release = this.toSeconds(this.release);
        if (release < this.sampleTime) {
          this._sig.setValueAtTime(0, time);
        } else if (this._releaseCurve === "linear") {
          this._sig.linearRampTo(0, release, time);
        } else if (this._releaseCurve === "exponential") {
          this._sig.targetRampTo(0, release, time);
        } else {
          assert(isArray(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array");
          this._sig.cancelAndHoldAtTime(time);
          this._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);
        }
      }
      return this;
    }
    getValueAtTime(time) {
      return this._sig.getValueAtTime(time);
    }
    triggerAttackRelease(duration, time, velocity = 1) {
      time = this.toSeconds(time);
      this.triggerAttack(time, velocity);
      this.triggerRelease(time + this.toSeconds(duration));
      return this;
    }
    cancel(after) {
      this._sig.cancelScheduledValues(this.toSeconds(after));
      return this;
    }
    connect(destination, outputNumber = 0, inputNumber = 0) {
      connectSignal(this, destination, outputNumber, inputNumber);
      return this;
    }
    asArray(length = 1024) {
      return __awaiter(this, void 0, void 0, function* () {
        const duration = length / this.context.sampleRate;
        const context2 = new OfflineContext(1, duration, this.context.sampleRate);
        const attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);
        const envelopeDuration = attackPortion + this.toSeconds(this.release);
        const sustainTime = envelopeDuration * 0.1;
        const totalDuration = envelopeDuration + sustainTime;
        const clone3 = new this.constructor(Object.assign(this.get(), {
          attack: duration * this.toSeconds(this.attack) / totalDuration,
          decay: duration * this.toSeconds(this.decay) / totalDuration,
          release: duration * this.toSeconds(this.release) / totalDuration,
          context: context2
        }));
        clone3._sig.toDestination();
        clone3.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);
        const buffer = yield context2.render();
        return buffer.getChannelData(0);
      });
    }
    dispose() {
      super.dispose();
      this._sig.dispose();
      return this;
    }
  };
  __decorate([
    timeRange(0)
  ], Envelope.prototype, "attack", void 0);
  __decorate([
    timeRange(0)
  ], Envelope.prototype, "decay", void 0);
  __decorate([
    range(0, 1)
  ], Envelope.prototype, "sustain", void 0);
  __decorate([
    timeRange(0)
  ], Envelope.prototype, "release", void 0);
  var EnvelopeCurves = (() => {
    const curveLen = 128;
    let i;
    let k;
    const cosineCurve = [];
    for (i = 0; i < curveLen; i++) {
      cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));
    }
    const rippleCurve = [];
    const rippleCurveFreq = 6.4;
    for (i = 0; i < curveLen - 1; i++) {
      k = i / (curveLen - 1);
      const sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;
      rippleCurve[i] = sineWave / 10 + k * 0.83;
    }
    rippleCurve[curveLen - 1] = 1;
    const stairsCurve = [];
    const steps = 5;
    for (i = 0; i < curveLen; i++) {
      stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;
    }
    const sineCurve = [];
    for (i = 0; i < curveLen; i++) {
      k = i / (curveLen - 1);
      sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));
    }
    const bounceCurve = [];
    for (i = 0; i < curveLen; i++) {
      k = i / (curveLen - 1);
      const freq = Math.pow(k, 3) * 4 + 0.2;
      const val = Math.cos(freq * Math.PI * 2 * k);
      bounceCurve[i] = Math.abs(val * (1 - k));
    }
    function invertCurve(curve) {
      const out = new Array(curve.length);
      for (let j2 = 0; j2 < curve.length; j2++) {
        out[j2] = 1 - curve[j2];
      }
      return out;
    }
    function reverseCurve(curve) {
      return curve.slice(0).reverse();
    }
    return {
      bounce: {
        In: invertCurve(bounceCurve),
        Out: bounceCurve
      },
      cosine: {
        In: cosineCurve,
        Out: reverseCurve(cosineCurve)
      },
      exponential: "exponential",
      linear: "linear",
      ripple: {
        In: rippleCurve,
        Out: invertCurve(rippleCurve)
      },
      sine: {
        In: sineCurve,
        Out: invertCurve(sineCurve)
      },
      step: {
        In: stairsCurve,
        Out: invertCurve(stairsCurve)
      }
    };
  })();

  // node_modules/tone/build/esm/instrument/Instrument.js
  var Instrument = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Instrument.getDefaults(), arguments));
      this._scheduledEvents = [];
      this._synced = false;
      this._original_triggerAttack = this.triggerAttack;
      this._original_triggerRelease = this.triggerRelease;
      const options = optionsFromArguments(Instrument.getDefaults(), arguments);
      this._volume = this.output = new Volume({
        context: this.context,
        volume: options.volume
      });
      this.volume = this._volume.volume;
      readOnly(this, "volume");
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        volume: 0
      });
    }
    sync() {
      if (this._syncState()) {
        this._syncMethod("triggerAttack", 1);
        this._syncMethod("triggerRelease", 0);
      }
      return this;
    }
    _syncState() {
      let changed = false;
      if (!this._synced) {
        this._synced = true;
        changed = true;
      }
      return changed;
    }
    _syncMethod(method, timePosition) {
      const originalMethod = this["_original_" + method] = this[method];
      this[method] = (...args) => {
        const time = args[timePosition];
        const id2 = this.context.transport.schedule((t2) => {
          args[timePosition] = t2;
          originalMethod.apply(this, args);
        }, time);
        this._scheduledEvents.push(id2);
      };
    }
    unsync() {
      this._scheduledEvents.forEach((id2) => this.context.transport.clear(id2));
      this._scheduledEvents = [];
      if (this._synced) {
        this._synced = false;
        this.triggerAttack = this._original_triggerAttack;
        this.triggerRelease = this._original_triggerRelease;
      }
      return this;
    }
    triggerAttackRelease(note, duration, time, velocity) {
      const computedTime = this.toSeconds(time);
      const computedDuration = this.toSeconds(duration);
      this.triggerAttack(note, computedTime, velocity);
      this.triggerRelease(computedTime + computedDuration);
      return this;
    }
    dispose() {
      super.dispose();
      this._volume.dispose();
      this.unsync();
      this._scheduledEvents = [];
      return this;
    }
  };

  // node_modules/tone/build/esm/instrument/Monophonic.js
  var Monophonic = class extends Instrument {
    constructor() {
      super(optionsFromArguments(Monophonic.getDefaults(), arguments));
      const options = optionsFromArguments(Monophonic.getDefaults(), arguments);
      this.portamento = options.portamento;
      this.onsilence = options.onsilence;
    }
    static getDefaults() {
      return Object.assign(Instrument.getDefaults(), {
        detune: 0,
        onsilence: noOp,
        portamento: 0
      });
    }
    triggerAttack(note, time, velocity = 1) {
      this.log("triggerAttack", note, time, velocity);
      const seconds = this.toSeconds(time);
      this._triggerEnvelopeAttack(seconds, velocity);
      this.setNote(note, seconds);
      return this;
    }
    triggerRelease(time) {
      this.log("triggerRelease", time);
      const seconds = this.toSeconds(time);
      this._triggerEnvelopeRelease(seconds);
      return this;
    }
    setNote(note, time) {
      const computedTime = this.toSeconds(time);
      const computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;
      if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {
        const portTime = this.toSeconds(this.portamento);
        this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);
      } else {
        this.frequency.setValueAtTime(computedFrequency, computedTime);
      }
      return this;
    }
  };
  __decorate([
    timeRange(0)
  ], Monophonic.prototype, "portamento", void 0);

  // node_modules/tone/build/esm/component/envelope/AmplitudeEnvelope.js
  var AmplitudeEnvelope = class extends Envelope {
    constructor() {
      super(optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]));
      this.name = "AmplitudeEnvelope";
      this._gainNode = new Gain({
        context: this.context,
        gain: 0
      });
      this.output = this._gainNode;
      this.input = this._gainNode;
      this._sig.connect(this._gainNode.gain);
      this.output = this._gainNode;
      this.input = this._gainNode;
    }
    dispose() {
      super.dispose();
      this._gainNode.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/instrument/Synth.js
  var Synth = class extends Monophonic {
    constructor() {
      super(optionsFromArguments(Synth.getDefaults(), arguments));
      this.name = "Synth";
      const options = optionsFromArguments(Synth.getDefaults(), arguments);
      this.oscillator = new OmniOscillator(Object.assign({
        context: this.context,
        detune: options.detune,
        onstop: () => this.onsilence(this)
      }, options.oscillator));
      this.frequency = this.oscillator.frequency;
      this.detune = this.oscillator.detune;
      this.envelope = new AmplitudeEnvelope(Object.assign({
        context: this.context
      }, options.envelope));
      this.oscillator.chain(this.envelope, this.output);
      readOnly(this, ["oscillator", "frequency", "detune", "envelope"]);
    }
    static getDefaults() {
      return Object.assign(Monophonic.getDefaults(), {
        envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
          attack: 5e-3,
          decay: 0.1,
          release: 1,
          sustain: 0.3
        }),
        oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), "frequency", "detune"]), {
          type: "triangle"
        })
      });
    }
    _triggerEnvelopeAttack(time, velocity) {
      this.envelope.triggerAttack(time, velocity);
      this.oscillator.start(time);
      if (this.envelope.sustain === 0) {
        const computedAttack = this.toSeconds(this.envelope.attack);
        const computedDecay = this.toSeconds(this.envelope.decay);
        this.oscillator.stop(time + computedAttack + computedDecay);
      }
    }
    _triggerEnvelopeRelease(time) {
      this.envelope.triggerRelease(time);
      this.oscillator.stop(time + this.toSeconds(this.envelope.release));
    }
    getLevelAtTime(time) {
      time = this.toSeconds(time);
      return this.envelope.getValueAtTime(time);
    }
    dispose() {
      super.dispose();
      this.oscillator.dispose();
      this.envelope.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/instrument/MembraneSynth.js
  var MembraneSynth = class extends Synth {
    constructor() {
      super(optionsFromArguments(MembraneSynth.getDefaults(), arguments));
      this.name = "MembraneSynth";
      this.portamento = 0;
      const options = optionsFromArguments(MembraneSynth.getDefaults(), arguments);
      this.pitchDecay = options.pitchDecay;
      this.octaves = options.octaves;
      readOnly(this, ["oscillator", "envelope"]);
    }
    static getDefaults() {
      return deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {
        envelope: {
          attack: 1e-3,
          attackCurve: "exponential",
          decay: 0.4,
          release: 1.4,
          sustain: 0.01
        },
        octaves: 10,
        oscillator: {
          type: "sine"
        },
        pitchDecay: 0.05
      });
    }
    setNote(note, time) {
      const seconds = this.toSeconds(time);
      const hertz = this.toFrequency(note instanceof FrequencyClass ? note.toFrequency() : note);
      const maxNote = hertz * this.octaves;
      this.oscillator.frequency.setValueAtTime(maxNote, seconds);
      this.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));
      return this;
    }
    dispose() {
      super.dispose();
      return this;
    }
  };
  __decorate([
    range(0)
  ], MembraneSynth.prototype, "octaves", void 0);
  __decorate([
    timeRange(0)
  ], MembraneSynth.prototype, "pitchDecay", void 0);

  // node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js
  var workletContext = new Set();
  function addToWorklet(classOrFunction) {
    workletContext.add(classOrFunction);
  }
  function registerProcessor(name2, classDesc) {
    const processor = `registerProcessor("${name2}", ${classDesc})`;
    workletContext.add(processor);
  }

  // node_modules/tone/build/esm/core/worklet/ToneAudioWorkletProcessor.worklet.js
  var toneAudioWorkletProcessor = `
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]]. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`;
  addToWorklet(toneAudioWorkletProcessor);

  // node_modules/tone/build/esm/core/worklet/SingleIOProcessor.worklet.js
  var singleIOProcess = `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`;
  addToWorklet(singleIOProcess);

  // node_modules/tone/build/esm/core/worklet/DelayLine.worklet.js
  var delayLine = `
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`;
  addToWorklet(delayLine);

  // node_modules/tone/build/esm/component/filter/FeedbackCombFilter.worklet.js
  var workletName = "feedback-comb-filter";
  var feedbackCombFilter = `
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`;
  registerProcessor(workletName, feedbackCombFilter);

  // node_modules/tone/build/esm/instrument/PolySynth.js
  var PolySynth = class extends Instrument {
    constructor() {
      super(optionsFromArguments(PolySynth.getDefaults(), arguments, ["voice", "options"]));
      this.name = "PolySynth";
      this._availableVoices = [];
      this._activeVoices = [];
      this._voices = [];
      this._gcTimeout = -1;
      this._averageActiveVoices = 0;
      const options = optionsFromArguments(PolySynth.getDefaults(), arguments, ["voice", "options"]);
      assert(!isNumber(options.voice), "DEPRECATED: The polyphony count is no longer the first argument.");
      const defaults4 = options.voice.getDefaults();
      this.options = Object.assign(defaults4, options.options);
      this.voice = options.voice;
      this.maxPolyphony = options.maxPolyphony;
      this._dummyVoice = this._getNextAvailableVoice();
      const index3 = this._voices.indexOf(this._dummyVoice);
      this._voices.splice(index3, 1);
      this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);
    }
    static getDefaults() {
      return Object.assign(Instrument.getDefaults(), {
        maxPolyphony: 32,
        options: {},
        voice: Synth
      });
    }
    get activeVoices() {
      return this._activeVoices.length;
    }
    _makeVoiceAvailable(voice) {
      this._availableVoices.push(voice);
      const activeVoiceIndex = this._activeVoices.findIndex((e) => e.voice === voice);
      this._activeVoices.splice(activeVoiceIndex, 1);
    }
    _getNextAvailableVoice() {
      if (this._availableVoices.length) {
        return this._availableVoices.shift();
      } else if (this._voices.length < this.maxPolyphony) {
        const voice = new this.voice(Object.assign(this.options, {
          context: this.context,
          onsilence: this._makeVoiceAvailable.bind(this)
        }));
        voice.connect(this.output);
        this._voices.push(voice);
        return voice;
      } else {
        warn("Max polyphony exceeded. Note dropped.");
      }
    }
    _collectGarbage() {
      this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);
      if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {
        const firstAvail = this._availableVoices.shift();
        const index3 = this._voices.indexOf(firstAvail);
        this._voices.splice(index3, 1);
        if (!this.context.isOffline) {
          firstAvail.dispose();
        }
      }
    }
    _triggerAttack(notes, time, velocity) {
      notes.forEach((note) => {
        const midiNote = new MidiClass(this.context, note).toMidi();
        const voice = this._getNextAvailableVoice();
        if (voice) {
          voice.triggerAttack(note, time, velocity);
          this._activeVoices.push({
            midi: midiNote,
            voice,
            released: false
          });
          this.log("triggerAttack", note, time);
        }
      });
    }
    _triggerRelease(notes, time) {
      notes.forEach((note) => {
        const midiNote = new MidiClass(this.context, note).toMidi();
        const event2 = this._activeVoices.find(({ midi, released }) => midi === midiNote && !released);
        if (event2) {
          event2.voice.triggerRelease(time);
          event2.released = true;
          this.log("triggerRelease", note, time);
        }
      });
    }
    _scheduleEvent(type, notes, time, velocity) {
      assert(!this.disposed, "Synth was already disposed");
      if (time <= this.now()) {
        if (type === "attack") {
          this._triggerAttack(notes, time, velocity);
        } else {
          this._triggerRelease(notes, time);
        }
      } else {
        this.context.setTimeout(() => {
          this._scheduleEvent(type, notes, time, velocity);
        }, time - this.now());
      }
    }
    triggerAttack(notes, time, velocity) {
      if (!Array.isArray(notes)) {
        notes = [notes];
      }
      const computedTime = this.toSeconds(time);
      this._scheduleEvent("attack", notes, computedTime, velocity);
      return this;
    }
    triggerRelease(notes, time) {
      if (!Array.isArray(notes)) {
        notes = [notes];
      }
      const computedTime = this.toSeconds(time);
      this._scheduleEvent("release", notes, computedTime);
      return this;
    }
    triggerAttackRelease(notes, duration, time, velocity) {
      const computedTime = this.toSeconds(time);
      this.triggerAttack(notes, computedTime, velocity);
      if (isArray(duration)) {
        assert(isArray(notes), "If the duration is an array, the notes must also be an array");
        notes = notes;
        for (let i = 0; i < notes.length; i++) {
          const d2 = duration[Math.min(i, duration.length - 1)];
          const durationSeconds = this.toSeconds(d2);
          assert(durationSeconds > 0, "The duration must be greater than 0");
          this.triggerRelease(notes[i], computedTime + durationSeconds);
        }
      } else {
        const durationSeconds = this.toSeconds(duration);
        assert(durationSeconds > 0, "The duration must be greater than 0");
        this.triggerRelease(notes, computedTime + durationSeconds);
      }
      return this;
    }
    sync() {
      if (this._syncState()) {
        this._syncMethod("triggerAttack", 1);
        this._syncMethod("triggerRelease", 1);
      }
      return this;
    }
    set(options) {
      const sanitizedOptions = omitFromObject(options, ["onsilence", "context"]);
      this.options = deepMerge(this.options, sanitizedOptions);
      this._voices.forEach((voice) => voice.set(sanitizedOptions));
      this._dummyVoice.set(sanitizedOptions);
      return this;
    }
    get() {
      return this._dummyVoice.get();
    }
    releaseAll(time) {
      const computedTime = this.toSeconds(time);
      this._activeVoices.forEach(({ voice }) => {
        voice.triggerRelease(computedTime);
      });
      return this;
    }
    dispose() {
      super.dispose();
      this._dummyVoice.dispose();
      this._voices.forEach((v) => v.dispose());
      this._activeVoices = [];
      this._availableVoices = [];
      this.context.clearInterval(this._gcTimeout);
      return this;
    }
  };

  // node_modules/tone/build/esm/instrument/Sampler.js
  var Sampler = class extends Instrument {
    constructor() {
      super(optionsFromArguments(Sampler.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls"));
      this.name = "Sampler";
      this._activeSources = new Map();
      const options = optionsFromArguments(Sampler.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
      const urlMap = {};
      Object.keys(options.urls).forEach((note) => {
        const noteNumber = parseInt(note, 10);
        assert(isNote(note) || isNumber(noteNumber) && isFinite(noteNumber), `url key is neither a note or midi pitch: ${note}`);
        if (isNote(note)) {
          const mid = new FrequencyClass(this.context, note).toMidi();
          urlMap[mid] = options.urls[note];
        } else if (isNumber(noteNumber) && isFinite(noteNumber)) {
          urlMap[noteNumber] = options.urls[noteNumber];
        }
      });
      this._buffers = new ToneAudioBuffers({
        urls: urlMap,
        onload: options.onload,
        baseUrl: options.baseUrl,
        onerror: options.onerror
      });
      this.attack = options.attack;
      this.release = options.release;
      this.curve = options.curve;
      if (this._buffers.loaded) {
        Promise.resolve().then(options.onload);
      }
    }
    static getDefaults() {
      return Object.assign(Instrument.getDefaults(), {
        attack: 0,
        baseUrl: "",
        curve: "exponential",
        onload: noOp,
        onerror: noOp,
        release: 0.1,
        urls: {}
      });
    }
    _findClosest(midi) {
      const MAX_INTERVAL = 96;
      let interval = 0;
      while (interval < MAX_INTERVAL) {
        if (this._buffers.has(midi + interval)) {
          return -interval;
        } else if (this._buffers.has(midi - interval)) {
          return interval;
        }
        interval++;
      }
      throw new Error(`No available buffers for note: ${midi}`);
    }
    triggerAttack(notes, time, velocity = 1) {
      this.log("triggerAttack", notes, time, velocity);
      if (!Array.isArray(notes)) {
        notes = [notes];
      }
      notes.forEach((note) => {
        const midiFloat = ftomf(new FrequencyClass(this.context, note).toFrequency());
        const midi = Math.round(midiFloat);
        const remainder = midiFloat - midi;
        const difference = this._findClosest(midi);
        const closestNote = midi - difference;
        const buffer = this._buffers.get(closestNote);
        const playbackRate = intervalToFrequencyRatio(difference + remainder);
        const source = new ToneBufferSource({
          url: buffer,
          context: this.context,
          curve: this.curve,
          fadeIn: this.attack,
          fadeOut: this.release,
          playbackRate
        }).connect(this.output);
        source.start(time, 0, buffer.duration / playbackRate, velocity);
        if (!isArray(this._activeSources.get(midi))) {
          this._activeSources.set(midi, []);
        }
        this._activeSources.get(midi).push(source);
        source.onended = () => {
          if (this._activeSources && this._activeSources.has(midi)) {
            const sources = this._activeSources.get(midi);
            const index3 = sources.indexOf(source);
            if (index3 !== -1) {
              sources.splice(index3, 1);
            }
          }
        };
      });
      return this;
    }
    triggerRelease(notes, time) {
      this.log("triggerRelease", notes, time);
      if (!Array.isArray(notes)) {
        notes = [notes];
      }
      notes.forEach((note) => {
        const midi = new FrequencyClass(this.context, note).toMidi();
        if (this._activeSources.has(midi) && this._activeSources.get(midi).length) {
          const sources = this._activeSources.get(midi);
          time = this.toSeconds(time);
          sources.forEach((source) => {
            source.stop(time);
          });
          this._activeSources.set(midi, []);
        }
      });
      return this;
    }
    releaseAll(time) {
      const computedTime = this.toSeconds(time);
      this._activeSources.forEach((sources) => {
        while (sources.length) {
          const source = sources.shift();
          source.stop(computedTime);
        }
      });
      return this;
    }
    sync() {
      if (this._syncState()) {
        this._syncMethod("triggerAttack", 1);
        this._syncMethod("triggerRelease", 1);
      }
      return this;
    }
    triggerAttackRelease(notes, duration, time, velocity = 1) {
      const computedTime = this.toSeconds(time);
      this.triggerAttack(notes, computedTime, velocity);
      if (isArray(duration)) {
        assert(isArray(notes), "notes must be an array when duration is array");
        notes.forEach((note, index3) => {
          const d2 = duration[Math.min(index3, duration.length - 1)];
          this.triggerRelease(note, computedTime + this.toSeconds(d2));
        });
      } else {
        this.triggerRelease(notes, computedTime + this.toSeconds(duration));
      }
      return this;
    }
    add(note, url, callback2) {
      assert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);
      if (isNote(note)) {
        const mid = new FrequencyClass(this.context, note).toMidi();
        this._buffers.add(mid, url, callback2);
      } else {
        this._buffers.add(note, url, callback2);
      }
      return this;
    }
    get loaded() {
      return this._buffers.loaded;
    }
    dispose() {
      super.dispose();
      this._buffers.dispose();
      this._activeSources.forEach((sources) => {
        sources.forEach((source) => source.dispose());
      });
      this._activeSources.clear();
      return this;
    }
  };
  __decorate([
    timeRange(0)
  ], Sampler.prototype, "attack", void 0);
  __decorate([
    timeRange(0)
  ], Sampler.prototype, "release", void 0);

  // node_modules/tone/build/esm/component/channel/Panner.js
  var Panner = class extends ToneAudioNode {
    constructor() {
      super(Object.assign(optionsFromArguments(Panner.getDefaults(), arguments, ["pan"])));
      this.name = "Panner";
      this._panner = this.context.createStereoPanner();
      this.input = this._panner;
      this.output = this._panner;
      const options = optionsFromArguments(Panner.getDefaults(), arguments, ["pan"]);
      this.pan = new Param({
        context: this.context,
        param: this._panner.pan,
        value: options.pan,
        minValue: -1,
        maxValue: 1
      });
      this._panner.channelCount = options.channelCount;
      this._panner.channelCountMode = "explicit";
      readOnly(this, "pan");
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        pan: 0,
        channelCount: 1
      });
    }
    dispose() {
      super.dispose();
      this._panner.disconnect();
      this.pan.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/effect/BitCrusher.worklet.js
  var workletName2 = "bit-crusher";
  var bitCrusherWorklet = `
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`;
  registerProcessor(workletName2, bitCrusherWorklet);

  // node_modules/tone/build/esm/effect/Freeverb.js
  var combFilterTunings = [1557 / 44100, 1617 / 44100, 1491 / 44100, 1422 / 44100, 1277 / 44100, 1356 / 44100, 1188 / 44100, 1116 / 44100];

  // node_modules/tone/build/esm/effect/JCReverb.js
  var combFilterDelayTimes = [1687 / 25e3, 1601 / 25e3, 2053 / 25e3, 2251 / 25e3];

  // node_modules/tone/build/esm/component/channel/Solo.js
  var Solo = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Solo.getDefaults(), arguments, ["solo"]));
      this.name = "Solo";
      const options = optionsFromArguments(Solo.getDefaults(), arguments, ["solo"]);
      this.input = this.output = new Gain({
        context: this.context
      });
      if (!Solo._allSolos.has(this.context)) {
        Solo._allSolos.set(this.context, new Set());
      }
      Solo._allSolos.get(this.context).add(this);
      this.solo = options.solo;
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        solo: false
      });
    }
    get solo() {
      return this._isSoloed();
    }
    set solo(solo) {
      if (solo) {
        this._addSolo();
      } else {
        this._removeSolo();
      }
      Solo._allSolos.get(this.context).forEach((instance) => instance._updateSolo());
    }
    get muted() {
      return this.input.gain.value === 0;
    }
    _addSolo() {
      if (!Solo._soloed.has(this.context)) {
        Solo._soloed.set(this.context, new Set());
      }
      Solo._soloed.get(this.context).add(this);
    }
    _removeSolo() {
      if (Solo._soloed.has(this.context)) {
        Solo._soloed.get(this.context).delete(this);
      }
    }
    _isSoloed() {
      return Solo._soloed.has(this.context) && Solo._soloed.get(this.context).has(this);
    }
    _noSolos() {
      return !Solo._soloed.has(this.context) || Solo._soloed.has(this.context) && Solo._soloed.get(this.context).size === 0;
    }
    _updateSolo() {
      if (this._isSoloed()) {
        this.input.gain.value = 1;
      } else if (this._noSolos()) {
        this.input.gain.value = 1;
      } else {
        this.input.gain.value = 0;
      }
    }
    dispose() {
      super.dispose();
      Solo._allSolos.get(this.context).delete(this);
      this._removeSolo();
      return this;
    }
  };
  Solo._allSolos = new Map();
  Solo._soloed = new Map();

  // node_modules/tone/build/esm/component/channel/PanVol.js
  var PanVol = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(PanVol.getDefaults(), arguments, ["pan", "volume"]));
      this.name = "PanVol";
      const options = optionsFromArguments(PanVol.getDefaults(), arguments, ["pan", "volume"]);
      this._panner = this.input = new Panner({
        context: this.context,
        pan: options.pan,
        channelCount: options.channelCount
      });
      this.pan = this._panner.pan;
      this._volume = this.output = new Volume({
        context: this.context,
        volume: options.volume
      });
      this.volume = this._volume.volume;
      this._panner.connect(this._volume);
      this.mute = options.mute;
      readOnly(this, ["pan", "volume"]);
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        mute: false,
        pan: 0,
        volume: 0,
        channelCount: 1
      });
    }
    get mute() {
      return this._volume.mute;
    }
    set mute(mute) {
      this._volume.mute = mute;
    }
    dispose() {
      super.dispose();
      this._panner.dispose();
      this.pan.dispose();
      this._volume.dispose();
      this.volume.dispose();
      return this;
    }
  };

  // node_modules/tone/build/esm/component/channel/Channel.js
  var Channel = class extends ToneAudioNode {
    constructor() {
      super(optionsFromArguments(Channel.getDefaults(), arguments, ["volume", "pan"]));
      this.name = "Channel";
      const options = optionsFromArguments(Channel.getDefaults(), arguments, ["volume", "pan"]);
      this._solo = this.input = new Solo({
        solo: options.solo,
        context: this.context
      });
      this._panVol = this.output = new PanVol({
        context: this.context,
        pan: options.pan,
        volume: options.volume,
        mute: options.mute,
        channelCount: options.channelCount
      });
      this.pan = this._panVol.pan;
      this.volume = this._panVol.volume;
      this._solo.connect(this._panVol);
      readOnly(this, ["pan", "volume"]);
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        pan: 0,
        volume: 0,
        mute: false,
        solo: false,
        channelCount: 1
      });
    }
    get solo() {
      return this._solo.solo;
    }
    set solo(solo) {
      this._solo.solo = solo;
    }
    get muted() {
      return this._solo.muted || this.mute;
    }
    get mute() {
      return this._panVol.mute;
    }
    set mute(mute) {
      this._panVol.mute = mute;
    }
    _getBus(name2) {
      if (!Channel.buses.has(name2)) {
        Channel.buses.set(name2, new Gain({ context: this.context }));
      }
      return Channel.buses.get(name2);
    }
    send(name2, volume = 0) {
      const bus = this._getBus(name2);
      const sendKnob = new Gain({
        context: this.context,
        units: "decibels",
        gain: volume
      });
      this.connect(sendKnob);
      sendKnob.connect(bus);
      return sendKnob;
    }
    receive(name2) {
      const bus = this._getBus(name2);
      bus.connect(this);
      return this;
    }
    dispose() {
      super.dispose();
      this._panVol.dispose();
      this.pan.dispose();
      this.volume.dispose();
      this._solo.dispose();
      return this;
    }
  };
  Channel.buses = new Map();

  // node_modules/tone/build/esm/core/context/Listener.js
  var Listener = class extends ToneAudioNode {
    constructor() {
      super(...arguments);
      this.name = "Listener";
      this.positionX = new Param({
        context: this.context,
        param: this.context.rawContext.listener.positionX
      });
      this.positionY = new Param({
        context: this.context,
        param: this.context.rawContext.listener.positionY
      });
      this.positionZ = new Param({
        context: this.context,
        param: this.context.rawContext.listener.positionZ
      });
      this.forwardX = new Param({
        context: this.context,
        param: this.context.rawContext.listener.forwardX
      });
      this.forwardY = new Param({
        context: this.context,
        param: this.context.rawContext.listener.forwardY
      });
      this.forwardZ = new Param({
        context: this.context,
        param: this.context.rawContext.listener.forwardZ
      });
      this.upX = new Param({
        context: this.context,
        param: this.context.rawContext.listener.upX
      });
      this.upY = new Param({
        context: this.context,
        param: this.context.rawContext.listener.upY
      });
      this.upZ = new Param({
        context: this.context,
        param: this.context.rawContext.listener.upZ
      });
    }
    static getDefaults() {
      return Object.assign(ToneAudioNode.getDefaults(), {
        positionX: 0,
        positionY: 0,
        positionZ: 0,
        forwardX: 0,
        forwardY: 0,
        forwardZ: -1,
        upX: 0,
        upY: 1,
        upZ: 0
      });
    }
    dispose() {
      super.dispose();
      this.positionX.dispose();
      this.positionY.dispose();
      this.positionZ.dispose();
      this.forwardX.dispose();
      this.forwardY.dispose();
      this.forwardZ.dispose();
      this.upX.dispose();
      this.upY.dispose();
      this.upZ.dispose();
      return this;
    }
  };
  onContextInit((context2) => {
    context2.listener = new Listener({ context: context2 });
  });
  onContextClose((context2) => {
    context2.listener.dispose();
  });

  // node_modules/tone/build/esm/index.js
  var Transport2 = getContext().transport;
  var Destination2 = getContext().destination;
  var Master = getContext().destination;
  var Listener2 = getContext().listener;
  var Draw2 = getContext().draw;
  var context = getContext();

  // static/js/event-emitter.ts
  var EventEmitter = class {
    constructor(events) {
      this.events = Object.fromEntries(Object.keys(events).map((k) => [k, []]));
    }
    on(name2, handler2) {
      this.events[name2].push(handler2);
    }
    emit(name2, args) {
      let status = "sync";
      let _block;
      const ev = __spreadProps(__spreadValues({}, args), {
        cancelEvent() {
          status = "canceled";
        },
        deferEvent() {
          status = "deferred";
          return () => {
            if (_block) {
              _block();
            }
          };
        },
        then(block) {
          if (status === "sync") {
            block();
          } else if (status === "deferred") {
            _block = block;
          }
        }
      });
      for (const handler2 of this.events[name2]) {
        handler2(ev);
      }
      return ev;
    }
  };

  // static/js/tabs.ts
  var Tabs = class {
    constructor(options = {}) {
      this._currentTab = "";
      this.tabEvents = new EventEmitter({
        beforeSwitch: true,
        afterSwitch: true
      });
      $("*[data-tab]").on("click", (e) => {
        const tab = $(e.target);
        const tabName = tab.data("tab");
        e.preventDefault();
        this.switchToTab(tabName);
      });
      let initialTab = options.initialTab;
      if (!initialTab && window.location.hash) {
        const hashFragment = window.location.hash.replace(/^#/, "");
        initialTab = hashFragment;
      }
      if (!initialTab) {
        initialTab = $(".tab:first").attr("data-tab");
      }
      if (initialTab) {
        this.switchToTab(initialTab);
      }
    }
    switchToTab(tabName) {
      const doSwitch = () => {
        const oldTab = this._currentTab;
        this._currentTab = tabName;
        const hashFragment = tabName !== "level" ? tabName : "";
        if (window.history) {
          window.history.replaceState(null, "", "#" + hashFragment);
        }
        const tab = $('*[data-tab="' + tabName + '"]');
        const allTabs = tab.siblings("*[data-tab]");
        const target = $('*[data-tabtarget="' + tabName + '"]');
        const allTargets = target.siblings("*[data-tabtarget]");
        allTabs.removeClass("tab-selected");
        tab.addClass("tab-selected");
        allTargets.addClass("hidden");
        target.removeClass("hidden");
        this.tabEvents.emit("afterSwitch", { oldTab, newTab: tabName });
      };
      if (this._currentTab != "") {
        const event2 = this.tabEvents.emit("beforeSwitch", { oldTab: this._currentTab, newTab: tabName });
        event2.then(doSwitch);
      } else {
        doSwitch();
      }
    }
    get currentTab() {
      return this._currentTab;
    }
    on(key, handler2) {
      const ret = this.tabEvents.on(key, handler2);
      if (key === "afterSwitch") {
        this.tabEvents.emit("afterSwitch", { oldTab: "", newTab: this._currentTab });
      }
      return ret;
    }
  };
  function getPreviousAndNext() {
    const selected = document.querySelector(".tab-selected");
    if (!selected)
      return [];
    const i = parseInt(selected.getAttribute("tabindex") || "0");
    const prev = document.querySelector(`.tab[tabindex='${i - 1}']`);
    const next = document.querySelector(`.tab[tabindex='${i + 1}']`);
    return [prev, next];
  }

  // static/js/pythonPrefixes.ts
  var turtle_prefix = `# coding=utf8

import random  # noqa F401
import time  # noqa F401
import turtle

t = turtle.Turtle()
t.shape("turtle")
t.hideturtle()
t.penup()
t.left(90)
t.pendown()
t.speed(3)
t.showturtle()
`;
  var pygame_prefix = `# coding=utf8

import pygame  # noqa F401
import buttons  # noqa F401

pygame.init()
canvas = pygame.display.set_mode((711, 300))
canvas.fill(pygame.Color(247, 250, 252, 255))

pygame_end = False
button_list = []


def create_button(name):
    if name not in button_list:
        button_list.append(name)
        buttons.add(name)
`;
  var normal_prefix = `# coding=utf8

import random  # noqa F401
import time  # noqa F401

try:
    import extensions  # noqa F401
except ModuleNotFoundError:
    # This is done because 'extensions' is not a python module but rather a Skulpt JS extension
    # These functions are defined in skulpt-stdlib-extensions.js
    # When running tests in test_python_prefixes it wil raise ModuleNotFoundError
    pass

global int_saver
global convert_numerals  # needed for recursion to work
int_saver = int


def int(s):
    if isinstance(s, str):
        numerals_dict = {'0': '0', '1': '1', '2': '2', '3': '3', '4': '4', '5': '5', '6': '6', '7': '7', '8': '8',
                         '9': '9', '\u{11066}': '0', '\u{11067}': '1', '\u{11068}': '2', '\u{11069}': '3', '\u{1106A}': '4', '\u{1106B}': '5', '\u{1106C}': '6', '\u{1106D}': '7',
                         '\u{1106E}': '8', '\u{1106F}': '9', '\u0966': '0', '\u0967': '1', '\u0968': '2', '\u0969': '3', '\u096A': '4', '\u096B': '5', '\u096C': '6',
                         '\u096D': '7', '\u096E': '8', '\u096F': '9', '\u0AE6': '0', '\u0AE7': '1', '\u0AE8': '2', '\u0AE9': '3', '\u0AEA': '4', '\u0AEB': '5',
                         '\u0AEC': '6', '\u0AED': '7', '\u0AEE': '8', '\u0AEF': '9', '\u0A66': '0', '\u0A67': '1', '\u0A68': '2', '\u0A69': '3', '\u0A6A': '4',
                         '\u0A6B': '5', '\u0A6C': '6', '\u0A6D': '7', '\u0A6E': '8', '\u0A6F': '9', '\u09E6': '0', '\u09E7': '1', '\u09E8': '2', '\u09E9': '3',
                         '\u09EA': '4', '\u09EB': '5', '\u09EC': '6', '\u09ED': '7', '\u09EE': '8', '\u09EF': '9', '\u0CE6': '0', '\u0CE7': '1', '\u0CE8': '2',
                         '\u0CE9': '3', '\u0CEA': '4', '\u0CEB': '5', '\u0CEC': '6', '\u0CED': '7', '\u0CEE': '8', '\u0CEF': '9', '\u0B66': '0', '\u0B67': '1',
                         '\u0B68': '2', '\u0B69': '3', '\u0B6A': '4', '\u0B6B': '5', '\u0B6C': '6', '\u0B6D': '7', '\u0B6E': '8', '\u0B6F': '9', '\u0D66': '0',
                         '\u0D67': '1', '\u0D68': '2', '\u0D69': '3', '\u0D6A': '4', '\u0D6B': '5', '\u0D6C': '6', '\u0D6D': '7', '\u0D6E': '8', '\u0D6F': '9',
                         '\u0BE6': '0', '\u0BE7': '1', '\u0BE8': '2', '\u0BE9': '3', '\u0BEA': '4', '\u0BEB': '5', '\u0BEC': '6', '\u0BED': '7', '\u0BEE': '8',
                         '\u0BEF': '9', '\u0C66': '0', '\u0C67': '1', '\u0C68': '2', '\u0C69': '3', '\u0C6A': '4', '\u0C6B': '5', '\u0C6C': '6', '\u0C6D': '7',
                         '\u0C6E': '8', '\u0C6F': '9', '\u1040': '0', '\u1041': '1', '\u1042': '2', '\u1043': '3', '\u1044': '4', '\u1045': '5', '\u1046': '6',
                         '\u1047': '7', '\u1048': '8', '\u1049': '9', '\u0F20': '0', '\u0F21': '1', '\u0F22': '2', '\u0F23': '3', '\u0F24': '4', '\u0F25': '5',
                         '\u0F26': '6', '\u0F27': '7', '\u0F28': '8', '\u0F29': '9', '\u1810': '0', '\u1811': '1', '\u1812': '2', '\u1813': '3', '\u1814': '4',
                         '\u1815': '5', '\u1816': '6', '\u1817': '7', '\u1818': '8', '\u1819': '9', '\u17E0': '0', '\u17E1': '1', '\u17E2': '2', '\u17E3': '3',
                         '\u17E4': '4', '\u17E5': '5', '\u17E6': '6', '\u17E7': '7', '\u17E8': '8', '\u17E9': '9', '\u0E50': '0', '\u0E51': '1', '\u0E52': '2',
                         '\u0E53': '3', '\u0E54': '4', '\u0E55': '5', '\u0E56': '6', '\u0E57': '7', '\u0E58': '8', '\u0E59': '9', '\u0ED0': '0', '\u0ED1': '1',
                         '\u0ED2': '2', '\u0ED3': '3', '\u0ED4': '4', '\u0ED5': '5', '\u0ED6': '6', '\u0ED7': '7', '\u0ED8': '8', '\u0ED9': '9', '\uA9D0': '0',
                         '\uA9D1': '1', '\uA9D2': '2', '\uA9D3': '3', '\uA9D4': '4', '\uA9D5': '5', '\uA9D6': '6', '\uA9D7': '7', '\uA9D8': '8', '\uA9D9': '9',
                         '\u0660': '0', '\u0661': '1', '\u0662': '2', '\u0663': '3', '\u0664': '4', '\u0665': '5', '\u0666': '6', '\u0667': '7', '\u0668': '8',
                         '\u0669': '9', '\u06F0': '0', '\u06F1': '1', '\u06F2': '2', '\u06F3': '3', '\u06F4': '4', '\u06F5': '5', '\u06F6': '6', '\u06F7': '7',
                         '\u06F8': '8', '\u06F9': '9', '\u3007': '0', '\u4E00': '1', '\u4E8C': '2', '\u4E09': '3', '\u56DB': '4', '\u4E94': '5', '\u516D': '6',
                         '\u4E03': '7', '\u516B': '8', '\u4E5D': '9', '\u96F6': '0'}
        latin_numerals = ''.join([numerals_dict.get(letter, letter) for letter in s])
        return int_saver(latin_numerals)
    return (int_saver(s))


def convert_numerals(alphabet, number):
    numerals_dict_return = {
        'Latin': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
        'Brahmi': ['\u{11066}', '\u{11067}', '\u{11068}', '\u{11069}', '\u{1106A}', '\u{1106B}', '\u{1106C}', '\u{1106D}', '\u{1106E}', '\u{1106F}'],
        'Devanagari': ['\u0966', '\u0967', '\u0968', '\u0969', '\u096A', '\u096B', '\u096C', '\u096D', '\u096E', '\u096F'],
        'Gujarati': ['\u0AE6', '\u0AE7', '\u0AE8', '\u0AE9', '\u0AEA', '\u0AEB', '\u0AEC', '\u0AED', '\u0AEE', '\u0AEF'],
        'Gurmukhi': ['\u0A66', '\u0A67', '\u0A68', '\u0A69', '\u0A6A', '\u0A6B', '\u0A6C', '\u0A6D', '\u0A6E', '\u0A6F'],
        'Bengali': ['\u09E6', '\u09E7', '\u09E8', '\u09E9', '\u09EA', '\u09EB', '\u09EC', '\u09ED', '\u09EE', '\u09EF'],
        'Kannada': ['\u0CE6', '\u0CE7', '\u0CE8', '\u0CE9', '\u0CEA', '\u0CEB', '\u0CEC', '\u0CED', '\u0CEE', '\u0CEF'],
        'Odia': ['\u0B66', '\u0B67', '\u0B68', '\u0B69', '\u0B6A', '\u0B6B', '\u0B6C', '\u0B6D', '\u0B6E', '\u0B6F'],
        'Malayalam': ['\u0D66', '\u0D67', '\u0D68', '\u0D69', '\u0D6A', '\u0D6B', '\u0D6C', '\u0D6D', '\u0D6E', '\u0D6F'],
        'Tamil': ['\u0BE6', '\u0BE7', '\u0BE8', '\u0BE9', '\u0BEA', '\u0BEB', '\u0BEC', '\u0BED', '\u0BEE', '\u0BEF'],
        'Telugu': ['\u0C66', '\u0C67', '\u0C68', '\u0C69', '\u0C6A', '\u0C6B', '\u0C6C', '\u0C6D', '\u0C6E', '\u0C6F'],
        'Burmese': ['\u1040', '\u1041', '\u1042', '\u1043', '\u1044', '\u1045', '\u1046', '\u1047', '\u1048', '\u1049'],
        'Tibetan': ['\u0F20', '\u0F21', '\u0F22', '\u0F23', '\u0F24', '\u0F25', '\u0F26', '\u0F27', '\u0F28', '\u0F29'],
        'Mongolian': ['\u1810', '\u1811', '\u1812', '\u1813', '\u1814', '\u1815', '\u1816', '\u1817', '\u1818', '\u1819'],
        'Khmer': ['\u17E0', '\u17E1', '\u17E2', '\u17E3', '\u17E4', '\u17E5', '\u17E6', '\u17E7', '\u17E8', '\u17E9'],
        'Thai': ['\u0E50', '\u0E51', '\u0E52', '\u0E53', '\u0E54', '\u0E55', '\u0E56', '\u0E57', '\u0E58', '\u0E59'],
        'Lao': ['\u0ED0', '\u0ED1', '\u0ED2', '\u0ED3', '\u0ED4', '\u0ED5', '\u0ED6', '\u0ED7', '\u0ED8', '\u0ED9'],
        'Javanese': ['\uA9D0', '\uA9D1', '\uA9D2', '\uA9D3', '\uA9D4', '\uA9D5', '\uA9D6', '\uA9D7', '\uA9D8', '\uA9D9'],
        'Arabic': ['\u0660', '\u0661', '\u0662', '\u0663', '\u0664', '\u0665', '\u0666', '\u0667', '\u0668', '\u0669'],
        'Persian': ['\u06F0', '\u06F1', '\u06F2', '\u06F3', '\u06F4', '\u06F5', '\u06F6', '\u06F7', '\u06F8', '\u06F9'],
        'Urdu': ['\u06F0', '\u06F1', '\u06F2', '\u06F3', '\u06F4', '\u06F5', '\u06F6', '\u06F7', '\u06F8', '\u06F9']
    }

    number = str(number)
    T = str

    sign = ''
    if number[0] == '-':
        sign = '-'
        number = number[1:]

    if number.replace('.', '', 1).isnumeric():
        numerals_list = numerals_dict_return[alphabet]
        if '.' in number:
            tokens = number.split('.')
            all_numerals_converted = [numerals_list[int(digit)] for digit in tokens[0]]
            all_numerals_converted.append('.')
            all_numerals_converted.extend(numerals_list[int(digit)] for digit in tokens[1])
            if alphabet == 'Latin':
                T = float
        else:
            all_numerals_converted = [numerals_list[int(digit)] for digit in number]
            if alphabet == 'Latin':
                T = int
        number = ''.join(all_numerals_converted)
    return T(f'{sign}{number}')
`;
  var music_prefix = `
notes_mapping = {
    'C': 'C4',
    'D': 'D4',
    'E': 'E4',
    'F': 'F4',
    'G': 'G4',
    'A': 'A4',
    'B': 'B4',
    '1': 'C0',
    '2': 'D0',
    '3': 'E0',
    '4': 'F0',
    '5': 'G0',
    '6': 'A0',
    '7': 'B0',
    '8': 'C1',
    '9': 'D1',
    '10': 'E1',
    '11': 'F1',
    '12': 'G1',
    '13': 'A1',
    '14': 'B1',
    '15': 'C2',
    '16': 'D2',
    '17': 'E2',
    '18': 'F2',
    '19': 'G2',
    '20': 'A2',
    '21': 'B2',
    '22': 'C3',
    '23': 'D3',
    '24': 'E3',
    '25': 'F3',
    '26': 'G3',
    '27': 'A3',
    '28': 'B3',
    '29': 'C4',
    '30': 'D4',
    '31': 'E4',
    '32': 'F4',
    '33': 'G4',
    '34': 'A4',
    '35': 'B4',
    '36': 'C5',
    '37': 'D5',
    '38': 'E5',
    '39': 'F5',
    '40': 'G5',
    '41': 'A5',
    '42': 'B5',
    '43': 'C6',
    '44': 'D6',
    '45': 'E6',
    '46': 'F6',
    '47': 'G6',
    '48': 'A6',
    '49': 'B6',
    '50': 'C7',
    '51': 'D7',
    '52': 'E7',
    '53': 'F7',
    '54': 'G7',
    '55': 'A7',
    '56': 'B7',
    '57': 'C8',
    '58': 'D8',
    '59': 'E8',
    '60': 'F8',
    '61': 'G8',
    '62': 'A8',
    '63': 'B8',
    '64': 'C9',
    '65': 'D9',
    '66': 'E9',
    '67': 'F9',
    '68': 'G9',
    '69': 'A9',
    '70': 'B9',
}
`;

  // static/js/types.ts
  function isServerSaveInfo(x) {
    return !!x && typeof x === "object" && !!x.id;
  }

  // static/js/tutorials/utils.ts
  function addHighlightBorder(element_id) {
    $("#" + element_id).addClass("border-2 rounded-lg border-red-500");
  }
  function removeBorder(element_id) {
    $("#" + element_id).removeClass("border-2 border-red-500");
  }
  function relocatePopup(x, y2) {
    $("#tutorial-pop-up").css({ "top": "20%", "left": "50%" });
    if (x && y2) {
      let left = x.toString() + "%";
      let top2 = y2.toString() + "%";
      $("#tutorial-pop-up").css({ "top": top2, "left": left });
    }
  }
  function tutorialPopup(current_level2, step) {
    let route = "/get_tutorial_step/" + current_level2 + "/";
    $.ajax({
      type: "GET",
      url: route + step.toString(),
      dataType: "json"
    }).done(function(response) {
      $("#tutorial_title").text(response.title);
      $("#tutorial_text").text(response.text);
      $("#tutorial-pop-up").fadeIn(800);
    }).fail(function(response) {
      modal.notifyError(response.responseText);
    });
  }

  // static/js/browser-helpers/unsaved-changes.ts
  function unloadHandler(event2) {
    event2.preventDefault();
    return event2.returnValue = ClientMessages["Unsaved_Changes"];
  }
  var unsavedChanges = false;
  function hasUnsavedChanges() {
    return unsavedChanges;
  }
  function markUnsavedChanges() {
    unsavedChanges = true;
    window.addEventListener("beforeunload", unloadHandler, { capture: true });
  }
  function clearUnsavedChanges() {
    unsavedChanges = false;
    window.removeEventListener("beforeunload", unloadHandler, { capture: true });
  }

  // static/js/tutorials/intro.ts
  var current_step = 0;
  function startIntro() {
    current_step = 1;
    $("#adventures").hide();
    $("#variables_container").hide();
    theGlobalEditor.contents = "";
    tutorialPopup("intro", current_step);
  }
  function callNextIntroStep() {
    current_step += 1;
    if (current_step == 2) {
      codeEditorStep();
    } else if (current_step == 3) {
      codeOutputStep();
    } else if (current_step == 4) {
      runButtonStep();
    } else if (current_step == 5) {
      tryRunButtonStep();
    } else if (current_step == 6) {
      speakAloudStep();
    } else if (current_step == 7) {
      runSpeakAloudStep();
    } else if (current_step == 8) {
      nextLevelStep();
    } else if (current_step == 9) {
      levelDefaultStep();
    } else if (current_step == 10) {
      adventureTabsStep();
    } else if (current_step == 11) {
      parsonsTabStep();
    } else if (current_step == 12) {
      quizTabStep();
    } else if (current_step == 13) {
      saveShareStep();
    } else if (current_step == 14) {
      cheatsheetStep();
    } else if (current_step == 15) {
      pushAchievement("well_begun_is_half_done");
      $("#achievement_pop-up").removeClass("z-10");
      $("#achievement_pop-up").addClass("z-50");
      setTimeout(function() {
        if ($("#achievement_pop-up").is(":visible")) {
          setTimeout(function() {
            endTutorial();
            $("#achievement_pop-up").removeClass("z-50");
            $("#achievement_pop-up").addClass("z-10");
          }, 5e3);
        } else {
          endTutorial();
          $("#achievement_pop-up").removeClass("z-50");
          $("#achievement_pop-up").addClass("z-10");
        }
      }, 500);
    } else {
      location.replace("/hedy");
    }
  }
  function codeEditorStep() {
    $("#editor").addClass("z-40");
    addHighlightBorder("editor");
    relocatePopup(65, 30);
    theGlobalEditor.contents = "print ___";
    tutorialPopup("intro", current_step);
  }
  function codeOutputStep() {
    removeBorder("editor");
    $("#code_output").addClass("z-40");
    addHighlightBorder("code_output");
    runit(1, "en", "", "run", function() {
      $("#output").focus();
    });
    relocatePopup(35, 30);
    tutorialPopup("intro", current_step);
  }
  function runButtonStep() {
    removeBorder("code_output");
    $("#code_related_buttons").show();
    $("#runButtonContainer").addClass("z-40");
    addHighlightBorder("runButtonContainer");
    relocatePopup(50, 30);
    tutorialPopup("intro", current_step);
  }
  function tryRunButtonStep() {
    $.ajax({
      type: "GET",
      url: "/get_tutorial_step/intro/code_snippet/",
      dataType: "json"
    }).done(function(response) {
      theGlobalEditor.contents = response.code;
    }).fail(function() {
      theGlobalEditor.contents = "print Hello world!\nprint I'm learning Hedy with the tutorial!";
    });
    relocatePopup(50, 70);
    tutorialPopup("intro", current_step);
  }
  function speakAloudStep() {
    removeBorder("runButtonContainer");
    $("#editor").removeClass("z-40");
    $("#code_output").removeClass("z-40");
    $("#runButtonContainer").removeClass("z-40");
    $("#speak_container").addClass("z-40 bg-white relative");
    addHighlightBorder("speak_container");
    relocatePopup(50, 30);
    tutorialPopup("intro", current_step);
  }
  function runSpeakAloudStep() {
    $("#editor").addClass("z-40");
    $("#code_output").addClass("z-40");
    $("#runButtonContainer").addClass("z-40");
    relocatePopup(50, 70);
    tutorialPopup("intro", current_step);
  }
  function nextLevelStep() {
    removeBorder("speak_container");
    $("#editor").removeClass("z-40");
    $("#code_output").removeClass("z-40");
    $("#runButtonContainer").removeClass("z-40");
    $("#speak_container").removeClass("z-40 bg-white relative");
    $("#next_level_button").addClass("z-40");
    $("#next_level_button").removeAttr("onclick");
    addHighlightBorder("next_level_button");
    relocatePopup(50, 30);
    tutorialPopup("intro", current_step);
  }
  function levelDefaultStep() {
    removeBorder("next_level_button");
    $("#next_level_button").removeClass("z-40");
    $("#code_content_container").addClass("z-40");
    $("#adventures").addClass("z-40 bg-gray-100");
    $("#adventures").show();
    clearUnsavedChanges();
    addHighlightBorder("adventures");
    relocatePopup(50, 40);
    tutorialPopup("intro", current_step);
  }
  function adventureTabsStep() {
    $("#adventures-buttons").children().each(function() {
      if ($(this).attr("data-tab") == "story") {
        clearUnsavedChanges();
        $(this).click();
      }
    });
    tutorialPopup("intro", current_step);
  }
  function parsonsTabStep() {
    $("#adventures-buttons").children().each(function() {
      if ($(this).attr("data-tab") == "parsons") {
        clearUnsavedChanges();
        $(this).click();
      }
    });
    tutorialPopup("intro", current_step);
  }
  function quizTabStep() {
    $("#adventures-buttons").children().each(function() {
      if ($(this).attr("data-tab") == "quiz") {
        clearUnsavedChanges();
        $(this).click();
      }
    });
    tutorialPopup("intro", current_step);
  }
  function saveShareStep() {
    $("#adventures-buttons").children().each(function() {
      if ($(this).attr("data-tab") == "default") {
        clearUnsavedChanges();
        $(this).click();
      }
    });
    removeBorder("adventures");
    $("#code_content_container").removeClass("z-40");
    $("#level-header").addClass("z-40");
    $("#cheatsheet_container").hide();
    addHighlightBorder("level-header");
    $("#save_program_button").removeAttr("onclick");
    $("#share_program_button").removeAttr("onclick");
    relocatePopup(50, 30);
    tutorialPopup("intro", current_step);
  }
  function cheatsheetStep() {
    $("#cheatsheet_container").show();
    $("#code_output").removeClass("z-40");
    $("#adventures").removeClass("z-40");
    $("#cheatsheet_dropdown").addClass("z-40");
    $("#cheatsheet_dropdown").show();
    tutorialPopup("intro", current_step);
  }
  function endTutorial() {
    removeBorder("level-header");
    $("#level-header").removeClass("z-40");
    $("#cheatsheet_dropdown").removeClass("z-40");
    $("#cheatsheet_dropdown").hide();
    relocatePopup(50, 15);
    tutorialPopup("intro", current_step);
  }

  // static/js/tutorials/teacher.ts
  var current_step2 = 0;
  function startTeacher() {
    current_step2 = 1;
    tutorialPopup("teacher", current_step2);
  }
  function callTeacherNextStep() {
    current_step2 += 1;
    if (current_step2 == 2) {
      classStep();
    } else if (current_step2 == 3) {
      customizeClassStep();
    } else if (current_step2 == 4) {
      adventureStep();
    } else if (current_step2 == 5) {
      multipleAccountsStep();
    } else if (current_step2 == 6) {
      documentationStep();
    } else if (current_step2 == 7) {
      pushAchievement("ring_the_bell");
      $("#achievement_pop-up").removeClass("z-10");
      $("#achievement_pop-up").addClass("z-50");
      setTimeout(function() {
        if ($("#achievement_pop-up").is(":visible")) {
          setTimeout(function() {
            teacherEndStep();
            $("#achievement_pop-up").removeClass("z-50");
            $("#achievement_pop-up").addClass("z-10");
          }, 5e3);
        } else {
          teacherEndStep();
          $("#achievement_pop-up").removeClass("z-50");
          $("#achievement_pop-up").addClass("z-10");
        }
      }, 500);
    } else {
      location.replace("/for-teachers");
    }
  }
  function classStep() {
    $("#auth_main_container").addClass("z-40");
    $("#teacher_classes").addClass("z-40 bg-gray-100");
    addHighlightBorder("teacher_classes");
    relocatePopup(50, 40);
    tutorialPopup("teacher", current_step2);
  }
  function customizeClassStep() {
    tutorialPopup("teacher", current_step2);
  }
  function adventureStep() {
    $("#teacher_adventures").addClass("z-40 bg-gray-100");
    removeBorder("teacher_classes");
    addHighlightBorder("teacher_adventures");
    relocatePopup(50, 70);
    tutorialPopup("teacher", current_step2);
  }
  function multipleAccountsStep() {
    $("#teacher_accounts").addClass("z-40 bg-gray-100");
    removeBorder("teacher_adventures");
    addHighlightBorder("teacher_accounts");
    relocatePopup(50, 20);
    tutorialPopup("teacher", current_step2);
  }
  function documentationStep() {
    $("#teacher_documentation").addClass("z-40 bg-gray-100");
    removeBorder("teacher_accounts");
    addHighlightBorder("teacher_documentation");
    tutorialPopup("teacher", current_step2);
  }
  function teacherEndStep() {
    removeBorder("teacher_documentation");
    tutorialPopup("teacher", current_step2);
  }

  // static/js/tutorials/level1.ts
  var current_step3 = 0;
  function startLevel1() {
    current_step3 = 1;
    tutorialPopup("1", current_step3);
  }
  function callNextStepLevel1() {
    current_step3 += 1;
    if (current_step3 == 2) {
      theGlobalEditor.contents = "print Hello world!";
      relocatePopup(50, 70);
      tutorialPopup("1", 2);
    } else if (current_step3 == 3) {
      location.replace("/hedy");
    }
  }

  // static/js/tutorials/tutorial.ts
  var current_level = "";
  function initializeTutorial() {
    $("#tutorial_next_button").off("click").on("click", () => {
      $("#tutorial-pop-up").hide();
      if (current_level == "intro") {
        return callNextIntroStep();
      } else if (current_level == "teacher") {
        return callTeacherNextStep();
      }
      return callNextLevelStep(current_level);
    });
  }
  function startIntroTutorial() {
    $("#tutorial-mask").show();
    current_level = "intro";
    startIntro();
  }
  function startLevelTutorial(level3) {
    $("#tutorial-mask").show();
    current_level = level3;
    startLevel(level3);
  }
  function startTeacherTutorial() {
    $("#tutorial-mask").show();
    current_level = "teacher";
    startTeacher();
  }
  function startLevel(current_level2) {
    if (current_level2 == "1") {
      startLevel1();
    }
  }
  function callNextLevelStep(current_level2) {
    if (current_level2 == "1") {
      callNextStepLevel1();
    }
  }

  // static/js/editor.ts
  var EditorType;
  (function(EditorType2) {
    EditorType2[EditorType2["MAIN"] = 0] = "MAIN";
    EditorType2[EditorType2["MODAL"] = 1] = "MODAL";
    EditorType2[EditorType2["COMMON_MISTAKES"] = 2] = "COMMON_MISTAKES";
    EditorType2[EditorType2["CHEATSHEET"] = 3] = "CHEATSHEET";
    EditorType2[EditorType2["PARSONS"] = 4] = "PARSONS";
    EditorType2[EditorType2["EXAMPLE"] = 5] = "EXAMPLE";
  })(EditorType || (EditorType = {}));

  // node_modules/@codemirror/state/dist/index.js
  var Text = class {
    lineAt(pos) {
      if (pos < 0 || pos > this.length)
        throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
      return this.lineInner(pos, false, 1, 0);
    }
    line(n) {
      if (n < 1 || n > this.lines)
        throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
      return this.lineInner(n, true, 1, 0);
    }
    replace(from17, to10, text) {
      [from17, to10] = clip(this, from17, to10);
      let parts = [];
      this.decompose(0, from17, parts, 2);
      if (text.length)
        text.decompose(0, text.length, parts, 1 | 2);
      this.decompose(to10, this.length, parts, 1);
      return TextNode.from(parts, this.length - (to10 - from17) + text.length);
    }
    append(other) {
      return this.replace(this.length, this.length, other);
    }
    slice(from17, to10 = this.length) {
      [from17, to10] = clip(this, from17, to10);
      let parts = [];
      this.decompose(from17, to10, parts, 0);
      return TextNode.from(parts, to10 - from17);
    }
    eq(other) {
      if (other == this)
        return true;
      if (other.length != this.length || other.lines != this.lines)
        return false;
      let start2 = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
      let a = new RawTextCursor(this), b = new RawTextCursor(other);
      for (let skip2 = start2, pos = start2; ; ) {
        a.next(skip2);
        b.next(skip2);
        skip2 = 0;
        if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
          return false;
        pos += a.value.length;
        if (a.done || pos >= end)
          return true;
      }
    }
    iter(dir = 1) {
      return new RawTextCursor(this, dir);
    }
    iterRange(from17, to10 = this.length) {
      return new PartialTextCursor(this, from17, to10);
    }
    iterLines(from17, to10) {
      let inner;
      if (from17 == null) {
        inner = this.iter();
      } else {
        if (to10 == null)
          to10 = this.lines + 1;
        let start2 = this.line(from17).from;
        inner = this.iterRange(start2, Math.max(start2, to10 == this.lines + 1 ? this.length : to10 <= 1 ? 0 : this.line(to10 - 1).to));
      }
      return new LineCursor(inner);
    }
    toString() {
      return this.sliceString(0);
    }
    toJSON() {
      let lines = [];
      this.flatten(lines);
      return lines;
    }
    constructor() {
    }
    static of(text) {
      if (text.length == 0)
        throw new RangeError("A document must have at least one line");
      if (text.length == 1 && !text[0])
        return Text.empty;
      return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
    }
  };
  var TextLeaf = class extends Text {
    constructor(text, length = textLength(text)) {
      super();
      this.text = text;
      this.length = length;
    }
    get lines() {
      return this.text.length;
    }
    get children() {
      return null;
    }
    lineInner(target, isLine, line, offset) {
      for (let i = 0; ; i++) {
        let string2 = this.text[i], end = offset + string2.length;
        if ((isLine ? line : end) >= target)
          return new Line(offset, end, line, string2);
        offset = end + 1;
        line++;
      }
    }
    decompose(from17, to10, target, open) {
      let text = from17 <= 0 && to10 >= this.length ? this : new TextLeaf(sliceText(this.text, from17, to10), Math.min(to10, this.length) - Math.max(0, from17));
      if (open & 1) {
        let prev = target.pop();
        let joined = appendText(text.text, prev.text.slice(), 0, text.length);
        if (joined.length <= 32) {
          target.push(new TextLeaf(joined, prev.length + text.length));
        } else {
          let mid = joined.length >> 1;
          target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
        }
      } else {
        target.push(text);
      }
    }
    replace(from17, to10, text) {
      if (!(text instanceof TextLeaf))
        return super.replace(from17, to10, text);
      [from17, to10] = clip(this, from17, to10);
      let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from17)), to10);
      let newLen = this.length + text.length - (to10 - from17);
      if (lines.length <= 32)
        return new TextLeaf(lines, newLen);
      return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from17, to10 = this.length, lineSep = "\n") {
      [from17, to10] = clip(this, from17, to10);
      let result = "";
      for (let pos = 0, i = 0; pos <= to10 && i < this.text.length; i++) {
        let line = this.text[i], end = pos + line.length;
        if (pos > from17 && i)
          result += lineSep;
        if (from17 < end && to10 > pos)
          result += line.slice(Math.max(0, from17 - pos), to10 - pos);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let line of this.text)
        target.push(line);
    }
    scanIdentical() {
      return 0;
    }
    static split(text, target) {
      let part = [], len = -1;
      for (let line of text) {
        part.push(line);
        len += line.length + 1;
        if (part.length == 32) {
          target.push(new TextLeaf(part, len));
          part = [];
          len = -1;
        }
      }
      if (len > -1)
        target.push(new TextLeaf(part, len));
      return target;
    }
  };
  var TextNode = class extends Text {
    constructor(children, length) {
      super();
      this.children = children;
      this.length = length;
      this.lines = 0;
      for (let child of children)
        this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
      for (let i = 0; ; i++) {
        let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
        if ((isLine ? endLine : end) >= target)
          return child.lineInner(target, isLine, line, offset);
        offset = end + 1;
        line = endLine + 1;
      }
    }
    decompose(from17, to10, target, open) {
      for (let i = 0, pos = 0; pos <= to10 && i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (from17 <= end && to10 >= pos) {
          let childOpen = open & ((pos <= from17 ? 1 : 0) | (end >= to10 ? 2 : 0));
          if (pos >= from17 && end <= to10 && !childOpen)
            target.push(child);
          else
            child.decompose(from17 - pos, to10 - pos, target, childOpen);
        }
        pos = end + 1;
      }
    }
    replace(from17, to10, text) {
      [from17, to10] = clip(this, from17, to10);
      if (text.lines < this.lines)
        for (let i = 0, pos = 0; i < this.children.length; i++) {
          let child = this.children[i], end = pos + child.length;
          if (from17 >= pos && to10 <= end) {
            let updated = child.replace(from17 - pos, to10 - pos, text);
            let totalLines = this.lines - child.lines + updated.lines;
            if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
              let copy = this.children.slice();
              copy[i] = updated;
              return new TextNode(copy, this.length - (to10 - from17) + text.length);
            }
            return super.replace(pos, end, updated);
          }
          pos = end + 1;
        }
      return super.replace(from17, to10, text);
    }
    sliceString(from17, to10 = this.length, lineSep = "\n") {
      [from17, to10] = clip(this, from17, to10);
      let result = "";
      for (let i = 0, pos = 0; i < this.children.length && pos <= to10; i++) {
        let child = this.children[i], end = pos + child.length;
        if (pos > from17 && i)
          result += lineSep;
        if (from17 < end && to10 > pos)
          result += child.sliceString(from17 - pos, to10 - pos, lineSep);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let child of this.children)
        child.flatten(target);
    }
    scanIdentical(other, dir) {
      if (!(other instanceof TextNode))
        return 0;
      let length = 0;
      let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
      for (; ; iA += dir, iB += dir) {
        if (iA == eA || iB == eB)
          return length;
        let chA = this.children[iA], chB = other.children[iB];
        if (chA != chB)
          return length + chA.scanIdentical(chB, dir);
        length += chA.length + 1;
      }
    }
    static from(children, length = children.reduce((l, ch2) => l + ch2.length + 1, -1)) {
      let lines = 0;
      for (let ch2 of children)
        lines += ch2.lines;
      if (lines < 32) {
        let flat = [];
        for (let ch2 of children)
          ch2.flatten(flat);
        return new TextLeaf(flat, length);
      }
      let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
      let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
      function add17(child) {
        let last;
        if (child.lines > maxChunk && child instanceof TextNode) {
          for (let node of child.children)
            add17(node);
        } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
          flush();
          chunked.push(child);
        } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
        } else {
          if (currentLines + child.lines > chunk)
            flush();
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk.push(child);
        }
      }
      function flush() {
        if (currentLines == 0)
          return;
        chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
        currentLen = -1;
        currentLines = currentChunk.length = 0;
      }
      for (let child of children)
        add17(child);
      flush();
      return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
    }
  };
  Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
  function textLength(text) {
    let length = -1;
    for (let line of text)
      length += line.length + 1;
    return length;
  }
  function appendText(text, target, from17 = 0, to10 = 1e9) {
    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to10; i++) {
      let line = text[i], end = pos + line.length;
      if (end >= from17) {
        if (end > to10)
          line = line.slice(0, to10 - pos);
        if (pos < from17)
          line = line.slice(from17 - pos);
        if (first) {
          target[target.length - 1] += line;
          first = false;
        } else
          target.push(line);
      }
      pos = end + 1;
    }
    return target;
  }
  function sliceText(text, from17, to10) {
    return appendText(text, [""], from17, to10);
  }
  var RawTextCursor = class {
    constructor(text, dir = 1) {
      this.dir = dir;
      this.done = false;
      this.lineBreak = false;
      this.value = "";
      this.nodes = [text];
      this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
    }
    nextInner(skip2, dir) {
      this.done = this.lineBreak = false;
      for (; ; ) {
        let last = this.nodes.length - 1;
        let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
        let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
        if (offset == (dir > 0 ? size : 0)) {
          if (last == 0) {
            this.done = true;
            this.value = "";
            return this;
          }
          if (dir > 0)
            this.offsets[last - 1]++;
          this.nodes.pop();
          this.offsets.pop();
        } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
          this.offsets[last] += dir;
          if (skip2 == 0) {
            this.lineBreak = true;
            this.value = "\n";
            return this;
          }
          skip2--;
        } else if (top2 instanceof TextLeaf) {
          let next = top2.text[offset + (dir < 0 ? -1 : 0)];
          this.offsets[last] += dir;
          if (next.length > Math.max(0, skip2)) {
            this.value = skip2 == 0 ? next : dir > 0 ? next.slice(skip2) : next.slice(0, next.length - skip2);
            return this;
          }
          skip2 -= next.length;
        } else {
          let next = top2.children[offset + (dir < 0 ? -1 : 0)];
          if (skip2 > next.length) {
            skip2 -= next.length;
            this.offsets[last] += dir;
          } else {
            if (dir < 0)
              this.offsets[last]--;
            this.nodes.push(next);
            this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
          }
        }
      }
    }
    next(skip2 = 0) {
      if (skip2 < 0) {
        this.nextInner(-skip2, -this.dir);
        skip2 = this.value.length;
      }
      return this.nextInner(skip2, this.dir);
    }
  };
  var PartialTextCursor = class {
    constructor(text, start2, end) {
      this.value = "";
      this.done = false;
      this.cursor = new RawTextCursor(text, start2 > end ? -1 : 1);
      this.pos = start2 > end ? text.length : 0;
      this.from = Math.min(start2, end);
      this.to = Math.max(start2, end);
    }
    nextInner(skip2, dir) {
      if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
        this.value = "";
        this.done = true;
        return this;
      }
      skip2 += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
      let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
      if (skip2 > limit)
        skip2 = limit;
      limit -= skip2;
      let { value } = this.cursor.next(skip2);
      this.pos += (value.length + skip2) * dir;
      this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
      this.done = !this.value;
      return this;
    }
    next(skip2 = 0) {
      if (skip2 < 0)
        skip2 = Math.max(skip2, this.from - this.pos);
      else if (skip2 > 0)
        skip2 = Math.min(skip2, this.to - this.pos);
      return this.nextInner(skip2, this.cursor.dir);
    }
    get lineBreak() {
      return this.cursor.lineBreak && this.value != "";
    }
  };
  var LineCursor = class {
    constructor(inner) {
      this.inner = inner;
      this.afterBreak = true;
      this.value = "";
      this.done = false;
    }
    next(skip2 = 0) {
      let { done, lineBreak, value } = this.inner.next(skip2);
      if (done && this.afterBreak) {
        this.value = "";
        this.afterBreak = false;
      } else if (done) {
        this.done = true;
        this.value = "";
      } else if (lineBreak) {
        if (this.afterBreak) {
          this.value = "";
        } else {
          this.afterBreak = true;
          this.next();
        }
      } else {
        this.value = value;
        this.afterBreak = false;
      }
      return this;
    }
    get lineBreak() {
      return false;
    }
  };
  if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function() {
      return this.iter();
    };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  var Line = class {
    constructor(from17, to10, number2, text) {
      this.from = from17;
      this.to = to10;
      this.number = number2;
      this.text = text;
    }
    get length() {
      return this.to - this.from;
    }
  };
  function clip(text, from17, to10) {
    from17 = Math.max(0, Math.min(text.length, from17));
    return [from17, Math.max(from17, Math.min(text.length, to10))];
  }
  var extend = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
  for (let i = 1; i < extend.length; i++)
    extend[i] += extend[i - 1];
  function isExtendingChar(code) {
    for (let i = 1; i < extend.length; i += 2)
      if (extend[i] > code)
        return extend[i - 1] <= code;
    return false;
  }
  function isRegionalIndicator(code) {
    return code >= 127462 && code <= 127487;
  }
  var ZWJ = 8205;
  function findClusterBreak(str, pos, forward18 = true, includeExtending = true) {
    return (forward18 ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
  }
  function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length)
      return pos;
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
      pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
      let next = codePointAt(str, pos);
      if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
        pos += codePointSize(next);
        prev = next;
      } else if (isRegionalIndicator(next)) {
        let countBefore = 0, i = pos - 2;
        while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
          countBefore++;
          i -= 2;
        }
        if (countBefore % 2 == 0)
          break;
        else
          pos += 2;
      } else {
        break;
      }
    }
    return pos;
  }
  function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
      let found = nextClusterBreak(str, pos - 2, includeExtending);
      if (found < pos)
        return found;
      pos--;
    }
    return 0;
  }
  function surrogateLow(ch2) {
    return ch2 >= 56320 && ch2 < 57344;
  }
  function surrogateHigh(ch2) {
    return ch2 >= 55296 && ch2 < 56320;
  }
  function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length)
      return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
      return code0;
    return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
  }
  function fromCodePoint(code) {
    if (code <= 65535)
      return String.fromCharCode(code);
    code -= 65536;
    return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
  }
  function codePointSize(code) {
    return code < 65536 ? 1 : 2;
  }
  var DefaultSplit = /\r\n?|\n/;
  var MapMode = /* @__PURE__ */ function(MapMode2) {
    MapMode2[MapMode2["Simple"] = 0] = "Simple";
    MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
    MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
    MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
    return MapMode2;
  }(MapMode || (MapMode = {}));
  var ChangeDesc = class {
    constructor(sections) {
      this.sections = sections;
    }
    get length() {
      let result = 0;
      for (let i = 0; i < this.sections.length; i += 2)
        result += this.sections[i];
      return result;
    }
    get newLength() {
      let result = 0;
      for (let i = 0; i < this.sections.length; i += 2) {
        let ins14 = this.sections[i + 1];
        result += ins14 < 0 ? this.sections[i] : ins14;
      }
      return result;
    }
    get empty() {
      return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
    }
    iterGaps(f) {
      for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins14 = this.sections[i++];
        if (ins14 < 0) {
          f(posA, posB, len);
          posB += len;
        } else {
          posB += ins14;
        }
        posA += len;
      }
    }
    iterChangedRanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get invertedDesc() {
      let sections = [];
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins14 = this.sections[i++];
        if (ins14 < 0)
          sections.push(len, ins14);
        else
          sections.push(ins14, len);
      }
      return new ChangeDesc(sections);
    }
    composeDesc(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other);
    }
    mapDesc(other, before = false) {
      return other.empty ? this : mapSet(this, other, before);
    }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
      let posA = 0, posB = 0;
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins14 = this.sections[i++], endA = posA + len;
        if (ins14 < 0) {
          if (endA > pos)
            return posB + (pos - posA);
          posB += len;
        } else {
          if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
            return null;
          if (endA > pos || endA == pos && assoc < 0 && !len)
            return pos == posA || assoc < 0 ? posB : posB + ins14;
          posB += ins14;
        }
        posA = endA;
      }
      if (pos > posA)
        throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
      return posB;
    }
    touchesRange(from17, to10 = from17) {
      for (let i = 0, pos = 0; i < this.sections.length && pos <= to10; ) {
        let len = this.sections[i++], ins14 = this.sections[i++], end = pos + len;
        if (ins14 >= 0 && pos <= to10 && end >= from17)
          return pos < from17 && end > to10 ? "cover" : true;
        pos = end;
      }
      return false;
    }
    toString() {
      let result = "";
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins14 = this.sections[i++];
        result += (result ? " " : "") + len + (ins14 >= 0 ? ":" + ins14 : "");
      }
      return result;
    }
    toJSON() {
      return this.sections;
    }
    static fromJSON(json) {
      if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number"))
        throw new RangeError("Invalid JSON representation of ChangeDesc");
      return new ChangeDesc(json);
    }
    static create(sections) {
      return new ChangeDesc(sections);
    }
  };
  var ChangeSet = class extends ChangeDesc {
    constructor(sections, inserted) {
      super(sections);
      this.inserted = inserted;
    }
    apply(doc2) {
      if (this.length != doc2.length)
        throw new RangeError("Applying change set to a document with the wrong length");
      iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
      return doc2;
    }
    mapDesc(other, before = false) {
      return mapSet(this, other, before, true);
    }
    invert(doc2) {
      let sections = this.sections.slice(), inserted = [];
      for (let i = 0, pos = 0; i < sections.length; i += 2) {
        let len = sections[i], ins14 = sections[i + 1];
        if (ins14 >= 0) {
          sections[i] = ins14;
          sections[i + 1] = len;
          let index3 = i >> 1;
          while (inserted.length < index3)
            inserted.push(Text.empty);
          inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
        }
        pos += len;
      }
      return new ChangeSet(sections, inserted);
    }
    compose(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other, true);
    }
    map(other, before = false) {
      return other.empty ? this : mapSet(this, other, before, true);
    }
    iterChanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get desc() {
      return ChangeDesc.create(this.sections);
    }
    filter(ranges) {
      let resultSections = [], resultInserted = [], filteredSections = [];
      let iter = new SectionIter(this);
      done:
        for (let i = 0, pos = 0; ; ) {
          let next = i == ranges.length ? 1e9 : ranges[i++];
          while (pos < next || pos == next && iter.len == 0) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, next - pos);
            addSection(filteredSections, len, -1);
            let ins14 = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
            addSection(resultSections, len, ins14);
            if (ins14 > 0)
              addInsert(resultInserted, resultSections, iter.text);
            iter.forward(len);
            pos += len;
          }
          let end = ranges[i++];
          while (pos < end) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, end - pos);
            addSection(resultSections, len, -1);
            addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
            iter.forward(len);
            pos += len;
          }
        }
      return {
        changes: new ChangeSet(resultSections, resultInserted),
        filtered: ChangeDesc.create(filteredSections)
      };
    }
    toJSON() {
      let parts = [];
      for (let i = 0; i < this.sections.length; i += 2) {
        let len = this.sections[i], ins14 = this.sections[i + 1];
        if (ins14 < 0)
          parts.push(len);
        else if (ins14 == 0)
          parts.push([len]);
        else
          parts.push([len].concat(this.inserted[i >> 1].toJSON()));
      }
      return parts;
    }
    static of(changes, length, lineSep) {
      let sections = [], inserted = [], pos = 0;
      let total = null;
      function flush(force = false) {
        if (!force && !sections.length)
          return;
        if (pos < length)
          addSection(sections, length - pos, -1);
        let set2 = new ChangeSet(sections, inserted);
        total = total ? total.compose(set2.map(total)) : set2;
        sections = [];
        inserted = [];
        pos = 0;
      }
      function process2(spec) {
        if (Array.isArray(spec)) {
          for (let sub of spec)
            process2(sub);
        } else if (spec instanceof ChangeSet) {
          if (spec.length != length)
            throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
          flush();
          total = total ? total.compose(spec.map(total)) : spec;
        } else {
          let { from: from17, to: to10 = from17, insert: insert2 } = spec;
          if (from17 > to10 || from17 < 0 || to10 > length)
            throw new RangeError(`Invalid change range ${from17} to ${to10} (in doc of length ${length})`);
          let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
          let insLen = insText.length;
          if (from17 == to10 && insLen == 0)
            return;
          if (from17 < pos)
            flush();
          if (from17 > pos)
            addSection(sections, from17 - pos, -1);
          addSection(sections, to10 - from17, insLen);
          addInsert(inserted, sections, insText);
          pos = to10;
        }
      }
      process2(changes);
      flush(!total);
      return total;
    }
    static empty(length) {
      return new ChangeSet(length ? [length, -1] : [], []);
    }
    static fromJSON(json) {
      if (!Array.isArray(json))
        throw new RangeError("Invalid JSON representation of ChangeSet");
      let sections = [], inserted = [];
      for (let i = 0; i < json.length; i++) {
        let part = json[i];
        if (typeof part == "number") {
          sections.push(part, -1);
        } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
          throw new RangeError("Invalid JSON representation of ChangeSet");
        } else if (part.length == 1) {
          sections.push(part[0], 0);
        } else {
          while (inserted.length < i)
            inserted.push(Text.empty);
          inserted[i] = Text.of(part.slice(1));
          sections.push(part[0], inserted[i].length);
        }
      }
      return new ChangeSet(sections, inserted);
    }
    static createSet(sections, inserted) {
      return new ChangeSet(sections, inserted);
    }
  };
  function addSection(sections, len, ins14, forceJoin = false) {
    if (len == 0 && ins14 <= 0)
      return;
    let last = sections.length - 2;
    if (last >= 0 && ins14 <= 0 && ins14 == sections[last + 1])
      sections[last] += len;
    else if (len == 0 && sections[last] == 0)
      sections[last + 1] += ins14;
    else if (forceJoin) {
      sections[last] += len;
      sections[last + 1] += ins14;
    } else
      sections.push(len, ins14);
  }
  function addInsert(values, sections, value) {
    if (value.length == 0)
      return;
    let index3 = sections.length - 2 >> 1;
    if (index3 < values.length) {
      values[values.length - 1] = values[values.length - 1].append(value);
    } else {
      while (values.length < index3)
        values.push(Text.empty);
      values.push(value);
    }
  }
  function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
      let len = desc.sections[i++], ins14 = desc.sections[i++];
      if (ins14 < 0) {
        posA += len;
        posB += len;
      } else {
        let endA = posA, endB = posB, text = Text.empty;
        for (; ; ) {
          endA += len;
          endB += ins14;
          if (ins14 && inserted)
            text = text.append(inserted[i - 2 >> 1]);
          if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
            break;
          len = desc.sections[i++];
          ins14 = desc.sections[i++];
        }
        f(posA, endA, posB, endB, text);
        posA = endA;
        posB = endB;
      }
    }
  }
  function mapSet(setA, setB, before, mkSet = false) {
    let sections = [], insert2 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let inserted = -1; ; ) {
      if (a.ins == -1 && b.ins == -1) {
        let len = Math.min(a.len, b.len);
        addSection(sections, len, -1);
        a.forward(len);
        b.forward(len);
      } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
        let len = b.len;
        addSection(sections, b.ins, -1);
        while (len) {
          let piece = Math.min(a.len, len);
          if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
            addSection(sections, 0, a.ins);
            if (insert2)
              addInsert(insert2, sections, a.text);
            inserted = a.i;
          }
          a.forward(piece);
          len -= piece;
        }
        b.next();
      } else if (a.ins >= 0) {
        let len = 0, left = a.len;
        while (left) {
          if (b.ins == -1) {
            let piece = Math.min(left, b.len);
            len += piece;
            left -= piece;
            b.forward(piece);
          } else if (b.ins == 0 && b.len < left) {
            left -= b.len;
            b.next();
          } else {
            break;
          }
        }
        addSection(sections, len, inserted < a.i ? a.ins : 0);
        if (insert2 && inserted < a.i)
          addInsert(insert2, sections, a.text);
        inserted = a.i;
        a.forward(a.len - left);
      } else if (a.done && b.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else {
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert2 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let open = false; ; ) {
      if (a.done && b.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else if (a.ins == 0) {
        addSection(sections, a.len, 0, open);
        a.next();
      } else if (b.len == 0 && !b.done) {
        addSection(sections, 0, b.ins, open);
        if (insert2)
          addInsert(insert2, sections, b.text);
        b.next();
      } else if (a.done || b.done) {
        throw new Error("Mismatched change set lengths");
      } else {
        let len = Math.min(a.len2, b.len), sectionLen = sections.length;
        if (a.ins == -1) {
          let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
          addSection(sections, len, insB, open);
          if (insert2 && insB)
            addInsert(insert2, sections, b.text);
        } else if (b.ins == -1) {
          addSection(sections, a.off ? 0 : a.len, len, open);
          if (insert2)
            addInsert(insert2, sections, a.textBit(len));
        } else {
          addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
          if (insert2 && !b.off)
            addInsert(insert2, sections, b.text);
        }
        open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
        a.forward2(len);
        b.forward(len);
      }
    }
  }
  var SectionIter = class {
    constructor(set2) {
      this.set = set2;
      this.i = 0;
      this.next();
    }
    next() {
      let { sections } = this.set;
      if (this.i < sections.length) {
        this.len = sections[this.i++];
        this.ins = sections[this.i++];
      } else {
        this.len = 0;
        this.ins = -2;
      }
      this.off = 0;
    }
    get done() {
      return this.ins == -2;
    }
    get len2() {
      return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
      let { inserted } = this.set, index3 = this.i - 2 >> 1;
      return index3 >= inserted.length ? Text.empty : inserted[index3];
    }
    textBit(len) {
      let { inserted } = this.set, index3 = this.i - 2 >> 1;
      return index3 >= inserted.length && !len ? Text.empty : inserted[index3].slice(this.off, len == null ? void 0 : this.off + len);
    }
    forward(len) {
      if (len == this.len)
        this.next();
      else {
        this.len -= len;
        this.off += len;
      }
    }
    forward2(len) {
      if (this.ins == -1)
        this.forward(len);
      else if (len == this.ins)
        this.next();
      else {
        this.ins -= len;
        this.off += len;
      }
    }
  };
  var SelectionRange = class {
    constructor(from17, to10, flags) {
      this.from = from17;
      this.to = to10;
      this.flags = flags;
    }
    get anchor() {
      return this.flags & 32 ? this.to : this.from;
    }
    get head() {
      return this.flags & 32 ? this.from : this.to;
    }
    get empty() {
      return this.from == this.to;
    }
    get assoc() {
      return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
    }
    get bidiLevel() {
      let level3 = this.flags & 7;
      return level3 == 7 ? null : level3;
    }
    get goalColumn() {
      let value = this.flags >> 6;
      return value == 16777215 ? void 0 : value;
    }
    map(change, assoc = -1) {
      let from17, to10;
      if (this.empty) {
        from17 = to10 = change.mapPos(this.from, assoc);
      } else {
        from17 = change.mapPos(this.from, 1);
        to10 = change.mapPos(this.to, -1);
      }
      return from17 == this.from && to10 == this.to ? this : new SelectionRange(from17, to10, this.flags);
    }
    extend(from17, to10 = from17) {
      if (from17 <= this.anchor && to10 >= this.anchor)
        return EditorSelection.range(from17, to10);
      let head = Math.abs(from17 - this.anchor) > Math.abs(to10 - this.anchor) ? from17 : to10;
      return EditorSelection.range(this.anchor, head);
    }
    eq(other, includeAssoc = false) {
      return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
    }
    toJSON() {
      return { anchor: this.anchor, head: this.head };
    }
    static fromJSON(json) {
      if (!json || typeof json.anchor != "number" || typeof json.head != "number")
        throw new RangeError("Invalid JSON representation for SelectionRange");
      return EditorSelection.range(json.anchor, json.head);
    }
    static create(from17, to10, flags) {
      return new SelectionRange(from17, to10, flags);
    }
  };
  var EditorSelection = class {
    constructor(ranges, mainIndex) {
      this.ranges = ranges;
      this.mainIndex = mainIndex;
    }
    map(change, assoc = -1) {
      if (change.empty)
        return this;
      return EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
    }
    eq(other, includeAssoc = false) {
      if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
        return false;
      for (let i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].eq(other.ranges[i], includeAssoc))
          return false;
      return true;
    }
    get main() {
      return this.ranges[this.mainIndex];
    }
    asSingle() {
      return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
    }
    addRange(range10, main = true) {
      return EditorSelection.create([range10].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    replaceRange(range10, which = this.mainIndex) {
      let ranges = this.ranges.slice();
      ranges[which] = range10;
      return EditorSelection.create(ranges, this.mainIndex);
    }
    toJSON() {
      return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
    }
    static fromJSON(json) {
      if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
        throw new RangeError("Invalid JSON representation for EditorSelection");
      return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
    }
    static single(anchor, head = anchor) {
      return new EditorSelection([EditorSelection.range(anchor, head)], 0);
    }
    static create(ranges, mainIndex = 0) {
      if (ranges.length == 0)
        throw new RangeError("A selection needs at least one range");
      for (let pos = 0, i = 0; i < ranges.length; i++) {
        let range10 = ranges[i];
        if (range10.empty ? range10.from <= pos : range10.from < pos)
          return EditorSelection.normalized(ranges.slice(), mainIndex);
        pos = range10.to;
      }
      return new EditorSelection(ranges, mainIndex);
    }
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
      return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
    }
    static range(anchor, head, goalColumn, bidiLevel) {
      let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
      return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
    }
    static normalized(ranges, mainIndex = 0) {
      let main = ranges[mainIndex];
      ranges.sort((a, b) => a.from - b.from);
      mainIndex = ranges.indexOf(main);
      for (let i = 1; i < ranges.length; i++) {
        let range10 = ranges[i], prev = ranges[i - 1];
        if (range10.empty ? range10.from <= prev.to : range10.from < prev.to) {
          let from17 = prev.from, to10 = Math.max(range10.to, prev.to);
          if (i <= mainIndex)
            mainIndex--;
          ranges.splice(--i, 2, range10.anchor > range10.head ? EditorSelection.range(to10, from17) : EditorSelection.range(from17, to10));
        }
      }
      return new EditorSelection(ranges, mainIndex);
    }
  };
  function checkSelection(selection2, docLength) {
    for (let range10 of selection2.ranges)
      if (range10.to > docLength)
        throw new RangeError("Selection points outside of document");
  }
  var nextID = 0;
  var Facet = class {
    constructor(combine, compareInput, compare2, isStatic, enables) {
      this.combine = combine;
      this.compareInput = compareInput;
      this.compare = compare2;
      this.isStatic = isStatic;
      this.id = nextID++;
      this.default = combine([]);
      this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
    get reader() {
      return this;
    }
    static define(config = {}) {
      return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);
    }
    of(value) {
      return new FacetProvider([], this, 0, value);
    }
    compute(deps, get) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 1, get);
    }
    computeN(deps, get) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 2, get);
    }
    from(field, get) {
      if (!get)
        get = (x) => x;
      return this.compute([field], (state) => get(state.field(field)));
    }
  };
  function sameArray(a, b) {
    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
  }
  var FacetProvider = class {
    constructor(dependencies, facet, type, value) {
      this.dependencies = dependencies;
      this.facet = facet;
      this.type = type;
      this.value = value;
      this.id = nextID++;
    }
    dynamicSlot(addresses) {
      var _a3;
      let getter = this.value;
      let compare2 = this.facet.compareInput;
      let id2 = this.id, idx = addresses[id2] >> 1, multi = this.type == 2;
      let depDoc = false, depSel = false, depAddrs = [];
      for (let dep of this.dependencies) {
        if (dep == "doc")
          depDoc = true;
        else if (dep == "selection")
          depSel = true;
        else if ((((_a3 = addresses[dep.id]) !== null && _a3 !== void 0 ? _a3 : 1) & 1) == 0)
          depAddrs.push(addresses[dep.id]);
      }
      return {
        create(state) {
          state.values[idx] = getter(state);
          return 1;
        },
        update(state, tr3) {
          if (depDoc && tr3.docChanged || depSel && (tr3.docChanged || tr3.selection) || ensureAll(state, depAddrs)) {
            let newVal = getter(state);
            if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
              state.values[idx] = newVal;
              return 1;
            }
          }
          return 0;
        },
        reconfigure: (state, oldState) => {
          let newVal, oldAddr = oldState.config.address[id2];
          if (oldAddr != null) {
            let oldVal = getAddr(oldState, oldAddr);
            if (this.dependencies.every((dep) => {
              return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
            }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
              state.values[idx] = oldVal;
              return 0;
            }
          } else {
            newVal = getter(state);
          }
          state.values[idx] = newVal;
          return 1;
        }
      };
    }
  };
  function compareArray(a, b, compare2) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compare2(a[i], b[i]))
        return false;
    return true;
  }
  function ensureAll(state, addrs) {
    let changed = false;
    for (let addr of addrs)
      if (ensureAddr(state, addr) & 1)
        changed = true;
    return changed;
  }
  function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map((p) => addresses[p.id]);
    let providerTypes = providers.map((p) => p.type);
    let dynamic = providerAddrs.filter((p) => !(p & 1));
    let idx = addresses[facet.id] >> 1;
    function get(state) {
      let values = [];
      for (let i = 0; i < providerAddrs.length; i++) {
        let value = getAddr(state, providerAddrs[i]);
        if (providerTypes[i] == 2)
          for (let val of value)
            values.push(val);
        else
          values.push(value);
      }
      return facet.combine(values);
    }
    return {
      create(state) {
        for (let addr of providerAddrs)
          ensureAddr(state, addr);
        state.values[idx] = get(state);
        return 1;
      },
      update(state, tr3) {
        if (!ensureAll(state, dynamic))
          return 0;
        let value = get(state);
        if (facet.compare(value, state.values[idx]))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure(state, oldState) {
        let depChanged = ensureAll(state, providerAddrs);
        let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
        if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
          state.values[idx] = oldValue;
          return 0;
        }
        let value = get(state);
        if (facet.compare(value, oldValue)) {
          state.values[idx] = oldValue;
          return 0;
        }
        state.values[idx] = value;
        return 1;
      }
    };
  }
  var initField = /* @__PURE__ */ Facet.define({ static: true });
  var StateField = class {
    constructor(id2, createF, updateF, compareF, spec) {
      this.id = id2;
      this.createF = createF;
      this.updateF = updateF;
      this.compareF = compareF;
      this.spec = spec;
      this.provides = void 0;
    }
    static define(config) {
      let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
      if (config.provide)
        field.provides = config.provide(field);
      return field;
    }
    create(state) {
      let init = state.facet(initField).find((i) => i.field == this);
      return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
    }
    slot(addresses) {
      let idx = addresses[this.id] >> 1;
      return {
        create: (state) => {
          state.values[idx] = this.create(state);
          return 1;
        },
        update: (state, tr3) => {
          let oldVal = state.values[idx];
          let value = this.updateF(oldVal, tr3);
          if (this.compareF(oldVal, value))
            return 0;
          state.values[idx] = value;
          return 1;
        },
        reconfigure: (state, oldState) => {
          if (oldState.config.address[this.id] != null) {
            state.values[idx] = oldState.field(this);
            return 0;
          }
          state.values[idx] = this.create(state);
          return 1;
        }
      };
    }
    init(create) {
      return [this, initField.of({ field: this, create })];
    }
    get extension() {
      return this;
    }
  };
  var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
  function prec(value) {
    return (ext) => new PrecExtension(ext, value);
  }
  var Prec = {
    highest: /* @__PURE__ */ prec(Prec_.highest),
    high: /* @__PURE__ */ prec(Prec_.high),
    default: /* @__PURE__ */ prec(Prec_.default),
    low: /* @__PURE__ */ prec(Prec_.low),
    lowest: /* @__PURE__ */ prec(Prec_.lowest)
  };
  var PrecExtension = class {
    constructor(inner, prec2) {
      this.inner = inner;
      this.prec = prec2;
    }
  };
  var Compartment = class {
    of(ext) {
      return new CompartmentInstance(this, ext);
    }
    reconfigure(content2) {
      return Compartment.reconfigure.of({ compartment: this, extension: content2 });
    }
    get(state) {
      return state.config.compartments.get(this);
    }
  };
  var CompartmentInstance = class {
    constructor(compartment, inner) {
      this.compartment = compartment;
      this.inner = inner;
    }
  };
  var Configuration = class {
    constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
      this.base = base2;
      this.compartments = compartments;
      this.dynamicSlots = dynamicSlots;
      this.address = address;
      this.staticValues = staticValues;
      this.facets = facets;
      this.statusTemplate = [];
      while (this.statusTemplate.length < dynamicSlots.length)
        this.statusTemplate.push(0);
    }
    staticFacet(facet) {
      let addr = this.address[facet.id];
      return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base2, compartments, oldState) {
      let fields = [];
      let facets = Object.create(null);
      let newCompartments = new Map();
      for (let ext of flatten(base2, compartments, newCompartments)) {
        if (ext instanceof StateField)
          fields.push(ext);
        else
          (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
      }
      let address = Object.create(null);
      let staticValues = [];
      let dynamicSlots = [];
      for (let field of fields) {
        address[field.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => field.slot(a));
      }
      let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
      for (let id2 in facets) {
        let providers = facets[id2], facet = providers[0].facet;
        let oldProviders = oldFacets && oldFacets[id2] || [];
        if (providers.every((p) => p.type == 0)) {
          address[facet.id] = staticValues.length << 1 | 1;
          if (sameArray(oldProviders, providers)) {
            staticValues.push(oldState.facet(facet));
          } else {
            let value = facet.combine(providers.map((p) => p.value));
            staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
          }
        } else {
          for (let p of providers) {
            if (p.type == 0) {
              address[p.id] = staticValues.length << 1 | 1;
              staticValues.push(p.value);
            } else {
              address[p.id] = dynamicSlots.length << 1;
              dynamicSlots.push((a) => p.dynamicSlot(a));
            }
          }
          address[facet.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
        }
      }
      let dynamic = dynamicSlots.map((f) => f(address));
      return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
    }
  };
  function flatten(extension, compartments, newCompartments) {
    let result = [[], [], [], [], []];
    let seen = new Map();
    function inner(ext, prec2) {
      let known = seen.get(ext);
      if (known != null) {
        if (known <= prec2)
          return;
        let found = result[known].indexOf(ext);
        if (found > -1)
          result[known].splice(found, 1);
        if (ext instanceof CompartmentInstance)
          newCompartments.delete(ext.compartment);
      }
      seen.set(ext, prec2);
      if (Array.isArray(ext)) {
        for (let e of ext)
          inner(e, prec2);
      } else if (ext instanceof CompartmentInstance) {
        if (newCompartments.has(ext.compartment))
          throw new RangeError(`Duplicate use of compartment in extensions`);
        let content2 = compartments.get(ext.compartment) || ext.inner;
        newCompartments.set(ext.compartment, content2);
        inner(content2, prec2);
      } else if (ext instanceof PrecExtension) {
        inner(ext.inner, ext.prec);
      } else if (ext instanceof StateField) {
        result[prec2].push(ext);
        if (ext.provides)
          inner(ext.provides, prec2);
      } else if (ext instanceof FacetProvider) {
        result[prec2].push(ext);
        if (ext.facet.extensions)
          inner(ext.facet.extensions, Prec_.default);
      } else {
        let content2 = ext.extension;
        if (!content2)
          throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
        inner(content2, prec2);
      }
    }
    inner(extension, Prec_.default);
    return result.reduce((a, b) => a.concat(b));
  }
  function ensureAddr(state, addr) {
    if (addr & 1)
      return 2;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4)
      throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2)
      return status;
    state.status[idx] = 4;
    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
    return state.status[idx] = 2 | changed;
  }
  function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
  }
  var languageData = /* @__PURE__ */ Facet.define();
  var allowMultipleSelections = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((v) => v),
    static: true
  });
  var lineSeparator = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : void 0,
    static: true
  });
  var changeFilter = /* @__PURE__ */ Facet.define();
  var transactionFilter = /* @__PURE__ */ Facet.define();
  var transactionExtender = /* @__PURE__ */ Facet.define();
  var readOnly2 = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : false
  });
  var Annotation = class {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
    static define() {
      return new AnnotationType();
    }
  };
  var AnnotationType = class {
    of(value) {
      return new Annotation(this, value);
    }
  };
  var StateEffectType = class {
    constructor(map3) {
      this.map = map3;
    }
    of(value) {
      return new StateEffect(this, value);
    }
  };
  var StateEffect = class {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
    map(mapping) {
      let mapped = this.type.map(this.value, mapping);
      return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    is(type) {
      return this.type == type;
    }
    static define(spec = {}) {
      return new StateEffectType(spec.map || ((v) => v));
    }
    static mapEffects(effects2, mapping) {
      if (!effects2.length)
        return effects2;
      let result = [];
      for (let effect of effects2) {
        let mapped = effect.map(mapping);
        if (mapped)
          result.push(mapped);
      }
      return result;
    }
  };
  StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
  StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
  var Transaction = class {
    constructor(startState, changes, selection2, effects2, annotations, scrollIntoView2) {
      this.startState = startState;
      this.changes = changes;
      this.selection = selection2;
      this.effects = effects2;
      this.annotations = annotations;
      this.scrollIntoView = scrollIntoView2;
      this._doc = null;
      this._state = null;
      if (selection2)
        checkSelection(selection2, changes.newLength);
      if (!annotations.some((a) => a.type == Transaction.time))
        this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
    static create(startState, changes, selection2, effects2, annotations, scrollIntoView2) {
      return new Transaction(startState, changes, selection2, effects2, annotations, scrollIntoView2);
    }
    get newDoc() {
      return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    get newSelection() {
      return this.selection || this.startState.selection.map(this.changes);
    }
    get state() {
      if (!this._state)
        this.startState.applyTransaction(this);
      return this._state;
    }
    annotation(type) {
      for (let ann of this.annotations)
        if (ann.type == type)
          return ann.value;
      return void 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get reconfigured() {
      return this.startState.config != this.state.config;
    }
    isUserEvent(event2) {
      let e = this.annotation(Transaction.userEvent);
      return !!(e && (e == event2 || e.length > event2.length && e.slice(0, event2.length) == event2 && e[event2.length] == "."));
    }
  };
  Transaction.time = /* @__PURE__ */ Annotation.define();
  Transaction.userEvent = /* @__PURE__ */ Annotation.define();
  Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
  Transaction.remote = /* @__PURE__ */ Annotation.define();
  function joinRanges(a, b) {
    let result = [];
    for (let iA = 0, iB = 0; ; ) {
      let from17, to10;
      if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
        from17 = a[iA++];
        to10 = a[iA++];
      } else if (iB < b.length) {
        from17 = b[iB++];
        to10 = b[iB++];
      } else
        return result;
      if (!result.length || result[result.length - 1] < from17)
        result.push(from17, to10);
      else if (result[result.length - 1] < to10)
        result[result.length - 1] = to10;
    }
  }
  function mergeTransaction(a, b, sequential) {
    var _a3;
    let mapForA, mapForB, changes;
    if (sequential) {
      mapForA = b.changes;
      mapForB = ChangeSet.empty(b.changes.length);
      changes = a.changes.compose(b.changes);
    } else {
      mapForA = b.changes.map(a.changes);
      mapForB = a.changes.mapDesc(b.changes, true);
      changes = a.changes.compose(mapForA);
    }
    return {
      changes,
      selection: b.selection ? b.selection.map(mapForB) : (_a3 = a.selection) === null || _a3 === void 0 ? void 0 : _a3.map(mapForA),
      effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
      annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
      scrollIntoView: a.scrollIntoView || b.scrollIntoView
    };
  }
  function resolveTransactionInner(state, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
      annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
      changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
      selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
      effects: asArray(spec.effects),
      annotations,
      scrollIntoView: !!spec.scrollIntoView
    };
  }
  function resolveTransaction(state, specs, filter) {
    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false)
      filter = false;
    for (let i = 1; i < specs.length; i++) {
      if (specs[i].filter === false)
        filter = false;
      let seq = !!specs[i].sequential;
      s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
    }
    let tr3 = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr3) : tr3);
  }
  function filterTransaction(tr3) {
    let state = tr3.startState;
    let result = true;
    for (let filter of state.facet(changeFilter)) {
      let value = filter(tr3);
      if (value === false) {
        result = false;
        break;
      }
      if (Array.isArray(value))
        result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
      let changes, back;
      if (result === false) {
        back = tr3.changes.invertedDesc;
        changes = ChangeSet.empty(state.doc.length);
      } else {
        let filtered = tr3.changes.filter(result);
        changes = filtered.changes;
        back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
      }
      tr3 = Transaction.create(state, changes, tr3.selection && tr3.selection.map(back), StateEffect.mapEffects(tr3.effects, back), tr3.annotations, tr3.scrollIntoView);
    }
    let filters = state.facet(transactionFilter);
    for (let i = filters.length - 1; i >= 0; i--) {
      let filtered = filters[i](tr3);
      if (filtered instanceof Transaction)
        tr3 = filtered;
      else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
        tr3 = filtered[0];
      else
        tr3 = resolveTransaction(state, asArray(filtered), false);
    }
    return tr3;
  }
  function extendTransaction(tr3) {
    let state = tr3.startState, extenders = state.facet(transactionExtender), spec = tr3;
    for (let i = extenders.length - 1; i >= 0; i--) {
      let extension = extenders[i](tr3);
      if (extension && Object.keys(extension).length)
        spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr3.changes.newLength), true);
    }
    return spec == tr3 ? tr3 : Transaction.create(state, tr3.changes, tr3.selection, spec.effects, spec.annotations, spec.scrollIntoView);
  }
  var none = [];
  function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [value];
  }
  var CharCategory = /* @__PURE__ */ function(CharCategory2) {
    CharCategory2[CharCategory2["Word"] = 0] = "Word";
    CharCategory2[CharCategory2["Space"] = 1] = "Space";
    CharCategory2[CharCategory2["Other"] = 2] = "Other";
    return CharCategory2;
  }(CharCategory || (CharCategory = {}));
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var wordChar;
  try {
    wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch (_) {
  }
  function hasWordChar(str) {
    if (wordChar)
      return wordChar.test(str);
    for (let i = 0; i < str.length; i++) {
      let ch2 = str[i];
      if (/\w/.test(ch2) || ch2 > "\x80" && (ch2.toUpperCase() != ch2.toLowerCase() || nonASCIISingleCaseWordChar.test(ch2)))
        return true;
    }
    return false;
  }
  function makeCategorizer(wordChars) {
    return (char) => {
      if (!/\S/.test(char))
        return CharCategory.Space;
      if (hasWordChar(char))
        return CharCategory.Word;
      for (let i = 0; i < wordChars.length; i++)
        if (char.indexOf(wordChars[i]) > -1)
          return CharCategory.Word;
      return CharCategory.Other;
    };
  }
  var EditorState = class {
    constructor(config, doc2, selection2, values, computeSlot, tr3) {
      this.config = config;
      this.doc = doc2;
      this.selection = selection2;
      this.values = values;
      this.status = config.statusTemplate.slice();
      this.computeSlot = computeSlot;
      if (tr3)
        tr3._state = this;
      for (let i = 0; i < this.config.dynamicSlots.length; i++)
        ensureAddr(this, i << 1);
      this.computeSlot = null;
    }
    field(field, require2 = true) {
      let addr = this.config.address[field.id];
      if (addr == null) {
        if (require2)
          throw new RangeError("Field is not present in this state");
        return void 0;
      }
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    update(...specs) {
      return resolveTransaction(this, specs, true);
    }
    applyTransaction(tr3) {
      let conf = this.config, { base: base2, compartments } = conf;
      for (let effect of tr3.effects) {
        if (effect.is(Compartment.reconfigure)) {
          if (conf) {
            compartments = new Map();
            conf.compartments.forEach((val, key) => compartments.set(key, val));
            conf = null;
          }
          compartments.set(effect.value.compartment, effect.value.extension);
        } else if (effect.is(StateEffect.reconfigure)) {
          conf = null;
          base2 = effect.value;
        } else if (effect.is(StateEffect.appendConfig)) {
          conf = null;
          base2 = asArray(base2).concat(effect.value);
        }
      }
      let startValues;
      if (!conf) {
        conf = Configuration.resolve(base2, compartments, this);
        let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
        startValues = intermediateState.values;
      } else {
        startValues = tr3.startState.values.slice();
      }
      let selection2 = tr3.startState.facet(allowMultipleSelections) ? tr3.newSelection : tr3.newSelection.asSingle();
      new EditorState(conf, tr3.newDoc, selection2, startValues, (state, slot) => slot.update(state, tr3), tr3);
    }
    replaceSelection(text) {
      if (typeof text == "string")
        text = this.toText(text);
      return this.changeByRange((range10) => ({
        changes: { from: range10.from, to: range10.to, insert: text },
        range: EditorSelection.cursor(range10.from + text.length)
      }));
    }
    changeByRange(f) {
      let sel = this.selection;
      let result1 = f(sel.ranges[0]);
      let changes = this.changes(result1.changes), ranges = [result1.range];
      let effects2 = asArray(result1.effects);
      for (let i = 1; i < sel.ranges.length; i++) {
        let result = f(sel.ranges[i]);
        let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
        for (let j2 = 0; j2 < i; j2++)
          ranges[j2] = ranges[j2].map(newMapped);
        let mapBy = changes.mapDesc(newChanges, true);
        ranges.push(result.range.map(mapBy));
        changes = changes.compose(newMapped);
        effects2 = StateEffect.mapEffects(effects2, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
      }
      return {
        changes,
        selection: EditorSelection.create(ranges, sel.mainIndex),
        effects: effects2
      };
    }
    changes(spec = []) {
      if (spec instanceof ChangeSet)
        return spec;
      return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    toText(string2) {
      return Text.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    sliceDoc(from17 = 0, to10 = this.doc.length) {
      return this.doc.sliceString(from17, to10, this.lineBreak);
    }
    facet(facet) {
      let addr = this.config.address[facet.id];
      if (addr == null)
        return facet.default;
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    toJSON(fields) {
      let result = {
        doc: this.sliceDoc(),
        selection: this.selection.toJSON()
      };
      if (fields)
        for (let prop in fields) {
          let value = fields[prop];
          if (value instanceof StateField && this.config.address[value.id] != null)
            result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
        }
      return result;
    }
    static fromJSON(json, config = {}, fields) {
      if (!json || typeof json.doc != "string")
        throw new RangeError("Invalid JSON representation for EditorState");
      let fieldInit = [];
      if (fields)
        for (let prop in fields) {
          if (Object.prototype.hasOwnProperty.call(json, prop)) {
            let field = fields[prop], value = json[prop];
            fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
          }
        }
      return EditorState.create({
        doc: json.doc,
        selection: EditorSelection.fromJSON(json.selection),
        extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
      });
    }
    static create(config = {}) {
      let configuration = Configuration.resolve(config.extensions || [], new Map());
      let doc2 = config.doc instanceof Text ? config.doc : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
      let selection2 = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);
      checkSelection(selection2, doc2.length);
      if (!configuration.staticFacet(allowMultipleSelections))
        selection2 = selection2.asSingle();
      return new EditorState(configuration, doc2, selection2, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
    }
    get tabSize() {
      return this.facet(EditorState.tabSize);
    }
    get lineBreak() {
      return this.facet(EditorState.lineSeparator) || "\n";
    }
    get readOnly() {
      return this.facet(readOnly2);
    }
    phrase(phrase2, ...insert2) {
      for (let map3 of this.facet(EditorState.phrases))
        if (Object.prototype.hasOwnProperty.call(map3, phrase2)) {
          phrase2 = map3[phrase2];
          break;
        }
      if (insert2.length)
        phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m, i) => {
          if (i == "$")
            return "$";
          let n = +(i || 1);
          return !n || n > insert2.length ? m : insert2[n - 1];
        });
      return phrase2;
    }
    languageDataAt(name2, pos, side = -1) {
      let values = [];
      for (let provider of this.facet(languageData)) {
        for (let result of provider(this, pos, side)) {
          if (Object.prototype.hasOwnProperty.call(result, name2))
            values.push(result[name2]);
        }
      }
      return values;
    }
    charCategorizer(at14) {
      return makeCategorizer(this.languageDataAt("wordChars", at14).join(""));
    }
    wordAt(pos) {
      let { text, from: from17, length } = this.doc.lineAt(pos);
      let cat = this.charCategorizer(pos);
      let start2 = pos - from17, end = pos - from17;
      while (start2 > 0) {
        let prev = findClusterBreak(text, start2, false);
        if (cat(text.slice(prev, start2)) != CharCategory.Word)
          break;
        start2 = prev;
      }
      while (end < length) {
        let next = findClusterBreak(text, end);
        if (cat(text.slice(end, next)) != CharCategory.Word)
          break;
        end = next;
      }
      return start2 == end ? null : EditorSelection.range(start2 + from17, end + from17);
    }
  };
  EditorState.allowMultipleSelections = allowMultipleSelections;
  EditorState.tabSize = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : 4
  });
  EditorState.lineSeparator = lineSeparator;
  EditorState.readOnly = readOnly2;
  EditorState.phrases = /* @__PURE__ */ Facet.define({
    compare(a, b) {
      let kA = Object.keys(a), kB = Object.keys(b);
      return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
    }
  });
  EditorState.languageData = languageData;
  EditorState.changeFilter = changeFilter;
  EditorState.transactionFilter = transactionFilter;
  EditorState.transactionExtender = transactionExtender;
  Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
  function combineConfig(configs, defaults4, combine = {}) {
    let result = {};
    for (let config of configs)
      for (let key of Object.keys(config)) {
        let value = config[key], current = result[key];
        if (current === void 0)
          result[key] = value;
        else if (current === value || value === void 0)
          ;
        else if (Object.hasOwnProperty.call(combine, key))
          result[key] = combine[key](current, value);
        else
          throw new Error("Config merge conflict for field " + key);
      }
    for (let key in defaults4)
      if (result[key] === void 0)
        result[key] = defaults4[key];
    return result;
  }
  var RangeValue = class {
    eq(other) {
      return this == other;
    }
    range(from17, to10 = from17) {
      return Range.create(from17, to10, this);
    }
  };
  RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
  RangeValue.prototype.point = false;
  RangeValue.prototype.mapMode = MapMode.TrackDel;
  var Range = class {
    constructor(from17, to10, value) {
      this.from = from17;
      this.to = to10;
      this.value = value;
    }
    static create(from17, to10, value) {
      return new Range(from17, to10, value);
    }
  };
  function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
  }
  var Chunk = class {
    constructor(from17, to10, value, maxPoint) {
      this.from = from17;
      this.to = to10;
      this.value = value;
      this.maxPoint = maxPoint;
    }
    get length() {
      return this.to[this.to.length - 1];
    }
    findIndex(pos, side, end, startAt = 0) {
      let arr = end ? this.to : this.from;
      for (let lo2 = startAt, hi3 = arr.length; ; ) {
        if (lo2 == hi3)
          return lo2;
        let mid = lo2 + hi3 >> 1;
        let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
        if (mid == lo2)
          return diff >= 0 ? lo2 : hi3;
        if (diff >= 0)
          hi3 = mid;
        else
          lo2 = mid + 1;
      }
    }
    between(offset, from17, to10, f) {
      for (let i = this.findIndex(from17, -1e9, true), e = this.findIndex(to10, 1e9, false, i); i < e; i++)
        if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
          return false;
    }
    map(offset, changes) {
      let value = [], from17 = [], to10 = [], newPos = -1, maxPoint = -1;
      for (let i = 0; i < this.value.length; i++) {
        let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
        if (curFrom == curTo) {
          let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
          if (mapped == null)
            continue;
          newFrom = newTo = mapped;
          if (val.startSide != val.endSide) {
            newTo = changes.mapPos(curFrom, val.endSide);
            if (newTo < newFrom)
              continue;
          }
        } else {
          newFrom = changes.mapPos(curFrom, val.startSide);
          newTo = changes.mapPos(curTo, val.endSide);
          if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
            continue;
        }
        if ((newTo - newFrom || val.endSide - val.startSide) < 0)
          continue;
        if (newPos < 0)
          newPos = newFrom;
        if (val.point)
          maxPoint = Math.max(maxPoint, newTo - newFrom);
        value.push(val);
        from17.push(newFrom - newPos);
        to10.push(newTo - newPos);
      }
      return { mapped: value.length ? new Chunk(from17, to10, value, maxPoint) : null, pos: newPos };
    }
  };
  var RangeSet = class {
    constructor(chunkPos, chunk, nextLayer, maxPoint) {
      this.chunkPos = chunkPos;
      this.chunk = chunk;
      this.nextLayer = nextLayer;
      this.maxPoint = maxPoint;
    }
    static create(chunkPos, chunk, nextLayer, maxPoint) {
      return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    get length() {
      let last = this.chunk.length - 1;
      return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
    }
    get size() {
      if (this.isEmpty)
        return 0;
      let size = this.nextLayer.size;
      for (let chunk of this.chunk)
        size += chunk.value.length;
      return size;
    }
    chunkEnd(index3) {
      return this.chunkPos[index3] + this.chunk[index3].length;
    }
    update(updateSpec) {
      let { add: add17 = [], sort: sort2 = false, filterFrom = 0, filterTo = this.length } = updateSpec;
      let filter = updateSpec.filter;
      if (add17.length == 0 && !filter)
        return this;
      if (sort2)
        add17 = add17.slice().sort(cmpRange);
      if (this.isEmpty)
        return add17.length ? RangeSet.of(add17) : this;
      let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
      let builder = new RangeSetBuilder();
      while (cur.value || i < add17.length) {
        if (i < add17.length && (cur.from - add17[i].from || cur.startSide - add17[i].value.startSide) >= 0) {
          let range10 = add17[i++];
          if (!builder.addInner(range10.from, range10.to, range10.value))
            spill.push(range10);
        } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add17.length || this.chunkEnd(cur.chunkIndex) < add17[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
          cur.nextChunk();
        } else {
          if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
            if (!builder.addInner(cur.from, cur.to, cur.value))
              spill.push(Range.create(cur.from, cur.to, cur.value));
          }
          cur.next();
        }
      }
      return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
    }
    map(changes) {
      if (changes.empty || this.isEmpty)
        return this;
      let chunks = [], chunkPos = [], maxPoint = -1;
      for (let i = 0; i < this.chunk.length; i++) {
        let start2 = this.chunkPos[i], chunk = this.chunk[i];
        let touch = changes.touchesRange(start2, start2 + chunk.length);
        if (touch === false) {
          maxPoint = Math.max(maxPoint, chunk.maxPoint);
          chunks.push(chunk);
          chunkPos.push(changes.mapPos(start2));
        } else if (touch === true) {
          let { mapped, pos } = chunk.map(start2, changes);
          if (mapped) {
            maxPoint = Math.max(maxPoint, mapped.maxPoint);
            chunks.push(mapped);
            chunkPos.push(pos);
          }
        }
      }
      let next = this.nextLayer.map(changes);
      return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
    }
    between(from17, to10, f) {
      if (this.isEmpty)
        return;
      for (let i = 0; i < this.chunk.length; i++) {
        let start2 = this.chunkPos[i], chunk = this.chunk[i];
        if (to10 >= start2 && from17 <= start2 + chunk.length && chunk.between(start2, from17 - start2, to10 - start2, f) === false)
          return;
      }
      this.nextLayer.between(from17, to10, f);
    }
    iter(from17 = 0) {
      return HeapCursor.from([this]).goto(from17);
    }
    get isEmpty() {
      return this.nextLayer == this;
    }
    static iter(sets, from17 = 0) {
      return HeapCursor.from(sets).goto(from17);
    }
    static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
      let a = oldSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
      let b = newSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
      let sharedChunks = findSharedChunks(a, b, textDiff);
      let sideA = new SpanCursor(a, sharedChunks, minPointSize);
      let sideB = new SpanCursor(b, sharedChunks, minPointSize);
      textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
      if (textDiff.empty && textDiff.length == 0)
        compare(sideA, 0, sideB, 0, 0, comparator);
    }
    static eq(oldSets, newSets, from17 = 0, to10) {
      if (to10 == null)
        to10 = 1e9 - 1;
      let a = oldSets.filter((set2) => !set2.isEmpty && newSets.indexOf(set2) < 0);
      let b = newSets.filter((set2) => !set2.isEmpty && oldSets.indexOf(set2) < 0);
      if (a.length != b.length)
        return false;
      if (!a.length)
        return true;
      let sharedChunks = findSharedChunks(a, b);
      let sideA = new SpanCursor(a, sharedChunks, 0).goto(from17), sideB = new SpanCursor(b, sharedChunks, 0).goto(from17);
      for (; ; ) {
        if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
          return false;
        if (sideA.to > to10)
          return true;
        sideA.next();
        sideB.next();
      }
    }
    static spans(sets, from17, to10, iterator, minPointSize = -1) {
      let cursor = new SpanCursor(sets, null, minPointSize).goto(from17), pos = from17;
      let openRanges = cursor.openStart;
      for (; ; ) {
        let curTo = Math.min(cursor.to, to10);
        if (cursor.point) {
          let active = cursor.activeForPoint(cursor.to);
          let openCount = cursor.pointFrom < from17 ? active.length + 1 : Math.min(active.length, openRanges);
          iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
          openRanges = Math.min(cursor.openEnd(curTo), active.length);
        } else if (curTo > pos) {
          iterator.span(pos, curTo, cursor.active, openRanges);
          openRanges = cursor.openEnd(curTo);
        }
        if (cursor.to > to10)
          return openRanges + (cursor.point && cursor.to > to10 ? 1 : 0);
        pos = cursor.to;
        cursor.next();
      }
    }
    static of(ranges, sort2 = false) {
      let build = new RangeSetBuilder();
      for (let range10 of ranges instanceof Range ? [ranges] : sort2 ? lazySort(ranges) : ranges)
        build.add(range10.from, range10.to, range10.value);
      return build.finish();
    }
    static join(sets) {
      if (!sets.length)
        return RangeSet.empty;
      let result = sets[sets.length - 1];
      for (let i = sets.length - 2; i >= 0; i--) {
        for (let layer2 = sets[i]; layer2 != RangeSet.empty; layer2 = layer2.nextLayer)
          result = new RangeSet(layer2.chunkPos, layer2.chunk, result, Math.max(layer2.maxPoint, result.maxPoint));
      }
      return result;
    }
  };
  RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
  function lazySort(ranges) {
    if (ranges.length > 1)
      for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
        let cur = ranges[i];
        if (cmpRange(prev, cur) > 0)
          return ranges.slice().sort(cmpRange);
        prev = cur;
      }
    return ranges;
  }
  RangeSet.empty.nextLayer = RangeSet.empty;
  var RangeSetBuilder = class {
    finishChunk(newArrays) {
      this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
      this.chunkPos.push(this.chunkStart);
      this.chunkStart = -1;
      this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
      this.maxPoint = -1;
      if (newArrays) {
        this.from = [];
        this.to = [];
        this.value = [];
      }
    }
    constructor() {
      this.chunks = [];
      this.chunkPos = [];
      this.chunkStart = -1;
      this.last = null;
      this.lastFrom = -1e9;
      this.lastTo = -1e9;
      this.from = [];
      this.to = [];
      this.value = [];
      this.maxPoint = -1;
      this.setMaxPoint = -1;
      this.nextLayer = null;
    }
    add(from17, to10, value) {
      if (!this.addInner(from17, to10, value))
        (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from17, to10, value);
    }
    addInner(from17, to10, value) {
      let diff = from17 - this.lastTo || value.startSide - this.last.endSide;
      if (diff <= 0 && (from17 - this.lastFrom || value.startSide - this.last.startSide) < 0)
        throw new Error("Ranges must be added sorted by `from` position and `startSide`");
      if (diff < 0)
        return false;
      if (this.from.length == 250)
        this.finishChunk(true);
      if (this.chunkStart < 0)
        this.chunkStart = from17;
      this.from.push(from17 - this.chunkStart);
      this.to.push(to10 - this.chunkStart);
      this.last = value;
      this.lastFrom = from17;
      this.lastTo = to10;
      this.value.push(value);
      if (value.point)
        this.maxPoint = Math.max(this.maxPoint, to10 - from17);
      return true;
    }
    addChunk(from17, chunk) {
      if ((from17 - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
        return false;
      if (this.from.length)
        this.finishChunk(true);
      this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
      this.chunks.push(chunk);
      this.chunkPos.push(from17);
      let last = chunk.value.length - 1;
      this.last = chunk.value[last];
      this.lastFrom = chunk.from[last] + from17;
      this.lastTo = chunk.to[last] + from17;
      return true;
    }
    finish() {
      return this.finishInner(RangeSet.empty);
    }
    finishInner(next) {
      if (this.from.length)
        this.finishChunk(false);
      if (this.chunks.length == 0)
        return next;
      let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
      this.from = null;
      return result;
    }
  };
  function findSharedChunks(a, b, textDiff) {
    let inA = new Map();
    for (let set2 of a)
      for (let i = 0; i < set2.chunk.length; i++)
        if (set2.chunk[i].maxPoint <= 0)
          inA.set(set2.chunk[i], set2.chunkPos[i]);
    let shared = new Set();
    for (let set2 of b)
      for (let i = 0; i < set2.chunk.length; i++) {
        let known = inA.get(set2.chunk[i]);
        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set2.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set2.chunk[i].length)))
          shared.add(set2.chunk[i]);
      }
    return shared;
  }
  var LayerCursor = class {
    constructor(layer2, skip2, minPoint, rank = 0) {
      this.layer = layer2;
      this.skip = skip2;
      this.minPoint = minPoint;
      this.rank = rank;
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    get endSide() {
      return this.value ? this.value.endSide : 0;
    }
    goto(pos, side = -1e9) {
      this.chunkIndex = this.rangeIndex = 0;
      this.gotoInner(pos, side, false);
      return this;
    }
    gotoInner(pos, side, forward18) {
      while (this.chunkIndex < this.layer.chunk.length) {
        let next = this.layer.chunk[this.chunkIndex];
        if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
          break;
        this.chunkIndex++;
        forward18 = false;
      }
      if (this.chunkIndex < this.layer.chunk.length) {
        let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
        if (!forward18 || this.rangeIndex < rangeIndex)
          this.setRangeIndex(rangeIndex);
      }
      this.next();
    }
    forward(pos, side) {
      if ((this.to - pos || this.endSide - side) < 0)
        this.gotoInner(pos, side, true);
    }
    next() {
      for (; ; ) {
        if (this.chunkIndex == this.layer.chunk.length) {
          this.from = this.to = 1e9;
          this.value = null;
          break;
        } else {
          let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
          let from17 = chunkPos + chunk.from[this.rangeIndex];
          this.from = from17;
          this.to = chunkPos + chunk.to[this.rangeIndex];
          this.value = chunk.value[this.rangeIndex];
          this.setRangeIndex(this.rangeIndex + 1);
          if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
            break;
        }
      }
    }
    setRangeIndex(index3) {
      if (index3 == this.layer.chunk[this.chunkIndex].value.length) {
        this.chunkIndex++;
        if (this.skip) {
          while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
            this.chunkIndex++;
        }
        this.rangeIndex = 0;
      } else {
        this.rangeIndex = index3;
      }
    }
    nextChunk() {
      this.chunkIndex++;
      this.rangeIndex = 0;
      this.next();
    }
    compare(other) {
      return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
    }
  };
  var HeapCursor = class {
    constructor(heap) {
      this.heap = heap;
    }
    static from(sets, skip2 = null, minPoint = -1) {
      let heap = [];
      for (let i = 0; i < sets.length; i++) {
        for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
          if (cur.maxPoint >= minPoint)
            heap.push(new LayerCursor(cur, skip2, minPoint, i));
        }
      }
      return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    goto(pos, side = -1e9) {
      for (let cur of this.heap)
        cur.goto(pos, side);
      for (let i = this.heap.length >> 1; i >= 0; i--)
        heapBubble(this.heap, i);
      this.next();
      return this;
    }
    forward(pos, side) {
      for (let cur of this.heap)
        cur.forward(pos, side);
      for (let i = this.heap.length >> 1; i >= 0; i--)
        heapBubble(this.heap, i);
      if ((this.to - pos || this.value.endSide - side) < 0)
        this.next();
    }
    next() {
      if (this.heap.length == 0) {
        this.from = this.to = 1e9;
        this.value = null;
        this.rank = -1;
      } else {
        let top2 = this.heap[0];
        this.from = top2.from;
        this.to = top2.to;
        this.value = top2.value;
        this.rank = top2.rank;
        if (top2.value)
          top2.next();
        heapBubble(this.heap, 0);
      }
    }
  };
  function heapBubble(heap, index3) {
    for (let cur = heap[index3]; ; ) {
      let childIndex = (index3 << 1) + 1;
      if (childIndex >= heap.length)
        break;
      let child = heap[childIndex];
      if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
        child = heap[childIndex + 1];
        childIndex++;
      }
      if (cur.compare(child) < 0)
        break;
      heap[childIndex] = cur;
      heap[index3] = child;
      index3 = childIndex;
    }
  }
  var SpanCursor = class {
    constructor(sets, skip2, minPoint) {
      this.minPoint = minPoint;
      this.active = [];
      this.activeTo = [];
      this.activeRank = [];
      this.minActive = -1;
      this.point = null;
      this.pointFrom = 0;
      this.pointRank = 0;
      this.to = -1e9;
      this.endSide = 0;
      this.openStart = -1;
      this.cursor = HeapCursor.from(sets, skip2, minPoint);
    }
    goto(pos, side = -1e9) {
      this.cursor.goto(pos, side);
      this.active.length = this.activeTo.length = this.activeRank.length = 0;
      this.minActive = -1;
      this.to = pos;
      this.endSide = side;
      this.openStart = -1;
      this.next();
      return this;
    }
    forward(pos, side) {
      while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
        this.removeActive(this.minActive);
      this.cursor.forward(pos, side);
    }
    removeActive(index3) {
      remove(this.active, index3);
      remove(this.activeTo, index3);
      remove(this.activeRank, index3);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
      let i = 0, { value, to: to10, rank } = this.cursor;
      while (i < this.activeRank.length && (rank - this.activeRank[i] || to10 - this.activeTo[i]) > 0)
        i++;
      insert(this.active, i, value);
      insert(this.activeTo, i, to10);
      insert(this.activeRank, i, rank);
      if (trackOpen)
        insert(trackOpen, i, this.cursor.from);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    next() {
      let from17 = this.to, wasPoint = this.point;
      this.point = null;
      let trackOpen = this.openStart < 0 ? [] : null;
      for (; ; ) {
        let a = this.minActive;
        if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
          if (this.activeTo[a] > from17) {
            this.to = this.activeTo[a];
            this.endSide = this.active[a].endSide;
            break;
          }
          this.removeActive(a);
          if (trackOpen)
            remove(trackOpen, a);
        } else if (!this.cursor.value) {
          this.to = this.endSide = 1e9;
          break;
        } else if (this.cursor.from > from17) {
          this.to = this.cursor.from;
          this.endSide = this.cursor.startSide;
          break;
        } else {
          let nextVal = this.cursor.value;
          if (!nextVal.point) {
            this.addActive(trackOpen);
            this.cursor.next();
          } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
            this.cursor.next();
          } else {
            this.point = nextVal;
            this.pointFrom = this.cursor.from;
            this.pointRank = this.cursor.rank;
            this.to = this.cursor.to;
            this.endSide = nextVal.endSide;
            this.cursor.next();
            this.forward(this.to, this.endSide);
            break;
          }
        }
      }
      if (trackOpen) {
        this.openStart = 0;
        for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from17; i--)
          this.openStart++;
      }
    }
    activeForPoint(to10) {
      if (!this.active.length)
        return this.active;
      let active = [];
      for (let i = this.active.length - 1; i >= 0; i--) {
        if (this.activeRank[i] < this.pointRank)
          break;
        if (this.activeTo[i] > to10 || this.activeTo[i] == to10 && this.active[i].endSide >= this.point.endSide)
          active.push(this.active[i]);
      }
      return active.reverse();
    }
    openEnd(to10) {
      let open = 0;
      for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to10; i--)
        open++;
      return open;
    }
  };
  function compare(a, startA, b, startB, length, comparator) {
    a.goto(startA);
    b.goto(startB);
    let endB = startB + length;
    let pos = startB, dPos = startB - startA;
    for (; ; ) {
      let diff = a.to + dPos - b.to || a.endSide - b.endSide;
      let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
      if (a.point || b.point) {
        if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))
          comparator.comparePoint(pos, clipEnd, a.point, b.point);
      } else {
        if (clipEnd > pos && !sameValues(a.active, b.active))
          comparator.compareRange(pos, clipEnd, a.active, b.active);
      }
      if (end > endB)
        break;
      pos = end;
      if (diff <= 0)
        a.next();
      if (diff >= 0)
        b.next();
    }
  }
  function sameValues(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (a[i] != b[i] && !a[i].eq(b[i]))
        return false;
    return true;
  }
  function remove(array, index3) {
    for (let i = index3, e = array.length - 1; i < e; i++)
      array[i] = array[i + 1];
    array.pop();
  }
  function insert(array, index3, value) {
    for (let i = array.length - 1; i >= index3; i--)
      array[i + 1] = array[i];
    array[index3] = value;
  }
  function findMinIndex(value, array) {
    let found = -1, foundPos = 1e9;
    for (let i = 0; i < array.length; i++)
      if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
        found = i;
        foundPos = array[i];
      }
    return found;
  }
  function countColumn(string2, tabSize, to10 = string2.length) {
    let n = 0;
    for (let i = 0; i < to10; ) {
      if (string2.charCodeAt(i) == 9) {
        n += tabSize - n % tabSize;
        i++;
      } else {
        n++;
        i = findClusterBreak(string2, i);
      }
    }
    return n;
  }
  function findColumn(string2, col, tabSize, strict) {
    for (let i = 0, n = 0; ; ) {
      if (n >= col)
        return i;
      if (i == string2.length)
        break;
      n += string2.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
      i = findClusterBreak(string2, i);
    }
    return strict === true ? -1 : string2.length;
  }

  // node_modules/style-mod/src/style-mod.js
  var C = "\u037C";
  var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
  var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
  var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
  var StyleModule = class {
    constructor(spec, options) {
      this.rules = [];
      let { finish } = options || {};
      function splitSelector(selector) {
        return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
      }
      function render(selectors, spec2, target, isKeyframes) {
        let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
        if (isAt && spec2 == null)
          return target.push(selectors[0] + ";");
        for (let prop in spec2) {
          let value = spec2[prop];
          if (/&/.test(prop)) {
            render(prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)), value, target);
          } else if (value && typeof value == "object") {
            if (!isAt)
              throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
            render(splitSelector(prop), value, local, keyframes);
          } else if (value != null) {
            local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
          }
        }
        if (local.length || keyframes) {
          target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
        }
      }
      for (let prop in spec)
        render(splitSelector(prop), spec[prop], this.rules);
    }
    getRules() {
      return this.rules.join("\n");
    }
    static newName() {
      let id2 = top[COUNT] || 1;
      top[COUNT] = id2 + 1;
      return C + id2.toString(36);
    }
    static mount(root, modules, options) {
      let set2 = root[SET], nonce = options && options.nonce;
      if (!set2)
        set2 = new StyleSet(root, nonce);
      else if (nonce)
        set2.setNonce(nonce);
      set2.mount(Array.isArray(modules) ? modules : [modules]);
    }
  };
  var adoptedSet = new Map();
  var StyleSet = class {
    constructor(root, nonce) {
      let doc2 = root.ownerDocument || root, win = doc2.defaultView;
      if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
        let adopted = adoptedSet.get(doc2);
        if (adopted) {
          root.adoptedStyleSheets = [adopted.sheet, ...root.adoptedStyleSheets];
          return root[SET] = adopted;
        }
        this.sheet = new win.CSSStyleSheet();
        root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];
        adoptedSet.set(doc2, this);
      } else {
        this.styleTag = doc2.createElement("style");
        if (nonce)
          this.styleTag.setAttribute("nonce", nonce);
        let target = root.head || root;
        target.insertBefore(this.styleTag, target.firstChild);
      }
      this.modules = [];
      root[SET] = this;
    }
    mount(modules) {
      let sheet = this.sheet;
      let pos = 0, j2 = 0;
      for (let i = 0; i < modules.length; i++) {
        let mod = modules[i], index3 = this.modules.indexOf(mod);
        if (index3 < j2 && index3 > -1) {
          this.modules.splice(index3, 1);
          j2--;
          index3 = -1;
        }
        if (index3 == -1) {
          this.modules.splice(j2++, 0, mod);
          if (sheet)
            for (let k = 0; k < mod.rules.length; k++)
              sheet.insertRule(mod.rules[k], pos++);
        } else {
          while (j2 < index3)
            pos += this.modules[j2++].rules.length;
          pos += mod.rules.length;
          j2++;
        }
      }
      if (!sheet) {
        let text = "";
        for (let i = 0; i < this.modules.length; i++)
          text += this.modules[i].getRules() + "\n";
        this.styleTag.textContent = text;
      }
    }
    setNonce(nonce) {
      if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
        this.styleTag.setAttribute("nonce", nonce);
    }
  };

  // node_modules/w3c-keyname/index.js
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  for (i = 0; i < 10; i++)
    base[48 + i] = base[96 + i] = String(i);
  var i;
  for (i = 1; i <= 24; i++)
    base[i + 111] = "F" + i;
  var i;
  for (i = 65; i <= 90; i++) {
    base[i] = String.fromCharCode(i + 32);
    shift[i] = String.fromCharCode(i);
  }
  var i;
  for (code in base)
    if (!shift.hasOwnProperty(code))
      shift[code] = base[code];
  var code;
  function keyName(event2) {
    var ignoreKey = mac && event2.metaKey && event2.shiftKey && !event2.ctrlKey && !event2.altKey || ie && event2.shiftKey && event2.key && event2.key.length == 1 || event2.key == "Unidentified";
    var name2 = !ignoreKey && event2.key || (event2.shiftKey ? shift : base)[event2.keyCode] || event2.key || "Unidentified";
    if (name2 == "Esc")
      name2 = "Escape";
    if (name2 == "Del")
      name2 = "Delete";
    if (name2 == "Left")
      name2 = "ArrowLeft";
    if (name2 == "Up")
      name2 = "ArrowUp";
    if (name2 == "Right")
      name2 = "ArrowRight";
    if (name2 == "Down")
      name2 = "ArrowDown";
    return name2;
  }

  // node_modules/@codemirror/view/dist/index.js
  function getSelection(root) {
    let target;
    if (root.nodeType == 11) {
      target = root.getSelection ? root : root.ownerDocument;
    } else {
      target = root;
    }
    return target.getSelection();
  }
  function contains(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
  }
  function deepActiveElement(doc2) {
    let elt = doc2.activeElement;
    while (elt && elt.shadowRoot)
      elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function hasSelection(dom, selection2) {
    if (!selection2.anchorNode)
      return false;
    try {
      return contains(dom, selection2.anchorNode);
    } catch (_) {
      return false;
    }
  }
  function clientRectsFor(dom) {
    if (dom.nodeType == 3)
      return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
      return dom.getClientRects();
    else
      return [];
  }
  function isEquivalentPosition(node, off2, targetNode, targetOff) {
    return targetNode ? scanFor(node, off2, targetNode, targetOff, -1) || scanFor(node, off2, targetNode, targetOff, 1) : false;
  }
  function domIndex(node) {
    for (var index3 = 0; ; index3++) {
      node = node.previousSibling;
      if (!node)
        return index3;
    }
  }
  function scanFor(node, off2, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node == targetNode && off2 == targetOff)
        return true;
      if (off2 == (dir < 0 ? 0 : maxOffset(node))) {
        if (node.nodeName == "DIV")
          return false;
        let parent = node.parentNode;
        if (!parent || parent.nodeType != 1)
          return false;
        off2 = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off2 + (dir < 0 ? -1 : 0)];
        if (node.nodeType == 1 && node.contentEditable == "false")
          return false;
        off2 = dir < 0 ? maxOffset(node) : 0;
      } else {
        return false;
      }
    }
  }
  function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  function flattenRect(rect, left) {
    let x = left ? rect.left : rect.right;
    return { left: x, right: x, top: rect.top, bottom: rect.bottom };
  }
  function windowRect(win) {
    return {
      left: 0,
      right: win.innerWidth,
      top: 0,
      bottom: win.innerHeight
    };
  }
  function scrollRectIntoView(dom, rect, side, x, y2, xMargin, yMargin, ltr) {
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    for (let cur = dom, stop = false; cur && !stop; ) {
      if (cur.nodeType == 1) {
        let bounding, top2 = cur == doc2.body;
        let scaleX = 1, scaleY = 1;
        if (top2) {
          bounding = windowRect(win);
        } else {
          if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position))
            stop = true;
          if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
            cur = cur.assignedSlot || cur.parentNode;
            continue;
          }
          let rect2 = cur.getBoundingClientRect();
          scaleX = rect2.width / cur.offsetWidth;
          scaleY = rect2.height / cur.offsetHeight;
          bounding = {
            left: rect2.left,
            right: rect2.left + cur.clientWidth * scaleX,
            top: rect2.top,
            bottom: rect2.top + cur.clientHeight * scaleY
          };
        }
        let moveX = 0, moveY = 0;
        if (y2 == "nearest") {
          if (rect.top < bounding.top) {
            moveY = -(bounding.top - rect.top + yMargin);
            if (side > 0 && rect.bottom > bounding.bottom + moveY)
              moveY = rect.bottom - bounding.bottom + moveY + yMargin;
          } else if (rect.bottom > bounding.bottom) {
            moveY = rect.bottom - bounding.bottom + yMargin;
            if (side < 0 && rect.top - moveY < bounding.top)
              moveY = -(bounding.top + moveY - rect.top + yMargin);
          }
        } else {
          let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
          let targetTop = y2 == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y2 == "start" || y2 == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
          moveY = targetTop - bounding.top;
        }
        if (x == "nearest") {
          if (rect.left < bounding.left) {
            moveX = -(bounding.left - rect.left + xMargin);
            if (side > 0 && rect.right > bounding.right + moveX)
              moveX = rect.right - bounding.right + moveX + xMargin;
          } else if (rect.right > bounding.right) {
            moveX = rect.right - bounding.right + xMargin;
            if (side < 0 && rect.left < bounding.left + moveX)
              moveX = -(bounding.left + moveX - rect.left + xMargin);
          }
        } else {
          let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
          moveX = targetLeft - bounding.left;
        }
        if (moveX || moveY) {
          if (top2) {
            win.scrollBy(moveX, moveY);
          } else {
            let movedX = 0, movedY = 0;
            if (moveY) {
              let start2 = cur.scrollTop;
              cur.scrollTop += moveY / scaleY;
              movedY = (cur.scrollTop - start2) * scaleY;
            }
            if (moveX) {
              let start2 = cur.scrollLeft;
              cur.scrollLeft += moveX / scaleX;
              movedX = (cur.scrollLeft - start2) * scaleX;
            }
            rect = {
              left: rect.left - movedX,
              top: rect.top - movedY,
              right: rect.right - movedX,
              bottom: rect.bottom - movedY
            };
            if (movedX && Math.abs(movedX - moveX) < 1)
              x = "nearest";
            if (movedY && Math.abs(movedY - moveY) < 1)
              y2 = "nearest";
          }
        }
        if (top2)
          break;
        cur = cur.assignedSlot || cur.parentNode;
      } else if (cur.nodeType == 11) {
        cur = cur.host;
      } else {
        break;
      }
    }
  }
  function scrollableParent(dom) {
    let doc2 = dom.ownerDocument;
    for (let cur = dom.parentNode; cur; ) {
      if (cur == doc2.body) {
        break;
      } else if (cur.nodeType == 1) {
        if (cur.scrollHeight > cur.clientHeight || cur.scrollWidth > cur.clientWidth)
          return cur;
        cur = cur.assignedSlot || cur.parentNode;
      } else if (cur.nodeType == 11) {
        cur = cur.host;
      } else {
        break;
      }
    }
    return null;
  }
  var DOMSelectionState = class {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    eq(domSel) {
      return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range10) {
      let { anchorNode, focusNode } = range10;
      this.set(anchorNode, Math.min(range10.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range10.focusOffset, focusNode ? maxOffset(focusNode) : 0));
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
      this.anchorNode = anchorNode;
      this.anchorOffset = anchorOffset;
      this.focusNode = focusNode;
      this.focusOffset = focusOffset;
    }
  };
  var preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive)
      return dom.setActive();
    if (preventScrollSupported)
      return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur = dom; cur; cur = cur.parentNode) {
      stack.push(cur, cur.scrollTop, cur.scrollLeft);
      if (cur == cur.ownerDocument)
        break;
    }
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      for (let i = 0; i < stack.length; ) {
        let elt = stack[i++], top2 = stack[i++], left = stack[i++];
        if (elt.scrollTop != top2)
          elt.scrollTop = top2;
        if (elt.scrollLeft != left)
          elt.scrollLeft = left;
      }
    }
  }
  var scratchRange;
  function textRange(node, from17, to10 = from17) {
    let range10 = scratchRange || (scratchRange = document.createRange());
    range10.setEnd(node, to10);
    range10.setStart(node, from17);
    return range10;
  }
  function dispatchKey(elt, name2, code) {
    let options = { key: name2, code: name2, keyCode: code, which: code, cancelable: true };
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up2 = new KeyboardEvent("keyup", options);
    up2.synthetic = true;
    elt.dispatchEvent(up2);
    return down.defaultPrevented || up2.defaultPrevented;
  }
  function getRoot(node) {
    while (node) {
      if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
        return node;
      node = node.assignedSlot || node.parentNode;
    }
    return null;
  }
  function clearAttributes(node) {
    while (node.attributes.length)
      node.removeAttributeNode(node.attributes[0]);
  }
  function atElementStart(doc2, selection2) {
    let node = selection2.focusNode, offset = selection2.focusOffset;
    if (!node || selection2.anchorNode != node || selection2.anchorOffset != offset)
      return false;
    offset = Math.min(offset, maxOffset(node));
    for (; ; ) {
      if (offset) {
        if (node.nodeType != 1)
          return false;
        let prev = node.childNodes[offset - 1];
        if (prev.contentEditable == "false")
          offset--;
        else {
          node = prev;
          offset = maxOffset(node);
        }
      } else if (node == doc2) {
        return true;
      } else {
        offset = domIndex(node);
        node = node.parentNode;
      }
    }
  }
  function isScrolledToBottom(elt) {
    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
  }
  var DOMPos = class {
    constructor(node, offset, precise = true) {
      this.node = node;
      this.offset = offset;
      this.precise = precise;
    }
    static before(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom), precise);
    }
    static after(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
    }
  };
  var noChildren = [];
  var ContentView = class {
    constructor() {
      this.parent = null;
      this.dom = null;
      this.flags = 2;
    }
    get overrideDOMText() {
      return null;
    }
    get posAtStart() {
      return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
      return this.posAtStart + this.length;
    }
    posBefore(view) {
      let pos = this.posAtStart;
      for (let child of this.children) {
        if (child == view)
          return pos;
        pos += child.length + child.breakAfter;
      }
      throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
      return this.posBefore(view) + view.length;
    }
    sync(view, track) {
      if (this.flags & 2) {
        let parent = this.dom;
        let prev = null, next;
        for (let child of this.children) {
          if (child.flags & 7) {
            if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
              let contentView = ContentView.get(next);
              if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                child.reuseDOM(next);
            }
            child.sync(view, track);
            child.flags &= ~7;
          }
          next = prev ? prev.nextSibling : parent.firstChild;
          if (track && !track.written && track.node == parent && next != child.dom)
            track.written = true;
          if (child.dom.parentNode == parent) {
            while (next && next != child.dom)
              next = rm$1(next);
          } else {
            parent.insertBefore(child.dom, next);
          }
          prev = child.dom;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (next && track && track.node == parent)
          track.written = true;
        while (next)
          next = rm$1(next);
      } else if (this.flags & 1) {
        for (let child of this.children)
          if (child.flags & 7) {
            child.sync(view, track);
            child.flags &= ~7;
          }
      }
    }
    reuseDOM(_dom) {
    }
    localPosFromDOM(node, offset) {
      let after;
      if (node == this.dom) {
        after = this.dom.childNodes[offset];
      } else {
        let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
        for (; ; ) {
          let parent = node.parentNode;
          if (parent == this.dom)
            break;
          if (bias == 0 && parent.firstChild != parent.lastChild) {
            if (node == parent.firstChild)
              bias = -1;
            else
              bias = 1;
          }
          node = parent;
        }
        if (bias < 0)
          after = node;
        else
          after = node.nextSibling;
      }
      if (after == this.dom.firstChild)
        return 0;
      while (after && !ContentView.get(after))
        after = after.nextSibling;
      if (!after)
        return this.length;
      for (let i = 0, pos = 0; ; i++) {
        let child = this.children[i];
        if (child.dom == after)
          return pos;
        pos += child.length + child.breakAfter;
      }
    }
    domBoundsAround(from17, to10, offset = 0) {
      let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
      for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (pos < from17 && end > to10)
          return child.domBoundsAround(from17, to10, pos);
        if (end >= from17 && fromI == -1) {
          fromI = i;
          fromStart = pos;
        }
        if (pos > to10 && child.dom.parentNode == this.dom) {
          toI = i;
          toEnd = prevEnd;
          break;
        }
        prevEnd = end;
        pos = end + child.breakAfter;
      }
      return {
        from: fromStart,
        to: toEnd < 0 ? offset + this.length : toEnd,
        startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
        endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
      };
    }
    markDirty(andParent = false) {
      this.flags |= 2;
      this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
      for (let parent = this.parent; parent; parent = parent.parent) {
        if (childList)
          parent.flags |= 2;
        if (parent.flags & 1)
          return;
        parent.flags |= 1;
        childList = false;
      }
    }
    setParent(parent) {
      if (this.parent != parent) {
        this.parent = parent;
        if (this.flags & 7)
          this.markParentsDirty(true);
      }
    }
    setDOM(dom) {
      if (this.dom == dom)
        return;
      if (this.dom)
        this.dom.cmView = null;
      this.dom = dom;
      dom.cmView = this;
    }
    get rootView() {
      for (let v = this; ; ) {
        let parent = v.parent;
        if (!parent)
          return v;
        v = parent;
      }
    }
    replaceChildren(from17, to10, children = noChildren) {
      this.markDirty();
      for (let i = from17; i < to10; i++) {
        let child = this.children[i];
        if (child.parent == this && children.indexOf(child) < 0)
          child.destroy();
      }
      this.children.splice(from17, to10 - from17, ...children);
      for (let i = 0; i < children.length; i++)
        children[i].setParent(this);
    }
    ignoreMutation(_rec) {
      return false;
    }
    ignoreEvent(_event) {
      return false;
    }
    childCursor(pos = this.length) {
      return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
      return this.childCursor().findPos(pos, bias);
    }
    toString() {
      let name2 = this.constructor.name.replace("View", "");
      return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
    }
    static get(node) {
      return node.cmView;
    }
    get isEditable() {
      return true;
    }
    get isWidget() {
      return false;
    }
    get isHidden() {
      return false;
    }
    merge(from17, to10, source, hasStart, openStart, openEnd) {
      return false;
    }
    become(other) {
      return false;
    }
    canReuseDOM(other) {
      return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
    }
    getSide() {
      return 0;
    }
    destroy() {
      for (let child of this.children)
        child.destroy();
      this.parent = null;
    }
  };
  ContentView.prototype.breakAfter = 0;
  function rm$1(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  var ChildCursor = class {
    constructor(children, pos, i) {
      this.children = children;
      this.pos = pos;
      this.i = i;
      this.off = 0;
    }
    findPos(pos, bias = 1) {
      for (; ; ) {
        if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
          this.off = pos - this.pos;
          return this;
        }
        let next = this.children[--this.i];
        this.pos -= next.length + next.breakAfter;
      }
    }
  };
  function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
    let { children } = parent;
    let before = children.length ? children[fromI] : null;
    let last = insert2.length ? insert2[insert2.length - 1] : null;
    let breakAtEnd = last ? last.breakAfter : breakAtStart;
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last : null, fromOff == 0, openStart, openEnd))
      return;
    if (toI < children.length) {
      let after = children[toI];
      if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {
        if (fromI == toI) {
          after = after.split(toOff);
          toOff = 0;
        }
        if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
          insert2[insert2.length - 1] = after;
        } else {
          if (toOff || after.children.length && !after.children[0].length)
            after.merge(0, toOff, null, false, 0, openEnd);
          insert2.push(after);
        }
      } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
        if (last)
          last.breakAfter = 1;
        else
          breakAtStart = 1;
      }
      toI++;
    }
    if (before) {
      before.breakAfter = breakAtStart;
      if (fromOff > 0) {
        if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
          before.breakAfter = insert2.shift().breakAfter;
        } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
          before.merge(fromOff, before.length, null, false, openStart, 0);
        }
        fromI++;
      }
    }
    while (fromI < toI && insert2.length) {
      if (children[toI - 1].become(insert2[insert2.length - 1])) {
        toI--;
        insert2.pop();
        openEnd = insert2.length ? 0 : openStart;
      } else if (children[fromI].become(insert2[0])) {
        fromI++;
        insert2.shift();
        openStart = insert2.length ? 0 : openEnd;
      } else {
        break;
      }
    }
    if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
      fromI--;
    if (fromI < toI || insert2.length)
      parent.replaceChildren(fromI, toI, insert2);
  }
  function mergeChildrenInto(parent, from17, to10, insert2, openStart, openEnd) {
    let cur = parent.childCursor();
    let { i: toI, off: toOff } = cur.findPos(to10, 1);
    let { i: fromI, off: fromOff } = cur.findPos(from17, -1);
    let dLen = from17 - to10;
    for (let view of insert2)
      dLen += view.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
  }
  var nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
  var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
  var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
  var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
  var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
  var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
  var gecko = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
  var chrome = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
  var webkit = "webkitFontSmoothing" in doc.documentElement.style;
  var safari = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
  var ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
  var browser = {
    mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
    windows: /* @__PURE__ */ /Win/.test(nav.platform),
    linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
    ie: ie2,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko,
    gecko_version: gecko ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome,
    chrome_version: chrome ? +chrome[1] : 0,
    ios,
    android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
  };
  var MaxJoinLen = 256;
  var TextView = class extends ContentView {
    constructor(text) {
      super();
      this.text = text;
    }
    get length() {
      return this.text.length;
    }
    createDOM(textDOM) {
      this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(view, track) {
      if (!this.dom)
        this.createDOM();
      if (this.dom.nodeValue != this.text) {
        if (track && track.node == this.dom)
          track.written = true;
        this.dom.nodeValue = this.text;
      }
    }
    reuseDOM(dom) {
      if (dom.nodeType == 3)
        this.createDOM(dom);
    }
    merge(from17, to10, source) {
      if (this.flags & 8 || source && (!(source instanceof TextView) || this.length - (to10 - from17) + source.length > MaxJoinLen || source.flags & 8))
        return false;
      this.text = this.text.slice(0, from17) + (source ? source.text : "") + this.text.slice(to10);
      this.markDirty();
      return true;
    }
    split(from17) {
      let result = new TextView(this.text.slice(from17));
      this.text = this.text.slice(0, from17);
      this.markDirty();
      result.flags |= this.flags & 8;
      return result;
    }
    localPosFromDOM(node, offset) {
      return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) {
      return new DOMPos(this.dom, pos);
    }
    domBoundsAround(_from, _to, offset) {
      return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
      return textCoords(this.dom, pos, side);
    }
  };
  var MarkView = class extends ContentView {
    constructor(mark, children = [], length = 0) {
      super();
      this.mark = mark;
      this.children = children;
      this.length = length;
      for (let ch2 of children)
        ch2.setParent(this);
    }
    setAttrs(dom) {
      clearAttributes(dom);
      if (this.mark.class)
        dom.className = this.mark.class;
      if (this.mark.attrs)
        for (let name2 in this.mark.attrs)
          dom.setAttribute(name2, this.mark.attrs[name2]);
      return dom;
    }
    canReuseDOM(other) {
      return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
    }
    reuseDOM(node) {
      if (node.nodeName == this.mark.tagName.toUpperCase()) {
        this.setDOM(node);
        this.flags |= 4 | 2;
      }
    }
    sync(view, track) {
      if (!this.dom)
        this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
      else if (this.flags & 4)
        this.setAttrs(this.dom);
      super.sync(view, track);
    }
    merge(from17, to10, source, _hasStart, openStart, openEnd) {
      if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from17 && openStart <= 0 || to10 < this.length && openEnd <= 0))
        return false;
      mergeChildrenInto(this, from17, to10, source ? source.children : [], openStart - 1, openEnd - 1);
      this.markDirty();
      return true;
    }
    split(from17) {
      let result = [], off2 = 0, detachFrom = -1, i = 0;
      for (let elt of this.children) {
        let end = off2 + elt.length;
        if (end > from17)
          result.push(off2 < from17 ? elt.split(from17 - off2) : elt);
        if (detachFrom < 0 && off2 >= from17)
          detachFrom = i;
        off2 = end;
        i++;
      }
      let length = this.length - from17;
      this.length = from17;
      if (detachFrom > -1) {
        this.children.length = detachFrom;
        this.markDirty();
      }
      return new MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
  };
  function textCoords(text, pos, side) {
    let length = text.nodeValue.length;
    if (pos > length)
      pos = length;
    let from17 = pos, to10 = pos, flatten2 = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
      if (!(browser.chrome || browser.gecko)) {
        if (pos) {
          from17--;
          flatten2 = 1;
        } else if (to10 < length) {
          to10++;
          flatten2 = -1;
        }
      }
    } else {
      if (side < 0)
        from17--;
      else if (to10 < length)
        to10++;
    }
    let rects = textRange(text, from17, to10).getClientRects();
    if (!rects.length)
      return null;
    let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten2 && rect.width == 0)
      rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
    return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
  }
  var WidgetView = class extends ContentView {
    static create(widget, length, side) {
      return new WidgetView(widget, length, side);
    }
    constructor(widget, length, side) {
      super();
      this.widget = widget;
      this.length = length;
      this.side = side;
      this.prevWidget = null;
    }
    split(from17) {
      let result = WidgetView.create(this.widget, this.length - from17, this.side);
      this.length -= from17;
      return result;
    }
    sync(view) {
      if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(view));
        this.dom.contentEditable = "false";
      }
    }
    getSide() {
      return this.side;
    }
    merge(from17, to10, source, hasStart, openStart, openEnd) {
      if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from17 > 0 && openStart <= 0 || to10 < this.length && openEnd <= 0))
        return false;
      this.length = from17 + (source ? source.length : 0) + (this.length - to10);
      return true;
    }
    become(other) {
      if (other instanceof WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
        if (!this.widget.compare(other.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event2) {
      return this.widget.ignoreEvent(event2);
    }
    get overrideDOMText() {
      if (this.length == 0)
        return Text.empty;
      let top2 = this;
      while (top2.parent)
        top2 = top2.parent;
      let { view } = top2, text = view && view.state.doc, start2 = this.posAtStart;
      return text ? text.slice(start2, start2 + this.length) : Text.empty;
    }
    domAtPos(pos) {
      return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos, side) {
      let custom = this.widget.coordsAt(this.dom, pos, side);
      if (custom)
        return custom;
      let rects = this.dom.getClientRects(), rect = null;
      if (!rects.length)
        return null;
      let fromBack = this.side ? this.side < 0 : pos > 0;
      for (let i = fromBack ? rects.length - 1 : 0; ; i += fromBack ? -1 : 1) {
        rect = rects[i];
        if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
          break;
      }
      return flattenRect(rect, !fromBack);
    }
    get isEditable() {
      return false;
    }
    get isWidget() {
      return true;
    }
    get isHidden() {
      return this.widget.isHidden;
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var WidgetBufferView = class extends ContentView {
    constructor(side) {
      super();
      this.side = side;
    }
    get length() {
      return 0;
    }
    merge() {
      return false;
    }
    become(other) {
      return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() {
      return new WidgetBufferView(this.side);
    }
    sync() {
      if (!this.dom) {
        let dom = document.createElement("img");
        dom.className = "cm-widgetBuffer";
        dom.setAttribute("aria-hidden", "true");
        this.setDOM(dom);
      }
    }
    getSide() {
      return this.side;
    }
    domAtPos(pos) {
      return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
    }
    localPosFromDOM() {
      return 0;
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos) {
      return this.dom.getBoundingClientRect();
    }
    get overrideDOMText() {
      return Text.empty;
    }
    get isHidden() {
      return true;
    }
  };
  TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
  function inlineDOMAtPos(parent, pos) {
    let dom = parent.dom, { children } = parent, i = 0;
    for (let off2 = 0; i < children.length; i++) {
      let child = children[i], end = off2 + child.length;
      if (end == off2 && child.getSide() <= 0)
        continue;
      if (pos > off2 && pos < end && child.dom.parentNode == dom)
        return child.domAtPos(pos - off2);
      if (pos <= off2)
        break;
      off2 = end;
    }
    for (let j2 = i; j2 > 0; j2--) {
      let prev = children[j2 - 1];
      if (prev.dom.parentNode == dom)
        return prev.domAtPos(prev.length);
    }
    for (let j2 = i; j2 < children.length; j2++) {
      let next = children[j2];
      if (next.dom.parentNode == dom)
        return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
  }
  function joinInlineInto(parent, view, open) {
    let last, { children } = parent;
    if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
      joinInlineInto(last, view.children[0], open - 1);
    } else {
      children.push(view);
      view.setParent(parent);
    }
    parent.length += view.length;
  }
  function coordsInChildren(view, pos, side) {
    let before = null, beforePos = -1, after = null, afterPos = -1;
    function scan(view2, pos2) {
      for (let i = 0, off2 = 0; i < view2.children.length && off2 <= pos2; i++) {
        let child = view2.children[i], end = off2 + child.length;
        if (end >= pos2) {
          if (child.children.length) {
            scan(child, pos2 - off2);
          } else if ((!after || after.isHidden && side > 0) && (end > pos2 || off2 == end && child.getSide() > 0)) {
            after = child;
            afterPos = pos2 - off2;
          } else if (off2 < pos2 || off2 == end && child.getSide() < 0 && !child.isHidden) {
            before = child;
            beforePos = pos2 - off2;
          }
        }
        off2 = end;
      }
    }
    scan(view, pos);
    let target = (side < 0 ? before : after) || before || after;
    if (target)
      return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
    return fallbackRect(view);
  }
  function fallbackRect(view) {
    let last = view.dom.lastChild;
    if (!last)
      return view.dom.getBoundingClientRect();
    let rects = clientRectsFor(last);
    return rects[rects.length - 1] || null;
  }
  function combineAttrs(source, target) {
    for (let name2 in source) {
      if (name2 == "class" && target.class)
        target.class += " " + source.class;
      else if (name2 == "style" && target.style)
        target.style += ";" + source.style;
      else
        target[name2] = source[name2];
    }
    return target;
  }
  var noAttrs = /* @__PURE__ */ Object.create(null);
  function attrsEq(a, b, ignore) {
    if (a == b)
      return true;
    if (!a)
      a = noAttrs;
    if (!b)
      b = noAttrs;
    let keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
      return false;
    for (let key of keysA) {
      if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key]))
        return false;
    }
    return true;
  }
  function updateAttrs(dom, prev, attrs) {
    let changed = false;
    if (prev) {
      for (let name2 in prev)
        if (!(attrs && name2 in attrs)) {
          changed = true;
          if (name2 == "style")
            dom.style.cssText = "";
          else
            dom.removeAttribute(name2);
        }
    }
    if (attrs) {
      for (let name2 in attrs)
        if (!(prev && prev[name2] == attrs[name2])) {
          changed = true;
          if (name2 == "style")
            dom.style.cssText = attrs[name2];
          else
            dom.setAttribute(name2, attrs[name2]);
        }
    }
    return changed;
  }
  function getAttrs(dom) {
    let attrs = Object.create(null);
    for (let i = 0; i < dom.attributes.length; i++) {
      let attr = dom.attributes[i];
      attrs[attr.name] = attr.value;
    }
    return attrs;
  }
  var LineView = class extends ContentView {
    constructor() {
      super(...arguments);
      this.children = [];
      this.length = 0;
      this.prevAttrs = void 0;
      this.attrs = null;
      this.breakAfter = 0;
    }
    merge(from17, to10, source, hasStart, openStart, openEnd) {
      if (source) {
        if (!(source instanceof LineView))
          return false;
        if (!this.dom)
          source.transferDOM(this);
      }
      if (hasStart)
        this.setDeco(source ? source.attrs : null);
      mergeChildrenInto(this, from17, to10, source ? source.children : [], openStart, openEnd);
      return true;
    }
    split(at14) {
      let end = new LineView();
      end.breakAfter = this.breakAfter;
      if (this.length == 0)
        return end;
      let { i, off: off2 } = this.childPos(at14);
      if (off2) {
        end.append(this.children[i].split(off2), 0);
        this.children[i].merge(off2, this.children[i].length, null, false, 0, 0);
        i++;
      }
      for (let j2 = i; j2 < this.children.length; j2++)
        end.append(this.children[j2], 0);
      while (i > 0 && this.children[i - 1].length == 0)
        this.children[--i].destroy();
      this.children.length = i;
      this.markDirty();
      this.length = at14;
      return end;
    }
    transferDOM(other) {
      if (!this.dom)
        return;
      this.markDirty();
      other.setDOM(this.dom);
      other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
      this.prevAttrs = void 0;
      this.dom = null;
    }
    setDeco(attrs) {
      if (!attrsEq(this.attrs, attrs)) {
        if (this.dom) {
          this.prevAttrs = this.attrs;
          this.markDirty();
        }
        this.attrs = attrs;
      }
    }
    append(child, openStart) {
      joinInlineInto(this, child, openStart);
    }
    addLineDeco(deco) {
      let attrs = deco.spec.attributes, cls = deco.spec.class;
      if (attrs)
        this.attrs = combineAttrs(attrs, this.attrs || {});
      if (cls)
        this.attrs = combineAttrs({ class: cls }, this.attrs || {});
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node) {
      if (node.nodeName == "DIV") {
        this.setDOM(node);
        this.flags |= 4 | 2;
      }
    }
    sync(view, track) {
      var _a3;
      if (!this.dom) {
        this.setDOM(document.createElement("div"));
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      } else if (this.flags & 4) {
        clearAttributes(this.dom);
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      }
      if (this.prevAttrs !== void 0) {
        updateAttrs(this.dom, this.prevAttrs, this.attrs);
        this.dom.classList.add("cm-line");
        this.prevAttrs = void 0;
      }
      super.sync(view, track);
      let last = this.dom.lastChild;
      while (last && ContentView.get(last) instanceof MarkView)
        last = last.lastChild;
      if (!last || !this.length || last.nodeName != "BR" && ((_a3 = ContentView.get(last)) === null || _a3 === void 0 ? void 0 : _a3.isEditable) == false && (!browser.ios || !this.children.some((ch2) => ch2 instanceof TextView))) {
        let hack = document.createElement("BR");
        hack.cmIgnore = true;
        this.dom.appendChild(hack);
      }
    }
    measureTextSize() {
      if (this.children.length == 0 || this.length > 20)
        return null;
      let totalWidth = 0, textHeight;
      for (let child of this.children) {
        if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
          return null;
        let rects = clientRectsFor(child.dom);
        if (rects.length != 1)
          return null;
        totalWidth += rects[0].width;
        textHeight = rects[0].height;
      }
      return !totalWidth ? null : {
        lineHeight: this.dom.getBoundingClientRect().height,
        charWidth: totalWidth / this.length,
        textHeight
      };
    }
    coordsAt(pos, side) {
      let rect = coordsInChildren(this, pos, side);
      if (!this.children.length && rect && this.parent) {
        let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
        if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
          let dist2 = (height - heightOracle.textHeight) / 2;
          return { top: rect.top + dist2, bottom: rect.bottom - dist2, left: rect.left, right: rect.left };
        }
      }
      return rect;
    }
    become(_other) {
      return false;
    }
    covers() {
      return true;
    }
    static find(docView, pos) {
      for (let i = 0, off2 = 0; i < docView.children.length; i++) {
        let block = docView.children[i], end = off2 + block.length;
        if (end >= pos) {
          if (block instanceof LineView)
            return block;
          if (end > pos)
            break;
        }
        off2 = end + block.breakAfter;
      }
      return null;
    }
  };
  var BlockWidgetView = class extends ContentView {
    constructor(widget, length, deco) {
      super();
      this.widget = widget;
      this.length = length;
      this.deco = deco;
      this.breakAfter = 0;
      this.prevWidget = null;
    }
    merge(from17, to10, source, _takeDeco, openStart, openEnd) {
      if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from17 > 0 && openStart <= 0 || to10 < this.length && openEnd <= 0))
        return false;
      this.length = from17 + (source ? source.length : 0) + (this.length - to10);
      return true;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at14) {
      let len = this.length - at14;
      this.length = at14;
      let end = new BlockWidgetView(this.widget, len, this.deco);
      end.breakAfter = this.breakAfter;
      return end;
    }
    get children() {
      return noChildren;
    }
    sync(view) {
      if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(view));
        this.dom.contentEditable = "false";
      }
    }
    get overrideDOMText() {
      return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
    }
    domBoundsAround() {
      return null;
    }
    become(other) {
      if (other instanceof BlockWidgetView && other.widget.constructor == this.widget.constructor) {
        if (!other.widget.compare(this.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        this.deco = other.deco;
        this.breakAfter = other.breakAfter;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event2) {
      return this.widget.ignoreEvent(event2);
    }
    get isEditable() {
      return false;
    }
    get isWidget() {
      return true;
    }
    coordsAt(pos, side) {
      return this.widget.coordsAt(this.dom, pos, side);
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
    covers(side) {
      let { startSide, endSide } = this.deco;
      return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
    }
  };
  var WidgetType = class {
    eq(widget) {
      return false;
    }
    updateDOM(dom, view) {
      return false;
    }
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    get estimatedHeight() {
      return -1;
    }
    get lineBreaks() {
      return 0;
    }
    ignoreEvent(event2) {
      return true;
    }
    coordsAt(dom, pos, side) {
      return null;
    }
    get isHidden() {
      return false;
    }
    destroy(dom) {
    }
  };
  var BlockType = /* @__PURE__ */ function(BlockType2) {
    BlockType2[BlockType2["Text"] = 0] = "Text";
    BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
    BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
    BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
    return BlockType2;
  }(BlockType || (BlockType = {}));
  var Decoration = class extends RangeValue {
    constructor(startSide, endSide, widget, spec) {
      super();
      this.startSide = startSide;
      this.endSide = endSide;
      this.widget = widget;
      this.spec = spec;
    }
    get heightRelevant() {
      return false;
    }
    static mark(spec) {
      return new MarkDecoration(spec);
    }
    static widget(spec) {
      let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
      side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
      return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    static replace(spec) {
      let block = !!spec.block, startSide, endSide;
      if (spec.isBlockGap) {
        startSide = -5e8;
        endSide = 4e8;
      } else {
        let { start: start2, end } = getInclusive(spec, block);
        startSide = (start2 ? block ? -3e8 : -1 : 5e8) - 1;
        endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
      }
      return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    static line(spec) {
      return new LineDecoration(spec);
    }
    static set(of, sort2 = false) {
      return RangeSet.of(of, sort2);
    }
    hasHeight() {
      return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
  };
  Decoration.none = RangeSet.empty;
  var MarkDecoration = class extends Decoration {
    constructor(spec) {
      let { start: start2, end } = getInclusive(spec);
      super(start2 ? -1 : 5e8, end ? 1 : -6e8, null, spec);
      this.tagName = spec.tagName || "span";
      this.class = spec.class || "";
      this.attrs = spec.attributes || null;
    }
    eq(other) {
      var _a3, _b;
      return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && (this.class || ((_a3 = this.attrs) === null || _a3 === void 0 ? void 0 : _a3.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, "class");
    }
    range(from17, to10 = from17) {
      if (from17 >= to10)
        throw new RangeError("Mark decorations may not be empty");
      return super.range(from17, to10);
    }
  };
  MarkDecoration.prototype.point = false;
  var LineDecoration = class extends Decoration {
    constructor(spec) {
      super(-2e8, -2e8, null, spec);
    }
    eq(other) {
      return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from17, to10 = from17) {
      if (to10 != from17)
        throw new RangeError("Line decoration ranges must be zero-length");
      return super.range(from17, to10);
    }
  };
  LineDecoration.prototype.mapMode = MapMode.TrackBefore;
  LineDecoration.prototype.point = true;
  var PointDecoration = class extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
      super(startSide, endSide, widget, spec);
      this.block = block;
      this.isReplace = isReplace;
      this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
    }
    get type() {
      return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
      return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
    }
    eq(other) {
      return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from17, to10 = from17) {
      if (this.isReplace && (from17 > to10 || from17 == to10 && this.startSide > 0 && this.endSide <= 0))
        throw new RangeError("Invalid range for replacement decoration");
      if (!this.isReplace && to10 != from17)
        throw new RangeError("Widget decorations can only have zero-length ranges");
      return super.range(from17, to10);
    }
  };
  PointDecoration.prototype.point = true;
  function getInclusive(spec, block = false) {
    let { inclusiveStart: start2, inclusiveEnd: end } = spec;
    if (start2 == null)
      start2 = spec.inclusive;
    if (end == null)
      end = spec.inclusive;
    return { start: start2 !== null && start2 !== void 0 ? start2 : block, end: end !== null && end !== void 0 ? end : block };
  }
  function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
  }
  function addRange(from17, to10, ranges, margin = 0) {
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin >= from17)
      ranges[last] = Math.max(ranges[last], to10);
    else
      ranges.push(from17, to10);
  }
  var ContentBuilder = class {
    constructor(doc2, pos, end, disallowBlockEffectsFor) {
      this.doc = doc2;
      this.pos = pos;
      this.end = end;
      this.disallowBlockEffectsFor = disallowBlockEffectsFor;
      this.content = [];
      this.curLine = null;
      this.breakAtStart = 0;
      this.pendingBuffer = 0;
      this.bufferMarks = [];
      this.atCursorPos = true;
      this.openStart = -1;
      this.openEnd = -1;
      this.text = "";
      this.textOff = 0;
      this.cursor = doc2.iter();
      this.skip = pos;
    }
    posCovered() {
      if (this.content.length == 0)
        return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
      let last = this.content[this.content.length - 1];
      return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);
    }
    getLine() {
      if (!this.curLine) {
        this.content.push(this.curLine = new LineView());
        this.atCursorPos = true;
      }
      return this.curLine;
    }
    flushBuffer(active = this.bufferMarks) {
      if (this.pendingBuffer) {
        this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
        this.pendingBuffer = 0;
      }
    }
    addBlockWidget(view) {
      this.flushBuffer();
      this.curLine = null;
      this.content.push(view);
    }
    finish(openEnd) {
      if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
        this.flushBuffer();
      else
        this.pendingBuffer = 0;
      if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
        this.getLine();
    }
    buildText(length, active, openStart) {
      while (length > 0) {
        if (this.textOff == this.text.length) {
          let { value, lineBreak, done } = this.cursor.next(this.skip);
          this.skip = 0;
          if (done)
            throw new Error("Ran out of text content when drawing inline views");
          if (lineBreak) {
            if (!this.posCovered())
              this.getLine();
            if (this.content.length)
              this.content[this.content.length - 1].breakAfter = 1;
            else
              this.breakAtStart = 1;
            this.flushBuffer();
            this.curLine = null;
            this.atCursorPos = true;
            length--;
            continue;
          } else {
            this.text = value;
            this.textOff = 0;
          }
        }
        let take = Math.min(this.text.length - this.textOff, length, 512);
        this.flushBuffer(active.slice(active.length - openStart));
        this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
        this.atCursorPos = true;
        this.textOff += take;
        length -= take;
        openStart = 0;
      }
    }
    span(from17, to10, active, openStart) {
      this.buildText(to10 - from17, active, openStart);
      this.pos = to10;
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    point(from17, to10, deco, active, openStart, index3) {
      if (this.disallowBlockEffectsFor[index3] && deco instanceof PointDecoration) {
        if (deco.block)
          throw new RangeError("Block decorations may not be specified via plugins");
        if (to10 > this.doc.lineAt(this.pos).to)
          throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
      }
      let len = to10 - from17;
      if (deco instanceof PointDecoration) {
        if (deco.block) {
          if (deco.startSide > 0 && !this.posCovered())
            this.getLine();
          this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, deco));
        } else {
          let view = WidgetView.create(deco.widget || new NullWidget("span"), len, len ? 0 : deco.startSide);
          let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from17 < to10 || deco.startSide > 0);
          let cursorAfter = !view.isEditable && (from17 < to10 || openStart > active.length || deco.startSide <= 0);
          let line = this.getLine();
          if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable)
            this.pendingBuffer = 0;
          this.flushBuffer(active);
          if (cursorBefore) {
            line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
            openStart = active.length + Math.max(0, openStart - active.length);
          }
          line.append(wrapMarks(view, active), openStart);
          this.atCursorPos = cursorAfter;
          this.pendingBuffer = !cursorAfter ? 0 : from17 < to10 || openStart > active.length ? 1 : 2;
          if (this.pendingBuffer)
            this.bufferMarks = active.slice();
        }
      } else if (this.doc.lineAt(this.pos).from == this.pos) {
        this.getLine().addLineDeco(deco);
      }
      if (len) {
        if (this.textOff + len <= this.text.length) {
          this.textOff += len;
        } else {
          this.skip += len - (this.text.length - this.textOff);
          this.text = "";
          this.textOff = 0;
        }
        this.pos = to10;
      }
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    static build(text, from17, to10, decorations2, dynamicDecorationMap) {
      let builder = new ContentBuilder(text, from17, to10, dynamicDecorationMap);
      builder.openEnd = RangeSet.spans(decorations2, from17, to10, builder);
      if (builder.openStart < 0)
        builder.openStart = builder.openEnd;
      builder.finish(builder.openEnd);
      return builder;
    }
  };
  function wrapMarks(view, active) {
    for (let mark of active)
      view = new MarkView(mark, [view], view.length);
    return view;
  }
  var NullWidget = class extends WidgetType {
    constructor(tag) {
      super();
      this.tag = tag;
    }
    eq(other) {
      return other.tag == this.tag;
    }
    toDOM() {
      return document.createElement(this.tag);
    }
    updateDOM(elt) {
      return elt.nodeName.toLowerCase() == this.tag;
    }
    get isHidden() {
      return true;
    }
  };
  var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
  var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
  var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
  var exceptionSink = /* @__PURE__ */ Facet.define();
  var updateListener = /* @__PURE__ */ Facet.define();
  var inputHandler = /* @__PURE__ */ Facet.define();
  var focusChangeEffect = /* @__PURE__ */ Facet.define();
  var perLineTextDirection = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x) => x)
  });
  var nativeSelectionHidden = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x) => x)
  });
  var ScrollTarget = class {
    constructor(range10, y2 = "nearest", x = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
      this.range = range10;
      this.y = y2;
      this.x = x;
      this.yMargin = yMargin;
      this.xMargin = xMargin;
      this.isSnapshot = isSnapshot;
    }
    map(changes) {
      return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
    clip(state) {
      return this.range.to <= state.doc.length ? this : new ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
  };
  var scrollIntoView = /* @__PURE__ */ StateEffect.define({ map: (t2, ch2) => t2.map(ch2) });
  function logException(state, exception, context2) {
    let handler2 = state.facet(exceptionSink);
    if (handler2.length)
      handler2[0](exception);
    else if (window.onerror)
      window.onerror(String(exception), context2, void 0, void 0, exception);
    else if (context2)
      console.error(context2 + ":", exception);
    else
      console.error(exception);
  }
  var editable = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : true });
  var nextPluginID = 0;
  var viewPlugin = /* @__PURE__ */ Facet.define();
  var ViewPlugin = class {
    constructor(id2, create, domEventHandlers, domEventObservers, buildExtensions) {
      this.id = id2;
      this.create = create;
      this.domEventHandlers = domEventHandlers;
      this.domEventObservers = domEventObservers;
      this.extension = buildExtensions(this);
    }
    static define(create, spec) {
      const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
      return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, (plugin) => {
        let ext = [viewPlugin.of(plugin)];
        if (deco)
          ext.push(decorations.of((view) => {
            let pluginInst = view.plugin(plugin);
            return pluginInst ? deco(pluginInst) : Decoration.none;
          }));
        if (provide)
          ext.push(provide(plugin));
        return ext;
      });
    }
    static fromClass(cls, spec) {
      return ViewPlugin.define((view) => new cls(view), spec);
    }
  };
  var PluginInstance = class {
    constructor(spec) {
      this.spec = spec;
      this.mustUpdate = null;
      this.value = null;
    }
    update(view) {
      if (!this.value) {
        if (this.spec) {
          try {
            this.value = this.spec.create(view);
          } catch (e) {
            logException(view.state, e, "CodeMirror plugin crashed");
            this.deactivate();
          }
        }
      } else if (this.mustUpdate) {
        let update = this.mustUpdate;
        this.mustUpdate = null;
        if (this.value.update) {
          try {
            this.value.update(update);
          } catch (e) {
            logException(update.state, e, "CodeMirror plugin crashed");
            if (this.value.destroy)
              try {
                this.value.destroy();
              } catch (_) {
              }
            this.deactivate();
          }
        }
      }
      return this;
    }
    destroy(view) {
      var _a3;
      if ((_a3 = this.value) === null || _a3 === void 0 ? void 0 : _a3.destroy) {
        try {
          this.value.destroy();
        } catch (e) {
          logException(view.state, e, "CodeMirror plugin crashed");
        }
      }
    }
    deactivate() {
      this.spec = this.value = null;
    }
  };
  var editorAttributes = /* @__PURE__ */ Facet.define();
  var contentAttributes = /* @__PURE__ */ Facet.define();
  var decorations = /* @__PURE__ */ Facet.define();
  var atomicRanges = /* @__PURE__ */ Facet.define();
  var bidiIsolatedRanges = /* @__PURE__ */ Facet.define();
  function getIsolatedRanges(view, from17, to10) {
    let isolates = view.state.facet(bidiIsolatedRanges);
    if (!isolates.length)
      return isolates;
    let sets = isolates.map((i) => i instanceof Function ? i(view) : i);
    let result = [];
    RangeSet.spans(sets, from17, to10, {
      point() {
      },
      span(from18, to11, active, open) {
        let level3 = result;
        for (let i = active.length - 1; i >= 0; i--, open--) {
          let iso = active[i].spec.bidiIsolate, update;
          if (iso == null)
            continue;
          if (open > 0 && level3.length && (update = level3[level3.length - 1]).to == from18 && update.direction == iso) {
            update.to = to11;
            level3 = update.inner;
          } else {
            let add17 = { from: from18, to: to11, direction: iso, inner: [] };
            level3.push(add17);
            level3 = add17.inner;
          }
        }
      }
    });
    return result;
  }
  var scrollMargins = /* @__PURE__ */ Facet.define();
  function getScrollMargins(view) {
    let left = 0, right = 0, top2 = 0, bottom = 0;
    for (let source of view.state.facet(scrollMargins)) {
      let m = source(view);
      if (m) {
        if (m.left != null)
          left = Math.max(left, m.left);
        if (m.right != null)
          right = Math.max(right, m.right);
        if (m.top != null)
          top2 = Math.max(top2, m.top);
        if (m.bottom != null)
          bottom = Math.max(bottom, m.bottom);
      }
    }
    return { left, right, top: top2, bottom };
  }
  var styleModule = /* @__PURE__ */ Facet.define();
  var ChangedRange = class {
    constructor(fromA, toA, fromB, toB) {
      this.fromA = fromA;
      this.toA = toA;
      this.fromB = fromB;
      this.toB = toB;
    }
    join(other) {
      return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set2) {
      let i = set2.length, me2 = this;
      for (; i > 0; i--) {
        let range10 = set2[i - 1];
        if (range10.fromA > me2.toA)
          continue;
        if (range10.toA < me2.fromA)
          break;
        me2 = me2.join(range10);
        set2.splice(i - 1, 1);
      }
      set2.splice(i, 0, me2);
      return set2;
    }
    static extendWithRanges(diff, ranges) {
      if (ranges.length == 0)
        return diff;
      let result = [];
      for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
        let next = dI == diff.length ? null : diff[dI], off2 = posA - posB;
        let end = next ? next.fromB : 1e9;
        while (rI < ranges.length && ranges[rI] < end) {
          let from17 = ranges[rI], to10 = ranges[rI + 1];
          let fromB = Math.max(posB, from17), toB = Math.min(end, to10);
          if (fromB <= toB)
            new ChangedRange(fromB + off2, toB + off2, fromB, toB).addToSet(result);
          if (to10 > end)
            break;
          else
            rI += 2;
        }
        if (!next)
          return result;
        new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
        posA = next.toA;
        posB = next.toB;
      }
    }
  };
  var ViewUpdate = class {
    constructor(view, state, transactions) {
      this.view = view;
      this.state = state;
      this.transactions = transactions;
      this.flags = 0;
      this.startState = view.state;
      this.changes = ChangeSet.empty(this.startState.doc.length);
      for (let tr3 of transactions)
        this.changes = this.changes.compose(tr3.changes);
      let changedRanges = [];
      this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
      this.changedRanges = changedRanges;
    }
    static create(view, state, transactions) {
      return new ViewUpdate(view, state, transactions);
    }
    get viewportChanged() {
      return (this.flags & 4) > 0;
    }
    get heightChanged() {
      return (this.flags & 2) > 0;
    }
    get geometryChanged() {
      return this.docChanged || (this.flags & (8 | 2)) > 0;
    }
    get focusChanged() {
      return (this.flags & 1) > 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get selectionSet() {
      return this.transactions.some((tr3) => tr3.selection);
    }
    get empty() {
      return this.flags == 0 && this.transactions.length == 0;
    }
  };
  var Direction = /* @__PURE__ */ function(Direction2) {
    Direction2[Direction2["LTR"] = 0] = "LTR";
    Direction2[Direction2["RTL"] = 1] = "RTL";
    return Direction2;
  }(Direction || (Direction = {}));
  var LTR = Direction.LTR;
  var RTL = Direction.RTL;
  function dec(str) {
    let result = [];
    for (let i = 0; i < str.length; i++)
      result.push(1 << +str[i]);
    return result;
  }
  var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
  var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
  var Brackets = /* @__PURE__ */ Object.create(null);
  var BracketStack = [];
  for (let p of ["()", "[]", "{}"]) {
    let l = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
  }
  function charType(ch2) {
    return ch2 <= 247 ? LowTypes[ch2] : 1424 <= ch2 && ch2 <= 1524 ? 2 : 1536 <= ch2 && ch2 <= 1785 ? ArabicTypes[ch2 - 1536] : 1774 <= ch2 && ch2 <= 2220 ? 4 : 8192 <= ch2 && ch2 <= 8203 ? 256 : 64336 <= ch2 && ch2 <= 65023 ? 4 : ch2 == 8204 ? 256 : 1;
  }
  var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
  var BidiSpan = class {
    get dir() {
      return this.level % 2 ? RTL : LTR;
    }
    constructor(from17, to10, level3) {
      this.from = from17;
      this.to = to10;
      this.level = level3;
    }
    side(end, dir) {
      return this.dir == dir == end ? this.to : this.from;
    }
    static find(order, index3, level3, assoc) {
      let maybe = -1;
      for (let i = 0; i < order.length; i++) {
        let span = order[i];
        if (span.from <= index3 && span.to >= index3) {
          if (span.level == level3)
            return i;
          if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index3 : span.to > index3 : order[maybe].level > span.level))
            maybe = i;
        }
      }
      if (maybe < 0)
        throw new RangeError("Index out of range");
      return maybe;
    }
  };
  function isolatesEq(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      let iA = a[i], iB = b[i];
      if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
        return false;
    }
    return true;
  }
  var types = [];
  function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
    for (let iI = 0; iI <= isolates.length; iI++) {
      let from17 = iI ? isolates[iI - 1].to : rFrom, to10 = iI < isolates.length ? isolates[iI].from : rTo;
      let prevType = iI ? 256 : outerType;
      for (let i = from17, prev = prevType, prevStrong = prevType; i < to10; i++) {
        let type = charType(line.charCodeAt(i));
        if (type == 512)
          type = prev;
        else if (type == 8 && prevStrong == 4)
          type = 16;
        types[i] = type == 4 ? 2 : type;
        if (type & 7)
          prevStrong = type;
        prev = type;
      }
      for (let i = from17, prev = prevType, prevStrong = prevType; i < to10; i++) {
        let type = types[i];
        if (type == 128) {
          if (i < to10 - 1 && prev == types[i + 1] && prev & 24)
            type = types[i] = prev;
          else
            types[i] = 256;
        } else if (type == 64) {
          let end = i + 1;
          while (end < to10 && types[end] == 64)
            end++;
          let replace = i && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
          for (let j2 = i; j2 < end; j2++)
            types[j2] = replace;
          i = end - 1;
        } else if (type == 8 && prevStrong == 1) {
          types[i] = 1;
        }
        prev = type;
        if (type & 7)
          prevStrong = type;
      }
    }
  }
  function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
    let oppositeType = outerType == 1 ? 2 : 1;
    for (let iI = 0, sI = 0, context2 = 0; iI <= isolates.length; iI++) {
      let from17 = iI ? isolates[iI - 1].to : rFrom, to10 = iI < isolates.length ? isolates[iI].from : rTo;
      for (let i = from17, ch2, br, type; i < to10; i++) {
        if (br = Brackets[ch2 = line.charCodeAt(i)]) {
          if (br < 0) {
            for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
              if (BracketStack[sJ + 1] == -br) {
                let flags = BracketStack[sJ + 2];
                let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
                if (type2)
                  types[i] = types[BracketStack[sJ]] = type2;
                sI = sJ;
                break;
              }
            }
          } else if (BracketStack.length == 189) {
            break;
          } else {
            BracketStack[sI++] = i;
            BracketStack[sI++] = ch2;
            BracketStack[sI++] = context2;
          }
        } else if ((type = types[i]) == 2 || type == 1) {
          let embed = type == outerType;
          context2 = embed ? 0 : 1;
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            let cur = BracketStack[sJ + 2];
            if (cur & 2)
              break;
            if (embed) {
              BracketStack[sJ + 2] |= 2;
            } else {
              if (cur & 4)
                break;
              BracketStack[sJ + 2] |= 4;
            }
          }
        }
      }
    }
  }
  function processNeutrals(rFrom, rTo, isolates, outerType) {
    for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
      let from17 = iI ? isolates[iI - 1].to : rFrom, to10 = iI < isolates.length ? isolates[iI].from : rTo;
      for (let i = from17; i < to10; ) {
        let type = types[i];
        if (type == 256) {
          let end = i + 1;
          for (; ; ) {
            if (end == to10) {
              if (iI == isolates.length)
                break;
              end = isolates[iI++].to;
              to10 = iI < isolates.length ? isolates[iI].from : rTo;
            } else if (types[end] == 256) {
              end++;
            } else {
              break;
            }
          }
          let beforeL = prev == 1;
          let afterL = (end < rTo ? types[end] : outerType) == 1;
          let replace = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
          for (let j2 = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j2 > i; ) {
            if (j2 == fromJ) {
              j2 = isolates[--jI].from;
              fromJ = jI ? isolates[jI - 1].to : rFrom;
            }
            types[--j2] = replace;
          }
          i = end;
        } else {
          prev = type;
          i++;
        }
      }
    }
  }
  function emitSpans(line, from17, to10, level3, baseLevel, isolates, order) {
    let ourType = level3 % 2 ? 2 : 1;
    if (level3 % 2 == baseLevel % 2) {
      for (let iCh = from17, iI = 0; iCh < to10; ) {
        let sameDir = true, isNum = false;
        if (iI == isolates.length || iCh < isolates[iI].from) {
          let next = types[iCh];
          if (next != ourType) {
            sameDir = false;
            isNum = next == 16;
          }
        }
        let recurse = !sameDir && ourType == 1 ? [] : null;
        let localLevel = sameDir ? level3 : level3 + 1;
        let iScan = iCh;
        run:
          for (; ; ) {
            if (iI < isolates.length && iScan == isolates[iI].from) {
              if (isNum)
                break run;
              let iso = isolates[iI];
              if (!sameDir)
                for (let upto = iso.to, jI = iI + 1; ; ) {
                  if (upto == to10)
                    break run;
                  if (jI < isolates.length && isolates[jI].from == upto)
                    upto = isolates[jI++].to;
                  else if (types[upto] == ourType)
                    break run;
                  else
                    break;
                }
              iI++;
              if (recurse) {
                recurse.push(iso);
              } else {
                if (iso.from > iCh)
                  order.push(new BidiSpan(iCh, iso.from, localLevel));
                let dirSwap = iso.direction == LTR != !(localLevel % 2);
                computeSectionOrder(line, dirSwap ? level3 + 1 : level3, baseLevel, iso.inner, iso.from, iso.to, order);
                iCh = iso.to;
              }
              iScan = iso.to;
            } else if (iScan == to10 || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
              break;
            } else {
              iScan++;
            }
          }
        if (recurse)
          emitSpans(line, iCh, iScan, level3 + 1, baseLevel, recurse, order);
        else if (iCh < iScan)
          order.push(new BidiSpan(iCh, iScan, localLevel));
        iCh = iScan;
      }
    } else {
      for (let iCh = to10, iI = isolates.length; iCh > from17; ) {
        let sameDir = true, isNum = false;
        if (!iI || iCh > isolates[iI - 1].to) {
          let next = types[iCh - 1];
          if (next != ourType) {
            sameDir = false;
            isNum = next == 16;
          }
        }
        let recurse = !sameDir && ourType == 1 ? [] : null;
        let localLevel = sameDir ? level3 : level3 + 1;
        let iScan = iCh;
        run:
          for (; ; ) {
            if (iI && iScan == isolates[iI - 1].to) {
              if (isNum)
                break run;
              let iso = isolates[--iI];
              if (!sameDir)
                for (let upto = iso.from, jI = iI; ; ) {
                  if (upto == from17)
                    break run;
                  if (jI && isolates[jI - 1].to == upto)
                    upto = isolates[--jI].from;
                  else if (types[upto - 1] == ourType)
                    break run;
                  else
                    break;
                }
              if (recurse) {
                recurse.push(iso);
              } else {
                if (iso.to < iCh)
                  order.push(new BidiSpan(iso.to, iCh, localLevel));
                let dirSwap = iso.direction == LTR != !(localLevel % 2);
                computeSectionOrder(line, dirSwap ? level3 + 1 : level3, baseLevel, iso.inner, iso.from, iso.to, order);
                iCh = iso.from;
              }
              iScan = iso.from;
            } else if (iScan == from17 || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
              break;
            } else {
              iScan--;
            }
          }
        if (recurse)
          emitSpans(line, iScan, iCh, level3 + 1, baseLevel, recurse, order);
        else if (iScan < iCh)
          order.push(new BidiSpan(iScan, iCh, localLevel));
        iCh = iScan;
      }
    }
  }
  function computeSectionOrder(line, level3, baseLevel, isolates, from17, to10, order) {
    let outerType = level3 % 2 ? 2 : 1;
    computeCharTypes(line, from17, to10, isolates, outerType);
    processBracketPairs(line, from17, to10, isolates, outerType);
    processNeutrals(from17, to10, isolates, outerType);
    emitSpans(line, from17, to10, level3, baseLevel, isolates, order);
  }
  function computeOrder(line, direction, isolates) {
    if (!line)
      return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
    if (direction == LTR && !isolates.length && !BidiRE.test(line))
      return trivialOrder(line.length);
    if (isolates.length)
      while (line.length > types.length)
        types[types.length] = 256;
    let order = [], level3 = direction == LTR ? 0 : 1;
    computeSectionOrder(line, level3, level3, isolates, 0, line.length, order);
    return order;
  }
  function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
  }
  var movedOver = "";
  function moveVisually(line, order, dir, start2, forward18) {
    var _a3;
    let startIndex = start2.head - line.from, spanI = -1;
    if (startIndex == 0) {
      if (!forward18 || !line.length)
        return null;
      if (order[0].level != dir) {
        startIndex = order[0].side(false, dir);
        spanI = 0;
      }
    } else if (startIndex == line.length) {
      if (forward18)
        return null;
      let last = order[order.length - 1];
      if (last.level != dir) {
        startIndex = last.side(true, dir);
        spanI = order.length - 1;
      }
    }
    if (spanI < 0)
      spanI = BidiSpan.find(order, startIndex, (_a3 = start2.bidiLevel) !== null && _a3 !== void 0 ? _a3 : -1, start2.assoc);
    let span = order[spanI];
    if (startIndex == span.side(forward18, dir)) {
      span = order[spanI += forward18 ? 1 : -1];
      startIndex = span.side(!forward18, dir);
    }
    let indexForward = forward18 == (span.dir == dir);
    let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    if (nextIndex != span.side(forward18, dir))
      return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
    let nextSpan = spanI == (forward18 ? order.length - 1 : 0) ? null : order[spanI + (forward18 ? 1 : -1)];
    if (!nextSpan && span.level != dir)
      return EditorSelection.cursor(forward18 ? line.to : line.from, forward18 ? -1 : 1, dir);
    if (nextSpan && nextSpan.level < span.level)
      return EditorSelection.cursor(nextSpan.side(!forward18, dir) + line.from, forward18 ? 1 : -1, nextSpan.level);
    return EditorSelection.cursor(nextIndex + line.from, forward18 ? -1 : 1, span.level);
  }
  var DocView = class extends ContentView {
    get length() {
      return this.view.state.doc.length;
    }
    constructor(view) {
      super();
      this.view = view;
      this.decorations = [];
      this.dynamicDecorationMap = [];
      this.domChanged = null;
      this.hasComposition = null;
      this.markedForComposition = new Set();
      this.minWidth = 0;
      this.minWidthFrom = 0;
      this.minWidthTo = 0;
      this.impreciseAnchor = null;
      this.impreciseHead = null;
      this.forceSelection = false;
      this.lastUpdate = Date.now();
      this.setDOM(view.contentDOM);
      this.children = [new LineView()];
      this.children[0].setParent(this);
      this.updateDeco();
      this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
    }
    update(update) {
      var _a3;
      let changedRanges = update.changedRanges;
      if (this.minWidth > 0 && changedRanges.length) {
        if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
          this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
        } else {
          this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
          this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
        }
      }
      let readCompositionAt = -1;
      if (this.view.inputState.composing >= 0) {
        if ((_a3 = this.domChanged) === null || _a3 === void 0 ? void 0 : _a3.newSel)
          readCompositionAt = this.domChanged.newSel.head;
        else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
          readCompositionAt = update.state.selection.main.head;
      }
      let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
      this.domChanged = null;
      if (this.hasComposition) {
        this.markedForComposition.clear();
        let { from: from17, to: to10 } = this.hasComposition;
        changedRanges = new ChangedRange(from17, to10, update.changes.mapPos(from17, -1), update.changes.mapPos(to10, 1)).addToSet(changedRanges.slice());
      }
      this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
      if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines)
        this.forceSelection = true;
      let prevDeco = this.decorations, deco = this.updateDeco();
      let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
      if (!(this.flags & 7) && changedRanges.length == 0) {
        return false;
      } else {
        this.updateInner(changedRanges, update.startState.doc.length, composition);
        if (update.transactions.length)
          this.lastUpdate = Date.now();
        return true;
      }
    }
    updateInner(changes, oldLength, composition) {
      this.view.viewState.mustMeasureContent = true;
      this.updateChildren(changes, oldLength, composition);
      let { observer } = this.view;
      observer.ignore(() => {
        this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
        this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
        let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
        this.sync(this.view, track);
        this.flags &= ~7;
        if (track && (track.written || observer.selectionRange.focusNode != track.node))
          this.forceSelection = true;
        this.dom.style.height = "";
      });
      this.markedForComposition.forEach((cView) => cView.flags &= ~8);
      let gaps = [];
      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
        for (let child of this.children)
          if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
            gaps.push(child.dom);
      }
      observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength, composition) {
      let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
      let cursor = this.childCursor(oldLength);
      for (let i = ranges.length - 1; ; i--) {
        let next = i >= 0 ? ranges[i] : null;
        if (!next)
          break;
        let { fromA, toA, fromB, toB } = next, content2, breakAtStart, openStart, openEnd;
        if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
          let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
          let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
          breakAtStart = before.breakAtStart;
          openStart = before.openStart;
          openEnd = after.openEnd;
          let compLine = this.compositionView(composition);
          if (after.breakAtStart) {
            compLine.breakAfter = 1;
          } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
            compLine.breakAfter = after.content[0].breakAfter;
            after.content.shift();
          }
          if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
            before.content.pop();
          }
          content2 = before.content.concat(compLine).concat(after.content);
        } else {
          ({ content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
        }
        let { i: toI, off: toOff } = cursor.findPos(toA, 1);
        let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
        replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
      }
      if (composition)
        this.fixCompositionDOM(composition);
    }
    compositionView(composition) {
      let cur = new TextView(composition.text.nodeValue);
      cur.flags |= 8;
      for (let { deco } of composition.marks)
        cur = new MarkView(deco, [cur], cur.length);
      let line = new LineView();
      line.append(cur, 0);
      return line;
    }
    fixCompositionDOM(composition) {
      let fix = (dom, cView2) => {
        cView2.flags |= 8 | (cView2.children.some((c2) => c2.flags & 7) ? 1 : 0);
        this.markedForComposition.add(cView2);
        let prev = ContentView.get(dom);
        if (prev && prev != cView2)
          prev.dom = null;
        cView2.setDOM(dom);
      };
      let pos = this.childPos(composition.range.fromB, 1);
      let cView = this.children[pos.i];
      fix(composition.line, cView);
      for (let i = composition.marks.length - 1; i >= -1; i--) {
        pos = cView.childPos(pos.off, 1);
        cView = cView.children[pos.i];
        fix(i >= 0 ? composition.marks[i].node : composition.text, cView);
      }
    }
    updateSelection(mustRead = false, fromPointer = false) {
      if (mustRead || !this.view.observer.selectionRange.focusNode)
        this.view.observer.readSelectionRange();
      let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
      let selectionNotFocus = !focused && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
      if (!(focused || fromPointer || selectionNotFocus))
        return;
      let force = this.forceSelection;
      this.forceSelection = false;
      let main = this.view.state.selection.main;
      let anchor = this.moveToLine(this.domAtPos(main.anchor));
      let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
      if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
        let dummy = document.createTextNode("");
        this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
        anchor = head = new DOMPos(dummy, 0);
        force = true;
      }
      let domSel = this.view.observer.selectionRange;
      if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
        this.view.observer.ignore(() => {
          if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
            this.dom.blur();
            this.dom.focus({ preventScroll: true });
          }
          let rawSel = getSelection(this.view.root);
          if (!rawSel)
            ;
          else if (main.empty) {
            if (browser.gecko) {
              let nextTo = nextToUneditable(anchor.node, anchor.offset);
              if (nextTo && nextTo != (1 | 2)) {
                let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
                if (text)
                  anchor = new DOMPos(text.node, text.offset);
              }
            }
            rawSel.collapse(anchor.node, anchor.offset);
            if (main.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
              rawSel.caretBidiLevel = main.bidiLevel;
          } else if (rawSel.extend) {
            rawSel.collapse(anchor.node, anchor.offset);
            try {
              rawSel.extend(head.node, head.offset);
            } catch (_) {
            }
          } else {
            let range10 = document.createRange();
            if (main.anchor > main.head)
              [anchor, head] = [head, anchor];
            range10.setEnd(head.node, head.offset);
            range10.setStart(anchor.node, anchor.offset);
            rawSel.removeAllRanges();
            rawSel.addRange(range10);
          }
          if (selectionNotFocus && this.view.root.activeElement == this.dom) {
            this.dom.blur();
            if (activeElt)
              activeElt.focus();
          }
        });
        this.view.observer.setSelectionRange(anchor, head);
      }
      this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
      this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    enforceCursorAssoc() {
      if (this.hasComposition)
        return;
      let { view } = this, cursor = view.state.selection.main;
      let sel = getSelection(view.root);
      let { anchorNode, anchorOffset } = view.observer.selectionRange;
      if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
        return;
      let line = LineView.find(this, cursor.head);
      if (!line)
        return;
      let lineStart = line.posAtStart;
      if (cursor.head == lineStart || cursor.head == lineStart + line.length)
        return;
      let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
      if (!before || !after || before.bottom > after.top)
        return;
      let dom = this.domAtPos(cursor.head + cursor.assoc);
      sel.collapse(dom.node, dom.offset);
      sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
      view.observer.readSelectionRange();
      let newRange = view.observer.selectionRange;
      if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
        sel.collapse(anchorNode, anchorOffset);
    }
    moveToLine(pos) {
      let dom = this.dom, newPos;
      if (pos.node != dom)
        return pos;
      for (let i = pos.offset; !newPos && i < dom.childNodes.length; i++) {
        let view = ContentView.get(dom.childNodes[i]);
        if (view instanceof LineView)
          newPos = view.domAtPos(0);
      }
      for (let i = pos.offset - 1; !newPos && i >= 0; i--) {
        let view = ContentView.get(dom.childNodes[i]);
        if (view instanceof LineView)
          newPos = view.domAtPos(view.length);
      }
      return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
    }
    nearest(dom) {
      for (let cur = dom; cur; ) {
        let domView = ContentView.get(cur);
        if (domView && domView.rootView == this)
          return domView;
        cur = cur.parentNode;
      }
      return null;
    }
    posFromDOM(node, offset) {
      let view = this.nearest(node);
      if (!view)
        throw new RangeError("Trying to find position for a DOM position outside of the document");
      return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
      let { i, off: off2 } = this.childCursor().findPos(pos, -1);
      for (; i < this.children.length - 1; ) {
        let child = this.children[i];
        if (off2 < child.length || child instanceof LineView)
          break;
        i++;
        off2 = 0;
      }
      return this.children[i].domAtPos(off2);
    }
    coordsAt(pos, side) {
      let best = null, bestPos = 0;
      for (let off2 = this.length, i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i], end = off2 - child.breakAfter, start2 = end - child.length;
        if (end < pos)
          break;
        if (start2 <= pos && (start2 < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
          best = child;
          bestPos = start2;
        }
        off2 = start2;
      }
      return best ? best.coordsAt(pos - bestPos, side) : null;
    }
    coordsForChar(pos) {
      let { i, off: off2 } = this.childPos(pos, 1), child = this.children[i];
      if (!(child instanceof LineView))
        return null;
      while (child.children.length) {
        let { i: i2, off: childOff } = child.childPos(off2, 1);
        for (; ; i2++) {
          if (i2 == child.children.length)
            return null;
          if ((child = child.children[i2]).length)
            break;
        }
        off2 = childOff;
      }
      if (!(child instanceof TextView))
        return null;
      let end = findClusterBreak(child.text, off2);
      if (end == off2)
        return null;
      let rects = textRange(child.dom, off2, end).getClientRects();
      for (let i2 = 0; i2 < rects.length; i2++) {
        let rect = rects[i2];
        if (i2 == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
          return rect;
      }
      return null;
    }
    measureVisibleLineHeights(viewport) {
      let result = [], { from: from17, to: to10 } = viewport;
      let contentWidth = this.view.contentDOM.clientWidth;
      let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
      let widest = -1, ltr = this.view.textDirection == Direction.LTR;
      for (let pos = 0, i = 0; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (end > to10)
          break;
        if (pos >= from17) {
          let childRect = child.dom.getBoundingClientRect();
          result.push(childRect.height);
          if (isWider) {
            let last = child.dom.lastChild;
            let rects = last ? clientRectsFor(last) : [];
            if (rects.length) {
              let rect = rects[rects.length - 1];
              let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
              if (width > widest) {
                widest = width;
                this.minWidth = contentWidth;
                this.minWidthFrom = pos;
                this.minWidthTo = end;
              }
            }
          }
        }
        pos = end + child.breakAfter;
      }
      return result;
    }
    textDirectionAt(pos) {
      let { i } = this.childPos(pos, 1);
      return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
      for (let child of this.children) {
        if (child instanceof LineView) {
          let measure = child.measureTextSize();
          if (measure)
            return measure;
        }
      }
      let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
      dummy.className = "cm-line";
      dummy.style.width = "99999px";
      dummy.style.position = "absolute";
      dummy.textContent = "abc def ghi jkl mno pqr stu";
      this.view.observer.ignore(() => {
        this.dom.appendChild(dummy);
        let rect = clientRectsFor(dummy.firstChild)[0];
        lineHeight = dummy.getBoundingClientRect().height;
        charWidth = rect ? rect.width / 27 : 7;
        textHeight = rect ? rect.height : lineHeight;
        dummy.remove();
      });
      return { lineHeight, charWidth, textHeight };
    }
    childCursor(pos = this.length) {
      let i = this.children.length;
      if (i)
        pos -= this.children[--i].length;
      return new ChildCursor(this.children, pos, i);
    }
    computeBlockGapDeco() {
      let deco = [], vs2 = this.view.viewState;
      for (let pos = 0, i = 0; ; i++) {
        let next = i == vs2.viewports.length ? null : vs2.viewports[i];
        let end = next ? next.from - 1 : this.length;
        if (end > pos) {
          let height = (vs2.lineBlockAt(end).bottom - vs2.lineBlockAt(pos).top) / this.view.scaleY;
          deco.push(Decoration.replace({
            widget: new BlockGapWidget(height),
            block: true,
            inclusive: true,
            isBlockGap: true
          }).range(pos, end));
        }
        if (!next)
          break;
        pos = next.to + 1;
      }
      return Decoration.set(deco);
    }
    updateDeco() {
      let allDeco = this.view.state.facet(decorations).map((d2, i) => {
        let dynamic = this.dynamicDecorationMap[i] = typeof d2 == "function";
        return dynamic ? d2(this.view) : d2;
      });
      for (let i = allDeco.length; i < allDeco.length + 3; i++)
        this.dynamicDecorationMap[i] = false;
      return this.decorations = [
        ...allDeco,
        this.computeBlockGapDeco(),
        this.view.viewState.lineGapDeco
      ];
    }
    scrollIntoView(target) {
      if (target.isSnapshot) {
        let ref = this.view.viewState.lineBlockAt(target.range.head);
        this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
        this.view.scrollDOM.scrollLeft = target.xMargin;
        return;
      }
      let { range: range10 } = target;
      let rect = this.coordsAt(range10.head, range10.empty ? range10.assoc : range10.head > range10.anchor ? -1 : 1), other;
      if (!rect)
        return;
      if (!range10.empty && (other = this.coordsAt(range10.anchor, range10.anchor > range10.head ? -1 : 1)))
        rect = {
          left: Math.min(rect.left, other.left),
          top: Math.min(rect.top, other.top),
          right: Math.max(rect.right, other.right),
          bottom: Math.max(rect.bottom, other.bottom)
        };
      let margins = getScrollMargins(this.view);
      let targetRect = {
        left: rect.left - margins.left,
        top: rect.top - margins.top,
        right: rect.right + margins.right,
        bottom: rect.bottom + margins.bottom
      };
      let { offsetWidth, offsetHeight } = this.view.scrollDOM;
      scrollRectIntoView(this.view.scrollDOM, targetRect, range10.head < range10.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
    }
  };
  function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
  }
  var BlockGapWidget = class extends WidgetType {
    constructor(height) {
      super();
      this.height = height;
    }
    toDOM() {
      let elt = document.createElement("div");
      this.updateDOM(elt);
      return elt;
    }
    eq(other) {
      return other.height == this.height;
    }
    updateDOM(elt) {
      elt.style.height = this.height + "px";
      return true;
    }
    get estimatedHeight() {
      return this.height;
    }
  };
  function findCompositionNode(view, headPos) {
    let sel = view.observer.selectionRange;
    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
    if (!textNode)
      return null;
    let from17 = headPos - textNode.offset;
    return { from: from17, to: from17 + textNode.node.nodeValue.length, node: textNode.node };
  }
  function findCompositionRange(view, changes, headPos) {
    let found = findCompositionNode(view, headPos);
    if (!found)
      return null;
    let { node: textNode, from: from17, to: to10 } = found, text = textNode.nodeValue;
    if (/[\n\r]/.test(text))
      return null;
    if (view.state.doc.sliceString(found.from, found.to) != text)
      return null;
    let inv = changes.invertedDesc;
    let range10 = new ChangedRange(inv.mapPos(from17), inv.mapPos(to10), from17, to10);
    let marks = [];
    for (let parent = textNode.parentNode; ; parent = parent.parentNode) {
      let parentView = ContentView.get(parent);
      if (parentView instanceof MarkView)
        marks.push({ node: parent, deco: parentView.mark });
      else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
        return { range: range10, text: textNode, marks, line: parent };
      else if (parent != view.contentDOM)
        marks.push({ node: parent, deco: new MarkDecoration({
          inclusive: true,
          attributes: getAttrs(parent),
          tagName: parent.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
  function nearbyTextNode(startNode, startOffset, side) {
    if (side <= 0)
      for (let node = startNode, offset = startOffset; ; ) {
        if (node.nodeType == 3)
          return { node, offset };
        if (node.nodeType == 1 && offset > 0) {
          node = node.childNodes[offset - 1];
          offset = maxOffset(node);
        } else {
          break;
        }
      }
    if (side >= 0)
      for (let node = startNode, offset = startOffset; ; ) {
        if (node.nodeType == 3)
          return { node, offset };
        if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
          node = node.childNodes[offset];
          offset = 0;
        } else {
          break;
        }
      }
    return null;
  }
  function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
      return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
  }
  var DecorationComparator$1 = class DecorationComparator {
    constructor() {
      this.changes = [];
    }
    compareRange(from17, to10) {
      addRange(from17, to10, this.changes);
    }
    comparePoint(from17, to10) {
      addRange(from17, to10, this.changes);
    }
  };
  function findChangedDeco(a, b, diff) {
    let comp = new DecorationComparator$1();
    RangeSet.compare(a, b, diff, comp);
    return comp.changes;
  }
  function inUneditable(node, inside2) {
    for (let cur = node; cur && cur != inside2; cur = cur.assignedSlot || cur.parentNode) {
      if (cur.nodeType == 1 && cur.contentEditable == "false") {
        return true;
      }
    }
    return false;
  }
  function touchesComposition(changes, composition) {
    let touched = false;
    if (composition)
      changes.iterChangedRanges((from17, to10) => {
        if (from17 < composition.to && to10 > composition.from)
          touched = true;
      });
    return touched;
  }
  function groupAt(state, pos, bias = 1) {
    let categorize = state.charCategorizer(pos);
    let line = state.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
      return EditorSelection.cursor(pos);
    if (linePos == 0)
      bias = 1;
    else if (linePos == line.length)
      bias = -1;
    let from17 = linePos, to10 = linePos;
    if (bias < 0)
      from17 = findClusterBreak(line.text, linePos, false);
    else
      to10 = findClusterBreak(line.text, linePos);
    let cat = categorize(line.text.slice(from17, to10));
    while (from17 > 0) {
      let prev = findClusterBreak(line.text, from17, false);
      if (categorize(line.text.slice(prev, from17)) != cat)
        break;
      from17 = prev;
    }
    while (to10 < line.length) {
      let next = findClusterBreak(line.text, to10);
      if (categorize(line.text.slice(to10, next)) != cat)
        break;
      to10 = next;
    }
    return EditorSelection.range(from17 + line.from, to10 + line.from);
  }
  function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
  }
  function getdy(y2, rect) {
    return rect.top > y2 ? rect.top - y2 : Math.max(0, y2 - rect.bottom);
  }
  function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
  }
  function upTop(rect, top2) {
    return top2 < rect.top ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
  }
  function upBot(rect, bottom) {
    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
  }
  function domPosAtCoords(parent, x, y2) {
    let closest2, closestRect, closestX, closestY, closestOverlap = false;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
      let rects = clientRectsFor(child);
      for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (closestRect && yOverlap(closestRect, rect))
          rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
        let dx = getdx(x, rect), dy = getdy(y2, rect);
        if (dx == 0 && dy == 0)
          return child.nodeType == 3 ? domPosInText(child, x, y2) : domPosAtCoords(child, x, y2);
        if (!closest2 || closestY > dy || closestY == dy && closestX > dx) {
          closest2 = child;
          closestRect = rect;
          closestX = dx;
          closestY = dy;
          let side = dy ? y2 < rect.top ? -1 : 1 : dx ? x < rect.left ? -1 : 1 : 0;
          closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);
        }
        if (dx == 0) {
          if (y2 > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
            above = child;
            aboveRect = rect;
          } else if (y2 < rect.top && (!belowRect || belowRect.top > rect.top)) {
            below = child;
            belowRect = rect;
          }
        } else if (aboveRect && yOverlap(aboveRect, rect)) {
          aboveRect = upBot(aboveRect, rect.bottom);
        } else if (belowRect && yOverlap(belowRect, rect)) {
          belowRect = upTop(belowRect, rect.top);
        }
      }
    }
    if (aboveRect && aboveRect.bottom >= y2) {
      closest2 = above;
      closestRect = aboveRect;
    } else if (belowRect && belowRect.top <= y2) {
      closest2 = below;
      closestRect = belowRect;
    }
    if (!closest2)
      return { node: parent, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest2.nodeType == 3)
      return domPosInText(closest2, clipX, y2);
    if (closestOverlap && closest2.contentEditable != "false")
      return domPosAtCoords(closest2, clipX, y2);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest2) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent, offset };
  }
  function domPosInText(node, x, y2) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i = 0; i < len; i++) {
      let rects = textRange(node, i, i + 1).getClientRects();
      for (let j2 = 0; j2 < rects.length; j2++) {
        let rect = rects[j2];
        if (rect.top == rect.bottom)
          continue;
        if (!generalSide)
          generalSide = x - rect.left;
        let dy = (rect.top > y2 ? rect.top - y2 : y2 - rect.bottom) - 1;
        if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
          let right = x >= (rect.left + rect.right) / 2, after = right;
          if (browser.chrome || browser.gecko) {
            let rectBefore = textRange(node, i).getBoundingClientRect();
            if (rectBefore.left == rect.right)
              after = !right;
          }
          if (dy <= 0)
            return { node, offset: i + (after ? 1 : 0) };
          closestOffset = i + (after ? 1 : 0);
          closestDY = dy;
        }
      }
    }
    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
  }
  function posAtCoords(view, coords, precise, bias = -1) {
    var _a3, _b;
    let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
    let block, { docHeight } = view.viewState;
    let { x, y: y2 } = coords, yOffset = y2 - docTop;
    if (yOffset < 0)
      return 0;
    if (yOffset > docHeight)
      return view.state.doc.length;
    for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
      block = view.elementAtHeight(yOffset);
      if (block.type == BlockType.Text)
        break;
      for (; ; ) {
        yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
        if (yOffset >= 0 && yOffset <= docHeight)
          break;
        if (bounced)
          return precise ? null : 0;
        bounced = true;
        bias = -bias;
      }
    }
    y2 = docTop + yOffset;
    let lineStart = block.from;
    if (lineStart < view.viewport.from)
      return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x, y2);
    if (lineStart > view.viewport.to)
      return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x, y2);
    let doc2 = view.dom.ownerDocument;
    let root = view.root.elementFromPoint ? view.root : doc2;
    let element = root.elementFromPoint(x, y2);
    if (element && !view.contentDOM.contains(element))
      element = null;
    if (!element) {
      x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
      element = root.elementFromPoint(x, y2);
      if (element && !view.contentDOM.contains(element))
        element = null;
    }
    let node, offset = -1;
    if (element && ((_a3 = view.docView.nearest(element)) === null || _a3 === void 0 ? void 0 : _a3.isEditable) != false) {
      if (doc2.caretPositionFromPoint) {
        let pos = doc2.caretPositionFromPoint(x, y2);
        if (pos)
          ({ offsetNode: node, offset } = pos);
      } else if (doc2.caretRangeFromPoint) {
        let range10 = doc2.caretRangeFromPoint(x, y2);
        if (range10) {
          ({ startContainer: node, startOffset: offset } = range10);
          if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
            node = void 0;
        }
      }
    }
    if (!node || !view.docView.dom.contains(node)) {
      let line = LineView.find(view.docView, lineStart);
      if (!line)
        return yOffset > block.top + block.height / 2 ? block.to : block.from;
      ({ node, offset } = domPosAtCoords(line.dom, x, y2));
    }
    let nearest = view.docView.nearest(node);
    if (!nearest)
      return null;
    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
      let rect = nearest.dom.getBoundingClientRect();
      return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
    } else {
      return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
    }
  }
  function posAtCoordsImprecise(view, contentRect, block, x, y2) {
    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
      let textHeight = view.viewState.heightOracle.textHeight;
      let line = Math.floor((y2 - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
      into += line * view.viewState.heightOracle.lineLength;
    }
    let content2 = view.state.sliceDoc(block.from, block.to);
    return block.from + findColumn(content2, into, view.state.tabSize);
  }
  function isSuspiciousSafariCaretResult(node, offset, x) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
      return false;
    for (let next = node.nextSibling; next; next = next.nextSibling)
      if (next.nodeType != 1 || next.nodeName != "BR")
        return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x;
  }
  function isSuspiciousChromeCaretResult(node, offset, x) {
    if (offset != 0)
      return false;
    for (let cur = node; ; ) {
      let parent = cur.parentNode;
      if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
        return false;
      if (parent.classList.contains("cm-line"))
        break;
      cur = parent;
    }
    let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x - rect.left > 5;
  }
  function blockAt(view, pos) {
    let line = view.lineBlockAt(pos);
    if (Array.isArray(line.type))
      for (let l of line.type) {
        if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
          return l;
      }
    return line;
  }
  function moveToLineBoundary(view, start2, forward18, includeWrap) {
    let line = blockAt(view, start2.head);
    let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start2.assoc < 0 && start2.head > line.from ? start2.head - 1 : start2.head);
    if (coords) {
      let editorRect = view.dom.getBoundingClientRect();
      let direction = view.textDirectionAt(line.from);
      let pos = view.posAtCoords({
        x: forward18 == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
        y: (coords.top + coords.bottom) / 2
      });
      if (pos != null)
        return EditorSelection.cursor(pos, forward18 ? -1 : 1);
    }
    return EditorSelection.cursor(forward18 ? line.to : line.from, forward18 ? -1 : 1);
  }
  function moveByChar(view, start2, forward18, by) {
    let line = view.state.doc.lineAt(start2.head), spans = view.bidiSpans(line);
    let direction = view.textDirectionAt(line.from);
    for (let cur = start2, check = null; ; ) {
      let next = moveVisually(line, spans, direction, cur, forward18), char = movedOver;
      if (!next) {
        if (line.number == (forward18 ? view.state.doc.lines : 1))
          return cur;
        char = "\n";
        line = view.state.doc.line(line.number + (forward18 ? 1 : -1));
        spans = view.bidiSpans(line);
        next = EditorSelection.cursor(forward18 ? line.from : line.to);
      }
      if (!check) {
        if (!by)
          return next;
        check = by(char);
      } else if (!check(char)) {
        return cur;
      }
      cur = next;
    }
  }
  function byGroup(view, pos, start2) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start2);
    return (next) => {
      let nextCat = categorize(next);
      if (cat == CharCategory.Space)
        cat = nextCat;
      return cat == nextCat;
    };
  }
  function moveVertically(view, start2, forward18, distance) {
    let startPos = start2.head, dir = forward18 ? 1 : -1;
    if (startPos == (forward18 ? view.state.doc.length : 0))
      return EditorSelection.cursor(startPos, start2.assoc);
    let goal = start2.goalColumn, startY;
    let rect = view.contentDOM.getBoundingClientRect();
    let startCoords = view.coordsAtPos(startPos, start2.assoc || -1), docTop = view.documentTop;
    if (startCoords) {
      if (goal == null)
        goal = startCoords.left - rect.left;
      startY = dir < 0 ? startCoords.top : startCoords.bottom;
    } else {
      let line = view.viewState.lineBlockAt(startPos);
      if (goal == null)
        goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
      startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
    for (let extra = 0; ; extra += 10) {
      let curY = startY + (dist2 + extra) * dir;
      let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
      if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
        let charRect = view.docView.coordsForChar(pos);
        let assoc = !charRect || curY < charRect.top ? -1 : 1;
        return EditorSelection.cursor(pos, assoc, void 0, goal);
      }
    }
  }
  function skipAtomicRanges(atoms, pos, bias) {
    for (; ; ) {
      let moved2 = 0;
      for (let set2 of atoms) {
        set2.between(pos - 1, pos + 1, (from17, to10, value) => {
          if (pos > from17 && pos < to10) {
            let side = moved2 || bias || (pos - from17 < to10 - pos ? -1 : 1);
            pos = side < 0 ? from17 : to10;
            moved2 = side;
          }
        });
      }
      if (!moved2)
        return pos;
    }
  }
  function skipAtoms(view, oldPos, pos) {
    let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f) => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
    return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
  }
  var InputState = class {
    setSelectionOrigin(origin) {
      this.lastSelectionOrigin = origin;
      this.lastSelectionTime = Date.now();
    }
    constructor(view) {
      this.view = view;
      this.lastKeyCode = 0;
      this.lastKeyTime = 0;
      this.lastTouchTime = 0;
      this.lastFocusTime = 0;
      this.lastScrollTop = 0;
      this.lastScrollLeft = 0;
      this.pendingIOSKey = void 0;
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastEscPress = 0;
      this.lastContextMenu = 0;
      this.scrollHandlers = [];
      this.handlers = Object.create(null);
      this.composing = -1;
      this.compositionFirstChange = null;
      this.compositionEndedAt = 0;
      this.compositionPendingKey = false;
      this.compositionPendingChange = false;
      this.mouseSelection = null;
      this.draggedContent = null;
      this.handleEvent = this.handleEvent.bind(this);
      this.notifiedFocused = view.hasFocus;
      if (browser.safari)
        view.contentDOM.addEventListener("input", () => null);
      if (browser.gecko)
        firefoxCopyCutHack(view.contentDOM.ownerDocument);
    }
    handleEvent(event2) {
      if (!eventBelongsToEditor(this.view, event2) || this.ignoreDuringComposition(event2))
        return;
      if (event2.type == "keydown" && this.keydown(event2))
        return;
      this.runHandlers(event2.type, event2);
    }
    runHandlers(type, event2) {
      let handlers2 = this.handlers[type];
      if (handlers2) {
        for (let observer of handlers2.observers)
          observer(this.view, event2);
        for (let handler2 of handlers2.handlers) {
          if (event2.defaultPrevented)
            break;
          if (handler2(this.view, event2)) {
            event2.preventDefault();
            break;
          }
        }
      }
    }
    ensureHandlers(plugins3) {
      let handlers2 = computeHandlers(plugins3), prev = this.handlers, dom = this.view.contentDOM;
      for (let type in handlers2)
        if (type != "scroll") {
          let passive = !handlers2[type].handlers.length;
          let exists = prev[type];
          if (exists && passive != !exists.handlers.length) {
            dom.removeEventListener(type, this.handleEvent);
            exists = null;
          }
          if (!exists)
            dom.addEventListener(type, this.handleEvent, { passive });
        }
      for (let type in prev)
        if (type != "scroll" && !handlers2[type])
          dom.removeEventListener(type, this.handleEvent);
      this.handlers = handlers2;
    }
    keydown(event2) {
      this.lastKeyCode = event2.keyCode;
      this.lastKeyTime = Date.now();
      if (event2.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
        return true;
      if (event2.keyCode != 27 && modifierCodes.indexOf(event2.keyCode) < 0)
        this.view.inputState.lastEscPress = 0;
      if (browser.android && browser.chrome && !event2.synthetic && (event2.keyCode == 13 || event2.keyCode == 8)) {
        this.view.observer.delayAndroidKey(event2.key, event2.keyCode);
        return true;
      }
      let pending;
      if (browser.ios && !event2.synthetic && !event2.altKey && !event2.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event2.keyCode)) && !event2.ctrlKey || EmacsyPendingKeys.indexOf(event2.key) > -1 && event2.ctrlKey && !event2.shiftKey)) {
        this.pendingIOSKey = pending || event2;
        setTimeout(() => this.flushIOSKey(), 250);
        return true;
      }
      if (event2.keyCode != 229)
        this.view.observer.forceFlush();
      return false;
    }
    flushIOSKey() {
      let key = this.pendingIOSKey;
      if (!key)
        return false;
      this.pendingIOSKey = void 0;
      return dispatchKey(this.view.contentDOM, key.key, key.keyCode);
    }
    ignoreDuringComposition(event2) {
      if (!/^key/.test(event2.type))
        return false;
      if (this.composing > 0)
        return true;
      if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
        this.compositionPendingKey = false;
        return true;
      }
      return false;
    }
    startMouseSelection(mouseSelection) {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
      this.mouseSelection = mouseSelection;
    }
    update(update) {
      if (this.mouseSelection)
        this.mouseSelection.update(update);
      if (this.draggedContent && update.docChanged)
        this.draggedContent = this.draggedContent.map(update.changes);
      if (update.transactions.length)
        this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
    }
  };
  function bindHandler(plugin, handler2) {
    return (view, event2) => {
      try {
        return handler2.call(plugin, event2, view);
      } catch (e) {
        logException(view.state, e);
      }
    };
  }
  function computeHandlers(plugins3) {
    let result = Object.create(null);
    function record(type) {
      return result[type] || (result[type] = { observers: [], handlers: [] });
    }
    for (let plugin of plugins3) {
      let spec = plugin.spec;
      if (spec && spec.domEventHandlers)
        for (let type in spec.domEventHandlers) {
          let f = spec.domEventHandlers[type];
          if (f)
            record(type).handlers.push(bindHandler(plugin.value, f));
        }
      if (spec && spec.domEventObservers)
        for (let type in spec.domEventObservers) {
          let f = spec.domEventObservers[type];
          if (f)
            record(type).observers.push(bindHandler(plugin.value, f));
        }
    }
    for (let type in handlers)
      record(type).handlers.push(handlers[type]);
    for (let type in observers)
      record(type).observers.push(observers[type]);
    return result;
  }
  var PendingKeys = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
  ];
  var EmacsyPendingKeys = "dthko";
  var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
  var dragScrollMargin = 6;
  function dragScrollSpeed(dist2) {
    return Math.max(0, dist2) * 0.7 + 8;
  }
  function dist(a, b) {
    return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
  }
  var MouseSelection = class {
    constructor(view, startEvent, style, mustSelect) {
      this.view = view;
      this.startEvent = startEvent;
      this.style = style;
      this.mustSelect = mustSelect;
      this.scrollSpeed = { x: 0, y: 0 };
      this.scrolling = -1;
      this.lastEvent = startEvent;
      this.scrollParent = scrollableParent(view.contentDOM);
      this.atoms = view.state.facet(atomicRanges).map((f) => f(view));
      let doc2 = view.contentDOM.ownerDocument;
      doc2.addEventListener("mousemove", this.move = this.move.bind(this));
      doc2.addEventListener("mouseup", this.up = this.up.bind(this));
      this.extend = startEvent.shiftKey;
      this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
      this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
    }
    start(event2) {
      if (this.dragging === false)
        this.select(event2);
    }
    move(event2) {
      var _a3;
      if (event2.buttons == 0)
        return this.destroy();
      if (this.dragging || this.dragging == null && dist(this.startEvent, event2) < 10)
        return;
      this.select(this.lastEvent = event2);
      let sx = 0, sy = 0;
      let rect = ((_a3 = this.scrollParent) === null || _a3 === void 0 ? void 0 : _a3.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight };
      let margins = getScrollMargins(this.view);
      if (event2.clientX - margins.left <= rect.left + dragScrollMargin)
        sx = -dragScrollSpeed(rect.left - event2.clientX);
      else if (event2.clientX + margins.right >= rect.right - dragScrollMargin)
        sx = dragScrollSpeed(event2.clientX - rect.right);
      if (event2.clientY - margins.top <= rect.top + dragScrollMargin)
        sy = -dragScrollSpeed(rect.top - event2.clientY);
      else if (event2.clientY + margins.bottom >= rect.bottom - dragScrollMargin)
        sy = dragScrollSpeed(event2.clientY - rect.bottom);
      this.setScrollSpeed(sx, sy);
    }
    up(event2) {
      if (this.dragging == null)
        this.select(this.lastEvent);
      if (!this.dragging)
        event2.preventDefault();
      this.destroy();
    }
    destroy() {
      this.setScrollSpeed(0, 0);
      let doc2 = this.view.contentDOM.ownerDocument;
      doc2.removeEventListener("mousemove", this.move);
      doc2.removeEventListener("mouseup", this.up);
      this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
    }
    setScrollSpeed(sx, sy) {
      this.scrollSpeed = { x: sx, y: sy };
      if (sx || sy) {
        if (this.scrolling < 0)
          this.scrolling = setInterval(() => this.scroll(), 50);
      } else if (this.scrolling > -1) {
        clearInterval(this.scrolling);
        this.scrolling = -1;
      }
    }
    scroll() {
      if (this.scrollParent) {
        this.scrollParent.scrollLeft += this.scrollSpeed.x;
        this.scrollParent.scrollTop += this.scrollSpeed.y;
      } else {
        this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);
      }
      if (this.dragging === false)
        this.select(this.lastEvent);
    }
    skipAtoms(sel) {
      let ranges = null;
      for (let i = 0; i < sel.ranges.length; i++) {
        let range10 = sel.ranges[i], updated = null;
        if (range10.empty) {
          let pos = skipAtomicRanges(this.atoms, range10.from, 0);
          if (pos != range10.from)
            updated = EditorSelection.cursor(pos, -1);
        } else {
          let from17 = skipAtomicRanges(this.atoms, range10.from, -1);
          let to10 = skipAtomicRanges(this.atoms, range10.to, 1);
          if (from17 != range10.from || to10 != range10.to)
            updated = EditorSelection.range(range10.from == range10.anchor ? from17 : to10, range10.from == range10.head ? from17 : to10);
        }
        if (updated) {
          if (!ranges)
            ranges = sel.ranges.slice();
          ranges[i] = updated;
        }
      }
      return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
    }
    select(event2) {
      let { view } = this, selection2 = this.skipAtoms(this.style.get(event2, this.extend, this.multiple));
      if (this.mustSelect || !selection2.eq(view.state.selection) || selection2.main.assoc != view.state.selection.main.assoc && this.dragging === false)
        this.view.dispatch({
          selection: selection2,
          userEvent: "select.pointer"
        });
      this.mustSelect = false;
    }
    update(update) {
      if (this.style.update(update))
        setTimeout(() => this.select(this.lastEvent), 20);
    }
  };
  function addsSelectionRange(view, event2) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event2) : browser.mac ? event2.metaKey : event2.ctrlKey;
  }
  function dragMovesSelection(view, event2) {
    let facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event2) : browser.mac ? !event2.altKey : !event2.ctrlKey;
  }
  function isInPrimarySelection(view, event2) {
    let { main } = view.state.selection;
    if (main.empty)
      return false;
    let sel = getSelection(view.root);
    if (!sel || sel.rangeCount == 0)
      return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.left <= event2.clientX && rect.right >= event2.clientX && rect.top <= event2.clientY && rect.bottom >= event2.clientY)
        return true;
    }
    return false;
  }
  function eventBelongsToEditor(view, event2) {
    if (!event2.bubbles)
      return true;
    if (event2.defaultPrevented)
      return false;
    for (let node = event2.target, cView; node != view.contentDOM; node = node.parentNode)
      if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event2))
        return false;
    return true;
  }
  var handlers = /* @__PURE__ */ Object.create(null);
  var observers = /* @__PURE__ */ Object.create(null);
  var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
  function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
      view.focus();
      target.remove();
      doPaste(view, target.value);
    }, 50);
  }
  function doPaste(view, input2) {
    let { state } = view, changes, i = 1, text = state.toText(input2);
    let byLine = text.lines == state.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text.toString();
    if (linewise) {
      let lastLine = -1;
      changes = state.changeByRange((range10) => {
        let line = state.doc.lineAt(range10.from);
        if (line.from == lastLine)
          return { range: range10 };
        lastLine = line.from;
        let insert2 = state.toText((byLine ? text.line(i++).text : input2) + state.lineBreak);
        return {
          changes: { from: line.from, insert: insert2 },
          range: EditorSelection.cursor(range10.from + insert2.length)
        };
      });
    } else if (byLine) {
      changes = state.changeByRange((range10) => {
        let line = text.line(i++);
        return {
          changes: { from: range10.from, to: range10.to, insert: line.text },
          range: EditorSelection.cursor(range10.from + line.length)
        };
      });
    } else {
      changes = state.replaceSelection(text);
    }
    view.dispatch(changes, {
      userEvent: "input.paste",
      scrollIntoView: true
    });
  }
  observers.scroll = (view) => {
    view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
    view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
  };
  handlers.keydown = (view, event2) => {
    view.inputState.setSelectionOrigin("select");
    if (event2.keyCode == 27)
      view.inputState.lastEscPress = Date.now();
    return false;
  };
  observers.touchstart = (view, e) => {
    view.inputState.lastTouchTime = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
  };
  observers.touchmove = (view) => {
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlers.mousedown = (view, event2) => {
    view.observer.flush();
    if (view.inputState.lastTouchTime > Date.now() - 2e3)
      return false;
    let style = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
      style = makeStyle(view, event2);
      if (style)
        break;
    }
    if (!style && event2.button == 0)
      style = basicMouseSelection(view, event2);
    if (style) {
      let mustFocus = !view.hasFocus;
      view.inputState.startMouseSelection(new MouseSelection(view, event2, style, mustFocus));
      if (mustFocus)
        view.observer.ignore(() => focusPreventScroll(view.contentDOM));
      let mouseSel = view.inputState.mouseSelection;
      if (mouseSel) {
        mouseSel.start(event2);
        return mouseSel.dragging === false;
      }
    }
    return false;
  };
  function rangeForClick(view, pos, bias, type) {
    if (type == 1) {
      return EditorSelection.cursor(pos, bias);
    } else if (type == 2) {
      return groupAt(view.state, pos, bias);
    } else {
      let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
      let from17 = visual ? visual.posAtStart : line.from, to10 = visual ? visual.posAtEnd : line.to;
      if (to10 < view.state.doc.length && to10 == line.to)
        to10++;
      return EditorSelection.range(from17, to10);
    }
  }
  var insideY = (y2, rect) => y2 >= rect.top && y2 <= rect.bottom;
  var inside = (x, y2, rect) => insideY(y2, rect) && x >= rect.left && x <= rect.right;
  function findPositionSide(view, pos, x, y2) {
    let line = LineView.find(view.docView, pos);
    if (!line)
      return 1;
    let off2 = pos - line.posAtStart;
    if (off2 == 0)
      return 1;
    if (off2 == line.length)
      return -1;
    let before = line.coordsAt(off2, -1);
    if (before && inside(x, y2, before))
      return -1;
    let after = line.coordsAt(off2, 1);
    if (after && inside(x, y2, after))
      return 1;
    return before && insideY(y2, before) ? -1 : 1;
  }
  function queryPos(view, event2) {
    let pos = view.posAtCoords({ x: event2.clientX, y: event2.clientY }, false);
    return { pos, bias: findPositionSide(view, pos, event2.clientX, event2.clientY) };
  }
  var BadMouseDetail = browser.ie && browser.ie_version <= 11;
  var lastMouseDown = null;
  var lastMouseDownCount = 0;
  var lastMouseDownTime = 0;
  function getClickType(event2) {
    if (!BadMouseDetail)
      return event2.detail;
    let last = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event2;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event2.clientX) < 2 && Math.abs(last.clientY - event2.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
  }
  function basicMouseSelection(view, event2) {
    let start2 = queryPos(view, event2), type = getClickType(event2);
    let startSel = view.state.selection;
    return {
      update(update) {
        if (update.docChanged) {
          start2.pos = update.changes.mapPos(start2.pos);
          startSel = startSel.map(update.changes);
        }
      },
      get(event3, extend3, multiple) {
        let cur = queryPos(view, event3), removed;
        let range10 = rangeForClick(view, cur.pos, cur.bias, type);
        if (start2.pos != cur.pos && !extend3) {
          let startRange = rangeForClick(view, start2.pos, start2.bias, type);
          let from17 = Math.min(startRange.from, range10.from), to10 = Math.max(startRange.to, range10.to);
          range10 = from17 < range10.from ? EditorSelection.range(from17, to10) : EditorSelection.range(to10, from17);
        }
        if (extend3)
          return startSel.replaceRange(startSel.main.extend(range10.from, range10.to));
        else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos)))
          return removed;
        else if (multiple)
          return startSel.addRange(range10);
        else
          return EditorSelection.create([range10]);
      }
    };
  }
  function removeRangeAround(sel, pos) {
    for (let i = 0; i < sel.ranges.length; i++) {
      let { from: from17, to: to10 } = sel.ranges[i];
      if (from17 <= pos && to10 >= pos)
        return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
    }
    return null;
  }
  handlers.dragstart = (view, event2) => {
    let { selection: { main: range10 } } = view.state;
    if (event2.target.draggable) {
      let cView = view.docView.nearest(event2.target);
      if (cView && cView.isWidget) {
        let from17 = cView.posAtStart, to10 = from17 + cView.length;
        if (from17 >= range10.to || to10 <= range10.from)
          range10 = EditorSelection.range(from17, to10);
      }
    }
    let { inputState } = view;
    if (inputState.mouseSelection)
      inputState.mouseSelection.dragging = true;
    inputState.draggedContent = range10;
    if (event2.dataTransfer) {
      event2.dataTransfer.setData("Text", view.state.sliceDoc(range10.from, range10.to));
      event2.dataTransfer.effectAllowed = "copyMove";
    }
    return false;
  };
  handlers.dragend = (view) => {
    view.inputState.draggedContent = null;
    return false;
  };
  function dropText(view, event2, text, direct) {
    if (!text)
      return;
    let dropPos = view.posAtCoords({ x: event2.clientX, y: event2.clientY }, false);
    let { draggedContent } = view.inputState;
    let del = direct && draggedContent && dragMovesSelection(view, event2) ? { from: draggedContent.from, to: draggedContent.to } : null;
    let ins14 = { from: dropPos, insert: text };
    let changes = view.state.changes(del ? [del, ins14] : ins14);
    view.focus();
    view.dispatch({
      changes,
      selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
      userEvent: del ? "move.drop" : "input.drop"
    });
    view.inputState.draggedContent = null;
  }
  handlers.drop = (view, event2) => {
    if (!event2.dataTransfer)
      return false;
    if (view.state.readOnly)
      return true;
    let files = event2.dataTransfer.files;
    if (files && files.length) {
      let text = Array(files.length), read = 0;
      let finishFile = () => {
        if (++read == files.length)
          dropText(view, event2, text.filter((s) => s != null).join(view.state.lineBreak), false);
      };
      for (let i = 0; i < files.length; i++) {
        let reader = new FileReader();
        reader.onerror = finishFile;
        reader.onload = () => {
          if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
            text[i] = reader.result;
          finishFile();
        };
        reader.readAsText(files[i]);
      }
      return true;
    } else {
      let text = event2.dataTransfer.getData("Text");
      if (text) {
        dropText(view, event2, text, true);
        return true;
      }
    }
    return false;
  };
  handlers.paste = (view, event2) => {
    if (view.state.readOnly)
      return true;
    view.observer.flush();
    let data = brokenClipboardAPI ? null : event2.clipboardData;
    if (data) {
      doPaste(view, data.getData("text/plain") || data.getData("text/uri-text"));
      return true;
    } else {
      capturePaste(view);
      return false;
    }
  };
  function captureCopy(view, text) {
    let parent = view.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(() => {
      target.remove();
      view.focus();
    }, 50);
  }
  function copiedRange(state) {
    let content2 = [], ranges = [], linewise = false;
    for (let range10 of state.selection.ranges)
      if (!range10.empty) {
        content2.push(state.sliceDoc(range10.from, range10.to));
        ranges.push(range10);
      }
    if (!content2.length) {
      let upto = -1;
      for (let { from: from17 } of state.selection.ranges) {
        let line = state.doc.lineAt(from17);
        if (line.number > upto) {
          content2.push(line.text);
          ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
        }
        upto = line.number;
      }
      linewise = true;
    }
    return { text: content2.join(state.lineBreak), ranges, linewise };
  }
  var lastLinewiseCopy = null;
  handlers.copy = handlers.cut = (view, event2) => {
    let { text, ranges, linewise } = copiedRange(view.state);
    if (!text && !linewise)
      return false;
    lastLinewiseCopy = linewise ? text : null;
    if (event2.type == "cut" && !view.state.readOnly)
      view.dispatch({
        changes: ranges,
        scrollIntoView: true,
        userEvent: "delete.cut"
      });
    let data = brokenClipboardAPI ? null : event2.clipboardData;
    if (data) {
      data.clearData();
      data.setData("text/plain", text);
      return true;
    } else {
      captureCopy(view, text);
      return false;
    }
  };
  var isFocusChange = /* @__PURE__ */ Annotation.define();
  function focusChangeTransaction(state, focus) {
    let effects2 = [];
    for (let getEffect of state.facet(focusChangeEffect)) {
      let effect = getEffect(state, focus);
      if (effect)
        effects2.push(effect);
    }
    return effects2 ? state.update({ effects: effects2, annotations: isFocusChange.of(true) }) : null;
  }
  function updateForFocusChange(view) {
    setTimeout(() => {
      let focus = view.hasFocus;
      if (focus != view.inputState.notifiedFocused) {
        let tr3 = focusChangeTransaction(view.state, focus);
        if (tr3)
          view.dispatch(tr3);
        else
          view.update([]);
      }
    }, 10);
  }
  observers.focus = (view) => {
    view.inputState.lastFocusTime = Date.now();
    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
      view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
      view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
    }
    updateForFocusChange(view);
  };
  observers.blur = (view) => {
    view.observer.clearSelectionRange();
    updateForFocusChange(view);
  };
  observers.compositionstart = observers.compositionupdate = (view) => {
    if (view.inputState.compositionFirstChange == null)
      view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
      view.inputState.composing = 0;
    }
  };
  observers.compositionend = (view) => {
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionPendingKey = true;
    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
    view.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android) {
      view.observer.flushSoon();
    } else if (view.inputState.compositionPendingChange) {
      Promise.resolve().then(() => view.observer.flush());
    } else {
      setTimeout(() => {
        if (view.inputState.composing < 0 && view.docView.hasComposition)
          view.update([]);
      }, 50);
    }
  };
  observers.contextmenu = (view) => {
    view.inputState.lastContextMenu = Date.now();
  };
  handlers.beforeinput = (view, event2) => {
    var _a3;
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event2.inputType))) {
      view.observer.delayAndroidKey(pending.key, pending.keyCode);
      if (pending.key == "Backspace" || pending.key == "Delete") {
        let startViewHeight = ((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0;
        setTimeout(() => {
          var _a4;
          if ((((_a4 = window.visualViewport) === null || _a4 === void 0 ? void 0 : _a4.height) || 0) > startViewHeight + 10 && view.hasFocus) {
            view.contentDOM.blur();
            view.focus();
          }
        }, 100);
      }
    }
    return false;
  };
  var appliedFirefoxHack = /* @__PURE__ */ new Set();
  function firefoxCopyCutHack(doc2) {
    if (!appliedFirefoxHack.has(doc2)) {
      appliedFirefoxHack.add(doc2);
      doc2.addEventListener("copy", () => {
      });
      doc2.addEventListener("cut", () => {
      });
    }
  }
  var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
  var HeightOracle = class {
    constructor(lineWrapping) {
      this.lineWrapping = lineWrapping;
      this.doc = Text.empty;
      this.heightSamples = {};
      this.lineHeight = 14;
      this.charWidth = 7;
      this.textHeight = 14;
      this.lineLength = 30;
      this.heightChanged = false;
    }
    heightForGap(from17, to10) {
      let lines = this.doc.lineAt(to10).number - this.doc.lineAt(from17).number + 1;
      if (this.lineWrapping)
        lines += Math.max(0, Math.ceil((to10 - from17 - lines * this.lineLength * 0.5) / this.lineLength));
      return this.lineHeight * lines;
    }
    heightForLine(length) {
      if (!this.lineWrapping)
        return this.lineHeight;
      let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
      return lines * this.lineHeight;
    }
    setDoc(doc2) {
      this.doc = doc2;
      return this;
    }
    mustRefreshForWrapping(whiteSpace) {
      return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
      let newHeight = false;
      for (let i = 0; i < lineHeights.length; i++) {
        let h3 = lineHeights[i];
        if (h3 < 0) {
          i++;
        } else if (!this.heightSamples[Math.floor(h3 * 10)]) {
          newHeight = true;
          this.heightSamples[Math.floor(h3 * 10)] = true;
        }
      }
      return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
      let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
      let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
      this.lineWrapping = lineWrapping;
      this.lineHeight = lineHeight;
      this.charWidth = charWidth;
      this.textHeight = textHeight;
      this.lineLength = lineLength;
      if (changed) {
        this.heightSamples = {};
        for (let i = 0; i < knownHeights.length; i++) {
          let h3 = knownHeights[i];
          if (h3 < 0)
            i++;
          else
            this.heightSamples[Math.floor(h3 * 10)] = true;
        }
      }
      return changed;
    }
  };
  var MeasuredHeights = class {
    constructor(from17, heights) {
      this.from = from17;
      this.heights = heights;
      this.index = 0;
    }
    get more() {
      return this.index < this.heights.length;
    }
  };
  var BlockInfo = class {
    constructor(from17, length, top2, height, _content) {
      this.from = from17;
      this.length = length;
      this.top = top2;
      this.height = height;
      this._content = _content;
    }
    get type() {
      return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
    }
    get to() {
      return this.from + this.length;
    }
    get bottom() {
      return this.top + this.height;
    }
    get widget() {
      return this._content instanceof PointDecoration ? this._content.widget : null;
    }
    get widgetLineBreaks() {
      return typeof this._content == "number" ? this._content : 0;
    }
    join(other) {
      let content2 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
      return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content2);
    }
  };
  var QueryType = /* @__PURE__ */ function(QueryType3) {
    QueryType3[QueryType3["ByPos"] = 0] = "ByPos";
    QueryType3[QueryType3["ByHeight"] = 1] = "ByHeight";
    QueryType3[QueryType3["ByPosNoHeight"] = 2] = "ByPosNoHeight";
    return QueryType3;
  }(QueryType || (QueryType = {}));
  var Epsilon = 1e-3;
  var HeightMap = class {
    constructor(length, height, flags = 2) {
      this.length = length;
      this.height = height;
      this.flags = flags;
    }
    get outdated() {
      return (this.flags & 2) > 0;
    }
    set outdated(value) {
      this.flags = (value ? 2 : 0) | this.flags & ~2;
    }
    setHeight(oracle, height) {
      if (this.height != height) {
        if (Math.abs(this.height - height) > Epsilon)
          oracle.heightChanged = true;
        this.height = height;
      }
    }
    replace(_from, _to, nodes) {
      return HeightMap.of(nodes);
    }
    decomposeLeft(_to, result) {
      result.push(this);
    }
    decomposeRight(_from, result) {
      result.push(this);
    }
    applyChanges(decorations2, oldDoc, oracle, changes) {
      let me2 = this, doc2 = oracle.doc;
      for (let i = changes.length - 1; i >= 0; i--) {
        let { fromA, toA, fromB, toB } = changes[i];
        let start2 = me2.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
        let end = start2.to >= toA ? start2 : me2.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
        toB += end.to - toA;
        toA = end.to;
        while (i > 0 && start2.from <= changes[i - 1].toA) {
          fromA = changes[i - 1].fromA;
          fromB = changes[i - 1].fromB;
          i--;
          if (fromA < start2.from)
            start2 = me2.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
        }
        fromB += start2.from - fromA;
        fromA = start2.from;
        let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
        me2 = me2.replace(fromA, toA, nodes);
      }
      return me2.updateHeight(oracle, 0);
    }
    static empty() {
      return new HeightMapText(0, 0);
    }
    static of(nodes) {
      if (nodes.length == 1)
        return nodes[0];
      let i = 0, j2 = nodes.length, before = 0, after = 0;
      for (; ; ) {
        if (i == j2) {
          if (before > after * 2) {
            let split = nodes[i - 1];
            if (split.break)
              nodes.splice(--i, 1, split.left, null, split.right);
            else
              nodes.splice(--i, 1, split.left, split.right);
            j2 += 1 + split.break;
            before -= split.size;
          } else if (after > before * 2) {
            let split = nodes[j2];
            if (split.break)
              nodes.splice(j2, 1, split.left, null, split.right);
            else
              nodes.splice(j2, 1, split.left, split.right);
            j2 += 2 + split.break;
            after -= split.size;
          } else {
            break;
          }
        } else if (before < after) {
          let next = nodes[i++];
          if (next)
            before += next.size;
        } else {
          let next = nodes[--j2];
          if (next)
            after += next.size;
        }
      }
      let brk = 0;
      if (nodes[i - 1] == null) {
        brk = 1;
        i--;
      } else if (nodes[i] == null) {
        brk = 1;
        j2++;
      }
      return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j2)));
    }
  };
  HeightMap.prototype.size = 1;
  var HeightMapBlock = class extends HeightMap {
    constructor(length, height, deco) {
      super(length, height);
      this.deco = deco;
    }
    blockAt(_height, _oracle, top2, offset) {
      return new BlockInfo(offset, this.length, top2, this.height, this.deco || 0);
    }
    lineAt(_value, _type, oracle, top2, offset) {
      return this.blockAt(0, oracle, top2, offset);
    }
    forEachLine(from17, to10, oracle, top2, offset, f) {
      if (from17 <= offset + this.length && to10 >= offset)
        f(this.blockAt(0, oracle, top2, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      this.outdated = false;
      return this;
    }
    toString() {
      return `block(${this.length})`;
    }
  };
  var HeightMapText = class extends HeightMapBlock {
    constructor(length, height) {
      super(length, height, null);
      this.collapsed = 0;
      this.widgetHeight = 0;
      this.breaks = 0;
    }
    blockAt(_height, _oracle, top2, offset) {
      return new BlockInfo(offset, this.length, top2, this.height, this.breaks);
    }
    replace(_from, _to, nodes) {
      let node = nodes[0];
      if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
        if (node instanceof HeightMapGap)
          node = new HeightMapText(node.length, this.height);
        else
          node.height = this.height;
        if (!this.outdated)
          node.outdated = false;
        return node;
      } else {
        return HeightMap.of(nodes);
      }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      else if (force || this.outdated)
        this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
      this.outdated = false;
      return this;
    }
    toString() {
      return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
  };
  var HeightMapGap = class extends HeightMap {
    constructor(length) {
      super(length, 0);
    }
    heightMetrics(oracle, offset) {
      let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
      let lines = lastLine - firstLine + 1;
      let perLine, perChar = 0;
      if (oracle.lineWrapping) {
        let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
        perLine = totalPerLine / lines;
        if (this.length > lines + 1)
          perChar = (this.height - totalPerLine) / (this.length - lines - 1);
      } else {
        perLine = this.height / lines;
      }
      return { firstLine, lastLine, perLine, perChar };
    }
    blockAt(height, oracle, top2, offset) {
      let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
      if (oracle.lineWrapping) {
        let guess = offset + Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length);
        let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
        let lineTop = Math.max(top2, height - lineHeight / 2);
        return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
      } else {
        let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
        let { from: from17, length } = oracle.doc.line(firstLine + line);
        return new BlockInfo(from17, length, top2 + perLine * line, perLine, 0);
      }
    }
    lineAt(value, type, oracle, top2, offset) {
      if (type == QueryType.ByHeight)
        return this.blockAt(value, oracle, top2, offset);
      if (type == QueryType.ByPosNoHeight) {
        let { from: from17, to: to10 } = oracle.doc.lineAt(value);
        return new BlockInfo(from17, to10 - from17, 0, 0, 0);
      }
      let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
      let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
      let linesAbove = line.number - firstLine;
      let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
      return new BlockInfo(line.from, line.length, Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)), lineHeight, 0);
    }
    forEachLine(from17, to10, oracle, top2, offset, f) {
      from17 = Math.max(from17, offset);
      to10 = Math.min(to10, offset + this.length);
      let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
      for (let pos = from17, lineTop = top2; pos <= to10; ) {
        let line = oracle.doc.lineAt(pos);
        if (pos == from17) {
          let linesAbove = line.number - firstLine;
          lineTop += perLine * linesAbove + perChar * (from17 - offset - linesAbove);
        }
        let lineHeight = perLine + perChar * line.length;
        f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
        lineTop += lineHeight;
        pos = line.to + 1;
      }
    }
    replace(from17, to10, nodes) {
      let after = this.length - to10;
      if (after > 0) {
        let last = nodes[nodes.length - 1];
        if (last instanceof HeightMapGap)
          nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
        else
          nodes.push(null, new HeightMapGap(after - 1));
      }
      if (from17 > 0) {
        let first = nodes[0];
        if (first instanceof HeightMapGap)
          nodes[0] = new HeightMapGap(from17 + first.length);
        else
          nodes.unshift(new HeightMapGap(from17 - 1), null);
      }
      return HeightMap.of(nodes);
    }
    decomposeLeft(to10, result) {
      result.push(new HeightMapGap(to10 - 1), null);
    }
    decomposeRight(from17, result) {
      result.push(null, new HeightMapGap(this.length - from17 - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let end = offset + this.length;
      if (measured && measured.from <= offset + this.length && measured.more) {
        let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
        if (measured.from > offset)
          nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
        while (pos <= end && measured.more) {
          let len = oracle.doc.lineAt(pos).length;
          if (nodes.length)
            nodes.push(null);
          let height = measured.heights[measured.index++];
          if (singleHeight == -1)
            singleHeight = height;
          else if (Math.abs(height - singleHeight) >= Epsilon)
            singleHeight = -2;
          let line = new HeightMapText(len, height);
          line.outdated = false;
          nodes.push(line);
          pos += len + 1;
        }
        if (pos <= end)
          nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
        let result = HeightMap.of(nodes);
        if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
          oracle.heightChanged = true;
        return result;
      } else if (force || this.outdated) {
        this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
        this.outdated = false;
      }
      return this;
    }
    toString() {
      return `gap(${this.length})`;
    }
  };
  var HeightMapBranch = class extends HeightMap {
    constructor(left, brk, right) {
      super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
      this.left = left;
      this.right = right;
      this.size = left.size + right.size;
    }
    get break() {
      return this.flags & 1;
    }
    blockAt(height, oracle, top2, offset) {
      let mid = top2 + this.left.height;
      return height < mid ? this.left.blockAt(height, oracle, top2, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type, oracle, top2, offset) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
      let base2 = left ? this.left.lineAt(value, type, oracle, top2, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
      if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
        return base2;
      let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
      if (left)
        return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
      else
        return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset).join(base2);
    }
    forEachLine(from17, to10, oracle, top2, offset, f) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      if (this.break) {
        if (from17 < rightOffset)
          this.left.forEachLine(from17, to10, oracle, top2, offset, f);
        if (to10 >= rightOffset)
          this.right.forEachLine(from17, to10, oracle, rightTop, rightOffset, f);
      } else {
        let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top2, offset);
        if (from17 < mid.from)
          this.left.forEachLine(from17, mid.from - 1, oracle, top2, offset, f);
        if (mid.to >= from17 && mid.from <= to10)
          f(mid);
        if (to10 > mid.to)
          this.right.forEachLine(mid.to + 1, to10, oracle, rightTop, rightOffset, f);
      }
    }
    replace(from17, to10, nodes) {
      let rightStart = this.left.length + this.break;
      if (to10 < rightStart)
        return this.balanced(this.left.replace(from17, to10, nodes), this.right);
      if (from17 > this.left.length)
        return this.balanced(this.left, this.right.replace(from17 - rightStart, to10 - rightStart, nodes));
      let result = [];
      if (from17 > 0)
        this.decomposeLeft(from17, result);
      let left = result.length;
      for (let node of nodes)
        result.push(node);
      if (from17 > 0)
        mergeGaps(result, left - 1);
      if (to10 < this.length) {
        let right = result.length;
        this.decomposeRight(to10, result);
        mergeGaps(result, right);
      }
      return HeightMap.of(result);
    }
    decomposeLeft(to10, result) {
      let left = this.left.length;
      if (to10 <= left)
        return this.left.decomposeLeft(to10, result);
      result.push(this.left);
      if (this.break) {
        left++;
        if (to10 >= left)
          result.push(null);
      }
      if (to10 > left)
        this.right.decomposeLeft(to10 - left, result);
    }
    decomposeRight(from17, result) {
      let left = this.left.length, right = left + this.break;
      if (from17 >= right)
        return this.right.decomposeRight(from17 - right, result);
      if (from17 < left)
        this.left.decomposeRight(from17, result);
      if (this.break && from17 < right)
        result.push(null);
      result.push(this.right);
    }
    balanced(left, right) {
      if (left.size > 2 * right.size || right.size > 2 * left.size)
        return HeightMap.of(this.break ? [left, null, right] : [left, right]);
      this.left = left;
      this.right = right;
      this.height = left.height + right.height;
      this.outdated = left.outdated || right.outdated;
      this.size = left.size + right.size;
      this.length = left.length + this.break + right.length;
      return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
      if (measured && measured.from <= offset + left.length && measured.more)
        rebalance = left = left.updateHeight(oracle, offset, force, measured);
      else
        left.updateHeight(oracle, offset, force);
      if (measured && measured.from <= rightStart + right.length && measured.more)
        rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
      else
        right.updateHeight(oracle, rightStart, force);
      if (rebalance)
        return this.balanced(left, right);
      this.height = this.left.height + this.right.height;
      this.outdated = false;
      return this;
    }
    toString() {
      return this.left + (this.break ? " " : "-") + this.right;
    }
  };
  function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
      nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
  }
  var relevantWidgetHeight = 5;
  var NodeBuilder = class {
    constructor(pos, oracle) {
      this.pos = pos;
      this.oracle = oracle;
      this.nodes = [];
      this.lineStart = -1;
      this.lineEnd = -1;
      this.covering = null;
      this.writtenTo = pos;
    }
    get isCovered() {
      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to10) {
      if (this.lineStart > -1) {
        let end = Math.min(to10, this.lineEnd), last = this.nodes[this.nodes.length - 1];
        if (last instanceof HeightMapText)
          last.length += end - this.pos;
        else if (end > this.pos || !this.isCovered)
          this.nodes.push(new HeightMapText(end - this.pos, -1));
        this.writtenTo = end;
        if (to10 > end) {
          this.nodes.push(null);
          this.writtenTo++;
          this.lineStart = -1;
        }
      }
      this.pos = to10;
    }
    point(from17, to10, deco) {
      if (from17 < to10 || deco.heightRelevant) {
        let height = deco.widget ? deco.widget.estimatedHeight : 0;
        let breaks = deco.widget ? deco.widget.lineBreaks : 0;
        if (height < 0)
          height = this.oracle.lineHeight;
        let len = to10 - from17;
        if (deco.block) {
          this.addBlock(new HeightMapBlock(len, height, deco));
        } else if (len || breaks || height >= relevantWidgetHeight) {
          this.addLineDeco(height, breaks, len);
        }
      } else if (to10 > from17) {
        this.span(from17, to10);
      }
      if (this.lineEnd > -1 && this.lineEnd < this.pos)
        this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
      if (this.lineStart > -1)
        return;
      let { from: from17, to: to10 } = this.oracle.doc.lineAt(this.pos);
      this.lineStart = from17;
      this.lineEnd = to10;
      if (this.writtenTo < from17) {
        if (this.writtenTo < from17 - 1 || this.nodes[this.nodes.length - 1] == null)
          this.nodes.push(this.blankContent(this.writtenTo, from17 - 1));
        this.nodes.push(null);
      }
      if (this.pos > from17)
        this.nodes.push(new HeightMapText(this.pos - from17, -1));
      this.writtenTo = this.pos;
    }
    blankContent(from17, to10) {
      let gap = new HeightMapGap(to10 - from17);
      if (this.oracle.doc.lineAt(from17).to == to10)
        gap.flags |= 4;
      return gap;
    }
    ensureLine() {
      this.enterLine();
      let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
      if (last instanceof HeightMapText)
        return last;
      let line = new HeightMapText(0, -1);
      this.nodes.push(line);
      return line;
    }
    addBlock(block) {
      this.enterLine();
      let deco = block.deco;
      if (deco && deco.startSide > 0 && !this.isCovered)
        this.ensureLine();
      this.nodes.push(block);
      this.writtenTo = this.pos = this.pos + block.length;
      if (deco && deco.endSide > 0)
        this.covering = block;
    }
    addLineDeco(height, breaks, length) {
      let line = this.ensureLine();
      line.length += length;
      line.collapsed += length;
      line.widgetHeight = Math.max(line.widgetHeight, height);
      line.breaks += breaks;
      this.writtenTo = this.pos = this.pos + length;
    }
    finish(from17) {
      let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
      if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
        this.nodes.push(new HeightMapText(0, -1));
      else if (this.writtenTo < this.pos || last == null)
        this.nodes.push(this.blankContent(this.writtenTo, this.pos));
      let pos = from17;
      for (let node of this.nodes) {
        if (node instanceof HeightMapText)
          node.updateHeight(this.oracle, pos);
        pos += node ? node.length : 1;
      }
      return this.nodes;
    }
    static build(oracle, decorations2, from17, to10) {
      let builder = new NodeBuilder(from17, oracle);
      RangeSet.spans(decorations2, from17, to10, builder, 0);
      return builder.finish(from17);
    }
  };
  function heightRelevantDecoChanges(a, b, diff) {
    let comp = new DecorationComparator2();
    RangeSet.compare(a, b, diff, comp, 0);
    return comp.changes;
  }
  var DecorationComparator2 = class {
    constructor() {
      this.changes = [];
    }
    compareRange() {
    }
    comparePoint(from17, to10, a, b) {
      if (from17 < to10 || a && a.heightRelevant || b && b.heightRelevant)
        addRange(from17, to10, this.changes, 5);
    }
  };
  function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
    let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
      if (parent.nodeType == 1) {
        let elt = parent;
        let style = window.getComputedStyle(elt);
        if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
          let parentRect = elt.getBoundingClientRect();
          left = Math.max(left, parentRect.left);
          right = Math.min(right, parentRect.right);
          top2 = Math.max(top2, parentRect.top);
          bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);
        }
        parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
      } else if (parent.nodeType == 11) {
        parent = parent.host;
      } else {
        break;
      }
    }
    return {
      left: left - rect.left,
      right: Math.max(left, right) - rect.left,
      top: top2 - (rect.top + paddingTop),
      bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
    };
  }
  function fullPixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    return {
      left: 0,
      right: rect.right - rect.left,
      top: paddingTop,
      bottom: rect.bottom - (rect.top + paddingTop)
    };
  }
  var LineGap = class {
    constructor(from17, to10, size) {
      this.from = from17;
      this.to = to10;
      this.size = size;
    }
    static same(a, b) {
      if (a.length != b.length)
        return false;
      for (let i = 0; i < a.length; i++) {
        let gA = a[i], gB = b[i];
        if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
          return false;
      }
      return true;
    }
    draw(viewState, wrapping) {
      return Decoration.replace({
        widget: new LineGapWidget(this.size * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
      }).range(this.from, this.to);
    }
  };
  var LineGapWidget = class extends WidgetType {
    constructor(size, vertical) {
      super();
      this.size = size;
      this.vertical = vertical;
    }
    eq(other) {
      return other.size == this.size && other.vertical == this.vertical;
    }
    toDOM() {
      let elt = document.createElement("div");
      if (this.vertical) {
        elt.style.height = this.size + "px";
      } else {
        elt.style.width = this.size + "px";
        elt.style.height = "2px";
        elt.style.display = "inline-block";
      }
      return elt;
    }
    get estimatedHeight() {
      return this.vertical ? this.size : -1;
    }
  };
  var ViewState = class {
    constructor(state) {
      this.state = state;
      this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
      this.inView = true;
      this.paddingTop = 0;
      this.paddingBottom = 0;
      this.contentDOMWidth = 0;
      this.contentDOMHeight = 0;
      this.editorHeight = 0;
      this.editorWidth = 0;
      this.scrollTop = 0;
      this.scrolledToBottom = true;
      this.scaleX = 1;
      this.scaleY = 1;
      this.scrollAnchorPos = 0;
      this.scrollAnchorHeight = -1;
      this.scaler = IdScaler;
      this.scrollTarget = null;
      this.printing = false;
      this.mustMeasureContent = true;
      this.defaultTextDirection = Direction.LTR;
      this.visibleRanges = [];
      this.mustEnforceCursorAssoc = false;
      let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
      this.heightOracle = new HeightOracle(guessWrapping);
      this.stateDeco = state.facet(decorations).filter((d2) => typeof d2 != "function");
      this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
      this.viewport = this.getViewport(0, null);
      this.updateViewportLines();
      this.updateForViewport();
      this.lineGaps = this.ensureLineGaps([]);
      this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
      this.computeVisibleRanges();
    }
    updateForViewport() {
      let viewports = [this.viewport], { main } = this.state.selection;
      for (let i = 0; i <= 1; i++) {
        let pos = i ? main.head : main.anchor;
        if (!viewports.some(({ from: from17, to: to10 }) => pos >= from17 && pos <= to10)) {
          let { from: from17, to: to10 } = this.lineBlockAt(pos);
          viewports.push(new Viewport(from17, to10));
        }
      }
      this.viewports = viewports.sort((a, b) => a.from - b.from);
      this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
    }
    updateViewportLines() {
      this.viewportLines = [];
      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
        this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
      });
    }
    update(update, scrollTarget = null) {
      this.state = update.state;
      let prevDeco = this.stateDeco;
      this.stateDeco = this.state.facet(decorations).filter((d2) => typeof d2 != "function");
      let contentChanges = update.changedRanges;
      let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
      let prevHeight = this.heightMap.height;
      let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
      this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
      if (this.heightMap.height != prevHeight)
        update.flags |= 2;
      if (scrollAnchor) {
        this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
        this.scrollAnchorHeight = scrollAnchor.top;
      } else {
        this.scrollAnchorPos = -1;
        this.scrollAnchorHeight = this.heightMap.height;
      }
      let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
      if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
        viewport = this.getViewport(0, scrollTarget);
      let updateLines = !update.changes.empty || update.flags & 2 || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
      this.viewport = viewport;
      this.updateForViewport();
      if (updateLines)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
      update.flags |= this.computeVisibleRanges();
      if (scrollTarget)
        this.scrollTarget = scrollTarget;
      if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
        this.mustEnforceCursorAssoc = true;
    }
    measure(view) {
      let dom = view.contentDOM, style = window.getComputedStyle(dom);
      let oracle = this.heightOracle;
      let whiteSpace = style.whiteSpace;
      this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
      let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
      let domRect = dom.getBoundingClientRect();
      let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
      this.contentDOMHeight = domRect.height;
      this.mustMeasureContent = false;
      let result = 0, bias = 0;
      if (domRect.width && domRect.height) {
        let scaleX = domRect.width / dom.offsetWidth;
        let scaleY = domRect.height / dom.offsetHeight;
        if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(domRect.width - dom.offsetWidth) < 1)
          scaleX = 1;
        if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(domRect.height - dom.offsetHeight) < 1)
          scaleY = 1;
        if (this.scaleX != scaleX || this.scaleY != scaleY) {
          this.scaleX = scaleX;
          this.scaleY = scaleY;
          result |= 8;
          refresh = measureContent = true;
        }
      }
      let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
      let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
      if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
        this.paddingTop = paddingTop;
        this.paddingBottom = paddingBottom;
        result |= 8 | 2;
      }
      if (this.editorWidth != view.scrollDOM.clientWidth) {
        if (oracle.lineWrapping)
          measureContent = true;
        this.editorWidth = view.scrollDOM.clientWidth;
        result |= 8;
      }
      let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
      if (this.scrollTop != scrollTop) {
        this.scrollAnchorHeight = -1;
        this.scrollTop = scrollTop;
      }
      this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
      let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
      let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
      this.pixelViewport = pixelViewport;
      let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
      if (inView != this.inView) {
        this.inView = inView;
        if (inView)
          measureContent = true;
      }
      if (!this.inView && !this.scrollTarget)
        return 0;
      let contentWidth = domRect.width;
      if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
        this.contentDOMWidth = domRect.width;
        this.editorHeight = view.scrollDOM.clientHeight;
        result |= 8;
      }
      if (measureContent) {
        let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
        if (oracle.mustRefreshForHeights(lineHeights))
          refresh = true;
        if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
          let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
          refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
          if (refresh) {
            view.docView.minWidth = 0;
            result |= 8;
          }
        }
        if (dTop > 0 && dBottom > 0)
          bias = Math.max(dTop, dBottom);
        else if (dTop < 0 && dBottom < 0)
          bias = Math.min(dTop, dBottom);
        oracle.heightChanged = false;
        for (let vp of this.viewports) {
          let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
          this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
        }
        if (oracle.heightChanged)
          result |= 2;
      }
      let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
      if (viewportChange)
        this.viewport = this.getViewport(bias, this.scrollTarget);
      this.updateForViewport();
      if (result & 2 || viewportChange)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
      result |= this.computeVisibleRanges();
      if (this.mustEnforceCursorAssoc) {
        this.mustEnforceCursorAssoc = false;
        view.docView.enforceCursorAssoc();
      }
      return result;
    }
    get visibleTop() {
      return this.scaler.fromDOM(this.pixelViewport.top);
    }
    get visibleBottom() {
      return this.scaler.fromDOM(this.pixelViewport.bottom);
    }
    getViewport(bias, scrollTarget) {
      let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
      let map3 = this.heightMap, oracle = this.heightOracle;
      let { visibleTop, visibleBottom } = this;
      let viewport = new Viewport(map3.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map3.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
      if (scrollTarget) {
        let { head } = scrollTarget.range;
        if (head < viewport.from || head > viewport.to) {
          let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
          let block = map3.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
          if (scrollTarget.y == "center")
            topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
          else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
            topPos = block.top;
          else
            topPos = block.bottom - viewHeight;
          viewport = new Viewport(map3.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map3.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
        }
      }
      return viewport;
    }
    mapViewport(viewport, changes) {
      let from17 = changes.mapPos(viewport.from, -1), to10 = changes.mapPos(viewport.to, 1);
      return new Viewport(this.heightMap.lineAt(from17, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to10, QueryType.ByPos, this.heightOracle, 0, 0).to);
    }
    viewportIsAppropriate({ from: from17, to: to10 }, bias = 0) {
      if (!this.inView)
        return true;
      let { top: top2 } = this.heightMap.lineAt(from17, QueryType.ByPos, this.heightOracle, 0, 0);
      let { bottom } = this.heightMap.lineAt(to10, QueryType.ByPos, this.heightOracle, 0, 0);
      let { visibleTop, visibleBottom } = this;
      return (from17 == 0 || top2 <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to10 == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
    }
    mapLineGaps(gaps, changes) {
      if (!gaps.length || changes.empty)
        return gaps;
      let mapped = [];
      for (let gap of gaps)
        if (!changes.touchesRange(gap.from, gap.to))
          mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
      return mapped;
    }
    ensureLineGaps(current, mayMeasure) {
      let wrapping = this.heightOracle.lineWrapping;
      let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
      if (this.defaultTextDirection != Direction.LTR && !wrapping)
        return [];
      let gaps = [];
      let addGap = (from17, to10, line, structure) => {
        if (to10 - from17 < halfMargin)
          return;
        let sel = this.state.selection.main, avoid = [sel.from];
        if (!sel.empty)
          avoid.push(sel.to);
        for (let pos of avoid) {
          if (pos > from17 && pos < to10) {
            addGap(from17, pos - 10, line, structure);
            addGap(pos + 10, to10, line, structure);
            return;
          }
        }
        let gap = find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from17) < halfMargin && Math.abs(gap2.to - to10) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
        if (!gap) {
          if (to10 < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to10 && r.to >= to10)) {
            let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to10), false, true).head;
            if (lineStart > from17)
              to10 = lineStart;
          }
          gap = new LineGap(from17, to10, this.gapSize(line, from17, to10, structure));
        }
        gaps.push(gap);
      };
      for (let line of this.viewportLines) {
        if (line.length < doubleMargin)
          continue;
        let structure = lineStructure(line.from, line.to, this.stateDeco);
        if (structure.total < doubleMargin)
          continue;
        let target = this.scrollTarget ? this.scrollTarget.range.head : null;
        let viewFrom, viewTo;
        if (wrapping) {
          let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
          let top2, bot;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
            top2 = targetFrac - spaceFrac;
            bot = targetFrac + spaceFrac;
          } else {
            top2 = (this.visibleTop - line.top - marginHeight) / line.height;
            bot = (this.visibleBottom - line.top + marginHeight) / line.height;
          }
          viewFrom = findPosition(structure, top2);
          viewTo = findPosition(structure, bot);
        } else {
          let totalWidth = structure.total * this.heightOracle.charWidth;
          let marginWidth = margin * this.heightOracle.charWidth;
          let left, right;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
            left = targetFrac - spaceFrac;
            right = targetFrac + spaceFrac;
          } else {
            left = (this.pixelViewport.left - marginWidth) / totalWidth;
            right = (this.pixelViewport.right + marginWidth) / totalWidth;
          }
          viewFrom = findPosition(structure, left);
          viewTo = findPosition(structure, right);
        }
        if (viewFrom > line.from)
          addGap(line.from, viewFrom, line, structure);
        if (viewTo < line.to)
          addGap(viewTo, line.to, line, structure);
      }
      return gaps;
    }
    gapSize(line, from17, to10, structure) {
      let fraction = findFraction(structure, to10) - findFraction(structure, from17);
      if (this.heightOracle.lineWrapping) {
        return line.height * fraction;
      } else {
        return structure.total * this.heightOracle.charWidth * fraction;
      }
    }
    updateLineGaps(gaps) {
      if (!LineGap.same(gaps, this.lineGaps)) {
        this.lineGaps = gaps;
        this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
      }
    }
    computeVisibleRanges() {
      let deco = this.stateDeco;
      if (this.lineGaps.length)
        deco = deco.concat(this.lineGapDeco);
      let ranges = [];
      RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
        span(from17, to10) {
          ranges.push({ from: from17, to: to10 });
        },
        point() {
        }
      }, 20);
      let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
      this.visibleRanges = ranges;
      return changed ? 4 : 0;
    }
    lineBlockAt(pos) {
      return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
      return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
    }
    scrollAnchorAt(scrollTop) {
      let block = this.lineBlockAtHeight(scrollTop + 8);
      return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
    }
    elementAtHeight(height) {
      return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
    }
    get docHeight() {
      return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
      return this.docHeight + this.paddingTop + this.paddingBottom;
    }
  };
  var Viewport = class {
    constructor(from17, to10) {
      this.from = from17;
      this.to = to10;
    }
  };
  function lineStructure(from17, to10, stateDeco) {
    let ranges = [], pos = from17, total = 0;
    RangeSet.spans(stateDeco, from17, to10, {
      span() {
      },
      point(from18, to11) {
        if (from18 > pos) {
          ranges.push({ from: pos, to: from18 });
          total += from18 - pos;
        }
        pos = to11;
      }
    }, 20);
    if (pos < to10) {
      ranges.push({ from: pos, to: to10 });
      total += to10 - pos;
    }
    return { total, ranges };
  }
  function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
      return ranges[0].from;
    if (ratio >= 1)
      return ranges[ranges.length - 1].to;
    let dist2 = Math.floor(total * ratio);
    for (let i = 0; ; i++) {
      let { from: from17, to: to10 } = ranges[i], size = to10 - from17;
      if (dist2 <= size)
        return from17 + dist2;
      dist2 -= size;
    }
  }
  function findFraction(structure, pos) {
    let counted = 0;
    for (let { from: from17, to: to10 } of structure.ranges) {
      if (pos <= to10) {
        counted += pos - from17;
        break;
      }
      counted += to10 - from17;
    }
    return counted / structure.total;
  }
  function find(array, f) {
    for (let val of array)
      if (f(val))
        return val;
    return void 0;
  }
  var IdScaler = {
    toDOM(n) {
      return n;
    },
    fromDOM(n) {
      return n;
    },
    scale: 1
  };
  var BigScaler = class {
    constructor(oracle, heightMap, viewports) {
      let vpHeight = 0, base2 = 0, domBase = 0;
      this.viewports = viewports.map(({ from: from17, to: to10 }) => {
        let top2 = heightMap.lineAt(from17, QueryType.ByPos, oracle, 0, 0).top;
        let bottom = heightMap.lineAt(to10, QueryType.ByPos, oracle, 0, 0).bottom;
        vpHeight += bottom - top2;
        return { from: from17, to: to10, top: top2, bottom, domTop: 0, domBottom: 0 };
      });
      this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
      for (let obj of this.viewports) {
        obj.domTop = domBase + (obj.top - base2) * this.scale;
        domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
        base2 = obj.bottom;
      }
    }
    toDOM(n) {
      for (let i = 0, base2 = 0, domBase = 0; ; i++) {
        let vp = i < this.viewports.length ? this.viewports[i] : null;
        if (!vp || n < vp.top)
          return domBase + (n - base2) * this.scale;
        if (n <= vp.bottom)
          return vp.domTop + (n - vp.top);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    fromDOM(n) {
      for (let i = 0, base2 = 0, domBase = 0; ; i++) {
        let vp = i < this.viewports.length ? this.viewports[i] : null;
        if (!vp || n < vp.domTop)
          return base2 + (n - domBase) / this.scale;
        if (n <= vp.domBottom)
          return vp.top + (n - vp.domTop);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
  };
  function scaleBlock(block, scaler) {
    if (scaler.scale == 1)
      return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b) => scaleBlock(b, scaler)) : block._content);
  }
  var theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
  var darkTheme = /* @__PURE__ */ Facet.define({ combine: (values) => values.indexOf(true) > -1 });
  var baseThemeID = /* @__PURE__ */ StyleModule.newName();
  var baseLightID = /* @__PURE__ */ StyleModule.newName();
  var baseDarkID = /* @__PURE__ */ StyleModule.newName();
  var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
  function buildTheme(main, spec, scopes) {
    return new StyleModule(spec, {
      finish(sel) {
        return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
          if (m == "&")
            return main;
          if (!scopes || !scopes[m])
            throw new RangeError(`Unsupported selector: ${m}`);
          return scopes[m];
        }) : main + " " + sel;
      }
    });
  }
  var baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
    "&": {
      position: "relative !important",
      boxSizing: "border-box",
      "&.cm-focused": {
        outline: "1px dotted #212121"
      },
      display: "flex !important",
      flexDirection: "column"
    },
    ".cm-scroller": {
      display: "flex !important",
      alignItems: "flex-start !important",
      fontFamily: "monospace",
      lineHeight: 1.4,
      height: "100%",
      overflowX: "auto",
      position: "relative",
      zIndex: 0
    },
    ".cm-content": {
      margin: 0,
      flexGrow: 2,
      flexShrink: 0,
      display: "block",
      whiteSpace: "pre",
      wordWrap: "normal",
      boxSizing: "border-box",
      minHeight: "100%",
      padding: "4px 0",
      outline: "none",
      "&[contenteditable=true]": {
        WebkitUserModify: "read-write-plaintext-only"
      }
    },
    ".cm-lineWrapping": {
      whiteSpace_fallback: "pre-wrap",
      whiteSpace: "break-spaces",
      wordBreak: "break-word",
      overflowWrap: "anywhere",
      flexShrink: 1
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
      display: "block",
      padding: "0 2px 0 6px"
    },
    ".cm-layer": {
      position: "absolute",
      left: 0,
      top: 0,
      contain: "size style",
      "& > *": {
        position: "absolute"
      }
    },
    "&light .cm-selectionBackground": {
      background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
      background: "#222"
    },
    "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#d7d4f0"
    },
    "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#233"
    },
    ".cm-cursorLayer": {
      pointerEvents: "none"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
      animation: "steps(1) cm-blink 1.2s infinite"
    },
    "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    ".cm-cursor, .cm-dropCursor": {
      borderLeft: "1.2px solid black",
      marginLeft: "-0.6px",
      pointerEvents: "none"
    },
    ".cm-cursor": {
      display: "none"
    },
    "&dark .cm-cursor": {
      borderLeftColor: "#444"
    },
    ".cm-dropCursor": {
      position: "absolute"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
      display: "block"
    },
    ".cm-announced": {
      position: "fixed",
      top: "-10000px"
    },
    "@media print": {
      ".cm-announced": { display: "none" }
    },
    "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
    "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-gutters": {
      flexShrink: 0,
      display: "flex",
      height: "100%",
      boxSizing: "border-box",
      insetInlineStart: 0,
      zIndex: 200
    },
    "&light .cm-gutters": {
      backgroundColor: "#f5f5f5",
      color: "#6c6c6c",
      borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
      backgroundColor: "#333338",
      color: "#ccc"
    },
    ".cm-gutter": {
      display: "flex !important",
      flexDirection: "column",
      flexShrink: 0,
      boxSizing: "border-box",
      minHeight: "100%",
      overflow: "hidden"
    },
    ".cm-gutterElement": {
      boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      padding: "0 3px 0 5px",
      minWidth: "20px",
      textAlign: "right",
      whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
      backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
      backgroundColor: "#222227"
    },
    ".cm-panels": {
      boxSizing: "border-box",
      position: "sticky",
      left: 0,
      right: 0
    },
    "&light .cm-panels": {
      backgroundColor: "#f5f5f5",
      color: "black"
    },
    "&light .cm-panels-top": {
      borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
      borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tab": {
      display: "inline-block",
      overflow: "hidden",
      verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
      verticalAlign: "text-top",
      height: "1em",
      width: 0,
      display: "inline"
    },
    ".cm-placeholder": {
      color: "#888",
      display: "inline-block",
      verticalAlign: "top"
    },
    ".cm-highlightSpace:before": {
      content: "attr(data-display)",
      position: "absolute",
      pointerEvents: "none",
      color: "#888"
    },
    ".cm-highlightTab": {
      backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
      backgroundSize: "auto 100%",
      backgroundPosition: "right 90%",
      backgroundRepeat: "no-repeat"
    },
    ".cm-trailingSpace": {
      backgroundColor: "#ff332255"
    },
    ".cm-button": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      padding: ".2em 1em",
      borderRadius: "1px"
    },
    "&light .cm-button": {
      backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
      }
    },
    "&dark .cm-button": {
      backgroundImage: "linear-gradient(#393939, #111)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#111, #333)"
      }
    },
    ".cm-textfield": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      border: "1px solid silver",
      padding: ".2em .5em"
    },
    "&light .cm-textfield": {
      backgroundColor: "white"
    },
    "&dark .cm-textfield": {
      border: "1px solid #555",
      backgroundColor: "inherit"
    }
  }, lightDarkIDs);
  var LineBreakPlaceholder = "\uFFFF";
  var DOMReader = class {
    constructor(points, state) {
      this.points = points;
      this.text = "";
      this.lineSeparator = state.facet(EditorState.lineSeparator);
    }
    append(text) {
      this.text += text;
    }
    lineBreak() {
      this.text += LineBreakPlaceholder;
    }
    readRange(start2, end) {
      if (!start2)
        return this;
      let parent = start2.parentNode;
      for (let cur = start2; ; ) {
        this.findPointBefore(parent, cur);
        let oldLen = this.text.length;
        this.readNode(cur);
        let next = cur.nextSibling;
        if (next == end)
          break;
        let view = ContentView.get(cur), nextView = ContentView.get(next);
        if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore) && this.text.length > oldLen)
          this.lineBreak();
        cur = next;
      }
      this.findPointBefore(parent, end);
      return this;
    }
    readTextNode(node) {
      let text = node.nodeValue;
      for (let point of this.points)
        if (point.node == node)
          point.pos = this.text.length + Math.min(point.offset, text.length);
      for (let off2 = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
        let nextBreak = -1, breakSize = 1, m;
        if (this.lineSeparator) {
          nextBreak = text.indexOf(this.lineSeparator, off2);
          breakSize = this.lineSeparator.length;
        } else if (m = re.exec(text)) {
          nextBreak = m.index;
          breakSize = m[0].length;
        }
        this.append(text.slice(off2, nextBreak < 0 ? text.length : nextBreak));
        if (nextBreak < 0)
          break;
        this.lineBreak();
        if (breakSize > 1) {
          for (let point of this.points)
            if (point.node == node && point.pos > this.text.length)
              point.pos -= breakSize - 1;
        }
        off2 = nextBreak + breakSize;
      }
    }
    readNode(node) {
      if (node.cmIgnore)
        return;
      let view = ContentView.get(node);
      let fromView = view && view.overrideDOMText;
      if (fromView != null) {
        this.findPointInside(node, fromView.length);
        for (let i = fromView.iter(); !i.next().done; ) {
          if (i.lineBreak)
            this.lineBreak();
          else
            this.append(i.value);
        }
      } else if (node.nodeType == 3) {
        this.readTextNode(node);
      } else if (node.nodeName == "BR") {
        if (node.nextSibling)
          this.lineBreak();
      } else if (node.nodeType == 1) {
        this.readRange(node.firstChild, null);
      }
    }
    findPointBefore(node, next) {
      for (let point of this.points)
        if (point.node == node && node.childNodes[point.offset] == next)
          point.pos = this.text.length;
    }
    findPointInside(node, length) {
      for (let point of this.points)
        if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
          point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
    }
  };
  function isAtEnd(parent, node, offset) {
    for (; ; ) {
      if (!node || offset < maxOffset(node))
        return false;
      if (node == parent)
        return true;
      offset = domIndex(node) + 1;
      node = node.parentNode;
    }
  }
  function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
  }
  var DOMPoint = class {
    constructor(node, offset) {
      this.node = node;
      this.offset = offset;
      this.pos = -1;
    }
  };
  var DOMChange = class {
    constructor(view, start2, end, typeOver) {
      this.typeOver = typeOver;
      this.bounds = null;
      this.text = "";
      let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
      if (view.state.readOnly && start2 > -1) {
        this.newSel = null;
      } else if (start2 > -1 && (this.bounds = view.docView.domBoundsAround(start2, end, 0))) {
        let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
        let reader = new DOMReader(selPoints, view.state);
        reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
        this.text = reader.text;
        this.newSel = selectionFromPoints(selPoints, this.bounds.from);
      } else {
        let domSel = view.observer.selectionRange;
        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
        this.newSel = EditorSelection.single(anchor, head);
      }
    }
  };
  function applyDOMChange(view, domChange) {
    let change;
    let { newSel } = domChange, sel = view.state.selection.main;
    let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
    if (domChange.bounds) {
      let { from: from17, to: to10 } = domChange.bounds;
      let preferredPos = sel.from, preferredSide = null;
      if (lastKey === 8 || browser.android && domChange.text.length < to10 - from17) {
        preferredPos = sel.to;
        preferredSide = "end";
      }
      let diff = findDiff(view.state.doc.sliceString(from17, to10, LineBreakPlaceholder), domChange.text, preferredPos - from17, preferredSide);
      if (diff) {
        if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
          diff.toB--;
        change = {
          from: from17 + diff.from,
          to: from17 + diff.toA,
          insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
        };
      }
    } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
      newSel = null;
    }
    if (!change && !newSel)
      return false;
    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
      change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
      change = {
        from: sel.from,
        to: sel.to,
        insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
      };
    } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
      if (newSel && change.insert.length == 2)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
    } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
      if (newSel)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
    }
    if (change) {
      if (browser.ios && view.inputState.flushIOSKey())
        return true;
      if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
        return true;
      let text = change.insert.toString();
      if (view.inputState.composing >= 0)
        view.inputState.composing++;
      let defaultTr;
      let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
      if (!view.state.facet(inputHandler).some((h3) => h3(view, change.from, change.to, text, defaultInsert)))
        view.dispatch(defaultInsert());
      return true;
    } else if (newSel && !newSel.main.eq(sel)) {
      let scrollIntoView2 = false, userEvent = "select";
      if (view.inputState.lastSelectionTime > Date.now() - 50) {
        if (view.inputState.lastSelectionOrigin == "select")
          scrollIntoView2 = true;
        userEvent = view.inputState.lastSelectionOrigin;
      }
      view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView2, userEvent });
      return true;
    } else {
      return false;
    }
  }
  function applyDefaultInsert(view, change, newSel) {
    let tr3, startState = view.state, sel = startState.selection.main;
    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
      let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
      let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
      tr3 = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
    } else {
      let changes = startState.changes(change);
      let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
      if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
        let replaced = view.state.sliceDoc(change.from, change.to);
        let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
        if (composition) {
          let dLen = change.insert.length - (change.to - change.from);
          compositionRange = { from: composition.from, to: composition.to - dLen };
        } else {
          compositionRange = view.state.doc.lineAt(sel.head);
        }
        let offset = sel.to - change.to, size = sel.to - sel.from;
        tr3 = startState.changeByRange((range10) => {
          if (range10.from == sel.from && range10.to == sel.to)
            return { changes, range: mainSel || range10.map(changes) };
          let to10 = range10.to - offset, from17 = to10 - replaced.length;
          if (range10.to - range10.from != size || view.state.sliceDoc(from17, to10) != replaced || range10.to >= compositionRange.from && range10.from <= compositionRange.to)
            return { range: range10 };
          let rangeChanges = startState.changes({ from: from17, to: to10, insert: change.insert }), selOff = range10.to - sel.to;
          return {
            changes: rangeChanges,
            range: !mainSel ? range10.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
          };
        });
      } else {
        tr3 = {
          changes,
          selection: mainSel && startState.selection.replaceRange(mainSel)
        };
      }
    }
    let userEvent = "input.type";
    if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
      view.inputState.compositionPendingChange = false;
      userEvent += ".compose";
      if (view.inputState.compositionFirstChange) {
        userEvent += ".start";
        view.inputState.compositionFirstChange = false;
      }
    }
    return startState.update(tr3, { userEvent, scrollIntoView: true });
  }
  function findDiff(a, b, preferredPos, preferredSide) {
    let minLen = Math.min(a.length, b.length);
    let from17 = 0;
    while (from17 < minLen && a.charCodeAt(from17) == b.charCodeAt(from17))
      from17++;
    if (from17 == minLen && a.length == b.length)
      return null;
    let toA = a.length, toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
      toA--;
      toB--;
    }
    if (preferredSide == "end") {
      let adjust = Math.max(0, from17 - Math.min(toA, toB));
      preferredPos -= toA + adjust - from17;
    }
    if (toA < from17 && a.length < b.length) {
      let move = preferredPos <= from17 && preferredPos >= toA ? from17 - preferredPos : 0;
      from17 -= move;
      toB = from17 + (toB - toA);
      toA = from17;
    } else if (toB < from17) {
      let move = preferredPos <= from17 && preferredPos >= toB ? from17 - preferredPos : 0;
      from17 -= move;
      toA = from17 + (toA - toB);
      toB = from17;
    }
    return { from: from17, toA, toB };
  }
  function selectionPoints(view) {
    let result = [];
    if (view.root.activeElement != view.contentDOM)
      return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
    if (anchorNode) {
      result.push(new DOMPoint(anchorNode, anchorOffset));
      if (focusNode != anchorNode || focusOffset != anchorOffset)
        result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
  }
  function selectionFromPoints(points, base2) {
    if (points.length == 0)
      return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
  }
  var observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
  };
  var useCharData = browser.ie && browser.ie_version <= 11;
  var DOMObserver = class {
    constructor(view) {
      this.view = view;
      this.active = false;
      this.selectionRange = new DOMSelectionState();
      this.selectionChanged = false;
      this.delayedFlush = -1;
      this.resizeTimeout = -1;
      this.queue = [];
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
      this.lastChange = 0;
      this.scrollTargets = [];
      this.intersection = null;
      this.resizeScroll = null;
      this.intersecting = false;
      this.gapIntersection = null;
      this.gaps = [];
      this.parentCheck = -1;
      this.dom = view.contentDOM;
      this.observer = new MutationObserver((mutations) => {
        for (let mut of mutations)
          this.queue.push(mut);
        if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (useCharData)
        this.onCharData = (event2) => {
          this.queue.push({
            target: event2.target,
            type: "characterData",
            oldValue: event2.prevValue
          });
          this.flushSoon();
        };
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.onResize = this.onResize.bind(this);
      this.onPrint = this.onPrint.bind(this);
      this.onScroll = this.onScroll.bind(this);
      if (typeof ResizeObserver == "function") {
        this.resizeScroll = new ResizeObserver(() => {
          var _a3;
          if (((_a3 = this.view.docView) === null || _a3 === void 0 ? void 0 : _a3.lastUpdate) < Date.now() - 75)
            this.onResize();
        });
        this.resizeScroll.observe(view.scrollDOM);
      }
      this.addWindowListeners(this.win = view.win);
      this.start();
      if (typeof IntersectionObserver == "function") {
        this.intersection = new IntersectionObserver((entries) => {
          if (this.parentCheck < 0)
            this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
            this.intersecting = !this.intersecting;
            if (this.intersecting != this.view.inView)
              this.onScrollChanged(document.createEvent("Event"));
          }
        }, { threshold: [0, 1e-3] });
        this.intersection.observe(this.dom);
        this.gapIntersection = new IntersectionObserver((entries) => {
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
            this.onScrollChanged(document.createEvent("Event"));
        }, {});
      }
      this.listenForScroll();
      this.readSelectionRange();
    }
    onScrollChanged(e) {
      this.view.inputState.runHandlers("scroll", e);
      if (this.intersecting)
        this.view.measure();
    }
    onScroll(e) {
      if (this.intersecting)
        this.flush(false);
      this.onScrollChanged(e);
    }
    onResize() {
      if (this.resizeTimeout < 0)
        this.resizeTimeout = setTimeout(() => {
          this.resizeTimeout = -1;
          this.view.requestMeasure();
        }, 50);
    }
    onPrint() {
      this.view.viewState.printing = true;
      this.view.measure();
      setTimeout(() => {
        this.view.viewState.printing = false;
        this.view.requestMeasure();
      }, 500);
    }
    updateGaps(gaps) {
      if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
        this.gapIntersection.disconnect();
        for (let gap of gaps)
          this.gapIntersection.observe(gap);
        this.gaps = gaps;
      }
    }
    onSelectionChange(event2) {
      let wasChanged = this.selectionChanged;
      if (!this.readSelectionRange() || this.delayedAndroidKey)
        return;
      let { view } = this, sel = this.selectionRange;
      if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
        return;
      let context2 = sel.anchorNode && view.docView.nearest(sel.anchorNode);
      if (context2 && context2.ignoreEvent(event2)) {
        if (!wasChanged)
          this.selectionChanged = false;
        return;
      }
      if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        this.flushSoon();
      else
        this.flush(false);
    }
    readSelectionRange() {
      let { view } = this;
      let range10 = browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);
      if (!range10 || this.selectionRange.eq(range10))
        return false;
      let local = hasSelection(this.dom, range10);
      if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range10)) {
        this.view.inputState.lastFocusTime = 0;
        view.docView.updateSelection();
        return false;
      }
      this.selectionRange.setRange(range10);
      if (local)
        this.selectionChanged = true;
      return true;
    }
    setSelectionRange(anchor, head) {
      this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
      this.selectionChanged = false;
    }
    clearSelectionRange() {
      this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
      this.parentCheck = -1;
      let i = 0, changed = null;
      for (let dom = this.dom; dom; ) {
        if (dom.nodeType == 1) {
          if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
            i++;
          else if (!changed)
            changed = this.scrollTargets.slice(0, i);
          if (changed)
            changed.push(dom);
          dom = dom.assignedSlot || dom.parentNode;
        } else if (dom.nodeType == 11) {
          dom = dom.host;
        } else {
          break;
        }
      }
      if (i < this.scrollTargets.length && !changed)
        changed = this.scrollTargets.slice(0, i);
      if (changed) {
        for (let dom of this.scrollTargets)
          dom.removeEventListener("scroll", this.onScroll);
        for (let dom of this.scrollTargets = changed)
          dom.addEventListener("scroll", this.onScroll);
      }
    }
    ignore(f) {
      if (!this.active)
        return f();
      try {
        this.stop();
        return f();
      } finally {
        this.start();
        this.clear();
      }
    }
    start() {
      if (this.active)
        return;
      this.observer.observe(this.dom, observeOptions);
      if (useCharData)
        this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.active = true;
    }
    stop() {
      if (!this.active)
        return;
      this.active = false;
      this.observer.disconnect();
      if (useCharData)
        this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    clear() {
      this.processRecords();
      this.queue.length = 0;
      this.selectionChanged = false;
    }
    delayAndroidKey(key, keyCode) {
      var _a3;
      if (!this.delayedAndroidKey) {
        let flush = () => {
          let key2 = this.delayedAndroidKey;
          if (key2) {
            this.clearDelayedAndroidKey();
            this.view.inputState.lastKeyCode = key2.keyCode;
            this.view.inputState.lastKeyTime = Date.now();
            let flushed = this.flush();
            if (!flushed && key2.force)
              dispatchKey(this.dom, key2.key, key2.keyCode);
          }
        };
        this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
      }
      if (!this.delayedAndroidKey || key == "Enter")
        this.delayedAndroidKey = {
          key,
          keyCode,
          force: this.lastChange < Date.now() - 50 || !!((_a3 = this.delayedAndroidKey) === null || _a3 === void 0 ? void 0 : _a3.force)
        };
    }
    clearDelayedAndroidKey() {
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
    }
    flushSoon() {
      if (this.delayedFlush < 0)
        this.delayedFlush = this.view.win.requestAnimationFrame(() => {
          this.delayedFlush = -1;
          this.flush();
        });
    }
    forceFlush() {
      if (this.delayedFlush >= 0) {
        this.view.win.cancelAnimationFrame(this.delayedFlush);
        this.delayedFlush = -1;
      }
      this.flush();
    }
    pendingRecords() {
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
      return this.queue;
    }
    processRecords() {
      let records = this.pendingRecords();
      if (records.length)
        this.queue = [];
      let from17 = -1, to10 = -1, typeOver = false;
      for (let record of records) {
        let range10 = this.readMutation(record);
        if (!range10)
          continue;
        if (range10.typeOver)
          typeOver = true;
        if (from17 == -1) {
          ({ from: from17, to: to10 } = range10);
        } else {
          from17 = Math.min(range10.from, from17);
          to10 = Math.max(range10.to, to10);
        }
      }
      return { from: from17, to: to10, typeOver };
    }
    readChange() {
      let { from: from17, to: to10, typeOver } = this.processRecords();
      let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
      if (from17 < 0 && !newSel)
        return null;
      if (from17 > -1)
        this.lastChange = Date.now();
      this.view.inputState.lastFocusTime = 0;
      this.selectionChanged = false;
      let change = new DOMChange(this.view, from17, to10, typeOver);
      this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
      return change;
    }
    flush(readSelection = true) {
      if (this.delayedFlush >= 0 || this.delayedAndroidKey)
        return false;
      if (readSelection)
        this.readSelectionRange();
      let domChange = this.readChange();
      if (!domChange) {
        this.view.requestMeasure();
        return false;
      }
      let startState = this.view.state;
      let handled = applyDOMChange(this.view, domChange);
      if (this.view.state == startState)
        this.view.update([]);
      return handled;
    }
    readMutation(rec) {
      let cView = this.view.docView.nearest(rec.target);
      if (!cView || cView.ignoreMutation(rec))
        return null;
      cView.markDirty(rec.type == "attributes");
      if (rec.type == "attributes")
        cView.flags |= 4;
      if (rec.type == "childList") {
        let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
        let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
        return {
          from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
          to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
          typeOver: false
        };
      } else if (rec.type == "characterData") {
        return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
      } else {
        return null;
      }
    }
    setWindow(win) {
      if (win != this.win) {
        this.removeWindowListeners(this.win);
        this.win = win;
        this.addWindowListeners(this.win);
      }
    }
    addWindowListeners(win) {
      win.addEventListener("resize", this.onResize);
      win.addEventListener("beforeprint", this.onPrint);
      win.addEventListener("scroll", this.onScroll);
      win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
      win.removeEventListener("scroll", this.onScroll);
      win.removeEventListener("resize", this.onResize);
      win.removeEventListener("beforeprint", this.onPrint);
      win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    destroy() {
      var _a3, _b, _c2;
      this.stop();
      (_a3 = this.intersection) === null || _a3 === void 0 ? void 0 : _a3.disconnect();
      (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c2 = this.resizeScroll) === null || _c2 === void 0 ? void 0 : _c2.disconnect();
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      this.removeWindowListeners(this.win);
      clearTimeout(this.parentCheck);
      clearTimeout(this.resizeTimeout);
      this.win.cancelAnimationFrame(this.delayedFlush);
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
    }
  };
  function findChild(cView, dom, dir) {
    while (dom) {
      let curView = ContentView.get(dom);
      if (curView && curView.parent == cView)
        return curView;
      let parent = dom.parentNode;
      dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
  }
  function safariSelectionRangeHack(view) {
    let found = null;
    function read(event2) {
      event2.preventDefault();
      event2.stopImmediatePropagation();
      found = event2.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    view.dom.ownerDocument.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    if (!found)
      return null;
    let anchorNode = found.startContainer, anchorOffset = found.startOffset;
    let focusNode = found.endContainer, focusOffset = found.endOffset;
    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
  }
  var EditorView = class {
    get state() {
      return this.viewState.state;
    }
    get viewport() {
      return this.viewState.viewport;
    }
    get visibleRanges() {
      return this.viewState.visibleRanges;
    }
    get inView() {
      return this.viewState.inView;
    }
    get composing() {
      return this.inputState.composing > 0;
    }
    get compositionStarted() {
      return this.inputState.composing >= 0;
    }
    get root() {
      return this._root;
    }
    get win() {
      return this.dom.ownerDocument.defaultView || window;
    }
    constructor(config = {}) {
      this.plugins = [];
      this.pluginMap = new Map();
      this.editorAttrs = {};
      this.contentAttrs = {};
      this.bidiCache = [];
      this.destroyed = false;
      this.updateState = 2;
      this.measureScheduled = -1;
      this.measureRequests = [];
      this.contentDOM = document.createElement("div");
      this.scrollDOM = document.createElement("div");
      this.scrollDOM.tabIndex = -1;
      this.scrollDOM.className = "cm-scroller";
      this.scrollDOM.appendChild(this.contentDOM);
      this.announceDOM = document.createElement("div");
      this.announceDOM.className = "cm-announced";
      this.announceDOM.setAttribute("aria-live", "polite");
      this.dom = document.createElement("div");
      this.dom.appendChild(this.announceDOM);
      this.dom.appendChild(this.scrollDOM);
      let { dispatch } = config;
      this.dispatchTransactions = config.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr3) => dispatch(tr3, this))) || ((trs) => this.update(trs));
      this.dispatch = this.dispatch.bind(this);
      this._root = config.root || getRoot(config.parent) || document;
      this.viewState = new ViewState(config.state || EditorState.create(config));
      if (config.scrollTo && config.scrollTo.is(scrollIntoView))
        this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);
      this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      for (let plugin of this.plugins)
        plugin.update(this);
      this.observer = new DOMObserver(this);
      this.inputState = new InputState(this);
      this.inputState.ensureHandlers(this.plugins);
      this.docView = new DocView(this);
      this.mountStyles();
      this.updateAttrs();
      this.updateState = 0;
      this.requestMeasure();
      if (config.parent)
        config.parent.appendChild(this.dom);
    }
    dispatch(...input2) {
      let trs = input2.length == 1 && input2[0] instanceof Transaction ? input2 : input2.length == 1 && Array.isArray(input2[0]) ? input2[0] : [this.state.update(...input2)];
      this.dispatchTransactions(trs, this);
    }
    update(transactions) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
      let redrawn = false, attrsChanged = false, update;
      let state = this.state;
      for (let tr3 of transactions) {
        if (tr3.startState != state)
          throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
        state = tr3.state;
      }
      if (this.destroyed) {
        this.viewState.state = state;
        return;
      }
      let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
      if (transactions.some((tr3) => tr3.annotation(isFocusChange))) {
        this.inputState.notifiedFocused = focus;
        focusFlag = 1;
      } else if (focus != this.inputState.notifiedFocused) {
        this.inputState.notifiedFocused = focus;
        dispatchFocus = focusChangeTransaction(state, focus);
        if (!dispatchFocus)
          focusFlag = 1;
      }
      let pendingKey = this.observer.delayedAndroidKey, domChange = null;
      if (pendingKey) {
        this.observer.clearDelayedAndroidKey();
        domChange = this.observer.readChange();
        if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
          domChange = null;
      } else {
        this.observer.clear();
      }
      if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
        return this.setState(state);
      update = ViewUpdate.create(this, state, transactions);
      update.flags |= focusFlag;
      let scrollTarget = this.viewState.scrollTarget;
      try {
        this.updateState = 2;
        for (let tr3 of transactions) {
          if (scrollTarget)
            scrollTarget = scrollTarget.map(tr3.changes);
          if (tr3.scrollIntoView) {
            let { main } = tr3.state.selection;
            scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
          }
          for (let e of tr3.effects)
            if (e.is(scrollIntoView))
              scrollTarget = e.value.clip(this.state);
        }
        this.viewState.update(update, scrollTarget);
        this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
        }
        redrawn = this.docView.update(update);
        if (this.state.facet(styleModule) != this.styleModules)
          this.mountStyles();
        attrsChanged = this.updateAttrs();
        this.showAnnouncements(transactions);
        this.docView.updateSelection(redrawn, transactions.some((tr3) => tr3.isUserEvent("select.pointer")));
      } finally {
        this.updateState = 0;
      }
      if (update.startState.facet(theme) != update.state.facet(theme))
        this.viewState.mustMeasureContent = true;
      if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
        this.requestMeasure();
      if (!update.empty)
        for (let listener of this.state.facet(updateListener)) {
          try {
            listener(update);
          } catch (e) {
            logException(this.state, e, "update listener");
          }
        }
      if (dispatchFocus || domChange)
        Promise.resolve().then(() => {
          if (dispatchFocus && this.state == dispatchFocus.startState)
            this.dispatch(dispatchFocus);
          if (domChange) {
            if (!applyDOMChange(this, domChange) && pendingKey.force)
              dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
          }
        });
    }
    setState(newState) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
      if (this.destroyed) {
        this.viewState.state = newState;
        return;
      }
      this.updateState = 2;
      let hadFocus = this.hasFocus;
      try {
        for (let plugin of this.plugins)
          plugin.destroy(this);
        this.viewState = new ViewState(newState);
        this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
        this.pluginMap.clear();
        for (let plugin of this.plugins)
          plugin.update(this);
        this.docView.destroy();
        this.docView = new DocView(this);
        this.inputState.ensureHandlers(this.plugins);
        this.mountStyles();
        this.updateAttrs();
        this.bidiCache = [];
      } finally {
        this.updateState = 0;
      }
      if (hadFocus)
        this.focus();
      this.requestMeasure();
    }
    updatePlugins(update) {
      let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
      if (prevSpecs != specs) {
        let newPlugins = [];
        for (let spec of specs) {
          let found = prevSpecs.indexOf(spec);
          if (found < 0) {
            newPlugins.push(new PluginInstance(spec));
          } else {
            let plugin = this.plugins[found];
            plugin.mustUpdate = update;
            newPlugins.push(plugin);
          }
        }
        for (let plugin of this.plugins)
          if (plugin.mustUpdate != update)
            plugin.destroy(this);
        this.plugins = newPlugins;
        this.pluginMap.clear();
      } else {
        for (let p of this.plugins)
          p.mustUpdate = update;
      }
      for (let i = 0; i < this.plugins.length; i++)
        this.plugins[i].update(this);
      if (prevSpecs != specs)
        this.inputState.ensureHandlers(this.plugins);
    }
    measure(flush = true) {
      if (this.destroyed)
        return;
      if (this.measureScheduled > -1)
        this.win.cancelAnimationFrame(this.measureScheduled);
      if (this.observer.delayedAndroidKey) {
        this.measureScheduled = -1;
        this.requestMeasure();
        return;
      }
      this.measureScheduled = 0;
      if (flush)
        this.observer.forceFlush();
      let updated = null;
      let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
      let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
      if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
        scrollAnchorHeight = -1;
      this.viewState.scrollAnchorHeight = -1;
      try {
        for (let i = 0; ; i++) {
          if (scrollAnchorHeight < 0) {
            if (isScrolledToBottom(sDOM)) {
              scrollAnchorPos = -1;
              scrollAnchorHeight = this.viewState.heightMap.height;
            } else {
              let block = this.viewState.scrollAnchorAt(scrollTop);
              scrollAnchorPos = block.from;
              scrollAnchorHeight = block.top;
            }
          }
          this.updateState = 1;
          let changed = this.viewState.measure(this);
          if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
            break;
          if (i > 5) {
            console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
            break;
          }
          let measuring = [];
          if (!(changed & 4))
            [this.measureRequests, measuring] = [measuring, this.measureRequests];
          let measured = measuring.map((m) => {
            try {
              return m.read(this);
            } catch (e) {
              logException(this.state, e);
              return BadMeasure;
            }
          });
          let update = ViewUpdate.create(this, this.state, []), redrawn = false;
          update.flags |= changed;
          if (!updated)
            updated = update;
          else
            updated.flags |= changed;
          this.updateState = 2;
          if (!update.empty) {
            this.updatePlugins(update);
            this.inputState.update(update);
            this.updateAttrs();
            redrawn = this.docView.update(update);
          }
          for (let i2 = 0; i2 < measuring.length; i2++)
            if (measured[i2] != BadMeasure) {
              try {
                let m = measuring[i2];
                if (m.write)
                  m.write(measured[i2], this);
              } catch (e) {
                logException(this.state, e);
              }
            }
          if (redrawn)
            this.docView.updateSelection(true);
          if (!update.viewportChanged && this.measureRequests.length == 0) {
            if (this.viewState.editorHeight) {
              if (this.viewState.scrollTarget) {
                this.docView.scrollIntoView(this.viewState.scrollTarget);
                this.viewState.scrollTarget = null;
                continue;
              } else {
                let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
                let diff = newAnchorHeight - scrollAnchorHeight;
                if (diff > 1 || diff < -1) {
                  scrollTop = scrollTop + diff;
                  sDOM.scrollTop = scrollTop / this.scaleY;
                  scrollAnchorHeight = -1;
                  continue;
                }
              }
            }
            break;
          }
        }
      } finally {
        this.updateState = 0;
        this.measureScheduled = -1;
      }
      if (updated && !updated.empty)
        for (let listener of this.state.facet(updateListener))
          listener(updated);
    }
    get themeClasses() {
      return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
    }
    updateAttrs() {
      let editorAttrs = attrsFromFacet(this, editorAttributes, {
        class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
      });
      let contentAttrs = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        translate: "no",
        contenteditable: !this.state.facet(editable) ? "false" : "true",
        class: "cm-content",
        style: `${browser.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true"
      };
      if (this.state.readOnly)
        contentAttrs["aria-readonly"] = "true";
      attrsFromFacet(this, contentAttributes, contentAttrs);
      let changed = this.observer.ignore(() => {
        let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
        let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
        return changedContent || changedEditor;
      });
      this.editorAttrs = editorAttrs;
      this.contentAttrs = contentAttrs;
      return changed;
    }
    showAnnouncements(trs) {
      let first = true;
      for (let tr3 of trs)
        for (let effect of tr3.effects)
          if (effect.is(EditorView.announce)) {
            if (first)
              this.announceDOM.textContent = "";
            first = false;
            let div = this.announceDOM.appendChild(document.createElement("div"));
            div.textContent = effect.value;
          }
    }
    mountStyles() {
      this.styleModules = this.state.facet(styleModule);
      let nonce = this.state.facet(EditorView.cspNonce);
      StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : void 0);
    }
    readMeasured() {
      if (this.updateState == 2)
        throw new Error("Reading the editor layout isn't allowed during an update");
      if (this.updateState == 0 && this.measureScheduled > -1)
        this.measure(false);
    }
    requestMeasure(request) {
      if (this.measureScheduled < 0)
        this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
      if (request) {
        if (this.measureRequests.indexOf(request) > -1)
          return;
        if (request.key != null)
          for (let i = 0; i < this.measureRequests.length; i++) {
            if (this.measureRequests[i].key === request.key) {
              this.measureRequests[i] = request;
              return;
            }
          }
        this.measureRequests.push(request);
      }
    }
    plugin(plugin) {
      let known = this.pluginMap.get(plugin);
      if (known === void 0 || known && known.spec != plugin)
        this.pluginMap.set(plugin, known = this.plugins.find((p) => p.spec == plugin) || null);
      return known && known.update(this).value;
    }
    get documentTop() {
      return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    get documentPadding() {
      return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
    }
    get scaleX() {
      return this.viewState.scaleX;
    }
    get scaleY() {
      return this.viewState.scaleY;
    }
    elementAtHeight(height) {
      this.readMeasured();
      return this.viewState.elementAtHeight(height);
    }
    lineBlockAtHeight(height) {
      this.readMeasured();
      return this.viewState.lineBlockAtHeight(height);
    }
    get viewportLineBlocks() {
      return this.viewState.viewportLines;
    }
    lineBlockAt(pos) {
      return this.viewState.lineBlockAt(pos);
    }
    get contentHeight() {
      return this.viewState.contentHeight;
    }
    moveByChar(start2, forward18, by) {
      return skipAtoms(this, start2, moveByChar(this, start2, forward18, by));
    }
    moveByGroup(start2, forward18) {
      return skipAtoms(this, start2, moveByChar(this, start2, forward18, (initial) => byGroup(this, start2.head, initial)));
    }
    moveToLineBoundary(start2, forward18, includeWrap = true) {
      return moveToLineBoundary(this, start2, forward18, includeWrap);
    }
    moveVertically(start2, forward18, distance) {
      return skipAtoms(this, start2, moveVertically(this, start2, forward18, distance));
    }
    domAtPos(pos) {
      return this.docView.domAtPos(pos);
    }
    posAtDOM(node, offset = 0) {
      return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
      this.readMeasured();
      return posAtCoords(this, coords, precise);
    }
    coordsAtPos(pos, side = 1) {
      this.readMeasured();
      let rect = this.docView.coordsAt(pos, side);
      if (!rect || rect.left == rect.right)
        return rect;
      let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
      let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
      return flattenRect(rect, span.dir == Direction.LTR == side > 0);
    }
    coordsForChar(pos) {
      this.readMeasured();
      return this.docView.coordsForChar(pos);
    }
    get defaultCharacterWidth() {
      return this.viewState.heightOracle.charWidth;
    }
    get defaultLineHeight() {
      return this.viewState.heightOracle.lineHeight;
    }
    get textDirection() {
      return this.viewState.defaultTextDirection;
    }
    textDirectionAt(pos) {
      let perLine = this.state.facet(perLineTextDirection);
      if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
        return this.textDirection;
      this.readMeasured();
      return this.docView.textDirectionAt(pos);
    }
    get lineWrapping() {
      return this.viewState.heightOracle.lineWrapping;
    }
    bidiSpans(line) {
      if (line.length > MaxBidiLine)
        return trivialOrder(line.length);
      let dir = this.textDirectionAt(line.from), isolates;
      for (let entry of this.bidiCache) {
        if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line.from, line.to))))
          return entry.order;
      }
      if (!isolates)
        isolates = getIsolatedRanges(this, line.from, line.to);
      let order = computeOrder(line.text, dir, isolates);
      this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
      return order;
    }
    get hasFocus() {
      var _a3;
      return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a3 = this.inputState) === null || _a3 === void 0 ? void 0 : _a3.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
    }
    focus() {
      this.observer.ignore(() => {
        focusPreventScroll(this.contentDOM);
        this.docView.updateSelection();
      });
    }
    setRoot(root) {
      if (this._root != root) {
        this._root = root;
        this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
        this.mountStyles();
      }
    }
    destroy() {
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.plugins = [];
      this.inputState.destroy();
      this.docView.destroy();
      this.dom.remove();
      this.observer.destroy();
      if (this.measureScheduled > -1)
        this.win.cancelAnimationFrame(this.measureScheduled);
      this.destroyed = true;
    }
    static scrollIntoView(pos, options = {}) {
      return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
    }
    scrollSnapshot() {
      let { scrollTop, scrollLeft } = this.scrollDOM;
      let ref = this.viewState.scrollAnchorAt(scrollTop);
      return scrollIntoView.of(new ScrollTarget(EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
    }
    static domEventHandlers(handlers2) {
      return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
    }
    static domEventObservers(observers2) {
      return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
    }
    static theme(spec, options) {
      let prefix = StyleModule.newName();
      let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
      if (options && options.dark)
        result.push(darkTheme.of(true));
      return result;
    }
    static baseTheme(spec) {
      return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    static findFromDOM(dom) {
      var _a3;
      let content2 = dom.querySelector(".cm-content");
      let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
      return ((_a3 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a3 === void 0 ? void 0 : _a3.view) || null;
    }
  };
  EditorView.styleModule = styleModule;
  EditorView.inputHandler = inputHandler;
  EditorView.focusChangeEffect = focusChangeEffect;
  EditorView.perLineTextDirection = perLineTextDirection;
  EditorView.exceptionSink = exceptionSink;
  EditorView.updateListener = updateListener;
  EditorView.editable = editable;
  EditorView.mouseSelectionStyle = mouseSelectionStyle;
  EditorView.dragMovesSelection = dragMovesSelection$1;
  EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
  EditorView.decorations = decorations;
  EditorView.atomicRanges = atomicRanges;
  EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
  EditorView.scrollMargins = scrollMargins;
  EditorView.darkTheme = darkTheme;
  EditorView.cspNonce = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : "" });
  EditorView.contentAttributes = contentAttributes;
  EditorView.editorAttributes = editorAttributes;
  EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
  EditorView.announce = /* @__PURE__ */ StateEffect.define();
  var MaxBidiLine = 4096;
  var BadMeasure = {};
  var CachedOrder = class {
    constructor(from17, to10, dir, isolates, fresh, order) {
      this.from = from17;
      this.to = to10;
      this.dir = dir;
      this.isolates = isolates;
      this.fresh = fresh;
      this.order = order;
    }
    static update(cache, changes) {
      if (changes.empty && !cache.some((c2) => c2.fresh))
        return cache;
      let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
      for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
        let entry = cache[i];
        if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
          result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
      }
      return result;
    }
  };
  function attrsFromFacet(view, facet, base2) {
    for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
      let source = sources[i], value = typeof source == "function" ? source(view) : source;
      if (value)
        combineAttrs(value, base2);
    }
    return base2;
  }
  var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
  function normalizeKeyName(name2, platform) {
    const parts = name2.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt, ctrl, shift2, meta2;
    for (let i = 0; i < parts.length - 1; ++i) {
      const mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod))
        meta2 = true;
      else if (/^a(lt)?$/i.test(mod))
        alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod))
        shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (platform == "mac")
          meta2 = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta2)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function modifiers(name2, event2, shift2) {
    if (event2.altKey)
      name2 = "Alt-" + name2;
    if (event2.ctrlKey)
      name2 = "Ctrl-" + name2;
    if (event2.metaKey)
      name2 = "Meta-" + name2;
    if (shift2 !== false && event2.shiftKey)
      name2 = "Shift-" + name2;
    return name2;
  }
  var handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
    keydown(event2, view) {
      return runHandlers(getKeymap(view.state), event2, view, "editor");
    }
  }));
  var keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
  var Keymaps = /* @__PURE__ */ new WeakMap();
  function getKeymap(state) {
    let bindings = state.facet(keymap);
    let map3 = Keymaps.get(bindings);
    if (!map3)
      Keymaps.set(bindings, map3 = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
    return map3;
  }
  function runScopeHandlers(view, event2, scope) {
    return runHandlers(getKeymap(view.state), event2, view, scope);
  }
  var storedPrefix = null;
  var PrefixTimeout = 4e3;
  function buildKeymap(bindings, platform = currentPlatform) {
    let bound = Object.create(null);
    let isPrefix = Object.create(null);
    let checkPrefix = (name2, is18) => {
      let current = isPrefix[name2];
      if (current == null)
        isPrefix[name2] = is18;
      else if (current != is18)
        throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add17 = (scope, key, command2, preventDefault, stopPropagation) => {
      var _a3, _b;
      let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
      let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
      for (let i = 1; i < parts.length; i++) {
        let prefix = parts.slice(0, i).join(" ");
        checkPrefix(prefix, true);
        if (!scopeObj[prefix])
          scopeObj[prefix] = {
            preventDefault: true,
            stopPropagation: false,
            run: [(view) => {
              let ourObj = storedPrefix = { view, prefix, scope };
              setTimeout(() => {
                if (storedPrefix == ourObj)
                  storedPrefix = null;
              }, PrefixTimeout);
              return true;
            }]
          };
      }
      let full = parts.join(" ");
      checkPrefix(full, false);
      let binding = scopeObj[full] || (scopeObj[full] = {
        preventDefault: false,
        stopPropagation: false,
        run: ((_b = (_a3 = scopeObj._any) === null || _a3 === void 0 ? void 0 : _a3.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
      });
      if (command2)
        binding.run.push(command2);
      if (preventDefault)
        binding.preventDefault = true;
      if (stopPropagation)
        binding.stopPropagation = true;
    };
    for (let b of bindings) {
      let scopes = b.scope ? b.scope.split(" ") : ["editor"];
      if (b.any)
        for (let scope of scopes) {
          let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
          if (!scopeObj._any)
            scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
          for (let key in scopeObj)
            scopeObj[key].run.push(b.any);
        }
      let name2 = b[platform] || b.key;
      if (!name2)
        continue;
      for (let scope of scopes) {
        add17(scope, name2, b.run, b.preventDefault, b.stopPropagation);
        if (b.shift)
          add17(scope, "Shift-" + name2, b.shift, b.preventDefault, b.stopPropagation);
      }
    }
    return bound;
  }
  function runHandlers(map3, event2, view, scope) {
    let name2 = keyName(event2);
    let charCode = codePointAt(name2, 0), isChar = codePointSize(charCode) == name2.length && name2 != " ";
    let prefix = "", handled = false, prevented = false, stopPropagation = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
      prefix = storedPrefix.prefix + " ";
      if (modifierCodes.indexOf(event2.keyCode) < 0) {
        prevented = true;
        storedPrefix = null;
      }
    }
    let ran = new Set();
    let runFor = (binding) => {
      if (binding) {
        for (let cmd2 of binding.run)
          if (!ran.has(cmd2)) {
            ran.add(cmd2);
            if (cmd2(view, event2)) {
              if (binding.stopPropagation)
                stopPropagation = true;
              return true;
            }
          }
        if (binding.preventDefault) {
          if (binding.stopPropagation)
            stopPropagation = true;
          prevented = true;
        }
      }
      return false;
    };
    let scopeObj = map3[scope], baseName, shiftName;
    if (scopeObj) {
      if (runFor(scopeObj[prefix + modifiers(name2, event2, !isChar)])) {
        handled = true;
      } else if (isChar && (event2.altKey || event2.metaKey || event2.ctrlKey) && !(browser.windows && event2.ctrlKey && event2.altKey) && (baseName = base[event2.keyCode]) && baseName != name2) {
        if (runFor(scopeObj[prefix + modifiers(baseName, event2, true)])) {
          handled = true;
        } else if (event2.shiftKey && (shiftName = shift[event2.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event2, false)])) {
          handled = true;
        }
      } else if (isChar && event2.shiftKey && runFor(scopeObj[prefix + modifiers(name2, event2, true)])) {
        handled = true;
      }
      if (!handled && runFor(scopeObj._any))
        handled = true;
    }
    if (prevented)
      handled = true;
    if (handled && stopPropagation)
      event2.stopPropagation();
    return handled;
  }
  var RectangleMarker = class {
    constructor(className, left, top2, width, height) {
      this.className = className;
      this.left = left;
      this.top = top2;
      this.width = width;
      this.height = height;
    }
    draw() {
      let elt = document.createElement("div");
      elt.className = this.className;
      this.adjust(elt);
      return elt;
    }
    update(elt, prev) {
      if (prev.className != this.className)
        return false;
      this.adjust(elt);
      return true;
    }
    adjust(elt) {
      elt.style.left = this.left + "px";
      elt.style.top = this.top + "px";
      if (this.width != null)
        elt.style.width = this.width + "px";
      elt.style.height = this.height + "px";
    }
    eq(p) {
      return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
    }
    static forRange(view, className, range10) {
      if (range10.empty) {
        let pos = view.coordsAtPos(range10.head, range10.assoc || 1);
        if (!pos)
          return [];
        let base2 = getBase(view);
        return [new RectangleMarker(className, pos.left - base2.left, pos.top - base2.top, null, pos.bottom - pos.top)];
      } else {
        return rectanglesForRange(view, className, range10);
      }
    }
  };
  function getBase(view) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
    return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
  }
  function wrappedLine(view, pos, inside2) {
    let range10 = EditorSelection.cursor(pos);
    return {
      from: Math.max(inside2.from, view.moveToLineBoundary(range10, false, true).from),
      to: Math.min(inside2.to, view.moveToLineBoundary(range10, true, true).from),
      type: BlockType.Text
    };
  }
  function rectanglesForRange(view, className, range10) {
    if (range10.to <= view.viewport.from || range10.from >= view.viewport.to)
      return [];
    let from17 = Math.max(range10.from, view.viewport.from), to10 = Math.min(range10.to, view.viewport.to);
    let ltr = view.textDirection == Direction.LTR;
    let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
    let lineElt = content2.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
    let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
    let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
    let startBlock = blockAt(view, from17), endBlock = blockAt(view, to10);
    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
    if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
      visualStart = wrappedLine(view, from17, visualStart);
    if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
      visualEnd = wrappedLine(view, to10, visualEnd);
    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
      return pieces(drawForLine(range10.from, range10.to, visualStart));
    } else {
      let top2 = visualStart ? drawForLine(range10.from, null, visualStart) : drawForWidget(startBlock, false);
      let bottom = visualEnd ? drawForLine(null, range10.to, visualEnd) : drawForWidget(endBlock, true);
      let between = [];
      if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top2.bottom + view.defaultLineHeight / 2 < bottom.top)
        between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
      else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text)
        top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
      return pieces(top2).concat(between).concat(pieces(bottom));
    }
    function piece(left, top2, right, bottom) {
      return new RectangleMarker(className, left - base2.left, top2 - base2.top - 0.01, right - left, bottom - top2 + 0.01);
    }
    function pieces({ top: top2, bottom, horizontal }) {
      let pieces2 = [];
      for (let i = 0; i < horizontal.length; i += 2)
        pieces2.push(piece(horizontal[i], top2, horizontal[i + 1], bottom));
      return pieces2;
    }
    function drawForLine(from18, to11, line) {
      let top2 = 1e9, bottom = -1e9, horizontal = [];
      function addSpan(from19, fromOpen, to12, toOpen, dir) {
        let fromCoords = view.coordsAtPos(from19, from19 == line.to ? -2 : 2);
        let toCoords = view.coordsAtPos(to12, to12 == line.from ? 2 : -2);
        if (!fromCoords || !toCoords)
          return;
        top2 = Math.min(fromCoords.top, toCoords.top, top2);
        bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
        if (dir == Direction.LTR)
          horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
        else
          horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
      }
      let start2 = from18 !== null && from18 !== void 0 ? from18 : line.from, end = to11 !== null && to11 !== void 0 ? to11 : line.to;
      for (let r of view.visibleRanges)
        if (r.to > start2 && r.from < end) {
          for (let pos = Math.max(r.from, start2), endPos = Math.min(r.to, end); ; ) {
            let docLine = view.state.doc.lineAt(pos);
            for (let span of view.bidiSpans(docLine)) {
              let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
              if (spanFrom >= endPos)
                break;
              if (spanTo > pos)
                addSpan(Math.max(spanFrom, pos), from18 == null && spanFrom <= start2, Math.min(spanTo, endPos), to11 == null && spanTo >= end, span.dir);
            }
            pos = docLine.to + 1;
            if (pos >= endPos)
              break;
          }
        }
      if (horizontal.length == 0)
        addSpan(start2, from18 == null, end, to11 == null, view.textDirection);
      return { top: top2, bottom, horizontal };
    }
    function drawForWidget(block, top2) {
      let y2 = contentRect.top + (top2 ? block.top : block.bottom);
      return { top: y2, bottom: y2, horizontal: [] };
    }
  }
  function sameMarker(a, b) {
    return a.constructor == b.constructor && a.eq(b);
  }
  var LayerView = class {
    constructor(view, layer2) {
      this.view = view;
      this.layer = layer2;
      this.drawn = [];
      this.scaleX = 1;
      this.scaleY = 1;
      this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
      this.dom = view.scrollDOM.appendChild(document.createElement("div"));
      this.dom.classList.add("cm-layer");
      if (layer2.above)
        this.dom.classList.add("cm-layer-above");
      if (layer2.class)
        this.dom.classList.add(layer2.class);
      this.scale();
      this.dom.setAttribute("aria-hidden", "true");
      this.setOrder(view.state);
      view.requestMeasure(this.measureReq);
      if (layer2.mount)
        layer2.mount(this.dom, view);
    }
    update(update) {
      if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
        this.setOrder(update.state);
      if (this.layer.update(update, this.dom) || update.geometryChanged) {
        this.scale();
        update.view.requestMeasure(this.measureReq);
      }
    }
    setOrder(state) {
      let pos = 0, order = state.facet(layerOrder);
      while (pos < order.length && order[pos] != this.layer)
        pos++;
      this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
    }
    measure() {
      return this.layer.markers(this.view);
    }
    scale() {
      let { scaleX, scaleY } = this.view;
      if (scaleX != this.scaleX || scaleY != this.scaleY) {
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
      }
    }
    draw(markers) {
      if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
        let old = this.dom.firstChild, oldI = 0;
        for (let marker of markers) {
          if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
            old = old.nextSibling;
            oldI++;
          } else {
            this.dom.insertBefore(marker.draw(), old);
          }
        }
        while (old) {
          let next = old.nextSibling;
          old.remove();
          old = next;
        }
        this.drawn = markers;
      }
    }
    destroy() {
      if (this.layer.destroy)
        this.layer.destroy(this.dom, this.view);
      this.dom.remove();
    }
  };
  var layerOrder = /* @__PURE__ */ Facet.define();
  function layer(config) {
    return [
      ViewPlugin.define((v) => new LayerView(v, config)),
      layerOrder.of(config)
    ];
  }
  var CanHidePrimary = !browser.ios;
  var selectionConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        cursorBlinkRate: 1200,
        drawRangeCursor: true
      }, {
        cursorBlinkRate: (a, b) => Math.min(a, b),
        drawRangeCursor: (a, b) => a || b
      });
    }
  });
  function drawSelection(config = {}) {
    return [
      selectionConfig.of(config),
      cursorLayer,
      selectionLayer,
      hideNativeSelection,
      nativeSelectionHidden.of(true)
    ];
  }
  function configChanged(update) {
    return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
  }
  var cursorLayer = /* @__PURE__ */ layer({
    above: true,
    markers(view) {
      let { state } = view, conf = state.facet(selectionConfig);
      let cursors = [];
      for (let r of state.selection.ranges) {
        let prim = r == state.selection.main;
        if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
          let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
          let cursor = r.empty ? r : EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
          for (let piece of RectangleMarker.forRange(view, className, cursor))
            cursors.push(piece);
        }
      }
      return cursors;
    },
    update(update, dom) {
      if (update.transactions.some((tr3) => tr3.selection))
        dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
      let confChange = configChanged(update);
      if (confChange)
        setBlinkRate(update.state, dom);
      return update.docChanged || update.selectionSet || confChange;
    },
    mount(dom, view) {
      setBlinkRate(view.state, dom);
    },
    class: "cm-cursorLayer"
  });
  function setBlinkRate(state, dom) {
    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
  }
  var selectionLayer = /* @__PURE__ */ layer({
    above: false,
    markers(view) {
      return view.state.selection.ranges.map((r) => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r)).reduce((a, b) => a.concat(b));
    },
    update(update, dom) {
      return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
    },
    class: "cm-selectionLayer"
  });
  var themeSpec = {
    ".cm-line": {
      "& ::selection": { backgroundColor: "transparent !important" },
      "&::selection": { backgroundColor: "transparent !important" }
    }
  };
  if (CanHidePrimary) {
    themeSpec[".cm-line"].caretColor = "transparent !important";
    themeSpec[".cm-content"] = { caretColor: "transparent !important" };
  }
  var hideNativeSelection = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.theme(themeSpec));
  var setDropCursorPos = /* @__PURE__ */ StateEffect.define({
    map(pos, mapping) {
      return pos == null ? null : mapping.mapPos(pos);
    }
  });
  var dropCursorPos = /* @__PURE__ */ StateField.define({
    create() {
      return null;
    },
    update(pos, tr3) {
      if (pos != null)
        pos = tr3.changes.mapPos(pos);
      return tr3.effects.reduce((pos2, e) => e.is(setDropCursorPos) ? e.value : pos2, pos);
    }
  });
  var drawDropCursor = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.cursor = null;
      this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
    }
    update(update) {
      var _a3;
      let cursorPos = update.state.field(dropCursorPos);
      if (cursorPos == null) {
        if (this.cursor != null) {
          (_a3 = this.cursor) === null || _a3 === void 0 ? void 0 : _a3.remove();
          this.cursor = null;
        }
      } else {
        if (!this.cursor) {
          this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
          this.cursor.className = "cm-dropCursor";
        }
        if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
          this.view.requestMeasure(this.measureReq);
      }
    }
    readPos() {
      let { view } = this;
      let pos = view.state.field(dropCursorPos);
      let rect = pos != null && view.coordsAtPos(pos);
      if (!rect)
        return null;
      let outer = view.scrollDOM.getBoundingClientRect();
      return {
        left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
        top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
        height: rect.bottom - rect.top
      };
    }
    drawCursor(pos) {
      if (this.cursor) {
        let { scaleX, scaleY } = this.view;
        if (pos) {
          this.cursor.style.left = pos.left / scaleX + "px";
          this.cursor.style.top = pos.top / scaleY + "px";
          this.cursor.style.height = pos.height / scaleY + "px";
        } else {
          this.cursor.style.left = "-100000px";
        }
      }
    }
    destroy() {
      if (this.cursor)
        this.cursor.remove();
    }
    setDropPos(pos) {
      if (this.view.state.field(dropCursorPos) != pos)
        this.view.dispatch({ effects: setDropCursorPos.of(pos) });
    }
  }, {
    eventObservers: {
      dragover(event2) {
        this.setDropPos(this.view.posAtCoords({ x: event2.clientX, y: event2.clientY }));
      },
      dragleave(event2) {
        if (event2.target == this.view.contentDOM || !this.view.contentDOM.contains(event2.relatedTarget))
          this.setDropPos(null);
      },
      dragend() {
        this.setDropPos(null);
      },
      drop() {
        this.setDropPos(null);
      }
    }
  });
  function dropCursor() {
    return [dropCursorPos, drawDropCursor];
  }
  function iterMatches(doc2, re, from17, to10, f) {
    re.lastIndex = 0;
    for (let cursor = doc2.iterRange(from17, to10), pos = from17, m; !cursor.next().done; pos += cursor.value.length) {
      if (!cursor.lineBreak)
        while (m = re.exec(cursor.value))
          f(pos + m.index, m);
    }
  }
  function matchRanges(view, maxLength) {
    let visible = view.visibleRanges;
    if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
      return visible;
    let result = [];
    for (let { from: from17, to: to10 } of visible) {
      from17 = Math.max(view.state.doc.lineAt(from17).from, from17 - maxLength);
      to10 = Math.min(view.state.doc.lineAt(to10).to, to10 + maxLength);
      if (result.length && result[result.length - 1].to >= from17)
        result[result.length - 1].to = to10;
      else
        result.push({ from: from17, to: to10 });
    }
    return result;
  }
  var MatchDecorator = class {
    constructor(config) {
      const { regexp, decoration, decorate, boundary, maxLength = 1e3 } = config;
      if (!regexp.global)
        throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
      this.regexp = regexp;
      if (decorate) {
        this.addMatch = (match, view, from17, add17) => decorate(add17, from17, from17 + match[0].length, match, view);
      } else if (typeof decoration == "function") {
        this.addMatch = (match, view, from17, add17) => {
          let deco = decoration(match, view, from17);
          if (deco)
            add17(from17, from17 + match[0].length, deco);
        };
      } else if (decoration) {
        this.addMatch = (match, _view, from17, add17) => add17(from17, from17 + match[0].length, decoration);
      } else {
        throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
      }
      this.boundary = boundary;
      this.maxLength = maxLength;
    }
    createDeco(view) {
      let build = new RangeSetBuilder(), add17 = build.add.bind(build);
      for (let { from: from17, to: to10 } of matchRanges(view, this.maxLength))
        iterMatches(view.state.doc, this.regexp, from17, to10, (from18, m) => this.addMatch(m, view, from18, add17));
      return build.finish();
    }
    updateDeco(update, deco) {
      let changeFrom = 1e9, changeTo = -1;
      if (update.docChanged)
        update.changes.iterChanges((_f, _t2, from17, to10) => {
          if (to10 > update.view.viewport.from && from17 < update.view.viewport.to) {
            changeFrom = Math.min(from17, changeFrom);
            changeTo = Math.max(to10, changeTo);
          }
        });
      if (update.viewportChanged || changeTo - changeFrom > 1e3)
        return this.createDeco(update.view);
      if (changeTo > -1)
        return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
      return deco;
    }
    updateRange(view, deco, updateFrom, updateTo) {
      for (let r of view.visibleRanges) {
        let from17 = Math.max(r.from, updateFrom), to10 = Math.min(r.to, updateTo);
        if (to10 > from17) {
          let fromLine = view.state.doc.lineAt(from17), toLine = fromLine.to < to10 ? view.state.doc.lineAt(to10) : fromLine;
          let start2 = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
          if (this.boundary) {
            for (; from17 > fromLine.from; from17--)
              if (this.boundary.test(fromLine.text[from17 - 1 - fromLine.from])) {
                start2 = from17;
                break;
              }
            for (; to10 < toLine.to; to10++)
              if (this.boundary.test(toLine.text[to10 - toLine.from])) {
                end = to10;
                break;
              }
          }
          let ranges = [], m;
          let add17 = (from18, to11, deco2) => ranges.push(deco2.range(from18, to11));
          if (fromLine == toLine) {
            this.regexp.lastIndex = start2 - fromLine.from;
            while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
              this.addMatch(m, view, m.index + fromLine.from, add17);
          } else {
            iterMatches(view.state.doc, this.regexp, start2, end, (from18, m2) => this.addMatch(m2, view, from18, add17));
          }
          deco = deco.update({ filterFrom: start2, filterTo: end, filter: (from18, to11) => from18 < start2 || to11 > end, add: ranges });
        }
      }
      return deco;
    }
  };
  var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
  var Specials = /* @__PURE__ */ new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
  var Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
  };
  var _supportsTabSize = null;
  function supportsTabSize() {
    var _a3;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
      let styles = document.body.style;
      _supportsTabSize = ((_a3 = styles.tabSize) !== null && _a3 !== void 0 ? _a3 : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
  }
  var specialCharConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let config = combineConfig(configs, {
        render: null,
        specialChars: Specials,
        addSpecialChars: null
      });
      if (config.replaceTabs = !supportsTabSize())
        config.specialChars = new RegExp("	|" + config.specialChars.source, UnicodeRegexpSupport);
      if (config.addSpecialChars)
        config.specialChars = new RegExp(config.specialChars.source + "|" + config.addSpecialChars.source, UnicodeRegexpSupport);
      return config;
    }
  });
  function highlightSpecialChars(config = {}) {
    return [specialCharConfig.of(config), specialCharPlugin()];
  }
  var _plugin = null;
  function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.decorations = Decoration.none;
        this.decorationCache = Object.create(null);
        this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
        this.decorations = this.decorator.createDeco(view);
      }
      makeDecorator(conf) {
        return new MatchDecorator({
          regexp: conf.specialChars,
          decoration: (m, view, pos) => {
            let { doc: doc2 } = view.state;
            let code = codePointAt(m[0], 0);
            if (code == 9) {
              let line = doc2.lineAt(pos);
              let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
              return Decoration.replace({
                widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)
              });
            }
            return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
          },
          boundary: conf.replaceTabs ? void 0 : /[^]/
        });
      }
      update(update) {
        let conf = update.state.facet(specialCharConfig);
        if (update.startState.facet(specialCharConfig) != conf) {
          this.decorator = this.makeDecorator(conf);
          this.decorations = this.decorator.createDeco(update.view);
        } else {
          this.decorations = this.decorator.updateDeco(update, this.decorations);
        }
      }
    }, {
      decorations: (v) => v.decorations
    }));
  }
  var DefaultPlaceholder = "\u2022";
  function placeholder$1(code) {
    if (code >= 32)
      return DefaultPlaceholder;
    if (code == 10)
      return "\u2424";
    return String.fromCharCode(9216 + code);
  }
  var SpecialCharWidget = class extends WidgetType {
    constructor(options, code) {
      super();
      this.options = options;
      this.code = code;
    }
    eq(other) {
      return other.code == this.code;
    }
    toDOM(view) {
      let ph2 = placeholder$1(this.code);
      let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
      let custom = this.options.render && this.options.render(this.code, desc, ph2);
      if (custom)
        return custom;
      let span = document.createElement("span");
      span.textContent = ph2;
      span.title = desc;
      span.setAttribute("aria-label", desc);
      span.className = "cm-specialChar";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  };
  var TabWidget = class extends WidgetType {
    constructor(width) {
      super();
      this.width = width;
    }
    eq(other) {
      return other.width == this.width;
    }
    toDOM() {
      let span = document.createElement("span");
      span.textContent = "	";
      span.className = "cm-tab";
      span.style.width = this.width + "px";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  };
  function highlightActiveLine() {
    return activeLineHighlighter;
  }
  var lineDeco = /* @__PURE__ */ Decoration.line({ class: "cm-activeLine" });
  var activeLineHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.decorations = this.getDeco(view);
    }
    update(update) {
      if (update.docChanged || update.selectionSet)
        this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
      let lastLineStart = -1, deco = [];
      for (let r of view.state.selection.ranges) {
        let line = view.lineBlockAt(r.head);
        if (line.from > lastLineStart) {
          deco.push(lineDeco.range(line.from));
          lastLineStart = line.from;
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v) => v.decorations
  });
  var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip": {
      zIndex: 100,
      boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
      border: "1px solid #bbb",
      backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
      borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tooltip-arrow": {
      height: `${7}px`,
      width: `${7 * 2}px`,
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: `${7}px solid transparent`,
        borderRight: `${7}px solid transparent`
      },
      ".cm-tooltip-above &": {
        bottom: `-${7}px`,
        "&:before": {
          borderTop: `${7}px solid #bbb`
        },
        "&:after": {
          borderTop: `${7}px solid #f5f5f5`,
          bottom: "1px"
        }
      },
      ".cm-tooltip-below &": {
        top: `-${7}px`,
        "&:before": {
          borderBottom: `${7}px solid #bbb`
        },
        "&:after": {
          borderBottom: `${7}px solid #f5f5f5`,
          top: "1px"
        }
      }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": {
        borderTopColor: "#333338",
        borderBottomColor: "#333338"
      },
      "&:after": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      }
    }
  });
  var panelConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let topContainer, bottomContainer;
      for (let c2 of configs) {
        topContainer = topContainer || c2.topContainer;
        bottomContainer = bottomContainer || c2.bottomContainer;
      }
      return { topContainer, bottomContainer };
    }
  });
  function getPanel(view, panel) {
    let plugin = view.plugin(panelPlugin);
    let index3 = plugin ? plugin.specs.indexOf(panel) : -1;
    return index3 > -1 ? plugin.panels[index3] : null;
  }
  var panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.input = view.state.facet(showPanel);
      this.specs = this.input.filter((s) => s);
      this.panels = this.specs.map((spec) => spec(view));
      let conf = view.state.facet(panelConfig);
      this.top = new PanelGroup(view, true, conf.topContainer);
      this.bottom = new PanelGroup(view, false, conf.bottomContainer);
      this.top.sync(this.panels.filter((p) => p.top));
      this.bottom.sync(this.panels.filter((p) => !p.top));
      for (let p of this.panels) {
        p.dom.classList.add("cm-panel");
        if (p.mount)
          p.mount();
      }
    }
    update(update) {
      let conf = update.state.facet(panelConfig);
      if (this.top.container != conf.topContainer) {
        this.top.sync([]);
        this.top = new PanelGroup(update.view, true, conf.topContainer);
      }
      if (this.bottom.container != conf.bottomContainer) {
        this.bottom.sync([]);
        this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
      }
      this.top.syncClasses();
      this.bottom.syncClasses();
      let input2 = update.state.facet(showPanel);
      if (input2 != this.input) {
        let specs = input2.filter((x) => x);
        let panels = [], top2 = [], bottom = [], mount2 = [];
        for (let spec of specs) {
          let known = this.specs.indexOf(spec), panel;
          if (known < 0) {
            panel = spec(update.view);
            mount2.push(panel);
          } else {
            panel = this.panels[known];
            if (panel.update)
              panel.update(update);
          }
          panels.push(panel);
          (panel.top ? top2 : bottom).push(panel);
        }
        this.specs = specs;
        this.panels = panels;
        this.top.sync(top2);
        this.bottom.sync(bottom);
        for (let p of mount2) {
          p.dom.classList.add("cm-panel");
          if (p.mount)
            p.mount();
        }
      } else {
        for (let p of this.panels)
          if (p.update)
            p.update(update);
      }
    }
    destroy() {
      this.top.sync([]);
      this.bottom.sync([]);
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view) => {
      let value = view.plugin(plugin);
      return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
    })
  });
  var PanelGroup = class {
    constructor(view, top2, container) {
      this.view = view;
      this.top = top2;
      this.container = container;
      this.dom = void 0;
      this.classes = "";
      this.panels = [];
      this.syncClasses();
    }
    sync(panels) {
      for (let p of this.panels)
        if (p.destroy && panels.indexOf(p) < 0)
          p.destroy();
      this.panels = panels;
      this.syncDOM();
    }
    syncDOM() {
      if (this.panels.length == 0) {
        if (this.dom) {
          this.dom.remove();
          this.dom = void 0;
        }
        return;
      }
      if (!this.dom) {
        this.dom = document.createElement("div");
        this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
        this.dom.style[this.top ? "top" : "bottom"] = "0";
        let parent = this.container || this.view.dom;
        parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
      }
      let curDOM = this.dom.firstChild;
      for (let panel of this.panels) {
        if (panel.dom.parentNode == this.dom) {
          while (curDOM != panel.dom)
            curDOM = rm(curDOM);
          curDOM = curDOM.nextSibling;
        } else {
          this.dom.insertBefore(panel.dom, curDOM);
        }
      }
      while (curDOM)
        curDOM = rm(curDOM);
    }
    scrollMargin() {
      return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
      if (!this.container || this.classes == this.view.themeClasses)
        return;
      for (let cls of this.classes.split(" "))
        if (cls)
          this.container.classList.remove(cls);
      for (let cls of (this.classes = this.view.themeClasses).split(" "))
        if (cls)
          this.container.classList.add(cls);
    }
  };
  function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
  }
  var showPanel = /* @__PURE__ */ Facet.define({
    enables: panelPlugin
  });
  var GutterMarker = class extends RangeValue {
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    eq(other) {
      return false;
    }
    destroy(dom) {
    }
  };
  GutterMarker.prototype.elementClass = "";
  GutterMarker.prototype.toDOM = void 0;
  GutterMarker.prototype.mapMode = MapMode.TrackBefore;
  GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
  GutterMarker.prototype.point = true;
  var gutterLineClass = /* @__PURE__ */ Facet.define();
  var defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => RangeSet.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
  };
  var activeGutters = /* @__PURE__ */ Facet.define();
  function gutter(config) {
    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];
  }
  var unfixGutters = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x) => x)
  });
  function gutters(config) {
    let result = [
      gutterView
    ];
    if (config && config.fixed === false)
      result.push(unfixGutters.of(true));
    return result;
  }
  var gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.prevViewport = view.viewport;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutters";
      this.dom.setAttribute("aria-hidden", "true");
      this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
      this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
      for (let gutter2 of this.gutters)
        this.dom.appendChild(gutter2.dom);
      this.fixed = !view.state.facet(unfixGutters);
      if (this.fixed) {
        this.dom.style.position = "sticky";
      }
      this.syncGutters(false);
      view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    }
    update(update) {
      if (this.updateGutters(update)) {
        let vpA = this.prevViewport, vpB = update.view.viewport;
        let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
        this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
      }
      if (update.geometryChanged)
        this.dom.style.minHeight = this.view.contentHeight + "px";
      if (this.view.state.facet(unfixGutters) != !this.fixed) {
        this.fixed = !this.fixed;
        this.dom.style.position = this.fixed ? "sticky" : "";
      }
      this.prevViewport = update.view.viewport;
    }
    syncGutters(detach) {
      let after = this.dom.nextSibling;
      if (detach)
        this.dom.remove();
      let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
      let classSet = [];
      let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
      for (let line of this.view.viewportLineBlocks) {
        if (classSet.length)
          classSet = [];
        if (Array.isArray(line.type)) {
          let first = true;
          for (let b of line.type) {
            if (b.type == BlockType.Text && first) {
              advanceCursor(lineClasses, classSet, b.from);
              for (let cx of contexts)
                cx.line(this.view, b, classSet);
              first = false;
            } else if (b.widget) {
              for (let cx of contexts)
                cx.widget(this.view, b);
            }
          }
        } else if (line.type == BlockType.Text) {
          advanceCursor(lineClasses, classSet, line.from);
          for (let cx of contexts)
            cx.line(this.view, line, classSet);
        } else if (line.widget) {
          for (let cx of contexts)
            cx.widget(this.view, line);
        }
      }
      for (let cx of contexts)
        cx.finish();
      if (detach)
        this.view.scrollDOM.insertBefore(this.dom, after);
    }
    updateGutters(update) {
      let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);
      let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
      if (prev == cur) {
        for (let gutter2 of this.gutters)
          if (gutter2.update(update))
            change = true;
      } else {
        change = true;
        let gutters2 = [];
        for (let conf of cur) {
          let known = prev.indexOf(conf);
          if (known < 0) {
            gutters2.push(new SingleGutterView(this.view, conf));
          } else {
            this.gutters[known].update(update);
            gutters2.push(this.gutters[known]);
          }
        }
        for (let g of this.gutters) {
          g.dom.remove();
          if (gutters2.indexOf(g) < 0)
            g.destroy();
        }
        for (let g of gutters2)
          this.dom.appendChild(g.dom);
        this.gutters = gutters2;
      }
      return change;
    }
    destroy() {
      for (let view of this.gutters)
        view.destroy();
      this.dom.remove();
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view) => {
      let value = view.plugin(plugin);
      if (!value || value.gutters.length == 0 || !value.fixed)
        return null;
      return view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth * view.scaleX } : { right: value.dom.offsetWidth * view.scaleX };
    })
  });
  function asArray2(val) {
    return Array.isArray(val) ? val : [val];
  }
  function advanceCursor(cursor, collect, pos) {
    while (cursor.value && cursor.from <= pos) {
      if (cursor.from == pos)
        collect.push(cursor.value);
      cursor.next();
    }
  }
  var UpdateContext = class {
    constructor(gutter2, viewport, height) {
      this.gutter = gutter2;
      this.height = height;
      this.i = 0;
      this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
    }
    addElement(view, block, markers) {
      let { gutter: gutter2 } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
      if (this.i == gutter2.elements.length) {
        let newElt = new GutterElement(view, height, above, markers);
        gutter2.elements.push(newElt);
        gutter2.dom.appendChild(newElt.dom);
      } else {
        gutter2.elements[this.i].update(view, height, above, markers);
      }
      this.height = block.bottom;
      this.i++;
    }
    line(view, line, extraMarkers) {
      let localMarkers = [];
      advanceCursor(this.cursor, localMarkers, line.from);
      if (extraMarkers.length)
        localMarkers = localMarkers.concat(extraMarkers);
      let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
      if (forLine)
        localMarkers.unshift(forLine);
      let gutter2 = this.gutter;
      if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
        return;
      this.addElement(view, line, localMarkers);
    }
    widget(view, block) {
      let marker = this.gutter.config.widgetMarker(view, block.widget, block);
      if (marker)
        this.addElement(view, block, [marker]);
    }
    finish() {
      let gutter2 = this.gutter;
      while (gutter2.elements.length > this.i) {
        let last = gutter2.elements.pop();
        gutter2.dom.removeChild(last.dom);
        last.destroy();
      }
    }
  };
  var SingleGutterView = class {
    constructor(view, config) {
      this.view = view;
      this.config = config;
      this.elements = [];
      this.spacer = null;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
      for (let prop in config.domEventHandlers) {
        this.dom.addEventListener(prop, (event2) => {
          let target = event2.target, y2;
          if (target != this.dom && this.dom.contains(target)) {
            while (target.parentNode != this.dom)
              target = target.parentNode;
            let rect = target.getBoundingClientRect();
            y2 = (rect.top + rect.bottom) / 2;
          } else {
            y2 = event2.clientY;
          }
          let line = view.lineBlockAtHeight(y2 - view.documentTop);
          if (config.domEventHandlers[prop](view, line, event2))
            event2.preventDefault();
        });
      }
      this.markers = asArray2(config.markers(view));
      if (config.initialSpacer) {
        this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
        this.dom.appendChild(this.spacer.dom);
        this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
      }
    }
    update(update) {
      let prevMarkers = this.markers;
      this.markers = asArray2(this.config.markers(update.view));
      if (this.spacer && this.config.updateSpacer) {
        let updated = this.config.updateSpacer(this.spacer.markers[0], update);
        if (updated != this.spacer.markers[0])
          this.spacer.update(update.view, 0, 0, [updated]);
      }
      let vp = update.view.viewport;
      return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
    }
    destroy() {
      for (let elt of this.elements)
        elt.destroy();
    }
  };
  var GutterElement = class {
    constructor(view, height, above, markers) {
      this.height = -1;
      this.above = 0;
      this.markers = [];
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutterElement";
      this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
      if (this.height != height) {
        this.height = height;
        this.dom.style.height = height + "px";
      }
      if (this.above != above)
        this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
      if (!sameMarkers(this.markers, markers))
        this.setMarkers(view, markers);
    }
    setMarkers(view, markers) {
      let cls = "cm-gutterElement", domPos = this.dom.firstChild;
      for (let iNew = 0, iOld = 0; ; ) {
        let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
        if (marker) {
          let c2 = marker.elementClass;
          if (c2)
            cls += " " + c2;
          for (let i = iOld; i < this.markers.length; i++)
            if (this.markers[i].compare(marker)) {
              skipTo = i;
              matched = true;
              break;
            }
        } else {
          skipTo = this.markers.length;
        }
        while (iOld < skipTo) {
          let next = this.markers[iOld++];
          if (next.toDOM) {
            next.destroy(domPos);
            let after = domPos.nextSibling;
            domPos.remove();
            domPos = after;
          }
        }
        if (!marker)
          break;
        if (marker.toDOM) {
          if (matched)
            domPos = domPos.nextSibling;
          else
            this.dom.insertBefore(marker.toDOM(view), domPos);
        }
        if (matched)
          iOld++;
      }
      this.dom.className = cls;
      this.markers = markers;
    }
    destroy() {
      this.setMarkers(null, []);
    }
  };
  function sameMarkers(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].compare(b[i]))
        return false;
    return true;
  }
  var lineNumberMarkers = /* @__PURE__ */ Facet.define();
  var lineNumberConfig = /* @__PURE__ */ Facet.define({
    combine(values) {
      return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
        domEventHandlers(a, b) {
          let result = Object.assign({}, a);
          for (let event2 in b) {
            let exists = result[event2], add17 = b[event2];
            result[event2] = exists ? (view, line, event3) => exists(view, line, event3) || add17(view, line, event3) : add17;
          }
          return result;
        }
      });
    }
  });
  var NumberMarker = class extends GutterMarker {
    constructor(number2) {
      super();
      this.number = number2;
    }
    eq(other) {
      return this.number == other.number;
    }
    toDOM() {
      return document.createTextNode(this.number);
    }
  };
  function formatNumber(view, number2) {
    return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
  }
  var lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state) => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view) {
      return view.state.facet(lineNumberMarkers);
    },
    lineMarker(view, line, others) {
      if (others.some((m) => m.toDOM))
        return null;
      return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    widgetMarker: () => null,
    lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
    initialSpacer(view) {
      return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update) {
      let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
      return max == spacer.number ? spacer : new NumberMarker(max);
    },
    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
  }));
  function lineNumbers(config = {}) {
    return [
      lineNumberConfig.of(config),
      gutters(),
      lineNumberGutter
    ];
  }
  function maxLineNumber(lines) {
    let last = 9;
    while (last < lines)
      last = last * 10 + 9;
    return last;
  }
  var activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
    constructor() {
      super(...arguments);
      this.elementClass = "cm-activeLineGutter";
    }
  }();
  var activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state) => {
    let marks = [], last = -1;
    for (let range10 of state.selection.ranges) {
      let linePos = state.doc.lineAt(range10.head).from;
      if (linePos > last) {
        last = linePos;
        marks.push(activeLineGutterMarker.range(linePos));
      }
    }
    return RangeSet.of(marks);
  });
  function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
  }

  // node_modules/@lezer/common/dist/index.js
  var DefaultBufferLength = 1024;
  var nextPropID = 0;
  var Range2 = class {
    constructor(from17, to10) {
      this.from = from17;
      this.to = to10;
    }
  };
  var NodeProp = class {
    constructor(config = {}) {
      this.id = nextPropID++;
      this.perNode = !!config.perNode;
      this.deserialize = config.deserialize || (() => {
        throw new Error("This node type doesn't define a deserialize function");
      });
    }
    add(match) {
      if (this.perNode)
        throw new RangeError("Can't add per-node props to node types");
      if (typeof match != "function")
        match = NodeType.match(match);
      return (type) => {
        let result = match(type);
        return result === void 0 ? null : [this, result];
      };
    }
  };
  NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.contextHash = new NodeProp({ perNode: true });
  NodeProp.lookAhead = new NodeProp({ perNode: true });
  NodeProp.mounted = new NodeProp({ perNode: true });
  var noProps = Object.create(null);
  var NodeType = class {
    constructor(name2, props, id2, flags = 0) {
      this.name = name2;
      this.props = props;
      this.id = id2;
      this.flags = flags;
    }
    static define(spec) {
      let props = spec.props && spec.props.length ? Object.create(null) : noProps;
      let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
      let type = new NodeType(spec.name || "", props, spec.id, flags);
      if (spec.props)
        for (let src of spec.props) {
          if (!Array.isArray(src))
            src = src(type);
          if (src) {
            if (src[0].perNode)
              throw new RangeError("Can't store a per-node prop on a node type");
            props[src[0].id] = src[1];
          }
        }
      return type;
    }
    prop(prop) {
      return this.props[prop.id];
    }
    get isTop() {
      return (this.flags & 1) > 0;
    }
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    get isError() {
      return (this.flags & 4) > 0;
    }
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    is(name2) {
      if (typeof name2 == "string") {
        if (this.name == name2)
          return true;
        let group = this.prop(NodeProp.group);
        return group ? group.indexOf(name2) > -1 : false;
      }
      return this.id == name2;
    }
    static match(map3) {
      let direct = Object.create(null);
      for (let prop in map3)
        for (let name2 of prop.split(" "))
          direct[name2] = map3[prop];
      return (node) => {
        for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
          let found = direct[i < 0 ? node.name : groups[i]];
          if (found)
            return found;
        }
      };
    }
  };
  NodeType.none = new NodeType("", Object.create(null), 0, 8);
  var NodeSet = class {
    constructor(types2) {
      this.types = types2;
      for (let i = 0; i < types2.length; i++)
        if (types2[i].id != i)
          throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    extend(...props) {
      let newTypes = [];
      for (let type of this.types) {
        let newProps = null;
        for (let source of props) {
          let add17 = source(type);
          if (add17) {
            if (!newProps)
              newProps = Object.assign({}, type.props);
            newProps[add17[0].id] = add17[1];
          }
        }
        newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
      }
      return new NodeSet(newTypes);
    }
  };
  var CachedNode = new WeakMap();
  var CachedInnerNode = new WeakMap();
  var IterMode;
  (function(IterMode2) {
    IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
    IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
  })(IterMode || (IterMode = {}));
  var Tree = class {
    constructor(type, children, positions2, length, props) {
      this.type = type;
      this.children = children;
      this.positions = positions2;
      this.length = length;
      this.props = null;
      if (props && props.length) {
        this.props = Object.create(null);
        for (let [prop, value] of props)
          this.props[typeof prop == "number" ? prop : prop.id] = value;
      }
    }
    toString() {
      let mounted = this.prop(NodeProp.mounted);
      if (mounted && !mounted.overlay)
        return mounted.tree.toString();
      let children = "";
      for (let ch2 of this.children) {
        let str = ch2.toString();
        if (str) {
          if (children)
            children += ",";
          children += str;
        }
      }
      return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
    }
    cursor(mode = 0) {
      return new TreeCursor(this.topNode, mode);
    }
    cursorAt(pos, side = 0, mode = 0) {
      let scope = CachedNode.get(this) || this.topNode;
      let cursor = new TreeCursor(scope);
      cursor.moveTo(pos, side);
      CachedNode.set(this, cursor._tree);
      return cursor;
    }
    get topNode() {
      return new TreeNode(this, 0, 0, null);
    }
    resolve(pos, side = 0) {
      let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
      CachedNode.set(this, node);
      return node;
    }
    resolveInner(pos, side = 0) {
      let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
      CachedInnerNode.set(this, node);
      return node;
    }
    iterate(spec) {
      let { enter, leave, from: from17 = 0, to: to10 = this.length } = spec;
      let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
      for (let c2 = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
        let entered = false;
        if (c2.from <= to10 && c2.to >= from17 && (!anon && c2.type.isAnonymous || enter(c2) !== false)) {
          if (c2.firstChild())
            continue;
          entered = true;
        }
        for (; ; ) {
          if (entered && leave && (anon || !c2.type.isAnonymous))
            leave(c2);
          if (c2.nextSibling())
            break;
          if (!c2.parent())
            return;
          entered = true;
        }
      }
    }
    prop(prop) {
      return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
    }
    get propValues() {
      let result = [];
      if (this.props)
        for (let id2 in this.props)
          result.push([+id2, this.props[id2]]);
      return result;
    }
    balance(config = {}) {
      return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions2, length) => new Tree(this.type, children, positions2, length, this.propValues), config.makeTree || ((children, positions2, length) => new Tree(NodeType.none, children, positions2, length)));
    }
    static build(data) {
      return buildTree(data);
    }
  };
  Tree.empty = new Tree(NodeType.none, [], [], 0);
  var FlatBufferCursor = class {
    constructor(buffer, index3) {
      this.buffer = buffer;
      this.index = index3;
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new FlatBufferCursor(this.buffer, this.index);
    }
  };
  var TreeBuffer = class {
    constructor(buffer, length, set2) {
      this.buffer = buffer;
      this.length = length;
      this.set = set2;
    }
    get type() {
      return NodeType.none;
    }
    toString() {
      let result = [];
      for (let index3 = 0; index3 < this.buffer.length; ) {
        result.push(this.childString(index3));
        index3 = this.buffer[index3 + 3];
      }
      return result.join(",");
    }
    childString(index3) {
      let id2 = this.buffer[index3], endIndex = this.buffer[index3 + 3];
      let type = this.set.types[id2], result = type.name;
      if (/\W/.test(result) && !type.isError)
        result = JSON.stringify(result);
      index3 += 4;
      if (endIndex == index3)
        return result;
      let children = [];
      while (index3 < endIndex) {
        children.push(this.childString(index3));
        index3 = this.buffer[index3 + 3];
      }
      return result + "(" + children.join(",") + ")";
    }
    findChild(startIndex, endIndex, dir, pos, side) {
      let { buffer } = this, pick = -1;
      for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
        if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
          pick = i;
          if (dir > 0)
            break;
        }
      }
      return pick;
    }
    slice(startI, endI, from17) {
      let b = this.buffer;
      let copy = new Uint16Array(endI - startI), len = 0;
      for (let i = startI, j2 = 0; i < endI; ) {
        copy[j2++] = b[i++];
        copy[j2++] = b[i++] - from17;
        let to10 = copy[j2++] = b[i++] - from17;
        copy[j2++] = b[i++] - startI;
        len = Math.max(len, to10);
      }
      return new TreeBuffer(copy, len, this.set);
    }
  };
  function checkSide(side, pos, from17, to10) {
    switch (side) {
      case -2:
        return from17 < pos;
      case -1:
        return to10 >= pos && from17 < pos;
      case 0:
        return from17 < pos && to10 > pos;
      case 1:
        return from17 <= pos && to10 > pos;
      case 2:
        return to10 > pos;
      case 4:
        return true;
    }
  }
  function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node;
  }
  function resolveNode(node, pos, side, overlays) {
    var _a3;
    while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
      let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
      if (!parent)
        return node;
      node = parent;
    }
    let mode = overlays ? 0 : IterMode.IgnoreOverlays;
    if (overlays)
      for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
        if (scan instanceof TreeNode && scan.index < 0 && ((_a3 = parent.enter(pos, side, mode)) === null || _a3 === void 0 ? void 0 : _a3.from) != scan.from)
          node = parent;
      }
    for (; ; ) {
      let inner = node.enter(pos, side, mode);
      if (!inner)
        return node;
      node = inner;
    }
  }
  var TreeNode = class {
    constructor(_tree, from17, index3, _parent) {
      this._tree = _tree;
      this.from = from17;
      this.index = index3;
      this._parent = _parent;
    }
    get type() {
      return this._tree.type;
    }
    get name() {
      return this._tree.type.name;
    }
    get to() {
      return this.from + this._tree.length;
    }
    nextChild(i, dir, pos, side, mode = 0) {
      for (let parent = this; ; ) {
        for (let { children, positions: positions2 } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
          let next = children[i], start2 = positions2[i] + parent.from;
          if (!checkSide(side, pos, start2, start2 + next.length))
            continue;
          if (next instanceof TreeBuffer) {
            if (mode & IterMode.ExcludeBuffers)
              continue;
            let index3 = next.findChild(0, next.buffer.length, dir, pos - start2, side);
            if (index3 > -1)
              return new BufferNode(new BufferContext(parent, next, i, start2), null, index3);
          } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
            let mounted;
            if (!(mode & IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
              return new TreeNode(mounted.tree, start2, i, parent);
            let inner = new TreeNode(next, start2, i, parent);
            return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
          }
        }
        if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
          return null;
        if (parent.index >= 0)
          i = parent.index + dir;
        else
          i = dir < 0 ? -1 : parent._parent._tree.children.length;
        parent = parent._parent;
        if (!parent)
          return null;
      }
    }
    get firstChild() {
      return this.nextChild(0, 1, 0, 4);
    }
    get lastChild() {
      return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
    }
    childAfter(pos) {
      return this.nextChild(0, 1, pos, 2);
    }
    childBefore(pos) {
      return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      let mounted;
      if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
        let rPos = pos - this.from;
        for (let { from: from17, to: to10 } of mounted.overlay) {
          if ((side > 0 ? from17 <= rPos : from17 < rPos) && (side < 0 ? to10 >= rPos : to10 > rPos))
            return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
        }
      }
      return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
      let val = this;
      while (val.type.isAnonymous && val._parent)
        val = val._parent;
      return val;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
    }
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    get tree() {
      return this._tree;
    }
    toTree() {
      return this._tree;
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    getChild(type, before = null, after = null) {
      let r = getChildren(this, type, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
      return getChildren(this, type, before, after);
    }
    toString() {
      return this._tree.toString();
    }
    get node() {
      return this;
    }
    matchContext(context2) {
      return matchNodeContext(this, context2);
    }
  };
  function getChildren(node, type, before, after) {
    let cur = node.cursor(), result = [];
    if (!cur.firstChild())
      return result;
    if (before != null) {
      while (!cur.type.is(before))
        if (!cur.nextSibling())
          return result;
    }
    for (; ; ) {
      if (after != null && cur.type.is(after))
        return result;
      if (cur.type.is(type))
        result.push(cur.node);
      if (!cur.nextSibling())
        return after == null ? result : [];
    }
  }
  function matchNodeContext(node, context2, i = context2.length - 1) {
    for (let p = node.parent; i >= 0; p = p.parent) {
      if (!p)
        return false;
      if (!p.type.isAnonymous) {
        if (context2[i] && context2[i] != p.name)
          return false;
        i--;
      }
    }
    return true;
  }
  var BufferContext = class {
    constructor(parent, buffer, index3, start2) {
      this.parent = parent;
      this.buffer = buffer;
      this.index = index3;
      this.start = start2;
    }
  };
  var BufferNode = class {
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    constructor(context2, _parent, index3) {
      this.context = context2;
      this._parent = _parent;
      this.index = index3;
      this.type = context2.buffer.set.types[context2.buffer.buffer[index3]];
    }
    child(dir, pos, side) {
      let { buffer } = this.context;
      let index3 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
      return index3 < 0 ? null : new BufferNode(this.context, this, index3);
    }
    get firstChild() {
      return this.child(1, 0, 4);
    }
    get lastChild() {
      return this.child(-1, 0, 4);
    }
    childAfter(pos) {
      return this.child(1, pos, 2);
    }
    childBefore(pos) {
      return this.child(-1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      if (mode & IterMode.ExcludeBuffers)
        return null;
      let { buffer } = this.context;
      let index3 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
      return index3 < 0 ? null : new BufferNode(this.context, this, index3);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
      return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
    }
    get nextSibling() {
      let { buffer } = this.context;
      let after = buffer.buffer[this.index + 3];
      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
        return new BufferNode(this.context, this._parent, after);
      return this.externalSibling(1);
    }
    get prevSibling() {
      let { buffer } = this.context;
      let parentStart = this._parent ? this._parent.index + 4 : 0;
      if (this.index == parentStart)
        return this.externalSibling(-1);
      return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
    }
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    get tree() {
      return null;
    }
    toTree() {
      let children = [], positions2 = [];
      let { buffer } = this.context;
      let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
      if (endI > startI) {
        let from17 = buffer.buffer[this.index + 1];
        children.push(buffer.slice(startI, endI, from17));
        positions2.push(0);
      }
      return new Tree(this.type, children, positions2, this.to - this.from);
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    toString() {
      return this.context.buffer.childString(this.index);
    }
    getChild(type, before = null, after = null) {
      let r = getChildren(this, type, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
      return getChildren(this, type, before, after);
    }
    get node() {
      return this;
    }
    matchContext(context2) {
      return matchNodeContext(this, context2);
    }
  };
  var TreeCursor = class {
    get name() {
      return this.type.name;
    }
    constructor(node, mode = 0) {
      this.mode = mode;
      this.buffer = null;
      this.stack = [];
      this.index = 0;
      this.bufferNode = null;
      if (node instanceof TreeNode) {
        this.yieldNode(node);
      } else {
        this._tree = node.context.parent;
        this.buffer = node.context;
        for (let n = node._parent; n; n = n._parent)
          this.stack.unshift(n.index);
        this.bufferNode = node;
        this.yieldBuf(node.index);
      }
    }
    yieldNode(node) {
      if (!node)
        return false;
      this._tree = node;
      this.type = node.type;
      this.from = node.from;
      this.to = node.to;
      return true;
    }
    yieldBuf(index3, type) {
      this.index = index3;
      let { start: start2, buffer } = this.buffer;
      this.type = type || buffer.set.types[buffer.buffer[index3]];
      this.from = start2 + buffer.buffer[index3 + 1];
      this.to = start2 + buffer.buffer[index3 + 2];
      return true;
    }
    yield(node) {
      if (!node)
        return false;
      if (node instanceof TreeNode) {
        this.buffer = null;
        return this.yieldNode(node);
      }
      this.buffer = node.context;
      return this.yieldBuf(node.index, node.type);
    }
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    enterChild(dir, pos, side) {
      if (!this.buffer)
        return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
      let { buffer } = this.buffer;
      let index3 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
      if (index3 < 0)
        return false;
      this.stack.push(this.index);
      return this.yieldBuf(index3);
    }
    firstChild() {
      return this.enterChild(1, 0, 4);
    }
    lastChild() {
      return this.enterChild(-1, 0, 4);
    }
    childAfter(pos) {
      return this.enterChild(1, pos, 2);
    }
    childBefore(pos) {
      return this.enterChild(-1, pos, -2);
    }
    enter(pos, side, mode = this.mode) {
      if (!this.buffer)
        return this.yield(this._tree.enter(pos, side, mode));
      return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    parent() {
      if (!this.buffer)
        return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
      if (this.stack.length)
        return this.yieldBuf(this.stack.pop());
      let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      this.buffer = null;
      return this.yieldNode(parent);
    }
    sibling(dir) {
      if (!this.buffer)
        return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
      let { buffer } = this.buffer, d2 = this.stack.length - 1;
      if (dir < 0) {
        let parentStart = d2 < 0 ? 0 : this.stack[d2] + 4;
        if (this.index != parentStart)
          return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
      } else {
        let after = buffer.buffer[this.index + 3];
        if (after < (d2 < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d2] + 3]))
          return this.yieldBuf(after);
      }
      return d2 < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
    }
    nextSibling() {
      return this.sibling(1);
    }
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(dir) {
      let index3, parent, { buffer } = this;
      if (buffer) {
        if (dir > 0) {
          if (this.index < buffer.buffer.buffer.length)
            return false;
        } else {
          for (let i = 0; i < this.index; i++)
            if (buffer.buffer.buffer[i + 3] < this.index)
              return false;
        }
        ({ index: index3, parent } = buffer);
      } else {
        ({ index: index3, _parent: parent } = this._tree);
      }
      for (; parent; { index: index3, _parent: parent } = parent) {
        if (index3 > -1)
          for (let i = index3 + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
            let child = parent._tree.children[i];
            if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
              return false;
          }
      }
      return true;
    }
    move(dir, enter) {
      if (enter && this.enterChild(dir, 0, 4))
        return true;
      for (; ; ) {
        if (this.sibling(dir))
          return true;
        if (this.atLastNode(dir) || !this.parent())
          return false;
      }
    }
    next(enter = true) {
      return this.move(1, enter);
    }
    prev(enter = true) {
      return this.move(-1, enter);
    }
    moveTo(pos, side = 0) {
      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
        if (!this.parent())
          break;
      while (this.enterChild(1, pos, side)) {
      }
      return this;
    }
    get node() {
      if (!this.buffer)
        return this._tree;
      let cache = this.bufferNode, result = null, depth = 0;
      if (cache && cache.context == this.buffer) {
        scan:
          for (let index3 = this.index, d2 = this.stack.length; d2 >= 0; ) {
            for (let c2 = cache; c2; c2 = c2._parent)
              if (c2.index == index3) {
                if (index3 == this.index)
                  return c2;
                result = c2;
                depth = d2 + 1;
                break scan;
              }
            index3 = this.stack[--d2];
          }
      }
      for (let i = depth; i < this.stack.length; i++)
        result = new BufferNode(this.buffer, result, this.stack[i]);
      return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    get tree() {
      return this.buffer ? null : this._tree._tree;
    }
    iterate(enter, leave) {
      for (let depth = 0; ; ) {
        let mustLeave = false;
        if (this.type.isAnonymous || enter(this) !== false) {
          if (this.firstChild()) {
            depth++;
            continue;
          }
          if (!this.type.isAnonymous)
            mustLeave = true;
        }
        for (; ; ) {
          if (mustLeave && leave)
            leave(this);
          mustLeave = this.type.isAnonymous;
          if (this.nextSibling())
            break;
          if (!depth)
            return;
          this.parent();
          depth--;
          mustLeave = true;
        }
      }
    }
    matchContext(context2) {
      if (!this.buffer)
        return matchNodeContext(this.node, context2);
      let { buffer } = this.buffer, { types: types2 } = buffer.set;
      for (let i = context2.length - 1, d2 = this.stack.length - 1; i >= 0; d2--) {
        if (d2 < 0)
          return matchNodeContext(this.node, context2, i);
        let type = types2[buffer.buffer[this.stack[d2]]];
        if (!type.isAnonymous) {
          if (context2[i] && context2[i] != type.name)
            return false;
          i--;
        }
      }
      return true;
    }
  };
  function hasChild(tree) {
    return tree.children.some((ch2) => ch2 instanceof TreeBuffer || !ch2.type.isAnonymous || hasChild(ch2));
  }
  function buildTree(data) {
    var _a3;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types2 = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children2, positions3, inRepeat) {
      let { id: id2, start: start2, end, size } = cursor;
      let lookAheadAtStart = lookAhead;
      while (size < 0) {
        cursor.next();
        if (size == -1) {
          let node2 = reused[id2];
          children2.push(node2);
          positions3.push(start2 - parentStart);
          return;
        } else if (size == -3) {
          contextHash = id2;
          return;
        } else if (size == -4) {
          lookAhead = id2;
          return;
        } else {
          throw new RangeError(`Unrecognized record size: ${size}`);
        }
      }
      let type = types2[id2], node, buffer2;
      let startPos = start2 - parentStart;
      if (end - start2 <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
        let data2 = new Uint16Array(buffer2.size - buffer2.skip);
        let endPos = cursor.pos - buffer2.size, index3 = data2.length;
        while (cursor.pos > endPos)
          index3 = copyToBuffer(buffer2.start, data2, index3);
        node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
        startPos = buffer2.start - parentStart;
      } else {
        let endPos = cursor.pos - size;
        cursor.next();
        let localChildren = [], localPositions = [];
        let localInRepeat = id2 >= minRepeatType ? id2 : -1;
        let lastGroup = 0, lastEnd = end;
        while (cursor.pos > endPos) {
          if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
            if (cursor.end <= lastEnd - maxBufferLength) {
              makeRepeatLeaf(localChildren, localPositions, start2, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
              lastGroup = localChildren.length;
              lastEnd = cursor.end;
            }
            cursor.next();
          } else {
            takeNode(start2, endPos, localChildren, localPositions, localInRepeat);
          }
        }
        if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
          makeRepeatLeaf(localChildren, localPositions, start2, lastGroup, start2, lastEnd, localInRepeat, lookAheadAtStart);
        localChildren.reverse();
        localPositions.reverse();
        if (localInRepeat > -1 && lastGroup > 0) {
          let make = makeBalanced(type);
          node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start2, make, make);
        } else {
          node = makeTree(type, localChildren, localPositions, end - start2, lookAheadAtStart - end);
        }
      }
      children2.push(node);
      positions3.push(startPos);
    }
    function makeBalanced(type) {
      return (children2, positions3, length2) => {
        let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
        if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
          if (!lastI && last.type == type && last.length == length2)
            return last;
          if (lookAheadProp = last.prop(NodeProp.lookAhead))
            lookAhead2 = positions3[lastI] + last.length + lookAheadProp;
        }
        return makeTree(type, children2, positions3, length2, lookAhead2);
      };
    }
    function makeRepeatLeaf(children2, positions3, base2, i, from17, to10, type, lookAhead2) {
      let localChildren = [], localPositions = [];
      while (children2.length > i) {
        localChildren.push(children2.pop());
        localPositions.push(positions3.pop() + base2 - from17);
      }
      children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to10 - from17, lookAhead2 - to10));
      positions3.push(from17 - base2);
    }
    function makeTree(type, children2, positions3, length2, lookAhead2 = 0, props) {
      if (contextHash) {
        let pair2 = [NodeProp.contextHash, contextHash];
        props = props ? [pair2].concat(props) : [pair2];
      }
      if (lookAhead2 > 25) {
        let pair2 = [NodeProp.lookAhead, lookAhead2];
        props = props ? [pair2].concat(props) : [pair2];
      }
      return new Tree(type, children2, positions3, length2, props);
    }
    function findBufferSize(maxSize, inRepeat) {
      let fork = cursor.fork();
      let size = 0, start2 = 0, skip2 = 0, minStart = fork.end - maxBufferLength;
      let result = { size: 0, start: 0, skip: 0 };
      scan:
        for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
          let nodeSize2 = fork.size;
          if (fork.id == inRepeat && nodeSize2 >= 0) {
            result.size = size;
            result.start = start2;
            result.skip = skip2;
            skip2 += 4;
            size += 4;
            fork.next();
            continue;
          }
          let startPos = fork.pos - nodeSize2;
          if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
            break;
          let localSkipped = fork.id >= minRepeatType ? 4 : 0;
          let nodeStart = fork.start;
          fork.next();
          while (fork.pos > startPos) {
            if (fork.size < 0) {
              if (fork.size == -3)
                localSkipped += 4;
              else
                break scan;
            } else if (fork.id >= minRepeatType) {
              localSkipped += 4;
            }
            fork.next();
          }
          start2 = nodeStart;
          size += nodeSize2;
          skip2 += localSkipped;
        }
      if (inRepeat < 0 || size == maxSize) {
        result.size = size;
        result.start = start2;
        result.skip = skip2;
      }
      return result.size > 4 ? result : void 0;
    }
    function copyToBuffer(bufferStart, buffer2, index3) {
      let { id: id2, start: start2, end, size } = cursor;
      cursor.next();
      if (size >= 0 && id2 < minRepeatType) {
        let startIndex = index3;
        if (size > 4) {
          let endPos = cursor.pos - (size - 4);
          while (cursor.pos > endPos)
            index3 = copyToBuffer(bufferStart, buffer2, index3);
        }
        buffer2[--index3] = startIndex;
        buffer2[--index3] = end - bufferStart;
        buffer2[--index3] = start2 - bufferStart;
        buffer2[--index3] = id2;
      } else if (size == -3) {
        contextHash = id2;
      } else if (size == -4) {
        lookAhead = id2;
      }
      return index3;
    }
    let children = [], positions2 = [];
    while (cursor.pos > 0)
      takeNode(data.start || 0, data.bufferStart || 0, children, positions2, -1);
    let length = (_a3 = data.length) !== null && _a3 !== void 0 ? _a3 : children.length ? positions2[0] + children[0].length : 0;
    return new Tree(types2[data.topID], children.reverse(), positions2.reverse(), length);
  }
  var nodeSizeCache = new WeakMap();
  function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
      return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
      size = 1;
      for (let child of node.children) {
        if (child.type != balanceType || !(child instanceof Tree)) {
          size = 1;
          break;
        }
        size += nodeSize(balanceType, child);
      }
      nodeSizeCache.set(node, size);
    }
    return size;
  }
  function balanceRange(balanceType, children, positions2, from17, to10, start2, length, mkTop, mkTree) {
    let total = 0;
    for (let i = from17; i < to10; i++)
      total += nodeSize(balanceType, children[i]);
    let maxChild = Math.ceil(total * 1.5 / 8);
    let localChildren = [], localPositions = [];
    function divide2(children2, positions3, from18, to11, offset) {
      for (let i = from18; i < to11; ) {
        let groupFrom = i, groupStart = positions3[i], groupSize = nodeSize(balanceType, children2[i]);
        i++;
        for (; i < to11; i++) {
          let nextSize = nodeSize(balanceType, children2[i]);
          if (groupSize + nextSize >= maxChild)
            break;
          groupSize += nextSize;
        }
        if (i == groupFrom + 1) {
          if (groupSize > maxChild) {
            let only = children2[groupFrom];
            divide2(only.children, only.positions, 0, only.children.length, positions3[groupFrom] + offset);
            continue;
          }
          localChildren.push(children2[groupFrom]);
        } else {
          let length2 = positions3[i - 1] + children2[i - 1].length - groupStart;
          localChildren.push(balanceRange(balanceType, children2, positions3, groupFrom, i, groupStart, length2, null, mkTree));
        }
        localPositions.push(groupStart + offset - start2);
      }
    }
    divide2(children, positions2, from17, to10, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
  }
  var TreeFragment = class {
    constructor(from17, to10, tree, offset, openStart = false, openEnd = false) {
      this.from = from17;
      this.to = to10;
      this.tree = tree;
      this.offset = offset;
      this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
    }
    get openStart() {
      return (this.open & 1) > 0;
    }
    get openEnd() {
      return (this.open & 2) > 0;
    }
    static addTree(tree, fragments = [], partial = false) {
      let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
      for (let f of fragments)
        if (f.to > tree.length)
          result.push(f);
      return result;
    }
    static applyChanges(fragments, changes, minGap = 128) {
      if (!changes.length)
        return fragments;
      let result = [];
      let fI = 1, nextF = fragments.length ? fragments[0] : null;
      for (let cI = 0, pos = 0, off2 = 0; ; cI++) {
        let nextC = cI < changes.length ? changes[cI] : null;
        let nextPos = nextC ? nextC.fromA : 1e9;
        if (nextPos - pos >= minGap)
          while (nextF && nextF.from < nextPos) {
            let cut = nextF;
            if (pos >= cut.from || nextPos <= cut.to || off2) {
              let fFrom = Math.max(cut.from, pos) - off2, fTo = Math.min(cut.to, nextPos) - off2;
              cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off2, cI > 0, !!nextC);
            }
            if (cut)
              result.push(cut);
            if (nextF.to > nextPos)
              break;
            nextF = fI < fragments.length ? fragments[fI++] : null;
          }
        if (!nextC)
          break;
        pos = nextC.toA;
        off2 = nextC.toA - nextC.toB;
      }
      return result;
    }
  };
  var Parser = class {
    startParse(input2, fragments, ranges) {
      if (typeof input2 == "string")
        input2 = new StringInput(input2);
      ranges = !ranges ? [new Range2(0, input2.length)] : ranges.length ? ranges.map((r) => new Range2(r.from, r.to)) : [new Range2(0, 0)];
      return this.createParse(input2, fragments || [], ranges);
    }
    parse(input2, fragments, ranges) {
      let parse2 = this.startParse(input2, fragments, ranges);
      for (; ; ) {
        let done = parse2.advance();
        if (done)
          return done;
      }
    }
  };
  var StringInput = class {
    constructor(string2) {
      this.string = string2;
    }
    get length() {
      return this.string.length;
    }
    chunk(from17) {
      return this.string.slice(from17);
    }
    get lineChunks() {
      return false;
    }
    read(from17, to10) {
      return this.string.slice(from17, to10);
    }
  };
  var stoppedInner = new NodeProp({ perNode: true });

  // node_modules/@lezer/highlight/dist/index.js
  var nextTagID = 0;
  var Tag = class {
    constructor(set2, base2, modified) {
      this.set = set2;
      this.base = base2;
      this.modified = modified;
      this.id = nextTagID++;
    }
    static define(parent) {
      if (parent === null || parent === void 0 ? void 0 : parent.base)
        throw new Error("Can not derive from a modified tag");
      let tag = new Tag([], null, []);
      tag.set.push(tag);
      if (parent)
        for (let t2 of parent.set)
          tag.set.push(t2);
      return tag;
    }
    static defineModifier() {
      let mod = new Modifier();
      return (tag) => {
        if (tag.modified.indexOf(mod) > -1)
          return tag;
        return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
      };
    }
  };
  var nextModifierID = 0;
  var Modifier = class {
    constructor() {
      this.instances = [];
      this.id = nextModifierID++;
    }
    static get(base2, mods) {
      if (!mods.length)
        return base2;
      let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray2(mods, t2.modified));
      if (exists)
        return exists;
      let set2 = [], tag = new Tag(set2, base2, mods);
      for (let m of mods)
        m.instances.push(tag);
      let configs = powerSet(mods);
      for (let parent of base2.set)
        if (!parent.modified.length)
          for (let config of configs)
            set2.push(Modifier.get(parent, config));
      return tag;
    }
  };
  function sameArray2(a, b) {
    return a.length == b.length && a.every((x, i) => x == b[i]);
  }
  function powerSet(array) {
    let sets = [[]];
    for (let i = 0; i < array.length; i++) {
      for (let j2 = 0, e = sets.length; j2 < e; j2++) {
        sets.push(sets[j2].concat(array[i]));
      }
    }
    return sets.sort((a, b) => b.length - a.length);
  }
  function styleTags(spec) {
    let byName = Object.create(null);
    for (let prop in spec) {
      let tags2 = spec[prop];
      if (!Array.isArray(tags2))
        tags2 = [tags2];
      for (let part of prop.split(" "))
        if (part) {
          let pieces = [], mode = 2, rest = part;
          for (let pos = 0; ; ) {
            if (rest == "..." && pos > 0 && pos + 3 == part.length) {
              mode = 1;
              break;
            }
            let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
            if (!m)
              throw new RangeError("Invalid path: " + part);
            pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
            pos += m[0].length;
            if (pos == part.length)
              break;
            let next = part[pos++];
            if (pos == part.length && next == "!") {
              mode = 0;
              break;
            }
            if (next != "/")
              throw new RangeError("Invalid path: " + part);
            rest = part.slice(pos);
          }
          let last = pieces.length - 1, inner = pieces[last];
          if (!inner)
            throw new RangeError("Invalid path: " + part);
          let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
          byName[inner] = rule.sort(byName[inner]);
        }
    }
    return ruleNodeProp.add(byName);
  }
  var ruleNodeProp = new NodeProp();
  var Rule = class {
    constructor(tags2, mode, context2, next) {
      this.tags = tags2;
      this.mode = mode;
      this.context = context2;
      this.next = next;
    }
    get opaque() {
      return this.mode == 0;
    }
    get inherit() {
      return this.mode == 1;
    }
    sort(other) {
      if (!other || other.depth < this.depth) {
        this.next = other;
        return this;
      }
      other.next = this.sort(other.next);
      return other;
    }
    get depth() {
      return this.context ? this.context.length : 0;
    }
  };
  Rule.empty = new Rule([], 2, null);
  function tagHighlighter(tags2, options) {
    let map3 = Object.create(null);
    for (let style of tags2) {
      if (!Array.isArray(style.tag))
        map3[style.tag.id] = style.class;
      else
        for (let tag of style.tag)
          map3[tag.id] = style.class;
    }
    let { scope, all = null } = options || {};
    return {
      style: (tags3) => {
        let cls = all;
        for (let tag of tags3) {
          for (let sub of tag.set) {
            let tagClass = map3[sub.id];
            if (tagClass) {
              cls = cls ? cls + " " + tagClass : tagClass;
              break;
            }
          }
        }
        return cls;
      },
      scope
    };
  }
  function highlightTags(highlighters, tags2) {
    let result = null;
    for (let highlighter of highlighters) {
      let value = highlighter.style(tags2);
      if (value)
        result = result ? result + " " + value : value;
    }
    return result;
  }
  function highlightTree(tree, highlighter, putStyle, from17 = 0, to10 = tree.length) {
    let builder = new HighlightBuilder(from17, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from17, to10, "", builder.highlighters);
    builder.flush(to10);
  }
  var HighlightBuilder = class {
    constructor(at14, highlighters, span) {
      this.at = at14;
      this.highlighters = highlighters;
      this.span = span;
      this.class = "";
    }
    startSpan(at14, cls) {
      if (cls != this.class) {
        this.flush(at14);
        if (at14 > this.at)
          this.at = at14;
        this.class = cls;
      }
    }
    flush(to10) {
      if (to10 > this.at && this.class)
        this.span(this.at, to10, this.class);
    }
    highlightRange(cursor, from17, to10, inheritedClass, highlighters) {
      let { type, from: start2, to: end } = cursor;
      if (start2 >= to10 || end <= from17)
        return;
      if (type.isTop)
        highlighters = this.highlighters.filter((h3) => !h3.scope || h3.scope(type));
      let cls = inheritedClass;
      let rule = getStyleTags(cursor) || Rule.empty;
      let tagCls = highlightTags(highlighters, rule.tags);
      if (tagCls) {
        if (cls)
          cls += " ";
        cls += tagCls;
        if (rule.mode == 1)
          inheritedClass += (inheritedClass ? " " : "") + tagCls;
      }
      this.startSpan(Math.max(from17, start2), cls);
      if (rule.opaque)
        return;
      let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
      if (mounted && mounted.overlay) {
        let inner = cursor.node.enter(mounted.overlay[0].from + start2, 1);
        let innerHighlighters = this.highlighters.filter((h3) => !h3.scope || h3.scope(mounted.tree.type));
        let hasChild2 = cursor.firstChild();
        for (let i = 0, pos = start2; ; i++) {
          let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
          let nextPos = next ? next.from + start2 : end;
          let rangeFrom = Math.max(from17, pos), rangeTo = Math.min(to10, nextPos);
          if (rangeFrom < rangeTo && hasChild2) {
            while (cursor.from < rangeTo) {
              this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
              this.startSpan(Math.min(rangeTo, cursor.to), cls);
              if (cursor.to >= nextPos || !cursor.nextSibling())
                break;
            }
          }
          if (!next || nextPos > to10)
            break;
          pos = next.to + start2;
          if (pos > from17) {
            this.highlightRange(inner.cursor(), Math.max(from17, next.from + start2), Math.min(to10, pos), "", innerHighlighters);
            this.startSpan(Math.min(to10, pos), cls);
          }
        }
        if (hasChild2)
          cursor.parent();
      } else if (cursor.firstChild()) {
        if (mounted)
          inheritedClass = "";
        do {
          if (cursor.to <= from17)
            continue;
          if (cursor.from >= to10)
            break;
          this.highlightRange(cursor, from17, to10, inheritedClass, highlighters);
          this.startSpan(Math.min(to10, cursor.to), cls);
        } while (cursor.nextSibling());
        cursor.parent();
      }
    }
  };
  function getStyleTags(node) {
    let rule = node.type.prop(ruleNodeProp);
    while (rule && rule.context && !node.matchContext(rule.context))
      rule = rule.next;
    return rule || null;
  }
  var t = Tag.define;
  var comment = t();
  var name = t();
  var typeName = t(name);
  var propertyName = t(name);
  var literal = t();
  var string = t(literal);
  var number = t(literal);
  var content = t();
  var heading = t(content);
  var keyword = t();
  var operator = t();
  var punctuation = t();
  var bracket = t(punctuation);
  var meta = t();
  var tags = {
    comment,
    lineComment: t(comment),
    blockComment: t(comment),
    docComment: t(comment),
    name,
    variableName: t(name),
    typeName,
    tagName: t(typeName),
    propertyName,
    attributeName: t(propertyName),
    className: t(name),
    labelName: t(name),
    namespace: t(name),
    macroName: t(name),
    literal,
    string,
    docString: t(string),
    character: t(string),
    attributeValue: t(string),
    number,
    integer: t(number),
    float: t(number),
    bool: t(literal),
    regexp: t(literal),
    escape: t(literal),
    color: t(literal),
    url: t(literal),
    keyword,
    self: t(keyword),
    null: t(keyword),
    atom: t(keyword),
    unit: t(keyword),
    modifier: t(keyword),
    operatorKeyword: t(keyword),
    controlKeyword: t(keyword),
    definitionKeyword: t(keyword),
    moduleKeyword: t(keyword),
    operator,
    derefOperator: t(operator),
    arithmeticOperator: t(operator),
    logicOperator: t(operator),
    bitwiseOperator: t(operator),
    compareOperator: t(operator),
    updateOperator: t(operator),
    definitionOperator: t(operator),
    typeOperator: t(operator),
    controlOperator: t(operator),
    punctuation,
    separator: t(punctuation),
    bracket,
    angleBracket: t(bracket),
    squareBracket: t(bracket),
    paren: t(bracket),
    brace: t(bracket),
    content,
    heading,
    heading1: t(heading),
    heading2: t(heading),
    heading3: t(heading),
    heading4: t(heading),
    heading5: t(heading),
    heading6: t(heading),
    contentSeparator: t(content),
    list: t(content),
    quote: t(content),
    emphasis: t(content),
    strong: t(content),
    link: t(content),
    monospace: t(content),
    strikethrough: t(content),
    inserted: t(),
    deleted: t(),
    changed: t(),
    invalid: t(),
    meta,
    documentMeta: t(meta),
    annotation: t(meta),
    processingInstruction: t(meta),
    definition: Tag.defineModifier(),
    constant: Tag.defineModifier(),
    function: Tag.defineModifier(),
    standard: Tag.defineModifier(),
    local: Tag.defineModifier(),
    special: Tag.defineModifier()
  };
  var classHighlighter = tagHighlighter([
    { tag: tags.link, class: "tok-link" },
    { tag: tags.heading, class: "tok-heading" },
    { tag: tags.emphasis, class: "tok-emphasis" },
    { tag: tags.strong, class: "tok-strong" },
    { tag: tags.keyword, class: "tok-keyword" },
    { tag: tags.atom, class: "tok-atom" },
    { tag: tags.bool, class: "tok-bool" },
    { tag: tags.url, class: "tok-url" },
    { tag: tags.labelName, class: "tok-labelName" },
    { tag: tags.inserted, class: "tok-inserted" },
    { tag: tags.deleted, class: "tok-deleted" },
    { tag: tags.literal, class: "tok-literal" },
    { tag: tags.string, class: "tok-string" },
    { tag: tags.number, class: "tok-number" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
    { tag: tags.variableName, class: "tok-variableName" },
    { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
    { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
    { tag: tags.special(tags.variableName), class: "tok-variableName2" },
    { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
    { tag: tags.typeName, class: "tok-typeName" },
    { tag: tags.namespace, class: "tok-namespace" },
    { tag: tags.className, class: "tok-className" },
    { tag: tags.macroName, class: "tok-macroName" },
    { tag: tags.propertyName, class: "tok-propertyName" },
    { tag: tags.operator, class: "tok-operator" },
    { tag: tags.comment, class: "tok-comment" },
    { tag: tags.meta, class: "tok-meta" },
    { tag: tags.invalid, class: "tok-invalid" },
    { tag: tags.punctuation, class: "tok-punctuation" }
  ]);

  // node_modules/@codemirror/language/dist/index.js
  var _a;
  var languageDataProp = /* @__PURE__ */ new NodeProp();
  function defineLanguageFacet(baseData) {
    return Facet.define({
      combine: baseData ? (values) => values.concat(baseData) : void 0
    });
  }
  var sublanguageProp = /* @__PURE__ */ new NodeProp();
  var Language = class {
    constructor(data, parser19, extraExtensions = [], name2 = "") {
      this.data = data;
      this.name = name2;
      if (!EditorState.prototype.hasOwnProperty("tree"))
        Object.defineProperty(EditorState.prototype, "tree", { get() {
          return syntaxTree(this);
        } });
      this.parser = parser19;
      this.extension = [
        language.of(this),
        EditorState.languageData.of((state, pos, side) => {
          let top2 = topNodeAt(state, pos, side), data2 = top2.type.prop(languageDataProp);
          if (!data2)
            return [];
          let base2 = state.facet(data2), sub = top2.type.prop(sublanguageProp);
          if (sub) {
            let innerNode = top2.resolve(pos - top2.from, side);
            for (let sublang of sub)
              if (sublang.test(innerNode, state)) {
                let data3 = state.facet(sublang.facet);
                return sublang.type == "replace" ? data3 : data3.concat(base2);
              }
          }
          return base2;
        })
      ].concat(extraExtensions);
    }
    isActiveAt(state, pos, side = -1) {
      return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
    }
    findRegions(state) {
      let lang = state.facet(language);
      if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
        return [{ from: 0, to: state.doc.length }];
      if (!lang || !lang.allowsNesting)
        return [];
      let result = [];
      let explore = (tree, from17) => {
        if (tree.prop(languageDataProp) == this.data) {
          result.push({ from: from17, to: from17 + tree.length });
          return;
        }
        let mount2 = tree.prop(NodeProp.mounted);
        if (mount2) {
          if (mount2.tree.prop(languageDataProp) == this.data) {
            if (mount2.overlay)
              for (let r of mount2.overlay)
                result.push({ from: r.from + from17, to: r.to + from17 });
            else
              result.push({ from: from17, to: from17 + tree.length });
            return;
          } else if (mount2.overlay) {
            let size = result.length;
            explore(mount2.tree, mount2.overlay[0].from + from17);
            if (result.length > size)
              return;
          }
        }
        for (let i = 0; i < tree.children.length; i++) {
          let ch2 = tree.children[i];
          if (ch2 instanceof Tree)
            explore(ch2, tree.positions[i] + from17);
        }
      };
      explore(syntaxTree(state), 0);
      return result;
    }
    get allowsNesting() {
      return true;
    }
  };
  Language.setState = /* @__PURE__ */ StateEffect.define();
  function topNodeAt(state, pos, side) {
    let topLang = state.facet(language), tree = syntaxTree(state).topNode;
    if (!topLang || topLang.allowsNesting) {
      for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
        if (node.type.isTop)
          tree = node;
    }
    return tree;
  }
  var LRLanguage = class extends Language {
    constructor(data, parser19, name2) {
      super(data, parser19, [], name2);
      this.parser = parser19;
    }
    static define(spec) {
      let data = defineLanguageFacet(spec.languageData);
      return new LRLanguage(data, spec.parser.configure({
        props: [languageDataProp.add((type) => type.isTop ? data : void 0)]
      }), spec.name);
    }
    configure(options, name2) {
      return new LRLanguage(this.data, this.parser.configure(options), name2 || this.name);
    }
    get allowsNesting() {
      return this.parser.hasWrappers();
    }
  };
  function syntaxTree(state) {
    let field = state.field(Language.state, false);
    return field ? field.tree : Tree.empty;
  }
  var DocInput = class {
    constructor(doc2) {
      this.doc = doc2;
      this.cursorPos = 0;
      this.string = "";
      this.cursor = doc2.iter();
    }
    get length() {
      return this.doc.length;
    }
    syncTo(pos) {
      this.string = this.cursor.next(pos - this.cursorPos).value;
      this.cursorPos = pos + this.string.length;
      return this.cursorPos - this.string.length;
    }
    chunk(pos) {
      this.syncTo(pos);
      return this.string;
    }
    get lineChunks() {
      return true;
    }
    read(from17, to10) {
      let stringStart = this.cursorPos - this.string.length;
      if (from17 < stringStart || to10 >= this.cursorPos)
        return this.doc.sliceString(from17, to10);
      else
        return this.string.slice(from17 - stringStart, to10 - stringStart);
    }
  };
  var currentContext = null;
  var ParseContext = class {
    constructor(parser19, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
      this.parser = parser19;
      this.state = state;
      this.fragments = fragments;
      this.tree = tree;
      this.treeLen = treeLen;
      this.viewport = viewport;
      this.skipped = skipped;
      this.scheduleOn = scheduleOn;
      this.parse = null;
      this.tempSkipped = [];
    }
    static create(parser19, state, viewport) {
      return new ParseContext(parser19, state, [], Tree.empty, 0, viewport, [], null);
    }
    startParse() {
      return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    work(until, upto) {
      if (upto != null && upto >= this.state.doc.length)
        upto = void 0;
      if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
        this.takeTree();
        return true;
      }
      return this.withContext(() => {
        var _a3;
        if (typeof until == "number") {
          let endTime = Date.now() + until;
          until = () => Date.now() > endTime;
        }
        if (!this.parse)
          this.parse = this.startParse();
        if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
          this.parse.stopAt(upto);
        for (; ; ) {
          let done = this.parse.advance();
          if (done) {
            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
            this.treeLen = (_a3 = this.parse.stoppedAt) !== null && _a3 !== void 0 ? _a3 : this.state.doc.length;
            this.tree = done;
            this.parse = null;
            if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
              this.parse = this.startParse();
            else
              return true;
          }
          if (until())
            return false;
        }
      });
    }
    takeTree() {
      let pos, tree;
      if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
        if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
          this.parse.stopAt(pos);
        this.withContext(() => {
          while (!(tree = this.parse.advance())) {
          }
        });
        this.treeLen = pos;
        this.tree = tree;
        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
        this.parse = null;
      }
    }
    withContext(f) {
      let prev = currentContext;
      currentContext = this;
      try {
        return f();
      } finally {
        currentContext = prev;
      }
    }
    withoutTempSkipped(fragments) {
      for (let r; r = this.tempSkipped.pop(); )
        fragments = cutFragments(fragments, r.from, r.to);
      return fragments;
    }
    changes(changes, newState) {
      let { fragments, tree, treeLen, viewport, skipped } = this;
      this.takeTree();
      if (!changes.empty) {
        let ranges = [];
        changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
        fragments = TreeFragment.applyChanges(fragments, ranges);
        tree = Tree.empty;
        treeLen = 0;
        viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
        if (this.skipped.length) {
          skipped = [];
          for (let r of this.skipped) {
            let from17 = changes.mapPos(r.from, 1), to10 = changes.mapPos(r.to, -1);
            if (from17 < to10)
              skipped.push({ from: from17, to: to10 });
          }
        }
      }
      return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    updateViewport(viewport) {
      if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
        return false;
      this.viewport = viewport;
      let startLen = this.skipped.length;
      for (let i = 0; i < this.skipped.length; i++) {
        let { from: from17, to: to10 } = this.skipped[i];
        if (from17 < viewport.to && to10 > viewport.from) {
          this.fragments = cutFragments(this.fragments, from17, to10);
          this.skipped.splice(i--, 1);
        }
      }
      if (this.skipped.length >= startLen)
        return false;
      this.reset();
      return true;
    }
    reset() {
      if (this.parse) {
        this.takeTree();
        this.parse = null;
      }
    }
    skipUntilInView(from17, to10) {
      this.skipped.push({ from: from17, to: to10 });
    }
    static getSkippingParser(until) {
      return new class extends Parser {
        createParse(input2, fragments, ranges) {
          let from17 = ranges[0].from, to10 = ranges[ranges.length - 1].to;
          let parser19 = {
            parsedPos: from17,
            advance() {
              let cx = currentContext;
              if (cx) {
                for (let r of ranges)
                  cx.tempSkipped.push(r);
                if (until)
                  cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
              }
              this.parsedPos = to10;
              return new Tree(NodeType.none, [], [], to10 - from17);
            },
            stoppedAt: null,
            stopAt() {
            }
          };
          return parser19;
        }
      }();
    }
    isDone(upto) {
      upto = Math.min(upto, this.state.doc.length);
      let frags = this.fragments;
      return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    static get() {
      return currentContext;
    }
  };
  function cutFragments(fragments, from17, to10) {
    return TreeFragment.applyChanges(fragments, [{ fromA: from17, toA: to10, fromB: from17, toB: to10 }]);
  }
  var LanguageState = class {
    constructor(context2) {
      this.context = context2;
      this.tree = context2.tree;
    }
    apply(tr3) {
      if (!tr3.docChanged && this.tree == this.context.tree)
        return this;
      let newCx = this.context.changes(tr3.changes, tr3.state);
      let upto = this.context.treeLen == tr3.startState.doc.length ? void 0 : Math.max(tr3.changes.mapPos(this.context.treeLen), newCx.viewport.to);
      if (!newCx.work(20, upto))
        newCx.takeTree();
      return new LanguageState(newCx);
    }
    static init(state) {
      let vpTo = Math.min(3e3, state.doc.length);
      let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
      if (!parseState.work(20, vpTo))
        parseState.takeTree();
      return new LanguageState(parseState);
    }
  };
  Language.state = /* @__PURE__ */ StateField.define({
    create: LanguageState.init,
    update(value, tr3) {
      for (let e of tr3.effects)
        if (e.is(Language.setState))
          return e.value;
      if (tr3.startState.facet(language) != tr3.state.facet(language))
        return LanguageState.init(tr3.state);
      return value.apply(tr3);
    }
  });
  var requestIdle = (callback2) => {
    let timeout2 = setTimeout(() => callback2(), 500);
    return () => clearTimeout(timeout2);
  };
  if (typeof requestIdleCallback != "undefined")
    requestIdle = (callback2) => {
      let idle = -1, timeout2 = setTimeout(() => {
        idle = requestIdleCallback(callback2, { timeout: 500 - 100 });
      }, 100);
      return () => idle < 0 ? clearTimeout(timeout2) : cancelIdleCallback(idle);
    };
  var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
  var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
    constructor(view) {
      this.view = view;
      this.working = null;
      this.workScheduled = 0;
      this.chunkEnd = -1;
      this.chunkBudget = -1;
      this.work = this.work.bind(this);
      this.scheduleWork();
    }
    update(update) {
      let cx = this.view.state.field(Language.state).context;
      if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
        this.scheduleWork();
      if (update.docChanged) {
        if (this.view.hasFocus)
          this.chunkBudget += 50;
        this.scheduleWork();
      }
      this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
      if (this.working)
        return;
      let { state } = this.view, field = state.field(Language.state);
      if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
        this.working = requestIdle(this.work);
    }
    work(deadline) {
      this.working = null;
      let now = Date.now();
      if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
        this.chunkEnd = now + 3e4;
        this.chunkBudget = 3e3;
      }
      if (this.chunkBudget <= 0)
        return;
      let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
      if (field.tree == field.context.tree && field.context.isDone(vpTo + 1e5))
        return;
      let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
      let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
      let done = field.context.work(() => {
        return isInputPending && isInputPending() || Date.now() > endTime;
      }, vpTo + (viewportFirst ? 0 : 1e5));
      this.chunkBudget -= Date.now() - now;
      if (done || this.chunkBudget <= 0) {
        field.context.takeTree();
        this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
      }
      if (this.chunkBudget > 0 && !(done && !viewportFirst))
        this.scheduleWork();
      this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
      if (cx.scheduleOn) {
        this.workScheduled++;
        cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
        cx.scheduleOn = null;
      }
    }
    destroy() {
      if (this.working)
        this.working();
    }
    isWorking() {
      return !!(this.working || this.workScheduled > 0);
    }
  }, {
    eventHandlers: { focus() {
      this.scheduleWork();
    } }
  });
  var language = /* @__PURE__ */ Facet.define({
    combine(languages) {
      return languages.length ? languages[0] : null;
    },
    enables: (language2) => [
      Language.state,
      parseWorker,
      EditorView.contentAttributes.compute([language2], (state) => {
        let lang = state.facet(language2);
        return lang && lang.name ? { "data-language": lang.name } : {};
      })
    ]
  });
  var LanguageSupport = class {
    constructor(language2, support = []) {
      this.language = language2;
      this.support = support;
      this.extension = [language2, support];
    }
  };
  var indentService = /* @__PURE__ */ Facet.define();
  var indentUnit = /* @__PURE__ */ Facet.define({
    combine: (values) => {
      if (!values.length)
        return "  ";
      let unit = values[0];
      if (!unit || /\S/.test(unit) || Array.from(unit).some((e) => e != unit[0]))
        throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
      return unit;
    }
  });
  function getIndentUnit(state) {
    let unit = state.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
  }
  function indentString(state, cols) {
    let result = "", ts2 = state.tabSize, ch2 = state.facet(indentUnit)[0];
    if (ch2 == "	") {
      while (cols >= ts2) {
        result += "	";
        cols -= ts2;
      }
      ch2 = " ";
    }
    for (let i = 0; i < cols; i++)
      result += ch2;
    return result;
  }
  function getIndentation(context2, pos) {
    if (context2 instanceof EditorState)
      context2 = new IndentContext(context2);
    for (let service of context2.state.facet(indentService)) {
      let result = service(context2, pos);
      if (result !== void 0)
        return result;
    }
    let tree = syntaxTree(context2.state);
    return tree.length >= pos ? syntaxIndentation(context2, tree, pos) : null;
  }
  var IndentContext = class {
    constructor(state, options = {}) {
      this.state = state;
      this.options = options;
      this.unit = getIndentUnit(state);
    }
    lineAt(pos, bias = 1) {
      let line = this.state.doc.lineAt(pos);
      let { simulateBreak, simulateDoubleBreak } = this.options;
      if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
        if (simulateDoubleBreak && simulateBreak == pos)
          return { text: "", from: pos };
        else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
          return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
        else
          return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
      }
      return line;
    }
    textAfterPos(pos, bias = 1) {
      if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
        return "";
      let { text, from: from17 } = this.lineAt(pos, bias);
      return text.slice(pos - from17, Math.min(text.length, pos + 100 - from17));
    }
    column(pos, bias = 1) {
      let { text, from: from17 } = this.lineAt(pos, bias);
      let result = this.countColumn(text, pos - from17);
      let override = this.options.overrideIndentation ? this.options.overrideIndentation(from17) : -1;
      if (override > -1)
        result += override - this.countColumn(text, text.search(/\S|$/));
      return result;
    }
    countColumn(line, pos = line.length) {
      return countColumn(line, this.state.tabSize, pos);
    }
    lineIndent(pos, bias = 1) {
      let { text, from: from17 } = this.lineAt(pos, bias);
      let override = this.options.overrideIndentation;
      if (override) {
        let overriden = override(from17);
        if (overriden > -1)
          return overriden;
      }
      return this.countColumn(text, text.search(/\S|$/));
    }
    get simulatedBreak() {
      return this.options.simulateBreak || null;
    }
  };
  var indentNodeProp = /* @__PURE__ */ new NodeProp();
  function syntaxIndentation(cx, ast, pos) {
    return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
  }
  function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
  }
  function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
      return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(NodeProp.closedBy))) {
      let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
      return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
    }
    return tree.parent == null ? topIndent : null;
  }
  function indentFrom(node, pos, base2) {
    for (; node; node = node.parent) {
      let strategy = indentStrategy(node);
      if (strategy)
        return strategy(TreeIndentContext.create(base2, pos, node));
    }
    return null;
  }
  function topIndent() {
    return 0;
  }
  var TreeIndentContext = class extends IndentContext {
    constructor(base2, pos, node) {
      super(base2.state, base2.options);
      this.base = base2;
      this.pos = pos;
      this.node = node;
    }
    static create(base2, pos, node) {
      return new TreeIndentContext(base2, pos, node);
    }
    get textAfter() {
      return this.textAfterPos(this.pos);
    }
    get baseIndent() {
      return this.baseIndentFor(this.node);
    }
    baseIndentFor(node) {
      let line = this.state.doc.lineAt(node.from);
      for (; ; ) {
        let atBreak = node.resolve(line.from);
        while (atBreak.parent && atBreak.parent.from == atBreak.from)
          atBreak = atBreak.parent;
        if (isParent(atBreak, node))
          break;
        line = this.state.doc.lineAt(atBreak.from);
      }
      return this.lineIndent(line.from);
    }
    continue() {
      let parent = this.node.parent;
      return parent ? indentFrom(parent, this.pos, this.base) : 0;
    }
  };
  function isParent(parent, of) {
    for (let cur = of; cur; cur = cur.parent)
      if (parent == cur)
        return true;
    return false;
  }
  function bracketedAligned(context2) {
    let tree = context2.node;
    let openToken = tree.childAfter(tree.from), last = tree.lastChild;
    if (!openToken)
      return null;
    let sim = context2.options.simulateBreak;
    let openLine = context2.state.doc.lineAt(openToken.from);
    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to; ; ) {
      let next = tree.childAfter(pos);
      if (!next || next == last)
        return null;
      if (!next.type.isSkipped)
        return next.from < lineEnd ? openToken : null;
      pos = next.to;
    }
  }
  function delimitedStrategy(context2, align, units, closing, closedAt) {
    let after = context2.textAfter, space = after.match(/^\s*/)[0].length;
    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context2.pos + space;
    let aligned = align ? bracketedAligned(context2) : null;
    if (aligned)
      return closed ? context2.column(aligned.from) : context2.column(aligned.to);
    return context2.baseIndent + (closed ? 0 : context2.unit * units);
  }
  var DontIndentBeyond = 200;
  function indentOnInput() {
    return EditorState.transactionFilter.of((tr3) => {
      if (!tr3.docChanged || !tr3.isUserEvent("input.type") && !tr3.isUserEvent("input.complete"))
        return tr3;
      let rules = tr3.startState.languageDataAt("indentOnInput", tr3.startState.selection.main.head);
      if (!rules.length)
        return tr3;
      let doc2 = tr3.newDoc, { head } = tr3.newSelection.main, line = doc2.lineAt(head);
      if (head > line.from + DontIndentBeyond)
        return tr3;
      let lineStart = doc2.sliceString(line.from, head);
      if (!rules.some((r) => r.test(lineStart)))
        return tr3;
      let { state } = tr3, last = -1, changes = [];
      for (let { head: head2 } of state.selection.ranges) {
        let line2 = state.doc.lineAt(head2);
        if (line2.from == last)
          continue;
        last = line2.from;
        let indent = getIndentation(state, line2.from);
        if (indent == null)
          continue;
        let cur = /^\s*/.exec(line2.text)[0];
        let norm = indentString(state, indent);
        if (cur != norm)
          changes.push({ from: line2.from, to: line2.from + cur.length, insert: norm });
      }
      return changes.length ? [tr3, { changes, sequential: true }] : tr3;
    });
  }
  var HighlightStyle = class {
    constructor(specs, options) {
      this.specs = specs;
      let modSpec;
      function def2(spec) {
        let cls = StyleModule.newName();
        (modSpec || (modSpec = Object.create(null)))["." + cls] = spec;
        return cls;
      }
      const all = typeof options.all == "string" ? options.all : options.all ? def2(options.all) : void 0;
      const scopeOpt = options.scope;
      this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
      this.style = tagHighlighter(specs.map((style) => ({
        tag: style.tag,
        class: style.class || def2(Object.assign({}, style, { tag: null }))
      })), {
        all
      }).style;
      this.module = modSpec ? new StyleModule(modSpec) : null;
      this.themeType = options.themeType;
    }
    static define(specs, options) {
      return new HighlightStyle(specs, options || {});
    }
  };
  var highlighterFacet = /* @__PURE__ */ Facet.define();
  var fallbackHighlighter = /* @__PURE__ */ Facet.define({
    combine(values) {
      return values.length ? [values[0]] : null;
    }
  });
  function getHighlighters(state) {
    let main = state.facet(highlighterFacet);
    return main.length ? main : state.facet(fallbackHighlighter);
  }
  function syntaxHighlighting(highlighter, options) {
    let ext = [treeHighlighter], themeType;
    if (highlighter instanceof HighlightStyle) {
      if (highlighter.module)
        ext.push(EditorView.styleModule.of(highlighter.module));
      themeType = highlighter.themeType;
    }
    if (options === null || options === void 0 ? void 0 : options.fallback)
      ext.push(fallbackHighlighter.of(highlighter));
    else if (themeType)
      ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
        return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
      }));
    else
      ext.push(highlighterFacet.of(highlighter));
    return ext;
  }
  var TreeHighlighter = class {
    constructor(view) {
      this.markCache = Object.create(null);
      this.tree = syntaxTree(view.state);
      this.decorations = this.buildDeco(view, getHighlighters(view.state));
    }
    update(update) {
      let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
      let styleChange = highlighters != getHighlighters(update.startState);
      if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
        this.decorations = this.decorations.map(update.changes);
      } else if (tree != this.tree || update.viewportChanged || styleChange) {
        this.tree = tree;
        this.decorations = this.buildDeco(update.view, highlighters);
      }
    }
    buildDeco(view, highlighters) {
      if (!highlighters || !this.tree.length)
        return Decoration.none;
      let builder = new RangeSetBuilder();
      for (let { from: from17, to: to10 } of view.visibleRanges) {
        highlightTree(this.tree, highlighters, (from18, to11, style) => {
          builder.add(from18, to11, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
        }, from17, to10);
      }
      return builder.finish();
    }
  };
  var treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
    decorations: (v) => v.decorations
  }));
  var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
    {
      tag: tags.meta,
      color: "#404740"
    },
    {
      tag: tags.link,
      textDecoration: "underline"
    },
    {
      tag: tags.heading,
      textDecoration: "underline",
      fontWeight: "bold"
    },
    {
      tag: tags.emphasis,
      fontStyle: "italic"
    },
    {
      tag: tags.strong,
      fontWeight: "bold"
    },
    {
      tag: tags.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: tags.keyword,
      color: "#708"
    },
    {
      tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
      color: "#219"
    },
    {
      tag: [tags.literal, tags.inserted],
      color: "#164"
    },
    {
      tag: [tags.string, tags.deleted],
      color: "#a11"
    },
    {
      tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
      color: "#e40"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.variableName),
      color: "#00f"
    },
    {
      tag: /* @__PURE__ */ tags.local(tags.variableName),
      color: "#30a"
    },
    {
      tag: [tags.typeName, tags.namespace],
      color: "#085"
    },
    {
      tag: tags.className,
      color: "#167"
    },
    {
      tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
      color: "#256"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.propertyName),
      color: "#00c"
    },
    {
      tag: tags.comment,
      color: "#940"
    },
    {
      tag: tags.invalid,
      color: "#f00"
    }
  ]);
  var DefaultScanDist = 1e4;
  var DefaultBrackets = "()[]{}";
  var bracketMatchingHandle = /* @__PURE__ */ new NodeProp();
  function matchingNodes(node, dir, brackets) {
    let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
    if (byProp)
      return byProp;
    if (node.name.length == 1) {
      let index3 = brackets.indexOf(node.name);
      if (index3 > -1 && index3 % 2 == (dir < 0 ? 1 : 0))
        return [brackets[index3 + dir]];
    }
    return null;
  }
  function findHandle(node) {
    let hasHandle = node.type.prop(bracketMatchingHandle);
    return hasHandle ? hasHandle(node.node) : node;
  }
  function matchBrackets(state, pos, dir, config = {}) {
    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;
    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
    for (let cur = node; cur; cur = cur.parent) {
      let matches2 = matchingNodes(cur.type, dir, brackets);
      if (matches2 && cur.from < cur.to) {
        let handle = findHandle(cur);
        if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
          return matchMarkedBrackets(state, pos, dir, cur, handle, matches2, brackets);
      }
    }
    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
  }
  function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
    let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
      do {
        if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
          if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
            let endHandle = findHandle(cursor);
            return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0, matched: true };
          } else if (matchingNodes(cursor.type, dir, brackets)) {
            depth++;
          } else if (matchingNodes(cursor.type, -dir, brackets)) {
            if (depth == 0) {
              let endHandle = findHandle(cursor);
              return {
                start: firstToken,
                end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : void 0,
                matched: false
              };
            }
            depth--;
          }
        }
      } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
    return { start: firstToken, matched: false };
  }
  function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
    let bracket2 = brackets.indexOf(startCh);
    if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
      return null;
    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
    for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
      let text = iter.value;
      if (dir < 0)
        distance += text.length;
      let basePos = pos + distance * dir;
      for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
        let found = brackets.indexOf(text[pos2]);
        if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
          continue;
        if (found % 2 == 0 == dir > 0) {
          depth++;
        } else if (depth == 1) {
          return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
        } else {
          depth--;
        }
      }
      if (dir > 0)
        distance += text.length;
    }
    return iter.done ? { start: startToken, matched: false } : null;
  }
  var noTokens = /* @__PURE__ */ Object.create(null);
  var typeArray = [NodeType.none];
  var warned = [];
  var defaultTable = /* @__PURE__ */ Object.create(null);
  for (let [legacyName, name2] of [
    ["variable", "variableName"],
    ["variable-2", "variableName.special"],
    ["string-2", "string.special"],
    ["def", "variableName.definition"],
    ["tag", "tagName"],
    ["attribute", "attributeName"],
    ["type", "typeName"],
    ["builtin", "variableName.standard"],
    ["qualifier", "modifier"],
    ["error", "invalid"],
    ["header", "heading"],
    ["property", "propertyName"]
  ])
    defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2);
  function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1)
      return;
    warned.push(part);
    console.warn(msg);
  }
  function createTokenType(extra, tagStr) {
    let tag = null;
    for (let part of tagStr.split(".")) {
      let value = extra[part] || tags[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!tag)
          warnForPart(part, `Modifier ${part} used at start of tag`);
        else
          tag = value(tag);
      } else {
        if (tag)
          warnForPart(part, `Tag ${part} used as modifier`);
        else
          tag = value;
      }
    }
    if (!tag)
      return 0;
    let name2 = tagStr.replace(/ /g, "_"), type = NodeType.define({
      id: typeArray.length,
      name: name2,
      props: [styleTags({ [name2]: tag })]
    });
    typeArray.push(type);
    return type.id;
  }

  // node_modules/@codemirror/commands/dist/index.js
  var toggleComment = (target) => {
    let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);
    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
  };
  function command(f, option2) {
    return ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      let tr3 = f(option2, state);
      if (!tr3)
        return false;
      dispatch(state.update(tr3));
      return true;
    };
  }
  var toggleLineComment = /* @__PURE__ */ command(changeLineComment, 0);
  var toggleBlockComment = /* @__PURE__ */ command(changeBlockComment, 0);
  var toggleBlockCommentByLine = /* @__PURE__ */ command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0);
  function getConfig(state, pos) {
    let data = state.languageDataAt("commentTokens", pos);
    return data.length ? data[0] : {};
  }
  var SearchMargin = 50;
  function findBlockComment(state, { open, close }, from17, to10) {
    let textBefore = state.sliceDoc(from17 - SearchMargin, from17);
    let textAfter = state.sliceDoc(to10, to10 + SearchMargin);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
      return {
        open: { pos: from17 - spaceBefore, margin: spaceBefore && 1 },
        close: { pos: to10 + spaceAfter, margin: spaceAfter && 1 }
      };
    }
    let startText, endText;
    if (to10 - from17 <= 2 * SearchMargin) {
      startText = endText = state.sliceDoc(from17, to10);
    } else {
      startText = state.sliceDoc(from17, from17 + SearchMargin);
      endText = state.sliceDoc(to10 - SearchMargin, to10);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
      return {
        open: {
          pos: from17 + startSpace + open.length,
          margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
        },
        close: {
          pos: to10 - endSpace - close.length,
          margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
        }
      };
    }
    return null;
  }
  function selectedLineRanges(state) {
    let ranges = [];
    for (let r of state.selection.ranges) {
      let fromLine = state.doc.lineAt(r.from);
      let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
      let last = ranges.length - 1;
      if (last >= 0 && ranges[last].to > fromLine.from)
        ranges[last].to = toLine.to;
      else
        ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
    }
    return ranges;
  }
  function changeBlockComment(option2, state, ranges = state.selection.ranges) {
    let tokens = ranges.map((r) => getConfig(state, r.from).block);
    if (!tokens.every((c2) => c2))
      return null;
    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
    if (option2 != 2 && !comments.every((c2) => c2)) {
      return { changes: state.changes(ranges.map((range10, i) => {
        if (comments[i])
          return [];
        return [{ from: range10.from, insert: tokens[i].open + " " }, { from: range10.to, insert: " " + tokens[i].close }];
      })) };
    } else if (option2 != 1 && comments.some((c2) => c2)) {
      let changes = [];
      for (let i = 0, comment2; i < comments.length; i++)
        if (comment2 = comments[i]) {
          let token = tokens[i], { open, close } = comment2;
          changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
        }
      return { changes };
    }
    return null;
  }
  function changeLineComment(option2, state, ranges = state.selection.ranges) {
    let lines = [];
    let prevLine = -1;
    for (let { from: from17, to: to10 } of ranges) {
      let startI = lines.length, minIndent = 1e9;
      let token = getConfig(state, from17).line;
      if (!token)
        continue;
      for (let pos = from17; pos <= to10; ) {
        let line = state.doc.lineAt(pos);
        if (line.from > prevLine && (from17 == to10 || to10 > line.from)) {
          prevLine = line.from;
          let indent = /^\s*/.exec(line.text)[0].length;
          let empty2 = indent == line.length;
          let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
          if (indent < line.text.length && indent < minIndent)
            minIndent = indent;
          lines.push({ line, comment: comment2, token, indent, empty: empty2, single: false });
        }
        pos = line.to + 1;
      }
      if (minIndent < 1e9) {
        for (let i = startI; i < lines.length; i++)
          if (lines[i].indent < lines[i].line.text.length)
            lines[i].indent = minIndent;
      }
      if (lines.length == startI + 1)
        lines[startI].single = true;
    }
    if (option2 != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
      let changes = [];
      for (let { line, token, indent, empty: empty2, single } of lines)
        if (single || !empty2)
          changes.push({ from: line.from + indent, insert: token + " " });
      let changeSet = state.changes(changes);
      return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
    } else if (option2 != 1 && lines.some((l) => l.comment >= 0)) {
      let changes = [];
      for (let { line, comment: comment2, token } of lines)
        if (comment2 >= 0) {
          let from17 = line.from + comment2, to10 = from17 + token.length;
          if (line.text[to10 - line.from] == " ")
            to10++;
          changes.push({ from: from17, to: to10 });
        }
      return { changes };
    }
    return null;
  }
  var fromHistory = /* @__PURE__ */ Annotation.define();
  var isolateHistory = /* @__PURE__ */ Annotation.define();
  var invertedEffects = /* @__PURE__ */ Facet.define();
  var historyConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        minDepth: 100,
        newGroupDelay: 500,
        joinToEvent: (_t2, isAdjacent2) => isAdjacent2
      }, {
        minDepth: Math.max,
        newGroupDelay: Math.min,
        joinToEvent: (a, b) => (tr3, adj) => a(tr3, adj) || b(tr3, adj)
      });
    }
  });
  function changeEnd(changes) {
    let end = 0;
    changes.iterChangedRanges((_, to10) => end = to10);
    return end;
  }
  var historyField_ = /* @__PURE__ */ StateField.define({
    create() {
      return HistoryState.empty;
    },
    update(state, tr3) {
      let config = tr3.state.facet(historyConfig);
      let fromHist = tr3.annotation(fromHistory);
      if (fromHist) {
        let selection2 = tr3.docChanged ? EditorSelection.single(changeEnd(tr3.changes)) : void 0;
        let item = HistEvent.fromTransaction(tr3, selection2), from17 = fromHist.side;
        let other = from17 == 0 ? state.undone : state.done;
        if (item)
          other = updateBranch(other, other.length, config.minDepth, item);
        else
          other = addSelection(other, tr3.startState.selection);
        return new HistoryState(from17 == 0 ? fromHist.rest : other, from17 == 0 ? other : fromHist.rest);
      }
      let isolate = tr3.annotation(isolateHistory);
      if (isolate == "full" || isolate == "before")
        state = state.isolate();
      if (tr3.annotation(Transaction.addToHistory) === false)
        return !tr3.changes.empty ? state.addMapping(tr3.changes.desc) : state;
      let event2 = HistEvent.fromTransaction(tr3);
      let time = tr3.annotation(Transaction.time), userEvent = tr3.annotation(Transaction.userEvent);
      if (event2)
        state = state.addChanges(event2, time, userEvent, config, tr3);
      else if (tr3.selection)
        state = state.addSelection(tr3.startState.selection, time, userEvent, config.newGroupDelay);
      if (isolate == "full" || isolate == "after")
        state = state.isolate();
      return state;
    },
    toJSON(value) {
      return { done: value.done.map((e) => e.toJSON()), undone: value.undone.map((e) => e.toJSON()) };
    },
    fromJSON(json) {
      return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
    }
  });
  function history(config = {}) {
    return [
      historyField_,
      historyConfig.of(config),
      EditorView.domEventHandlers({
        beforeinput(e, view) {
          let command2 = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e.preventDefault();
          return command2(view);
        }
      })
    ];
  }
  function cmd(side, selection2) {
    return function({ state, dispatch }) {
      if (!selection2 && state.readOnly)
        return false;
      let historyState = state.field(historyField_, false);
      if (!historyState)
        return false;
      let tr3 = historyState.pop(side, state, selection2);
      if (!tr3)
        return false;
      dispatch(tr3);
      return true;
    };
  }
  var undo = /* @__PURE__ */ cmd(0, false);
  var redo = /* @__PURE__ */ cmd(1, false);
  var undoSelection = /* @__PURE__ */ cmd(0, true);
  var redoSelection = /* @__PURE__ */ cmd(1, true);
  var HistEvent = class {
    constructor(changes, effects2, mapped, startSelection, selectionsAfter) {
      this.changes = changes;
      this.effects = effects2;
      this.mapped = mapped;
      this.startSelection = startSelection;
      this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
      return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
      var _a3, _b, _c2;
      return {
        changes: (_a3 = this.changes) === null || _a3 === void 0 ? void 0 : _a3.toJSON(),
        mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
        startSelection: (_c2 = this.startSelection) === null || _c2 === void 0 ? void 0 : _c2.toJSON(),
        selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
      };
    }
    static fromJSON(json) {
      return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
    }
    static fromTransaction(tr3, selection2) {
      let effects2 = none2;
      for (let invert of tr3.startState.facet(invertedEffects)) {
        let result = invert(tr3);
        if (result.length)
          effects2 = effects2.concat(result);
      }
      if (!effects2.length && tr3.changes.empty)
        return null;
      return new HistEvent(tr3.changes.invert(tr3.startState.doc), effects2, void 0, selection2 || tr3.startState.selection, none2);
    }
    static selection(selections) {
      return new HistEvent(void 0, none2, void 0, void 0, selections);
    }
  };
  function updateBranch(branch, to10, maxLen, newEvent) {
    let start2 = to10 + 1 > maxLen + 20 ? to10 - maxLen - 1 : 0;
    let newBranch = branch.slice(start2, to10);
    newBranch.push(newEvent);
    return newBranch;
  }
  function isAdjacent(a, b) {
    let ranges = [], isAdjacent2 = false;
    a.iterChangedRanges((f, t2) => ranges.push(f, t2));
    b.iterChangedRanges((_f, _t2, f, t2) => {
      for (let i = 0; i < ranges.length; ) {
        let from17 = ranges[i++], to10 = ranges[i++];
        if (t2 >= from17 && f <= to10)
          isAdjacent2 = true;
      }
    });
    return isAdjacent2;
  }
  function eqSelectionShape(a, b) {
    return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
  }
  function conc(a, b) {
    return !a.length ? b : !b.length ? a : a.concat(b);
  }
  var none2 = [];
  var MaxSelectionsPerEvent = 200;
  function addSelection(branch, selection2) {
    if (!branch.length) {
      return [HistEvent.selection([selection2])];
    } else {
      let lastEvent = branch[branch.length - 1];
      let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
      if (sels.length && sels[sels.length - 1].eq(selection2))
        return branch;
      sels.push(selection2);
      return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
  }
  function popSelection(branch) {
    let last = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
    return newBranch;
  }
  function addMappingToBranch(branch, mapping) {
    if (!branch.length)
      return branch;
    let length = branch.length, selections = none2;
    while (length) {
      let event2 = mapEvent(branch[length - 1], mapping, selections);
      if (event2.changes && !event2.changes.empty || event2.effects.length) {
        let result = branch.slice(0, length);
        result[length - 1] = event2;
        return result;
      } else {
        mapping = event2.mapped;
        length--;
        selections = event2.selectionsAfter;
      }
    }
    return selections.length ? [HistEvent.selection(selections)] : none2;
  }
  function mapEvent(event2, mapping, extraSelections) {
    let selections = conc(event2.selectionsAfter.length ? event2.selectionsAfter.map((s) => s.map(mapping)) : none2, extraSelections);
    if (!event2.changes)
      return HistEvent.selection(selections);
    let mappedChanges = event2.changes.map(mapping), before = mapping.mapDesc(event2.changes, true);
    let fullMapping = event2.mapped ? event2.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, StateEffect.mapEffects(event2.effects, mapping), fullMapping, event2.startSelection.map(before), selections);
  }
  var joinableUserEvent = /^(input\.type|delete)($|\.)/;
  var HistoryState = class {
    constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
      this.done = done;
      this.undone = undone;
      this.prevTime = prevTime;
      this.prevUserEvent = prevUserEvent;
    }
    isolate() {
      return this.prevTime ? new HistoryState(this.done, this.undone) : this;
    }
    addChanges(event2, time, userEvent, config, tr3) {
      let done = this.done, lastEvent = done[done.length - 1];
      if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event2.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr3, isAdjacent(lastEvent.changes, event2.changes)) || userEvent == "input.type.compose")) {
        done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event2.changes.compose(lastEvent.changes), conc(event2.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none2));
      } else {
        done = updateBranch(done, done.length, config.minDepth, event2);
      }
      return new HistoryState(done, none2, time, userEvent);
    }
    addSelection(selection2, time, userEvent, newGroupDelay) {
      let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none2;
      if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection2))
        return this;
      return new HistoryState(addSelection(this.done, selection2), this.undone, time, userEvent);
    }
    addMapping(mapping) {
      return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state, selection2) {
      let branch = side == 0 ? this.done : this.undone;
      if (branch.length == 0)
        return null;
      let event2 = branch[branch.length - 1];
      if (selection2 && event2.selectionsAfter.length) {
        return state.update({
          selection: event2.selectionsAfter[event2.selectionsAfter.length - 1],
          annotations: fromHistory.of({ side, rest: popSelection(branch) }),
          userEvent: side == 0 ? "select.undo" : "select.redo",
          scrollIntoView: true
        });
      } else if (!event2.changes) {
        return null;
      } else {
        let rest = branch.length == 1 ? none2 : branch.slice(0, branch.length - 1);
        if (event2.mapped)
          rest = addMappingToBranch(rest, event2.mapped);
        return state.update({
          changes: event2.changes,
          selection: event2.startSelection,
          effects: event2.effects,
          annotations: fromHistory.of({ side, rest }),
          filter: false,
          userEvent: side == 0 ? "undo" : "redo",
          scrollIntoView: true
        });
      }
    }
  };
  HistoryState.empty = /* @__PURE__ */ new HistoryState(none2, none2);
  var historyKeymap = [
    { key: "Mod-z", run: undo, preventDefault: true },
    { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
    { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
    { key: "Mod-u", run: undoSelection, preventDefault: true },
    { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
  ];
  function updateSel(sel, by) {
    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
  }
  function setSel(state, selection2) {
    return state.update({ selection: selection2, scrollIntoView: true, userEvent: "select" });
  }
  function moveSel({ state, dispatch }, how) {
    let selection2 = updateSel(state.selection, how);
    if (selection2.eq(state.selection))
      return false;
    dispatch(setSel(state, selection2));
    return true;
  }
  function rangeEnd(range10, forward18) {
    return EditorSelection.cursor(forward18 ? range10.to : range10.from);
  }
  function cursorByChar(view, forward18) {
    return moveSel(view, (range10) => range10.empty ? view.moveByChar(range10, forward18) : rangeEnd(range10, forward18));
  }
  function ltrAtCursor(view) {
    return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
  }
  var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
  var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
  function cursorByGroup(view, forward18) {
    return moveSel(view, (range10) => range10.empty ? view.moveByGroup(range10, forward18) : rangeEnd(range10, forward18));
  }
  var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
  var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
  var segmenter = typeof Intl != "undefined" && Intl.Segmenter ? /* @__PURE__ */ new Intl.Segmenter(void 0, { granularity: "word" }) : null;
  function interestingNode(state, node, bracketProp) {
    if (node.type.prop(bracketProp))
      return true;
    let len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
  }
  function moveBySyntax(state, start2, forward18) {
    let pos = syntaxTree(state).resolveInner(start2.head);
    let bracketProp = forward18 ? NodeProp.closedBy : NodeProp.openedBy;
    for (let at14 = start2.head; ; ) {
      let next = forward18 ? pos.childAfter(at14) : pos.childBefore(at14);
      if (!next)
        break;
      if (interestingNode(state, next, bracketProp))
        pos = next;
      else
        at14 = forward18 ? next.to : next.from;
    }
    let bracket2 = pos.type.prop(bracketProp), match, newPos;
    if (bracket2 && (match = forward18 ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
      newPos = forward18 ? match.end.to : match.end.from;
    else
      newPos = forward18 ? pos.to : pos.from;
    return EditorSelection.cursor(newPos, forward18 ? -1 : 1);
  }
  var cursorSyntaxLeft = (view) => moveSel(view, (range10) => moveBySyntax(view.state, range10, !ltrAtCursor(view)));
  var cursorSyntaxRight = (view) => moveSel(view, (range10) => moveBySyntax(view.state, range10, ltrAtCursor(view)));
  function cursorByLine(view, forward18) {
    return moveSel(view, (range10) => {
      if (!range10.empty)
        return rangeEnd(range10, forward18);
      let moved2 = view.moveVertically(range10, forward18);
      return moved2.head != range10.head ? moved2 : view.moveToLineBoundary(range10, forward18);
    });
  }
  var cursorLineUp = (view) => cursorByLine(view, false);
  var cursorLineDown = (view) => cursorByLine(view, true);
  function pageInfo(view) {
    let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
    let marginTop = 0, marginBottom = 0, height;
    if (selfScroll) {
      for (let source of view.state.facet(EditorView.scrollMargins)) {
        let margins = source(view);
        if (margins === null || margins === void 0 ? void 0 : margins.top)
          marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
        if (margins === null || margins === void 0 ? void 0 : margins.bottom)
          marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
      }
      height = view.scrollDOM.clientHeight - marginTop - marginBottom;
    } else {
      height = (view.dom.ownerDocument.defaultView || window).innerHeight;
    }
    return {
      marginTop,
      marginBottom,
      selfScroll,
      height: Math.max(view.defaultLineHeight, height - 5)
    };
  }
  function cursorByPage(view, forward18) {
    let page = pageInfo(view);
    let { state } = view, selection2 = updateSel(state.selection, (range10) => {
      return range10.empty ? view.moveVertically(range10, forward18, page.height) : rangeEnd(range10, forward18);
    });
    if (selection2.eq(state.selection))
      return false;
    let effect;
    if (page.selfScroll) {
      let startPos = view.coordsAtPos(state.selection.main.head);
      let scrollRect = view.scrollDOM.getBoundingClientRect();
      let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
      if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
        effect = EditorView.scrollIntoView(selection2.main.head, { y: "start", yMargin: startPos.top - scrollTop });
    }
    view.dispatch(setSel(state, selection2), { effects: effect });
    return true;
  }
  var cursorPageUp = (view) => cursorByPage(view, false);
  var cursorPageDown = (view) => cursorByPage(view, true);
  function moveByLineBoundary(view, start2, forward18) {
    let line = view.lineBlockAt(start2.head), moved2 = view.moveToLineBoundary(start2, forward18);
    if (moved2.head == start2.head && moved2.head != (forward18 ? line.to : line.from))
      moved2 = view.moveToLineBoundary(start2, forward18, false);
    if (!forward18 && moved2.head == line.from && line.length) {
      let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
      if (space && start2.head != line.from + space)
        moved2 = EditorSelection.cursor(line.from + space);
    }
    return moved2;
  }
  var cursorLineBoundaryForward = (view) => moveSel(view, (range10) => moveByLineBoundary(view, range10, true));
  var cursorLineBoundaryBackward = (view) => moveSel(view, (range10) => moveByLineBoundary(view, range10, false));
  var cursorLineBoundaryLeft = (view) => moveSel(view, (range10) => moveByLineBoundary(view, range10, !ltrAtCursor(view)));
  var cursorLineBoundaryRight = (view) => moveSel(view, (range10) => moveByLineBoundary(view, range10, ltrAtCursor(view)));
  var cursorLineStart = (view) => moveSel(view, (range10) => EditorSelection.cursor(view.lineBlockAt(range10.head).from, 1));
  var cursorLineEnd = (view) => moveSel(view, (range10) => EditorSelection.cursor(view.lineBlockAt(range10.head).to, -1));
  function toMatchingBracket(state, dispatch, extend3) {
    let found = false, selection2 = updateSel(state.selection, (range10) => {
      let matching = matchBrackets(state, range10.head, -1) || matchBrackets(state, range10.head, 1) || range10.head > 0 && matchBrackets(state, range10.head - 1, 1) || range10.head < state.doc.length && matchBrackets(state, range10.head + 1, -1);
      if (!matching || !matching.end)
        return range10;
      found = true;
      let head = matching.start.from == range10.head ? matching.end.to : matching.end.from;
      return extend3 ? EditorSelection.range(range10.anchor, head) : EditorSelection.cursor(head);
    });
    if (!found)
      return false;
    dispatch(setSel(state, selection2));
    return true;
  }
  var cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
  function extendSel(view, how) {
    let selection2 = updateSel(view.state.selection, (range10) => {
      let head = how(range10);
      return EditorSelection.range(range10.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
    });
    if (selection2.eq(view.state.selection))
      return false;
    view.dispatch(setSel(view.state, selection2));
    return true;
  }
  function selectByChar(view, forward18) {
    return extendSel(view, (range10) => view.moveByChar(range10, forward18));
  }
  var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
  var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
  function selectByGroup(view, forward18) {
    return extendSel(view, (range10) => view.moveByGroup(range10, forward18));
  }
  var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
  var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
  var selectSyntaxLeft = (view) => extendSel(view, (range10) => moveBySyntax(view.state, range10, !ltrAtCursor(view)));
  var selectSyntaxRight = (view) => extendSel(view, (range10) => moveBySyntax(view.state, range10, ltrAtCursor(view)));
  function selectByLine(view, forward18) {
    return extendSel(view, (range10) => view.moveVertically(range10, forward18));
  }
  var selectLineUp = (view) => selectByLine(view, false);
  var selectLineDown = (view) => selectByLine(view, true);
  function selectByPage(view, forward18) {
    return extendSel(view, (range10) => view.moveVertically(range10, forward18, pageInfo(view).height));
  }
  var selectPageUp = (view) => selectByPage(view, false);
  var selectPageDown = (view) => selectByPage(view, true);
  var selectLineBoundaryForward = (view) => extendSel(view, (range10) => moveByLineBoundary(view, range10, true));
  var selectLineBoundaryBackward = (view) => extendSel(view, (range10) => moveByLineBoundary(view, range10, false));
  var selectLineBoundaryLeft = (view) => extendSel(view, (range10) => moveByLineBoundary(view, range10, !ltrAtCursor(view)));
  var selectLineBoundaryRight = (view) => extendSel(view, (range10) => moveByLineBoundary(view, range10, ltrAtCursor(view)));
  var selectLineStart = (view) => extendSel(view, (range10) => EditorSelection.cursor(view.lineBlockAt(range10.head).from));
  var selectLineEnd = (view) => extendSel(view, (range10) => EditorSelection.cursor(view.lineBlockAt(range10.head).to));
  var cursorDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: 0 }));
    return true;
  };
  var cursorDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.doc.length }));
    return true;
  };
  var selectDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
    return true;
  };
  var selectDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
    return true;
  };
  var selectAll = ({ state, dispatch }) => {
    dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
    return true;
  };
  var selectLine = ({ state, dispatch }) => {
    let ranges = selectedLineBlocks(state).map(({ from: from17, to: to10 }) => EditorSelection.range(from17, Math.min(to10 + 1, state.doc.length)));
    dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
    return true;
  };
  var selectParentSyntax = ({ state, dispatch }) => {
    let selection2 = updateSel(state.selection, (range10) => {
      var _a3;
      let context2 = syntaxTree(state).resolveInner(range10.head, 1);
      while (!(context2.from < range10.from && context2.to >= range10.to || context2.to > range10.to && context2.from <= range10.from || !((_a3 = context2.parent) === null || _a3 === void 0 ? void 0 : _a3.parent)))
        context2 = context2.parent;
      return EditorSelection.range(context2.to, context2.from);
    });
    dispatch(setSel(state, selection2));
    return true;
  };
  var simplifySelection = ({ state, dispatch }) => {
    let cur = state.selection, selection2 = null;
    if (cur.ranges.length > 1)
      selection2 = EditorSelection.create([cur.main]);
    else if (!cur.main.empty)
      selection2 = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);
    if (!selection2)
      return false;
    dispatch(setSel(state, selection2));
    return true;
  };
  function deleteBy(target, by) {
    if (target.state.readOnly)
      return false;
    let event2 = "delete.selection", { state } = target;
    let changes = state.changeByRange((range10) => {
      let { from: from17, to: to10 } = range10;
      if (from17 == to10) {
        let towards = by(from17);
        if (towards < from17) {
          event2 = "delete.backward";
          towards = skipAtomic(target, towards, false);
        } else if (towards > from17) {
          event2 = "delete.forward";
          towards = skipAtomic(target, towards, true);
        }
        from17 = Math.min(from17, towards);
        to10 = Math.max(to10, towards);
      } else {
        from17 = skipAtomic(target, from17, false);
        to10 = skipAtomic(target, to10, true);
      }
      return from17 == to10 ? { range: range10 } : { changes: { from: from17, to: to10 }, range: EditorSelection.cursor(from17) };
    });
    if (changes.changes.empty)
      return false;
    target.dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: event2,
      effects: event2 == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
    }));
    return true;
  }
  function skipAtomic(target, pos, forward18) {
    if (target instanceof EditorView)
      for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
        ranges.between(pos, pos, (from17, to10) => {
          if (from17 < pos && to10 > pos)
            pos = forward18 ? to10 : from17;
        });
    return pos;
  }
  var deleteByChar = (target, forward18) => deleteBy(target, (pos) => {
    let { state } = target, line = state.doc.lineAt(pos), before, targetPos;
    if (!forward18 && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
      if (before[before.length - 1] == "	")
        return pos - 1;
      let col = countColumn(before, state.tabSize), drop3 = col % getIndentUnit(state) || getIndentUnit(state);
      for (let i = 0; i < drop3 && before[before.length - 1 - i] == " "; i++)
        pos--;
      targetPos = pos;
    } else {
      targetPos = findClusterBreak(line.text, pos - line.from, forward18, forward18) + line.from;
      if (targetPos == pos && line.number != (forward18 ? state.doc.lines : 1))
        targetPos += forward18 ? 1 : -1;
    }
    return targetPos;
  });
  var deleteCharBackward = (view) => deleteByChar(view, false);
  var deleteCharForward = (view) => deleteByChar(view, true);
  var deleteByGroup = (target, forward18) => deleteBy(target, (start2) => {
    let pos = start2, { state } = target, line = state.doc.lineAt(pos);
    let categorize = state.charCategorizer(pos);
    for (let cat = null; ; ) {
      if (pos == (forward18 ? line.to : line.from)) {
        if (pos == start2 && line.number != (forward18 ? state.doc.lines : 1))
          pos += forward18 ? 1 : -1;
        break;
      }
      let next = findClusterBreak(line.text, pos - line.from, forward18) + line.from;
      let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
      let nextCat = categorize(nextChar);
      if (cat != null && nextCat != cat)
        break;
      if (nextChar != " " || pos != start2)
        cat = nextCat;
      pos = next;
    }
    return pos;
  });
  var deleteGroupBackward = (target) => deleteByGroup(target, false);
  var deleteGroupForward = (target) => deleteByGroup(target, true);
  var deleteToLineEnd = (view) => deleteBy(view, (pos) => {
    let lineEnd = view.lineBlockAt(pos).to;
    return pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1);
  });
  var deleteToLineStart = (view) => deleteBy(view, (pos) => {
    let lineStart = view.lineBlockAt(pos).from;
    return pos > lineStart ? lineStart : Math.max(0, pos - 1);
  });
  var deleteTrailingWhitespace = ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = [];
    for (let pos = 0, prev = "", iter = state.doc.iter(); ; ) {
      iter.next();
      if (iter.lineBreak || iter.done) {
        let trailing = prev.search(/\s+$/);
        if (trailing > -1)
          changes.push({ from: pos - (prev.length - trailing), to: pos });
        if (iter.done)
          break;
        prev = "";
      } else {
        prev = iter.value;
      }
      pos += iter.value.length;
    }
    if (!changes.length)
      return false;
    dispatch(state.update({ changes, userEvent: "delete" }));
    return true;
  };
  var splitLine = ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range10) => {
      return {
        changes: { from: range10.from, to: range10.to, insert: Text.of(["", ""]) },
        range: EditorSelection.cursor(range10.from)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
  var transposeChars = ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range10) => {
      if (!range10.empty || range10.from == 0 || range10.from == state.doc.length)
        return { range: range10 };
      let pos = range10.from, line = state.doc.lineAt(pos);
      let from17 = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
      let to10 = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
      return {
        changes: { from: from17, to: to10, insert: state.doc.slice(pos, to10).append(state.doc.slice(from17, pos)) },
        range: EditorSelection.cursor(to10)
      };
    });
    if (changes.changes.empty)
      return false;
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
    return true;
  };
  function selectedLineBlocks(state) {
    let blocks = [], upto = -1;
    for (let range10 of state.selection.ranges) {
      let startLine = state.doc.lineAt(range10.from), endLine = state.doc.lineAt(range10.to);
      if (!range10.empty && range10.to == endLine.from)
        endLine = state.doc.lineAt(range10.to - 1);
      if (upto >= startLine.number) {
        let prev = blocks[blocks.length - 1];
        prev.to = endLine.to;
        prev.ranges.push(range10);
      } else {
        blocks.push({ from: startLine.from, to: endLine.to, ranges: [range10] });
      }
      upto = endLine.number + 1;
    }
    return blocks;
  }
  function moveLine(state, dispatch, forward18) {
    if (state.readOnly)
      return false;
    let changes = [], ranges = [];
    for (let block of selectedLineBlocks(state)) {
      if (forward18 ? block.to == state.doc.length : block.from == 0)
        continue;
      let nextLine = state.doc.lineAt(forward18 ? block.to + 1 : block.from - 1);
      let size = nextLine.length + 1;
      if (forward18) {
        changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
        for (let r of block.ranges)
          ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
      } else {
        changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
        for (let r of block.ranges)
          ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
      }
    }
    if (!changes.length)
      return false;
    dispatch(state.update({
      changes,
      scrollIntoView: true,
      selection: EditorSelection.create(ranges, state.selection.mainIndex),
      userEvent: "move.line"
    }));
    return true;
  }
  var moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
  var moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
  function copyLine(state, dispatch, forward18) {
    if (state.readOnly)
      return false;
    let changes = [];
    for (let block of selectedLineBlocks(state)) {
      if (forward18)
        changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
      else
        changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
    }
    dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
    return true;
  }
  var copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
  var copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
  var deleteLine = (view) => {
    if (view.state.readOnly)
      return false;
    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from: from17, to: to10 }) => {
      if (from17 > 0)
        from17--;
      else if (to10 < state.doc.length)
        to10++;
      return { from: from17, to: to10 };
    }));
    let selection2 = updateSel(state.selection, (range10) => view.moveVertically(range10, true)).map(changes);
    view.dispatch({ changes, selection: selection2, scrollIntoView: true, userEvent: "delete.line" });
    return true;
  };
  function isBetweenBrackets(state, pos) {
    if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
      return { from: pos, to: pos };
    let context2 = syntaxTree(state).resolveInner(pos);
    let before = context2.childBefore(pos), after = context2.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from)))
      return { from: before.to, to: after.from };
    return null;
  }
  var insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
  var insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
  function newlineAndIndent(atEof) {
    return ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      let changes = state.changeByRange((range10) => {
        let { from: from17, to: to10 } = range10, line = state.doc.lineAt(from17);
        let explode = !atEof && from17 == to10 && isBetweenBrackets(state, from17);
        if (atEof)
          from17 = to10 = (to10 <= line.to ? line : state.doc.lineAt(to10)).to;
        let cx = new IndentContext(state, { simulateBreak: from17, simulateDoubleBreak: !!explode });
        let indent = getIndentation(cx, from17);
        if (indent == null)
          indent = countColumn(/^\s*/.exec(state.doc.lineAt(from17).text)[0], state.tabSize);
        while (to10 < line.to && /\s/.test(line.text[to10 - line.from]))
          to10++;
        if (explode)
          ({ from: from17, to: to10 } = explode);
        else if (from17 > line.from && from17 < line.from + 100 && !/\S/.test(line.text.slice(0, from17)))
          from17 = line.from;
        let insert2 = ["", indentString(state, indent)];
        if (explode)
          insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
        return {
          changes: { from: from17, to: to10, insert: Text.of(insert2) },
          range: EditorSelection.cursor(from17 + 1 + insert2[1].length)
        };
      });
      dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
      return true;
    };
  }
  function changeBySelectedLine(state, f) {
    let atLine = -1;
    return state.changeByRange((range10) => {
      let changes = [];
      for (let pos = range10.from; pos <= range10.to; ) {
        let line = state.doc.lineAt(pos);
        if (line.number > atLine && (range10.empty || range10.to > line.from)) {
          f(line, changes, range10);
          atLine = line.number;
        }
        pos = line.to + 1;
      }
      let changeSet = state.changes(changes);
      return {
        changes,
        range: EditorSelection.range(changeSet.mapPos(range10.anchor, 1), changeSet.mapPos(range10.head, 1))
      };
    });
  }
  var indentSelection = ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let updated = Object.create(null);
    let context2 = new IndentContext(state, { overrideIndentation: (start2) => {
      let found = updated[start2];
      return found == null ? -1 : found;
    } });
    let changes = changeBySelectedLine(state, (line, changes2, range10) => {
      let indent = getIndentation(context2, line.from);
      if (indent == null)
        return;
      if (!/\S/.test(line.text))
        indent = 0;
      let cur = /^\s*/.exec(line.text)[0];
      let norm = indentString(state, indent);
      if (cur != norm || range10.from < line.from + cur.length) {
        updated[line.from] = indent;
        changes2.push({ from: line.from, to: line.from + cur.length, insert: norm });
      }
    });
    if (!changes.changes.empty)
      dispatch(state.update(changes, { userEvent: "indent" }));
    return true;
  };
  var indentMore = ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
      changes.push({ from: line.from, insert: state.facet(indentUnit) });
    }), { userEvent: "input.indent" }));
    return true;
  };
  var indentLess = ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
      let space = /^\s*/.exec(line.text)[0];
      if (!space)
        return;
      let col = countColumn(space, state.tabSize), keep = 0;
      let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
      while (keep < space.length && keep < insert2.length && space.charCodeAt(keep) == insert2.charCodeAt(keep))
        keep++;
      changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert2.slice(keep) });
    }), { userEvent: "delete.dedent" }));
    return true;
  };
  var emacsStyleKeymap = [
    { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
    { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
    { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
    { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
    { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
    { key: "Ctrl-d", run: deleteCharForward },
    { key: "Ctrl-h", run: deleteCharBackward },
    { key: "Ctrl-k", run: deleteToLineEnd },
    { key: "Ctrl-Alt-h", run: deleteGroupBackward },
    { key: "Ctrl-o", run: splitLine },
    { key: "Ctrl-t", run: transposeChars },
    { key: "Ctrl-v", run: cursorPageDown }
  ];
  var standardKeymap = /* @__PURE__ */ [
    { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
    { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
    { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
    { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
    { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
    { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
    { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
    { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
    { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
    { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
    { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
    { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
    { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
    { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
    { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
    { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
    { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
    { key: "Enter", run: insertNewlineAndIndent },
    { key: "Mod-a", run: selectAll },
    { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
    { key: "Delete", run: deleteCharForward },
    { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
    { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
    { mac: "Mod-Backspace", run: deleteToLineStart },
    { mac: "Mod-Delete", run: deleteToLineEnd }
  ].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
  var defaultKeymap = /* @__PURE__ */ [
    { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
    { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
    { key: "Alt-ArrowUp", run: moveLineUp },
    { key: "Shift-Alt-ArrowUp", run: copyLineUp },
    { key: "Alt-ArrowDown", run: moveLineDown },
    { key: "Shift-Alt-ArrowDown", run: copyLineDown },
    { key: "Escape", run: simplifySelection },
    { key: "Mod-Enter", run: insertBlankLine },
    { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
    { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
    { key: "Mod-[", run: indentLess },
    { key: "Mod-]", run: indentMore },
    { key: "Mod-Alt-\\", run: indentSelection },
    { key: "Shift-Mod-k", run: deleteLine },
    { key: "Shift-Mod-\\", run: cursorMatchingBracket },
    { key: "Mod-/", run: toggleComment },
    { key: "Alt-A", run: toggleBlockComment }
  ].concat(standardKeymap);
  var indentWithTab = { key: "Tab", run: indentMore, shift: indentLess };

  // node_modules/crelt/index.js
  function crelt() {
    var elt = arguments[0];
    if (typeof elt == "string")
      elt = document.createElement(elt);
    var i = 1, next = arguments[1];
    if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
      for (var name2 in next)
        if (Object.prototype.hasOwnProperty.call(next, name2)) {
          var value = next[name2];
          if (typeof value == "string")
            elt.setAttribute(name2, value);
          else if (value != null)
            elt[name2] = value;
        }
      i++;
    }
    for (; i < arguments.length; i++)
      add(elt, arguments[i]);
    return elt;
  }
  function add(elt, child) {
    if (typeof child == "string") {
      elt.appendChild(document.createTextNode(child));
    } else if (child == null) {
    } else if (child.nodeType != null) {
      elt.appendChild(child);
    } else if (Array.isArray(child)) {
      for (var i = 0; i < child.length; i++)
        add(elt, child[i]);
    } else {
      throw new RangeError("Unsupported child node: " + child);
    }
  }

  // node_modules/@codemirror/search/dist/index.js
  var basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
  var SearchCursor = class {
    constructor(text, query, from17 = 0, to10 = text.length, normalize, test) {
      this.test = test;
      this.value = { from: 0, to: 0 };
      this.done = false;
      this.matches = [];
      this.buffer = "";
      this.bufferPos = 0;
      this.iter = text.iterRange(from17, to10);
      this.bufferStart = from17;
      this.normalize = normalize ? (x) => normalize(basicNormalize(x)) : basicNormalize;
      this.query = this.normalize(query);
    }
    peek() {
      if (this.bufferPos == this.buffer.length) {
        this.bufferStart += this.buffer.length;
        this.iter.next();
        if (this.iter.done)
          return -1;
        this.bufferPos = 0;
        this.buffer = this.iter.value;
      }
      return codePointAt(this.buffer, this.bufferPos);
    }
    next() {
      while (this.matches.length)
        this.matches.pop();
      return this.nextOverlapping();
    }
    nextOverlapping() {
      for (; ; ) {
        let next = this.peek();
        if (next < 0) {
          this.done = true;
          return this;
        }
        let str = fromCodePoint(next), start2 = this.bufferStart + this.bufferPos;
        this.bufferPos += codePointSize(next);
        let norm = this.normalize(str);
        for (let i = 0, pos = start2; ; i++) {
          let code = norm.charCodeAt(i);
          let match = this.match(code, pos);
          if (i == norm.length - 1) {
            if (match) {
              this.value = match;
              return this;
            }
            break;
          }
          if (pos == start2 && i < str.length && str.charCodeAt(i) == code)
            pos++;
        }
      }
    }
    match(code, pos) {
      let match = null;
      for (let i = 0; i < this.matches.length; i += 2) {
        let index3 = this.matches[i], keep = false;
        if (this.query.charCodeAt(index3) == code) {
          if (index3 == this.query.length - 1) {
            match = { from: this.matches[i + 1], to: pos + 1 };
          } else {
            this.matches[i]++;
            keep = true;
          }
        }
        if (!keep) {
          this.matches.splice(i, 2);
          i -= 2;
        }
      }
      if (this.query.charCodeAt(0) == code) {
        if (this.query.length == 1)
          match = { from: pos, to: pos + 1 };
        else
          this.matches.push(1, pos);
      }
      if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferPos))
        match = null;
      return match;
    }
  };
  if (typeof Symbol != "undefined")
    SearchCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  var empty = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") };
  var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
  var RegExpCursor = class {
    constructor(text, query, options, from17 = 0, to10 = text.length) {
      this.text = text;
      this.to = to10;
      this.curLine = "";
      this.done = false;
      this.value = empty;
      if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
        return new MultilineRegExpCursor(text, query, options, from17, to10);
      this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
      this.test = options === null || options === void 0 ? void 0 : options.test;
      this.iter = text.iter();
      let startLine = text.lineAt(from17);
      this.curLineStart = startLine.from;
      this.matchPos = toCharEnd(text, from17);
      this.getLine(this.curLineStart);
    }
    getLine(skip2) {
      this.iter.next(skip2);
      if (this.iter.lineBreak) {
        this.curLine = "";
      } else {
        this.curLine = this.iter.value;
        if (this.curLineStart + this.curLine.length > this.to)
          this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
        this.iter.next();
      }
    }
    nextLine() {
      this.curLineStart = this.curLineStart + this.curLine.length + 1;
      if (this.curLineStart > this.to)
        this.curLine = "";
      else
        this.getLine(0);
    }
    next() {
      for (let off2 = this.matchPos - this.curLineStart; ; ) {
        this.re.lastIndex = off2;
        let match = this.matchPos <= this.to && this.re.exec(this.curLine);
        if (match) {
          let from17 = this.curLineStart + match.index, to10 = from17 + match[0].length;
          this.matchPos = toCharEnd(this.text, to10 + (from17 == to10 ? 1 : 0));
          if (from17 == this.curLineStart + this.curLine.length)
            this.nextLine();
          if ((from17 < to10 || from17 > this.value.to) && (!this.test || this.test(from17, to10, match))) {
            this.value = { from: from17, to: to10, match };
            return this;
          }
          off2 = this.matchPos - this.curLineStart;
        } else if (this.curLineStart + this.curLine.length < this.to) {
          this.nextLine();
          off2 = 0;
        } else {
          this.done = true;
          return this;
        }
      }
    }
  };
  var flattened = /* @__PURE__ */ new WeakMap();
  var FlattenedDoc = class {
    constructor(from17, text) {
      this.from = from17;
      this.text = text;
    }
    get to() {
      return this.from + this.text.length;
    }
    static get(doc2, from17, to10) {
      let cached = flattened.get(doc2);
      if (!cached || cached.from >= to10 || cached.to <= from17) {
        let flat = new FlattenedDoc(from17, doc2.sliceString(from17, to10));
        flattened.set(doc2, flat);
        return flat;
      }
      if (cached.from == from17 && cached.to == to10)
        return cached;
      let { text, from: cachedFrom } = cached;
      if (cachedFrom > from17) {
        text = doc2.sliceString(from17, cachedFrom) + text;
        cachedFrom = from17;
      }
      if (cached.to < to10)
        text += doc2.sliceString(cached.to, to10);
      flattened.set(doc2, new FlattenedDoc(cachedFrom, text));
      return new FlattenedDoc(from17, text.slice(from17 - cachedFrom, to10 - cachedFrom));
    }
  };
  var MultilineRegExpCursor = class {
    constructor(text, query, options, from17, to10) {
      this.text = text;
      this.to = to10;
      this.done = false;
      this.value = empty;
      this.matchPos = toCharEnd(text, from17);
      this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
      this.test = options === null || options === void 0 ? void 0 : options.test;
      this.flat = FlattenedDoc.get(text, from17, this.chunkEnd(from17 + 5e3));
    }
    chunkEnd(pos) {
      return pos >= this.to ? this.to : this.text.lineAt(pos).to;
    }
    next() {
      for (; ; ) {
        let off2 = this.re.lastIndex = this.matchPos - this.flat.from;
        let match = this.re.exec(this.flat.text);
        if (match && !match[0] && match.index == off2) {
          this.re.lastIndex = off2 + 1;
          match = this.re.exec(this.flat.text);
        }
        if (match) {
          let from17 = this.flat.from + match.index, to10 = from17 + match[0].length;
          if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from17, to10, match))) {
            this.value = { from: from17, to: to10, match };
            this.matchPos = toCharEnd(this.text, to10 + (from17 == to10 ? 1 : 0));
            return this;
          }
        }
        if (this.flat.to == this.to) {
          this.done = true;
          return this;
        }
        this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
      }
    }
  };
  if (typeof Symbol != "undefined") {
    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  function validRegExp(source) {
    try {
      new RegExp(source, baseFlags);
      return true;
    } catch (_a3) {
      return false;
    }
  }
  function toCharEnd(text, pos) {
    if (pos >= text.length)
      return pos;
    let line = text.lineAt(pos), next;
    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
      pos++;
    return pos;
  }
  function createLineDialog(view) {
    let input2 = crelt("input", { class: "cm-textfield", name: "line" });
    let dom = crelt("form", {
      class: "cm-gotoLine",
      onkeydown: (event2) => {
        if (event2.keyCode == 27) {
          event2.preventDefault();
          view.dispatch({ effects: dialogEffect.of(false) });
          view.focus();
        } else if (event2.keyCode == 13) {
          event2.preventDefault();
          go2();
        }
      },
      onsubmit: (event2) => {
        event2.preventDefault();
        go2();
      }
    }, crelt("label", view.state.phrase("Go to line"), ": ", input2), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")));
    function go2() {
      let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input2.value);
      if (!match)
        return;
      let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
      let [, sign2, ln2, cl2, percent] = match;
      let col = cl2 ? +cl2.slice(1) : 0;
      let line = ln2 ? +ln2 : startLine.number;
      if (ln2 && percent) {
        let pc2 = line / 100;
        if (sign2)
          pc2 = pc2 * (sign2 == "-" ? -1 : 1) + startLine.number / state.doc.lines;
        line = Math.round(state.doc.lines * pc2);
      } else if (ln2 && sign2) {
        line = line * (sign2 == "-" ? -1 : 1) + startLine.number;
      }
      let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));
      let selection2 = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
      view.dispatch({
        effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection2.from, { y: "center" })],
        selection: selection2
      });
      view.focus();
    }
    return { dom };
  }
  var dialogEffect = /* @__PURE__ */ StateEffect.define();
  var dialogField = /* @__PURE__ */ StateField.define({
    create() {
      return true;
    },
    update(value, tr3) {
      for (let e of tr3.effects)
        if (e.is(dialogEffect))
          value = e.value;
      return value;
    },
    provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
  });
  var gotoLine = (view) => {
    let panel = getPanel(view, createLineDialog);
    if (!panel) {
      let effects2 = [dialogEffect.of(true)];
      if (view.state.field(dialogField, false) == null)
        effects2.push(StateEffect.appendConfig.of([dialogField, baseTheme$12]));
      view.dispatch({ effects: effects2 });
      panel = getPanel(view, createLineDialog);
    }
    if (panel)
      panel.dom.querySelector("input").focus();
    return true;
  };
  var baseTheme$12 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-panel.cm-gotoLine": {
      padding: "2px 6px 4px",
      "& label": { fontSize: "80%" }
    }
  });
  var defaultHighlightOptions = {
    highlightWordAroundCursor: false,
    minSelectionLength: 1,
    maxMatches: 100,
    wholeWords: false
  };
  var highlightConfig = /* @__PURE__ */ Facet.define({
    combine(options) {
      return combineConfig(options, defaultHighlightOptions, {
        highlightWordAroundCursor: (a, b) => a || b,
        minSelectionLength: Math.min,
        maxMatches: Math.min
      });
    }
  });
  function highlightSelectionMatches(options) {
    let ext = [defaultTheme, matchHighlighter];
    if (options)
      ext.push(highlightConfig.of(options));
    return ext;
  }
  var matchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch" });
  var mainMatchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
  function insideWordBoundaries(check, state, from17, to10) {
    return (from17 == 0 || check(state.sliceDoc(from17 - 1, from17)) != CharCategory.Word) && (to10 == state.doc.length || check(state.sliceDoc(to10, to10 + 1)) != CharCategory.Word);
  }
  function insideWord(check, state, from17, to10) {
    return check(state.sliceDoc(from17, from17 + 1)) == CharCategory.Word && check(state.sliceDoc(to10 - 1, to10)) == CharCategory.Word;
  }
  var matchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.decorations = this.getDeco(view);
    }
    update(update) {
      if (update.selectionSet || update.docChanged || update.viewportChanged)
        this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
      let conf = view.state.facet(highlightConfig);
      let { state } = view, sel = state.selection;
      if (sel.ranges.length > 1)
        return Decoration.none;
      let range10 = sel.main, query, check = null;
      if (range10.empty) {
        if (!conf.highlightWordAroundCursor)
          return Decoration.none;
        let word = state.wordAt(range10.head);
        if (!word)
          return Decoration.none;
        check = state.charCategorizer(range10.head);
        query = state.sliceDoc(word.from, word.to);
      } else {
        let len = range10.to - range10.from;
        if (len < conf.minSelectionLength || len > 200)
          return Decoration.none;
        if (conf.wholeWords) {
          query = state.sliceDoc(range10.from, range10.to);
          check = state.charCategorizer(range10.head);
          if (!(insideWordBoundaries(check, state, range10.from, range10.to) && insideWord(check, state, range10.from, range10.to)))
            return Decoration.none;
        } else {
          query = state.sliceDoc(range10.from, range10.to).trim();
          if (!query)
            return Decoration.none;
        }
      }
      let deco = [];
      for (let part of view.visibleRanges) {
        let cursor = new SearchCursor(state.doc, query, part.from, part.to);
        while (!cursor.next().done) {
          let { from: from17, to: to10 } = cursor.value;
          if (!check || insideWordBoundaries(check, state, from17, to10)) {
            if (range10.empty && from17 <= range10.from && to10 >= range10.to)
              deco.push(mainMatchDeco.range(from17, to10));
            else if (from17 >= range10.to || to10 <= range10.from)
              deco.push(matchDeco.range(from17, to10));
            if (deco.length > conf.maxMatches)
              return Decoration.none;
          }
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v) => v.decorations
  });
  var defaultTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
    ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
  });
  var selectWord = ({ state, dispatch }) => {
    let { selection: selection2 } = state;
    let newSel = EditorSelection.create(selection2.ranges.map((range10) => state.wordAt(range10.head) || EditorSelection.cursor(range10.head)), selection2.mainIndex);
    if (newSel.eq(selection2))
      return false;
    dispatch(state.update({ selection: newSel }));
    return true;
  };
  function findNextOccurrence(state, query) {
    let { main, ranges } = state.selection;
    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
      cursor.next();
      if (cursor.done) {
        if (cycled)
          return null;
        cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
        cycled = true;
      } else {
        if (cycled && ranges.some((r) => r.from == cursor.value.from))
          continue;
        if (fullWord) {
          let word2 = state.wordAt(cursor.value.from);
          if (!word2 || word2.from != cursor.value.from || word2.to != cursor.value.to)
            continue;
        }
        return cursor.value;
      }
    }
  }
  var selectNextOccurrence = ({ state, dispatch }) => {
    let { ranges } = state.selection;
    if (ranges.some((sel) => sel.from === sel.to))
      return selectWord({ state, dispatch });
    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
    if (state.selection.ranges.some((r) => state.sliceDoc(r.from, r.to) != searchedText))
      return false;
    let range10 = findNextOccurrence(state, searchedText);
    if (!range10)
      return false;
    dispatch(state.update({
      selection: state.selection.addRange(EditorSelection.range(range10.from, range10.to), false),
      effects: EditorView.scrollIntoView(range10.to)
    }));
    return true;
  };
  var searchConfigFacet = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        top: false,
        caseSensitive: false,
        literal: false,
        regexp: false,
        wholeWord: false,
        createPanel: (view) => new SearchPanel(view),
        scrollToMatch: (range10) => EditorView.scrollIntoView(range10)
      });
    }
  });
  var SearchQuery = class {
    constructor(config) {
      this.search = config.search;
      this.caseSensitive = !!config.caseSensitive;
      this.literal = !!config.literal;
      this.regexp = !!config.regexp;
      this.replace = config.replace || "";
      this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
      this.unquoted = this.unquote(this.search);
      this.wholeWord = !!config.wholeWord;
    }
    unquote(text) {
      return this.literal ? text : text.replace(/\\([nrt\\])/g, (_, ch2) => ch2 == "n" ? "\n" : ch2 == "r" ? "\r" : ch2 == "t" ? "	" : "\\");
    }
    eq(other) {
      return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
    }
    create() {
      return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
    }
    getCursor(state, from17 = 0, to10) {
      let st2 = state.doc ? state : EditorState.create({ doc: state });
      if (to10 == null)
        to10 = st2.doc.length;
      return this.regexp ? regexpCursor(this, st2, from17, to10) : stringCursor(this, st2, from17, to10);
    }
  };
  var QueryType2 = class {
    constructor(spec) {
      this.spec = spec;
    }
  };
  function stringCursor(spec, state, from17, to10) {
    return new SearchCursor(state.doc, spec.unquoted, from17, to10, spec.caseSensitive ? void 0 : (x) => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
  }
  function stringWordTest(doc2, categorizer) {
    return (from17, to10, buf, bufPos) => {
      if (bufPos > from17 || bufPos + buf.length < to10) {
        bufPos = Math.max(0, from17 - 2);
        buf = doc2.sliceString(bufPos, Math.min(doc2.length, to10 + 2));
      }
      return (categorizer(charBefore(buf, from17 - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from17 - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to10 - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to10 - bufPos)) != CharCategory.Word);
    };
  }
  var StringQuery = class extends QueryType2 {
    constructor(spec) {
      super(spec);
    }
    nextMatch(state, curFrom, curTo) {
      let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
      if (cursor.done)
        cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();
      return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(state, from17, to10) {
      for (let pos = to10; ; ) {
        let start2 = Math.max(from17, pos - 1e4 - this.spec.unquoted.length);
        let cursor = stringCursor(this.spec, state, start2, pos), range10 = null;
        while (!cursor.nextOverlapping().done)
          range10 = cursor.value;
        if (range10)
          return range10;
        if (start2 == from17)
          return null;
        pos -= 1e4;
      }
    }
    prevMatch(state, curFrom, curTo) {
      return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
    }
    getReplacement(_result) {
      return this.spec.unquote(this.spec.replace);
    }
    matchAll(state, limit) {
      let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
      while (!cursor.next().done) {
        if (ranges.length >= limit)
          return null;
        ranges.push(cursor.value);
      }
      return ranges;
    }
    highlight(state, from17, to10, add17) {
      let cursor = stringCursor(this.spec, state, Math.max(0, from17 - this.spec.unquoted.length), Math.min(to10 + this.spec.unquoted.length, state.doc.length));
      while (!cursor.next().done)
        add17(cursor.value.from, cursor.value.to);
    }
  };
  function regexpCursor(spec, state, from17, to10) {
    return new RegExpCursor(state.doc, spec.search, {
      ignoreCase: !spec.caseSensitive,
      test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
    }, from17, to10);
  }
  function charBefore(str, index3) {
    return str.slice(findClusterBreak(str, index3, false), index3);
  }
  function charAfter(str, index3) {
    return str.slice(index3, findClusterBreak(str, index3));
  }
  function regexpWordTest(categorizer) {
    return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
  }
  var RegExpQuery = class extends QueryType2 {
    nextMatch(state, curFrom, curTo) {
      let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();
      if (cursor.done)
        cursor = regexpCursor(this.spec, state, 0, curFrom).next();
      return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(state, from17, to10) {
      for (let size = 1; ; size++) {
        let start2 = Math.max(from17, to10 - size * 1e4);
        let cursor = regexpCursor(this.spec, state, start2, to10), range10 = null;
        while (!cursor.next().done)
          range10 = cursor.value;
        if (range10 && (start2 == from17 || range10.from > start2 + 10))
          return range10;
        if (start2 == from17)
          return null;
      }
    }
    prevMatch(state, curFrom, curTo) {
      return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
    }
    getReplacement(result) {
      return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (m, i) => i == "$" ? "$" : i == "&" ? result.match[0] : i != "0" && +i < result.match.length ? result.match[i] : m));
    }
    matchAll(state, limit) {
      let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
      while (!cursor.next().done) {
        if (ranges.length >= limit)
          return null;
        ranges.push(cursor.value);
      }
      return ranges;
    }
    highlight(state, from17, to10, add17) {
      let cursor = regexpCursor(this.spec, state, Math.max(0, from17 - 250), Math.min(to10 + 250, state.doc.length));
      while (!cursor.next().done)
        add17(cursor.value.from, cursor.value.to);
    }
  };
  var setSearchQuery = /* @__PURE__ */ StateEffect.define();
  var togglePanel = /* @__PURE__ */ StateEffect.define();
  var searchState = /* @__PURE__ */ StateField.define({
    create(state) {
      return new SearchState(defaultQuery(state).create(), null);
    },
    update(value, tr3) {
      for (let effect of tr3.effects) {
        if (effect.is(setSearchQuery))
          value = new SearchState(effect.value.create(), value.panel);
        else if (effect.is(togglePanel))
          value = new SearchState(value.query, effect.value ? createSearchPanel : null);
      }
      return value;
    },
    provide: (f) => showPanel.from(f, (val) => val.panel)
  });
  var SearchState = class {
    constructor(query, panel) {
      this.query = query;
      this.panel = panel;
    }
  };
  var matchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch" });
  var selectedMatchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
  var searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = this.highlight(view.state.field(searchState));
    }
    update(update) {
      let state = update.state.field(searchState);
      if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
        this.decorations = this.highlight(state);
    }
    highlight({ query, panel }) {
      if (!panel || !query.spec.valid)
        return Decoration.none;
      let { view } = this;
      let builder = new RangeSetBuilder();
      for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
        let { from: from17, to: to10 } = ranges[i];
        while (i < l - 1 && to10 > ranges[i + 1].from - 2 * 250)
          to10 = ranges[++i].to;
        query.highlight(view.state, from17, to10, (from18, to11) => {
          let selected = view.state.selection.ranges.some((r) => r.from == from18 && r.to == to11);
          builder.add(from18, to11, selected ? selectedMatchMark : matchMark);
        });
      }
      return builder.finish();
    }
  }, {
    decorations: (v) => v.decorations
  });
  function searchCommand(f) {
    return (view) => {
      let state = view.state.field(searchState, false);
      return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
    };
  }
  var findNext = /* @__PURE__ */ searchCommand((view, { query }) => {
    let { to: to10 } = view.state.selection.main;
    let next = query.nextMatch(view.state, to10, to10);
    if (!next)
      return false;
    let selection2 = EditorSelection.single(next.from, next.to);
    let config = view.state.facet(searchConfigFacet);
    view.dispatch({
      selection: selection2,
      effects: [announceMatch(view, next), config.scrollToMatch(selection2.main, view)],
      userEvent: "select.search"
    });
    selectSearchInput(view);
    return true;
  });
  var findPrevious = /* @__PURE__ */ searchCommand((view, { query }) => {
    let { state } = view, { from: from17 } = state.selection.main;
    let prev = query.prevMatch(state, from17, from17);
    if (!prev)
      return false;
    let selection2 = EditorSelection.single(prev.from, prev.to);
    let config = view.state.facet(searchConfigFacet);
    view.dispatch({
      selection: selection2,
      effects: [announceMatch(view, prev), config.scrollToMatch(selection2.main, view)],
      userEvent: "select.search"
    });
    selectSearchInput(view);
    return true;
  });
  var selectMatches = /* @__PURE__ */ searchCommand((view, { query }) => {
    let ranges = query.matchAll(view.state, 1e3);
    if (!ranges || !ranges.length)
      return false;
    view.dispatch({
      selection: EditorSelection.create(ranges.map((r) => EditorSelection.range(r.from, r.to))),
      userEvent: "select.search.matches"
    });
    return true;
  });
  var selectSelectionMatches = ({ state, dispatch }) => {
    let sel = state.selection;
    if (sel.ranges.length > 1 || sel.main.empty)
      return false;
    let { from: from17, to: to10 } = sel.main;
    let ranges = [], main = 0;
    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from17, to10)); !cur.next().done; ) {
      if (ranges.length > 1e3)
        return false;
      if (cur.value.from == from17)
        main = ranges.length;
      ranges.push(EditorSelection.range(cur.value.from, cur.value.to));
    }
    dispatch(state.update({
      selection: EditorSelection.create(ranges, main),
      userEvent: "select.search.matches"
    }));
    return true;
  };
  var replaceNext = /* @__PURE__ */ searchCommand((view, { query }) => {
    let { state } = view, { from: from17, to: to10 } = state.selection.main;
    if (state.readOnly)
      return false;
    let next = query.nextMatch(state, from17, from17);
    if (!next)
      return false;
    let changes = [], selection2, replacement;
    let effects2 = [];
    if (next.from == from17 && next.to == to10) {
      replacement = state.toText(query.getReplacement(next));
      changes.push({ from: next.from, to: next.to, insert: replacement });
      next = query.nextMatch(state, next.from, next.to);
      effects2.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from17).number) + "."));
    }
    if (next) {
      let off2 = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
      selection2 = EditorSelection.single(next.from - off2, next.to - off2);
      effects2.push(announceMatch(view, next));
      effects2.push(state.facet(searchConfigFacet).scrollToMatch(selection2.main, view));
    }
    view.dispatch({
      changes,
      selection: selection2,
      effects: effects2,
      userEvent: "input.replace"
    });
    return true;
  });
  var replaceAll = /* @__PURE__ */ searchCommand((view, { query }) => {
    if (view.state.readOnly)
      return false;
    let changes = query.matchAll(view.state, 1e9).map((match) => {
      let { from: from17, to: to10 } = match;
      return { from: from17, to: to10, insert: query.getReplacement(match) };
    });
    if (!changes.length)
      return false;
    let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
    view.dispatch({
      changes,
      effects: EditorView.announce.of(announceText),
      userEvent: "input.replace.all"
    });
    return true;
  });
  function createSearchPanel(view) {
    return view.state.facet(searchConfigFacet).createPanel(view);
  }
  function defaultQuery(state, fallback) {
    var _a3, _b, _c2, _d2, _e2;
    let sel = state.selection.main;
    let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
    if (fallback && !selText)
      return fallback;
    let config = state.facet(searchConfigFacet);
    return new SearchQuery({
      search: ((_a3 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a3 !== void 0 ? _a3 : config.literal) ? selText : selText.replace(/\n/g, "\\n"),
      caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,
      literal: (_c2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c2 !== void 0 ? _c2 : config.literal,
      regexp: (_d2 = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d2 !== void 0 ? _d2 : config.regexp,
      wholeWord: (_e2 = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e2 !== void 0 ? _e2 : config.wholeWord
    });
  }
  function getSearchInput(view) {
    let panel = getPanel(view, createSearchPanel);
    return panel && panel.dom.querySelector("[main-field]");
  }
  function selectSearchInput(view) {
    let input2 = getSearchInput(view);
    if (input2 && input2 == view.root.activeElement)
      input2.select();
  }
  var openSearchPanel = (view) => {
    let state = view.state.field(searchState, false);
    if (state && state.panel) {
      let searchInput2 = getSearchInput(view);
      if (searchInput2 && searchInput2 != view.root.activeElement) {
        let query = defaultQuery(view.state, state.query.spec);
        if (query.valid)
          view.dispatch({ effects: setSearchQuery.of(query) });
        searchInput2.focus();
        searchInput2.select();
      }
    } else {
      view.dispatch({ effects: [
        togglePanel.of(true),
        state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
      ] });
    }
    return true;
  };
  var closeSearchPanel = (view) => {
    let state = view.state.field(searchState, false);
    if (!state || !state.panel)
      return false;
    let panel = getPanel(view, createSearchPanel);
    if (panel && panel.dom.contains(view.root.activeElement))
      view.focus();
    view.dispatch({ effects: togglePanel.of(false) });
    return true;
  };
  var searchKeymap = [
    { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
    { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
    { key: "Mod-Shift-l", run: selectSelectionMatches },
    { key: "Alt-g", run: gotoLine },
    { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
  ];
  var SearchPanel = class {
    constructor(view) {
      this.view = view;
      let query = this.query = view.state.field(searchState).query.spec;
      this.commit = this.commit.bind(this);
      this.searchField = crelt("input", {
        value: query.search,
        placeholder: phrase(view, "Find"),
        "aria-label": phrase(view, "Find"),
        class: "cm-textfield",
        name: "search",
        form: "",
        "main-field": "true",
        onchange: this.commit,
        onkeyup: this.commit
      });
      this.replaceField = crelt("input", {
        value: query.replace,
        placeholder: phrase(view, "Replace"),
        "aria-label": phrase(view, "Replace"),
        class: "cm-textfield",
        name: "replace",
        form: "",
        onchange: this.commit,
        onkeyup: this.commit
      });
      this.caseField = crelt("input", {
        type: "checkbox",
        name: "case",
        form: "",
        checked: query.caseSensitive,
        onchange: this.commit
      });
      this.reField = crelt("input", {
        type: "checkbox",
        name: "re",
        form: "",
        checked: query.regexp,
        onchange: this.commit
      });
      this.wordField = crelt("input", {
        type: "checkbox",
        name: "word",
        form: "",
        checked: query.wholeWord,
        onchange: this.commit
      });
      function button(name2, onclick, content2) {
        return crelt("button", { class: "cm-button", name: name2, onclick, type: "button" }, content2);
      }
      this.dom = crelt("div", { onkeydown: (e) => this.keydown(e), class: "cm-search" }, [
        this.searchField,
        button("next", () => findNext(view), [phrase(view, "next")]),
        button("prev", () => findPrevious(view), [phrase(view, "previous")]),
        button("select", () => selectMatches(view), [phrase(view, "all")]),
        crelt("label", null, [this.caseField, phrase(view, "match case")]),
        crelt("label", null, [this.reField, phrase(view, "regexp")]),
        crelt("label", null, [this.wordField, phrase(view, "by word")]),
        ...view.state.readOnly ? [] : [
          crelt("br"),
          this.replaceField,
          button("replace", () => replaceNext(view), [phrase(view, "replace")]),
          button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
        ],
        crelt("button", {
          name: "close",
          onclick: () => closeSearchPanel(view),
          "aria-label": phrase(view, "close"),
          type: "button"
        }, ["\xD7"])
      ]);
    }
    commit() {
      let query = new SearchQuery({
        search: this.searchField.value,
        caseSensitive: this.caseField.checked,
        regexp: this.reField.checked,
        wholeWord: this.wordField.checked,
        replace: this.replaceField.value
      });
      if (!query.eq(this.query)) {
        this.query = query;
        this.view.dispatch({ effects: setSearchQuery.of(query) });
      }
    }
    keydown(e) {
      if (runScopeHandlers(this.view, e, "search-panel")) {
        e.preventDefault();
      } else if (e.keyCode == 13 && e.target == this.searchField) {
        e.preventDefault();
        (e.shiftKey ? findPrevious : findNext)(this.view);
      } else if (e.keyCode == 13 && e.target == this.replaceField) {
        e.preventDefault();
        replaceNext(this.view);
      }
    }
    update(update) {
      for (let tr3 of update.transactions)
        for (let effect of tr3.effects) {
          if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
            this.setQuery(effect.value);
        }
    }
    setQuery(query) {
      this.query = query;
      this.searchField.value = query.search;
      this.replaceField.value = query.replace;
      this.caseField.checked = query.caseSensitive;
      this.reField.checked = query.regexp;
      this.wordField.checked = query.wholeWord;
    }
    mount() {
      this.searchField.select();
    }
    get pos() {
      return 80;
    }
    get top() {
      return this.view.state.facet(searchConfigFacet).top;
    }
  };
  function phrase(view, phrase2) {
    return view.state.phrase(phrase2);
  }
  var AnnounceMargin = 30;
  var Break = /[\s\.,:;?!]/;
  function announceMatch(view, { from: from17, to: to10 }) {
    let line = view.state.doc.lineAt(from17), lineEnd = view.state.doc.lineAt(to10).to;
    let start2 = Math.max(line.from, from17 - AnnounceMargin), end = Math.min(lineEnd, to10 + AnnounceMargin);
    let text = view.state.sliceDoc(start2, end);
    if (start2 != line.from) {
      for (let i = 0; i < AnnounceMargin; i++)
        if (!Break.test(text[i + 1]) && Break.test(text[i])) {
          text = text.slice(i);
          break;
        }
    }
    if (end != lineEnd) {
      for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
        if (!Break.test(text[i - 1]) && Break.test(text[i])) {
          text = text.slice(0, i);
          break;
        }
    }
    return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
  }
  var baseTheme2 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-panel.cm-search": {
      padding: "2px 6px 4px",
      position: "relative",
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "4px",
        backgroundColor: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      },
      "& input, & button, & label": {
        margin: ".2em .6em .2em 0"
      },
      "& input[type=checkbox]": {
        marginRight: ".2em"
      },
      "& label": {
        fontSize: "80%",
        whiteSpace: "pre"
      }
    },
    "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
    "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
    "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
    "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
  });
  var searchExtensions = [
    searchState,
    /* @__PURE__ */ Prec.low(searchHighlighter),
    baseTheme2
  ];

  // static/js/cm-decorations.ts
  var addErrorLine = StateEffect.define();
  var addErrorWord = StateEffect.define();
  var removeErrorMarkers = StateEffect.define();
  var addDebugLine = StateEffect.define();
  var addDebugWords = StateEffect.define({
    map: (val, mapping) => ({ from: mapping.mapPos(val.from), to: mapping.mapPos(val.to) })
  });
  var removeDebugLine = StateEffect.define();
  var breakpointGutterEffect = StateEffect.define({
    map: (val, mapping) => ({ pos: mapping.mapPos(val.pos), on: val.on })
  });
  var deactivateLineEffect = StateEffect.define({
    map: (val, mapping) => ({ pos: mapping.mapPos(val.pos), on: val.on })
  });
  var addIncorrectLineEffect = StateEffect.define({
    map: (val, maping) => ({ from: maping.mapPos(val.from), to: maping.mapPos(val.to) })
  });
  var removeIncorrectLineEffect = StateEffect.define();
  var errorLineField = StateField.define({
    create() {
      return Decoration.none;
    },
    update(errors, transaction) {
      errors = errors.map(transaction.changes);
      for (let e of transaction.effects) {
        if (e.is(addErrorLine)) {
          const line = transaction.state.doc.line(e.value.row);
          errors = errors.update({
            add: [errorHighlightLine.range(line.from, line.from)]
          });
        } else if (e.is(addErrorWord)) {
          const line = transaction.state.doc.line(e.value.row);
          const length = line.text.slice(e.value.col - 1).split(/(\s+)/)[0].length;
          if (length > 0) {
            errors = errors.update({
              add: [errorHighlightMark.range(line.from + e.value.col - 1, line.from + e.value.col - 1 + length)]
            });
          } else {
            errors = errors.update({
              add: [errorHighlightLine.range(line.from, line.from)]
            });
          }
        } else if (e.is(removeErrorMarkers)) {
          return Decoration.none;
        }
      }
      return errors;
    },
    provide: (f) => EditorView.decorations.from(f)
  });
  var debugLineField = StateField.define({
    create() {
      return Decoration.none;
    },
    update(errors, tr3) {
      errors = errors.map(tr3.changes);
      for (let e of tr3.effects) {
        if (e.is(addDebugLine)) {
          const line = tr3.state.doc.line(e.value.row);
          errors = errors.update({
            add: [debugLine.range(line.from, line.from)]
          });
        } else if (e.is(addDebugWords)) {
          errors = errors.update({
            add: [debugWord.range(e.value.from, e.value.to)]
          });
        } else if (e.is(removeDebugLine)) {
          return Decoration.none;
        }
      }
      return errors;
    },
    provide: (f) => EditorView.decorations.from(f)
  });
  var incorrectLineField = StateField.define({
    create() {
      return Decoration.none;
    },
    update(errors, tr3) {
      errors = errors.map(tr3.changes);
      for (let e of tr3.effects) {
        if (e.is(addIncorrectLineEffect)) {
          errors = errors.update({
            add: [incorrectCodeMark.range(e.value.from, e.value.to)]
          });
        } else if (e.is(removeIncorrectLineEffect)) {
          return Decoration.none;
        }
      }
      return errors;
    },
    provide: (f) => EditorView.decorations.from(f)
  });
  var breakpointGutterState = StateField.define({
    create() {
      return RangeSet.empty;
    },
    update(set2, transaction) {
      set2 = set2.map(transaction.changes);
      for (let e of transaction.effects) {
        if (e.is(breakpointGutterEffect)) {
          if (e.value.on)
            set2 = set2.update({ add: [deactivateGutterMarker.range(e.value.pos)] });
          else
            set2 = set2.update({ filter: (from17) => from17 != e.value.pos });
        }
      }
      return set2;
    }
  });
  var deactivateLineState = StateField.define({
    create() {
      return Decoration.none;
    },
    update(set2, transaction) {
      set2 = set2.map(transaction.changes);
      for (let e of transaction.effects) {
        if (e.is(deactivateLineEffect)) {
          if (e.value.on) {
            set2 = set2.update({
              add: [deactivateLineMarker.range(e.value.pos, e.value.pos)]
            });
          } else {
            set2 = set2.update({
              filter: (from17) => from17 != e.value.pos
            });
          }
        }
      }
      return set2;
    },
    provide: (f) => EditorView.decorations.from(f)
  });
  var errorHighlightLine = Decoration.line({ class: "cm-error-editor" });
  var errorHighlightMark = Decoration.mark({ class: "cm-error-editor" });
  var debugLine = Decoration.line({ class: "cm-debugger-current-line" });
  var debugWord = Decoration.mark({ class: "cm-debugger-current-line" });
  var incorrectCodeMark = Decoration.mark({ class: "cm-incorrect-hedy-code" });
  var deactivateLineMarker = Decoration.line({ class: "cm-disabled-line" });
  var highlightVariableMarker = Decoration.mark({ class: "cm-highlight-var" });
  var highlightFunctionMarker = Decoration.mark({ class: "cm-highlight-fun" });
  var decorationsTheme = EditorView.theme({
    ".cm-error-editor": {
      outline: "2px solid #F56565",
      backgroundColor: "rgba(66, 153, 225, 0.7)",
      color: "white"
    },
    ".cm-debugger-current-line": {
      backgroundColor: "#2D6099"
    },
    ".cm-incorrect-hedy-code": {
      textDecoration: "red wavy underline"
    },
    ".cm-highlight-var": {
      color: "#c2e3ff "
    },
    ".cm-highlight-fun": {
      color: "#EDF492"
    }
  });
  var deactivateGutterMarker = new class extends GutterMarker {
    toDOM() {
      return document.createTextNode("\u{1F634}");
    }
  }();
  function toggleLine(view, pos) {
    let breakpoints = view.state.field(breakpointGutterState);
    let isDeactivated = false;
    breakpoints.between(pos, pos, () => {
      isDeactivated = true;
    });
    view.dispatch({
      effects: [
        breakpointGutterEffect.of({ pos, on: !isDeactivated }),
        deactivateLineEffect.of({ pos, on: !isDeactivated })
      ]
    });
  }
  var breakpointGutter = [
    breakpointGutterState,
    deactivateLineState,
    gutter({
      class: "cm-breakpoint-gutter",
      markers: (v) => v.state.field(breakpointGutterState),
      initialSpacer: () => deactivateGutterMarker,
      domEventHandlers: {
        mousedown(view, line) {
          toggleLine(view, line.from);
          return true;
        }
      }
    }),
    EditorView.baseTheme({
      ".cm-breakpoint-gutter .cm-gutterElement": {
        paddingLeft: "5px",
        cursor: "default"
      },
      ".cm-disabled-line": {
        textDecoration: "line-through"
      }
    })
  ];
  var PlacheholderWidget = class extends WidgetType {
    constructor(space, placeholder) {
      super();
      this.space = space;
      this.placeholder = placeholder;
    }
    toDOM() {
      let wrap = document.createElement("span");
      wrap.setAttribute("aria-hidden", "true");
      wrap.style.setProperty("background", "#F92672");
      wrap.style.setProperty("color", "white");
      wrap.innerHTML = "_";
      return wrap;
    }
    ignoreEvent() {
      return false;
    }
  };
  var placeholderMatcher = new MatchDecorator({
    regexp: /(?<![^ ])(_)(?= |$)/g,
    decoration: (match) => Decoration.replace({
      widget: new PlacheholderWidget(match[1], match[2])
    })
  });
  var placeholders = ViewPlugin.fromClass(class {
    constructor(view) {
      this.placeholders = placeholderMatcher.createDeco(view);
    }
    update(update) {
      this.placeholders = placeholderMatcher.updateDeco(update, this.placeholders);
    }
  }, {
    decorations: (instance) => instance.placeholders,
    provide: (plugin) => EditorView.atomicRanges.of((view) => {
      var _a3;
      return ((_a3 = view.plugin(plugin)) == null ? void 0 : _a3.placeholders) || Decoration.none;
    })
  });
  var variableHighlighter = ViewPlugin.fromClass(class {
    constructor(view) {
      this.decorations = highlightVariables(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged) {
        this.decorations = highlightVariables(update.view);
      }
    }
  }, {
    decorations: (v) => v.decorations
  });
  function highlightVariables(view) {
    const level3 = view.state.facet(level);
    if (level3 == 1)
      return Decoration.none;
    let variableDeco = new RangeSetBuilder();
    let variableData = [];
    let functionsNames = new Set();
    let variablesNames = new Set();
    let definingCommands = [
      "Assign",
      "Ask",
      "AssignList",
      "For",
      "Input"
    ];
    for (let { from: from17, to: to10 } of view.visibleRanges) {
      syntaxTree(view.state).iterate({
        from: from17,
        to: to10,
        enter: (node) => {
          if (definingCommands.includes(node.node.name)) {
            const child = node.node.getChild("Text");
            addVar(child, variableData, "variable", view, functionsNames, variablesNames);
          } else if (node.node.name === "Define") {
            const textChild = node.node.getChild("Text");
            addVar(textChild, variableData, "function", view, functionsNames, variablesNames);
            const argumentChild = node.node.getChild("Arguments");
            const expressions = argumentChild == null ? void 0 : argumentChild.getChildren("Expression");
            expressions == null ? void 0 : expressions.map((expression) => {
              const textChild2 = expression.getChild("Text");
              addVar(textChild2, variableData, "variable", view, functionsNames, variablesNames);
            });
          }
        }
      });
    }
    let commands = [
      "Assign",
      "Print",
      "Forward",
      "Turn",
      "Color",
      "Sleep",
      "ListAccess",
      "Add",
      "Remove",
      "EqualityCheck",
      "InListCheck",
      "NotInListCheck",
      "Expression",
      "Repeat",
      "For",
      "Call"
    ];
    if (level3 > 3)
      commands.push("Ask");
    for (let { from: from17, to: to10 } of view.visibleRanges) {
      syntaxTree(view.state).iterate({
        from: from17,
        to: to10,
        enter: (node) => {
          if (commands.includes(node.name)) {
            const children = node.node.getChildren("Text");
            let i = definingCommands.includes(node.name) ? 1 : 0;
            for (; i < children.length; i++) {
              const child = children[i];
              const text = view.state.doc.sliceString(child.from, child.to);
              if (level3 <= 3) {
                const varNames = getVarNames(text) || [];
                let startIndex = 0;
                for (const name2 of varNames) {
                  if (variablesNames.has(name2)) {
                    const index3 = text.indexOf(name2, startIndex);
                    variableData.push({
                      name: name2,
                      type: "variable",
                      pos: { from: child.from + index3, to: child.from + index3 + name2.length }
                    });
                    startIndex = index3 + name2.length;
                  }
                }
              } else if (variablesNames.has(text) || functionsNames.has(text)) {
                variableData.push({
                  name: text,
                  type: variablesNames.has(text) ? "variable" : "function",
                  pos: { from: child.from, to: child.to }
                });
              }
            }
          }
        }
      });
    }
    variableData.sort((a, b) => a.pos.from - b.pos.from);
    variableData.forEach((data) => {
      if (data.type === "function") {
        variableDeco.add(data.pos.from, data.pos.to, highlightFunctionMarker);
      } else {
        variableDeco.add(data.pos.from, data.pos.to, highlightVariableMarker);
      }
    });
    return variableDeco.finish();
  }
  function getVarNames(name2) {
    const varRegex = /^[\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}_]+([\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}_]+|[\p{Mn}\p{Mc}\p{Nd}\p{Pc}·]+)*$/gmu;
    return name2.match(varRegex);
  }
  function isVarName(name2) {
    const varRegex = /^[\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}_]+([\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}_]+|[\p{Mn}\p{Mc}\p{Nd}\p{Pc}·]+)*$/gmu;
    return varRegex.test(name2);
  }
  function basicIndent(context2, pos) {
    const nextIndentationSize = context2.lineIndent(pos, -1);
    let prevIndentationSize;
    try {
      prevIndentationSize = context2.lineIndent(pos + 1, -1);
    } catch (error2) {
      prevIndentationSize = 0;
    }
    const indentBy = Math.max(prevIndentationSize, nextIndentationSize);
    return indentBy;
  }
  function addVar(child, variableData, type, view, functionsNames, variablesNames) {
    if (child && isVarName(view.state.doc.sliceString(child.from, child.to))) {
      const name2 = view.state.doc.sliceString(child.from, child.to);
      const data = {
        name: name2,
        type,
        pos: { from: child.from, to: child.to }
      };
      variableData.push(data);
      switch (type) {
        case "function":
          functionsNames.add(name2);
          break;
        case "variable":
          variablesNames.add(name2);
          break;
      }
    }
  }

  // node_modules/@lezer/lr/dist/index.js
  var Stack = class {
    constructor(p, stack, state, reducePos, pos, score, buffer, bufferBase, curContext, lookAhead = 0, parent) {
      this.p = p;
      this.stack = stack;
      this.state = state;
      this.reducePos = reducePos;
      this.pos = pos;
      this.score = score;
      this.buffer = buffer;
      this.bufferBase = bufferBase;
      this.curContext = curContext;
      this.lookAhead = lookAhead;
      this.parent = parent;
    }
    toString() {
      return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    static start(p, state, pos = 0) {
      let cx = p.parser.context;
      return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    get context() {
      return this.curContext ? this.curContext.context : null;
    }
    pushState(state, start2) {
      this.stack.push(this.state, start2, this.bufferBase + this.buffer.length);
      this.state = state;
    }
    reduce(action) {
      var _a3;
      let depth = action >> 19, type = action & 65535;
      let { parser: parser19 } = this.p;
      let dPrec = parser19.dynamicPrecedence(type);
      if (dPrec)
        this.score += dPrec;
      if (depth == 0) {
        this.pushState(parser19.getGoto(this.state, type, true), this.reducePos);
        if (type < parser19.minRepeatTerm)
          this.storeNode(type, this.reducePos, this.reducePos, 4, true);
        this.reduceContext(type, this.reducePos);
        return;
      }
      let base2 = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
      let start2 = base2 ? this.stack[base2 - 2] : this.p.ranges[0].from, size = this.reducePos - start2;
      if (size >= 2e3 && !((_a3 = this.p.parser.nodeSet.types[type]) === null || _a3 === void 0 ? void 0 : _a3.isAnonymous)) {
        if (start2 == this.p.lastBigReductionStart) {
          this.p.bigReductionCount++;
          this.p.lastBigReductionSize = size;
        } else if (this.p.lastBigReductionSize < size) {
          this.p.bigReductionCount = 1;
          this.p.lastBigReductionStart = start2;
          this.p.lastBigReductionSize = size;
        }
      }
      let bufferBase = base2 ? this.stack[base2 - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
      if (type < parser19.minRepeatTerm || action & 131072) {
        let pos = parser19.stateFlag(this.state, 1) ? this.pos : this.reducePos;
        this.storeNode(type, start2, pos, count + 4, true);
      }
      if (action & 262144) {
        this.state = this.stack[base2];
      } else {
        let baseStateID = this.stack[base2 - 3];
        this.state = parser19.getGoto(baseStateID, type, true);
      }
      while (this.stack.length > base2)
        this.stack.pop();
      this.reduceContext(type, start2);
    }
    storeNode(term, start2, end, size = 4, isReduce = false) {
      if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
        let cur = this, top2 = this.buffer.length;
        if (top2 == 0 && cur.parent) {
          top2 = cur.bufferBase - cur.parent.bufferBase;
          cur = cur.parent;
        }
        if (top2 > 0 && cur.buffer[top2 - 4] == 0 && cur.buffer[top2 - 1] > -1) {
          if (start2 == end)
            return;
          if (cur.buffer[top2 - 2] >= start2) {
            cur.buffer[top2 - 2] = end;
            return;
          }
        }
      }
      if (!isReduce || this.pos == end) {
        this.buffer.push(term, start2, end, size);
      } else {
        let index3 = this.buffer.length;
        if (index3 > 0 && this.buffer[index3 - 4] != 0)
          while (index3 > 0 && this.buffer[index3 - 2] > end) {
            this.buffer[index3] = this.buffer[index3 - 4];
            this.buffer[index3 + 1] = this.buffer[index3 - 3];
            this.buffer[index3 + 2] = this.buffer[index3 - 2];
            this.buffer[index3 + 3] = this.buffer[index3 - 1];
            index3 -= 4;
            if (size > 4)
              size -= 4;
          }
        this.buffer[index3] = term;
        this.buffer[index3 + 1] = start2;
        this.buffer[index3 + 2] = end;
        this.buffer[index3 + 3] = size;
      }
    }
    shift(action, type, start2, end) {
      if (action & 131072) {
        this.pushState(action & 65535, this.pos);
      } else if ((action & 262144) == 0) {
        let nextState = action, { parser: parser19 } = this.p;
        if (end > this.pos || type <= parser19.maxNode) {
          this.pos = end;
          if (!parser19.stateFlag(nextState, 1))
            this.reducePos = end;
        }
        this.pushState(nextState, start2);
        this.shiftContext(type, start2);
        if (type <= parser19.maxNode)
          this.buffer.push(type, start2, end, 4);
      } else {
        this.pos = end;
        this.shiftContext(type, start2);
        if (type <= this.p.parser.maxNode)
          this.buffer.push(type, start2, end, 4);
      }
    }
    apply(action, next, nextStart, nextEnd) {
      if (action & 65536)
        this.reduce(action);
      else
        this.shift(action, next, nextStart, nextEnd);
    }
    useNode(value, next) {
      let index3 = this.p.reused.length - 1;
      if (index3 < 0 || this.p.reused[index3] != value) {
        this.p.reused.push(value);
        index3++;
      }
      let start2 = this.pos;
      this.reducePos = this.pos = start2 + value.length;
      this.pushState(next, start2);
      this.buffer.push(index3, start2, this.reducePos, -1);
      if (this.curContext)
        this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    split() {
      let parent = this;
      let off2 = parent.buffer.length;
      while (off2 > 0 && parent.buffer[off2 - 2] > parent.reducePos)
        off2 -= 4;
      let buffer = parent.buffer.slice(off2), base2 = parent.bufferBase + off2;
      while (parent && base2 == parent.bufferBase)
        parent = parent.parent;
      return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
    }
    recoverByDelete(next, nextEnd) {
      let isNode = next <= this.p.parser.maxNode;
      if (isNode)
        this.storeNode(next, this.pos, nextEnd, 4);
      this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
      this.pos = this.reducePos = nextEnd;
      this.score -= 190;
    }
    canShift(term) {
      for (let sim = new SimulatedStack(this); ; ) {
        let action = this.p.parser.stateSlot(sim.state, 4) || this.p.parser.hasAction(sim.state, term);
        if (action == 0)
          return false;
        if ((action & 65536) == 0)
          return true;
        sim.reduce(action);
      }
    }
    recoverByInsert(next) {
      if (this.stack.length >= 300)
        return [];
      let nextStates = this.p.parser.nextStates(this.state);
      if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
        let best = [];
        for (let i = 0, s; i < nextStates.length; i += 2) {
          if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
            best.push(nextStates[i], s);
        }
        if (this.stack.length < 120)
          for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
            let s = nextStates[i + 1];
            if (!best.some((v, i2) => i2 & 1 && v == s))
              best.push(nextStates[i], s);
          }
        nextStates = best;
      }
      let result = [];
      for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
        let s = nextStates[i + 1];
        if (s == this.state)
          continue;
        let stack = this.split();
        stack.pushState(s, this.pos);
        stack.storeNode(0, stack.pos, stack.pos, 4, true);
        stack.shiftContext(nextStates[i], this.pos);
        stack.reducePos = this.pos;
        stack.score -= 200;
        result.push(stack);
      }
      return result;
    }
    forceReduce() {
      let { parser: parser19 } = this.p;
      let reduce = parser19.stateSlot(this.state, 5);
      if ((reduce & 65536) == 0)
        return false;
      if (!parser19.validAction(this.state, reduce)) {
        let depth = reduce >> 19, term = reduce & 65535;
        let target = this.stack.length - depth * 3;
        if (target < 0 || parser19.getGoto(this.stack[target], term, false) < 0) {
          let backup = this.findForcedReduction();
          if (backup == null)
            return false;
          reduce = backup;
        }
        this.storeNode(0, this.pos, this.pos, 4, true);
        this.score -= 100;
      }
      this.reducePos = this.pos;
      this.reduce(reduce);
      return true;
    }
    findForcedReduction() {
      let { parser: parser19 } = this.p, seen = [];
      let explore = (state, depth) => {
        if (seen.includes(state))
          return;
        seen.push(state);
        return parser19.allActions(state, (action) => {
          if (action & (262144 | 131072))
            ;
          else if (action & 65536) {
            let rDepth = (action >> 19) - depth;
            if (rDepth > 1) {
              let term = action & 65535, target = this.stack.length - rDepth * 3;
              if (target >= 0 && parser19.getGoto(this.stack[target], term, false) >= 0)
                return rDepth << 19 | 65536 | term;
            }
          } else {
            let found = explore(action, depth + 1);
            if (found != null)
              return found;
          }
        });
      };
      return explore(this.state, 0);
    }
    forceAll() {
      while (!this.p.parser.stateFlag(this.state, 2)) {
        if (!this.forceReduce()) {
          this.storeNode(0, this.pos, this.pos, 4, true);
          break;
        }
      }
      return this;
    }
    get deadEnd() {
      if (this.stack.length != 3)
        return false;
      let { parser: parser19 } = this.p;
      return parser19.data[parser19.stateSlot(this.state, 1)] == 65535 && !parser19.stateSlot(this.state, 4);
    }
    restart() {
      this.storeNode(0, this.pos, this.pos, 4, true);
      this.state = this.stack[0];
      this.stack.length = 0;
    }
    sameState(other) {
      if (this.state != other.state || this.stack.length != other.stack.length)
        return false;
      for (let i = 0; i < this.stack.length; i += 3)
        if (this.stack[i] != other.stack[i])
          return false;
      return true;
    }
    get parser() {
      return this.p.parser;
    }
    dialectEnabled(dialectID) {
      return this.p.parser.dialect.flags[dialectID];
    }
    shiftContext(term, start2) {
      if (this.curContext)
        this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start2)));
    }
    reduceContext(term, start2) {
      if (this.curContext)
        this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start2)));
    }
    emitContext() {
      let last = this.buffer.length - 1;
      if (last < 0 || this.buffer[last] != -3)
        this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
    }
    emitLookAhead() {
      let last = this.buffer.length - 1;
      if (last < 0 || this.buffer[last] != -4)
        this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
    }
    updateContext(context2) {
      if (context2 != this.curContext.context) {
        let newCx = new StackContext(this.curContext.tracker, context2);
        if (newCx.hash != this.curContext.hash)
          this.emitContext();
        this.curContext = newCx;
      }
    }
    setLookAhead(lookAhead) {
      if (lookAhead > this.lookAhead) {
        this.emitLookAhead();
        this.lookAhead = lookAhead;
      }
    }
    close() {
      if (this.curContext && this.curContext.tracker.strict)
        this.emitContext();
      if (this.lookAhead > 0)
        this.emitLookAhead();
    }
  };
  var StackContext = class {
    constructor(tracker, context2) {
      this.tracker = tracker;
      this.context = context2;
      this.hash = tracker.strict ? tracker.hash(context2) : 0;
    }
  };
  var SimulatedStack = class {
    constructor(start2) {
      this.start = start2;
      this.state = start2.state;
      this.stack = start2.stack;
      this.base = this.stack.length;
    }
    reduce(action) {
      let term = action & 65535, depth = action >> 19;
      if (depth == 0) {
        if (this.stack == this.start.stack)
          this.stack = this.stack.slice();
        this.stack.push(this.state, 0, 0);
        this.base += 3;
      } else {
        this.base -= (depth - 1) * 3;
      }
      let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
      this.state = goto;
    }
  };
  var StackBufferCursor = class {
    constructor(stack, pos, index3) {
      this.stack = stack;
      this.pos = pos;
      this.index = index3;
      this.buffer = stack.buffer;
      if (this.index == 0)
        this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
      return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
      let next = this.stack.parent;
      if (next != null) {
        this.index = this.stack.bufferBase - next.bufferBase;
        this.stack = next;
        this.buffer = next.buffer;
      }
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    next() {
      this.index -= 4;
      this.pos -= 4;
      if (this.index == 0)
        this.maybeNext();
    }
    fork() {
      return new StackBufferCursor(this.stack, this.pos, this.index);
    }
  };
  function decodeArray(input2, Type = Uint16Array) {
    if (typeof input2 != "string")
      return input2;
    let array = null;
    for (let pos = 0, out = 0; pos < input2.length; ) {
      let value = 0;
      for (; ; ) {
        let next = input2.charCodeAt(pos++), stop = false;
        if (next == 126) {
          value = 65535;
          break;
        }
        if (next >= 92)
          next--;
        if (next >= 34)
          next--;
        let digit = next - 32;
        if (digit >= 46) {
          digit -= 46;
          stop = true;
        }
        value += digit;
        if (stop)
          break;
        value *= 46;
      }
      if (array)
        array[out++] = value;
      else
        array = new Type(value);
    }
    return array;
  }
  var CachedToken = class {
    constructor() {
      this.start = -1;
      this.value = -1;
      this.end = -1;
      this.extended = -1;
      this.lookAhead = 0;
      this.mask = 0;
      this.context = 0;
    }
  };
  var nullToken = new CachedToken();
  var InputStream = class {
    constructor(input2, ranges) {
      this.input = input2;
      this.ranges = ranges;
      this.chunk = "";
      this.chunkOff = 0;
      this.chunk2 = "";
      this.chunk2Pos = 0;
      this.next = -1;
      this.token = nullToken;
      this.rangeIndex = 0;
      this.pos = this.chunkPos = ranges[0].from;
      this.range = ranges[0];
      this.end = ranges[ranges.length - 1].to;
      this.readNext();
    }
    resolveOffset(offset, assoc) {
      let range10 = this.range, index3 = this.rangeIndex;
      let pos = this.pos + offset;
      while (pos < range10.from) {
        if (!index3)
          return null;
        let next = this.ranges[--index3];
        pos -= range10.from - next.to;
        range10 = next;
      }
      while (assoc < 0 ? pos > range10.to : pos >= range10.to) {
        if (index3 == this.ranges.length - 1)
          return null;
        let next = this.ranges[++index3];
        pos += next.from - range10.to;
        range10 = next;
      }
      return pos;
    }
    clipPos(pos) {
      if (pos >= this.range.from && pos < this.range.to)
        return pos;
      for (let range10 of this.ranges)
        if (range10.to > pos)
          return Math.max(pos, range10.from);
      return this.end;
    }
    peek(offset) {
      let idx = this.chunkOff + offset, pos, result;
      if (idx >= 0 && idx < this.chunk.length) {
        pos = this.pos + offset;
        result = this.chunk.charCodeAt(idx);
      } else {
        let resolved = this.resolveOffset(offset, 1);
        if (resolved == null)
          return -1;
        pos = resolved;
        if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
          result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
        } else {
          let i = this.rangeIndex, range10 = this.range;
          while (range10.to <= pos)
            range10 = this.ranges[++i];
          this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
          if (pos + this.chunk2.length > range10.to)
            this.chunk2 = this.chunk2.slice(0, range10.to - pos);
          result = this.chunk2.charCodeAt(0);
        }
      }
      if (pos >= this.token.lookAhead)
        this.token.lookAhead = pos + 1;
      return result;
    }
    acceptToken(token, endOffset = 0) {
      let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
      if (end == null || end < this.token.start)
        throw new RangeError("Token end out of bounds");
      this.token.value = token;
      this.token.end = end;
    }
    getChunk() {
      if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
        let { chunk, chunkPos } = this;
        this.chunk = this.chunk2;
        this.chunkPos = this.chunk2Pos;
        this.chunk2 = chunk;
        this.chunk2Pos = chunkPos;
        this.chunkOff = this.pos - this.chunkPos;
      } else {
        this.chunk2 = this.chunk;
        this.chunk2Pos = this.chunkPos;
        let nextChunk = this.input.chunk(this.pos);
        let end = this.pos + nextChunk.length;
        this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
        this.chunkPos = this.pos;
        this.chunkOff = 0;
      }
    }
    readNext() {
      if (this.chunkOff >= this.chunk.length) {
        this.getChunk();
        if (this.chunkOff == this.chunk.length)
          return this.next = -1;
      }
      return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    advance(n = 1) {
      this.chunkOff += n;
      while (this.pos + n >= this.range.to) {
        if (this.rangeIndex == this.ranges.length - 1)
          return this.setDone();
        n -= this.range.to - this.pos;
        this.range = this.ranges[++this.rangeIndex];
        this.pos = this.range.from;
      }
      this.pos += n;
      if (this.pos >= this.token.lookAhead)
        this.token.lookAhead = this.pos + 1;
      return this.readNext();
    }
    setDone() {
      this.pos = this.chunkPos = this.end;
      this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
      this.chunk = "";
      return this.next = -1;
    }
    reset(pos, token) {
      if (token) {
        this.token = token;
        token.start = pos;
        token.lookAhead = pos + 1;
        token.value = token.extended = -1;
      } else {
        this.token = nullToken;
      }
      if (this.pos != pos) {
        this.pos = pos;
        if (pos == this.end) {
          this.setDone();
          return this;
        }
        while (pos < this.range.from)
          this.range = this.ranges[--this.rangeIndex];
        while (pos >= this.range.to)
          this.range = this.ranges[++this.rangeIndex];
        if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
          this.chunkOff = pos - this.chunkPos;
        } else {
          this.chunk = "";
          this.chunkOff = 0;
        }
        this.readNext();
      }
      return this;
    }
    read(from17, to10) {
      if (from17 >= this.chunkPos && to10 <= this.chunkPos + this.chunk.length)
        return this.chunk.slice(from17 - this.chunkPos, to10 - this.chunkPos);
      if (from17 >= this.chunk2Pos && to10 <= this.chunk2Pos + this.chunk2.length)
        return this.chunk2.slice(from17 - this.chunk2Pos, to10 - this.chunk2Pos);
      if (from17 >= this.range.from && to10 <= this.range.to)
        return this.input.read(from17, to10);
      let result = "";
      for (let r of this.ranges) {
        if (r.from >= to10)
          break;
        if (r.to > from17)
          result += this.input.read(Math.max(r.from, from17), Math.min(r.to, to10));
      }
      return result;
    }
  };
  var TokenGroup = class {
    constructor(data, id2) {
      this.data = data;
      this.id = id2;
    }
    token(input2, stack) {
      let { parser: parser19 } = stack.p;
      readToken(this.data, input2, stack, this.id, parser19.data, parser19.tokenPrecTable);
    }
  };
  TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
  var LocalTokenGroup = class {
    constructor(data, precTable, elseToken) {
      this.precTable = precTable;
      this.elseToken = elseToken;
      this.data = typeof data == "string" ? decodeArray(data) : data;
    }
    token(input2, stack) {
      let start2 = input2.pos, skipped = 0;
      for (; ; ) {
        let atEof = input2.next < 0, nextPos = input2.resolveOffset(1, 1);
        readToken(this.data, input2, stack, 0, this.data, this.precTable);
        if (input2.token.value > -1)
          break;
        if (this.elseToken == null)
          return;
        if (!atEof)
          skipped++;
        if (nextPos == null)
          break;
        input2.reset(nextPos, input2.token);
      }
      if (skipped) {
        input2.reset(start2, input2.token);
        input2.acceptToken(this.elseToken, skipped);
      }
    }
  };
  LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
  function readToken(data, input2, stack, group, precTable, precOffset) {
    let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
    scan:
      for (; ; ) {
        if ((groupMask & data[state]) == 0)
          break;
        let accEnd = data[state + 1];
        for (let i = state + 3; i < accEnd; i += 2)
          if ((data[i + 1] & groupMask) > 0) {
            let term = data[i];
            if (dialect.allows(term) && (input2.token.value == -1 || input2.token.value == term || overrides(term, input2.token.value, precTable, precOffset))) {
              input2.acceptToken(term);
              break;
            }
          }
        let next = input2.next, low = 0, high = data[state + 2];
        if (input2.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 && data[accEnd + high * 3 - 3] == 65535) {
          state = data[accEnd + high * 3 - 1];
          continue scan;
        }
        for (; low < high; ) {
          let mid = low + high >> 1;
          let index3 = accEnd + mid + (mid << 1);
          let from17 = data[index3], to10 = data[index3 + 1] || 65536;
          if (next < from17)
            high = mid;
          else if (next >= to10)
            low = mid + 1;
          else {
            state = data[index3 + 2];
            input2.advance();
            continue scan;
          }
        }
        break;
      }
  }
  function findOffset(data, start2, term) {
    for (let i = start2, next; (next = data[i]) != 65535; i++)
      if (next == term)
        return i - start2;
    return -1;
  }
  function overrides(token, prev, tableData, tableOffset) {
    let iPrev = findOffset(tableData, tableOffset, prev);
    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
  }
  var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
  var stackIDs = null;
  function cutAt(tree, pos, side) {
    let cursor = tree.cursor(IterMode.IncludeAnonymous);
    cursor.moveTo(pos);
    for (; ; ) {
      if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
        for (; ; ) {
          if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
            return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25));
          if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
            break;
          if (!cursor.parent())
            return side < 0 ? 0 : tree.length;
        }
    }
  }
  var FragmentCursor = class {
    constructor(fragments, nodeSet) {
      this.fragments = fragments;
      this.nodeSet = nodeSet;
      this.i = 0;
      this.fragment = null;
      this.safeFrom = -1;
      this.safeTo = -1;
      this.trees = [];
      this.start = [];
      this.index = [];
      this.nextFragment();
    }
    nextFragment() {
      let fr2 = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
      if (fr2) {
        this.safeFrom = fr2.openStart ? cutAt(fr2.tree, fr2.from + fr2.offset, 1) - fr2.offset : fr2.from;
        this.safeTo = fr2.openEnd ? cutAt(fr2.tree, fr2.to + fr2.offset, -1) - fr2.offset : fr2.to;
        while (this.trees.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
        }
        this.trees.push(fr2.tree);
        this.start.push(-fr2.offset);
        this.index.push(0);
        this.nextStart = this.safeFrom;
      } else {
        this.nextStart = 1e9;
      }
    }
    nodeAt(pos) {
      if (pos < this.nextStart)
        return null;
      while (this.fragment && this.safeTo <= pos)
        this.nextFragment();
      if (!this.fragment)
        return null;
      for (; ; ) {
        let last = this.trees.length - 1;
        if (last < 0) {
          this.nextFragment();
          return null;
        }
        let top2 = this.trees[last], index3 = this.index[last];
        if (index3 == top2.children.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
          continue;
        }
        let next = top2.children[index3];
        let start2 = this.start[last] + top2.positions[index3];
        if (start2 > pos) {
          this.nextStart = start2;
          return null;
        }
        if (next instanceof Tree) {
          if (start2 == pos) {
            if (start2 < this.safeFrom)
              return null;
            let end = start2 + next.length;
            if (end <= this.safeTo) {
              let lookAhead = next.prop(NodeProp.lookAhead);
              if (!lookAhead || end + lookAhead < this.fragment.to)
                return next;
            }
          }
          this.index[last]++;
          if (start2 + next.length >= Math.max(this.safeFrom, pos)) {
            this.trees.push(next);
            this.start.push(start2);
            this.index.push(0);
          }
        } else {
          this.index[last]++;
          this.nextStart = start2 + next.length;
        }
      }
    }
  };
  var TokenCache = class {
    constructor(parser19, stream) {
      this.stream = stream;
      this.tokens = [];
      this.mainToken = null;
      this.actions = [];
      this.tokens = parser19.tokenizers.map((_) => new CachedToken());
    }
    getActions(stack) {
      let actionIndex = 0;
      let main = null;
      let { parser: parser19 } = stack.p, { tokenizers } = parser19;
      let mask = parser19.stateSlot(stack.state, 3);
      let context2 = stack.curContext ? stack.curContext.hash : 0;
      let lookAhead = 0;
      for (let i = 0; i < tokenizers.length; i++) {
        if ((1 << i & mask) == 0)
          continue;
        let tokenizer = tokenizers[i], token = this.tokens[i];
        if (main && !tokenizer.fallback)
          continue;
        if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context2) {
          this.updateCachedToken(token, tokenizer, stack);
          token.mask = mask;
          token.context = context2;
        }
        if (token.lookAhead > token.end + 25)
          lookAhead = Math.max(token.lookAhead, lookAhead);
        if (token.value != 0) {
          let startIndex = actionIndex;
          if (token.extended > -1)
            actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
          actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
          if (!tokenizer.extend) {
            main = token;
            if (actionIndex > startIndex)
              break;
          }
        }
      }
      while (this.actions.length > actionIndex)
        this.actions.pop();
      if (lookAhead)
        stack.setLookAhead(lookAhead);
      if (!main && stack.pos == this.stream.end) {
        main = new CachedToken();
        main.value = stack.p.parser.eofTerm;
        main.start = main.end = stack.pos;
        actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
      }
      this.mainToken = main;
      return this.actions;
    }
    getMainToken(stack) {
      if (this.mainToken)
        return this.mainToken;
      let main = new CachedToken(), { pos, p } = stack;
      main.start = pos;
      main.end = Math.min(pos + 1, p.stream.end);
      main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
      return main;
    }
    updateCachedToken(token, tokenizer, stack) {
      let start2 = this.stream.clipPos(stack.pos);
      tokenizer.token(this.stream.reset(start2, token), stack);
      if (token.value > -1) {
        let { parser: parser19 } = stack.p;
        for (let i = 0; i < parser19.specialized.length; i++)
          if (parser19.specialized[i] == token.value) {
            let result = parser19.specializers[i](this.stream.read(token.start, token.end), stack);
            if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
              if ((result & 1) == 0)
                token.value = result >> 1;
              else
                token.extended = result >> 1;
              break;
            }
          }
      } else {
        token.value = 0;
        token.end = this.stream.clipPos(start2 + 1);
      }
    }
    putAction(action, token, end, index3) {
      for (let i = 0; i < index3; i += 3)
        if (this.actions[i] == action)
          return index3;
      this.actions[index3++] = action;
      this.actions[index3++] = token;
      this.actions[index3++] = end;
      return index3;
    }
    addActions(stack, token, end, index3) {
      let { state } = stack, { parser: parser19 } = stack.p, { data } = parser19;
      for (let set2 = 0; set2 < 2; set2++) {
        for (let i = parser19.stateSlot(state, set2 ? 2 : 1); ; i += 3) {
          if (data[i] == 65535) {
            if (data[i + 1] == 1) {
              i = pair(data, i + 2);
            } else {
              if (index3 == 0 && data[i + 1] == 2)
                index3 = this.putAction(pair(data, i + 2), token, end, index3);
              break;
            }
          }
          if (data[i] == token)
            index3 = this.putAction(pair(data, i + 1), token, end, index3);
        }
      }
      return index3;
    }
  };
  var Parse = class {
    constructor(parser19, input2, fragments, ranges) {
      this.parser = parser19;
      this.input = input2;
      this.ranges = ranges;
      this.recovering = 0;
      this.nextStackID = 9812;
      this.minStackPos = 0;
      this.reused = [];
      this.stoppedAt = null;
      this.lastBigReductionStart = -1;
      this.lastBigReductionSize = 0;
      this.bigReductionCount = 0;
      this.stream = new InputStream(input2, ranges);
      this.tokens = new TokenCache(parser19, this.stream);
      this.topTerm = parser19.top[1];
      let { from: from17 } = ranges[0];
      this.stacks = [Stack.start(this, parser19.top[0], from17)];
      this.fragments = fragments.length && this.stream.end - from17 > parser19.bufferLength * 4 ? new FragmentCursor(fragments, parser19.nodeSet) : null;
    }
    get parsedPos() {
      return this.minStackPos;
    }
    advance() {
      let stacks = this.stacks, pos = this.minStackPos;
      let newStacks = this.stacks = [];
      let stopped, stoppedTokens;
      if (this.bigReductionCount > 300 && stacks.length == 1) {
        let [s] = stacks;
        while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) {
        }
        this.bigReductionCount = this.lastBigReductionSize = 0;
      }
      for (let i = 0; i < stacks.length; i++) {
        let stack = stacks[i];
        for (; ; ) {
          this.tokens.mainToken = null;
          if (stack.pos > pos) {
            newStacks.push(stack);
          } else if (this.advanceStack(stack, newStacks, stacks)) {
            continue;
          } else {
            if (!stopped) {
              stopped = [];
              stoppedTokens = [];
            }
            stopped.push(stack);
            let tok = this.tokens.getMainToken(stack);
            stoppedTokens.push(tok.value, tok.end);
          }
          break;
        }
      }
      if (!newStacks.length) {
        let finished = stopped && findFinished(stopped);
        if (finished) {
          if (verbose)
            console.log("Finish with " + this.stackID(finished));
          return this.stackToTree(finished);
        }
        if (this.parser.strict) {
          if (verbose && stopped)
            console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
          throw new SyntaxError("No parse at " + pos);
        }
        if (!this.recovering)
          this.recovering = 5;
      }
      if (this.recovering && stopped) {
        let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
        if (finished) {
          if (verbose)
            console.log("Force-finish " + this.stackID(finished));
          return this.stackToTree(finished.forceAll());
        }
      }
      if (this.recovering) {
        let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
        if (newStacks.length > maxRemaining) {
          newStacks.sort((a, b) => b.score - a.score);
          while (newStacks.length > maxRemaining)
            newStacks.pop();
        }
        if (newStacks.some((s) => s.reducePos > pos))
          this.recovering--;
      } else if (newStacks.length > 1) {
        outer:
          for (let i = 0; i < newStacks.length - 1; i++) {
            let stack = newStacks[i];
            for (let j2 = i + 1; j2 < newStacks.length; j2++) {
              let other = newStacks[j2];
              if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
                if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                  newStacks.splice(j2--, 1);
                } else {
                  newStacks.splice(i--, 1);
                  continue outer;
                }
              }
            }
          }
        if (newStacks.length > 12)
          newStacks.splice(12, newStacks.length - 12);
      }
      this.minStackPos = newStacks[0].pos;
      for (let i = 1; i < newStacks.length; i++)
        if (newStacks[i].pos < this.minStackPos)
          this.minStackPos = newStacks[i].pos;
      return null;
    }
    stopAt(pos) {
      if (this.stoppedAt != null && this.stoppedAt < pos)
        throw new RangeError("Can't move stoppedAt forward");
      this.stoppedAt = pos;
    }
    advanceStack(stack, stacks, split) {
      let start2 = stack.pos, { parser: parser19 } = this;
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (this.stoppedAt != null && start2 > this.stoppedAt)
        return stack.forceReduce() ? stack : null;
      if (this.fragments) {
        let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
        for (let cached = this.fragments.nodeAt(start2); cached; ) {
          let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser19.getGoto(stack.state, cached.type.id) : -1;
          if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
            stack.useNode(cached, match);
            if (verbose)
              console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser19.getName(cached.type.id)})`);
            return true;
          }
          if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
            break;
          let inner = cached.children[0];
          if (inner instanceof Tree && cached.positions[0] == 0)
            cached = inner;
          else
            break;
        }
      }
      let defaultReduce = parser19.stateSlot(stack.state, 4);
      if (defaultReduce > 0) {
        stack.reduce(defaultReduce);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser19.getName(defaultReduce & 65535)})`);
        return true;
      }
      if (stack.stack.length >= 9e3) {
        while (stack.stack.length > 6e3 && stack.forceReduce()) {
        }
      }
      let actions = this.tokens.getActions(stack);
      for (let i = 0; i < actions.length; ) {
        let action = actions[i++], term = actions[i++], end = actions[i++];
        let last = i == actions.length || !split;
        let localStack = last ? stack : stack.split();
        let main = this.tokens.mainToken;
        localStack.apply(action, term, main ? main.start : localStack.pos, end);
        if (verbose)
          console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser19.getName(action & 65535)}`} for ${parser19.getName(term)} @ ${start2}${localStack == stack ? "" : ", split"})`);
        if (last)
          return true;
        else if (localStack.pos > start2)
          stacks.push(localStack);
        else
          split.push(localStack);
      }
      return false;
    }
    advanceFully(stack, newStacks) {
      let pos = stack.pos;
      for (; ; ) {
        if (!this.advanceStack(stack, null, null))
          return false;
        if (stack.pos > pos) {
          pushStackDedup(stack, newStacks);
          return true;
        }
      }
    }
    runRecovery(stacks, tokens, newStacks) {
      let finished = null, restarted = false;
      for (let i = 0; i < stacks.length; i++) {
        let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
        let base2 = verbose ? this.stackID(stack) + " -> " : "";
        if (stack.deadEnd) {
          if (restarted)
            continue;
          restarted = true;
          stack.restart();
          if (verbose)
            console.log(base2 + this.stackID(stack) + " (restarted)");
          let done = this.advanceFully(stack, newStacks);
          if (done)
            continue;
        }
        let force = stack.split(), forceBase = base2;
        for (let j2 = 0; force.forceReduce() && j2 < 10; j2++) {
          if (verbose)
            console.log(forceBase + this.stackID(force) + " (via force-reduce)");
          let done = this.advanceFully(force, newStacks);
          if (done)
            break;
          if (verbose)
            forceBase = this.stackID(force) + " -> ";
        }
        for (let insert2 of stack.recoverByInsert(token)) {
          if (verbose)
            console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
          this.advanceFully(insert2, newStacks);
        }
        if (this.stream.end > stack.pos) {
          if (tokenEnd == stack.pos) {
            tokenEnd++;
            token = 0;
          }
          stack.recoverByDelete(token, tokenEnd);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
          pushStackDedup(stack, newStacks);
        } else if (!finished || finished.score < stack.score) {
          finished = stack;
        }
      }
      return finished;
    }
    stackToTree(stack) {
      stack.close();
      return Tree.build({
        buffer: StackBufferCursor.create(stack),
        nodeSet: this.parser.nodeSet,
        topID: this.topTerm,
        maxBufferLength: this.parser.bufferLength,
        reused: this.reused,
        start: this.ranges[0].from,
        length: stack.pos - this.ranges[0].from,
        minRepeatType: this.parser.minRepeatTerm
      });
    }
    stackID(stack) {
      let id2 = (stackIDs || (stackIDs = new WeakMap())).get(stack);
      if (!id2)
        stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
      return id2 + stack;
    }
  };
  function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
      let other = newStacks[i];
      if (other.pos == stack.pos && other.sameState(stack)) {
        if (newStacks[i].score < stack.score)
          newStacks[i] = stack;
        return;
      }
    }
    newStacks.push(stack);
  }
  var Dialect = class {
    constructor(source, flags, disabled) {
      this.source = source;
      this.flags = flags;
      this.disabled = disabled;
    }
    allows(term) {
      return !this.disabled || this.disabled[term] == 0;
    }
  };
  var LRParser = class extends Parser {
    constructor(spec) {
      super();
      this.wrappers = [];
      if (spec.version != 14)
        throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
      let nodeNames = spec.nodeNames.split(" ");
      this.minRepeatTerm = nodeNames.length;
      for (let i = 0; i < spec.repeatNodeCount; i++)
        nodeNames.push("");
      let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
      let nodeProps = [];
      for (let i = 0; i < nodeNames.length; i++)
        nodeProps.push([]);
      function setProp(nodeID, prop, value) {
        nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
      }
      if (spec.nodeProps)
        for (let propSpec of spec.nodeProps) {
          let prop = propSpec[0];
          if (typeof prop == "string")
            prop = NodeProp[prop];
          for (let i = 1; i < propSpec.length; ) {
            let next = propSpec[i++];
            if (next >= 0) {
              setProp(next, prop, propSpec[i++]);
            } else {
              let value = propSpec[i + -next];
              for (let j2 = -next; j2 > 0; j2--)
                setProp(propSpec[i++], prop, value);
              i++;
            }
          }
        }
      this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
        name: i >= this.minRepeatTerm ? void 0 : name2,
        id: i,
        props: nodeProps[i],
        top: topTerms.indexOf(i) > -1,
        error: i == 0,
        skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
      })));
      if (spec.propSources)
        this.nodeSet = this.nodeSet.extend(...spec.propSources);
      this.strict = false;
      this.bufferLength = DefaultBufferLength;
      let tokenArray = decodeArray(spec.tokenData);
      this.context = spec.context;
      this.specializerSpecs = spec.specialized || [];
      this.specialized = new Uint16Array(this.specializerSpecs.length);
      for (let i = 0; i < this.specializerSpecs.length; i++)
        this.specialized[i] = this.specializerSpecs[i].term;
      this.specializers = this.specializerSpecs.map(getSpecializer);
      this.states = decodeArray(spec.states, Uint32Array);
      this.data = decodeArray(spec.stateData);
      this.goto = decodeArray(spec.goto);
      this.maxTerm = spec.maxTerm;
      this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
      this.topRules = spec.topRules;
      this.dialects = spec.dialects || {};
      this.dynamicPrecedences = spec.dynamicPrecedences || null;
      this.tokenPrecTable = spec.tokenPrec;
      this.termNames = spec.termNames || null;
      this.maxNode = this.nodeSet.types.length - 1;
      this.dialect = this.parseDialect();
      this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input2, fragments, ranges) {
      let parse2 = new Parse(this, input2, fragments, ranges);
      for (let w of this.wrappers)
        parse2 = w(parse2, input2, fragments, ranges);
      return parse2;
    }
    getGoto(state, term, loose = false) {
      let table = this.goto;
      if (term >= table[0])
        return -1;
      for (let pos = table[term + 1]; ; ) {
        let groupTag = table[pos++], last = groupTag & 1;
        let target = table[pos++];
        if (last && loose)
          return target;
        for (let end = pos + (groupTag >> 1); pos < end; pos++)
          if (table[pos] == state)
            return target;
        if (last)
          return -1;
      }
    }
    hasAction(state, terminal) {
      let data = this.data;
      for (let set2 = 0; set2 < 2; set2++) {
        for (let i = this.stateSlot(state, set2 ? 2 : 1), next; ; i += 3) {
          if ((next = data[i]) == 65535) {
            if (data[i + 1] == 1)
              next = data[i = pair(data, i + 2)];
            else if (data[i + 1] == 2)
              return pair(data, i + 2);
            else
              break;
          }
          if (next == terminal || next == 0)
            return pair(data, i + 1);
        }
      }
      return 0;
    }
    stateSlot(state, slot) {
      return this.states[state * 6 + slot];
    }
    stateFlag(state, flag) {
      return (this.stateSlot(state, 0) & flag) > 0;
    }
    validAction(state, action) {
      return !!this.allActions(state, (a) => a == action ? true : null);
    }
    allActions(state, action) {
      let deflt = this.stateSlot(state, 4);
      let result = deflt ? action(deflt) : void 0;
      for (let i = this.stateSlot(state, 1); result == null; i += 3) {
        if (this.data[i] == 65535) {
          if (this.data[i + 1] == 1)
            i = pair(this.data, i + 2);
          else
            break;
        }
        result = action(pair(this.data, i + 1));
      }
      return result;
    }
    nextStates(state) {
      let result = [];
      for (let i = this.stateSlot(state, 1); ; i += 3) {
        if (this.data[i] == 65535) {
          if (this.data[i + 1] == 1)
            i = pair(this.data, i + 2);
          else
            break;
        }
        if ((this.data[i + 2] & 65536 >> 16) == 0) {
          let value = this.data[i + 1];
          if (!result.some((v, i2) => i2 & 1 && v == value))
            result.push(this.data[i], value);
        }
      }
      return result;
    }
    configure(config) {
      let copy = Object.assign(Object.create(LRParser.prototype), this);
      if (config.props)
        copy.nodeSet = this.nodeSet.extend(...config.props);
      if (config.top) {
        let info = this.topRules[config.top];
        if (!info)
          throw new RangeError(`Invalid top rule name ${config.top}`);
        copy.top = info;
      }
      if (config.tokenizers)
        copy.tokenizers = this.tokenizers.map((t2) => {
          let found = config.tokenizers.find((r) => r.from == t2);
          return found ? found.to : t2;
        });
      if (config.specializers) {
        copy.specializers = this.specializers.slice();
        copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
          let found = config.specializers.find((r) => r.from == s.external);
          if (!found)
            return s;
          let spec = Object.assign(Object.assign({}, s), { external: found.to });
          copy.specializers[i] = getSpecializer(spec);
          return spec;
        });
      }
      if (config.contextTracker)
        copy.context = config.contextTracker;
      if (config.dialect)
        copy.dialect = this.parseDialect(config.dialect);
      if (config.strict != null)
        copy.strict = config.strict;
      if (config.wrap)
        copy.wrappers = copy.wrappers.concat(config.wrap);
      if (config.bufferLength != null)
        copy.bufferLength = config.bufferLength;
      return copy;
    }
    hasWrappers() {
      return this.wrappers.length > 0;
    }
    getName(term) {
      return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    get eofTerm() {
      return this.maxNode + 1;
    }
    get topNode() {
      return this.nodeSet.types[this.top[1]];
    }
    dynamicPrecedence(term) {
      let prec2 = this.dynamicPrecedences;
      return prec2 == null ? 0 : prec2[term] || 0;
    }
    parseDialect(dialect) {
      let values = Object.keys(this.dialects), flags = values.map(() => false);
      if (dialect)
        for (let part of dialect.split(" ")) {
          let id2 = values.indexOf(part);
          if (id2 >= 0)
            flags[id2] = true;
        }
      let disabled = null;
      for (let i = 0; i < values.length; i++)
        if (!flags[i]) {
          for (let j2 = this.dialects[values[i]], id2; (id2 = this.data[j2++]) != 65535; )
            (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
        }
      return new Dialect(dialect, flags, disabled);
    }
    static deserialize(spec) {
      return new LRParser(spec);
    }
  };
  function pair(data, off2) {
    return data[off2] | data[off2 + 1] << 16;
  }
  function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
      let stopped = stack.p.stoppedAt;
      if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score))
        best = stack;
    }
    return best;
  }
  function getSpecializer(spec) {
    if (spec.external) {
      let mask = spec.extend ? 1 : 0;
      return (value, stack) => spec.external(value, stack) << 1 | mask;
    }
    return spec.get;
  }

  // static/js/lezer-parsers/level1-parser.terms.ts
  var print = 1;
  var forward = 2;
  var turn = 3;
  var echo = 4;
  var play = 5;
  var ask = 6;
  var color = 7;

  // static/js/lezer-parsers/level2-parser.terms.ts
  var ask2 = 1;
  var print2 = 2;
  var forward2 = 3;
  var turn2 = 4;
  var color2 = 5;
  var sleep = 6;
  var play2 = 7;
  var is = 8;

  // static/js/lezer-parsers/level3-parser.terms.ts
  var ask3 = 1;
  var at = 2;
  var random = 3;
  var print3 = 4;
  var forward3 = 5;
  var turn3 = 6;
  var color3 = 7;
  var sleep2 = 8;
  var play3 = 9;
  var is2 = 10;
  var add2 = 11;
  var from = 12;
  var remove2 = 13;
  var toList = 14;

  // static/js/lezer-parsers/level4-parser.terms.ts
  var ask4 = 1;
  var at2 = 2;
  var random2 = 3;
  var print4 = 4;
  var forward4 = 5;
  var turn4 = 6;
  var color4 = 7;
  var sleep3 = 8;
  var play4 = 9;
  var is3 = 10;
  var add3 = 11;
  var from2 = 12;
  var remove3 = 13;
  var toList2 = 14;
  var clear = 15;

  // static/js/lezer-parsers/level5-parser.terms.ts
  var ask5 = 1;
  var at3 = 2;
  var random3 = 3;
  var ifs = 4;
  var elses = 5;
  var pressed = 6;
  var print5 = 7;
  var forward5 = 8;
  var turn5 = 9;
  var color5 = 10;
  var sleep4 = 11;
  var play5 = 12;
  var is4 = 13;
  var add4 = 14;
  var from3 = 15;
  var remove4 = 16;
  var toList3 = 17;
  var clear2 = 18;
  var ins = 19;
  var not_in = 20;

  // static/js/lezer-parsers/level6-parser.terms.ts
  var ask6 = 1;
  var at4 = 2;
  var random4 = 3;
  var ifs2 = 4;
  var elses2 = 5;
  var pressed2 = 6;
  var print6 = 7;
  var forward6 = 8;
  var turn6 = 9;
  var color6 = 10;
  var sleep5 = 11;
  var play6 = 12;
  var is5 = 13;
  var add5 = 14;
  var from4 = 15;
  var remove5 = 16;
  var toList4 = 17;
  var clear3 = 18;
  var ins2 = 19;
  var not_in2 = 20;

  // static/js/lezer-parsers/level7-parser.terms.ts
  var ask7 = 1;
  var at5 = 2;
  var random5 = 3;
  var ifs3 = 4;
  var pressed3 = 5;
  var elses3 = 6;
  var print7 = 7;
  var forward7 = 8;
  var turn7 = 9;
  var color7 = 10;
  var sleep6 = 11;
  var play7 = 12;
  var is6 = 13;
  var add6 = 14;
  var from5 = 15;
  var remove6 = 16;
  var toList5 = 17;
  var clear4 = 18;
  var ins3 = 19;
  var not_in3 = 20;
  var repeat = 21;
  var times = 22;

  // static/js/lezer-parsers/level8-parser.terms.ts
  var ask8 = 1;
  var at6 = 2;
  var random6 = 3;
  var ifs4 = 4;
  var pressed4 = 5;
  var elses4 = 6;
  var print8 = 7;
  var forward8 = 8;
  var turn8 = 9;
  var color8 = 10;
  var sleep7 = 11;
  var play8 = 12;
  var is7 = 13;
  var add7 = 14;
  var from6 = 15;
  var remove7 = 16;
  var toList6 = 17;
  var clear5 = 18;
  var ins4 = 19;
  var not_in4 = 20;
  var repeat2 = 21;
  var times2 = 22;

  // static/js/lezer-parsers/level10-parser.terms.ts
  var ask9 = 1;
  var at7 = 2;
  var random7 = 3;
  var ifs5 = 4;
  var pressed5 = 5;
  var elses5 = 6;
  var print9 = 7;
  var forward9 = 8;
  var turn9 = 9;
  var color9 = 10;
  var sleep8 = 11;
  var play9 = 12;
  var is8 = 13;
  var add8 = 14;
  var from7 = 15;
  var remove8 = 16;
  var toList7 = 17;
  var clear6 = 18;
  var ins5 = 19;
  var not_in5 = 20;
  var repeat3 = 21;
  var times3 = 22;
  var fors = 23;

  // static/js/lezer-parsers/level11-parser.terms.ts
  var ask10 = 1;
  var at8 = 2;
  var random8 = 3;
  var ifs6 = 4;
  var pressed6 = 5;
  var elses6 = 6;
  var print10 = 7;
  var forward10 = 8;
  var turn10 = 9;
  var color10 = 10;
  var sleep9 = 11;
  var play10 = 12;
  var is9 = 13;
  var add9 = 14;
  var from8 = 15;
  var remove9 = 16;
  var toList8 = 17;
  var clear7 = 18;
  var ins6 = 19;
  var not_in6 = 20;
  var repeat4 = 21;
  var times4 = 22;
  var fors2 = 23;
  var to = 24;
  var range2 = 25;

  // static/js/lezer-parsers/level12-parser.terms.ts
  var ask11 = 1;
  var at9 = 2;
  var random9 = 3;
  var ifs7 = 4;
  var pressed7 = 5;
  var elses7 = 6;
  var call = 7;
  var _with = 8;
  var print11 = 9;
  var forward11 = 10;
  var turn11 = 11;
  var color11 = 12;
  var sleep10 = 13;
  var play11 = 14;
  var is10 = 15;
  var add10 = 16;
  var from9 = 17;
  var remove10 = 18;
  var toList9 = 19;
  var clear8 = 20;
  var ins7 = 21;
  var not_in7 = 22;
  var repeat5 = 23;
  var times5 = 24;
  var fors3 = 25;
  var to2 = 26;
  var range3 = 27;
  var define2 = 28;
  var returns = 29;

  // static/js/lezer-parsers/level13-parser.terms.ts
  var ask12 = 1;
  var at10 = 2;
  var random10 = 3;
  var ifs8 = 4;
  var pressed8 = 5;
  var elses8 = 6;
  var and = 7;
  var or = 8;
  var call2 = 9;
  var _with2 = 10;
  var print12 = 11;
  var forward12 = 12;
  var turn12 = 13;
  var color12 = 14;
  var sleep11 = 15;
  var play12 = 16;
  var is11 = 17;
  var add11 = 18;
  var from10 = 19;
  var remove11 = 20;
  var toList10 = 21;
  var clear9 = 22;
  var ins8 = 23;
  var not_in8 = 24;
  var repeat6 = 25;
  var times6 = 26;
  var fors4 = 27;
  var to3 = 28;
  var range4 = 29;
  var define3 = 30;
  var returns2 = 31;

  // static/js/lezer-parsers/level14-parser.terms.ts
  var ask13 = 1;
  var at11 = 2;
  var random11 = 3;
  var ifs9 = 4;
  var pressed9 = 5;
  var elses9 = 6;
  var and2 = 7;
  var or2 = 8;
  var is12 = 9;
  var define4 = 10;
  var _with3 = 11;
  var print13 = 12;
  var forward13 = 13;
  var turn13 = 14;
  var color13 = 15;
  var sleep12 = 16;
  var play13 = 17;
  var add12 = 18;
  var from11 = 19;
  var remove12 = 20;
  var toList11 = 21;
  var clear10 = 22;
  var ins9 = 23;
  var not_in9 = 24;
  var repeat7 = 25;
  var times7 = 26;
  var fors5 = 27;
  var to4 = 28;
  var range5 = 29;
  var call3 = 30;
  var returns3 = 31;

  // static/js/lezer-parsers/level15-parser.terms.ts
  var ask14 = 1;
  var at12 = 2;
  var random12 = 3;
  var ifs10 = 4;
  var pressed10 = 5;
  var elses10 = 6;
  var and3 = 7;
  var or3 = 8;
  var is13 = 9;
  var _while = 10;
  var define5 = 11;
  var _with4 = 12;
  var print14 = 13;
  var forward14 = 14;
  var turn14 = 15;
  var color14 = 16;
  var sleep13 = 17;
  var play14 = 18;
  var add13 = 19;
  var from12 = 20;
  var remove13 = 21;
  var toList12 = 22;
  var clear11 = 23;
  var ins10 = 24;
  var not_in10 = 25;
  var repeat8 = 26;
  var times8 = 27;
  var fors6 = 28;
  var to5 = 29;
  var range6 = 30;
  var call4 = 31;
  var returns4 = 32;

  // static/js/lezer-parsers/level16-parser.terms.ts
  var ask15 = 1;
  var random13 = 2;
  var ifs11 = 3;
  var pressed11 = 4;
  var elses11 = 5;
  var and4 = 6;
  var or4 = 7;
  var is14 = 8;
  var _while2 = 9;
  var define6 = 10;
  var _with5 = 11;
  var print15 = 12;
  var forward15 = 13;
  var turn15 = 14;
  var color15 = 15;
  var sleep14 = 16;
  var play15 = 17;
  var add14 = 18;
  var from13 = 19;
  var remove14 = 20;
  var toList13 = 21;
  var clear12 = 22;
  var ins11 = 23;
  var not_in11 = 24;
  var repeat9 = 25;
  var times9 = 26;
  var fors7 = 27;
  var to6 = 28;
  var range7 = 29;
  var call5 = 30;
  var returns5 = 31;

  // static/js/lezer-parsers/level17-parser.terms.ts
  var ask16 = 1;
  var random14 = 2;
  var ifs12 = 3;
  var pressed12 = 4;
  var elses12 = 5;
  var and5 = 6;
  var or5 = 7;
  var is15 = 8;
  var _while3 = 9;
  var elif = 10;
  var define7 = 11;
  var _with6 = 12;
  var print16 = 13;
  var forward16 = 14;
  var turn16 = 15;
  var color16 = 16;
  var sleep15 = 17;
  var play16 = 18;
  var add15 = 19;
  var from14 = 20;
  var remove15 = 21;
  var toList14 = 22;
  var clear13 = 23;
  var ins12 = 24;
  var not_in12 = 25;
  var repeat10 = 26;
  var times10 = 27;
  var fors8 = 28;
  var to7 = 29;
  var range8 = 30;
  var call6 = 31;
  var returns6 = 32;

  // static/js/lezer-parsers/level18-parser.terms.ts
  var print17 = 1;
  var is16 = 2;
  var input = 3;
  var sleep16 = 4;
  var play17 = 5;
  var random15 = 6;
  var forward17 = 7;
  var turn17 = 8;
  var color17 = 9;
  var add16 = 10;
  var remove16 = 11;
  var from15 = 12;
  var clear14 = 13;
  var ifs13 = 14;
  var elses13 = 15;
  var and6 = 16;
  var or6 = 17;
  var pressed13 = 18;
  var notIn = 19;
  var ins13 = 20;
  var repeat11 = 21;
  var times11 = 22;
  var range9 = 23;
  var whiles = 24;
  var def = 25;
  var returns7 = 26;
  var fors9 = 27;
  var toList15 = 28;
  var elif2 = 29;

  // static/js/lezer-parsers/tokens.ts
  var TRADUCTION;
  var level2;
  var keywordToToken = {
    1: {
      extend: {
        "ask": ask,
        "print": print,
        "play": play,
        "echo": echo,
        "forward": forward,
        "turn": turn,
        "color": color
      },
      specialize: {}
    },
    2: {
      extend: {
        "print": print2,
        "forward": forward2,
        "turn": turn2,
        "color": color2,
        "play": play2,
        "sleep": sleep,
        "is": is
      },
      specialize: {
        "ask": ask2
      }
    },
    3: {
      extend: {
        "print": print3,
        "forward": forward3,
        "turn": turn3,
        "color": color3,
        "play": play3,
        "sleep": sleep2,
        "is": is2,
        "add": add2,
        "remove": remove2,
        "from": from,
        "to_list": toList
      },
      specialize: {
        "ask": ask3,
        "at": at,
        "random": random
      }
    },
    4: {
      extend: {
        "print": print4,
        "forward": forward4,
        "turn": turn4,
        "color": color4,
        "play": play4,
        "sleep": sleep3,
        "is": is3,
        "add": add3,
        "remove": remove3,
        "from": from2,
        "to_list": toList2,
        "clear": clear
      },
      specialize: {
        "ask": ask4,
        "at": at2,
        "random": random2
      }
    },
    5: {
      extend: {
        "print": print5,
        "forward": forward5,
        "turn": turn5,
        "color": color5,
        "play": play5,
        "sleep": sleep4,
        "is": is4,
        "add": add4,
        "remove": remove4,
        "from": from3,
        "to_list": toList3,
        "clear": clear2,
        "not_in": not_in,
        "in": ins
      },
      specialize: {
        "if": ifs,
        "pressed": pressed,
        "ask": ask5,
        "at": at3,
        "random": random3,
        "else": elses
      }
    },
    6: {
      extend: {
        "print": print6,
        "forward": forward6,
        "turn": turn6,
        "color": color6,
        "play": play6,
        "sleep": sleep5,
        "is": is5,
        "add": add5,
        "remove": remove5,
        "from": from4,
        "to_list": toList4,
        "clear": clear3,
        "not_in": not_in2,
        "in": ins2
      },
      specialize: {
        "if": ifs2,
        "pressed": pressed2,
        "ask": ask6,
        "at": at4,
        "random": random4,
        "else": elses2
      }
    },
    7: {
      extend: {
        "print": print7,
        "forward": forward7,
        "turn": turn7,
        "color": color7,
        "play": play7,
        "sleep": sleep6,
        "is": is6,
        "add": add6,
        "remove": remove6,
        "from": from5,
        "to_list": toList5,
        "clear": clear4,
        "not_in": not_in3,
        "in": ins3,
        "repeat": repeat,
        "times": times
      },
      specialize: {
        "if": ifs3,
        "pressed": pressed3,
        "ask": ask7,
        "at": at5,
        "random": random5,
        "else": elses3
      }
    },
    8: {
      extend: {
        "print": print8,
        "forward": forward8,
        "turn": turn8,
        "color": color8,
        "play": play8,
        "sleep": sleep7,
        "is": is7,
        "add": add7,
        "remove": remove7,
        "from": from6,
        "to_list": toList6,
        "clear": clear5,
        "not_in": not_in4,
        "in": ins4,
        "repeat": repeat2,
        "times": times2
      },
      specialize: {
        "if": ifs4,
        "pressed": pressed4,
        "ask": ask8,
        "at": at6,
        "random": random6,
        "else": elses4
      }
    },
    9: {
      extend: {
        "print": print8,
        "forward": forward8,
        "turn": turn8,
        "color": color8,
        "play": play8,
        "sleep": sleep7,
        "is": is7,
        "add": add7,
        "remove": remove7,
        "from": from6,
        "to_list": toList6,
        "clear": clear5,
        "not_in": not_in4,
        "in": ins4,
        "repeat": repeat2,
        "times": times2
      },
      specialize: {
        "if": ifs4,
        "pressed": pressed4,
        "ask": ask8,
        "at": at6,
        "random": random6,
        "else": elses4
      }
    },
    10: {
      extend: {
        "print": print9,
        "forward": forward9,
        "turn": turn9,
        "color": color9,
        "play": play9,
        "sleep": sleep8,
        "is": is8,
        "add": add8,
        "remove": remove8,
        "from": from7,
        "to_list": toList7,
        "clear": clear6,
        "not_in": not_in5,
        "in": ins5,
        "repeat": repeat3,
        "times": times3,
        "for": fors
      },
      specialize: {
        "if": ifs5,
        "pressed": pressed5,
        "ask": ask9,
        "at": at7,
        "random": random7,
        "else": elses5
      }
    },
    11: {
      extend: {
        "print": print10,
        "forward": forward10,
        "turn": turn10,
        "color": color10,
        "play": play10,
        "sleep": sleep9,
        "is": is9,
        "add": add9,
        "remove": remove9,
        "from": from8,
        "to_list": toList8,
        "clear": clear7,
        "not_in": not_in6,
        "in": ins6,
        "repeat": repeat4,
        "times": times4,
        "for": fors2,
        "to": to,
        "range": range2
      },
      specialize: {
        "if": ifs6,
        "pressed": pressed6,
        "ask": ask10,
        "at": at8,
        "random": random8,
        "else": elses6
      }
    },
    12: {
      extend: {
        "print": print11,
        "forward": forward11,
        "turn": turn11,
        "color": color11,
        "play": play11,
        "sleep": sleep10,
        "is": is10,
        "add": add10,
        "remove": remove10,
        "from": from9,
        "to_list": toList9,
        "clear": clear8,
        "not_in": not_in7,
        "in": ins7,
        "repeat": repeat5,
        "times": times5,
        "for": fors3,
        "to": to2,
        "range": range3,
        "return": returns,
        "define": define2
      },
      specialize: {
        "if": ifs7,
        "pressed": pressed7,
        "ask": ask11,
        "at": at9,
        "random": random9,
        "else": elses7,
        "call": call,
        "with": _with
      }
    },
    13: {
      extend: {
        "print": print12,
        "forward": forward12,
        "turn": turn12,
        "color": color12,
        "play": play12,
        "sleep": sleep11,
        "is": is11,
        "add": add11,
        "remove": remove11,
        "from": from10,
        "to_list": toList10,
        "clear": clear9,
        "not_in": not_in8,
        "in": ins8,
        "repeat": repeat6,
        "times": times6,
        "for": fors4,
        "to": to3,
        "range": range4,
        "return": returns2,
        "define": define3
      },
      specialize: {
        "if": ifs8,
        "pressed": pressed8,
        "ask": ask12,
        "at": at10,
        "random": random10,
        "else": elses8,
        "and": and,
        "or": or,
        "call": call2,
        "with": _with2
      }
    },
    14: {
      extend: {
        "print": print13,
        "forward": forward13,
        "turn": turn13,
        "color": color13,
        "play": play13,
        "sleep": sleep12,
        "add": add12,
        "remove": remove12,
        "from": from11,
        "to_list": toList11,
        "clear": clear10,
        "not_in": not_in9,
        "repeat": repeat7,
        "times": times7,
        "for": fors5,
        "to": to4,
        "range": range5,
        "return": returns3,
        "define": define4
      },
      specialize: {
        "if": ifs9,
        "pressed": pressed9,
        "ask": ask13,
        "at": at11,
        "random": random11,
        "else": elses9,
        "and": and2,
        "or": or2,
        "in": ins9,
        "is": is12,
        "call": call3,
        "with": _with3
      }
    },
    15: {
      extend: {
        "print": print14,
        "forward": forward14,
        "turn": turn14,
        "color": color14,
        "play": play14,
        "sleep": sleep13,
        "is": is13,
        "add": add13,
        "remove": remove13,
        "from": from12,
        "to_list": toList12,
        "clear": clear11,
        "not_in": not_in10,
        "repeat": repeat8,
        "times": times8,
        "for": fors6,
        "to": to5,
        "range": range6,
        "return": returns4,
        "define": define5
      },
      specialize: {
        "if": ifs10,
        "pressed": pressed10,
        "ask": ask14,
        "at": at12,
        "random": random12,
        "else": elses10,
        "and": and3,
        "or": or3,
        "in": ins10,
        "is": is13,
        "while": _while,
        "call": call4,
        "with": _with4
      }
    },
    16: {
      extend: {
        "print": print15,
        "forward": forward15,
        "turn": turn15,
        "color": color15,
        "play": play15,
        "sleep": sleep14,
        "is": is14,
        "add": add14,
        "remove": remove14,
        "from": from13,
        "to_list": toList13,
        "clear": clear12,
        "not_in": not_in11,
        "repeat": repeat9,
        "times": times9,
        "for": fors7,
        "to": to6,
        "range": range7,
        "return": returns5,
        "define": define6
      },
      specialize: {
        "if": ifs11,
        "pressed": pressed11,
        "ask": ask15,
        "random": random13,
        "else": elses11,
        "and": and4,
        "or": or4,
        "in": ins11,
        "is": is14,
        "while": _while2,
        "call": call5,
        "with": _with5
      }
    },
    17: {
      extend: {
        "print": print16,
        "forward": forward16,
        "turn": turn16,
        "color": color16,
        "play": play16,
        "sleep": sleep15,
        "is": is15,
        "add": add15,
        "remove": remove15,
        "from": from14,
        "to_list": toList14,
        "clear": clear13,
        "not_in": not_in12,
        "repeat": repeat10,
        "times": times10,
        "for": fors8,
        "to": to7,
        "range": range8,
        "return": returns6,
        "define": define7
      },
      specialize: {
        "if": ifs12,
        "pressed": pressed12,
        "ask": ask16,
        "random": random14,
        "else": elses12,
        "and": and5,
        "or": or5,
        "in": ins12,
        "is": is15,
        "while": _while3,
        "elif": elif,
        "call": call6,
        "with": _with6
      }
    },
    18: {
      specialize: {
        "add": add16,
        "and": and6,
        "clear": clear14,
        "color": color17,
        "def": def,
        "print": print17,
        "is": is16,
        "input": input,
        "play": play17,
        "sleep": sleep16,
        "random": random15,
        "forward": forward17,
        "turn": turn17,
        "to_list": toList15,
        "remove": remove16,
        "from": from15,
        "if": ifs13,
        "else": elses13,
        "or": or6,
        "pressed": pressed13,
        "not_in": notIn,
        "in": ins13,
        "repeat": repeat11,
        "times": times11,
        "range": range9,
        "while": whiles,
        "return": returns7,
        "for": fors9,
        "elif": elif2
      },
      extend: {}
    }
  };
  var specializeTranslations;
  var extendTranslations;
  function initializeTranslation(options) {
    const TRADUCTIONS = convert2(highlighting_trad_default);
    level2 = options.level;
    let lang = options.keywordLanguage;
    if (!TRADUCTIONS.has(lang)) {
      lang = "en";
    }
    TRADUCTION = TRADUCTIONS.get(lang);
    specializeTranslations = new Map();
    extendTranslations = new Map();
    for (const [key, value] of TRADUCTION) {
      if (key in keywordToToken[level2].specialize) {
        specializeTranslations.set(key, value);
      } else if (key in keywordToToken[level2].extend) {
        extendTranslations.set(key, value);
      }
    }
  }
  function specializeKeyword(name2, stack) {
    for (const [key, value] of specializeTranslations) {
      const regexString = value.replace(" ", "|");
      if (new RegExp(`^(${regexString})$`, "gu").test(name2)) {
        if (stack.canShift(keywordToToken[level2].specialize[key])) {
          return keywordToToken[level2].specialize[key];
        }
      }
    }
    return -1;
  }
  function extendKeyword(name2, stack) {
    for (const [key, value] of extendTranslations) {
      const regexString = value.replace(" ", "|");
      if (new RegExp(`^(${regexString})$`, "gu").test(name2)) {
        if (stack.canShift(keywordToToken[level2].extend[key])) {
          return keywordToToken[level2].extend[key];
        }
      }
    }
    return -1;
  }
  function convert2(o) {
    if (typeof o === "object") {
      let tmp = new Map(Object.entries(o));
      let ret = new Map();
      tmp.forEach((value, key) => {
        ret.set(key, convert2(value));
      });
      return ret;
    } else {
      return o;
    }
  }

  // static/js/lezer-parsers/level1-parser.ts
  var parser = LRParser.deserialize({
    version: 14,
    states: "&`QYQPOOOOQO'#Cq'#CqQYQPOOOOQO'#Cs'#CsOwQPO'#CgOOQO'#Ct'#CtO!PQPO'#CpOOQO'#Cu'#CuO![QPO'#CiOOQO'#Cv'#CvO!dQPO'#CjOOQO'#Cw'#CwO!rQPO'#CkOOQO'#Cx'#CxO!zQPO'#CmOOQO'#Cy'#CyO#SQPO'#CnOOQO'#Cz'#CzO#[QPO'#CoOOQO'#Cl'#ClOOQO'#Cf'#CfQrQPO'#CrQ#dQPOOOOQO-E6o-E6oOOQO-E6q-E6qO$OQPO,59ROOQO-E6r-E6rO$ZQPO,59TOOQO-E6s-E6sO$fQPO,59UOOQO-E6t-E6tO$qQPO,59VOOQO-E6u-E6uOOQO-E6v-E6vOOQO,59X,59XOOQO-E6w-E6wOOQO,59Y,59YOOQO-E6x-E6xOOQO,59Z,59ZO$|QPO,59^OOQO-E6p-E6p",
    stateData: "%n~OWOSqOS~OPROQ]OR_OSXOTZOUVOVaO[TOrPO~OPRO[TO~O[TOodXrdX~OUVO[TO~OSXO[TOo^Xr^X~OTZO[TO~OQ]O[rO~OR_O[tO~OVaO[vO~OPROQ]OR_OSXOTZOUVOVaO[TO~O[TOoZarZa~O[TOo]ar]a~O[TOo^ar^a~O[TOo_ar_a~OrPOPfaQfaRfaSfaTfaUfaVfa[faofa~O",
    goto: "$UoPPPPPPPPPPpuPuuuuzzzu!P!Z!b!j#S#[#d#l#t#|VeOQfVdOQfVcOQfQQOSgQwRweSfOQRxfUSOQfRhSUUOQfQiSYjUikmoQkWQmYRo[UWOQfRlWUYOQfRnYU[OQfRp[U^OQfRq^U`OQfRs`UbOQfRub",
    nodeNames: "\u26A0 print forward turn echo play ask color Comment Program Command Print Text Ask Echo Play Turtle Forward Turn Color ErrorInvalid",
    maxTerm: 34,
    nodeProps: [
      ["group", 16, "turtle"]
    ],
    skippedNodes: [0, 8],
    repeatNodeCount: 10,
    tokenData: "#O~RXOYnYZ!]Zpnpq!bqsnst!gt;'Sn;'S;=`!V<%lOn~sU[~OYnZpnqsnt;'Sn;'S;=`!V<%lOn~!YP;=`<%ln~!bOr~~!gOq~~!lSW~OY!gZ;'S!g;'S;=`!x<%lO!g~!{P;=`<%l!g",
    tokenizers: [0],
    topRules: { "Program": [0, 9] },
    dynamicPrecedences: { "20": -10 },
    specialized: [{ term: 12, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 0
  });

  // static/js/lezer-parsers/level2-parser.ts
  var parser2 = LRParser.deserialize({
    version: 14,
    states: "'OQYQPOOOOQO'#Cs'#CsQYQPOOOtQPO'#CvO!SQPO'#CrOOQO'#Cx'#CxO!_QPO'#CkOOQO'#Cy'#CyO!gQPO'#ClOOQO'#Cz'#CzO!oQPO'#CnOOQO'#C{'#C{O!wQPO'#CoOOQO'#C|'#C|O#PQPO'#CpOOQO'#Cm'#CmOOQO'#C}'#C}O#XQPO'#CqOOQO'#Cg'#CgQoQPO'#CtQ#gQPOOOOQO-E6q-E6qOOQO'#Cu'#CuO$OQPO,59SOOQO'#Cv'#CvOOQO-E6t-E6tO$ZQPO,59VOOQO-E6v-E6vO$fQPO,59WOOQO-E6w-E6wOOQO-E6x-E6xOOQO,59Y,59YOOQO-E6y-E6yOOQO,59Z,59ZOOQO-E6z-E6zOOQO,59[,59[O$qQPO,59]OOQO-E6{-E6{O$|QPO,59`OOQO-E6r-E6rOOQO-E6s-E6sO%kQPO1G.nOOQO'#Cw'#CwO%vQPO1G.pO&OQPO7+$[OOQO-E6u-E6u",
    stateData: "&Z~OXOStOS~OQTORXOSZOT]OU`OVVO]ROuPO~OWfO]jXrjXujX~O]hOrfXufX~OQTO]hO~OVVO]hO~ORXO]oO~OSZO]qO~OT]O]sO~OU`O]hOreXueX~OQTORXOSZOT]OU`OVVO]RO~OPzOWfO]hO~O]hOr_au_a~O]hOr`au`a~O]hOreauea~OuPOQhaRhaShaThaUhaVha]harha~O]hOr[iu[i~OPzO]hO~O]hOr^qu^q~O",
    goto: "$arPPPPPPPPPPPsxPxxxx}}}xx!S!^!e!k#X#_#g#o#w$P$XVcOQdVbOQdV_OQdQQOSeQvRvcSdOQRwdQgRRxgUSOQd[iSjlty|QjUQlWQtaQygR|{Q{gR}{UUOQdRkUUWOQdRmWUYOQdRnYU[OQdRp[U^OQdRr^UaOQdRua",
    nodeNames: "\u26A0 ask print forward turn color sleep play is Comment Program Command Assign Text Ask Print Play Turtle Forward Turn Color Sleep ErrorInvalid",
    maxTerm: 37,
    nodeProps: [
      ["group", 17, "turtle"]
    ],
    skippedNodes: [0, 9],
    repeatNodeCount: 11,
    tokenData: "#O~RXOYnYZ!]Zpnpq!bqsnst!gt;'Sn;'S;=`!V<%lOn~sU]~OYnZpnqsnt;'Sn;'S;=`!V<%lOn~!YP;=`<%ln~!bOu~~!gOt~~!lSX~OY!gZ;'S!g;'S;=`!x<%lO!g~!{P;=`<%l!g",
    tokenizers: [0],
    topRules: { "Program": [0, 10] },
    dynamicPrecedences: { "22": -10 },
    specialized: [{ term: 13, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }, { term: 13, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 0
  });

  // static/js/lezer-parsers/level3-parser.ts
  var parser3 = LRParser.deserialize({
    version: 14,
    states: "+pQYQPOOOOQO'#DO'#DOQYQPOOOzQPO'#DRO!YQPO'#C}OOQO'#DW'#DWO!eQPO'#CtOOQO'#DY'#DYO!mQPO'#CuOOQO'#DZ'#DZO!uQPO'#CwOOQO'#D['#D[O!}QPO'#CxOOQO'#D]'#D]O#VQPO'#CyOOQO'#Cv'#CvOOQO'#D^'#D^O#_QPO'#CzOOQO'#D_'#D_O#mQPO'#C{OOQO'#Da'#DaO#uQPO'#C|OOQO'#Cm'#CmQuQPO'#DPQ#}QPOOOOQO-E6|-E6|OOQO'#DQ'#DQO$lQPO,59YOOQO'#DR'#DROOQO-E7P-E7PO$wQPO'#DXOOQO-E7U-E7UOOQO'#DX'#DXO%VQPO,59`O%bQPO,59aOOQO-E7W-E7WO%mQPO,59cOOQO-E7X-E7XOOQO,59c,59cO%xQPO,59dOOQO-E7Y-E7YOOQO,59d,59dO&TQPO,59eOOQO-E7Z-E7ZOOQO,59e,59eO&`QPO,59fOOQO-E7[-E7[OOQO,59f,59fOOQO-E7]-E7]O&kQPO,59gOOQO-E7_-E7_O&pQPO,59hO&uQPO,59kOOQO-E6}-E6}OOQO-E7O-E7OO'jQPO'#DRO'{QPO1G.tOOQO1G.t1G.tOOQO'#DV'#DVO(ZQPO1G.yOOQO'#DS'#DSO(cQPO,59[OOQO-E7V-E7VOOQO'#D`'#D`O(nQPO1G/ROOQO'#Db'#DbO(vQPO1G/SO!pQPO'#DUO)OQPO7+$cO)ZQPO7+$eOOQO-E7T-E7TOOQO-E7Q-E7QOOQO'#DT'#DTO)fQPO1G.vOOQO1G.v1G.vOOQO-E7^-E7^OOQO7+$m7+$mOOQO-E7`-E7`OOQO7+$n7+$nO)tQPO,59pOOQO-E7S-E7SOOQO-E7R-E7R",
    stateData: "*S~O_OS!XOS~OSTOTXOUZOV]OW`OXVOZbO]dOcRO!YPO~OYjOcuX!VuX!YuX~OclO!VqX!YqX~OSTOcnO~OXVOclO~OTXOctO~OUZOcwO~OV]OczO~OW`Oc}O!VnX!YnX~OZbOc!RO~O]dOc!TO~OSTOTXOUZOV]OW`OXVOZbO]dOcRO~OP![OYjOc!XO~OQ!^Oc{X!V{X!Y{X~OcnO!Vha!Yha~OclO!Via!Yia~OQ!^O!Vka!Yka~OQ!^O!Vla!Yla~OQ!^O!Vma!Yma~OQ!^O!Vna!Yna~O^!aO~O[!cO~O!YPOSsaTsaUsaVsaWsaXsaZsa]sacsa!Vsa~OQ!^OcuXfuX!VuX!YuX~OclOf!eO!Vbi!Ybi~OP![OclO~OQ!^OR!jOc!lO~O^!aOc!nO~O[!cOc!pO~Of!eO!Veq!Yeq~OclO!Vgq!Ygq~OR!jOcdi!Vdi!Ydi~OclOfxa!Vxa!Yxa~O",
    goto: "&`!VPPPPPPPPPPPPPPPPP!W!]P!b!]P!]!]!]!]!u!u!u!]!]!]!]!z#U#]#c#{$W$^$d$j$r$x%Q%Y%b%j%r%z&Q&YVgOQhVfOQhSpUqQvYQy[Q|^Q!PaR!ZkV_OQhQQOSiQ!UR!UgShOQR!VhQkRR!WkUSOQhYmSr!Y!g!qQrWQ!YkQ!g!]R!q!e[!_ntwz}!XR!i!_Q!k!_R!s!kQ!f!YR!r!fQ!]kR!h!]UUOQhRoUQqUR!`qUWOQhRsWUYOQhRuYU[OQhRx[U^OQhR{^UaOQhR!OaUcOQhR!QcQ!b!RR!m!bUeOQhR!SeQ!d!TR!o!d",
    nodeNames: "\u26A0 ask at random print forward turn color sleep play is add from remove toList Comment Program Command Assign Text ListAccess AssignList Comma Ask Print Play Turtle Forward Turn Color Sleep Add Remove ErrorInvalid",
    maxTerm: 56,
    nodeProps: [
      ["group", 26, "turtle"]
    ],
    skippedNodes: [0, 15],
    repeatNodeCount: 19,
    tokenData: "$P~RbOY!ZYZ#XZp!Zpq#^qs!Zst#ct|!Z|}#z}#Q!Z#RBn!ZBnBo#zBo&FV!Z&FV&FW#z&FW;'S!Z;'S;=`#R<%l?Hb!Z?Hb?Hc#z?HcO!Z~!`Zc~OY!ZZp!Zqs!Zt|!Z}#Q!Z#RBn!ZBo&FV!Z&FW;'S!Z;'S;=`#R<%l?Hb!Z?HcO!Z~#UP;=`<%l!Z~#^O!Y~~#cO!X~~#hS_~OY#cZ;'S#c;'S;=`#t<%lO#c~#wP;=`<%l#c~$POf~",
    tokenizers: [0],
    topRules: { "Program": [0, 16] },
    dynamicPrecedences: { "33": -10 },
    specialized: [{ term: 19, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }, { term: 19, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 0
  });

  // static/js/lezer-parsers/level4-parser.ts
  var parser4 = LRParser.deserialize({
    version: 14,
    states: "-tQYQPOOOOQO'#DR'#DRQYQPOOO}QPO'#DUO!]QPO'#DQOOQO'#D^'#D^O!hQPO'#CvOOQO'#D_'#D_O!sQPO'#CwOOQO'#D`'#D`O#RQPO'#CxOOQO'#Da'#DaO#ZQPO'#CzOOQO'#Db'#DbO#cQPO'#C{OOQO'#Dc'#DcO#kQPO'#C|OOQO'#Cy'#CyOOQO'#Dd'#DdO#sQPO'#C}OOQO'#De'#DeO$RQPO'#DOOOQO'#Dg'#DgO$ZQPO'#DPOOQO'#Cn'#CnQxQPO'#DSQ$cQPOOOOQO-E7P-E7POOQO'#DT'#DTO%TQPO,59ZOOQO'#DU'#DUOOQO-E7S-E7SOOQO-E7[-E7[O%`QPO'#DZO%tOSO'#DmO%|OQO'#DqOOQO'#Cu'#CuOOQO'#DZ'#DZO&UQPO,59cOOQO-E7]-E7]O&gQPO,59dOOQO-E7^-E7^O&rQPO,59fOOQO-E7_-E7_OOQO,59f,59fO&}QPO,59gOOQO-E7`-E7`OOQO,59g,59gO'YQPO,59hOOQO-E7a-E7aOOQO,59h,59hO'eQPO,59iOOQO-E7b-E7bOOQO,59i,59iOOQO-E7c-E7cO'pQPO,59jOOQO-E7e-E7eO'uQPO,59kO'zQPO,59nOOQO-E7Q-E7QOOQO-E7R-E7RO(rQPO'#DUO)TQPO1G.uOOQO1G.u1G.uOOQO'#DY'#DYO)cQPO1G.zOOQO'#DV'#DVO)qQPO,59]OOOO'#D['#D[O)|OSO,5:XOOQO,5:X,5:XOOOO'#D]'#D]O*UOQO,5:]OOQO,5:],5:]OOQO-E7X-E7XOOQO'#Df'#DfO*^QPO1G/UOOQO'#Dh'#DhO*fQPO1G/VO#UQPO'#DXO*nQPO7+$dOOQO-E7W-E7WO*yQPO7+$fOOQO-E7T-E7TOOQO'#DW'#DWO+[QPO1G.wOOQO1G.w1G.wOOOO-E7Y-E7YOOQO1G/s1G/sOOOO-E7Z-E7ZOOQO1G/w1G/wOOQO-E7d-E7dOOQO7+$p7+$pOOQO-E7f-E7fOOQO7+$q7+$qO+pQPO,59sOOQO-E7V-E7VOOQO-E7U-E7U",
    stateData: ",O~O`OS!_OS~OSVOTZOU]OV_OWbOXXOZdO]fO_TOdRO!`PO~OYlOdxX!]xX!`xX~OdnO!]tX!`tX~O_TO!]jX!`jX~OSVOdqO!brO!fsO~OXXOdnO~OTZOdzO~OU]Od}O~OV_Od!QO~OWbOd!TO!]qX!`qX~OZdOd!XO~O]fOd!ZO~OSVOTZOU]OV_OWbOXXOZdO]fO_TOdRO~OP!bOYlOd!_O~OQ!dOd}X!]}X!`}X!b}X!f}X~O!c!fO!d!hO~O!g!iO!h!kO~OdqO!brO!fsO!]ka!`ka~OdnO!]la!`la~OQ!dO!]na!`na~OQ!dO!]oa!`oa~OQ!dO!]pa!`pa~OQ!dO!]qa!`qa~O^!mO~O[!oO~O!`POSvaTvaUvaVvaWvaXvaZva]va_vadva!]va~OQ!dOdxXgxX!]xX!`xX~OdnOg!qO!]ci!`ci~OP!bOdqO!brO!fsO~OQ!dOR!vOd!xO~O!c!fO!d!zO~O!g!iO!h!|O~O^!mOd#OO~O[!oOd#QO~Og!qO!]fq!`fq~OdqO!brO!fsO!]hq!`hq~OR!vOdei!]ei!`ei!bei!fei~OdnOg{a!]{a!`{a~O",
    goto: "'c!fPPPPPPPPPPPPPPPPPP!g!lP!q!lP!l#W!l!l!l!l#^#^#^!l!l!l!l#c#m#t#z$`$k$q$w$}%X%_%e%m%u%}&V&_&g&o&w&}'VPPPP']PPP']ViOQjVhOQjWuWv!c!tQ|[Q!P^Q!S`Q!VcR!amXuWv!c!tVaOQjQQOSkQ![R![iSjOQR!]jQmRR!^mUSOQjWoSx!`#RQxYQ!`mR#R!q[!eqz}!Q!T!_R!u!eQ!w!eR#T!wQ!r!`R#S!rQ!cmR!s!cQvWS!lv!tR!t!cQ!grR!y!gQ!jsR!{!jUUOQjRpUUWOQjRwWUYOQjRyYU[OQjR{[U^OQjR!O^U`OQjR!R`UcOQjR!UcUeOQjR!WeQ!n!XR!}!nUgOQjR!YgQ!p!ZR#P!pXtWv!c!t",
    nodeNames: "\u26A0 ask at random print forward turn color sleep play is add from remove toList clear Comment Program Command Assign Text ListAccess AssignList Comma Ask String Clear Print Play Turtle Forward Turn Color Sleep Add Remove ErrorInvalid",
    maxTerm: 70,
    nodeProps: [
      ["group", 29, "turtle"]
    ],
    skippedNodes: [0, 16],
    repeatNodeCount: 22,
    tokenData: "$g~ReOY!dYZ#eZp!dpq#jqr!drs#ost#ttw!dwx$]x|!d|}$b}#Q!d#RBn!dBnBo$bBo&FV!d&FV&FW$b&FW;'S!d;'S;=`#_<%l?Hb!d?Hb?Hc$b?HcO!d~!i[d~OY!dZp!dqr!dtw!dx|!d}#Q!d#RBn!dBo&FV!d&FW;'S!d;'S;=`#_<%l?Hb!d?HcO!d~#bP;=`<%l!d~#jO!`~~#oO!_~~#tO!b~~#yS`~OY#tZ;'S#t;'S;=`$V<%lO#t~$YP;=`<%l#t~$bO!f~~$gOg~",
    tokenizers: [2, new LocalTokenGroup("_~RQYZXwxX~^O!h~~", 14, 69), new LocalTokenGroup("_~RQYZXrsX~^O!d~~", 14, 65)],
    topRules: { "Program": [0, 17] },
    dynamicPrecedences: { "36": -10 },
    specialized: [{ term: 20, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }, { term: 20, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 0
  });

  // static/js/lezer-parsers/level5-parser.ts
  var parser5 = LRParser.deserialize({
    version: 14,
    states: "1vQYQPOOOOQO'#D_'#D_QYQPOOO!TQPO'#DbO!fQPO'#D]OOQO'#Dj'#DjO!tQPO'#C{OOQO'#Dk'#DkO#SQPO'#C|OOQO'#Dl'#DlO#bQPO'#C}OOQO'#Dm'#DmO#jQPO'#DPOOQO'#Dn'#DnO#rQPO'#DQOOQO'#Do'#DoO#zQPO'#DROOQO'#DO'#DOOOQO'#Dp'#DpO$SQPO'#DSOOQO'#Dq'#DqO$eQPO'#DTOOQO'#Ds'#DsO$mQPO'#DUOOQO'#Du'#DuO$uQPO'#DVOOQO'#Dy'#DyO%rQPO'#D^OOQO'#Cs'#CsQ!OQPO'#D`Q%yQPOOOOQO-E7]-E7]OOQO'#Da'#DaO&QQPO,59`OOQO'#Db'#DbOOQO-E7`-E7`OOQO-E7h-E7hO&]QPO'#DgO&tOSO'#EOO&|OQO'#ESOOQO'#Cz'#CzOOQO'#Dg'#DgO'UQPO,59hOOQO-E7i-E7iO'jQPO,59iOOQO-E7j-E7jO'xQPO,59kOOQO-E7k-E7kOOQO,59k,59kO(WQPO,59lOOQO-E7l-E7lOOQO,59l,59lO(fQPO,59mOOQO-E7m-E7mOOQO,59m,59mO(tQPO,59nOOQO-E7n-E7nOOQO,59n,59nOOQO-E7o-E7oO)SQPO,59oOOQO-E7q-E7qO)XQPO,59pOOQO-E7s-E7sO)^QPO'#DXOOQO'#DW'#DWO`QPO,59qO`QPO,59xOOQO'#D['#D[OOQO-E7w-E7wOOQO,59x,59xO)iQPO,59zOOQO-E7^-E7^OOQO-E7_-E7_O*gQPO'#DbO*{QPO1G.zOOQO1G.z1G.zOOQO'#Df'#DfO+^QPO1G/POOQO'#Dc'#DcO+lQPO,59bOOOO'#Dh'#DhO+wOSO,5:jOOQO,5:j,5:jOOOO'#Di'#DiO,POQO,5:nOOQO,5:n,5:nOOQO-E7e-E7eOOQO'#Dr'#DrO,XQPO1G/ZOOQO'#Dt'#DtO,aQPO1G/[O,iQPO,59sOOQO'#Dw'#DwO,zQPO,59tOOQO'#Dx'#DxO-SQPO,59uO`QPO1G/]O-[QPO1G/]OOQO1G/d1G/dO#eQPO'#DeO-gQPO7+$iOOQO-E7d-E7dO-uQPO7+$kOOQO-E7a-E7aOOQO'#Dd'#DdO.ZQPO1G.|OOQO1G.|1G.|OOOO-E7f-E7fOOQO1G0U1G0UOOOO-E7g-E7gOOQO1G0Y1G0YOOQO-E7p-E7pOOQO7+$u7+$uOOQO-E7r-E7rOOQO7+$v7+$vOOQO'#Dv'#DvO.rQPO1G/_OOQO1G/_1G/_OOQO-E7u-E7uOOQO1G/`1G/`OOQO-E7v-E7vOOQO1G/a1G/aO/jQPO7+$wOOQO7+$w7+$wO/uQPO,5:POOQO-E7c-E7cOOQO-E7b-E7bOOQO-E7t-E7tOOQO<<Hc<<Hc",
    stateData: "0W~OeOS!pOS~OShOTjOVVOWZOX]OY_OZbO[XO^dO`fObTOiRO!qPO~O]pOi!UX!n!UX!q!UXT!UX~OirO!n!PX!q!PXT!PX~ObTO!noX!qoXToX~OVVOiuO!svO!wwO~O[XOirO~OWZOi!OO~OX]Oi!RO~OY_Oi!UO~OZbOi!XO!nvX!qvXTvX~O^dOi!]O~O`fOi!_O~OShOi!aO~OTjOVVOWZOX]OY_OZbO[XO^dO`fObTOiRO~O!qPO~P$}OShO~P$}OP!nO]pOi!kO~OQ!pOi!ZX!n!ZX!q!ZX!s!ZX!w!ZXT!ZX~O!t!rO!u!tO~O!x!uO!y!wO~OiuO!svO!wwO!npa!qpaTpa~OirO!nqa!qqaTqa~OQ!pO!nsa!qsaTsa~OQ!pO!nta!qtaTta~OQ!pO!nua!quaTua~OQ!pO!nva!qvaTva~Oa!yO~O_!{O~O]pOc#OOd#QO~O!qPOS!SaT!SaV!SaW!SaX!SaY!SaZ!Sa[!Sa^!Sa`!Sab!Sai!Sa!n!Sa~OQ!pOi!UXl!UX!n!UX!q!UXT!UX~OirOl#VO!nhi!qhiThi~OP!nOiuO!svO!wwO~OQ!pOR#[Oi#^O~O!t!rO!u#`O~O!x!uO!y#bO~Oa!yOi#dO~O_!{Oi#fO~OU#gO]pOi#iO!svO!wwO~Oc#OOi#kO~Od#QOi#mO~OTjO!nyi!qyi~Ol#VO!nkq!qkqTkq~OiuO!svO!wwO!nmq!qmqTmq~OR#[Oiji!nji!qji!sji!wjiTji~OU#gOV{iW{iX{iY{iZ{i[{i^{i`{ib{ii{i!q{i~OTjO!nyq!qyq~OirOl!Xa!n!Xa!q!XaT!Xa~O",
    goto: "*r!wPPPPPPPPPPPPPPPPPPPPPPP!x!}P#Y!}P!}#o!}!}!}!}#x#x#x!}!}!}$R$W$Z$Z$Z$^!}$j$u%X%`%j&S&_&e&k&q&{'R'X'e'q'}(Z(g(s)P)])c)o)u)}*T*Z*aPPPP*kPPP*kVmOQnUlOQnX!ek!c!d#SWyWz!o#YQ!Q[Q!T^Q!W`Q!ZcR!mqWyWz!o#YR#i!}_aOQkn!c!d#SVlOQnR!ciR!biQ!gkQ#T!cQ#U!dR#n#SUlOQnQ#o#TR#t#nQQOWoQ!d!h#SQ!dkQ!hmR#S!cSnOQR!inQqRS!jq!}R!}!a^SOQkn!c!d#SWsS|!l#pQ|YQ!lqR#p#V[!qu!O!R!U!X!kR#Z!qQ#]!qR#r#]Q#W!lR#q#WQ!oqR#X!oQzWS!xz#YR#Y!oQ!svR#_!sQ!vwR#a!v^UOQkn!c!d#SRtU^WOQkn!c!d#SR{W^YOQkn!c!d#SR}Y^[OQkn!c!d#SR!P[^^OQkn!c!d#SR!S^^`OQkn!c!d#SR!V`^cOQkn!c!d#SR!Yc^eOQkn!c!d#SR![eQ!z!]R#c!z^gOQkn!c!d#SR!^gQ!|!_R#e!|UiOQnR!`iQ#h!}R#s#hQ#P!aR#j#PQ#R!aR#l#RYkOQn#T#nR!fkZxWz!o!}#Y",
    nodeNames: "\u26A0 ask at random if else pressed print forward turn color sleep play is add from remove toList clear in not_in Comment Program Command Assign Text ListAccess AssignList Comma Ask String Clear Print Play Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck IfLessCommand ErrorInvalid Else",
    maxTerm: 87,
    nodeProps: [
      ["group", 34, "turtle"]
    ],
    skippedNodes: [0, 21],
    repeatNodeCount: 27,
    tokenData: "$g~ReOY!dYZ#eZp!dpq#jqr!drs#ost#ttw!dwx$]x|!d|}$b}#Q!d#RBn!dBnBo$bBo&FV!d&FV&FW$b&FW;'S!d;'S;=`#_<%l?Hb!d?Hb?Hc$b?HcO!d~!i[i~OY!dZp!dqr!dtw!dx|!d}#Q!d#RBn!dBo&FV!d&FW;'S!d;'S;=`#_<%l?Hb!d?HcO!d~#bP;=`<%l!d~#jO!q~~#oO!p~~#tO!s~~#ySe~OY#tZ;'S#t;'S;=`$V<%lO#t~$YP;=`<%l#t~$bO!w~~$gOl~",
    tokenizers: [2, new LocalTokenGroup("_~RQYZXwxX~^O!y~~", 14, 86), new LocalTokenGroup("_~RQYZXrsX~^O!u~~", 14, 82)],
    topRules: { "Program": [0, 22] },
    dynamicPrecedences: { "47": -10 },
    specialized: [{ term: 25, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }, { term: 25, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 0
  });

  // static/js/lezer-parsers/level6-parser.ts
  var parser6 = LRParser.deserialize({
    version: 14,
    states: "3nQYQPOOOOQO'#Dd'#DdQYQPOOO!TQPO'#DjO!iQPO'#DbOOQO'#Dp'#DpO!wQPO'#DQO#VQPO'#DROOQO'#Dq'#DqO#eQPO'#DSOOQO'#Dr'#DrO#mQPO'#DUOOQO'#Ds'#DsO#xQPO'#DVOOQO'#Dt'#DtO$TQPO'#DWOOQO'#DT'#DTOOQO'#Du'#DuO$`QPO'#DXOOQO'#Dv'#DvO$tQPO'#DYOOQO'#Dx'#DxO$|QPO'#DZOOQO'#Dz'#DzO%UQPO'#D[OOQO'#EO'#EOO&RQPO'#DcOOQO'#Cs'#CsQ!OQPO'#DeQ&YQPOOOOQO-E7b-E7bOOQO'#Df'#DfO&aQPO,59`OOQO'#Cv'#CvO&oQPO,59`OOQO'#Dj'#DjOOQO-E7h-E7hOOQO-E7n-E7nO&zQPO'#DmOOQO'#Cw'#CwO(aQPO'#CwO(kOSO'#EZO(sOQO'#E_OOQO'#DP'#DPOOQO'#Dm'#DmO({QPO,59mO)dQPO,59nOOQO-E7o-E7oO)rQPO,59pOOQO-E7p-E7pOOQO,59p,59pO*ZQPO,59qOOQO-E7q-E7qOOQO,59q,59qO*rQPO,59rOOQO-E7r-E7rOOQO,59r,59rO+ZQPO,59sOOQO-E7s-E7sOOQO,59s,59sOOQO-E7t-E7tO+rQPO,59tOOQO-E7v-E7vO+wQPO,59uOOQO-E7x-E7xO+|QPO'#D^OOQO'#D]'#D]O`QPO,59vO`QPO,59}OOQO'#Da'#DaOOQO-E7|-E7|OOQO,59},59}O,XQPO,5:POOQO-E7c-E7cOOQO-E7d-E7dO-VQPO'#DgO-tQPO1G/SO-{QPO'#CwOOQO'#Dg'#DgO.VQPO1G.zO.hQPO1G/SOOQO'#Dl'#DlO.pQPO1G/UOOQO'#Cy'#CyOOQO'#Cz'#CzO/RQPO,5:pO/RQPO,5:pOOQO'#Dh'#DhO/ZQPO,59gOOOO'#Dn'#DnO/iOSO,5:uOOQO,5:u,5:uOOOO'#Do'#DoO/qOQO,5:yOOQO,5:y,5:yOOQO-E7k-E7kOOQO'#Dw'#DwO/yQPO1G/`OOQO'#Dy'#DyO0RQPO1G/aO0ZQPO,59xOOQO'#D|'#D|O0oQPO,59yOOQO'#D}'#D}O0wQPO,59zO`QPO1G/bO1PQPO1G/bOOQO1G/i1G/iO1[QPO'#DkO1dQPO7+$nOOQO-E7e-E7eOOQO-E7j-E7jO1rQPO7+$pOOQO1G0[1G0[O2ZQPO1G0[OOQO-E7f-E7fOOQO'#Di'#DiO3kQPO1G/ROOQO1G/R1G/ROOOO-E7l-E7lOOQO1G0a1G0aOOOO-E7m-E7mOOQO1G0e1G0eOOQO-E7u-E7uOOQO7+$z7+$zOOQO-E7w-E7wOOQO7+${7+${O4zQPO1G/dOOQO'#D{'#D{O5[QPO1G/dOOQO1G/d1G/dOOQO-E7z-E7zOOQO1G/e1G/eOOQO-E7{-E7{OOQO1G/f1G/fO5cQPO7+$|OOQO7+$|7+$|O5nQPO,5:VOOQO,5:V,5:VOOQO-E7i-E7iOOQO-E7g-E7gOOQO-E7y-E7yOOQO<<Hh<<Hh",
    stateData: "6S~OeOS!uOS~OSgOTiOVVOWYOX[OY^OZaO[WO^cO`eObTOiRO!vPO~O]oO!wqOi!^X!s!^X!v!^XT!^X~OisO!s!UX!v!UXT!UX~ObTO!stX!vtXTtX~OixOlwO#OyO#SzO~O[WOisO~OWYOixOlwO~OX[OixOlwO~OY^OixOlwO~OZaOixOlwO!s{X!v{XT{X~O^cOi!_O~O`eOi!aO~OSgOi!cO~OTiOVVOWYOX[OY^OZaO[WO^cO`eObTOiRO~O!vPO~P%^OSgO~P%^OP!sO]oOi!oOl!nO~OP!sOi!oOl!nO~O!y!uO!z!uO!{!vO!|!vOi!aXl!aX!s!aX!v!aX#O!aX#S!aXT!aX~OQ!yOikXlkX!skX!vkX!ykX!zkX!{kX!|kXTkX~O#OkX#SkX~P'oO#P!{O#Q!}O~O#T#OO#U#QO~OixOlwO#OyO#SzO!sua!vuaTua~OisO!sva!vvaTva~O!y!uO!z!uO!{!vO!|!vO!sxa!vxaTxa~O!y!uO!z!uO!{!vO!|!vO!sya!vyaTya~O!y!uO!z!uO!{!vO!|!vO!sza!vzaTza~O!y!uO!z!uO!{!vO!|!vO!s{a!v{aT{a~Oa#SO~O_#UO~O]oOc#XOd#ZO~O!vPOS!XaT!XaV!XaW!XaX!XaY!XaZ!Xa[!Xa^!Xa`!Xab!Xai!Xa!s!Xa~O!y!uO!z!uO!{!vO!|!vOi!ZXl!ZX!s!ZX!v!ZXT!ZX~Oq#`O~P'rOi!^Xq!^X~P'oOixOlwO!shi!vhiThi~OisOq#`O~OP!sOixOlwO#OyO#SzO~OiwOlwO~OQ!yOR#hOi#jOl#jO~O#P!{O#Q#lO~O#T#OO#U#nO~Oa#SOi#pO~O_#UOi#rO~OU#tO]oOiwOlwO#OyO#SzO~Oc#XOi#xO~Od#ZOi#zO~OTiO!s!Oi!v!Oi~OisOl$OO~Oq#`O!spq!vpqTpq~OixOlwO#OyO#SzO!srq!vrqTrq~O!y!uO!z!uO!{!vO!|!vOi!xil!xi!s!xi!v!xi#O!xi#S!xiV!xiW!xiX!xiY!xiZ!xi[!xi^!xi`!xib!xiT!xi~OR#hOioiloi!soi!voi#Ooi#SoiToi~OV!QiW!QiX!QiY!QiZ!Qi[!Qi^!Qi`!Qib!Qii!Qi!v!Qi~O!y!uO!z!uO!{!vO!|!vO~P4VOU#tO~P4VOTiO!s!Oq!v!Oq~OisOq!_a!s!_a!v!_aT!_a~Oli~",
    goto: ",d#SPPPPPPPPPPPPPPPPPPPPPPP#T#YP#e#hP$Y$d$n#YP#Y%V#Y#Y#Y#Y%`%`%`#Y#Y#Y%i%n%q%q%q%t#Y&Q&]&o&v'Q'X'`'f(P(W(_(i(o(u)R)_)k)w*T*a*m*s+P+V+_+e+k+qPPPPP+{PPPP,]PPP,]VlOQmUkOQmX!gj!e!f#]RrRWvV}!t#dQ!QZQ!T]Q!W_Q!ZbU!mpr!qQ#e!wQ#f!xR#s#Wa!wv!Q!T!W!Z!m#f#sa!xv!Q!T!W!Z!m#f#sW|V}!t#dQ!SZQ!V]Q!Y_Q!]bV!ppr!qW|V}!t#dR#v#W_`OQjm!e!f#]VkOQmR!ehR!dhQ!ijQ#^!eQ#_!fR#{#]UkOQmQ#|#^R$S#{QQOWnQ!f!j#]Q!fjQ!jlR#]!eSmOQR!kmQpRS!lp#WR#W!cS!qprR#b!qS!zx!oR#g!zQ#i!zR$Q#i^SOQjm!e!f#]WtS!O!r#}Q!OXS!rprR#}#`S#a!n!rR$P#aS!tprR#c!tQ}VS#R}#dR#d!tQ!|yR#k!|Q#PzR#m#P^UOQjm!e!f#]RuU^XOQjm!e!f#]R!PX^ZOQjm!e!f#]R!RZ^]OQjm!e!f#]R!U]^_OQjm!e!f#]R!X_^bOQjm!e!f#]R![b^dOQjm!e!f#]R!^dQ#T!_R#o#T^fOQjm!e!f#]R!`fQ#V!aR#q#VUhOQmR!bhQ#u#WR$R#uQ#Y!cR#w#YQ#[!cR#y#[YjOQm#^#{R!hjmwVZ]_bpr}!q!t!w!x#W#dZ{V}!t#W#d",
    nodeNames: "\u26A0 ask at random if else pressed print forward turn color sleep play is add from remove toList clear in not_in Comment Program Command Assign Text Op Expression Int Op Op ListAccess AssignList Comma Ask String Clear Print Play Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck IfLessCommand ErrorInvalid Else",
    maxTerm: 98,
    nodeProps: [
      ["group", 39, "turtle"]
    ],
    skippedNodes: [0, 21],
    repeatNodeCount: 27,
    tokenData: "*x~R!^OY$}YZ&UZp$}pq&Zqr$}rs&`st&etw$}wx&|xz$}z{'R{|'W|}']}!O'b!O!P$}!P!Q'g!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!_!`*s!`#Q$}#RBn$}BnBo']BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FV&FW']&FW;'S$};'S;=`&O<%l?Hb$}?Hb?Hc']?HcO$}~%S^i~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!_$}!`#Q$}#RBn$}Bo&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~&RP;=`<%l$}~&ZO!v~~&`O!u~~&eO#O~~&jSe~OY&eZ;'S&e;'S;=`&v<%lO&e~&yP;=`<%l&e~'RO#S~~'WO!y~~']O!{~~'bOq~~'gO!|~~'lO!z~~'s!Ol~i~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!`#Q$}#RBn$}BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~*xO!w~",
    tokenizers: [2, new LocalTokenGroup("_~RQYZXwxX~^O#U~~", 14, 97), new LocalTokenGroup("_~RQYZXrsX~^O#Q~~", 14, 93)],
    topRules: { "Program": [0, 22] },
    dynamicPrecedences: { "52": -10 },
    specialized: [{ term: 25, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }, { term: 25, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 967
  });

  // static/js/lezer-parsers/level7-parser.ts
  var parser7 = LRParser.deserialize({
    version: 14,
    states: "4pQYQPOOOOQO'#Dg'#DgQYQPOOO!WQPO'#DmO!lQPO'#DeOOQO'#Ds'#DsO!zQPO'#DSO#YQPO'#DTOOQO'#Dt'#DtO#hQPO'#DUOOQO'#Du'#DuO#pQPO'#DWOOQO'#Dv'#DvO#{QPO'#DXOOQO'#Dw'#DwO$WQPO'#DYOOQO'#DV'#DVOOQO'#Dx'#DxO$cQPO'#DZOOQO'#Dy'#DyO$wQPO'#D[OOQO'#D{'#D{O%PQPO'#D]OOQO'#D}'#D}O%XQPO'#D^OOQO'#ER'#ERO%aQPO'#DdOOQO'#ET'#ETO&dQPO'#DfOOQO'#Cu'#CuQ!RQPO'#DhQ&kQPOOOOQO-E7e-E7eOOQO'#Di'#DiO&rQPO,59bOOQO'#Cx'#CxO'QQPO,59bOOQO'#Dm'#DmOOQO-E7k-E7kOOQO-E7q-E7qO']QPO'#DpOOQO'#Cy'#CyO(rQPO'#CyO(|OSO'#E`O)UOQO'#EdOOQO'#DR'#DROOQO'#Dp'#DpO)^QPO,59oO)uQPO,59pOOQO-E7r-E7rO*TQPO,59rOOQO-E7s-E7sOOQO,59r,59rO*lQPO,59sOOQO-E7t-E7tOOQO,59s,59sO+TQPO,59tOOQO-E7u-E7uOOQO,59t,59tO+lQPO,59uOOQO-E7v-E7vOOQO,59u,59uOOQO-E7w-E7wO,TQPO,59vOOQO-E7y-E7yO,YQPO,59wOOQO-E7{-E7{O,_QPO'#D`OOQO'#D_'#D_O`QPO,59xOOQO-E8P-E8PO,jQPO,5:OO`QPO,5:QOOQO'#Dc'#DcOOQO-E8R-E8ROOQO,5:Q,5:QO,oQPO,5:SOOQO-E7f-E7fOOQO-E7g-E7gO-pQPO'#DjO._QPO1G/UO.fQPO'#CyOOQO'#Dj'#DjO.pQPO1G.|O/RQPO1G/UOOQO'#Do'#DoO/ZQPO1G/WOOQO'#C{'#C{OOQO'#C|'#C|O/lQPO,5:uO/lQPO,5:uOOQO'#Dk'#DkO/tQPO,59iOOOO'#Dq'#DqO0SOSO,5:zOOQO,5:z,5:zOOOO'#Dr'#DrO0[OQO,5;OOOQO,5;O,5;OOOQO-E7n-E7nOOQO'#Dz'#DzO0dQPO1G/bOOQO'#D|'#D|O0lQPO1G/cO0tQPO,59zOOQO'#EP'#EPO1YQPO,59{OOQO'#EQ'#EQO1bQPO,59|O`QPO1G/dO1jQPO1G/dOOQO'#ES'#ESO1uQPO1G/jOOQO1G/l1G/lO2VQPO'#DnO2_QPO7+$pOOQO-E7h-E7hOOQO-E7m-E7mO2mQPO7+$rOOQO1G0a1G0aO3UQPO1G0aOOQO-E7i-E7iOOQO'#Dl'#DlO4iQPO1G/TOOQO1G/T1G/TOOOO-E7o-E7oOOQO1G0f1G0fOOOO-E7p-E7pOOQO1G0j1G0jOOQO-E7x-E7xOOQO7+$|7+$|OOQO-E7z-E7zOOQO7+$}7+$}O5{QPO1G/fOOQO'#EO'#EOO6]QPO1G/fOOQO1G/f1G/fOOQO-E7}-E7}OOQO1G/g1G/gOOQO-E8O-E8OOOQO1G/h1G/hO6dQPO7+%OOOQO7+%O7+%OOOQO-E8Q-E8QOOQO7+%U7+%UO6oQPO,5:YOOQO,5:Y,5:YOOQO-E7l-E7lOOQO-E7j-E7jOOQO-E7|-E7|OOQO<<Hj<<Hj",
    stateData: "7T~OgOS!zOS~OSgOUkOVVOWYOX[OY^OZaO[WO^cO`eObTOeiOkRO!{PO~O]qO!|sOk!aX!x!aX!{!aXU!aX~OkuO!x!XX!{!XXU!XX~ObTO!xvX!{vXUvX~OkzOnyO#T{O#X|O~O[WOkuO~OWYOkzOnyO~OX[OkzOnyO~OY^OkzOnyO~OZaOkzOnyO!x}X!{}XU}X~O^cOk!aO~O`eOk!cO~OSgOk!eO~OeiOk!iOn!iO~OUkOVVOWYOX[OY^OZaO[WO^cO`eObTOeiOkRO~O!{PO~P%lOSgO~P%lOP!wO]qOk!sOn!rO~OP!wOk!sOn!rO~O#O!yO#P!yO#Q!zO#R!zOk!dXn!dX!x!dX!{!dX#T!dX#X!dXU!dX~OQ!}OkmXnmX!xmX!{mX#OmX#PmX#QmX#RmXUmX~O#TmX#XmX~P(QO#U#PO#V#RO~O#Y#SO#Z#UO~OkzOnyO#T{O#X|O!xwa!{waUwa~OkuO!xxa!{xaUxa~O#O!yO#P!yO#Q!zO#R!zO!xza!{zaUza~O#O!yO#P!yO#Q!zO#R!zO!x{a!{{aU{a~O#O!yO#P!yO#Q!zO#R!zO!x|a!{|aU|a~O#O!yO#P!yO#Q!zO#R!zO!x}a!{}aU}a~Oa#WO~O_#YO~O]qOc#]Od#_O~Of#cO~O!{POS![aU![aV![aW![aX![aY![aZ![a[![a^![a`![ab![ae![ak![a!x![a~O#O!yO#P!yO#Q!zO#R!zOk!^Xn!^X!x!^X!{!^XU!^X~Os#fO~P(TOk!aXs!aX~P(QOkzOnyO!xji!{jiUji~OkuOs#fO~OP!wOkzOnyO#T{O#X|O~OkyOnyO~OQ!}OR#nOk#pOn#pO~O#U#PO#V#rO~O#Y#SO#Z#tO~Oa#WOk#vO~O_#YOk#xO~OT#zO]qOkyOnyO#T{O#X|O~Oc#]Ok$OO~Od#_Ok$QO~OUkO!x!Qi!{!Qi~OSgOf#cO!x!Wi!{!Wi~P%lOkuOn$WO~Os#fO!xrq!{rqUrq~OkzOnyO#T{O#X|O!xtq!{tqUtq~O#O!yO#P!yO#Q!zO#R!zOk!}in!}i!x!}i!{!}i#T!}i#X!}iV!}iW!}iX!}iY!}iZ!}i[!}i^!}i`!}ib!}ie!}iU!}i~OR#nOkqinqi!xqi!{qi#Tqi#XqiUqi~OV!SiW!SiX!SiY!SiZ!Si[!Si^!Si`!Sib!Sie!Sik!Si!{!Si~O#O!yO#P!yO#Q!zO#R!zO~P5TOT#zO~P5TOUkO!x!Qq!{!Qq~OkuOs!ba!x!ba!{!baU!ba~Onk~",
    goto: "-`#XPPPPPPPPPPPPPPPPPPPPPPPPP#Y#bP#n#qP$c$m$w#bP#b%`#b#b#b#b%i%i%i#b#b#b%s%y%|%|%|&P#b#b&]&i&{'S'^'e'l'r(^(e(l(v(|)S)a)n){*Y*g*t+R+X+f+l+u+{,R,X,f,lPPPPP,wPPPP-XPPP-XUnOQoR$U#dWmOQo#dX!kl!g!j#aRtRWxV!P!x#jQ!SZQ!V]Q!Y_Q!]bU!qrt!uQ#k!{Q#l!|R#y#[a!{x!S!V!Y!]!q#l#ya!|x!S!V!Y!]!q#l#yW!OV!P!x#jQ!UZQ!X]Q![_Q!_bV!trt!uW!OV!P!x#jR#|#[a`OQlo!g!j#a#dXmOQo#dR!ghR!fhQ!mlQ#b!gQ#e!jR$R#aWmOQo#dQ$S#bR$[$RQQOWpQ!j!n#aQ!jlQ!nnR#a!gSoOQR!ooQrRS!pr#[R#[!eS!urtR#h!uS#Oz!sR#m#OQ#o#OR$Y#o`SOQlo!g!j#a#dWvS!Q!v$VQ!QXS!vrtR$V#fS#g!r!vR$X#gS!xrtR#i!xQ!PVS#V!P#jR#j!xQ#Q{R#q#QQ#T|R#s#T`UOQlo!g!j#a#dRwU`XOQlo!g!j#a#dR!RX`ZOQlo!g!j#a#dR!TZ`]OQlo!g!j#a#dR!W]`_OQlo!g!j#a#dR!Z_`bOQlo!g!j#a#dR!^b`dOQlo!g!j#a#dR!`dQ#X!aR#u#X`fOQlo!g!j#a#dR!bfQ#Z!cR#w#ZWhOQo#dR!dhQ#{#[R$Z#{Q#^!eR#}#^Q#`!eR$P#``jOQlo!g!j#a#dR!hjQ#d!iR$T#d[lOQo#b#d$RR!llmyVZ]_brt!P!u!x!{!|#[#jZ}V!P!x#[#j",
    nodeNames: "\u26A0 ask at random if pressed else print forward turn color sleep play is add from remove toList clear in not_in repeat times Comment Program Command Assign Text Op Expression Int Op Op ListAccess AssignList Comma Ask String Clear Print Play Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck IfLessCommand Repeat ErrorInvalid Else",
    maxTerm: 103,
    nodeProps: [
      ["group", 41, "turtle"]
    ],
    skippedNodes: [0, 23],
    repeatNodeCount: 29,
    tokenData: "*x~R!^OY$}YZ&UZp$}pq&Zqr$}rs&`st&etw$}wx&|xz$}z{'R{|'W|}']}!O'b!O!P$}!P!Q'g!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!_!`*s!`#Q$}#RBn$}BnBo']BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FV&FW']&FW;'S$};'S;=`&O<%l?Hb$}?Hb?Hc']?HcO$}~%S^k~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!_$}!`#Q$}#RBn$}Bo&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~&RP;=`<%l$}~&ZO!{~~&`O!z~~&eO#T~~&jSg~OY&eZ;'S&e;'S;=`&v<%lO&e~&yP;=`<%l&e~'RO#X~~'WO#O~~']O#Q~~'bOs~~'gO#R~~'lO#P~~'s!On~k~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!`#Q$}#RBn$}BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~*xO!|~",
    tokenizers: [2, new LocalTokenGroup("_~RQYZXwxX~^O#Z~~", 14, 102), new LocalTokenGroup("_~RQYZXrsX~^O#V~~", 14, 98)],
    topRules: { "Program": [0, 24] },
    dynamicPrecedences: { "55": -10 },
    specialized: [{ term: 27, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }, { term: 27, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 1014
  });

  // static/js/lezer-parsers/level8-parser.ts
  var parser8 = LRParser.deserialize({
    version: 14,
    states: "3bQYQPOOOOQO'#Df'#DfQYQPOOO!WQPO'#DlO!iQPO'#DeOOQO'#Dr'#DrO!tQPO'#DSO#PQPO'#DTOOQO'#Ds'#DsO#_QPO'#DUOOQO'#Dt'#DtO#gQPO'#DWOOQO'#Du'#DuO#rQPO'#DXOOQO'#Dv'#DvO#}QPO'#DYOOQO'#DV'#DVOOQO'#Dw'#DwO$YQPO'#DZOOQO'#Dx'#DxO$kQPO'#D[OOQO'#Dz'#DzO$sQPO'#D]OOQO'#D|'#D|O${QPO'#D^OOQO'#EQ'#EQO%TQPO'#DcOOQO'#ER'#ERO%`QPO'#DdOOQO'#Cu'#CuQ!RQPO'#DgQ%kQPOOOOQO-E7d-E7dOOQO'#Dh'#DhO&fQPO,59bOOQO'#Cx'#CxO&tQPO,59bOOQO'#Dl'#DlOOQO-E7j-E7jOOQO-E7p-E7pO'PQPO'#DoOOQO'#Cy'#CyO(`QPO'#CyO(jOSO'#E_O(rOQO'#EcOOQO'#DR'#DROOQO'#Do'#DoO(zQPO,59oO)`QPO,59pOOQO-E7q-E7qO)kQPO,59rOOQO-E7r-E7rOOQO,59r,59rO*PQPO,59sOOQO-E7s-E7sOOQO,59s,59sO*eQPO,59tOOQO-E7t-E7tOOQO,59t,59tO*yQPO,59uOOQO-E7u-E7uOOQO,59u,59uOOQO-E7v-E7vO+_QPO,59vOOQO-E7x-E7xO+dQPO,59wOOQO-E7z-E7zO+iQPO'#D`OOQO'#D_'#D_OOQO,59x,59xOOQO-E8O-E8OOOQO-E8P-E8PO+tQPO,5:OO+yQPO,5:ROOQO-E7e-E7eOOQO-E7f-E7fO,zQPO'#DiO-fQPO1G/UO-mQPO'#CyOOQO'#Di'#DiO-wQPO1G.|O.VQPO1G/UOOQO'#Dn'#DnO._QPO1G/WOOQO'#C{'#C{OOQO'#C|'#C|O.pQPO,5:tO.pQPO,5:tOOQO'#Dj'#DjO.xQPO,59iOOOO'#Dp'#DpO/WOSO,5:yOOQO,5:y,5:yOOOO'#Dq'#DqO/`OQO,5:}OOQO,5:},5:}OOQO-E7m-E7mOOQO'#Dy'#DyO/hQPO1G/bOOQO'#D{'#D{O/pQPO1G/cO/xQPO,59zOOQO'#EO'#EOO0^QPO,59{OOQO'#EP'#EPO0fQPO,59|OOQO'#ES'#ESO0nQPO1G/jO0yQPO'#DmO1RQPO7+$pOOQO-E7g-E7gOOQO-E7l-E7lO1^QPO7+$rOOQO1G0`1G0`O1rQPO1G0`OOQO-E7h-E7hOOQO'#Dk'#DkO2dQPO1G/TOOQO1G/T1G/TOOOO-E7n-E7nOOQO1G0e1G0eOOOO-E7o-E7oOOQO1G0i1G0iOOQO-E7w-E7wOOQO7+$|7+$|OOQO-E7y-E7yOOQO7+$}7+$}O2{QPO1G/fOOQO'#D}'#D}O3aQPO1G/fOOQO1G/f1G/fOOQO-E7|-E7|OOQO1G/g1G/gOOQO-E7}-E7}OOQO1G/h1G/hOOQO-E8Q-E8QO3lQPO,5:XOOQO,5:X,5:XOOQO-E7k-E7kOOQO-E7i-E7iOOQO-E7{-E7{",
    stateData: "3}~OgOS!yOS~OSgOUiOVVOWYOX[OY^OZaO[WO^cO`eObTOekOkRO!zPO~O]qO!{sOk!`X!w!`X!z!`X~OkuO!w!XX!z!XX~ObTO!wvX!zvX~OkzOnyO#S{O#W|O~O[WOkuO~OWYOkzOnyO~OX[OkzOnyO~OY^OkzOnyO~OZaOkzOnyO!w}X!z}X~O^cOk!aO~O`eOk!cO~OSgOk!eO~OUiO!w!VX!z!VX~OekOk!jOn!jO~OSgOUiOVVOWYOX[OY^OZaO[WO^cO`eObTOekOkRO~OP!tO]qOk!pOn!oO~OP!tOk!pOn!oO~O!}!vO#O!vO#P!wO#Q!wOk!cXn!cX!w!cX!z!cX#S!cX#W!cX~OQ!zOkmXnmX!wmX!zmX!}mX#OmX#PmX#QmX~O#SmX#WmX~P'qO#T!|O#U#OO~O#X#PO#Y#RO~OkzOnyO#S{O#W|O!wwa!zwa~OkuO!wxa!zxa~O!}!vO#O!vO#P!wO#Q!wO!wza!zza~O!}!vO#O!vO#P!wO#Q!wO!w{a!z{a~O!}!vO#O!vO#P!wO#Q!wO!w|a!z|a~O!}!vO#O!vO#P!wO#Q!wO!w}a!z}a~Oa#TO~O_#VO~O]qOc#YOd#[O~Of#^O~O!zPOS!ZaU!ZaV!ZaW!ZaX!ZaY!ZaZ!Za[!Za^!Za`!Zab!Zae!Zak!Za!w!Za~O!}!vO#O!vO#P!wO#Q!wOk!]Xn!]X!w!]X!z!]X~Os#`O~P'tOk!`Xs!`X~P'qOkzOnyO!wji!zji~OkuOs#`O~OP!tOkzOnyO#S{O#W|O~OkyOnyO~OQ!zOR#hOk#jOn#jO~O#T!|O#U#lO~O#X#PO#Y#nO~Oa#TOk#pO~O_#VOk#rO~OT#tO]qOkyOnyO#S{O#W|O~Oc#YOk#xO~Od#[Ok#zO~Of#^O!w!Wi!z!Wi~OkuOn#}O~Os#`O!wrq!zrq~OkzOnyO#S{O#W|O!wtq!ztq~O!}!vO#O!vO#P!wO#Q!wOk!|in!|i!w!|i!z!|i#S!|i#W!|i~OR#hOkqinqi!wqi!zqi#Sqi#Wqi~O!}!vO#O!vO#P!wO#Q!wO!w!Si!z!Si~OT#tO!w!Si!z!Si~OkuOs!aa!w!aa!z!aa~Onk~",
    goto: "+O#WPPPPPPPPPPPPPPPPPPPPPPPPP#X#^P#c#fP$W$b$l#^P#^%T#^#^#^#^%^%^%^#^#^#^#^%c%f%f%f#^#^#^%i%s%z&U&]&d&j'P'W'_'i'o'u'}(V(_(g(o(w)P)V)_)e)m)s)y*P*X*aPPPPP*gPPPP*wPPP*wVnOQoVmOQoRtRWxV!P!u#dQ!SZQ!V]Q!Y_Q!]bU!nrt!rQ#e!xQ#f!yR#s#Xa!xx!S!V!Y!]!n#f#sa!yx!S!V!Y!]!n#f#sW!OV!P!u#dQ!UZQ!X]Q![_Q!_bV!qrt!rW!OV!P!u#dR#v#XV`OQoR!ghR!fhQQOSpQ!kR!knSoOQR!loQrRS!mr#XR#X!eS!rrtR#b!rS!{z!pR#g!{Q#i!{R$P#iUSOQoWvS!Q!s#|Q!QXS!srtR#|#`S#a!o!sR$O#aS!urtR#c!uQ!PVS#S!P#dR#d!uQ!}{R#k!}Q#Q|R#m#QUUOQoRwUUXOQoR!RXUZOQoR!TZU]OQoR!W]U_OQoR!Z_UbOQoR!^bUdOQoR!`dQ#U!aR#o#UUfOQoR!bfQ#W!cR#q#WUhOQoR!dhQ#u#XR$Q#uQ#Z!eR#w#ZQ#]!eR#y#]UjOQoR!hjUlOQoR!ilQ#_!jR#{#_myVZ]_brt!P!r!u!x!y#X#dZ}V!P!u#X#d",
    nodeNames: "\u26A0 ask at random if pressed else print forward turn color sleep play is add from remove toList clear in not_in repeat times Comment Program Command Assign Text Op Expression Int Op Op ListAccess AssignList Comma Ask String Clear Print Play Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck Else Repeat ErrorInvalid",
    maxTerm: 102,
    nodeProps: [
      ["group", 41, "turtle"]
    ],
    skippedNodes: [0, 23],
    repeatNodeCount: 29,
    tokenData: "*x~R!^OY$}YZ&UZp$}pq&Zqr$}rs&`st&etw$}wx&|xz$}z{'R{|'W|}']}!O'b!O!P$}!P!Q'g!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!_!`*s!`#Q$}#RBn$}BnBo']BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FV&FW']&FW;'S$};'S;=`&O<%l?Hb$}?Hb?Hc']?HcO$}~%S^k~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!_$}!`#Q$}#RBn$}Bo&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~&RP;=`<%l$}~&ZO!z~~&`O!y~~&eO#S~~&jSg~OY&eZ;'S&e;'S;=`&v<%lO&e~&yP;=`<%l&e~'RO#W~~'WO!}~~']O#P~~'bOs~~'gO#Q~~'lO#O~~'s!On~k~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!`#Q$}#RBn$}BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~*xO!{~",
    tokenizers: [2, new LocalTokenGroup("_~RQYZXwxX~^O#Y~~", 14, 101), new LocalTokenGroup("_~RQYZXrsX~^O#U~~", 14, 97)],
    topRules: { "Program": [0, 24] },
    dynamicPrecedences: { "55": -10 },
    specialized: [{ term: 27, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }, { term: 27, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 870
  });

  // static/js/lezer-parsers/level9-parser.ts
  var parser9 = LRParser.deserialize({
    version: 14,
    states: "3bQYQPOOOOQO'#Df'#DfQYQPOOO!WQPO'#DlO!iQPO'#DeOOQO'#Dr'#DrO!tQPO'#DSO#PQPO'#DTOOQO'#Ds'#DsO#_QPO'#DUOOQO'#Dt'#DtO#gQPO'#DWOOQO'#Du'#DuO#rQPO'#DXOOQO'#Dv'#DvO#}QPO'#DYOOQO'#DV'#DVOOQO'#Dw'#DwO$YQPO'#DZOOQO'#Dx'#DxO$kQPO'#D[OOQO'#Dz'#DzO$sQPO'#D]OOQO'#D|'#D|O${QPO'#D^OOQO'#EQ'#EQO%TQPO'#DcOOQO'#ER'#ERO%`QPO'#DdOOQO'#Cu'#CuQ!RQPO'#DgQ%kQPOOOOQO-E7d-E7dOOQO'#Dh'#DhO&fQPO,59bOOQO'#Cx'#CxO&tQPO,59bOOQO'#Dl'#DlOOQO-E7j-E7jOOQO-E7p-E7pO'PQPO'#DoOOQO'#Cy'#CyO(`QPO'#CyO(jOSO'#E_O(rOQO'#EcOOQO'#DR'#DROOQO'#Do'#DoO(zQPO,59oO)`QPO,59pOOQO-E7q-E7qO)kQPO,59rOOQO-E7r-E7rOOQO,59r,59rO*PQPO,59sOOQO-E7s-E7sOOQO,59s,59sO*eQPO,59tOOQO-E7t-E7tOOQO,59t,59tO*yQPO,59uOOQO-E7u-E7uOOQO,59u,59uOOQO-E7v-E7vO+_QPO,59vOOQO-E7x-E7xO+dQPO,59wOOQO-E7z-E7zO+iQPO'#D`OOQO'#D_'#D_OOQO,59x,59xOOQO-E8O-E8OOOQO-E8P-E8PO+tQPO,5:OO+yQPO,5:ROOQO-E7e-E7eOOQO-E7f-E7fO,zQPO'#DiO-fQPO1G/UO-mQPO'#CyOOQO'#Di'#DiO-wQPO1G.|O.VQPO1G/UOOQO'#Dn'#DnO._QPO1G/WOOQO'#C{'#C{OOQO'#C|'#C|O.pQPO,5:tO.pQPO,5:tOOQO'#Dj'#DjO.xQPO,59iOOOO'#Dp'#DpO/WOSO,5:yOOQO,5:y,5:yOOOO'#Dq'#DqO/`OQO,5:}OOQO,5:},5:}OOQO-E7m-E7mOOQO'#Dy'#DyO/hQPO1G/bOOQO'#D{'#D{O/pQPO1G/cO/xQPO,59zOOQO'#EO'#EOO0^QPO,59{OOQO'#EP'#EPO0fQPO,59|OOQO'#ES'#ESO0nQPO1G/jO0yQPO'#DmO1RQPO7+$pOOQO-E7g-E7gOOQO-E7l-E7lO1^QPO7+$rOOQO1G0`1G0`O1rQPO1G0`OOQO-E7h-E7hOOQO'#Dk'#DkO2dQPO1G/TOOQO1G/T1G/TOOOO-E7n-E7nOOQO1G0e1G0eOOOO-E7o-E7oOOQO1G0i1G0iOOQO-E7w-E7wOOQO7+$|7+$|OOQO-E7y-E7yOOQO7+$}7+$}O2{QPO1G/fOOQO'#D}'#D}O3aQPO1G/fOOQO1G/f1G/fOOQO-E7|-E7|OOQO1G/g1G/gOOQO-E7}-E7}OOQO1G/h1G/hOOQO-E8Q-E8QO3lQPO,5:XOOQO,5:X,5:XOOQO-E7k-E7kOOQO-E7i-E7iOOQO-E7{-E7{",
    stateData: "3}~OgOS!yOS~OSgOUiOVVOWYOX[OY^OZaO[WO^cO`eObTOekOkRO!zPO~O]qO!{sOk!`X!w!`X!z!`X~OkuO!w!XX!z!XX~ObTO!wvX!zvX~OkzOnyO#S{O#W|O~O[WOkuO~OWYOkzOnyO~OX[OkzOnyO~OY^OkzOnyO~OZaOkzOnyO!w}X!z}X~O^cOk!aO~O`eOk!cO~OSgOk!eO~OUiO!w!VX!z!VX~OekOk!jOn!jO~OSgOUiOVVOWYOX[OY^OZaO[WO^cO`eObTOekOkRO~OP!tO]qOk!pOn!oO~OP!tOk!pOn!oO~O!}!vO#O!vO#P!wO#Q!wOk!cXn!cX!w!cX!z!cX#S!cX#W!cX~OQ!zOkmXnmX!wmX!zmX!}mX#OmX#PmX#QmX~O#SmX#WmX~P'qO#T!|O#U#OO~O#X#PO#Y#RO~OkzOnyO#S{O#W|O!wwa!zwa~OkuO!wxa!zxa~O!}!vO#O!vO#P!wO#Q!wO!wza!zza~O!}!vO#O!vO#P!wO#Q!wO!w{a!z{a~O!}!vO#O!vO#P!wO#Q!wO!w|a!z|a~O!}!vO#O!vO#P!wO#Q!wO!w}a!z}a~Oa#TO~O_#VO~O]qOc#YOd#[O~Of#^O~O!zPOS!ZaU!ZaV!ZaW!ZaX!ZaY!ZaZ!Za[!Za^!Za`!Zab!Zae!Zak!Za!w!Za~O!}!vO#O!vO#P!wO#Q!wOk!]Xn!]X!w!]X!z!]X~Os#`O~P'tOk!`Xs!`X~P'qOkzOnyO!wji!zji~OkuOs#`O~OP!tOkzOnyO#S{O#W|O~OkyOnyO~OQ!zOR#hOk#jOn#jO~O#T!|O#U#lO~O#X#PO#Y#nO~Oa#TOk#pO~O_#VOk#rO~OT#tO]qOkyOnyO#S{O#W|O~Oc#YOk#xO~Od#[Ok#zO~Of#^O!w!Wi!z!Wi~OkuOn#}O~Os#`O!wrq!zrq~OkzOnyO#S{O#W|O!wtq!ztq~O!}!vO#O!vO#P!wO#Q!wOk!|in!|i!w!|i!z!|i#S!|i#W!|i~OR#hOkqinqi!wqi!zqi#Sqi#Wqi~O!}!vO#O!vO#P!wO#Q!wO!w!Si!z!Si~OT#tO!w!Si!z!Si~OkuOs!aa!w!aa!z!aa~Onk~",
    goto: "+O#WPPPPPPPPPPPPPPPPPPPPPPPPP#X#^P#c#fP$W$b$l#^P#^%T#^#^#^#^%^%^%^#^#^#^#^%c%f%f%f#^#^#^%i%s%z&U&]&d&j'P'W'_'i'o'u'}(V(_(g(o(w)P)V)_)e)m)s)y*P*X*aPPPPP*gPPPP*wPPP*wVnOQoVmOQoRtRWxV!P!u#dQ!SZQ!V]Q!Y_Q!]bU!nrt!rQ#e!xQ#f!yR#s#Xa!xx!S!V!Y!]!n#f#sa!yx!S!V!Y!]!n#f#sW!OV!P!u#dQ!UZQ!X]Q![_Q!_bV!qrt!rW!OV!P!u#dR#v#XV`OQoR!ghR!fhQQOSpQ!kR!knSoOQR!loQrRS!mr#XR#X!eS!rrtR#b!rS!{z!pR#g!{Q#i!{R$P#iUSOQoWvS!Q!s#|Q!QXS!srtR#|#`S#a!o!sR$O#aS!urtR#c!uQ!PVS#S!P#dR#d!uQ!}{R#k!}Q#Q|R#m#QUUOQoRwUUXOQoR!RXUZOQoR!TZU]OQoR!W]U_OQoR!Z_UbOQoR!^bUdOQoR!`dQ#U!aR#o#UUfOQoR!bfQ#W!cR#q#WUhOQoR!dhQ#u#XR$Q#uQ#Z!eR#w#ZQ#]!eR#y#]UjOQoR!hjUlOQoR!ilQ#_!jR#{#_myVZ]_brt!P!r!u!x!y#X#dZ}V!P!u#X#d",
    nodeNames: "\u26A0 ask at random if pressed else print forward turn color sleep play is add from remove toList clear in not_in repeat times Comment Program Command Assign Text Op Expression Int Op Op ListAccess AssignList Comma Ask String Clear Print Play Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck Else Repeat ErrorInvalid",
    maxTerm: 102,
    nodeProps: [
      ["group", 41, "turtle"]
    ],
    skippedNodes: [0, 23],
    repeatNodeCount: 29,
    tokenData: "*x~R!^OY$}YZ&UZp$}pq&Zqr$}rs&`st&etw$}wx&|xz$}z{'R{|'W|}']}!O'b!O!P$}!P!Q'g!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!_!`*s!`#Q$}#RBn$}BnBo']BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FV&FW']&FW;'S$};'S;=`&O<%l?Hb$}?Hb?Hc']?HcO$}~%S^k~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!_$}!`#Q$}#RBn$}Bo&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~&RP;=`<%l$}~&ZO!z~~&`O!y~~&eO#S~~&jSg~OY&eZ;'S&e;'S;=`&v<%lO&e~&yP;=`<%l&e~'RO#W~~'WO!}~~']O#P~~'bOs~~'gO#Q~~'lO#O~~'s!On~k~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!`#Q$}#RBn$}BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~*xO!{~",
    tokenizers: [2, new LocalTokenGroup("_~RQYZXwxX~^O#Y~~", 14, 101), new LocalTokenGroup("_~RQYZXrsX~^O#U~~", 14, 97)],
    topRules: { "Program": [0, 24] },
    dynamicPrecedences: { "55": -10 },
    specialized: [{ term: 27, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }, { term: 27, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 870
  });

  // static/js/lezer-parsers/level10-parser.ts
  var parser10 = LRParser.deserialize({
    version: 14,
    states: "4WQYQPOOOOQO'#Dh'#DhQYQPOOO!ZQPO'#DnO!lQPO'#DgOOQO'#Dt'#DtO!wQPO'#DTO#SQPO'#DUOOQO'#Du'#DuO#bQPO'#DVOOQO'#Dv'#DvO#jQPO'#DXOOQO'#Dw'#DwO#uQPO'#DYOOQO'#Dx'#DxO$QQPO'#DZOOQO'#DW'#DWOOQO'#Dy'#DyO$]QPO'#D[OOQO'#Dz'#DzO$nQPO'#D]OOQO'#D|'#D|O$vQPO'#D^OOQO'#EO'#EOO%OQPO'#D_OOQO'#ES'#ESO%WQPO'#DdOOQO'#ET'#ETO%cQPO'#DeOOQO'#EV'#EVO%nQPO'#DfOOQO'#Cv'#CvQ!UQPO'#DiQ%vQPOOOOQO-E7f-E7fOOQO'#Dj'#DjO&tQPO,59cOOQO'#Cy'#CyO'SQPO,59cOOQO'#Dn'#DnOOQO-E7l-E7lOOQO-E7r-E7rO'_QPO'#DqOOQO'#Cz'#CzO(nQPO'#CzO(xOSO'#EbO)QOQO'#EfOOQO'#DS'#DSOOQO'#Dq'#DqO)YQPO,59pO)nQPO,59qOOQO-E7s-E7sO)yQPO,59sOOQO-E7t-E7tOOQO,59s,59sO*_QPO,59tOOQO-E7u-E7uOOQO,59t,59tO*sQPO,59uOOQO-E7v-E7vOOQO,59u,59uO+XQPO,59vOOQO-E7w-E7wOOQO,59v,59vOOQO-E7x-E7xO+mQPO,59wOOQO-E7z-E7zO+rQPO,59xOOQO-E7|-E7|O+wQPO'#DaOOQO'#D`'#D`OOQO,59y,59yOOQO-E8Q-E8QOOQO-E8R-E8RO,SQPO,5:POOQO-E8T-E8TO,XQPO,5:QO,^QPO,5:TOOQO-E7g-E7gOOQO-E7h-E7hO-bQPO'#DkO-|QPO1G/VO.TQPO'#CzOOQO'#Dk'#DkO._QPO1G.}O.mQPO1G/VOOQO'#Dp'#DpO.uQPO1G/XOOQO'#C|'#C|OOQO'#C}'#C}O/WQPO,5:wO/WQPO,5:wOOQO'#Dl'#DlO/`QPO,59jOOOO'#Dr'#DrO/nOSO,5:|OOQO,5:|,5:|OOOO'#Ds'#DsO/vOQO,5;QOOQO,5;Q,5;QOOQO-E7o-E7oOOQO'#D{'#D{O0OQPO1G/cOOQO'#D}'#D}O0WQPO1G/dO0`QPO,59{OOQO'#EQ'#EQO0tQPO,59|OOQO'#ER'#ERO0|QPO,59}OOQO'#EU'#EUO1UQPO1G/kO1aQPO1G/lO1iQPO'#DoO1qQPO7+$qOOQO-E7i-E7iOOQO-E7n-E7nO1|QPO7+$sOOQO1G0c1G0cO2bQPO1G0cOOQO-E7j-E7jOOQO'#Dm'#DmO3SQPO1G/UOOQO1G/U1G/UOOOO-E7p-E7pOOQO1G0h1G0hOOOO-E7q-E7qOOQO1G0l1G0lOOQO-E7y-E7yOOQO7+$}7+$}OOQO-E7{-E7{OOQO7+%O7+%OO3kQPO1G/gOOQO'#EP'#EPO4PQPO1G/gOOQO1G/g1G/gOOQO-E8O-E8OOOQO1G/h1G/hOOQO-E8P-E8POOQO1G/i1G/iOOQO-E8S-E8SOOQO7+%W7+%WO4[QPO,5:ZOOQO,5:Z,5:ZOOQO-E7m-E7mOOQO-E7k-E7kOOQO-E7}-E7}",
    stateData: "4m~OhOS!|OS~OSgOUiOVVOWYOX[OY^OZaO[WO^cO`eObTOekOgmOlRO!}PO~O]sO#OuOl!bX!z!bX!}!bX~OlwO!z!ZX!}!ZX~ObTO!zwX!}wX~Ol|Oo{O#V}O#Z!OO~O[WOlwO~OWYOl|Oo{O~OX[Ol|Oo{O~OY^Ol|Oo{O~OZaOl|Oo{O!z!OX!}!OX~O^cOl!cO~O`eOl!eO~OSgOl!gO~OUiO!z!WX!}!WX~OekOl!lOo!lO~OgmOl!nO~OSgOUiOVVOWYOX[OY^OZaO[WO^cO`eObTOekOgmOlRO~OP!xO]sOl!tOo!sO~OP!xOl!tOo!sO~O#Q!zO#R!zO#S!{O#T!{Ol!eXo!eX!z!eX!}!eX#V!eX#Z!eX~OQ#OOlnXonX!znX!}nX#QnX#RnX#SnX#TnX~O#VnX#ZnX~P(PO#W#QO#X#SO~O#[#TO#]#VO~Ol|Oo{O#V}O#Z!OO!zxa!}xa~OlwO!zya!}ya~O#Q!zO#R!zO#S!{O#T!{O!z{a!}{a~O#Q!zO#R!zO#S!{O#T!{O!z|a!}|a~O#Q!zO#R!zO#S!{O#T!{O!z}a!}}a~O#Q!zO#R!zO#S!{O#T!{O!z!Oa!}!Oa~Oa#XO~O_#ZO~O]sOc#^Od#`O~Of#bO~Oc#^O~O!}POS!]aU!]aV!]aW!]aX!]aY!]aZ!]a[!]a^!]a`!]ab!]ae!]ag!]al!]a!z!]a~O#Q!zO#R!zO#S!{O#T!{Ol!_Xo!_X!z!_X!}!_X~Ot#eO~P(SOl!bXt!bX~P(POl|Oo{O!zki!}ki~OlwOt#eO~OP!xOl|Oo{O#V}O#Z!OO~Ol{Oo{O~OQ#OOR#mOl#oOo#oO~O#W#QO#X#qO~O#[#TO#]#sO~Oa#XOl#uO~O_#ZOl#wO~OT#yO]sOl{Oo{O#V}O#Z!OO~Oc#^Ol#}O~Od#`Ol$PO~Of#bO!z!Xi!}!Xi~Oc#^Ol$RO~OlwOo$TO~Ot#eO!zsq!}sq~Ol|Oo{O#V}O#Z!OO!zuq!}uq~O#Q!zO#R!zO#S!{O#T!{Ol#Pio#Pi!z#Pi!}#Pi#V#Pi#Z#Pi~OR#mOlriori!zri!}ri#Vri#Zri~O#Q!zO#R!zO#S!{O#T!{O!z!Ti!}!Ti~OT#yO!z!Ti!}!Ti~OlwOt!ca!z!ca!}!ca~Ool~",
    goto: "+_#ZPPPPPPPPPPPPPPPPPPPPPPPPPP#[#aP#f#iP$Z$e$o#aP#a%W#a#a#a#a%a%a%a#a#a#a#a%f%i%i%i#a#a#a#a%l%v%}&X&`&g&m'S'Z'b'l'r'x(Q(Y(b(j(r(z)S)Y)b)h)p)v*Q*W*`*h*nPPPPP*vPPPP+WPPP+WVpOQqVoOQqRvRWzV!R!y#iQ!UZQ!X]Q![_Q!_bU!rtv!vQ#j!|Q#k!}R#x#]a!|z!U!X![!_!r#k#xa!}z!U!X![!_!r#k#xW!QV!R!y#iQ!WZQ!Z]Q!^_Q!abV!utv!vW!QV!R!y#iR#{#]V`OQqR!ihR!hhQQOSrQ!oR!opSqOQR!pqQtRS!qt#]R#]!gS!vtvR#g!vS#P|!tR#l#PQ#n#PR$V#nUSOQqWxS!S!w$SQ!SXS!wtvR$S#eS#f!s!wR$U#fS!ytvR#h!yQ!RVS#W!R#iR#i!yQ#R}R#p#RQ#U!OR#r#UUUOQqRyUUXOQqR!TXUZOQqR!VZU]OQqR!Y]U_OQqR!]_UbOQqR!`bUdOQqR!bdQ#Y!cR#t#YUfOQqR!dfQ#[!eR#v#[UhOQqR!fhQ#z#]R$W#zQ#_!gQ#d!nT#|#_#dQ#a!gR$O#aUjOQqR!jjUlOQqR!klQ#c!lR$Q#cUnOQqR!mnm{VZ]_btv!R!v!y!|!}#]#iZ!PV!R!y#]#i",
    nodeNames: "\u26A0 ask at random if pressed else print forward turn color sleep play is add from remove toList clear in not_in repeat times for Comment Program Command Assign Text Op Expression Int Op Op ListAccess AssignList Comma Ask String Clear Print Play Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck Else Repeat For ErrorInvalid",
    maxTerm: 105,
    nodeProps: [
      ["group", 42, "turtle"]
    ],
    skippedNodes: [0, 24],
    repeatNodeCount: 30,
    tokenData: "*x~R!^OY$}YZ&UZp$}pq&Zqr$}rs&`st&etw$}wx&|xz$}z{'R{|'W|}']}!O'b!O!P$}!P!Q'g!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!_!`*s!`#Q$}#RBn$}BnBo']BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FV&FW']&FW;'S$};'S;=`&O<%l?Hb$}?Hb?Hc']?HcO$}~%S^l~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!_$}!`#Q$}#RBn$}Bo&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~&RP;=`<%l$}~&ZO!}~~&`O!|~~&eO#V~~&jSh~OY&eZ;'S&e;'S;=`&v<%lO&e~&yP;=`<%l&e~'RO#Z~~'WO#Q~~']O#S~~'bOt~~'gO#T~~'lO#R~~'s!Oo~l~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!`#Q$}#RBn$}BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~*xO#O~",
    tokenizers: [2, new LocalTokenGroup("_~RQYZXwxX~^O#]~~", 14, 104), new LocalTokenGroup("_~RQYZXrsX~^O#X~~", 14, 100)],
    topRules: { "Program": [0, 25] },
    dynamicPrecedences: { "57": -10 },
    specialized: [{ term: 28, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }, { term: 28, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 900
  });

  // static/js/lezer-parsers/level11-parser.ts
  var parser11 = LRParser.deserialize({
    version: 14,
    states: "5fQYQPOOOOQO'#Dj'#DjQYQPOOO!ZQPO'#DpO!lQPO'#DiOOQO'#Dv'#DvO!wQPO'#DVOOQO'#Dw'#DwO#SQPO'#DWOOQO'#Dx'#DxO#eQPO'#DXOOQO'#Dy'#DyO#mQPO'#DZOOQO'#Dz'#DzO#xQPO'#D[OOQO'#D{'#D{O$TQPO'#D]OOQO'#DY'#DYOOQO'#D|'#D|O$`QPO'#D^OOQO'#D}'#D}O$qQPO'#D_OOQO'#EP'#EPO$yQPO'#D`OOQO'#ER'#ERO%RQPO'#DaOOQO'#EV'#EVO%ZQPO'#DfOOQO'#EW'#EWO%fQPO'#DgOOQO'#EY'#EYO%qQPO'#DhOOQO'#Cx'#CxQ!UQPO'#DkQ%yQPOOOOQO-E7h-E7hOOQO'#Dl'#DlO&wQPO,59eOOQO'#C{'#C{O'VQPO,59eOOQO'#Dp'#DpOOQO-E7n-E7nOOQO-E7t-E7tO'bQPO'#DsOOQO'#C|'#C|O(qQPO'#C|O({OSO'#EgO)TOQO'#EkOOQO'#DU'#DUOOQO'#Ds'#DsO)]QPO,59rOOQO-E7u-E7uO)qQPO,59sOOQO-E7v-E7vO)|QPO,59uOOQO-E7w-E7wOOQO,59u,59uO*bQPO,59vOOQO-E7x-E7xOOQO,59v,59vO*vQPO,59wOOQO-E7y-E7yOOQO,59w,59wO+[QPO,59xOOQO-E7z-E7zOOQO,59x,59xOOQO-E7{-E7{O+pQPO,59yOOQO-E7}-E7}O+uQPO,59zOOQO-E8P-E8PO+zQPO'#DcOOQO'#Db'#DbOOQO,59{,59{OOQO-E8T-E8TOOQO-E8U-E8UO,VQPO,5:ROOQO-E8W-E8WO,[QPO,5:SO,aQPO,5:VOOQO-E7i-E7iOOQO-E7j-E7jO-eQPO'#DmO.PQPO1G/XO.WQPO'#C|OOQO'#Dm'#DmO.bQPO1G/PO.pQPO1G/XOOQO'#Dr'#DrO.xQPO1G/ZOOQO'#DO'#DOOOQO'#DP'#DPO/ZQPO,5:|O/ZQPO,5:|OOQO'#Dn'#DnO/cQPO,59lOOOO'#Dt'#DtO/qOSO,5;ROOQO,5;R,5;ROOOO'#Du'#DuO/yOQO,5;VOOQO,5;V,5;VOOQO-E7q-E7qOOQO'#EO'#EOO0RQPO1G/eOOQO'#EQ'#EQO0ZQPO1G/fO0cQPO,59}OOQO'#ET'#ETO0wQPO,5:OOOQO'#EU'#EUO1PQPO,5:POOQO'#EX'#EXO1XQPO1G/mO1dQPO1G/nO1oQPO'#DqO1wQPO7+$sOOQO-E7k-E7kOOQO-E7p-E7pO2SQPO7+$uOOQO1G0h1G0hO2hQPO1G0hOOQO-E7l-E7lOOQO'#Do'#DoO3YQPO1G/WOOQO1G/W1G/WOOOO-E7r-E7rOOQO1G0m1G0mOOOO-E7s-E7sOOQO1G0q1G0qOOQO-E7|-E7|OOQO7+%P7+%POOQO-E8O-E8OOOQO7+%Q7+%QO3qQPO1G/iOOQO'#ES'#ESO4VQPO1G/iOOQO1G/i1G/iOOQO-E8R-E8ROOQO1G/j1G/jOOQO-E8S-E8SOOQO1G/k1G/kOOQO-E8V-E8VOOQO'#EZ'#EZO4bQPO7+%YOOQO7+%Y7+%YO4mQPO,5:]OOQO,5:],5:]OOQO-E7o-E7oOOQO-E7m-E7mOOQO-E8Q-E8QOOQO-E8X-E8XO4{QPO<<HtOOQO'#E['#E[O5QQPOAN>`OOQO-E8Y-E8YOOQOG23zG23z",
    stateData: "5`~OjOS#ROS~OShOUjOVVOWZOX]OY_OZbO[XO^dO`fObTOelOgnOnRO#SPO~O]tO#TvOn!dX#P!dX#S!dX~OnxO#P!]X#S!]X~ObTO#PyX#SyX~OVVOn}Oq|O#[!OO#`!PO~O[XOnxO~OWZOn}Oq|O~OX]On}Oq|O~OY_On}Oq|O~OZbOn}Oq|O#P!QX#S!QX~O^dOn!eO~O`fOn!gO~OShOn!iO~OUjO#P!YX#S!YX~OelOn!nOq!nO~OgnOn!pO~OShOUjOVVOWZOX]OY_OZbO[XO^dO`fObTOelOgnOnRO~OP!zO]tOn!vOq!uO~OP!zOn!vOq!uO~O#V!|O#W!|O#X!}O#Y!}On!gXq!gX#P!gX#S!gX#[!gX#`!gX~OQ#QOnpXqpX#PpX#SpX#VpX#WpX#XpX#YpX~O#[pX#`pX~P(SO#]#SO#^#UO~O#a#VO#b#XO~On}Oq|O#[!OO#`!PO#Pza#Sza~OnxO#P{a#S{a~O#V!|O#W!|O#X!}O#Y!}O#P}a#S}a~O#V!|O#W!|O#X!}O#Y!}O#P!Oa#S!Oa~O#V!|O#W!|O#X!}O#Y!}O#P!Pa#S!Pa~O#V!|O#W!|O#X!}O#Y!}O#P!Qa#S!Qa~Oa#ZO~O_#]O~O]tOc#`Od#bO~Of#dO~Oc#`O~O#SPOS!_aU!_aV!_aW!_aX!_aY!_aZ!_a[!_a^!_a`!_ab!_ae!_ag!_an!_a#P!_a~O#V!|O#W!|O#X!}O#Y!}On!aXq!aX#P!aX#S!aX~Ov#gO~P(VOn!dXv!dX~P(SOn}Oq|O#Pmi#Smi~OnxOv#gO~OP!zOn}Oq|O#[!OO#`!PO~On|Oq|O~OQ#QOR#oOn#qOq#qO~O#]#SO#^#sO~O#a#VO#b#uO~Oa#ZOn#wO~O_#]On#yO~OT#{O]tOn|Oq|O#[!OO#`!PO~Oc#`On$PO~Od#bOn$RO~Of#dO#P!Zi#S!Zi~Oc#`Oi$TOn$VO~OnxOq$XO~Ov#gO#Puq#Suq~On}Oq|O#[!OO#`!PO#Pwq#Swq~O#V!|O#W!|O#X!}O#Y!}On#Uiq#Ui#P#Ui#S#Ui#[#Ui#`#Ui~OR#oOntiqti#Pti#Sti#[ti#`ti~O#V!|O#W!|O#X!}O#Y!}O#P!Vi#S!Vi~OT#{O#P!Vi#S!Vi~Oi$TOn$^Oq$^O~OnxOv!ea#P!ea#S!ea~Oh$_O~Oh$_On$bOq$bO~Oqn~",
    goto: "+x#`PPPPPPPPPPPPPPPPPPPPPPPPPPPP#a#fP#k#nP$`$j$t#fP#f%]#f#f#f#f%f%f%f#f#f#f#f%k%n%n%n#f#f#f#f%q%{&S&^&e&l&r'X'`'g'q'w'}(V(_(g(o(w)P)X)a)g)o)u)}*T*_*e*m*u*{+T+ZPPPPP+aPPPP+qPPP+qVqOQrVpOQrRwRW{W!S!{#kQ!W[Q!Z^Q!^`Q!acU!tuw!xQ#l#OQ#m#PR#z#_a#O{!W!Z!^!a!t#m#za#P{!W!Z!^!a!t#m#zW!RW!S!{#kQ!Y[Q!]^Q!``Q!ccV!wuw!xW!RW!S!{#kR#}#_VaOQrR!kiR!jiQQOSsQ!qR!qqSrOQR!rrQuRS!su#_R#_!iS!xuwR#i!xS#R}!vR#n#RQ#p#RR$Z#pUSOQrWyS!U!y$WQ!UYS!yuwR$W#gS#h!u!yR$Y#hS!{uwR#j!{Q!SWS#Y!S#kR#k!{Q#T!OR#r#TQ#W!PR#t#WUUOQrRzUUWOQrR!TWUYOQrR!VYU[OQrR!X[U^OQrR![^U`OQrR!_`UcOQrR!bcUeOQrR!deQ#[!eR#v#[UgOQrR!fgQ#^!gR#x#^UiOQrR!hiQ#|#_R$[#|Q#a!iQ#f!pT$O#a#fQ#c!iR$Q#cUkOQrR!lkUmOQrR!mmQ#e!nR$S#eUoOQrR!ooQ$U#fR$]$UQ$`$^R$a$`m|W[^`cuw!S!x!{#O#P#_#kZ!QW!S!{#_#k",
    nodeNames: "\u26A0 ask at random if pressed else print forward turn color sleep play is add from remove toList clear in not_in repeat times for to range Comment Program Command Assign Text Op Expression Int Op Op ListAccess AssignList Comma Ask String Clear Print Play Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck Else Repeat For ErrorInvalid",
    maxTerm: 110,
    nodeProps: [
      ["group", 44, "turtle"]
    ],
    skippedNodes: [0, 26],
    repeatNodeCount: 33,
    tokenData: "*x~R!^OY$}YZ&UZp$}pq&Zqr$}rs&`st&etw$}wx&|xz$}z{'R{|'W|}']}!O'b!O!P$}!P!Q'g!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!_!`*s!`#Q$}#RBn$}BnBo']BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FV&FW']&FW;'S$};'S;=`&O<%l?Hb$}?Hb?Hc']?HcO$}~%S^n~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!_$}!`#Q$}#RBn$}Bo&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~&RP;=`<%l$}~&ZO#S~~&`O#R~~&eO#[~~&jSj~OY&eZ;'S&e;'S;=`&v<%lO&e~&yP;=`<%l&e~'RO#`~~'WO#V~~']O#X~~'bOv~~'gO#Y~~'lO#W~~'s!Oq~n~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!`#Q$}#RBn$}BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~*xO#T~",
    tokenizers: [2, new LocalTokenGroup("_~RQYZXwxX~^O#b~~", 14, 109), new LocalTokenGroup("_~RQYZXrsX~^O#^~~", 14, 105)],
    topRules: { "Program": [0, 27] },
    dynamicPrecedences: { "59": -10 },
    specialized: [{ term: 30, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }, { term: 30, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 933
  });

  // static/js/lezer-parsers/level12-parser.ts
  var parser12 = LRParser.deserialize({
    version: 14,
    states: ":WQYQPOOOOQO'#Dr'#DrQYQPOOO!dQPO'#D}OOQO'#Dz'#DzO!xQPO'#DUO#QQPO'#C}O#YQPO'#DqOOQO'#ER'#ERO#eQPO'#D]OOQO'#ES'#ESO$RQPO'#D^OOQO'#ET'#ETO$YQPO'#D_OOQO'#EU'#EUO$bQPO'#DaOOQO'#EV'#EVO$iQPO'#DbOOQO'#EW'#EWO$pQPO'#DcOOQO'#D`'#D`OOQO'#EX'#EXO$wQPO'#DdOOQO'#EY'#EYO%gQPO'#DeOOQO'#E['#E[O%nQPO'#DfOOQO'#E^'#E^O%uQPO'#DgOOQO'#Eb'#EbO%}QPO'#DlOOQO'#Ec'#EcO&YQPO'#DmOOQO'#Ee'#EeO&eQPO'#DnOOQO'#Eh'#EhO&mQPO'#DoOOQO'#Ei'#EiO&uQPO'#DpOOQO'#C|'#C|Q!_QPO'#DsQ&|QPOOOOQO-E7p-E7pOOQO'#Dt'#DtO(TQPO,59kOOQO'#Dv'#DvO(wQPO,59iOOQO'#DR'#DRO(cQPO,59iOOQO-E7x-E7xO)OQPO,59pO)|QPO,59iO#pQPO,59iOOQO'#D}'#D}OOQO-E7{-E7{OOQO-E8P-E8PO*{QPO'#DSO+YOSO'#EoO+bOQO'#EsOOQO'#DT'#DTO+jQPO'#EQOOQO'#DS'#DSOOQO'#EQ'#EQO,_QPO,59xOOQO-E8Q-E8QO,iQPO,59yOOQO-E8R-E8RO,tQPO,59{OOQO-E8S-E8SOOQO,59{,59{O-YQPO,59|OOQO-E8T-E8TOOQO,59|,59|O-nQPO,59}OOQO-E8U-E8UOOQO,59},59}O.SQPO,5:OOOQO-E8V-E8VOOQO,5:O,5:OO.hQPO,5:POOQO-E8W-E8WO.yQPO,5:QOOQO-E8Y-E8YOOQO-E8[-E8[O/[QPO'#DiOOQO'#Dh'#DhOOQO,5:R,5:ROOQO-E8`-E8`OOQO-E8a-E8aO/jQPO,5:XOOQO-E8c-E8cO/oQPO,5:YOOQO-E8f-E8fO/tQPO,5:ZO0PQPO,5:[OOQO-E8g-E8gO0ZQPO,5:_OOQO-E7q-E7qOOQO-E7r-E7rOOQO'#Du'#DuO1hQPO1G/VOOQO1G/V1G/VO2oQPO'#DSOOQO-E7t-E7tO2yQPO'#DwO3nQPO1G/aOOQO'#Dw'#DwO4fQPO1G/TO4pQPO1G/aOOQO'#EP'#EPO4xQPO1G/bOOQO'#D{'#D{O5PQPO1G/[OOOO'#Dx'#DxO5WOSO,5;ZOOQO,5;Z,5;ZOOOO'#Dy'#DyO5`OQO,5;_OOQO,5;_,5;_OOQO'#DX'#DXOOQO'#DY'#DYO%UQPO,5;dO%UQPO,5;dOOQO-E8O-E8OOOQO'#EZ'#EZO5hQPO1G/kOOQO'#E]'#E]O5pQPO1G/lO5xQPO,5:TO6SQPO,5:TOOQO'#E`'#E`O6ZQPO,5:UOOQO'#Ea'#EaO6cQPO,5:VOOQO'#Ed'#EdO6kQPO1G/sO6vQPO1G/tO5PQPO1G/uOOQO-E7s-E7sO7RQPO'#EOO7ZQPO7+${OOQO-E7u-E7uOOQO-E7}-E7}O7fQPO7+$|OOQO-E7y-E7yO7pQPO'#EwOOQO'#Ew'#EwO8nQPO'#DVOOQO7+$v7+$vOOOO-E7v-E7vOOQO1G0u1G0uOOOO-E7w-E7wOOQO1G0y1G0yOOQO1G1O1G1OO9lQPO1G1OOOQO-E8X-E8XOOQO7+%V7+%VOOQO-E8Z-E8ZOOQO7+%W7+%WO:gQPO1G/oOOQO'#E_'#E_O:{QPO1G/oOOQO-E8^-E8^OOQO1G/p1G/pOOQO-E8_-E8_OOQO1G/q1G/qOOQO-E8b-E8bOOQO'#Ef'#EfO;WQPO7+%`OOQO7+%`7+%`OOQO7+%a7+%aO;cQPO,5:jOOQO,5:j,5:jOOQO-E7|-E7|O#pQPO'#D|O;qQPO,59qOOQO-E8]-E8]OOQO-E8d-E8dO<oQPO<<HzOOQO,5:h,5:hOOQO-E7z-E7zOOQO'#Eg'#EgO<tQPOAN>fOOQO'#DV'#DVOOQO-E8e-E8eOOQOG24QG24QPOQO,59q,59qO5PQPO1G/[O=PQPO,59pO=WQPO'#DUO%UQPO,5;dO%UQPO,5;dO=`QPO1G1O",
    stateData: "=j~OnOS#`OS~OSkOUmOVSOXYOY^OZ`O[bO]eO^[O`gObiOdWOgoOiqOlsOmuOrRO#aPO~OQ{O_}O#b!POr!qX#^!qX#a!qX~OVSOr!SO~O_}O#b!PO~Or!VO#^!eX#a!eX~OdWO#^!PX#a!PX~OVSOr!YOt!_O#d!ZO#h![O~OXYO~P#pO^[Or!VO~OY^O~P#pOZ`O~P#pO[bO~P#pO]eO#^!WX#a!WX~P#pOVSOr!_Ot!_O#d!ZO#h![O~O`gO~P%UObiO~P%UOSkOr!vO~OUmO#^!`X#a!`X~OgoOr!{Ot!{O~OiqOr!}O~OlsOr#PO~OmuO~P#pOSkOUmOVSOXYOY^OZ`O[bO]eO^[O`gObiOdWOgoOiqOlsOmuOrRO~OQ{OR#VOr#XOt#XO~OP#aOVSOr#YOt#]O#d!ZO#h![O~O_}O~P(cOW#cO#^xa#axaVxarxatxa#dxa#hxa#mxa#nxa#oxa#pxacxaaxa~O_}O~P#pOQ{OVvXrvXtvX#^vX#avX#dvX#hvX#mvX#nvX#ovX#pvX~OzvXcvXavX~P*TO#e#eO#f#gO~O#i#hO#j#jO~O#m#kO#n#kO#o#lO#p#lOV!tXr!tXt!tX#^!tX#a!tX#d!tX#h!tX~O#^!Qa#a!Qa~P#pOr!VO#^!Ra#a!Ra~O#m#kO#n#kO#o#lO#p#lO#^!Ta#a!Ta~O#m#kO#n#kO#o#lO#p#lO#^!Ua#a!Ua~O#m#kO#n#kO#o#lO#p#lO#^!Va#a!Va~O#m#kO#n#kO#o#lO#p#lO#^!Wa#a!Wa~Oc#pO#m#kO#n#kO#o#lO#p#lO~Oa#rO#m#kO#n#kO#o#lO#p#lO~O_}Oe#vOf#xO#b!PO~Oh#zO~Oe#vO~OW#cO#^!ca#a!ca~O#^!da#a!da~P#pO#aPOS!gaU!gaV!gaX!gaY!gaZ!ga[!ga]!ga^!ga`!gab!gad!gag!gai!gal!gam!gar!ga#^!ga~OR#VO_si#bsiVsirsitsi#^si#asi#dsi#hsizsi#msi#nsi#osi#psicsiasi~Or!qXz!qX~P*TO#m#kO#n#kO#o#lO#p#lOV!kXr!kXt!kX#^!kX#a!kX#d!kX#h!kX~Oz$POVvXrvXtvX#^vX#avX#dvX#hvX#mvX#nvX#ovX#pvX~O#^qi#aqi~P#pOr!VOz$PO~OP#aO~P#pOW#cO~P#pO#e#eO#f$[O~O#i#hO#j$^O~Oc#pOr$bO~Oa#rOr$dO~OT$fO_}O~P%UOT$fO~P%UOe#vOr$iO~Of#xOr$kO~Oh#zO#^!ai#a!ai~Oe#vOk$mOr$oO~Or!VOt$rO~Oz$PO#^}q#a}q~O#^!Oq#a!Oq~P#pO#m#kO#n#kO#o#lO#p#lOz#kX#^#kX#a#kXV#kXr#kXt#kX#d#kX#h#kXc#kXa#kX~Oz$tO#^yX#ayXVyXryXtyX#dyX#hyX#myX#nyX#oyX#pyXcyXayX~O#m#kO#n#kO#o#lO#p#lOV#lir#lit#li#^#li#a#li#d#li#h#lic#lia#li~O#m#kO#n#kO#o#lO#p#lO#^!]i#a!]i~OT$fO#^!]i#a!]i~Ok$mOr$xOt$xO~Or!VOz!ra#^!ra#a!ra~Oz$tO#^ya#ayaVyaryatya#dya#hya#mya#nya#oya#pyacyaaya~Oj${O~Oj${Or%POt%PO~Ozxa~P)OOVSOr%SO~Oz#li~P9lOtr~",
    goto: "0x#mPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP#n#sP#xP$p$y&Q&o'cP'j'z#s#s#s#s#s#s([([([#s#s#s#s(a(d(d(d#s#s#s#s#s#s(g(q(x)Q)W)f)o)u){*s+R+X+n+u+|,[,d,l,t,|-U-^-f-n-t-|.S.[.c.m.s.{/T/Z/c/i/o/wPPPPP0PPPP0PPPP0n&QVxOQyVwOQyUUOQy[!`Zv!a#Q#b$TQ!g_Q!jaQ!mcQ!pfY#^!O!Q!T!U#_X$W#d#}$t%RQ!QRQ!UUR#u!v[!^Zv!a#Q#b$TQ!e_Q!haQ!kcQ!nfQ!qhQ!sjY#[!O!Q!T!U#_W$V#d#}$t%RS$_#m%UQ$`#nS$e#t#uR%W%V!X!_Z_acfhjv!O!Q!T!U!a#Q#_#b#d#m#n#t#u#}$T$t%R%U%VUwOQy!X!_Z_acfhjv!O!Q!T!U!a#Q#_#b#d#m#n#t#u#}$T$t%R%U%VS$Y#d%RR$p#}d#m!^!e!h!k!n!q!s#[$`$eT%U$V%Wd#n!^!e!h!k!n!q!s#[$`$eT%V$V%WVdOQyR!xlR!wlQQOSzQ#SR#SxSyOQR#TyU|R!Y#YR#U|Q#W|R$O#WQ!ORQ!TUU#Z!O!T#tR#t!vW#_!O!Q!T!UR$R#_Q#f!ZR$Z#fQ#i![R$]#i!QTOQZ_acfhjvy!O!Q!T!U!a#Q#_#b#m#n#t#u$TS!RT%T]%T#d#}$t%R%U%VQ#d!SQ#}#PU$U#d#}%RR%R%SQ$u$XR$z$uUVOQyW!WV!c#`$qQ!c]S#`!O!QR$q$PS$Q#]#`R$s$QS#b!O!QR$S#bQ!aZQ#QvU#o!a#Q$TR$T#bUXOQyR!XXUZOQyR!bZU]OQyR!d]U_OQyR!f_UaOQyR!iaUcOQyR!lcUfOQyR!ofUhOQyR!rhQ#q!qR$a#qUjOQyR!tjQ#s!sR$c#sUlOQyR!ulS$g#t#uR$v$gQ#w!vQ#|!}T$h#w#|Q#y!vR$j#yUnOQyR!ynUpOQyR!zpQ#{!{R$l#{UrOQyR!|rQ$n#|R$w$nQ$|$xR%O$|UtOQyR#OtUvOQyR#Rv!X!]Z_acfhjv!O!Q!T!U!a#Q#_#b#d#m#n#t#u#}$T$t%R%U%VS$X#d#}Q$y$tR$}%R",
    nodeNames: "\u26A0 ask at random if pressed else call with print forward turn color sleep play is add from remove toList clear in not_in repeat times for to range define return Comment Program Command Assign Text ListAccess Number Op Expression String Call Arguments Comma Op Op AssignList Ask Clear Print Play Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck Else Repeat For Define Return ErrorInvalid",
    maxTerm: 124,
    nodeProps: [
      ["group", 50, "turtle"]
    ],
    skippedNodes: [0, 30],
    repeatNodeCount: 38,
    tokenData: "1U~R!^OY$}YZ&UZp$}pq&Zqr$}rs&`st&etw$}wx&|xz$}z{'R{|'W|}']}!O'b!O!P$}!P!Q'g!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!_!`1P!`#Q$}#RBn$}BnBo']BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FV&FW']&FW;'S$};'S;=`&O<%l?Hb$}?Hb?Hc']?HcO$}~%S^r~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!_$}!`#Q$}#RBn$}Bo&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~&RP;=`<%l$}~&ZO#a~~&`O#`~~&eO#d~~&jSn~OY&eZ;'S&e;'S;=`&v<%lO&e~&yP;=`<%l&e~'RO#h~~'WO#m~~']O#o~~'bOz~~'gO#p~~'lO#n~~'s!Ot~r~OY$}Zp$}qr$}tw$}xz$}!O!P*s!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!`#Q$}#RBn$}BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~*x!Or~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R-x!R!S-x!S!T-x!T!U-x!U!V-x!V!W-x!W!X-x!X!Y-x!Y!Z-x!Z![-x![!_$}!`#Q$}#RBn$}BoDf$}DfDg-xDgDh-xDhDi-xDiDj-xDjDk-xDkDl-xDlDm-xDmDn-xDnDo-xDoDp-xDpGl$}GlGm-xGmGn-xGnGo-xGoGp-xGpGq-xGqGr-xGrGs-xGsGt-xGtGu-xGuGv-xGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~.P!Ot~r~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R-x!R!S-x!S!T-x!T!U-x!U!V-x!V!W-x!W!X-x!X!Y-x!Y!Z-x!Z![-x![!_$}!`#Q$}#RBn$}BoDf$}DfDg-xDgDh-xDhDi-xDiDj-xDjDk-xDkDl-xDlDm-xDmDn-xDnDo-xDoDp-xDpGl$}GlGm-xGmGn-xGnGo-xGoGp-xGpGq-xGqGr-xGrGs-xGsGt-xGtGu-xGuGv-xGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~1UO#b~",
    tokenizers: [2, new LocalTokenGroup("_~RQYZXwxX~^O#j~~", 14, 117), new LocalTokenGroup("_~RQYZXrsX~^O#f~~", 14, 113)],
    topRules: { "Program": [0, 31] },
    dynamicPrecedences: { "67": -10 },
    specialized: [{ term: 34, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }, { term: 34, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 1311
  });

  // static/js/lezer-parsers/level13-parser.ts
  var parser13 = LRParser.deserialize({
    version: 14,
    states: ";`QYQPOOOOQO'#Dt'#DtQYQPOOO!dQPO'#EPOOQO'#D|'#D|O!xQPO'#DWO#QQPO'#DPO#YQPO'#DsOOQO'#ET'#ETO#eQPO'#D_OOQO'#EU'#EUO$RQPO'#D`OOQO'#EV'#EVO$YQPO'#DaOOQO'#EW'#EWO$bQPO'#DcOOQO'#EX'#EXO$iQPO'#DdOOQO'#EY'#EYO$pQPO'#DeOOQO'#Db'#DbOOQO'#EZ'#EZO$wQPO'#DfOOQO'#E['#E[O%gQPO'#DgOOQO'#E^'#E^O%nQPO'#DhOOQO'#E`'#E`O%uQPO'#DiOOQO'#Eg'#EgO%}QPO'#DnOOQO'#Eh'#EhO&YQPO'#DoOOQO'#Ej'#EjO&eQPO'#DpOOQO'#Em'#EmO&mQPO'#DqOOQO'#En'#EnO&uQPO'#DrOOQO'#DO'#DOQ!_QPO'#DuQ&|QPOOOOQO-E7r-E7rOOQO'#Dv'#DvO(TQPO,59mOOQO'#Dx'#DxO(wQPO,59kOOQO'#DT'#DTO(cQPO,59kOOQO-E7z-E7zO)OQPO,59rO*SQPO,59kO#pQPO,59kOOQO'#EP'#EPOOQO-E7}-E7}OOQO-E8R-E8RO+RQPO'#DUO+fOSO'#EtO+nOQO'#ExOOQO'#DV'#DVO+vQPO'#ESOOQO'#DU'#DUOOQO'#ES'#ESO,kQPO,59zOOQO-E8S-E8SO,uQPO,59{OOQO-E8T-E8TO-QQPO,59}OOQO-E8U-E8UOOQO,59},59}O-fQPO,5:OOOQO-E8V-E8VOOQO,5:O,5:OO-zQPO,5:POOQO-E8W-E8WOOQO,5:P,5:PO.`QPO,5:QOOQO-E8X-E8XOOQO,5:Q,5:QO.tQPO,5:ROOQO-E8Y-E8YO/VQPO,5:SOOQO-E8[-E8[OOQO-E8^-E8^O/hQPO'#DkOOQO'#Dj'#DjO/vQPO,5:TOOQO-E8e-E8eOOQO-E8f-E8fO0UQPO,5:ZOOQO-E8h-E8hO0ZQPO,5:[OOQO-E8k-E8kO0`QPO,5:]O0kQPO,5:^OOQO-E8l-E8lO0uQPO,5:aOOQO-E7s-E7sOOQO-E7t-E7tOOQO'#Dw'#DwO2SQPO1G/XOOQO1G/X1G/XO3aQPO'#DUOOQO-E7v-E7vO3kQPO'#DyO4`QPO1G/cOOQO'#Dy'#DyO5WQPO1G/VO5bQPO1G/cOOQO'#ER'#ERO5jQPO1G/dOOQO'#D}'#D}O5qQPO1G/^OOOO'#Dz'#DzO5xOSO,5;`OOQO,5;`,5;`OOOO'#D{'#D{O6QOQO,5;dOOQO,5;d,5;dOOQO'#DZ'#DZOOQO'#D['#D[O%UQPO,5;iO%UQPO,5;iOOQO-E8Q-E8QOOQO'#E]'#E]O6YQPO1G/mOOQO'#E_'#E_O6bQPO1G/nO6jQPO,5:VO6tQPO,5:VOOQO'#Eb'#EbO6{QPO,5:WOOQO'#Ec'#EcO7TQPO,5:XOOQO'#Ee'#EeO7]QPO'#EdOOQO'#Ef'#EfO7eQPO'#EdO7mQPO1G/oOOQO'#Ei'#EiO7{QPO1G/uO8WQPO1G/vO5qQPO1G/wOOQO-E7u-E7uO8cQPO'#EQO8kQPO7+$}OOQO-E7w-E7wOOQO-E8P-E8PO8vQPO7+%OOOQO-E7{-E7{O9QQPO'#E|OOQO'#E|'#E|O:UQPO'#DXOOQO7+$x7+$xOOOO-E7x-E7xOOQO1G0z1G0zOOOO-E7y-E7yOOQO1G1O1G1OOOQO1G1T1G1TO;YQPO1G1TOOQO-E8Z-E8ZOOQO7+%X7+%XOOQO-E8]-E8]OOQO7+%Y7+%YO<ZQPO1G/qOOQO'#Ea'#EaO<uQPO1G/qOOQO-E8`-E8`OOQO1G/r1G/rOOQO-E8a-E8aOOQO1G/s1G/sOOQO-E8c-E8cOOQO,5;O,5;OOOQO-E8d-E8dOOQO-E8b-E8bOOQO-E8g-E8gOOQO'#Ek'#EkO=WQPO7+%bOOQO7+%b7+%bOOQO7+%c7+%cO=cQPO,5:lOOQO,5:l,5:lOOQO-E8O-E8OO#pQPO'#EOO=qQPO,59sOOQO-E8_-E8_OOQO-E8i-E8iO>uQPO<<H|OOQO,5:j,5:jOOQO-E7|-E7|OOQO'#El'#ElO>zQPOAN>hOOQO'#DX'#DXOOQO-E8j-E8jOOQOG24SG24SPOQO,59s,59sO5qQPO1G/^O?VQPO,59rO?^QPO'#DWO%UQPO,5;iO%UQPO,5;iO?fQPO1G1T",
    stateData: "?p~OpOS#eOS~OSkOUmOXSOZYO[^O]`O^bO_eO`[ObgOdiOfWOioOkqOnsOouOtRO#fPO~OQ{Oa}O#g!POt!sX#c!sX#f!sX~OXSOt!SO~Oa}O#g!PO~Ot!VO#c!gX#f!gX~OfWO#c!RX#f!RX~OXSOt!YOv!_O#i!ZO#m![O~OZYO~P#pO`[Ot!VO~O[^O~P#pO]`O~P#pO^bO~P#pO_eO#c!YX#f!YX~P#pOXSOt!_Ov!_O#i!ZO#m![O~ObgO~P%UOdiO~P%UOSkOt!vO~OUmO#c!bX#f!bX~OioOt!{Ov!{O~OkqOt!}O~OnsOt#PO~OouO~P#pOSkOUmOXSOZYO[^O]`O^bO_eO`[ObgOdiOfWOioOkqOnsOouOtRO~OQ{OR#VOt#XOv#XO~OP#aOXSOt#YOv#]O#i!ZO#m![O~Oa}O~P(cOY#cO#cza#fzaXzatzavza#iza#mza#rza#sza#tza#uzaezaczaVzaWza~Oa}O~P#pOQ{OXxXtxXvxX#cxX#fxX#ixX#mxX#rxX#sxX#txX#uxX~O|xXexXcxXVxXWxX~P*ZO#j#eO#k#gO~O#n#hO#o#jO~O#r#kO#s#kO#t#lO#u#lOX!vXt!vXv!vX#c!vX#f!vX#i!vX#m!vX~O#c!Sa#f!Sa~P#pOt!VO#c!Ta#f!Ta~O#r#kO#s#kO#t#lO#u#lO#c!Va#f!Va~O#r#kO#s#kO#t#lO#u#lO#c!Wa#f!Wa~O#r#kO#s#kO#t#lO#u#lO#c!Xa#f!Xa~O#r#kO#s#kO#t#lO#u#lO#c!Ya#f!Ya~Oe#pO#r#kO#s#kO#t#lO#u#lO~Oc#rO#r#kO#s#kO#t#lO#u#lO~Oa}Og#vOh#xO#g!PO~OV#zOW#|O#c!]a#f!]a~Oj$PO~Og#vO~OY#cO#c!ea#f!ea~O#c!fa#f!fa~P#pO#fPOS!iaU!iaX!iaZ!ia[!ia]!ia^!ia_!ia`!iab!iad!iaf!iai!iak!ian!iao!iat!ia#c!ia~OR#VOaui#guiXuituivui#cui#fui#iui#mui|ui#rui#sui#tui#uuieuicuiVuiWui~Ot!sX|!sX~P*ZO#r#kO#s#kO#t#lO#u#lOX!mXt!mXv!mX#c!mX#f!mX#i!mX#m!mX~O|$UOXxXtxXvxX#cxX#fxX#ixX#mxX#rxX#sxX#txX#uxX~O#csi#fsi~P#pOt!VO|$UO~OP#aO~P#pOY#cO~P#pO#j#eO#k$aO~O#n#hO#o$cO~Oe#pOt$gO~Oc#rOt$iO~OT$kOa}O~P%UOT$kO~P%UOg#vOt$nO~Oh#xOt$pO~OV#zOt!vO~OW#|Ot!vO~OV#zOW#|O#c!]i#f!]i~Oj$PO#c!ci#f!ci~Og#vOm$vOt$xO~Ot!VOv${O~O|$UO#c!Pq#f!Pq~O#c!Qq#f!Qq~P#pO#r#kO#s#kO#t#lO#u#lO|#pX#c#pX#f#pXX#pXt#pXv#pX#i#pX#m#pXe#pXc#pXV#pXW#pX~O|$}O#c{X#f{XX{Xt{Xv{X#i{X#m{X#r{X#s{X#t{X#u{Xe{Xc{XV{XW{X~O#r#kO#s#kO#t#lO#u#lOX#qit#qiv#qi#c#qi#f#qi#i#qi#m#qie#qic#qiV#qiW#qi~O#r#kO#s#kO#t#lO#u#lOV!_iW!_i#c!_i#f!_i~OT$kOV!_iW!_i#c!_i#f!_i~Om$vOt%ROv%RO~Ot!VO|!ta#c!ta#f!ta~O|$}O#c{a#f{aX{at{av{a#i{a#m{a#r{a#s{a#t{a#u{ae{ac{aV{aW{a~Ol%UO~Ol%UOt%YOv%YO~O|za~P)OOXSOt%]O~O|#qi~P;YOvt~",
    goto: "1i#rPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP#s#xP#}P$u%O&V&t'hP'o(P#x#x#x#x#x#x(a(a(a#x#x#x#x(f(m(m(m#x#x#x#x#x#x(r(|)T)])c)q)z*Q*W+O+^+d+y,Q,X,g,o,w-P-X-a-i-q-y.P.X._.g.n.x/O/U/]/d/l/t/z0S0Y0`0hPPPPP0pPPP0pPPP1_&VVxOQyVwOQyUUOQy[!`Zv!a#Q#b$YQ!g_Q!jaQ!mcQ!pfY#^!O!Q!T!U#_X$]#d$S$}%[Q!QRQ!UUR#u!v[!^Zv!a#Q#b$YQ!e_Q!haQ!kcQ!nfQ!qhQ!sjY#[!O!Q!T!U#_W$[#d$S$}%[S$d#m%_Q$e#nS$j#t#uR%a%`!X!_Z_acfhjv!O!Q!T!U!a#Q#_#b#d#m#n#t#u$S$Y$}%[%_%`UwOQy!X!_Z_acfhjv!O!Q!T!U!a#Q#_#b#d#m#n#t#u$S$Y$}%[%_%`S$_#d%[R$y$Sd#m!^!e!h!k!n!q!s#[$e$jT%_$[%ad#n!^!e!h!k!n!q!s#[$e$jT%`$[%aVdOQyQ!xlT$r#{#}V!wl#{#}QQOSzQ#SR#SxSyOQR#TyU|R!Y#YR#U|Q#W|R$T#WQ!ORQ!TUU#Z!O!T#tR#t!vW#_!O!Q!T!UR$W#_Q#f!ZR$`#fQ#i![R$b#i!QTOQZ_acfhjvy!O!Q!T!U!a#Q#_#b#m#n#t#u$YS!RT%^]%^#d$S$}%[%_%`Q#d!SQ$S#PU$Z#d$S%[R%[%]Q%O$^R%T%OUVOQyW!WV!c#`$zQ!c]S#`!O!QR$z$US$V#]#`R$|$VS#b!O!QR$X#bQ!aZQ#QvU#o!a#Q$YR$Y#bUXOQyR!XXUZOQyR!bZU]OQyR!d]U_OQyR!f_UaOQyR!iaUcOQyR!lcUfOQyR!ofUhOQyR!rhQ#q!qR$f#qUjOQyR!tjQ#s!sR$h#sUlOQyR!ulS$l#t#uR%P$lQ#w!vQ$R!}T$m#w$RQ#y!vR$o#yQ$O!xR$t$OS#{!x$OR$q#{S#}!x$OR$s#}UnOQyR!ynUpOQyR!zpQ$Q!{R$u$QUrOQyR!|rQ$w$RR%Q$wQ%V%RR%X%VUtOQyR#OtUvOQyR#Rv!X!]Z_acfhjv!O!Q!T!U!a#Q#_#b#d#m#n#t#u$S$Y$}%[%_%`S$^#d$SQ%S$}R%W%[",
    nodeNames: "\u26A0 ask at random if pressed else and or call with print forward turn color sleep play is add from remove toList clear in not_in repeat times for to range define return Comment Program Command Assign Text ListAccess Number Op Expression String Call Arguments Comma Op Op AssignList Ask Clear Print Play Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck Else Repeat For Define Return ErrorInvalid",
    maxTerm: 129,
    nodeProps: [
      ["group", 52, "turtle"]
    ],
    skippedNodes: [0, 32],
    repeatNodeCount: 41,
    tokenData: "1U~R!^OY$}YZ&UZp$}pq&Zqr$}rs&`st&etw$}wx&|xz$}z{'R{|'W|}']}!O'b!O!P$}!P!Q'g!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!_!`1P!`#Q$}#RBn$}BnBo']BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FV&FW']&FW;'S$};'S;=`&O<%l?Hb$}?Hb?Hc']?HcO$}~%S^t~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!_$}!`#Q$}#RBn$}Bo&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~&RP;=`<%l$}~&ZO#f~~&`O#e~~&eO#i~~&jSp~OY&eZ;'S&e;'S;=`&v<%lO&e~&yP;=`<%l&e~'RO#m~~'WO#r~~']O#t~~'bO|~~'gO#u~~'lO#s~~'s!Ov~t~OY$}Zp$}qr$}tw$}xz$}!O!P*s!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!`#Q$}#RBn$}BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~*x!Ot~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R-x!R!S-x!S!T-x!T!U-x!U!V-x!V!W-x!W!X-x!X!Y-x!Y!Z-x!Z![-x![!_$}!`#Q$}#RBn$}BoDf$}DfDg-xDgDh-xDhDi-xDiDj-xDjDk-xDkDl-xDlDm-xDmDn-xDnDo-xDoDp-xDpGl$}GlGm-xGmGn-xGnGo-xGoGp-xGpGq-xGqGr-xGrGs-xGsGt-xGtGu-xGuGv-xGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~.P!Ov~t~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R-x!R!S-x!S!T-x!T!U-x!U!V-x!V!W-x!W!X-x!X!Y-x!Y!Z-x!Z![-x![!_$}!`#Q$}#RBn$}BoDf$}DfDg-xDgDh-xDhDi-xDiDj-xDjDk-xDkDl-xDlDm-xDmDn-xDnDo-xDoDp-xDpGl$}GlGm-xGmGn-xGnGo-xGoGp-xGpGq-xGqGr-xGrGs-xGsGt-xGtGu-xGuGv-xGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~1UO#g~",
    tokenizers: [2, new LocalTokenGroup("_~RQYZXwxX~^O#o~~", 14, 122), new LocalTokenGroup("_~RQYZXrsX~^O#k~~", 14, 118)],
    topRules: { "Program": [0, 33] },
    dynamicPrecedences: { "69": -10 },
    specialized: [{ term: 36, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }, { term: 36, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 1409
  });

  // static/js/lezer-parsers/level14-parser.ts
  var parser14 = LRParser.deserialize({
    version: 14,
    states: "=QQYQPOOOOQO'#Dz'#DzQYQPOOO!dQPO'#EVOOQO'#ES'#ESO!xQPO'#DWO#QQPO'#DPO#YQPO'#DyOOQO'#EZ'#EZO#eQPO'#D_OOQO'#E['#E[O$RQPO'#D`OOQO'#E]'#E]O$YQPO'#DaOOQO'#E^'#E^O$bQPO'#DcOOQO'#E_'#E_O$iQPO'#DdOOQO'#E`'#E`O$pQPO'#DeOOQO'#Db'#DbOOQO'#Ea'#EaO$wQPO'#DfOOQO'#Eb'#EbO%gQPO'#DgOOQO'#Ed'#EdO%nQPO'#DhOOQO'#Ef'#EfO&WQPO'#DiOOQO'#Em'#EmO&_QPO'#DtOOQO'#En'#EnO&jQPO'#DuOOQO'#Ep'#EpO&uQPO'#DvOOQO'#Es'#EsO&}QPO'#DwOOQO'#Et'#EtO'VQPO'#DxOOQO'#DO'#DOQ!_QPO'#D{Q'^QPOOOOQO-E7x-E7xOOQO'#D|'#D|O(eQPO,59mOOQO'#EO'#EOO)XQPO,59kOOQO'#DT'#DTO(sQPO,59kOOQO-E8Q-E8QO)`QPO,59rO*yQPO,59kO#pQPO,59kOOQO'#EV'#EVOOQO-E8T-E8TOOQO-E8X-E8XO+xQPO'#DUO,rOSO'#EzO,zOQO'#FOOOQO'#DV'#DVO-SQPO'#EYOOQO'#DU'#DUOOQO'#EY'#EYO-wQPO,59zOOQO-E8Y-E8YO.RQPO,59{OOQO-E8Z-E8ZO.^QPO,59}OOQO-E8[-E8[OOQO,59},59}O.rQPO,5:OOOQO-E8]-E8]OOQO,5:O,5:OO/WQPO,5:POOQO-E8^-E8^OOQO,5:P,5:PO/lQPO,5:QOOQO-E8_-E8_OOQO,5:Q,5:QO0QQPO,5:ROOQO-E8`-E8`O0cQPO,5:SOOQO-E8b-E8bO0tQPO'#DlO1iQPO'#DUOOQO-E8d-E8dOOQO'#Dj'#DjO2aQPO,5:TOOQO-E8k-E8kOOQO-E8l-E8lO2oQPO,5:aOOQO-E8n-E8nO2tQPO,5:bOOQO-E8q-E8qO2yQPO,5:cO3UQPO,5:dOOQO-E8r-E8rO3`QPO,5:gOOQO-E7y-E7yOOQO-E7z-E7zOOQO'#D}'#D}O4mQPO1G/XOOQO1G/X1G/XO6ZQPO'#DUOOQO-E7|-E7|O6eQPO'#EPO7YQPO1G/cOOQO'#EP'#EPO8QQPO1G/VO8[QPO1G/cOOQO'#EX'#EXO8dQPO1G/dOOQO'#ET'#ETO8kQPO1G/^OOOO'#EQ'#EQO8rOSO,5;fOOQO,5;f,5;fOOOO'#ER'#ERO8zOQO,5;jOOQO,5;j,5;jOOQO'#DZ'#DZOOQO'#D['#D[O%UQPO,5;oO%UQPO,5;oOOQO-E8W-E8WOOQO'#Ec'#EcO9SQPO1G/mOOQO'#Ee'#EeO9[QPO1G/nO9dQPO,5:WO9kQPO,5:WOOQO'#Dn'#DnO%UQPO,5:XOOQO'#Dp'#DpOOQO'#Dq'#DqO9kQPO,5:ZOOQO'#Eh'#EhO9rQPO,5:^OOQO'#Ei'#EiO9zQPO,5:_O:SQPO,5:VOOQO'#Ek'#EkO:[QPO'#EjOOQO'#El'#ElO:cQPO'#EjO:jQPO1G/oOOQO'#Eo'#EoO:xQPO1G/{O;TQPO1G/|O8kQPO1G/}OOQO-E7{-E7{O;`QPO'#EWO;hQPO7+$}OOQO-E7}-E7}OOQO-E8V-E8VO;sQPO7+%OOOQO-E8R-E8RO;}QPO'#FSOOQO'#FS'#FSO=hQPO'#DXOOQO7+$x7+$xOOOO-E8O-E8OOOQO1G1Q1G1QOOOO-E8P-E8POOQO1G1U1G1UOOQO1G1Z1G1ZO?RQPO1G1ZOOQO-E8a-E8aOOQO7+%X7+%XOOQO-E8c-E8cOOQO7+%Y7+%YO@iQPO1G/rO%UQPO1G/rOATQPO1G/sOAoQPO1G/uO%UQPO1G/uOOQO-E8f-E8fOOQO1G/x1G/xOOQO-E8g-E8gOOQO1G/y1G/yOOQO'#Eg'#EgOBZQPO1G/qOOQO-E8i-E8iOOQO,5;U,5;UOOQO-E8j-E8jOOQO-E8h-E8hOOQO-E8m-E8mOOQO'#Eq'#EqOBlQPO7+%hOOQO7+%h7+%hOOQO7+%i7+%iOBwQPO,5:rOOQO,5:r,5:rOOQO-E8U-E8UO#pQPO'#EUOCVQPO,59sODpQPO7+%^OE[QPO7+%aOOQO-E8e-E8eOOQO-E8o-E8oOEvQPO<<ISOOQO,5:p,5:pOOQO-E8S-E8SOOQO'#Er'#ErOE{QPOAN>nOOQO'#DX'#DXOOQO-E8p-E8pOOQOG24YG24YPOQO,59s,59sO8kQPO1G/^OFWQPO,59rOF_QPO'#DWO%UQPO,5;oO%UQPO,5;oOFgQPO1G1Z",
    stateData: "Fq~OpOS#kOS~OSkOUmOYsO[YO]^O^`O_bO`eOa[ObgOdiOfWOioOkqOnSOouOtRO#lPO~OQ{OX}O#m!POt!yX#i!yX#l!yX~OnSOt!SO~OX}O#m!PO~Ot!VO#i!mX#l!mX~OfWO#i!RX#l!RX~OnSOt!YOv!_O#o!ZO#s![O~O[YO~P#pOa[Ot!VO~O]^O~P#pO^`O~P#pO_bO~P#pO`eO#i!YX#l!YX~P#pOnSOt!_Ov!_O#o!ZO#s![O~ObgO~P%UOdiO~P%UOnSOt!vOv!_O#o!ZO#s![O~OSkO~P%uOUmO#i!hX#l!hX~OioOt!|Ov!|O~OkqOt#OO~OYsOt#QO~OouO~P#pOSkOUmOYsO[YO]^O^`O_bO`eOa[ObgOdiOfWOioOkqOnSOouOtRO~OQ{OR#WOt#YOv#YO~OP#bOnSOt#ZOv#^O#o!ZO#s![O~OX}O~P(sOZ#dO#iza#lzanzatzavza#oza#sza#xza#yza#zza#{zaezaczaXzagzahza#mza#|za#}za$OzaVzaWza~OX}O~P#pOQ{OnxXtxXvxX#ixX#lxX#oxX#sxX#xxX#yxX#zxX#{xX~O|xXexXcxXXxXgxXhxX#mxX#|xX#}xX$OxXVxXWxX~P+QO#p#fO#q#hO~O#t#iO#u#kO~O#x#lO#y#lO#z#mO#{#mOn!|Xt!|Xv!|X#i!|X#l!|X#o!|X#s!|X~O#i!Sa#l!Sa~P#pOt!VO#i!Ta#l!Ta~O#x#lO#y#lO#z#mO#{#mO#i!Va#l!Va~O#x#lO#y#lO#z#mO#{#mO#i!Wa#l!Wa~O#x#lO#y#lO#z#mO#{#mO#i!Xa#l!Xa~O#x#lO#y#lO#z#mO#{#mO#i!Ya#l!Ya~Oe#qO#x#lO#y#lO#z#mO#{#mO~Oc#sO#x#lO#y#lO#z#mO#{#mO~OX}Og#|Oh$OO#m!PO#x#lO#y#lO#z#mO#{#mO#|#wO#}#yO$O#zO~OX}OXxXgxXhxX#mxX#xxX#yxX#zxX#{xX#|xX#}xX$OxX~OV$ROW$TO#i!]a#l!]a~Oj$WO~Og#|O~OZ#dO#i!ka#l!ka~O#i!la#l!la~P#pO#lPOS!oaU!oaY!oa[!oa]!oa^!oa_!oa`!oaa!oab!oad!oaf!oai!oak!oan!oao!oat!oa#i!oa~OR#WOXui#muinuituivui#iui#lui#oui#sui|ui#xui#yui#zui#{uieuicuiguihui#|ui#}ui$OuiVuiWui~Ot!yX|!yX~P+QO#x#lO#y#lO#z#mO#{#mOn!sXt!sXv!sX#i!sX#l!sX#o!sX#s!sX~O|$]OnxXtxXvxX#ixX#lxX#oxX#sxX#xxX#yxX#zxX#{xX~O#isi#lsi~P#pOt!VO|$]O~OP#bO~P#pOZ#dO~P#pO#p#fO#q$hO~O#t#iO#u$jO~Oe#qOt$nO~Oc#sOt$pO~OX}O~P%UO#m!PO~P%UOg#|Ot$wO~Oh$OOt$yO~OT$zOX}O~OV$RO~P%uOW$TO~P%uOV$ROW$TO#i!]i#l!]i~Oj$WO#i!ii#l!ii~Og#|Om%ROt%TO~Ot!VOv%WO~O|$]O#i!Pq#l!Pq~O#i!Qq#l!Qq~P#pO#x#lO#y#lO#z#mO#{#mO|#vX#i#vX#l#vXn#vXt#vXv#vX#o#vX#s#vXe#vXc#vXX#vXg#vXh#vX#m#vX#|#vX#}#vX$O#vXV#vXW#vX~O|%YO#i{X#l{Xn{Xt{Xv{X#o{X#s{X#x{X#y{X#z{X#{{Xe{Xc{XX{Xg{Xh{X#m{X#|{X#}{X$O{XV{XW{X~O#x#lO#y#lO#z#mO#{#mOn#wit#wiv#wi#i#wi#l#wi#o#wi#s#wie#wic#wiX#wig#wih#wi#m#wi#|#wi#}#wi$O#wiV#wiW#wi~O#x#lO#y#lO#z#mO#{#mOV!`iW!`i#i!`i#l!`i~O#x#lO#y#lO#z#mO#{#mOV!aiW!ai#i!ai#l!ai~O#x#lO#y#lO#z#mO#{#mOV!ciW!ci#i!ci#l!ci~OT$zOV!_iW!_i#i!_i#l!_i~Om%ROt%`Ov%`O~Ot!VO|!za#i!za#l!za~O|%YO#i{a#l{an{at{av{a#o{a#s{a#x{a#y{a#z{a#{{ae{ac{aX{ag{ah{a#m{a#|{a#}{a$O{aV{aW{a~O#x#lO#y#lO#z#mO#{#mOV!`qW!`q#i!`q#l!`q~O#x#lO#y#lO#z#mO#{#mOV!cqW!cq#i!cq#l!cq~Ol%cO~Ol%cOt%gOv%gO~O|za~P)`OnSOt%jO~O|#wi~P?ROvt~",
    goto: "3X#xPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP#y$OP$TP${%[&t'j(eP(l)R$O$O$O$O$O$O)h)h)h$O$O$O$O)m)t)t)t)y)t)|)|)t)t$O$O$O$O$O$O*P*Z*b*j*p+S+]+c+i,h,v,|-c-j-q.P.X.a.i.q.y/R/Z/c/i/q/w0P0V0a0g0m0t0{1T1]1c1k1q1w2PPPPPP2XPPP2XPPP2}&tVxOQyVwOQyUUOQy[!`Zv!a#R#c$aQ!g_Q!jaQ!mcQ!pfY#_!O!Q!T!U#`X$d#e$Z%Y%iQ!QRQ!UUQ#v!uQ$r#vR$u#{[!^Zv!a#R#c$aQ!e_Q!haQ!kcQ!nfQ!qhQ!sjU!ul$S$UY#]!O!Q!T!U#`W$c#e$Z%Y%iS$k#n%lQ$l#oS$q#u#vQ$s#xQ$t#{Q%[$rQ%]$uR%n%m!g!_Z_acfhjlv!O!Q!T!U!a#R#`#c#e#n#o#u#v#x#{$S$U$Z$a$r$u%Y%i%l%mUwOQy!g!_Z_acfhjlv!O!Q!T!U!a#R#`#c#e#n#o#u#v#x#{$S$U$Z$a$r$u%Y%i%l%mS$f#e%iR%U$Zn#n!^!e!h!k!n!q!s!u#]$l$q$s$t%[%]T%l$c%nn#o!^!e!h!k!n!q!s!u#]$l$q$s$t%[%]T%m$c%nVdOQyQ!ylT$}$S$UV!xl$S$UR#x!uR#{!uQQOSzQ#TR#TxSyOQR#UyU|R!Y#ZR#V|Q#X|R$[#XQ!ORQ!TUW#[!O!T#u$QQ#u!uR$Q!vW#`!O!Q!T!UR$_#`Q#g!ZR$g#gQ#j![R$i#j!`TOQZ_acfhjlvy!O!Q!T!U!a#R#`#c#n#o#u#v#x#{$S$U$a$r$uS!RT%k]%k#e$Z%Y%i%l%mQ#e!SQ$Z#QU$b#e$Z%iR%i%jQ%Z$eR%b%ZUVOQyW!WV!c#a%VQ!c]S#a!O!QR%V$]S$^#^#aR%X$^S#c!O!QR$`#cQ!aZQ#RvU#p!a#R$aR$a#cUXOQyR!XXUZOQyR!bZU]OQyR!d]U_OQyR!f_UaOQyR!iaUcOQyR!lcUfOQyR!ofUhOQyR!rhQ#r!qR$m#rUjOQyR!tjQ#t!sR$o#tUlOQyR!wlQ${$QR%^${Q#}!uQ$Y#OT$v#}$YQ$P!uR$x$PQ$V!yR%P$VS$S!y$VR$|$SS$U!y$VR%O$UUnOQyR!znUpOQyR!{pQ$X!|R%Q$XUrOQyR!}rQ%S$YR%_%SQ%d%`R%f%dUtOQyR#PtUvOQyR#Sv!g!]Z_acfhjlv!O!Q!T!U!a#R#`#c#e#n#o#u#v#x#{$S$U$Z$a$r$u%Y%i%l%mS$e#e$ZQ%a%YR%e%i",
    nodeNames: "\u26A0 ask at random if pressed else and or is define with print forward turn color sleep play add from remove toList clear in not_in repeat times for to range call return Comment Program Command Assign Text ListAccess Number Op Expression String Call Arguments Comma Op Op AssignList Ask Clear Print Play Turtle Forward Turn Color Sleep Add Remove If Condition PressedCheck EqualityCheck NotEqualCheck Op ComparisonCheck Op Op InListCheck NotInListCheck Else Repeat For Define Return ErrorInvalid",
    maxTerm: 138,
    nodeProps: [
      ["group", 52, "turtle"]
    ],
    skippedNodes: [0, 32],
    repeatNodeCount: 41,
    tokenData: "1e~R!`OY%TYZ&XZp%Tpq&^qr&crs&nst&stw%Twx'[xz%Tz{'a{|'f|}'k}!O'p!O!P%T!P!Q'u!Q!R'z!R!S'z!S!T'z!T!U'z!U!V'z!V!W'z!W!X'z!X!Y'z!Y!Z'z!Z!['z![!^%T!^!_1U!_!`1Z!`!a1`!a#Q%T#RBn%TBnBo'kBoDf%TDfDg'zDgDh'zDhDi'zDiDj'zDjDk'zDkDl'zDlDm'zDmDn'zDnDo'zDoDp'zDpGl%TGlGm'zGmGn'zGnGo'zGoGp'zGpGq'zGqGr'zGrGs'zGsGt'zGtGu'zGuGv'zGv&FV%T&FV&FW'k&FW;'S%T;'S;=`&R<%l?Hb%T?Hb?Hc'k?HcO%T~%Y]t~OY%TZp%Ttw%Txz%T!O!P%T!Q!^%T!a#Q%T#RBn%TBo&FV%T&FW;'S%T;'S;=`&R<%l?Hb%T?HcO%T~&UP;=`<%l%T~&^O#l~~&cO#k~~&fP!_!`&i~&nO#|~~&sO#o~~&xSp~OY&sZ;'S&s;'S;=`'U<%lO&s~'XP;=`<%l&s~'aO#s~~'fO#x~~'kO#z~~'pO|~~'uO#{~~'zO#y~~(R}v~t~OY%TZp%Ttw%Txz%T!O!P+O!Q!R'z!R!S'z!S!T'z!T!U'z!U!V'z!V!W'z!W!X'z!X!Y'z!Y!Z'z!Z!['z![!^%T!a#Q%T#RBn%TBoDf%TDfDg'zDgDh'zDhDi'zDiDj'zDjDk'zDkDl'zDlDm'zDmDn'zDnDo'zDoDp'zDpGl%TGlGm'zGmGn'zGnGo'zGoGp'zGpGq'zGqGr'zGrGs'zGsGt'zGtGu'zGuGv'zGv&FV%T&FW;'S%T;'S;=`&R<%l?Hb%T?HcO%T~+T}t~OY%TZp%Ttw%Txz%T!O!P%T!Q!R.Q!R!S.Q!S!T.Q!T!U.Q!U!V.Q!V!W.Q!W!X.Q!X!Y.Q!Y!Z.Q!Z![.Q![!^%T!a#Q%T#RBn%TBoDf%TDfDg.QDgDh.QDhDi.QDiDj.QDjDk.QDkDl.QDlDm.QDmDn.QDnDo.QDoDp.QDpGl%TGlGm.QGmGn.QGnGo.QGoGp.QGpGq.QGqGr.QGrGs.QGsGt.QGtGu.QGuGv.QGv&FV%T&FW;'S%T;'S;=`&R<%l?Hb%T?HcO%T~.X}v~t~OY%TZp%Ttw%Txz%T!O!P%T!Q!R.Q!R!S.Q!S!T.Q!T!U.Q!U!V.Q!V!W.Q!W!X.Q!X!Y.Q!Y!Z.Q!Z![.Q![!^%T!a#Q%T#RBn%TBoDf%TDfDg.QDgDh.QDhDi.QDiDj.QDjDk.QDkDl.QDlDm.QDmDn.QDnDo.QDoDp.QDpGl%TGlGm.QGmGn.QGnGo.QGoGp.QGpGq.QGqGr.QGrGs.QGsGt.QGtGu.QGuGv.QGv&FV%T&FW;'S%T;'S;=`&R<%l?Hb%T?HcO%T~1ZO$O~~1`O#m~~1eO#}~",
    tokenizers: [2, new LocalTokenGroup("_~RQYZXwxX~^O#u~~", 14, 128), new LocalTokenGroup("_~RQYZXrsX~^O#q~~", 14, 124)],
    topRules: { "Program": [0, 33] },
    dynamicPrecedences: { "75": -10 },
    specialized: [{ term: 36, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }, { term: 36, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 1732
  });

  // static/js/lezer-parsers/level15-parser.ts
  var parser15 = LRParser.deserialize({
    version: 14,
    states: "=pQYQPOOOOQO'#D|'#D|QYQPOOO!gQPO'#EXOOQO'#EU'#EUO!{QPO'#DXO#TQPO'#DQO#]QPO'#D{OOQO'#E]'#E]O#hQPO'#D`OOQO'#E^'#E^O$UQPO'#DaOOQO'#E_'#E_O$]QPO'#DbOOQO'#E`'#E`O$eQPO'#DdOOQO'#Ea'#EaO$lQPO'#DeOOQO'#Eb'#EbO$sQPO'#DfOOQO'#Dc'#DcOOQO'#Ec'#EcO$zQPO'#DgOOQO'#Ed'#EdO%jQPO'#DhOOQO'#Ef'#EfO%qQPO'#DiOOQO'#Eh'#EhO&ZQPO'#DjOOQO'#Eo'#EoO&bQPO'#DuOOQO'#Ep'#EpO&mQPO'#DvOOQO'#Er'#ErO&xQPO'#DwOOQO'#Eu'#EuO'QQPO'#DxOOQO'#Ev'#EvO'YQPO'#DyOOQO'#Ew'#EwO'aQPO'#DzOOQO'#DP'#DPQ!bQPO'#D}Q'hQPOOOOQO-E7z-E7zOOQO'#EO'#EOO(rQPO,59nOOQO'#EQ'#EQO)fQPO,59lOOQO'#DU'#DUO)QQPO,59lOOQO-E8S-E8SO)mQPO,59sO+WQPO,59lO#sQPO,59lOOQO'#EX'#EXOOQO-E8V-E8VOOQO-E8Z-E8ZO,VQPO'#DVO-POSO'#E}O-XOQO'#FROOQO'#DW'#DWO-aQPO'#E[OOQO'#DV'#DVOOQO'#E['#E[O.UQPO,59{OOQO-E8[-E8[O.`QPO,59|OOQO-E8]-E8]O.kQPO,5:OOOQO-E8^-E8^OOQO,5:O,5:OO/PQPO,5:POOQO-E8_-E8_OOQO,5:P,5:PO/eQPO,5:QOOQO-E8`-E8`OOQO,5:Q,5:QO/yQPO,5:ROOQO-E8a-E8aOOQO,5:R,5:RO0_QPO,5:SOOQO-E8b-E8bO0pQPO,5:TOOQO-E8d-E8dO1RQPO'#DmO1vQPO'#DVOOQO-E8f-E8fOOQO'#Dk'#DkO2nQPO,5:UOOQO-E8m-E8mOOQO-E8n-E8nO2|QPO,5:bOOQO-E8p-E8pO3RQPO,5:cOOQO-E8s-E8sO3WQPO,5:dO3cQPO,5:eOOQO-E8t-E8tOOQO-E8u-E8uO3mQPO,5:fO3{QPO,5:iOOQO-E7{-E7{OOQO-E7|-E7|OOQO'#EP'#EPO5]QPO1G/YOOQO1G/Y1G/YO6yQPO'#DVOOQO-E8O-E8OO7TQPO'#ERO7xQPO1G/dOOQO'#ER'#ERO8pQPO1G/WO8zQPO1G/dOOQO'#EZ'#EZO9SQPO1G/eOOQO'#EV'#EVO9ZQPO1G/_OOOO'#ES'#ESO9bOSO,5;iOOQO,5;i,5;iOOOO'#ET'#ETO9jOQO,5;mOOQO,5;m,5;mOOQO'#D['#D[OOQO'#D]'#D]O%XQPO,5;rO%XQPO,5;rOOQO-E8Y-E8YOOQO'#Ee'#EeO9rQPO1G/nOOQO'#Eg'#EgO9zQPO1G/oO:SQPO,5:XO:ZQPO,5:XOOQO'#Do'#DoO%XQPO,5:YOOQO'#Dq'#DqOOQO'#Dr'#DrO:ZQPO,5:[OOQO'#Ej'#EjO:bQPO,5:_OOQO'#Ek'#EkO:jQPO,5:`O:rQPO,5:WOOQO'#Em'#EmO:zQPO'#ElOOQO'#En'#EnO;RQPO'#ElO;YQPO1G/pOOQO'#Eq'#EqO;hQPO1G/|O;sQPO1G/}O9ZQPO1G0OO<OQPO1G0QOOQO-E7}-E7}O<^QPO'#EYO<fQPO7+%OOOQO-E8P-E8POOQO-E8X-E8XO<qQPO7+%POOQO-E8T-E8TO<{QPO'#FVOOQO'#FV'#FVO>fQPO'#DYOOQO7+$y7+$yOOOO-E8Q-E8QOOQO1G1T1G1TOOOO-E8R-E8ROOQO1G1X1G1XOOQO1G1^1G1^O@PQPO1G1^OOQO-E8c-E8cOOQO7+%Y7+%YOOQO-E8e-E8eOOQO7+%Z7+%ZOAgQPO1G/sO%XQPO1G/sOBRQPO1G/tOBmQPO1G/vO%XQPO1G/vOOQO-E8h-E8hOOQO1G/y1G/yOOQO-E8i-E8iOOQO1G/z1G/zOOQO'#Ei'#EiOCXQPO1G/rOOQO-E8k-E8kOOQO,5;W,5;WOOQO-E8l-E8lOOQO-E8j-E8jOOQO-E8o-E8oOOQO'#Es'#EsOCjQPO7+%iOOQO7+%i7+%iOOQO7+%j7+%jOCuQPO,5:tOOQO,5:t,5:tOOQO-E8W-E8WO#sQPO'#EWODTQPO,59tOEnQPO7+%_OFYQPO7+%bOOQO-E8g-E8gOOQO-E8q-E8qOFtQPO<<ITOOQO,5:r,5:rOOQO-E8U-E8UOOQO'#Et'#EtOFyQPOAN>oOOQO'#DY'#DYOOQO-E8r-E8rOOQOG24ZG24ZPOQO,59t,59tO9ZQPO1G/_OGUQPO,59sOG]QPO'#DXO%XQPO,5;rO%XQPO,5;rOGeQPO1G1^",
    stateData: "Go~OqOS#nOS~OSkOUmOYwOZsO]YO^^O_`O`bOaeOb[OcgOeiOgWOjoOlqOoSOpuOuRO#oPO~OQ}OX!PO#p!ROu!{X#l!{X#o!{X~OoSOu!UO~OX!PO#p!RO~Ou!XO#l!oX#o!oX~OgWO#l!SX#o!SX~OoSOu![Ow!aO#r!]O#v!^O~O]YO~P#sOb[Ou!XO~O^^O~P#sO_`O~P#sO`bO~P#sOaeO#l!ZX#o!ZX~P#sOoSOu!aOw!aO#r!]O#v!^O~OcgO~P%XOeiO~P%XOoSOu!xOw!aO#r!]O#v!^O~OSkO~P%xOUmO#l!iX#o!iX~OjoOu#OOw#OO~OlqOu#QO~OZsOu#SO~OpuO~P#sOYwO~P%xOSkOUmOYwOZsO]YO^^O_`O`bOaeOb[OcgOeiOgWOjoOlqOoSOpuOuRO~OQ}OR#[Ou#^Ow#^O~OP#fOoSOu#_Ow#bO#r!]O#v!^O~OX!PO~P)QO[#hO#l{a#o{ao{au{aw{a#r{a#v{a#{{a#|{a#}{a$O{af{ad{aX{ah{ai{a#p{a$P{a$Q{a$R{aV{aW{a~OX!PO~P#sOQ}OoyXuyXwyX#lyX#oyX#ryX#vyX#{yX#|yX#}yX$OyX~O}yXfyXdyXXyXhyXiyX#pyX$PyX$QyX$RyXVyXWyX~P+_O#s#jO#t#lO~O#w#mO#x#oO~O#{#pO#|#pO#}#qO$O#qOo#OXu#OXw#OX#l#OX#o#OX#r#OX#v#OX~O#l!Ta#o!Ta~P#sOu!XO#l!Ua#o!Ua~O#{#pO#|#pO#}#qO$O#qO#l!Wa#o!Wa~O#{#pO#|#pO#}#qO$O#qO#l!Xa#o!Xa~O#{#pO#|#pO#}#qO$O#qO#l!Ya#o!Ya~O#{#pO#|#pO#}#qO$O#qO#l!Za#o!Za~Of#uO#{#pO#|#pO#}#qO$O#qO~Od#wO#{#pO#|#pO#}#qO$O#qO~OX!POh$QOi$SO#p!RO#{#pO#|#pO#}#qO$O#qO$P#{O$Q#}O$R$OO~OX!POXyXhyXiyX#pyX#{yX#|yX#}yX$OyX$PyX$QyX$RyX~OV$VOW$XO#l!^a#o!^a~Ok$[O~Oh$QO~O[#hO#l!la#o!la~O#l!ma#o!ma~P#sOV$VOW$XO#l!na#o!na~O#oPOS!qaU!qaY!qaZ!qa]!qa^!qa_!qa`!qaa!qab!qac!qae!qag!qaj!qal!qao!qap!qau!qa#l!qa~OR#[OXvi#pvioviuviwvi#lvi#ovi#rvi#vvi}vi#{vi#|vi#}vi$Ovifvidvihviivi$Pvi$Qvi$RviVviWvi~Ou!{X}!{X~P+_O#{#pO#|#pO#}#qO$O#qOo!uXu!uXw!uX#l!uX#o!uX#r!uX#v!uX~O}$bOoyXuyXwyX#lyX#oyX#ryX#vyX#{yX#|yX#}yX$OyX~O#lti#oti~P#sOu!XO}$bO~OP#fO~P#sO[#hO~P#sO#s#jO#t$mO~O#w#mO#x$oO~Of#uOu$sO~Od#wOu$uO~OX!PO~P%XO#p!RO~P%XOh$QOu$|O~Oi$SOu%OO~OT%POX!PO~OV$VO~P%xOW$XO~P%xOV$VOW$XO#l!^i#o!^i~Ok$[O#l!ji#o!ji~Oh$QOn%WOu%YO~OV$VOW$XO#l!ni#o!ni~Ou!XOw%]O~O}$bO#l!Qq#o!Qq~O#l!Rq#o!Rq~P#sO#{#pO#|#pO#}#qO$O#qO}#yX#l#yX#o#yXo#yXu#yXw#yX#r#yX#v#yXf#yXd#yXX#yXh#yXi#yX#p#yX$P#yX$Q#yX$R#yXV#yXW#yX~O}%_O#l|X#o|Xo|Xu|Xw|X#r|X#v|X#{|X#||X#}|X$O|Xf|Xd|XX|Xh|Xi|X#p|X$P|X$Q|X$R|XV|XW|X~O#{#pO#|#pO#}#qO$O#qOo#ziu#ziw#zi#l#zi#o#zi#r#zi#v#zif#zid#ziX#zih#zii#zi#p#zi$P#zi$Q#zi$R#ziV#ziW#zi~O#{#pO#|#pO#}#qO$O#qOV!aiW!ai#l!ai#o!ai~O#{#pO#|#pO#}#qO$O#qOV!biW!bi#l!bi#o!bi~O#{#pO#|#pO#}#qO$O#qOV!diW!di#l!di#o!di~OT%POV!`iW!`i#l!`i#o!`i~On%WOu%eOw%eO~Ou!XO}!|a#l!|a#o!|a~O}%_O#l|a#o|ao|au|aw|a#r|a#v|a#{|a#||a#}|a$O|af|ad|aX|ah|ai|a#p|a$P|a$Q|a$R|aV|aW|a~O#{#pO#|#pO#}#qO$O#qOV!aqW!aq#l!aq#o!aq~O#{#pO#|#pO#}#qO$O#qOV!dqW!dq#l!dq#o!dq~Om%hO~Om%hOu%lOw%lO~O}{a~P)mOoSOu%oO~O}#zi~P@POwu~",
    goto: "3u#{PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP#|$RP$WP%O%_&x'o(kP(r)X$R$R$R$R$R$R)n)n)n$R$R$R$R)s)})})}*T)}*W*W)})}$R$R$R$R$R$R$R*Z*e*l*t*z+^+g+m+s,s-R-X-n-u-|.[.d.l.t.|/U/^/f/n/t/|0S0[0b0l0r0|1V1`1h1p1v2O2U2[2d2lPPPPP2tPPP2tPPP3k&xVzOQ{VyOQ{UUOQ{[!bZv!c#T#g$fQ!i_Q!laQ!ocQ!rfY#c!Q!S!V!W#dX$i#i$_%_%nQ!SRQ!WUQ#z!wQ$w#zR$z$P[!`Zv!c#T#g$fQ!g_Q!jaQ!mcQ!pfQ!shQ!ujW!wlx$W$YY#a!Q!S!V!W#dW$h#i$_%_%nS$p#r%qQ$q#sS$v#y#zQ$x#|Q$y$PQ%a$wQ%b$zR%s%r!i!aZ_acfhjlvx!Q!S!V!W!c#T#d#g#i#r#s#y#z#|$P$W$Y$_$f$w$z%_%n%q%rUyOQ{!i!aZ_acfhjlvx!Q!S!V!W!c#T#d#g#i#r#s#y#z#|$P$W$Y$_$f$w$z%_%n%q%rS$k#i%nR%Z$_n#r!`!g!j!m!p!s!u!w#a$q$v$x$y%a%bT%q$h%sn#s!`!g!j!m!p!s!u!w#a$q$v$x$y%a%bT%r$h%sVdOQ{Q!{lQ#WxT%S$W$YX!zlx$W$YR#|!wR$P!wQQOS|Q#XR#XzS{OQR#Y{U!OR![#_R#Z!OQ#]!OR$a#]Q!QRQ!VUW#`!Q!V#y$UQ#y!wR$U!xW#d!Q!S!V!WR$d#dQ#k!]R$l#kQ#n!^R$n#n!bTOQZ_acfhjlvx{!Q!S!V!W!c#T#d#g#r#s#y#z#|$P$W$Y$f$w$zS!TT%p]%p#i$_%_%n%q%rQ#i!UQ$_#SU$g#i$_%nR%n%oQ%`$jR%g%`UVOQ{W!YV!e#e%[Q!e]S#e!Q!SR%[$bS$c#b#eR%^$cS#g!Q!SR$e#gQ!cZQ#TvU#t!c#T$fR$f#gUXOQ{R!ZXUZOQ{R!dZU]OQ{R!f]U_OQ{R!h_UaOQ{R!kaUcOQ{R!ncUfOQ{R!qfUhOQ{R!thQ#v!sR$r#vUjOQ{R!vjQ#x!uR$t#xUlOQ{R!ylQ%Q$UR%c%QQ$R!wQ$^#QT${$R$^Q$T!wR$}$TQ$Z!{Q$`#WT%U$Z$`W$W!{#W$Z$`R%R$WW$Y!{#W$Z$`R%T$YUnOQ{R!|nUpOQ{R!}pQ$]#OR%V$]UrOQ{R#PrQ%X$^R%d%XQ%i%eR%k%iUtOQ{R#RtUvOQ{R#UvUxOQ{R#Vx!i!_Z_acfhjlvx!Q!S!V!W!c#T#d#g#i#r#s#y#z#|$P$W$Y$_$f$w$z%_%n%q%rS$j#i$_Q%f%_R%j%n",
    nodeNames: "\u26A0 ask at random if pressed else and or is while define with print forward turn color sleep play add from remove toList clear in not_in repeat times for to range call return Comment Program Command Assign Text ListAccess Number Op Expression String Call Arguments Comma Op Op AssignList Ask Clear Print Play Turtle Forward Turn Color Sleep Add Remove If Condition PressedCheck EqualityCheck NotEqualCheck Op ComparisonCheck Op Op InListCheck NotInListCheck Else Repeat For Define Return While ErrorInvalid",
    maxTerm: 141,
    nodeProps: [
      ["group", 53, "turtle"]
    ],
    skippedNodes: [0, 33],
    repeatNodeCount: 42,
    tokenData: "1e~R!`OY%TYZ&XZp%Tpq&^qr&crs&nst&stw%Twx'[xz%Tz{'a{|'f|}'k}!O'p!O!P%T!P!Q'u!Q!R'z!R!S'z!S!T'z!T!U'z!U!V'z!V!W'z!W!X'z!X!Y'z!Y!Z'z!Z!['z![!^%T!^!_1U!_!`1Z!`!a1`!a#Q%T#RBn%TBnBo'kBoDf%TDfDg'zDgDh'zDhDi'zDiDj'zDjDk'zDkDl'zDlDm'zDmDn'zDnDo'zDoDp'zDpGl%TGlGm'zGmGn'zGnGo'zGoGp'zGpGq'zGqGr'zGrGs'zGsGt'zGtGu'zGuGv'zGv&FV%T&FV&FW'k&FW;'S%T;'S;=`&R<%l?Hb%T?Hb?Hc'k?HcO%T~%Y]u~OY%TZp%Ttw%Txz%T!O!P%T!Q!^%T!a#Q%T#RBn%TBo&FV%T&FW;'S%T;'S;=`&R<%l?Hb%T?HcO%T~&UP;=`<%l%T~&^O#o~~&cO#n~~&fP!_!`&i~&nO$P~~&sO#r~~&xSq~OY&sZ;'S&s;'S;=`'U<%lO&s~'XP;=`<%l&s~'aO#v~~'fO#{~~'kO#}~~'pO}~~'uO$O~~'zO#|~~(R}w~u~OY%TZp%Ttw%Txz%T!O!P+O!Q!R'z!R!S'z!S!T'z!T!U'z!U!V'z!V!W'z!W!X'z!X!Y'z!Y!Z'z!Z!['z![!^%T!a#Q%T#RBn%TBoDf%TDfDg'zDgDh'zDhDi'zDiDj'zDjDk'zDkDl'zDlDm'zDmDn'zDnDo'zDoDp'zDpGl%TGlGm'zGmGn'zGnGo'zGoGp'zGpGq'zGqGr'zGrGs'zGsGt'zGtGu'zGuGv'zGv&FV%T&FW;'S%T;'S;=`&R<%l?Hb%T?HcO%T~+T}u~OY%TZp%Ttw%Txz%T!O!P%T!Q!R.Q!R!S.Q!S!T.Q!T!U.Q!U!V.Q!V!W.Q!W!X.Q!X!Y.Q!Y!Z.Q!Z![.Q![!^%T!a#Q%T#RBn%TBoDf%TDfDg.QDgDh.QDhDi.QDiDj.QDjDk.QDkDl.QDlDm.QDmDn.QDnDo.QDoDp.QDpGl%TGlGm.QGmGn.QGnGo.QGoGp.QGpGq.QGqGr.QGrGs.QGsGt.QGtGu.QGuGv.QGv&FV%T&FW;'S%T;'S;=`&R<%l?Hb%T?HcO%T~.X}w~u~OY%TZp%Ttw%Txz%T!O!P%T!Q!R.Q!R!S.Q!S!T.Q!T!U.Q!U!V.Q!V!W.Q!W!X.Q!X!Y.Q!Y!Z.Q!Z![.Q![!^%T!a#Q%T#RBn%TBoDf%TDfDg.QDgDh.QDhDi.QDiDj.QDjDk.QDkDl.QDlDm.QDmDn.QDnDo.QDoDp.QDpGl%TGlGm.QGmGn.QGnGo.QGoGp.QGpGq.QGqGr.QGrGs.QGsGt.QGtGu.QGuGv.QGv&FV%T&FW;'S%T;'S;=`&R<%l?Hb%T?HcO%T~1ZO$R~~1`O#p~~1eO$Q~",
    tokenizers: [2, new LocalTokenGroup("_~RQYZXwxX~^O#x~~", 14, 131), new LocalTokenGroup("_~RQYZXrsX~^O#t~~", 14, 127)],
    topRules: { "Program": [0, 34] },
    dynamicPrecedences: { "77": -10 },
    specialized: [{ term: 37, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }, { term: 37, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 1776
  });

  // static/js/lezer-parsers/level16-parser.ts
  var parser16 = LRParser.deserialize({
    version: 14,
    states: "<nQYQPOOOOQO'#D}'#D}QYQPOOO!gQPO'#E_OOQO'#EU'#EUO!{QPO'#DYO#TQPO'#DPOOQO'#E['#E[O#]QPO'#DaOOQO'#E]'#E]O#yQPO'#DbOOQO'#E^'#E^O$QQPO'#DcO$YQPO'#D|OOQO'#E`'#E`O$eQPO'#DeOOQO'#Ea'#EaO$lQPO'#DfOOQO'#Eb'#EbO$sQPO'#DgOOQO'#Dd'#DdOOQO'#Ec'#EcO$zQPO'#DhOOQO'#Ed'#EdO%XQPO'#DiOOQO'#Ef'#EfO%`QPO'#DjOOQO'#Eh'#EhO%xQPO'#DkOOQO'#Eo'#EoO&PQPO'#DvOOQO'#Ep'#EpO&[QPO'#DwOOQO'#Er'#ErO&gQPO'#DxOOQO'#Eu'#EuO&oQPO'#DyOOQO'#Ev'#EvO&wQPO'#DzOOQO'#Ew'#EwO'OQPO'#D{OOQO'#DO'#DOQ!bQPO'#EOQ'VQPOOOOQO-E7{-E7{OOQO'#DS'#DSO(aQPO,59mOOQO'#EQ'#EQO(lQPO,59kOOQO'#DV'#DVO(yQPO,59kOOQO-E8S-E8SO)TQPO,59tO*nQPO,59kO#hQPO,59kOOQO-E8Y-E8YO+mQPO'#DWO,gOSO'#FPO,oOQO'#FTOOQO'#DX'#DXO,wQPO'#EZOOQO'#DW'#DWO-lQPO,59|OOQO-E8Z-E8ZOOQO-E8[-E8[OOQO'#E_'#E_O-vQPO,59}OOQO-E8]-E8]O.RQPO,5:POOQO-E8^-E8^O.gQPO,5:QOOQO-E8_-E8_O.{QPO,5:ROOQO-E8`-E8`O/aQPO,5:SOOQO-E8a-E8aO/uQPO,5:TOOQO-E8b-E8bO0WQPO,5:UOOQO-E8d-E8dO0iQPO'#DWO0pQPO'#DnOOQO-E8f-E8fOOQO'#Dl'#DlO1eQPO,5:VOOQO-E8m-E8mOOQO-E8n-E8nO1sQPO,5:cOOQO-E8p-E8pO1xQPO,5:dOOQO-E8s-E8sO1}QPO,5:eO2YQPO,5:fOOQO-E8t-E8tOOQO-E8u-E8uO2dQPO,5:gO2rQPO,5:jOOQO-E7|-E7|OOQO'#EP'#EPO4SQPO1G/XO4VQPO1G/XOOQO-E8O-E8OO4[QPO'#ERO5PQPO1G/VO5ZQPO1G/eOOQO'#EY'#EYO5fQPO1G/fOOQO'#EV'#EVO5mQPO1G/`OOOO'#ES'#ESO5tOSO,5;kOOQO,5;k,5;kOOOO'#ET'#ETO5|OQO,5;oOOQO,5;o,5;oOOQO'#D]'#D]OOQO'#D^'#D^O#hQPO,5;sO#hQPO,5;sOOQO-E8X-E8XOOQO'#Ee'#EeO6UQPO1G/oOOQO'#Eg'#EgO6^QPO1G/pO6fQPO,5:XO*nQPO,5:YO6nQPO,5:YOOQO'#Dp'#DpO#hQPO,5:ZOOQO'#Dr'#DrOOQO'#Ds'#DsO6nQPO,5:]OOQO'#Ej'#EjO6uQPO,5:`OOQO'#Ek'#EkO6}QPO,5:aOOQO'#Em'#EmO7VQPO'#ElOOQO'#En'#EnO7^QPO'#ElO7eQPO1G/qOOQO'#Eq'#EqO7sQPO1G/}O8OQPO1G0OO5mQPO1G0PO8ZQPO1G0ROOQO-E7}-E7}OOQO'#DU'#DUOOQO7+$s7+$sOOQO-E8P-E8PO8iQPO7+%POOQO-E8W-E8WO8nQPO7+%QOOQO-E8T-E8TOOQO7+$z7+$zO:`QPO'#DZOOOO-E8Q-E8QOOQO1G1V1G1VOOOO-E8R-E8ROOQO1G1Z1G1ZOOQO1G1_1G1_O:gQPO1G1_OOQO-E8c-E8cOOQO7+%Z7+%ZOOQO-E8e-E8eOOQO7+%[7+%[OOQO'#Ei'#EiO;}QPO1G/sO<`QPO1G/tO#hQPO1G/tO<zQPO1G/uO=fQPO1G/wO#hQPO1G/wOOQO-E8h-E8hOOQO1G/z1G/zOOQO-E8i-E8iOOQO1G/{1G/{OOQO-E8k-E8kOOQO,5;W,5;WOOQO-E8l-E8lOOQO-E8j-E8jOOQO-E8o-E8oOOQO'#Es'#EsO>QQPO7+%jOOQO7+%j7+%jOOQO7+%k7+%kO>]QPO'#EXO>hQPO<<HkO>pQPO,59uO#hQPO'#EWOOQO-E8g-E8gO@ZQPO7+%`O@uQPO7+%cOOQO-E8q-E8qOAaQPO<<IUOOQO,5:s,5:sOOQO-E8V-E8VOOQOAN>VAN>VOOQO-E8U-E8UOAfQPO,5:rOOQO'#Et'#EtOCPQPOAN>pOOQO-E8r-E8rOOQOG24[G24[POQO,59u,59uOC[QPO'#DZO5mQPO1G/`OCcQPO,59tOCjQPO'#DYO#hQPO,5;sO#hQPO,5;sOCrQPO1G1_",
    stateData: "C|~OpOS#nOS~ORkOTmOXwOYsO[XO]^O^`O_bO`eOaZObgOdiOfVOioOkqOnSOouOtRO#oPO~OW!PO#p}O#r!ROt#RX#l#RX#o#RX~OnSOt!UO~OW!PO#r!RO~OfVO#l!TX#o!TX~OnSOt!YOw!_O#t!ZO#x![O~O[XO~P#hOaZOt!cO~Ot!cO#l!pX#o!pX~O]^O~P#hO^`O~P#hO_bO~P#hO`eO#l![X#o![X~P#hObgO~P#hOdiO~P#hOnSOt!rOw!_O#t!ZO#x![O~ORkO~P%gOTmO#l!jX#o!jX~OioOt!yOw!yO~OkqOt!{O~OYsOt!}O~OouO~P#hOXwO~P%gORkOTmOXwOYsO[XO]^O^`O_bO`eOaZObgOdiOfVOioOkqOnSOouOtRO~OQ#UOt#WOw#WO~OP#]OW!PO#p}O~P#hOP#]O#p}O~P#hOZ#_O#l|a#o|an|at|aw|a#t|a#x|a#||a#}|a$O|a$P|ae|ac|aW|ag|ah|a#r|a$Q|a$R|a$S|aU|aV|a~OW!PO~P#hO#p}O#|zX#}zX$OzX$PzXWzXgzXhzX#rzX$QzX$RzX$SzX~OnzXtzXwzX#lzX#ozX#tzX#xzXezXczX!OzXUzXVzX~P*uO#u#aO#v#cO~O#y#dO#z#fO~O#|#gO#}#gO$O#hO$P#hOn!}Xt!}Xw!}X#l!}X#o!}X#t!}X#x!}X~O#l!Ua#o!Ua~P#hOt!cO#l!Va#o!Va~O#|#gO#}#gO$O#hO$P#hO#l!Xa#o!Xa~O#|#gO#}#gO$O#hO$P#hO#l!Ya#o!Ya~O#|#gO#}#gO$O#hO$P#hO#l!Za#o!Za~O#|#gO#}#gO$O#hO$P#hO#l![a#o![a~Oe#lO#|#gO#}#gO$O#hO$P#hO~Oc#nO#|#gO#}#gO$O#hO$P#hO~OW!PO~P*uOW!POg#xOh#zO#r!RO#|#gO#}#gO$O#hO$P#hO$Q#sO$R#uO$S#vO~OU#|OV$OO#l!_a#o!_a~Oj$RO~Og#xO~OZ#_O#l!ma#o!ma~O#l!na#o!na~P#hOU#|OV$OO#l!oa#o!oa~O#oPOR!raT!raX!raY!ra[!ra]!ra^!ra_!ra`!raa!rab!rad!raf!rai!rak!ran!rao!rat!ra#l!ra~OQ#UO#q$XO~O#|#gO#}#gO$O#hO$P#hOn!uXt!uXw!uX#l!uX#o!uX#t!uX#x!uX~O#lsi#osi~P#hOw$[O#t!ZO#x![O~OP#]O~P#hOZ#_O~P#hO#u#aO#v$cO~O#y#dO#z$eO~Oe#lOt$iO~Oc#nOt$kO~OS$lOW!PO~O#r!RO~P#hOg#xOt$tO~Oh#zOt$vO~OU#|O~P%gOV$OO~P%gOU#|OV$OO#l!_i#o!_i~Oj$RO#l!ki#o!ki~Og#xOm$|Ot%OO~OU#|OV$OO#l!oi#o!oi~O!O%QO~O#l!Sq#o!Sq~P#hO#|#gO#}#gO$O#hO$P#hO#l}X#o}Xn}Xt}Xw}X#t}X#x}Xe}Xc}XW}Xg}Xh}X#r}X$Q}X$R}X$S}XU}XV}X~O!O%TO~P8xO#|#gO#}#gO$O#hO$P#hOn#{it#{iw#{i#l#{i#o#{i#t#{i#x#{ie#{ic#{iW#{ig#{ih#{i#r#{i$Q#{i$R#{i$S#{iU#{iV#{i~OS$lOU!aiV!ai#l!ai#o!ai~O#|#gO#}#gO$O#hO$P#hOU!biV!bi#l!bi#o!bi~O#|#gO#}#gO$O#hO$P#hOU!ciV!ci#l!ci#o!ci~O#|#gO#}#gO$O#hO$P#hOU!eiV!ei#l!ei#o!ei~Om$|Ot%YOw%YO~Ow%ZO#t!ZO#x![O~O!O%QO#q$XO~O!O%TO#l}a#o}an}at}aw}a#t}a#x}a#|}a#}}a$O}a$P}ae}ac}aW}ag}ah}a#r}a$Q}a$R}a$S}aU}aV}a~O#|#gO#}#gO$O#hO$P#hOU!bqV!bq#l!bq#o!bq~O#|#gO#}#gO$O#hO$P#hOU!eqV!eq#l!eq#o!eq~Ol%`O~O#|#gO#}#gO$O#hO$P#hO!O!za#l!za#o!zan!zat!zaw!za#t!za#x!zae!zac!zaW!zag!zah!za#r!za$Q!za$R!za$S!zaU!zaV!za~Ol%`Ot%cOw%cO~O!O}X~P8xO!O|a~P)TOnSOt%gO~O!O#{i~P:gOwt~",
    goto: "4O#|PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP#}$SP$X%TP%^%e%t'c(`)[P)c)z$S$S$S$S$S$S*c*c*c$S$S$S$S*h*r*r*r*x*r*{*{*r*r$S$S$S$S$S$S$S+O+Y+a+g+y,S,Y,`-`-n-t-z.R.a.i.q.y/V/_/g/o/w0P0V0_0e0m0s0}1T1_1h1q1y2R2X2a2g2m2u2}PPPPPPP3VPPP3VPPP$^VzOQ{VyOQ{UUOQ{!i!_Y_acfhjlvx!Q!S!V!W!`#O#Z#^#`#i#j#q#r#t#w#}$P$U$^$o$r%T%f%i%jU!OR!Y!rT#[!Q!SS$Y#V#WR%]%RQ!SRQ!WUQ#r!sQ$o#rR$r#w[!^Yv!`#O#^$^Q!f_Q!haQ!jcQ!lfQ!nhQ!pjW!slx#}$PY#Y!Q!S!V!W#ZS$a#`$US$f#i%iQ$g#jS$n#q#rQ$p#tQ$q#wQ%V$oQ%W$rQ%_%TQ%e%fR%k%j!h!_Y_acfhjlvx!Q!S!V!W!`#O#Z#^#`#i#j#q#r#t#w#}$P$U$^$o$r%T%f%i%jQ$[#[R%Z%QUyOQ{!i!_Y_acfhjlvx!Q!S!V!W!`#O#Z#^#`#i#j#q#r#t#w#}$P$U$^$o$r%T%f%i%jS$`#`%fR%P$Un#i!^!f!h!j!l!n!p!s#Y$g$n$p$q%V%WX%i$a%_%e%kn#j!^!f!h!j!l!n!p!s#Y$g$n$p$q%V%WX%j$a%_%e%kVdOQ{Q!vlQ#RxT$x#}$PX!ulx#}$PR#t!sR#w!sQQOS|Q#SR#SzS{OQR#T{Q#V!OR$W#VQ!QRQ!VUW#X!Q!V#p#qQ#p!rR#q!sW#Z!Q!S!V!WR$Z#ZQ#b!ZR$b#bQ#e![R$d#e!bTOQY_acfhjlvx{!Q!S!V!W!`#O#Z#^#i#j#q#r#t#w#}$P$^$o$rS!TT%h]%h#`$U%T%f%i%jQ#`!UQ$U!}U$_#`$U%fR%f%gQ%S$aR%^%SQ%R$[R%[%RS#^!Q!SR$]#^Q!`YQ#OvU#k!`#O$^R$^#^UWOQ{R!XWUYOQ{R!aYU[OQ{R!b[U]OQ{Q!d[T!e]!dU_OQ{R!g_UaOQ{R!iaUcOQ{R!kcUfOQ{R!mfUhOQ{R!ohQ#m!nR$h#mUjOQ{R!qjQ#o!pR$j#oUlOQ{R!tlQ$m#pR%U$mQ#y!sQ$T!{T$s#y$TQ#{!sR$u#{Q$Q!vQ$V#RT$z$Q$VW#}!v#R$Q$VR$w#}W$P!v#R$Q$VR$y$PUnOQ{R!wnUpOQ{R!xpQ$S!yR${$SUrOQ{R!zrQ$}$TR%X$}Q%a%YR%b%aUtOQ{R!|tUvOQ{R#PvUxOQ{R#Qx!m!]Y_acfhjlvx!Q!S!V!W!`#O#Z#[#^#`#i#j#q#r#t#w#}$P$U$^$o$r%Q%T%f%i%j",
    nodeNames: "\u26A0 ask random if pressed else and or is while define with print forward turn color sleep play add from remove toList clear in not_in repeat times for to range call return Comment Program Command Assign Text ListAccess Op Number Op Op Expression String Call Arguments Comma Op Op AssignList Ask Clear Print Play Turtle Forward Turn Color Sleep Add Remove If Condition PressedCheck EqualityCheck NotEqualCheck Op ComparisonCheck Op Op InListCheck NotInListCheck Else Repeat For Define Return While ErrorInvalid",
    maxTerm: 142,
    nodeProps: [
      ["group", 54, "turtle"]
    ],
    skippedNodes: [0, 32],
    repeatNodeCount: 41,
    tokenData: "2U~R!cOY%^YZ&eZp%^pq&jqr&ors&zst'Ptw%^wx'hxz%^z{'m{|'r|}'w}!O'|!O!P%^!P!Q(R!Q!R(W!R!S(W!S!T(W!T!U(W!U!V(W!V!W(W!W!X(W!X!Y(W!Y!Z(W!Z![(W![!^%^!^!_1k!_!`1p!`!a1u!a!}%^!}#O1z#O#P%^#P#Q2P#QBn%^BnBo'wBoDf%^DfDg(WDgDh(WDhDi(WDiDj(WDjDk(WDkDl(WDlDm(WDmDn(WDnDo(WDoDp(WDpGl%^GlGm(WGmGn(WGnGo(WGoGp(WGpGq(WGqGr(WGrGs(WGsGt(WGtGu(WGuGv(WGv&FV%^&FV&FW'w&FW;'S%^;'S;=`&_<%l?Hb%^?Hb?Hc'w?HcO%^~%c^t~OY%^Zp%^tw%^xz%^!O!P%^!Q!^%^!a!}%^#O#P%^#QBn%^Bo&FV%^&FW;'S%^;'S;=`&_<%l?Hb%^?HcO%^~&bP;=`<%l%^~&jO#o~~&oO#n~~&rP!_!`&u~&zO$Q~~'PO#t~~'USp~OY'PZ;'S'P;'S;=`'b<%lO'P~'eP;=`<%l'P~'mO#x~~'rO#|~~'wO$O~~'|O!O~~(RO$P~~(WO#}~~(_!Ow~t~OY%^Zp%^tw%^xz%^!O!P+_!Q!R(W!R!S(W!S!T(W!T!U(W!U!V(W!V!W(W!W!X(W!X!Y(W!Y!Z(W!Z![(W![!^%^!a!}%^#O#P%^#QBn%^BoDf%^DfDg(WDgDh(WDhDi(WDiDj(WDjDk(WDkDl(WDlDm(WDmDn(WDnDo(WDoDp(WDpGl%^GlGm(WGmGn(WGnGo(WGoGp(WGpGq(WGqGr(WGrGs(WGsGt(WGtGu(WGuGv(WGv&FV%^&FW;'S%^;'S;=`&_<%l?Hb%^?HcO%^~+d!Ot~OY%^Zp%^tw%^xz%^!O!P%^!Q!R.d!R!S.d!S!T.d!T!U.d!U!V.d!V!W.d!W!X.d!X!Y.d!Y!Z.d!Z![.d![!^%^!a!}%^#O#P%^#QBn%^BoDf%^DfDg.dDgDh.dDhDi.dDiDj.dDjDk.dDkDl.dDlDm.dDmDn.dDnDo.dDoDp.dDpGl%^GlGm.dGmGn.dGnGo.dGoGp.dGpGq.dGqGr.dGrGs.dGsGt.dGtGu.dGuGv.dGv&FV%^&FW;'S%^;'S;=`&_<%l?Hb%^?HcO%^~.k!Ow~t~OY%^Zp%^tw%^xz%^!O!P%^!Q!R.d!R!S.d!S!T.d!T!U.d!U!V.d!V!W.d!W!X.d!X!Y.d!Y!Z.d!Z![.d![!^%^!a!}%^#O#P%^#QBn%^BoDf%^DfDg.dDgDh.dDhDi.dDiDj.dDjDk.dDkDl.dDlDm.dDmDn.dDnDo.dDoDp.dDpGl%^GlGm.dGmGn.dGnGo.dGoGp.dGpGq.dGqGr.dGrGs.dGsGt.dGtGu.dGuGv.dGv&FV%^&FW;'S%^;'S;=`&_<%l?Hb%^?HcO%^~1pO$S~~1uO#r~~1zO$R~~2PO#p~~2UO#q~",
    tokenizers: [2, new LocalTokenGroup("_~RQYZXwxX~^O#z~~", 14, 133), new LocalTokenGroup("_~RQYZXrsX~^O#v~~", 14, 129)],
    topRules: { "Program": [0, 33] },
    dynamicPrecedences: { "78": -10 },
    specialized: [{ term: 36, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }, { term: 36, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 1605
  });

  // static/js/lezer-parsers/level17-parser.ts
  var parser17 = LRParser.deserialize({
    version: 14,
    states: ">xQYQPOOOOQO'#EQ'#EQQYQPOOO!jQPO'#EbOOQO'#EX'#EXO#OQPO'#DZO#WQPO'#DQOOQO'#E_'#E_O#`QPO'#DbOOQO'#E`'#E`O#|QPO'#DcOOQO'#Ea'#EaO$TQPO'#DdO$]QPO'#EPOOQO'#Ec'#EcO$hQPO'#DfOOQO'#Ed'#EdO$oQPO'#DgOOQO'#Ee'#EeO$vQPO'#DhOOQO'#De'#DeOOQO'#Ef'#EfO$}QPO'#DiOOQO'#Eg'#EgO%[QPO'#DjOOQO'#Ei'#EiO%cQPO'#DkOOQO'#Ek'#EkO%{QPO'#DlOOQO'#Er'#ErO&SQPO'#DxOOQO'#Es'#EsO&[QPO'#DyOOQO'#Eu'#EuO&gQPO'#DzOOQO'#Ex'#ExO&oQPO'#D{OOQO'#Ey'#EyO&wQPO'#D|OOQO'#Ez'#EzO'OQPO'#D}OOQO'#E{'#E{O'VQPO'#EOOOQO'#DP'#DPQ!eQPO'#ERQ'^QPOOOOQO-E8O-E8OOOQO'#DT'#DTO(kQPO,59nOOQO'#ET'#ETO(vQPO,59lOOQO'#DW'#DWO)TQPO,59lOOQO-E8V-E8VO)_QPO,59uO*{QPO,59lO#kQPO,59lOOQO-E8]-E8]O+zQPO'#DXO,wOSO'#FTO-POQO'#FXOOQO'#DY'#DYO-XQPO'#E^OOQO'#DX'#DXO-|QPO,59}OOQO-E8^-E8^OOQO-E8_-E8_OOQO'#Eb'#EbO.WQPO,5:OOOQO-E8`-E8`O.cQPO,5:QOOQO-E8a-E8aO.wQPO,5:ROOQO-E8b-E8bO/]QPO,5:SOOQO-E8c-E8cO/qQPO,5:TOOQO-E8d-E8dO0VQPO,5:UOOQO-E8e-E8eO0hQPO,5:VOOQO-E8g-E8gO0yQPO'#DXO1QQPO'#DoOOQO-E8i-E8iOOQO'#Dm'#DmO1uQPO,5:WOOQO'#Dw'#DwOOQO-E8p-E8pOOQO,5:d,5:dOOQO-E8q-E8qO2QQPO,5:eOOQO-E8s-E8sO2VQPO,5:fOOQO-E8v-E8vO2[QPO,5:gO2dQPO,5:hOOQO-E8w-E8wOOQO-E8x-E8xO1uQPO,5:iOOQO-E8y-E8yO1uQPO,5:jO2nQPO,5:mOOQO-E8P-E8POOQO'#ES'#ESO4RQPO1G/YO4UQPO1G/YOOQO-E8R-E8RO4ZQPO'#EUO5OQPO1G/WO5YQPO1G/fOOQO'#E]'#E]O5eQPO1G/gOOQO'#EY'#EYO5lQPO1G/aOOOO'#EV'#EVO5sOSO,5;oOOQO,5;o,5;oOOOO'#EW'#EWO5{OQO,5;sOOQO,5;s,5;sOOQO'#D^'#D^OOQO'#D_'#D_O#kQPO,5;wO#kQPO,5;wOOQO-E8[-E8[OOQO'#Eh'#EhO6TQPO1G/pOOQO'#Ej'#EjO6]QPO1G/qO6eQPO,5:YO*{QPO,5:ZO6mQPO,5:ZOOQO'#Dq'#DqO#kQPO,5:[OOQO'#Ds'#DsOOQO'#Dt'#DtO6mQPO,5:^OOQO'#Em'#EmO6tQPO,5:aOOQO'#En'#EnO6|QPO,5:bOOQO'#Ep'#EpO7UQPO'#EoOOQO'#Eq'#EqO7]QPO'#EoO1uQPO1G/rOOQO1G/r1G/rOOQO'#Et'#EtO7dQPO1G0PO7oQPO1G0QO5lQPO1G0ROOQO1G0R1G0RO1uQPO1G0TOOQO1G0T1G0TO1uQPO1G0UOOQO1G0U1G0UOOQO-E8Q-E8QOOQO'#DV'#DVOOQO7+$t7+$tOOQO-E8S-E8SO7zQPO7+%QOOQO-E8Z-E8ZO8PQPO7+%ROOQO-E8W-E8WOOQO7+${7+${O9tQPO'#D[OOOO-E8T-E8TOOQO1G1Z1G1ZOOOO-E8U-E8UOOQO1G1_1G1_OOQO1G1c1G1cO9{QPO1G1cOOQO-E8f-E8fOOQO7+%[7+%[OOQO-E8h-E8hOOQO7+%]7+%]OOQO'#El'#ElO;fQPO1G/tO;tQPO1G/uO#kQPO1G/uO<]QPO1G/vO<tQPO1G/xO#kQPO1G/xOOQO-E8k-E8kOOQO1G/{1G/{OOQO-E8l-E8lOOQO1G/|1G/|OOQO-E8n-E8nOOQO,5;Z,5;ZOOQO-E8o-E8oOOQO-E8m-E8mOOQO7+%^7+%^OOQO-E8r-E8rOOQO'#Ev'#EvO=]QPO7+%lO&VQPO7+%lO&VQPO7+%mOOQO7+%o7+%oOOQO7+%p7+%pO=hQPO'#E[O=sQPO<<HlO={QPO,59vO#kQPO'#EZOOQO-E8j-E8jO?iQPO7+%aO@QQPO7+%dOOQO-E8t-E8tO@iQPO<<IWOOQO<<IW<<IWOOQO<<IX<<IXOOQO,5:v,5:vOOQO-E8Y-E8YOOQOAN>WAN>WOOQO-E8X-E8XO@nQPO,5:uOOQO'#Ew'#EwOB[QPOAN>rOOQO-E8u-E8uO&VQPOG24^POQO,59v,59vOOQOLD)xLD)xOBgQPO'#D[O5lQPO1G/aOBnQPO,59uOBuQPO'#DZO#kQPO,5;wO#kQPO,5;wOB}QPO1G1c",
    stateData: "CX~OqOS#rOS~ORkOTmOXwOYyOZsO]XO^^O_`O`bOaeObZOcgOeiOgVOjoOlqOoSOpuOuRO#sPO~OW!RO#t!PO#v!TOu#UX#p#UX#s#UX~OoSOu!WO~OW!RO#v!TO~OgVO#p!UX#s!UX~OoSOu![Ox!aO#x!]O#|!^O~O]XO~P#kObZOu!eO~Ou!eO#p!sX#s!sX~O^^O~P#kO_`O~P#kO`bO~P#kOaeO#p!]X#s!]X~P#kOcgO~P#kOeiO~P#kOoSOu!tOx!aO#x!]O#|!^O~ORkO~P%jOTmO$X!yO~OjoOu!}Ox!}O~OlqOu#PO~OZsOu#RO~OpuO~P#kOXwO~P%jOYyO~P%jORkOTmOXwOYyOZsO]XO^^O_`O`bOaeObZOcgOeiOgVOjoOlqOoSOpuOuRO~OQ#[Ou#^Ox#^O~OP#cOW!RO#t!PO~P#kOP#cO#t!PO~P#kO[#eO#p}a#s}ao}au}ax}a#x}a#|}a$Q}a$R}a$S}a$T}af}ad}aW}ah}ai}a#v}a$U}a$V}a$W}aU}aV}a$X}a~OW!RO~P#kO#t!PO$Q{X$R{X$S{X$T{XW{Xh{Xi{X#v{X$U{X$V{X$W{X~Oo{Xu{Xx{X#p{X#s{X#x{X#|{Xf{Xd{X!P{XU{XV{X$X{X~P+SO#y#gO#z#iO~O#}#jO$O#lO~O$Q#mO$R#mO$S#nO$T#nOo#QXu#QXx#QX#p#QX#s#QX#x#QX#|#QX~O#p!Va#s!Va~P#kOu!eO#p!Wa#s!Wa~O$Q#mO$R#mO$S#nO$T#nO#p!Ya#s!Ya~O$Q#mO$R#mO$S#nO$T#nO#p!Za#s!Za~O$Q#mO$R#mO$S#nO$T#nO#p![a#s![a~O$Q#mO$R#mO$S#nO$T#nO#p!]a#s!]a~Of#rO$Q#mO$R#mO$S#nO$T#nO~Od#tO$Q#mO$R#mO$S#nO$T#nO~OW!RO~P+SOW!ROh$OOi$QO#v!TO$Q#mO$R#mO$S#nO$T#nO$U#yO$V#{O$W#|O~OU$SOV$UO$X!yO~Ok$YO~Oh$OO~O[#eO$X!yO~O#p!pa#s!pa~P#kO#sPOR!uaT!uaX!uaY!uaZ!ua]!ua^!ua_!ua`!uaa!uab!uac!uae!uag!uaj!ual!uao!uap!uau!ua#p!ua~OQ#[O#u$dO~O$Q#mO$R#mO$S#nO$T#nOo!xXu!xXx!xX#p!xX#s!xX#x!xX#|!xX~O#pti#sti~P#kOx$gO#x!]O#|!^O~OP#cO~P#kO[#eO~P#kO#y#gO#z$nO~O#}#jO$O$pO~Of#rOu$tO~Od#tOu$vO~OS$wOW!RO~O#v!TO~P#kOh$OOu%PO~Oi$QOu%RO~OU$SO~P%jOV$UO~P%jOk$YO#p!mi#s!mi~Oh$OOn%YOu%[O~O!P%`O~O#p!Tq#s!Tq~P#kO$Q#mO$R#mO$S#nO$T#nO#p!OX#s!OX$X!OXo!OXu!OXx!OX#x!OX#|!OXf!OXd!OXW!OXh!OXi!OX#v!OX$U!OX$V!OX$W!OXU!OXV!OX~O!P%cO~P8ZO$Q#mO$R#mO$S#nO$T#nOo$Piu$Pix$Pi#p$Pi#s$Pi#x$Pi#|$Pif$Pid$PiW$Pih$Pii$Pi#v$Pi$U$Pi$V$Pi$W$PiU$PiV$Pi$X$Pi~OS$wOU!biV!bi$X!bi~O$Q#mO$R#mO$S#nO$T#nOU!ciV!ci$X!ci~O$Q#mO$R#mO$S#nO$T#nOU!diV!di$X!di~O$Q#mO$R#mO$S#nO$T#nOU!fiV!fi$X!fi~On%YOu%hOx%hO~Ox%kO#x!]O#|!^O~O!P%`O#u$dO~O!P%cO#p!Oa#s!Oa$X!Oao!Oau!Oax!Oa#x!Oa#|!Oa$Q!Oa$R!Oa$S!Oa$T!Oaf!Oad!OaW!Oah!Oai!Oa#v!Oa$U!Oa$V!Oa$W!OaU!OaV!Oa~O$Q#mO$R#mO$S#nO$T#nOU!cqV!cq$X!cq~O$Q#mO$R#mO$S#nO$T#nOU!fqV!fq$X!fq~Om%pO~O$Q#mO$R#mO$S#nO$T#nO!P!}a#p!}a#s!}a$X!}ao!}au!}ax!}a#x!}a#|!}af!}ad!}aW!}ah!}ai!}a#v!}a$U!}a$V!}a$W!}aU!}aV!}a~Om%pOu%sOx%sO~O!P!OX~P8ZO!P}a~P)_OoSOu%xO~O!P$Pi~P9{Oxu~",
    goto: "5a$QPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP$R$WP$]%YP%c%j%y'i(g)dP)k*S$W$W$W$W$W$W*k*k*k$W$W$W$W*p*}*}*}+U*}+X+X*}*}+[$W$W$W$W$W$W$W$W+},X,`,f,x-R-X-_.`.n.t.z/R/a/i/q/y0V0_0g0o0w1P1V1_1e1m1s1}2T2c2n2y3R3Z3a3i3o3u3}4V4_PPPPPPP4gPPP4gPPP$bV|OQ}V{OQ}UUOQ}!k!aY_acfhjlvxz!S!U!X!Y!b#S#a#d#f#o#p#w#x#z#}$T$V$]$i$z$}%c%w%z%{U!QR![!tT#b!S!US$e#]#^R%m%aQ!URQ!YUQ#x!uQ$z#xR$}#}[!`Yv!b#S#d$iQ!h_Q!jaQ!lcQ!nfQ!phQ!rjY!ulxz$T$VY#`!S!U!X!Y#aS$l#f$]S$q#o%zQ$r#pS$y#w#xQ${#zQ$|#}Q%e$zQ%f$}Q%o%cQ%v%wR%|%{!j!aY_acfhjlvxz!S!U!X!Y!b#S#a#d#f#o#p#w#x#z#}$T$V$]$i$z$}%c%w%z%{Q$g#bR%k%`U{OQ}!k!aY_acfhjlvxz!S!U!X!Y!b#S#a#d#f#o#p#w#x#z#}$T$V$]$i$z$}%c%w%z%{S$k#f%wR%]$]n#o!`!h!j!l!n!p!r!u#`$r$y${$|%e%fX%z$l%o%v%|n#p!`!h!j!l!n!p!r!u#`$r$y${$|%e%fX%{$l%o%v%|VdOQ}Q!xlQ#VxQ#XzT%T$T$VZ!wlxz$T$VR#z!uR#}!uQ!{nQ$X!xQ$^#RQ$`#VQ$b#XQ%W$WQ%^$_Q%_$aQ%i%[Q%j%]R%u%sQQOS!OQ#YR#Y|S}OQR#Z}Q#]!QR$c#]Q!SRQ!XUW#_!S!X#v#wQ#v!tR#w!uW#a!S!U!X!YR$f#aQ#h!]R$m#hQ#k!^R$o#k!dTOQY_acfhjlvxz}!S!U!X!Y!b#S#a#d#o#p#w#x#z#}$T$V$i$z$}S!VT%y]%y#f$]%c%w%z%{Q#f!WQ$]#RU$j#f$]%wR%w%xQ%b$lR%n%bQ%a$gR%l%aS#d!S!UR$h#dQ!bYQ#SvU#q!b#S$iR$i#dUWOQ}R!ZWUYOQ}R!cYU[OQ}R!d[U]OQ}Q!f[T!g]!fU_OQ}R!i_UaOQ}R!kaUcOQ}R!mcUfOQ}R!ofUhOQ}R!qhQ#s!pR$s#sUjOQ}R!sjQ#u!rR$u#uUlOQ}R!vlQ$x#vR%d$xQ$P!uQ$[#PT%O$P$[Q$R!uR%Q$RQ$W!xQ$_#VQ$a#XV%V$W$_$a[$T!x#V#X$W$_$aR%S$T[$V!x#V#X$W$_$aR%U$VUnOQ}R!znUpOQ}R!|pQ$Z!}R%X$ZUrOQ}R#OrQ%Z$[R%g%ZQ%q%hR%r%qUtOQ}R#QtUvOQ}R#TvUxOQ}R#UxUzOQ}R#Wz!o!_Y_acfhjlvxz!S!U!X!Y!b#S#a#b#d#f#o#p#w#x#z#}$T$V$]$i$z$}%`%c%w%z%{",
    nodeNames: "\u26A0 ask random if pressed else and or is while elif define with print forward turn color sleep play add from remove toList clear in not_in repeat times for to range call return Comment Program Command Assign Text ListAccess Op Number Op Op Expression String Call Arguments Comma Op Op AssignList Ask Clear Print Play Turtle Forward Turn Color Sleep Add Remove If Condition PressedCheck EqualityCheck NotEqualCheck Op ComparisonCheck Op Op InListCheck NotInListCheck Op Else Repeat For Define Return While Elif ErrorInvalid",
    maxTerm: 147,
    nodeProps: [
      ["group", 55, "turtle"]
    ],
    skippedNodes: [0, 33],
    repeatNodeCount: 42,
    tokenData: "2a~R!dOY%aYZ&kZp%apq&pqr&urs'Qst'Vtw%awx'nxz%az{'s{|'x|}'}}!O(S!O!P%a!P!Q(X!Q!R(^!R!S(^!S!T(^!T!U(^!U!V(^!V!W(^!W!X(^!X!Y(^!Y!Z(^!Z![(^![!]1q!]!^%a!^!_1v!_!`1{!`!a2Q!a!}%a!}#O2V#O#P%a#P#Q2[#QBn%aBnBo'}BoDf%aDfDg(^DgDh(^DhDi(^DiDj(^DjDk(^DkDl(^DlDm(^DmDn(^DnDo(^DoDp(^DpGl%aGlGm(^GmGn(^GnGo(^GoGp(^GpGq(^GqGr(^GrGs(^GsGt(^GtGu(^GuGv(^Gv&FV%a&FV&FW'}&FW;'S%a;'S;=`&e<%l?Hb%a?Hb?Hc'}?HcO%a~%f_u~OY%aZp%atw%axz%a!O!P%a!Q![%a!]!^%a!a!}%a#O#P%a#QBn%aBo&FV%a&FW;'S%a;'S;=`&e<%l?Hb%a?HcO%a~&hP;=`<%l%a~&pO#s~~&uO#r~~&xP!_!`&{~'QO$U~~'VO#x~~'[Sq~OY'VZ;'S'V;'S;=`'h<%lO'V~'kP;=`<%l'V~'sO#|~~'xO$Q~~'}O$S~~(SO!P~~(XO$T~~(^O$R~~(e!Ox~u~OY%aZp%atw%axz%a!O!P+e!Q!R(^!R!S(^!S!T(^!T!U(^!U!V(^!V!W(^!W!X(^!X!Y(^!Y!Z(^!Z![(^!]!^%a!a!}%a#O#P%a#QBn%aBoDf%aDfDg(^DgDh(^DhDi(^DiDj(^DjDk(^DkDl(^DlDm(^DmDn(^DnDo(^DoDp(^DpGl%aGlGm(^GmGn(^GnGo(^GoGp(^GpGq(^GqGr(^GrGs(^GsGt(^GtGu(^GuGv(^Gv&FV%a&FW;'S%a;'S;=`&e<%l?Hb%a?HcO%a~+j!Ou~OY%aZp%atw%axz%a!O!P%a!Q!R.j!R!S.j!S!T.j!T!U.j!U!V.j!V!W.j!W!X.j!X!Y.j!Y!Z.j!Z![.j!]!^%a!a!}%a#O#P%a#QBn%aBoDf%aDfDg.jDgDh.jDhDi.jDiDj.jDjDk.jDkDl.jDlDm.jDmDn.jDnDo.jDoDp.jDpGl%aGlGm.jGmGn.jGnGo.jGoGp.jGpGq.jGqGr.jGrGs.jGsGt.jGtGu.jGuGv.jGv&FV%a&FW;'S%a;'S;=`&e<%l?Hb%a?HcO%a~.q!Ox~u~OY%aZp%atw%axz%a!O!P%a!Q!R.j!R!S.j!S!T.j!T!U.j!U!V.j!V!W.j!W!X.j!X!Y.j!Y!Z.j!Z![.j!]!^%a!a!}%a#O#P%a#QBn%aBoDf%aDfDg.jDgDh.jDhDi.jDiDj.jDjDk.jDkDl.jDlDm.jDmDn.jDnDo.jDoDp.jDpGl%aGlGm.jGmGn.jGnGo.jGoGp.jGpGq.jGqGr.jGrGs.jGsGt.jGtGu.jGuGv.jGv&FV%a&FW;'S%a;'S;=`&e<%l?Hb%a?HcO%a~1vO$X~~1{O$W~~2QO#v~~2VO$V~~2[O#t~~2aO#u~",
    tokenizers: [2, new LocalTokenGroup("_~RQYZXwxX~^O$O~~", 14, 137), new LocalTokenGroup("_~RQYZXrsX~^O#z~~", 14, 133)],
    topRules: { "Program": [0, 34] },
    dynamicPrecedences: { "81": -10 },
    specialized: [{ term: 37, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }, { term: 37, get: (value, stack) => extendKeyword(value, stack) << 1 | 1, external: extendKeyword, extend: true }],
    tokenPrec: 1570
  });

  // static/js/lezer-parsers/level18-parser.ts
  var parser18 = LRParser.deserialize({
    version: 14,
    states: "?OQYQPOOOOQO'#EO'#EOQYQPOOO!gQPO'#E]O#OQPO'#C}OOQO'#EY'#EYO#WQPO'#DaOOQO'#EZ'#EZO#cQPO'#DbOOQO'#E['#E[O#kQPO'#DcO#sQPO'#D}OOQO'#E^'#E^O$OQPO'#DeOOQO'#E_'#E_O$aQPO'#DfOOQO'#E`'#E`O$rQPO'#DgOOQO'#Dd'#DdOOQO'#Ea'#EaO%TQPO'#DhOOQO'#Eb'#EbO%lQPO'#DiOOQO'#Ed'#EdO%}QPO'#DjOOQO'#Ef'#EfO&`QPO'#DkOOQO'#El'#ElO&qQPO'#DvOOQO'#Em'#EmO&yQPO'#DwOOQO'#Eo'#EoO'UQPO'#DxOOQO'#Er'#ErO'^QPO'#DyOOQO'#Es'#EsO'fQPO'#DzOOQO'#Eu'#EuO'nQPO'#D{OOQO'#Ev'#EvO(PQPO'#D|OOQO'#C|'#C|Q!bQPO'#EPQ(bQPOOOOQO-E7|-E7|OOQO'#DQ'#DQO)lQPO,59kOOQO'#ER'#ERO*]QPO,59iOOQO'#DT'#DTOOQO'#DX'#DXO*dQPO,59rO)wQPO,59iO*uQPO,59iO$RQPO,59iOOQO-E8W-E8WOOQO-E8X-E8XO*dQPO,59|OOQO-E8Y-E8YOOQO'#E]'#E]O+WQPO,59}OOQO-E8Z-E8ZO,ZQPO'#DUO-WOSO'#FOO-`OQO'#FSOOQO'#DV'#DVO-hQPO,5:POOQO'#DU'#DUOOQO-E8[-E8[O-|QPO,5:QOOQO-E8]-E8]O.bQPO,5:ROOQO-E8^-E8^O.vQPO,5:SOOQO-E8_-E8_O/[QPO,5:TOOQO-E8`-E8`O/mQPO,5:UOOQO-E8b-E8bO0OQPO'#DUO0VQPO'#DnOOQO-E8d-E8dOOQO'#Dl'#DlO0wQPO,5:VOOQO'#Du'#DuOOQO-E8j-E8jOOQO,5:b,5:bOOQO-E8k-E8kO1SQPO,5:cOOQO-E8m-E8mO1XQPO,5:dOOQO-E8p-E8pO#fQPO,5:eO#fQPO'#DWOOQO-E8q-E8qOOQO'#Et'#EtO1^QPO,5:fOOQO-E8s-E8sO0wQPO,5:gOOQO-E8t-E8tO0wQPO,5:hO1iQPO,5:kOOQO-E7}-E7}OOQO'#EQ'#EQO2yQPO1G/VO2|QPO1G/VOOQO-E8P-E8PO3RQPO'#ESO3sQPO1G/TO4XQPO1G/eOOQO'#EX'#EXO4dQPO1G/fOOQO'#D['#D[OOQO1G/^1G/^O*pQPO1G/^O4lQPO'#DYOOQO1G/h1G/hO*pQPO1G/hOOOO'#ET'#ETO5QOSO,5;jOOQO,5;j,5;jOOOO'#EU'#EUO5YOQO,5;nOOQO,5;n,5;nOOQO'#D]'#D]OOQO'#D^'#D^O$RQPO,5;tO$RQPO,5;tOOQO'#Ec'#EcO5bQPO1G/oOOQO'#Ee'#EeO5jQPO1G/pO5rQPO,5:XO*uQPO,5:YO5zQPO,5:YOOQO'#Dp'#DpO$RQPO,5:ZOOQO'#Dr'#DrOOQO'#Ds'#DsO5zQPO,5:]OOQO'#Eh'#EhO6]QPO,5:`OOQO'#Ej'#EjO6eQPO'#EiOOQO'#Ek'#EkO6vQPO'#EiO0wQPO1G/qOOQO1G/q1G/qOOQO'#En'#EnO7XQPO1G/}OOQO'#Ep'#EpO7dQPO1G0OO*dQPO1G0POOQO-E8r-E8rO0wQPO1G0ROOQO1G0R1G0RO0wQPO1G0SOOQO1G0S1G0SOOQO-E8O-E8OOOQO'#DS'#DSOOQO7+$q7+$qOOQO-E8Q-E8QO7oQPO7+%POOQO-E8V-E8VO*dQPO7+%QOOQO7+$x7+$xO7tQPO,59tO$RQPO'#EVOOQO7+%S7+%SOOOO-E8R-E8ROOQO1G1U1G1UOOOO-E8S-E8SOOQO1G1Y1G1YOOQO1G1`1G1`O7|QPO1G1`OOQO-E8a-E8aOOQO7+%Z7+%ZOOQO-E8c-E8cOOQO7+%[7+%[OOQO'#Eg'#EgO9gQPO1G/sO9uQPO1G/tO$RQPO1G/tO:^QPO1G/uO:uQPO1G/wO$RQPO1G/wOOQO-E8f-E8fOOQO1G/z1G/zOOQO-E8h-E8hOOQO,5;T,5;TOOQO-E8i-E8iOOQO-E8g-E8gOOQO7+%]7+%]OOQO-E8l-E8lOOQO-E8n-E8nOOQO'#Eq'#EqO;^QPO7+%jO&tQPO7+%jO&tQPO7+%kO*pQPO7+%kOOQO7+%m7+%mOOQO7+%n7+%nO;fQPO'#EWO;qQPO<<HkOOQO<<Hl<<HlO*pQPO<<HlOOQO-E8T-E8TO;yQPO,5:qOOQO-E8e-E8eO<_QPO7+%`O<vQPO7+%cOOQO-E8o-E8oO=_QPO<<IUOOQO<<IU<<IUOOQO<<IV<<IVO&tQPO<<IVOOQO,5:r,5:rOOQO-E8U-E8UOOQOAN>VAN>VOOQOAN>WAN>WO=gQPOAN>pOOQOAN>qAN>qO=lQPOG24[O=tQPOLD)vO&tQPO!$'MbO=|QPO!$'MbOOQO!)9B|!)9B|O*pQPO!)9B|O&tQPO!.K8hOOQO!4/.S!4/.S",
    stateData: ">X~OnOS#mOS~OPVOScOTXOV[OW^OX`OYeOZgO]TO^iO_kOemOhuOiqOjsOkoOmwOrRO#nPO~OQ!PO#o}O#q!RO#z!SOr#PX#k#PX#n#PX~OQ!PO#q!RO~O]TO#k!TX#n!TX~OPVO#z!SO~OTXOr!]O~Or!]O#k!qX#n!qX~OV[Or!`Ou!eO#s!aO#w!bO~OW^Or!`Ou!eO#s!aO#w!bO~OX`Or!`Ou!eO#s!aO#w!bO~OScOr!`Ou!eO#s!aO#w!bO#k![X#n![X~OYeOr!`Ou!eO#s!aO#w!bO~OZgOr!`Ou!eO#s!aO#w!bO~O^iOr!qOu!eO#s!aO#w!bO~O_kO$U!vO~OemOr!zOu!zO~OkoOr!|O~OiqOr#OO~OjsOr#PO~OhuOr!qOu!eO#s!aO#w!bO~OmwOr!qOu!eO#s!aO#w!bO~OPVOScOTXOV[OW^OX`OYeOZgO]TO^iO_kOemOhuOiqOjsOkoOmwOrRO~OU#ZOr#]Ou#]O~OR#bOr!`Ou!eO#o}O#s!aO#w!bO~OQ!PO~P)wOr!`Ou!eO#s!aO#w!bO#{#dO~OQ!POr!`Ou!eO#s!aO#w!bO~Or!]O#k!Va#n!Va~O#o}O#z!SO#}xX$OxX$PxX$QxXQxXcxX#qxX$RxX$SxX$TxX~O#kxX#nxXlxX[xXrxXuxX#sxX#wxX}xX#{xX`xXaxX$UxX~P+cO#t#jO#u#lO~O#x#mO#y#oO~O#}#pO$O#pO$P#qO$Q#qO#k!Xa#n!Xa~O#}#pO$O#pO$P#qO$Q#qO#k!Ya#n!Ya~O#}#pO$O#pO$P#qO$Q#qO#k!Za#n!Za~O#}#pO$O#pO$P#qO$Q#qO#k![a#n![a~Ol#tO#}#pO$O#pO$P#qO$Q#qO~O[#vO#}#pO$O#pO$P#qO$Q#qO~OQ!PO~P+cOQ!POc$QO#q!RO#}#pO$O#pO$P#qO$Q#qO$R#{O$S#}O$T$OO~O`$SOa$UO$U!vO~Of$YO~Od$[O~Or#PO#k!na#n!na~O#nPOP!saS!saT!saV!saW!saX!saY!saZ!sa]!sa^!sa_!sae!sah!sai!saj!sak!sam!sar!sa#k!sa~OU#ZO#p$eO~O#}#pO$O#pO$P#qO$Q#qOr!vXu!vX#k!vX#n!vX#s!vX#w!vX~Or!`Ou!eO#s!aO#w!bO#kqi#nqi~Ou$hO#s!aO#w!bO~OR#bO#z!SO~O}$mO#}#pO$O#pO$P#qO$Q#qO#{|X~O#t#jO#u$pO~O#x#mO#y$rO~Ol#tOr$vO~O[#vOr$xO~OQ!POb$yO~Or!`Ou!eO#q!RO#s!aO#w!bO~Oc$QOr%RO~O`$SOr!qOu!eO#s!aO#w!bO~Oa$UOr!qOu!eO#s!aO#w!bO~Of$YO#k!ki#n!ki~Od$[Og%ZOr%]O~O}%bO~O}$mO#{|a~O#}#pO$O#pO$P#qO$Q#qO#k#|i#n#|il#|i[#|iQ#|ic#|i#q#|i$R#|i$S#|i$T#|ir#|iu#|i#s#|i#w#|i}#|i#{#|i`#|ia#|i$U#|i~Ob$yO`!aia!ai$U!ai~O#}#pO$O#pO$P#qO$Q#qO`!bia!bi$U!bi~O#}#pO$O#pO$P#qO$Q#qO`!cia!ci$U!ci~O#}#pO$O#pO$P#qO$Q#qO`!eia!ei$U!ei~Og%ZO#z!SO~Ou%pO#s!aO#w!bO~O}%bO#p$eO~O#}#pO$O#pO$P#qO$Q#qO}!ya#{!ya~O#}#pO$O#pO$P#qO$Q#qO`!bqa!bq$U!bq~O#}#pO$O#pO$P#qO$Q#qO`!eqa!eq$U!eq~Or%tOu%tO~O}%vO~Or%wOu%wO~O}%yO#{#dO~Or%{Ou%{O~Our~",
    goto: "3t#}PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP$O$TP$Y%OP%X%`%o'Q'w(q)TP)a*P*c$T$T$T$T$T$T*u*u*u$T$T$T$T*z+X+X+X+`+X+c+c+X+f$T$T$T$T$T$T$T$T,[,f,m,s-V-`-f-l-r-x.P.X.a.i.u.}/V/_/g/o/u/}0T0]0c0i0w1S1_1g1o1u1}2T2Z2c2k2q2yPPPPPPP3RPPP3RPPPPP$_VzOQ{VyOQ{USOQ{!]!e]_adfhjvx!Q!T!U!V!W!Z#`#r#s#y#z#|$P$T$V$^$j$m$|%PU!OR!`!qT#a!Q!US$f#[#]R%r%cQ!URQ!WSQ#z!rQ$|#zR%P$PQ!d]Q!g_Q!iaQ!kdQ!mfQ!ohY!rjvx$T$VY#_!Q!U!V!W#`W#g!T!Z$^$jQ$s#rQ$t#sS${#y#zQ$}#|Q%O$PQ%g$mQ%i$|R%j%P![!e]_adfhjvx!Q!T!U!V!W!Z#`#r#s#y#z#|$P$T$V$^$j$m$|%PQ$h#aR%p%bUyOQ{![!e]_adfhjvx!Q!T!U!V!W!Z#`#r#s#y#z#|$P$T$V$^$j$m$|%PT#Rt#SW!TR!`!q#PQ!ZWQ$^#OQ$j#cR%l%[Q#f!TQ#i!ZQ%_$^R%e$jQ#e!TQ#h!ZQ$k#fQ$n#iQ%^$^Q%d$jQ%o%_Q%s%eQ%x%wR%|%{q#r!d!g!i!k!m!o!r#_#g$t${$}%O%g%i%jq#s!d!g!i!k!m!o!r#_#g$t${$}%O%g%i%jVbOQ{Q!ujQ#UvQ#WxT%T$T$VZ!tjvx$T$VR#|!rR$P!rQ!xlQ$X!uQ$a#UQ$c#WQ%W$WQ%`$`Q%a$bQ%m%]Q%n%^Q%u%oQ%z%xR%}%|QQOS|Q#XR#XzS{OQR#Y{Q#[!OR$d#[Q!QRQ!VSW#^!Q!V#x#yQ#x!qR#y!rW#`!Q!U!V!WR$g#`Q#k!aR$o#kQ#n!bR$q#nQ$l#gR%f$lQ%c$hR%q%cS#c!Q!UR$i#cUUOQ{R!XUUWOQ{R!YWUYOQ{R![YUZOQ{Q!^YT!_Z!^U]OQ{R!f]U_OQ{R!h_UaOQ{R!jaUdOQ{R!ldUfOQ{R!nfQ#u!mR$u#uUhOQ{R!phQ#w!oR$w#wUjOQ{R!sjQ$z#xR%h$zQ$R!rR%Q$RQ$W!uQ$`#UQ$b#WV%V$W$`$b[$T!u#U#W$W$`$bR%S$T[$V!u#U#W$W$`$bR%U$VUlOQ{R!wlUnOQ{R!ynQ$Z!zR%X$ZUpOQ{R!{pQ$]!|R%Y$]Q%[$]R%k%[UrOQ{R!}rUtOQ{R#QtQ#StR$_#SUvOQ{R#TvUxOQ{R#Vx!a!c]_adfhjvx!Q!T!U!V!W!Z#`#a#r#s#y#z#|$P$T$V$^$j$m$|%P%b",
    nodeNames: "\u26A0 print is input sleep play random forward turn color add remove from clear if else and or pressed notIn in repeat times range while def return for toList elif Comment Program Command Assign Text ListAccess Op Number Op Op Expression String Call Op Arguments Comma Op Op Op AssignList Input Clear Print Play Turtle Forward Turn Color Sleep Add Remove If Condition PressedCheck EqualityCheck NotEqualCheck Op ComparisonCheck Op Op ListCheck Op Else Repeat For Define Return While Elif ErrorInvalid",
    maxTerm: 144,
    nodeProps: [
      ["group", 54, "turtle"]
    ],
    skippedNodes: [0, 30],
    repeatNodeCount: 39,
    tokenData: "2b~R!eOY%dYZ&kZp%dpq&pqr&urs'Qst'Vtw%dwx'nxy'syz'xz{'}{|(S|}(X}!O(^!O!P%d!P!Q(c!Q!R(h!R!S(h!S!T(h!T!U(h!U!V(h!V!W(h!W!X(h!X!Y(h!Y!Z(h!Z![(h![!]1r!]!^%d!^!_1w!_!`1|!`!a2R!a!}%d!}#O2W#O#P%d#P#Q2]#QBn%dBnBo(XBoDf%dDfDg(hDgDh(hDhDi(hDiDj(hDjDk(hDkDl(hDlDm(hDmDn(hDnDo(hDoDp(hDpGl%dGlGm(hGmGn(hGnGo(hGoGp(hGpGq(hGqGr(hGrGs(hGsGt(hGtGu(hGuGv(hGv&FV%d&FV&FW(X&FW;'S%d;'S;=`&e<%l?Hb%d?Hb?Hc(X?HcO%d~%i^r~OY%dZp%dtw%d!O!P%d!Q![%d!]!^%d!a!}%d#O#P%d#QBn%dBo&FV%d&FW;'S%d;'S;=`&e<%l?Hb%d?HcO%d~&hP;=`<%l%d~&pO#n~~&uO#m~~&xP!_!`&{~'QO$R~~'VO#s~~'[Sn~OY'VZ;'S'V;'S;=`'h<%lO'V~'kP;=`<%l'V~'sO#w~~'xO#z~~'}O#{~~(SO#}~~(XO$P~~(^O}~~(cO$Q~~(hO$O~~(o}u~r~OY%dZp%dtw%d!O!P+l!Q!R(h!R!S(h!S!T(h!T!U(h!U!V(h!V!W(h!W!X(h!X!Y(h!Y!Z(h!Z![(h!]!^%d!a!}%d#O#P%d#QBn%dBoDf%dDfDg(hDgDh(hDhDi(hDiDj(hDjDk(hDkDl(hDlDm(hDmDn(hDnDo(hDoDp(hDpGl%dGlGm(hGmGn(hGnGo(hGoGp(hGpGq(hGqGr(hGrGs(hGsGt(hGtGu(hGuGv(hGv&FV%d&FW;'S%d;'S;=`&e<%l?Hb%d?HcO%d~+q}r~OY%dZp%dtw%d!O!P%d!Q!R.n!R!S.n!S!T.n!T!U.n!U!V.n!V!W.n!W!X.n!X!Y.n!Y!Z.n!Z![.n!]!^%d!a!}%d#O#P%d#QBn%dBoDf%dDfDg.nDgDh.nDhDi.nDiDj.nDjDk.nDkDl.nDlDm.nDmDn.nDnDo.nDoDp.nDpGl%dGlGm.nGmGn.nGnGo.nGoGp.nGpGq.nGqGr.nGrGs.nGsGt.nGtGu.nGuGv.nGv&FV%d&FW;'S%d;'S;=`&e<%l?Hb%d?HcO%d~.u}u~r~OY%dZp%dtw%d!O!P%d!Q!R.n!R!S.n!S!T.n!T!U.n!U!V.n!V!W.n!W!X.n!X!Y.n!Y!Z.n!Z![.n!]!^%d!a!}%d#O#P%d#QBn%dBoDf%dDfDg.nDgDh.nDhDi.nDiDj.nDjDk.nDkDl.nDlDm.nDmDn.nDnDo.nDoDp.nDpGl%dGlGm.nGmGn.nGnGo.nGoGp.nGpGq.nGqGr.nGrGs.nGsGt.nGtGu.nGuGv.nGv&FV%d&FW;'S%d;'S;=`&e<%l?Hb%d?HcO%d~1wO$U~~1|O$T~~2RO#q~~2WO$S~~2]O#o~~2bO#p~",
    tokenizers: [2, new LocalTokenGroup("_~RQYZXwxX~^O#y~~", 14, 132), new LocalTokenGroup("_~RQYZXrsX~^O#u~~", 14, 128)],
    topRules: { "Program": [0, 31] },
    dynamicPrecedences: { "79": -10 },
    specialized: [{ term: 34, get: (value, stack) => specializeKeyword(value, stack) << 1, external: specializeKeyword }],
    tokenPrec: 1340
  });

  // static/js/lezer-parsers/language-packages.ts
  var languagePerLevel = {
    1: parser,
    2: parser2,
    3: parser3,
    4: parser4,
    5: parser5,
    6: parser6,
    7: parser7,
    8: parser8,
    9: parser9,
    10: parser10,
    11: parser11,
    12: parser12,
    13: parser13,
    14: parser14,
    15: parser15,
    16: parser16,
    17: parser17,
    18: parser18
  };

  // static/js/cm-monokai-theme.ts
  var strawberry = "#ff6188";
  var greenLizard = "#a6e22e";
  var whiskey = "#d19a66";
  var ivory = "#abb2bf";
  var darkSilver = "#75715e";
  var coral = "#e06c75";
  var stone = "#7d8799";
  var malibu = "#61afef";
  var violet = "#ae81ff";
  var background = "#272822";
  var highlightBackground = "#202020";
  var selection = "#90cdf463";
  var gutterBackground = "#2F3129";
  var gutterColor = "#8F908A";
  var skyBlue = "#66D9EF";
  var tooltipBackground = "#353a42";
  var darkBackground = "#21252b";
  var monokaiTheme = EditorView.theme({
    "&": {
      color: ivory,
      backgroundColor: background
    },
    ".cm-content": {
      caretColor: "white"
    },
    ".cm-cursor, .cm-dropCursor": { borderLeftColor: "white" },
    "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection, borderRadius: "2px" },
    ".cm-panels": { backgroundColor: darkBackground, color: ivory },
    ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
    ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
    ".cm-searchMatch": {
      backgroundColor: "#72a1ff59",
      outline: "1px solid #457dff"
    },
    ".cm-searchMatch.cm-searchMatch-selected": {
      backgroundColor: "#6199ff2f"
    },
    ".cm-activeLine": { backgroundColor: "#706d6d15" },
    ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
    "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
      backgroundColor: "#bad0f847"
    },
    ".cm-gutters": {
      backgroundColor: gutterBackground,
      color: gutterColor,
      border: "none"
    },
    ".cm-activeLineGutter": {
      backgroundColor: "#85828215",
      color: "white"
    },
    ".cm-foldPlaceholder": {
      backgroundColor: "transparent",
      border: "none",
      color: "#ddd"
    },
    ".cm-tooltip": {
      border: "none",
      backgroundColor: tooltipBackground
    },
    ".cm-tooltip .cm-tooltip-arrow:before": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    },
    ".cm-tooltip .cm-tooltip-arrow:after": {
      borderTopColor: tooltipBackground,
      borderBottomColor: tooltipBackground
    },
    ".cm-tooltip-autocomplete": {
      "& > ul > li[aria-selected]": {
        backgroundColor: highlightBackground,
        color: ivory
      }
    }
  }, { dark: true });
  var monokaiHighlightStyle = HighlightStyle.define([
    {
      tag: tags.keyword,
      color: strawberry
    },
    {
      tag: [tags.name, tags.deleted, tags.character, tags.propertyName, tags.macroName],
      color: "white"
    },
    {
      tag: [tags.function(tags.variableName), tags.labelName],
      color: malibu
    },
    {
      tag: [tags.color, tags.constant(tags.name), tags.standard(tags.name)],
      color: whiskey
    },
    {
      tag: [tags.definition(tags.name), tags.separator],
      color: ivory
    },
    {
      tag: [tags.typeName, tags.className, tags.number, tags.changed, tags.annotation, tags.modifier, tags.self, tags.namespace],
      color: greenLizard
    },
    {
      tag: [tags.operator, tags.operatorKeyword, tags.url, tags.escape, tags.regexp, tags.link, tags.special(tags.string)],
      color: skyBlue
    },
    {
      tag: [tags.meta, tags.comment],
      color: darkSilver
    },
    {
      tag: tags.strong,
      fontWeight: "bold"
    },
    {
      tag: tags.emphasis,
      fontStyle: "italic"
    },
    {
      tag: tags.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: tags.link,
      color: stone,
      textDecoration: "underline"
    },
    {
      tag: tags.heading,
      fontWeight: "bold",
      color: coral
    },
    {
      tag: [tags.atom, tags.bool, tags.special(tags.variableName)],
      color: whiskey
    },
    {
      tag: [tags.processingInstruction, tags.string, tags.inserted],
      color: violet
    },
    {
      tag: tags.invalid,
      color: ivory
    }
  ]);
  var monokai = [monokaiTheme, syntaxHighlighting(monokaiHighlightStyle)];

  // static/js/cm-editor.ts
  var indentSize = " ".repeat(4);
  var level = Facet.define();
  var HedyCodeMirrorEditorCreator = class {
    initializeEditorWithGutter($editor, editorType, dir = "ltr") {
      let editor = new HedyCodeMirrorEditor($editor.get(0), $editor.data("readonly"), editorType, dir);
      return editor;
    }
    initializeReadOnlyEditor(preview, dir = "ltr") {
      let editorType;
      if ($(preview).hasClass("common-mistakes")) {
        editorType = EditorType.COMMON_MISTAKES;
      } else if ($(preview).hasClass("cheatsheet")) {
        editorType = EditorType.CHEATSHEET;
      } else if ($(preview).hasClass("parsons")) {
        editorType = EditorType.PARSONS;
      } else {
        editorType = EditorType.EXAMPLE;
      }
      return new HedyCodeMirrorEditor(preview, true, editorType, dir);
    }
  };
  var HedyCodeMirrorEditor = class {
    constructor(element, isReadOnly, editorType, __2 = "ltr") {
      this.readMode = new Compartment();
      this.editorEvent = new EventEmitter({
        change: true,
        guttermousedown: true,
        changeBreakpoint: true,
        click: true
      });
      this.incorrectLineMapping = {};
      let state;
      if (editorType === EditorType.MAIN) {
        const mainEditorStyling = EditorView.theme({
          "&": {
            background: "#272822",
            fontSize: "15.2px",
            color: "white",
            borderRadius: "4px",
            marginRight: "5px"
          },
          ".cm-scroller": {
            overflow: "auto"
          },
          ".cm-gutters": {
            borderRadius: "4px"
          },
          ".cm-cursor, .cm-dropCursor": { borderLeftColor: "white", borderLeftWidth: "2px" },
          ".cm-name": {
            color: "#009975"
          }
        });
        state = EditorState.create({
          doc: "",
          extensions: [
            mainEditorStyling,
            breakpointGutter,
            lineNumbers(),
            highlightActiveLineGutter(),
            highlightSpecialChars(),
            history(),
            drawSelection(),
            dropCursor(),
            indentOnInput(),
            syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
            highlightActiveLine(),
            highlightSelectionMatches(),
            keymap.of([
              ...defaultKeymap,
              ...searchKeymap,
              ...historyKeymap,
              indentWithTab
            ]),
            indentUnit.of(indentSize),
            indentService.of(basicIndent),
            monokai,
            this.readMode.of(EditorState.readOnly.of(isReadOnly)),
            errorLineField,
            debugLineField,
            incorrectLineField,
            Prec.high(decorationsTheme),
            placeholders,
            theLevel ? level.of(theLevel) : [],
            Prec.highest(variableHighlighter)
          ]
        });
      } else {
        let theme2 = {
          ".cm-cursor, .cm-dropCursor": { border: "none" },
          ".cm-name": {
            color: "#009975"
          }
        };
        let extensions = [
          highlightSpecialChars(),
          drawSelection(),
          syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
          monokai,
          this.readMode.of(EditorState.readOnly.of(isReadOnly)),
          placeholders,
          theLevel ? level.of(theLevel) : [],
          Prec.high(decorationsTheme),
          Prec.highest(variableHighlighter)
        ];
        switch (editorType) {
          case EditorType.CHEATSHEET:
          case EditorType.EXAMPLE:
          case EditorType.PARSONS:
            theme2[".cm-scroller"] = { "overflow": "auto", "min-height": "3.5rem" };
            extensions.push(EditorView.theme(theme2));
            break;
          case EditorType.COMMON_MISTAKES:
            theme2["&"] = {
              background: "#272822",
              fontSize: "15.2px",
              color: "white",
              borderRadius: "4px",
              marginRight: "5px"
            };
            extensions.push([
              EditorView.theme(theme2),
              lineNumbers(),
              highlightActiveLine(),
              highlightActiveLineGutter()
            ]);
            break;
        }
        state = EditorState.create({
          doc: "",
          extensions
        });
      }
      this.view = new EditorView({
        parent: element,
        state
      });
      if (theLevel) {
        this.setHighlighterForLevel(theLevel);
      }
    }
    setHighlighterForLevel(level3) {
      const language2 = languagePerLevel[level3];
      const hedyStyleTags = {
        "print forward turn play color ask is echo sleep Comma": tags.keyword,
        "at random remove from add to if else in not Op": tags.keyword,
        "repeat times for range with return and or while": tags.keyword,
        "elif def input toList": tags.keyword,
        Comment: tags.lineComment,
        "Text": tags.name,
        "String": tags.string,
        "clear pressed": tags.color,
        "Number Int": tags.number,
        "define call": tags.operatorKeyword,
        "Command/ErrorInvalid/Text": tags.invalid
      };
      const parserWithMetadata = language2.configure({
        props: [
          styleTags(hedyStyleTags)
        ]
      });
      const langPackage = LRLanguage.define({
        parser: parserWithMetadata,
        languageData: {
          commentTokens: { line: "#" }
        }
      });
      function hedy() {
        return new LanguageSupport(langPackage);
      }
      const effect = StateEffect.appendConfig.of(hedy());
      this.view.dispatch({ effects: effect });
      const transaction = this.view.state.update({
        effects: StateEffect.appendConfig.of(EditorView.updateListener.of((v) => {
          if (v.docChanged) {
            console.log(language2.parse(v.view.state.doc.toString()).toString());
          }
        }))
      });
      this.view.dispatch(transaction);
    }
    get contents() {
      return this.view.state.doc.toString();
    }
    set contents(content2) {
      let transaction = this.view.state.update({ changes: { from: 0, to: this.view.state.doc.length, insert: content2 } });
      this.view.dispatch(transaction);
    }
    get isReadOnly() {
      return this.view.state.readOnly;
    }
    set isReadOnly(isReadMode) {
      this.view.dispatch({
        effects: this.readMode.reconfigure(EditorState.readOnly.of(isReadMode))
      });
    }
    resize(newHeightRem) {
      if (newHeightRem === void 0) {
        console.log("Error! When resizing a CodeMirror instance, you need to provide the new height");
        return;
      }
      console.warn("Oops! editor.resize() should not have been called anymore");
    }
    focus() {
      this.view.focus();
    }
    clearErrors() {
      let effect = removeErrorMarkers.of();
      this.view.dispatch({ effects: effect });
    }
    moveCursorToEndOfFile() {
      const endPos = this.view.state.doc.length;
      this.view.dispatch(this.view.state.update({ selection: { anchor: endPos } }));
    }
    clearSelection() {
      const currentSelection = this.view.state.selection;
      const currentAnchor = currentSelection.ranges[0].anchor;
      this.view.dispatch(this.view.state.update({ selection: { anchor: currentAnchor } }));
    }
    clearBreakpoints() {
    }
    configureMainEditor() {
    }
    getHighlighter(level3) {
      return `${level3}`;
    }
    trimTrailingSpace() {
      deleteTrailingWhitespace(this.view);
    }
    on(key, handler2) {
      if (key === "change") {
        const transaction = this.view.state.update({
          effects: StateEffect.appendConfig.of(EditorView.updateListener.of((v) => {
            if (v.docChanged) {
              handler2();
            }
          }))
        });
        this.view.dispatch(transaction);
      } else if (key === "click") {
        const eventHandler = EditorView.domEventHandlers({
          click: handler2
        });
        const effect = StateEffect.appendConfig.of(eventHandler);
        this.view.dispatch({ effects: effect });
      }
    }
    highlightError(row, col) {
      let effect;
      if (col === void 0) {
        effect = addErrorLine.of({ row });
      } else {
        effect = addErrorWord.of({ row, col });
      }
      this.view.dispatch({ effects: effect });
    }
    setDebuggerCurrentLine(line, startPos, finishPos) {
      if (this.currentDebugLine) {
        this.view.dispatch({ effects: removeDebugLine.of() });
      }
      if (line === void 0) {
        this.currentDebugLine = void 0;
        return;
      }
      this.currentDebugLine = line;
      if (startPos !== void 0 && finishPos !== void 0) {
        let effect;
        const docLine = this.view.state.doc.line(line);
        const from17 = docLine.from + startPos - 1;
        const to10 = docLine.from + finishPos;
        effect = addDebugWords.of({ from: from17, to: to10 });
        this.view.dispatch({ effects: effect });
      } else {
        let effect;
        effect = addDebugLine.of({ row: line });
        this.view.dispatch({ effects: effect });
      }
    }
    getActiveContents(debugLine2) {
      const currentContent = this.view.state.doc.toString();
      if (currentContent === "") {
        return "";
      }
      const gutterMarkers = this.view.state.field(breakpointGutterState);
      const deactivatedLines = [];
      let to10;
      let lines;
      if (debugLine2 === null) {
        to10 = this.view.state.doc.length;
        lines = currentContent.split("\n");
      } else {
        const currentDebugLine = parseInt(debugLine2, 10) + 1;
        to10 = this.view.state.doc.line(currentDebugLine).to;
        lines = currentContent.split("\n").slice(0, currentDebugLine);
      }
      gutterMarkers.between(0, to10, (from17) => {
        deactivatedLines.push(this.view.state.doc.lineAt(from17).number);
      });
      const resultingLines = [];
      for (let i = 0; i < lines.length; i++) {
        if (deactivatedLines.includes(i + 1)) {
          resultingLines.push("");
        } else {
          resultingLines.push(lines[i]);
        }
      }
      const code = resultingLines.join("\n");
      return code;
    }
    setIncorrectLine(range10, lineIndex) {
      const startLine = this.view.state.doc.line(range10.startLine);
      const endLine = this.view.state.doc.line(range10.endLine);
      const from17 = startLine.from + range10.startColumn - 1;
      let to10 = endLine.from + range10.endColumn - 1;
      to10 = to10 > endLine.to ? endLine.to : to10;
      this.incorrectLineMapping[`${from17}-${to10}`] = lineIndex;
      let effect = addIncorrectLineEffect.of({ from: from17, to: to10 });
      this.view.dispatch({ effects: effect });
    }
    clearIncorrectLines() {
      this.incorrectLineMapping = {};
      const effect = removeIncorrectLineEffect.of();
      this.view.dispatch({ effects: effect });
    }
    getPosFromCoord(x, y2) {
      return this.view.posAtCoords({ x, y: y2 });
    }
    indexOfErrorInPos(pos) {
      const incorrectLineSet = this.view.state.field(incorrectLineField);
      let index3 = null;
      incorrectLineSet.between(pos, pos, (from17, to10) => {
        index3 = this.incorrectLineMapping[`${from17}-${to10}`];
      });
      return index3;
    }
    hasIncorrectLinesDecorations() {
      const incorrectLineSet = this.view.state.field(incorrectLineField);
      let hasIncorrectLines = false;
      incorrectLineSet.between(0, this.view.state.doc.length, () => {
        hasIncorrectLines = true;
      });
      return hasIncorrectLines;
    }
    skipFaultyHandler(event2) {
      if (!this.hasIncorrectLinesDecorations())
        return;
      const pos = this.getPosFromCoord(event2.x, event2.y);
      if (pos == null)
        return;
      const index3 = this.indexOfErrorInPos(pos);
      if (index3 == null) {
        error.hide();
      } else {
        let mapError = theGlobalSourcemap[index3];
        error.hide();
        error.show(ClientMessages["Transpile_error"], mapError.error);
      }
    }
  };

  // node_modules/sortablejs/modular/sortable.esm.js
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) {
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  var version2 = "1.15.0";
  function userAgent(pattern) {
    if (typeof window !== "undefined" && window.navigator) {
      return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
    }
  }
  var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
  var Edge = userAgent(/Edge/i);
  var FireFox = userAgent(/firefox/i);
  var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
  var IOS = userAgent(/iP(ad|od|hone)/i);
  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
  var captureMode = {
    capture: false,
    passive: false
  };
  function on(el3, event2, fn2) {
    el3.addEventListener(event2, fn2, !IE11OrLess && captureMode);
  }
  function off(el3, event2, fn2) {
    el3.removeEventListener(event2, fn2, !IE11OrLess && captureMode);
  }
  function matches(el3, selector) {
    if (!selector)
      return;
    selector[0] === ">" && (selector = selector.substring(1));
    if (el3) {
      try {
        if (el3.matches) {
          return el3.matches(selector);
        } else if (el3.msMatchesSelector) {
          return el3.msMatchesSelector(selector);
        } else if (el3.webkitMatchesSelector) {
          return el3.webkitMatchesSelector(selector);
        }
      } catch (_) {
        return false;
      }
    }
    return false;
  }
  function getParentOrHost(el3) {
    return el3.host && el3 !== document && el3.host.nodeType ? el3.host : el3.parentNode;
  }
  function closest(el3, selector, ctx, includeCTX) {
    if (el3) {
      ctx = ctx || document;
      do {
        if (selector != null && (selector[0] === ">" ? el3.parentNode === ctx && matches(el3, selector) : matches(el3, selector)) || includeCTX && el3 === ctx) {
          return el3;
        }
        if (el3 === ctx)
          break;
      } while (el3 = getParentOrHost(el3));
    }
    return null;
  }
  var R_SPACE = /\s+/g;
  function toggleClass(el3, name2, state) {
    if (el3 && name2) {
      if (el3.classList) {
        el3.classList[state ? "add" : "remove"](name2);
      } else {
        var className = (" " + el3.className + " ").replace(R_SPACE, " ").replace(" " + name2 + " ", " ");
        el3.className = (className + (state ? " " + name2 : "")).replace(R_SPACE, " ");
      }
    }
  }
  function css(el3, prop, val) {
    var style = el3 && el3.style;
    if (style) {
      if (val === void 0) {
        if (document.defaultView && document.defaultView.getComputedStyle) {
          val = document.defaultView.getComputedStyle(el3, "");
        } else if (el3.currentStyle) {
          val = el3.currentStyle;
        }
        return prop === void 0 ? val : val[prop];
      } else {
        if (!(prop in style) && prop.indexOf("webkit") === -1) {
          prop = "-webkit-" + prop;
        }
        style[prop] = val + (typeof val === "string" ? "" : "px");
      }
    }
  }
  function matrix(el3, selfOnly) {
    var appliedTransforms = "";
    if (typeof el3 === "string") {
      appliedTransforms = el3;
    } else {
      do {
        var transform = css(el3, "transform");
        if (transform && transform !== "none") {
          appliedTransforms = transform + " " + appliedTransforms;
        }
      } while (!selfOnly && (el3 = el3.parentNode));
    }
    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
    return matrixFn && new matrixFn(appliedTransforms);
  }
  function find2(ctx, tagName, iterator) {
    if (ctx) {
      var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
      if (iterator) {
        for (; i < n; i++) {
          iterator(list[i], i);
        }
      }
      return list;
    }
    return [];
  }
  function getWindowScrollingElement() {
    var scrollingElement = document.scrollingElement;
    if (scrollingElement) {
      return scrollingElement;
    } else {
      return document.documentElement;
    }
  }
  function getRect(el3, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
    if (!el3.getBoundingClientRect && el3 !== window)
      return;
    var elRect, top2, left, bottom, right, height, width;
    if (el3 !== window && el3.parentNode && el3 !== getWindowScrollingElement()) {
      elRect = el3.getBoundingClientRect();
      top2 = elRect.top;
      left = elRect.left;
      bottom = elRect.bottom;
      right = elRect.right;
      height = elRect.height;
      width = elRect.width;
    } else {
      top2 = 0;
      left = 0;
      bottom = window.innerHeight;
      right = window.innerWidth;
      height = window.innerHeight;
      width = window.innerWidth;
    }
    if ((relativeToContainingBlock || relativeToNonStaticParent) && el3 !== window) {
      container = container || el3.parentNode;
      if (!IE11OrLess) {
        do {
          if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
            var containerRect = container.getBoundingClientRect();
            top2 -= containerRect.top + parseInt(css(container, "border-top-width"));
            left -= containerRect.left + parseInt(css(container, "border-left-width"));
            bottom = top2 + elRect.height;
            right = left + elRect.width;
            break;
          }
        } while (container = container.parentNode);
      }
    }
    if (undoScale && el3 !== window) {
      var elMatrix = matrix(container || el3), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
      if (elMatrix) {
        top2 /= scaleY;
        left /= scaleX;
        width /= scaleX;
        height /= scaleY;
        bottom = top2 + height;
        right = left + width;
      }
    }
    return {
      top: top2,
      left,
      bottom,
      right,
      width,
      height
    };
  }
  function isScrolledPast(el3, elSide, parentSide) {
    var parent = getParentAutoScrollElement(el3, true), elSideVal = getRect(el3)[elSide];
    while (parent) {
      var parentSideVal = getRect(parent)[parentSide], visible = void 0;
      if (parentSide === "top" || parentSide === "left") {
        visible = elSideVal >= parentSideVal;
      } else {
        visible = elSideVal <= parentSideVal;
      }
      if (!visible)
        return parent;
      if (parent === getWindowScrollingElement())
        break;
      parent = getParentAutoScrollElement(parent, false);
    }
    return false;
  }
  function getChild(el3, childNum, options, includeDragEl) {
    var currentChild = 0, i = 0, children = el3.children;
    while (i < children.length) {
      if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el3, false)) {
        if (currentChild === childNum) {
          return children[i];
        }
        currentChild++;
      }
      i++;
    }
    return null;
  }
  function lastChild(el3, selector) {
    var last = el3.lastElementChild;
    while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
      last = last.previousElementSibling;
    }
    return last || null;
  }
  function index(el3, selector) {
    var index3 = 0;
    if (!el3 || !el3.parentNode) {
      return -1;
    }
    while (el3 = el3.previousElementSibling) {
      if (el3.nodeName.toUpperCase() !== "TEMPLATE" && el3 !== Sortable.clone && (!selector || matches(el3, selector))) {
        index3++;
      }
    }
    return index3;
  }
  function getRelativeScrollOffset(el3) {
    var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
    if (el3) {
      do {
        var elMatrix = matrix(el3), scaleX = elMatrix.a, scaleY = elMatrix.d;
        offsetLeft += el3.scrollLeft * scaleX;
        offsetTop += el3.scrollTop * scaleY;
      } while (el3 !== winScroller && (el3 = el3.parentNode));
    }
    return [offsetLeft, offsetTop];
  }
  function indexOfObject(arr, obj) {
    for (var i in arr) {
      if (!arr.hasOwnProperty(i))
        continue;
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key] === arr[i][key])
          return Number(i);
      }
    }
    return -1;
  }
  function getParentAutoScrollElement(el3, includeSelf) {
    if (!el3 || !el3.getBoundingClientRect)
      return getWindowScrollingElement();
    var elem = el3;
    var gotSelf = false;
    do {
      if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
        var elemCSS = css(elem);
        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
          if (!elem.getBoundingClientRect || elem === document.body)
            return getWindowScrollingElement();
          if (gotSelf || includeSelf)
            return elem;
          gotSelf = true;
        }
      }
    } while (elem = elem.parentNode);
    return getWindowScrollingElement();
  }
  function extend2(dst, src) {
    if (dst && src) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          dst[key] = src[key];
        }
      }
    }
    return dst;
  }
  function isRectEqual(rect1, rect2) {
    return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
  }
  var _throttleTimeout;
  function throttle(callback2, ms2) {
    return function() {
      if (!_throttleTimeout) {
        var args = arguments, _this = this;
        if (args.length === 1) {
          callback2.call(_this, args[0]);
        } else {
          callback2.apply(_this, args);
        }
        _throttleTimeout = setTimeout(function() {
          _throttleTimeout = void 0;
        }, ms2);
      }
    };
  }
  function cancelThrottle() {
    clearTimeout(_throttleTimeout);
    _throttleTimeout = void 0;
  }
  function scrollBy(el3, x, y2) {
    el3.scrollLeft += x;
    el3.scrollTop += y2;
  }
  function clone(el3) {
    var Polymer = window.Polymer;
    var $3 = window.jQuery || window.Zepto;
    if (Polymer && Polymer.dom) {
      return Polymer.dom(el3).cloneNode(true);
    } else if ($3) {
      return $3(el3).clone(true)[0];
    } else {
      return el3.cloneNode(true);
    }
  }
  var expando = "Sortable" + new Date().getTime();
  function AnimationStateManager() {
    var animationStates = [], animationCallbackId;
    return {
      captureAnimationState: function captureAnimationState() {
        animationStates = [];
        if (!this.options.animation)
          return;
        var children = [].slice.call(this.el.children);
        children.forEach(function(child) {
          if (css(child, "display") === "none" || child === Sortable.ghost)
            return;
          animationStates.push({
            target: child,
            rect: getRect(child)
          });
          var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
          if (child.thisAnimationDuration) {
            var childMatrix = matrix(child, true);
            if (childMatrix) {
              fromRect.top -= childMatrix.f;
              fromRect.left -= childMatrix.e;
            }
          }
          child.fromRect = fromRect;
        });
      },
      addAnimationState: function addAnimationState(state) {
        animationStates.push(state);
      },
      removeAnimationState: function removeAnimationState(target) {
        animationStates.splice(indexOfObject(animationStates, {
          target
        }), 1);
      },
      animateAll: function animateAll(callback2) {
        var _this = this;
        if (!this.options.animation) {
          clearTimeout(animationCallbackId);
          if (typeof callback2 === "function")
            callback2();
          return;
        }
        var animating = false, animationTime = 0;
        animationStates.forEach(function(state) {
          var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
          if (targetMatrix) {
            toRect.top -= targetMatrix.f;
            toRect.left -= targetMatrix.e;
          }
          target.toRect = toRect;
          if (target.thisAnimationDuration) {
            if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
              time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
            }
          }
          if (!isRectEqual(toRect, fromRect)) {
            target.prevFromRect = fromRect;
            target.prevToRect = toRect;
            if (!time) {
              time = _this.options.animation;
            }
            _this.animate(target, animatingRect, toRect, time);
          }
          if (time) {
            animating = true;
            animationTime = Math.max(animationTime, time);
            clearTimeout(target.animationResetTimer);
            target.animationResetTimer = setTimeout(function() {
              target.animationTime = 0;
              target.prevFromRect = null;
              target.fromRect = null;
              target.prevToRect = null;
              target.thisAnimationDuration = null;
            }, time);
            target.thisAnimationDuration = time;
          }
        });
        clearTimeout(animationCallbackId);
        if (!animating) {
          if (typeof callback2 === "function")
            callback2();
        } else {
          animationCallbackId = setTimeout(function() {
            if (typeof callback2 === "function")
              callback2();
          }, animationTime);
        }
        animationStates = [];
      },
      animate: function animate(target, currentRect, toRect, duration) {
        if (duration) {
          css(target, "transition", "");
          css(target, "transform", "");
          var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
          target.animatingX = !!translateX;
          target.animatingY = !!translateY;
          css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
          this.forRepaintDummy = repaint(target);
          css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
          css(target, "transform", "translate3d(0,0,0)");
          typeof target.animated === "number" && clearTimeout(target.animated);
          target.animated = setTimeout(function() {
            css(target, "transition", "");
            css(target, "transform", "");
            target.animated = false;
            target.animatingX = false;
            target.animatingY = false;
          }, duration);
        }
      }
    };
  }
  function repaint(target) {
    return target.offsetWidth;
  }
  function calculateRealTime(animatingRect, fromRect, toRect, options) {
    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
  }
  var plugins = [];
  var defaults2 = {
    initializeByDefault: true
  };
  var PluginManager = {
    mount: function mount(plugin) {
      for (var option2 in defaults2) {
        if (defaults2.hasOwnProperty(option2) && !(option2 in plugin)) {
          plugin[option2] = defaults2[option2];
        }
      }
      plugins.forEach(function(p) {
        if (p.pluginName === plugin.pluginName) {
          throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
        }
      });
      plugins.push(plugin);
    },
    pluginEvent: function pluginEvent(eventName, sortable, evt) {
      var _this = this;
      this.eventCanceled = false;
      evt.cancel = function() {
        _this.eventCanceled = true;
      };
      var eventNameGlobal = eventName + "Global";
      plugins.forEach(function(plugin) {
        if (!sortable[plugin.pluginName])
          return;
        if (sortable[plugin.pluginName][eventNameGlobal]) {
          sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
            sortable
          }, evt));
        }
        if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
          sortable[plugin.pluginName][eventName](_objectSpread2({
            sortable
          }, evt));
        }
      });
    },
    initializePlugins: function initializePlugins(sortable, el3, defaults4, options) {
      plugins.forEach(function(plugin) {
        var pluginName = plugin.pluginName;
        if (!sortable.options[pluginName] && !plugin.initializeByDefault)
          return;
        var initialized = new plugin(sortable, el3, sortable.options);
        initialized.sortable = sortable;
        initialized.options = sortable.options;
        sortable[pluginName] = initialized;
        _extends(defaults4, initialized.defaults);
      });
      for (var option2 in sortable.options) {
        if (!sortable.options.hasOwnProperty(option2))
          continue;
        var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
        if (typeof modified !== "undefined") {
          sortable.options[option2] = modified;
        }
      }
    },
    getEventProperties: function getEventProperties(name2, sortable) {
      var eventProperties = {};
      plugins.forEach(function(plugin) {
        if (typeof plugin.eventProperties !== "function")
          return;
        _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name2));
      });
      return eventProperties;
    },
    modifyOption: function modifyOption(sortable, name2, value) {
      var modifiedValue;
      plugins.forEach(function(plugin) {
        if (!sortable[plugin.pluginName])
          return;
        if (plugin.optionListeners && typeof plugin.optionListeners[name2] === "function") {
          modifiedValue = plugin.optionListeners[name2].call(sortable[plugin.pluginName], value);
        }
      });
      return modifiedValue;
    }
  };
  function dispatchEvent(_ref) {
    var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name2 = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
    sortable = sortable || rootEl2 && rootEl2[expando];
    if (!sortable)
      return;
    var evt, options = sortable.options, onName = "on" + name2.charAt(0).toUpperCase() + name2.substr(1);
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent(name2, {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent("Event");
      evt.initEvent(name2, true, true);
    }
    evt.to = toEl || rootEl2;
    evt.from = fromEl || rootEl2;
    evt.item = targetEl || rootEl2;
    evt.clone = cloneEl2;
    evt.oldIndex = oldIndex2;
    evt.newIndex = newIndex2;
    evt.oldDraggableIndex = oldDraggableIndex2;
    evt.newDraggableIndex = newDraggableIndex2;
    evt.originalEvent = originalEvent;
    evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
    var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name2, sortable));
    for (var option2 in allEventProperties) {
      evt[option2] = allEventProperties[option2];
    }
    if (rootEl2) {
      rootEl2.dispatchEvent(evt);
    }
    if (options[onName]) {
      options[onName].call(sortable, evt);
    }
  }
  var _excluded = ["evt"];
  var pluginEvent2 = function pluginEvent3(eventName, sortable) {
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
      dragEl,
      parentEl,
      ghostEl,
      rootEl,
      nextEl,
      lastDownEl,
      cloneEl,
      cloneHidden,
      dragStarted: moved,
      putSortable,
      activeSortable: Sortable.active,
      originalEvent,
      oldIndex,
      oldDraggableIndex,
      newIndex,
      newDraggableIndex,
      hideGhostForTarget: _hideGhostForTarget,
      unhideGhostForTarget: _unhideGhostForTarget,
      cloneNowHidden: function cloneNowHidden() {
        cloneHidden = true;
      },
      cloneNowShown: function cloneNowShown() {
        cloneHidden = false;
      },
      dispatchSortableEvent: function dispatchSortableEvent(name2) {
        _dispatchEvent({
          sortable,
          name: name2,
          originalEvent
        });
      }
    }, data));
  };
  function _dispatchEvent(info) {
    dispatchEvent(_objectSpread2({
      putSortable,
      cloneEl,
      targetEl: dragEl,
      rootEl,
      oldIndex,
      oldDraggableIndex,
      newIndex,
      newDraggableIndex
    }, info));
  }
  var dragEl;
  var parentEl;
  var ghostEl;
  var rootEl;
  var nextEl;
  var lastDownEl;
  var cloneEl;
  var cloneHidden;
  var oldIndex;
  var newIndex;
  var oldDraggableIndex;
  var newDraggableIndex;
  var activeGroup;
  var putSortable;
  var awaitingDragStarted = false;
  var ignoreNextClick = false;
  var sortables = [];
  var tapEvt;
  var touchEvt;
  var lastDx;
  var lastDy;
  var tapDistanceLeft;
  var tapDistanceTop;
  var moved;
  var lastTarget;
  var lastDirection;
  var pastFirstInvertThresh = false;
  var isCircumstantialInvert = false;
  var targetMoveDistance;
  var ghostRelativeParent;
  var ghostRelativeParentInitialScroll = [];
  var _silent = false;
  var savedInputChecked = [];
  var documentExists = typeof document !== "undefined";
  var PositionGhostAbsolutely = IOS;
  var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
  var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
  var supportCssPointerEvents = function() {
    if (!documentExists)
      return;
    if (IE11OrLess) {
      return false;
    }
    var el3 = document.createElement("x");
    el3.style.cssText = "pointer-events:auto";
    return el3.style.pointerEvents === "auto";
  }();
  var _detectDirection = function _detectDirection2(el3, options) {
    var elCSS = css(el3), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el3, 0, options), child2 = getChild(el3, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === "flex") {
      return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
    }
    if (elCSS.display === "grid") {
      return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
      var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
      return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
    }
    return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
  };
  var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  };
  var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y2) {
    var ret;
    sortables.some(function(sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable))
        return;
      var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y2 >= rect.top - threshold && y2 <= rect.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  };
  var _prepareGroup = function _prepareGroup2(options) {
    function toFn(value, pull) {
      return function(to10, from17, dragEl2, evt) {
        var sameGroup = to10.options.group.name && from17.options.group.name && to10.options.group.name === from17.options.group.name;
        if (value == null && (pull || sameGroup)) {
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === "clone") {
          return value;
        } else if (typeof value === "function") {
          return toFn(value(to10, from17, dragEl2, evt), pull)(to10, from17, dragEl2, evt);
        } else {
          var otherGroup = (pull ? to10 : from17).options.group.name;
          return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }
    var group = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof(originalGroup) != "object") {
      originalGroup = {
        name: originalGroup
      };
    }
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  };
  var _hideGhostForTarget = function _hideGhostForTarget2() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, "display", "none");
    }
  };
  var _unhideGhostForTarget = function _unhideGhostForTarget2() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, "display", "");
    }
  };
  if (documentExists && !ChromeForAndroid) {
    document.addEventListener("click", function(evt) {
      if (ignoreNextClick) {
        evt.preventDefault();
        evt.stopPropagation && evt.stopPropagation();
        evt.stopImmediatePropagation && evt.stopImmediatePropagation();
        ignoreNextClick = false;
        return false;
      }
    }, true);
  }
  var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
    if (dragEl) {
      evt = evt.touches ? evt.touches[0] : evt;
      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
      if (nearest) {
        var event2 = {};
        for (var i in evt) {
          if (evt.hasOwnProperty(i)) {
            event2[i] = evt[i];
          }
        }
        event2.target = event2.rootEl = nearest;
        event2.preventDefault = void 0;
        event2.stopPropagation = void 0;
        nearest[expando]._onDragOver(event2);
      }
    }
  };
  var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
    if (dragEl) {
      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
    }
  };
  function Sortable(el3, options) {
    if (!(el3 && el3.nodeType && el3.nodeType === 1)) {
      throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el3));
    }
    this.el = el3;
    this.options = options = _extends({}, options);
    el3[expando] = this;
    var defaults4 = {
      group: null,
      sort: true,
      disabled: false,
      store: null,
      handle: null,
      draggable: /^[uo]l$/i.test(el3.nodeName) ? ">li" : ">*",
      swapThreshold: 1,
      invertSwap: false,
      invertedSwapThreshold: null,
      removeCloneOnHide: true,
      direction: function direction() {
        return _detectDirection(el3, this.options);
      },
      ghostClass: "sortable-ghost",
      chosenClass: "sortable-chosen",
      dragClass: "sortable-drag",
      ignore: "a, img",
      filter: null,
      preventOnFilter: true,
      animation: 0,
      easing: null,
      setData: function setData(dataTransfer, dragEl2) {
        dataTransfer.setData("Text", dragEl2.textContent);
      },
      dropBubble: false,
      dragoverBubble: false,
      dataIdAttr: "data-id",
      delay: 0,
      delayOnTouchOnly: false,
      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
      forceFallback: false,
      fallbackClass: "sortable-fallback",
      fallbackOnBody: false,
      fallbackTolerance: 0,
      fallbackOffset: {
        x: 0,
        y: 0
      },
      supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
      emptyInsertThreshold: 5
    };
    PluginManager.initializePlugins(this, el3, defaults4);
    for (var name2 in defaults4) {
      !(name2 in options) && (options[name2] = defaults4[name2]);
    }
    _prepareGroup(options);
    for (var fn2 in this) {
      if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
        this[fn2] = this[fn2].bind(this);
      }
    }
    this.nativeDraggable = options.forceFallback ? false : supportDraggable;
    if (this.nativeDraggable) {
      this.options.touchStartThreshold = 1;
    }
    if (options.supportPointer) {
      on(el3, "pointerdown", this._onTapStart);
    } else {
      on(el3, "mousedown", this._onTapStart);
      on(el3, "touchstart", this._onTapStart);
    }
    if (this.nativeDraggable) {
      on(el3, "dragover", this);
      on(el3, "dragenter", this);
    }
    sortables.push(this.el);
    options.store && options.store.get && this.sort(options.store.get(this) || []);
    _extends(this, AnimationStateManager());
  }
  Sortable.prototype = {
    constructor: Sortable,
    _isOutsideThisEl: function _isOutsideThisEl(target) {
      if (!this.el.contains(target) && target !== this.el) {
        lastTarget = null;
      }
    },
    _getDirection: function _getDirection(evt, target) {
      return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
    },
    _onTapStart: function _onTapStart(evt) {
      if (!evt.cancelable)
        return;
      var _this = this, el3 = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
      _saveInputCheckedState(el3);
      if (dragEl) {
        return;
      }
      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
        return;
      }
      if (originalTarget.isContentEditable) {
        return;
      }
      if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
        return;
      }
      target = closest(target, options.draggable, el3, false);
      if (target && target.animated) {
        return;
      }
      if (lastDownEl === target) {
        return;
      }
      oldIndex = index(target);
      oldDraggableIndex = index(target, options.draggable);
      if (typeof filter === "function") {
        if (filter.call(this, evt, target, this)) {
          _dispatchEvent({
            sortable: _this,
            rootEl: originalTarget,
            name: "filter",
            targetEl: target,
            toEl: el3,
            fromEl: el3
          });
          pluginEvent2("filter", _this, {
            evt
          });
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return;
        }
      } else if (filter) {
        filter = filter.split(",").some(function(criteria) {
          criteria = closest(originalTarget, criteria.trim(), el3, false);
          if (criteria) {
            _dispatchEvent({
              sortable: _this,
              rootEl: criteria,
              name: "filter",
              targetEl: target,
              fromEl: el3,
              toEl: el3
            });
            pluginEvent2("filter", _this, {
              evt
            });
            return true;
          }
        });
        if (filter) {
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return;
        }
      }
      if (options.handle && !closest(originalTarget, options.handle, el3, false)) {
        return;
      }
      this._prepareDragStart(evt, touch, target);
    },
    _prepareDragStart: function _prepareDragStart(evt, touch, target) {
      var _this = this, el3 = _this.el, options = _this.options, ownerDocument = el3.ownerDocument, dragStartFn;
      if (target && !dragEl && target.parentNode === el3) {
        var dragRect = getRect(target);
        rootEl = el3;
        dragEl = target;
        parentEl = dragEl.parentNode;
        nextEl = dragEl.nextSibling;
        lastDownEl = target;
        activeGroup = options.group;
        Sortable.dragged = dragEl;
        tapEvt = {
          target: dragEl,
          clientX: (touch || evt).clientX,
          clientY: (touch || evt).clientY
        };
        tapDistanceLeft = tapEvt.clientX - dragRect.left;
        tapDistanceTop = tapEvt.clientY - dragRect.top;
        this._lastX = (touch || evt).clientX;
        this._lastY = (touch || evt).clientY;
        dragEl.style["will-change"] = "all";
        dragStartFn = function dragStartFn2() {
          pluginEvent2("delayEnded", _this, {
            evt
          });
          if (Sortable.eventCanceled) {
            _this._onDrop();
            return;
          }
          _this._disableDelayedDragEvents();
          if (!FireFox && _this.nativeDraggable) {
            dragEl.draggable = true;
          }
          _this._triggerDragStart(evt, touch);
          _dispatchEvent({
            sortable: _this,
            name: "choose",
            originalEvent: evt
          });
          toggleClass(dragEl, options.chosenClass, true);
        };
        options.ignore.split(",").forEach(function(criteria) {
          find2(dragEl, criteria.trim(), _disableDraggable);
        });
        on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "mouseup", _this._onDrop);
        on(ownerDocument, "touchend", _this._onDrop);
        on(ownerDocument, "touchcancel", _this._onDrop);
        if (FireFox && this.nativeDraggable) {
          this.options.touchStartThreshold = 4;
          dragEl.draggable = true;
        }
        pluginEvent2("delayStart", this, {
          evt
        });
        if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
          if (Sortable.eventCanceled) {
            this._onDrop();
            return;
          }
          on(ownerDocument, "mouseup", _this._disableDelayedDrag);
          on(ownerDocument, "touchend", _this._disableDelayedDrag);
          on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
          on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
          on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
          options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
        } else {
          dragStartFn();
        }
      }
    },
    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
      var touch = e.touches ? e.touches[0] : e;
      if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
        this._disableDelayedDrag();
      }
    },
    _disableDelayedDrag: function _disableDelayedDrag() {
      dragEl && _disableDraggable(dragEl);
      clearTimeout(this._dragStartTimer);
      this._disableDelayedDragEvents();
    },
    _disableDelayedDragEvents: function _disableDelayedDragEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, "mouseup", this._disableDelayedDrag);
      off(ownerDocument, "touchend", this._disableDelayedDrag);
      off(ownerDocument, "touchcancel", this._disableDelayedDrag);
      off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
      off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
      off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
    },
    _triggerDragStart: function _triggerDragStart(evt, touch) {
      touch = touch || evt.pointerType == "touch" && evt;
      if (!this.nativeDraggable || touch) {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._onTouchMove);
        } else if (touch) {
          on(document, "touchmove", this._onTouchMove);
        } else {
          on(document, "mousemove", this._onTouchMove);
        }
      } else {
        on(dragEl, "dragend", this);
        on(rootEl, "dragstart", this._onDragStart);
      }
      try {
        if (document.selection) {
          _nextTick(function() {
            document.selection.empty();
          });
        } else {
          window.getSelection().removeAllRanges();
        }
      } catch (err) {
      }
    },
    _dragStarted: function _dragStarted(fallback, evt) {
      awaitingDragStarted = false;
      if (rootEl && dragEl) {
        pluginEvent2("dragStarted", this, {
          evt
        });
        if (this.nativeDraggable) {
          on(document, "dragover", _checkOutsideTargetEl);
        }
        var options = this.options;
        !fallback && toggleClass(dragEl, options.dragClass, false);
        toggleClass(dragEl, options.ghostClass, true);
        Sortable.active = this;
        fallback && this._appendGhost();
        _dispatchEvent({
          sortable: this,
          name: "start",
          originalEvent: evt
        });
      } else {
        this._nulling();
      }
    },
    _emulateDragOver: function _emulateDragOver() {
      if (touchEvt) {
        this._lastX = touchEvt.clientX;
        this._lastY = touchEvt.clientY;
        _hideGhostForTarget();
        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        var parent = target;
        while (target && target.shadowRoot) {
          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          if (target === parent)
            break;
          parent = target;
        }
        dragEl.parentNode[expando]._isOutsideThisEl(target);
        if (parent) {
          do {
            if (parent[expando]) {
              var inserted = void 0;
              inserted = parent[expando]._onDragOver({
                clientX: touchEvt.clientX,
                clientY: touchEvt.clientY,
                target,
                rootEl: parent
              });
              if (inserted && !this.options.dragoverBubble) {
                break;
              }
            }
            target = parent;
          } while (parent = parent.parentNode);
        }
        _unhideGhostForTarget();
      }
    },
    _onTouchMove: function _onTouchMove(evt) {
      if (tapEvt) {
        var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
        if (!Sortable.active && !awaitingDragStarted) {
          if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
            return;
          }
          this._onDragStart(evt, true);
        }
        if (ghostEl) {
          if (ghostMatrix) {
            ghostMatrix.e += dx - (lastDx || 0);
            ghostMatrix.f += dy - (lastDy || 0);
          } else {
            ghostMatrix = {
              a: 1,
              b: 0,
              c: 0,
              d: 1,
              e: dx,
              f: dy
            };
          }
          var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
          css(ghostEl, "webkitTransform", cssMatrix);
          css(ghostEl, "mozTransform", cssMatrix);
          css(ghostEl, "msTransform", cssMatrix);
          css(ghostEl, "transform", cssMatrix);
          lastDx = dx;
          lastDy = dy;
          touchEvt = touch;
        }
        evt.cancelable && evt.preventDefault();
      }
    },
    _appendGhost: function _appendGhost() {
      if (!ghostEl) {
        var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
        if (PositionGhostAbsolutely) {
          ghostRelativeParent = container;
          while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
            ghostRelativeParent = ghostRelativeParent.parentNode;
          }
          if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
            if (ghostRelativeParent === document)
              ghostRelativeParent = getWindowScrollingElement();
            rect.top += ghostRelativeParent.scrollTop;
            rect.left += ghostRelativeParent.scrollLeft;
          } else {
            ghostRelativeParent = getWindowScrollingElement();
          }
          ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
        }
        ghostEl = dragEl.cloneNode(true);
        toggleClass(ghostEl, options.ghostClass, false);
        toggleClass(ghostEl, options.fallbackClass, true);
        toggleClass(ghostEl, options.dragClass, true);
        css(ghostEl, "transition", "");
        css(ghostEl, "transform", "");
        css(ghostEl, "box-sizing", "border-box");
        css(ghostEl, "margin", 0);
        css(ghostEl, "top", rect.top);
        css(ghostEl, "left", rect.left);
        css(ghostEl, "width", rect.width);
        css(ghostEl, "height", rect.height);
        css(ghostEl, "opacity", "0.8");
        css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
        css(ghostEl, "zIndex", "100000");
        css(ghostEl, "pointerEvents", "none");
        Sortable.ghost = ghostEl;
        container.appendChild(ghostEl);
        css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
      }
    },
    _onDragStart: function _onDragStart(evt, fallback) {
      var _this = this;
      var dataTransfer = evt.dataTransfer;
      var options = _this.options;
      pluginEvent2("dragStart", this, {
        evt
      });
      if (Sortable.eventCanceled) {
        this._onDrop();
        return;
      }
      pluginEvent2("setupClone", this);
      if (!Sortable.eventCanceled) {
        cloneEl = clone(dragEl);
        cloneEl.removeAttribute("id");
        cloneEl.draggable = false;
        cloneEl.style["will-change"] = "";
        this._hideClone();
        toggleClass(cloneEl, this.options.chosenClass, false);
        Sortable.clone = cloneEl;
      }
      _this.cloneId = _nextTick(function() {
        pluginEvent2("clone", _this);
        if (Sortable.eventCanceled)
          return;
        if (!_this.options.removeCloneOnHide) {
          rootEl.insertBefore(cloneEl, dragEl);
        }
        _this._hideClone();
        _dispatchEvent({
          sortable: _this,
          name: "clone"
        });
      });
      !fallback && toggleClass(dragEl, options.dragClass, true);
      if (fallback) {
        ignoreNextClick = true;
        _this._loopId = setInterval(_this._emulateDragOver, 50);
      } else {
        off(document, "mouseup", _this._onDrop);
        off(document, "touchend", _this._onDrop);
        off(document, "touchcancel", _this._onDrop);
        if (dataTransfer) {
          dataTransfer.effectAllowed = "move";
          options.setData && options.setData.call(_this, dataTransfer, dragEl);
        }
        on(document, "drop", _this);
        css(dragEl, "transform", "translateZ(0)");
      }
      awaitingDragStarted = true;
      _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
      on(document, "selectstart", _this);
      moved = true;
      if (Safari) {
        css(document.body, "user-select", "none");
      }
    },
    _onDragOver: function _onDragOver(evt) {
      var el3 = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
      if (_silent)
        return;
      function dragOverEvent(name2, extra) {
        pluginEvent2(name2, _this, _objectSpread2({
          evt,
          isOwner,
          axis: vertical ? "vertical" : "horizontal",
          revert,
          dragRect,
          targetRect,
          canSort,
          fromSortable,
          target,
          completed,
          onMove: function onMove(target2, after2) {
            return _onMove(rootEl, el3, dragEl, dragRect, target2, getRect(target2), evt, after2);
          },
          changed
        }, extra));
      }
      function capture() {
        dragOverEvent("dragOverAnimationCapture");
        _this.captureAnimationState();
        if (_this !== fromSortable) {
          fromSortable.captureAnimationState();
        }
      }
      function completed(insertion) {
        dragOverEvent("dragOverCompleted", {
          insertion
        });
        if (insertion) {
          if (isOwner) {
            activeSortable._hideClone();
          } else {
            activeSortable._showClone(_this);
          }
          if (_this !== fromSortable) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
            toggleClass(dragEl, options.ghostClass, true);
          }
          if (putSortable !== _this && _this !== Sortable.active) {
            putSortable = _this;
          } else if (_this === Sortable.active && putSortable) {
            putSortable = null;
          }
          if (fromSortable === _this) {
            _this._ignoreWhileAnimating = target;
          }
          _this.animateAll(function() {
            dragOverEvent("dragOverAnimationComplete");
            _this._ignoreWhileAnimating = null;
          });
          if (_this !== fromSortable) {
            fromSortable.animateAll();
            fromSortable._ignoreWhileAnimating = null;
          }
        }
        if (target === dragEl && !dragEl.animated || target === el3 && !target.animated) {
          lastTarget = null;
        }
        if (!options.dragoverBubble && !evt.rootEl && target !== document) {
          dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
          !insertion && nearestEmptyInsertDetectEvent(evt);
        }
        !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
        return completedFired = true;
      }
      function changed() {
        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);
        _dispatchEvent({
          sortable: _this,
          name: "change",
          toEl: el3,
          newIndex,
          newDraggableIndex,
          originalEvent: evt
        });
      }
      if (evt.preventDefault !== void 0) {
        evt.cancelable && evt.preventDefault();
      }
      target = closest(target, options.draggable, el3, true);
      dragOverEvent("dragOver");
      if (Sortable.eventCanceled)
        return completedFired;
      if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
        return completed(false);
      }
      ignoreNextClick = false;
      if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
        vertical = this._getDirection(evt, target) === "vertical";
        dragRect = getRect(dragEl);
        dragOverEvent("dragOverValid");
        if (Sortable.eventCanceled)
          return completedFired;
        if (revert) {
          parentEl = rootEl;
          capture();
          this._hideClone();
          dragOverEvent("revert");
          if (!Sortable.eventCanceled) {
            if (nextEl) {
              rootEl.insertBefore(dragEl, nextEl);
            } else {
              rootEl.appendChild(dragEl);
            }
          }
          return completed(true);
        }
        var elLastChild = lastChild(el3, options.draggable);
        if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
          if (elLastChild === dragEl) {
            return completed(false);
          }
          if (elLastChild && el3 === evt.target) {
            target = elLastChild;
          }
          if (target) {
            targetRect = getRect(target);
          }
          if (_onMove(rootEl, el3, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
            capture();
            if (elLastChild && elLastChild.nextSibling) {
              el3.insertBefore(dragEl, elLastChild.nextSibling);
            } else {
              el3.appendChild(dragEl);
            }
            parentEl = el3;
            changed();
            return completed(true);
          }
        } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
          var firstChild = getChild(el3, 0, options, true);
          if (firstChild === dragEl) {
            return completed(false);
          }
          target = firstChild;
          targetRect = getRect(target);
          if (_onMove(rootEl, el3, dragEl, dragRect, target, targetRect, evt, false) !== false) {
            capture();
            el3.insertBefore(dragEl, firstChild);
            parentEl = el3;
            changed();
            return completed(true);
          }
        } else if (target.parentNode === el3) {
          targetRect = getRect(target);
          var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el3, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
          if (lastTarget !== target) {
            targetBeforeFirstSwap = targetRect[side1];
            pastFirstInvertThresh = false;
            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
          }
          direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
          var sibling;
          if (direction !== 0) {
            var dragIndex = index(dragEl);
            do {
              dragIndex -= direction;
              sibling = parentEl.children[dragIndex];
            } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
          }
          if (direction === 0 || sibling === target) {
            return completed(false);
          }
          lastTarget = target;
          lastDirection = direction;
          var nextSibling = target.nextElementSibling, after = false;
          after = direction === 1;
          var moveVector = _onMove(rootEl, el3, dragEl, dragRect, target, targetRect, evt, after);
          if (moveVector !== false) {
            if (moveVector === 1 || moveVector === -1) {
              after = moveVector === 1;
            }
            _silent = true;
            setTimeout(_unsilent, 30);
            capture();
            if (after && !nextSibling) {
              el3.appendChild(dragEl);
            } else {
              target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
            }
            if (scrolledPastTop) {
              scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
            }
            parentEl = dragEl.parentNode;
            if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
              targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
            }
            changed();
            return completed(true);
          }
        }
        if (el3.contains(dragEl)) {
          return completed(false);
        }
      }
      return false;
    },
    _ignoreWhileAnimating: null,
    _offMoveEvents: function _offMoveEvents() {
      off(document, "mousemove", this._onTouchMove);
      off(document, "touchmove", this._onTouchMove);
      off(document, "pointermove", this._onTouchMove);
      off(document, "dragover", nearestEmptyInsertDetectEvent);
      off(document, "mousemove", nearestEmptyInsertDetectEvent);
      off(document, "touchmove", nearestEmptyInsertDetectEvent);
    },
    _offUpEvents: function _offUpEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, "mouseup", this._onDrop);
      off(ownerDocument, "touchend", this._onDrop);
      off(ownerDocument, "pointerup", this._onDrop);
      off(ownerDocument, "touchcancel", this._onDrop);
      off(document, "selectstart", this);
    },
    _onDrop: function _onDrop(evt) {
      var el3 = this.el, options = this.options;
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      pluginEvent2("drop", this, {
        evt
      });
      parentEl = dragEl && dragEl.parentNode;
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      if (Sortable.eventCanceled) {
        this._nulling();
        return;
      }
      awaitingDragStarted = false;
      isCircumstantialInvert = false;
      pastFirstInvertThresh = false;
      clearInterval(this._loopId);
      clearTimeout(this._dragStartTimer);
      _cancelNextTick(this.cloneId);
      _cancelNextTick(this._dragStartId);
      if (this.nativeDraggable) {
        off(document, "drop", this);
        off(el3, "dragstart", this._onDragStart);
      }
      this._offMoveEvents();
      this._offUpEvents();
      if (Safari) {
        css(document.body, "user-select", "");
      }
      css(dragEl, "transform", "");
      if (evt) {
        if (moved) {
          evt.cancelable && evt.preventDefault();
          !options.dropBubble && evt.stopPropagation();
        }
        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
        }
        if (dragEl) {
          if (this.nativeDraggable) {
            off(dragEl, "dragend", this);
          }
          _disableDraggable(dragEl);
          dragEl.style["will-change"] = "";
          if (moved && !awaitingDragStarted) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
          }
          toggleClass(dragEl, this.options.chosenClass, false);
          _dispatchEvent({
            sortable: this,
            name: "unchoose",
            toEl: parentEl,
            newIndex: null,
            newDraggableIndex: null,
            originalEvent: evt
          });
          if (rootEl !== parentEl) {
            if (newIndex >= 0) {
              _dispatchEvent({
                rootEl: parentEl,
                name: "add",
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "remove",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                rootEl: parentEl,
                name: "sort",
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
            putSortable && putSortable.save();
          } else {
            if (newIndex !== oldIndex) {
              if (newIndex >= 0) {
                _dispatchEvent({
                  sortable: this,
                  name: "update",
                  toEl: parentEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  sortable: this,
                  name: "sort",
                  toEl: parentEl,
                  originalEvent: evt
                });
              }
            }
          }
          if (Sortable.active) {
            if (newIndex == null || newIndex === -1) {
              newIndex = oldIndex;
              newDraggableIndex = oldDraggableIndex;
            }
            _dispatchEvent({
              sortable: this,
              name: "end",
              toEl: parentEl,
              originalEvent: evt
            });
            this.save();
          }
        }
      }
      this._nulling();
    },
    _nulling: function _nulling() {
      pluginEvent2("nulling", this);
      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
      savedInputChecked.forEach(function(el3) {
        el3.checked = true;
      });
      savedInputChecked.length = lastDx = lastDy = 0;
    },
    handleEvent: function handleEvent(evt) {
      switch (evt.type) {
        case "drop":
        case "dragend":
          this._onDrop(evt);
          break;
        case "dragenter":
        case "dragover":
          if (dragEl) {
            this._onDragOver(evt);
            _globalDragOver(evt);
          }
          break;
        case "selectstart":
          evt.preventDefault();
          break;
      }
    },
    toArray: function toArray() {
      var order = [], el3, children = this.el.children, i = 0, n = children.length, options = this.options;
      for (; i < n; i++) {
        el3 = children[i];
        if (closest(el3, options.draggable, this.el, false)) {
          order.push(el3.getAttribute(options.dataIdAttr) || _generateId(el3));
        }
      }
      return order;
    },
    sort: function sort(order, useAnimation) {
      var items = {}, rootEl2 = this.el;
      this.toArray().forEach(function(id2, i) {
        var el3 = rootEl2.children[i];
        if (closest(el3, this.options.draggable, rootEl2, false)) {
          items[id2] = el3;
        }
      }, this);
      useAnimation && this.captureAnimationState();
      order.forEach(function(id2) {
        if (items[id2]) {
          rootEl2.removeChild(items[id2]);
          rootEl2.appendChild(items[id2]);
        }
      });
      useAnimation && this.animateAll();
    },
    save: function save() {
      var store = this.options.store;
      store && store.set && store.set(this);
    },
    closest: function closest$1(el3, selector) {
      return closest(el3, selector || this.options.draggable, this.el, false);
    },
    option: function option(name2, value) {
      var options = this.options;
      if (value === void 0) {
        return options[name2];
      } else {
        var modifiedValue = PluginManager.modifyOption(this, name2, value);
        if (typeof modifiedValue !== "undefined") {
          options[name2] = modifiedValue;
        } else {
          options[name2] = value;
        }
        if (name2 === "group") {
          _prepareGroup(options);
        }
      }
    },
    destroy: function destroy() {
      pluginEvent2("destroy", this);
      var el3 = this.el;
      el3[expando] = null;
      off(el3, "mousedown", this._onTapStart);
      off(el3, "touchstart", this._onTapStart);
      off(el3, "pointerdown", this._onTapStart);
      if (this.nativeDraggable) {
        off(el3, "dragover", this);
        off(el3, "dragenter", this);
      }
      Array.prototype.forEach.call(el3.querySelectorAll("[draggable]"), function(el4) {
        el4.removeAttribute("draggable");
      });
      this._onDrop();
      this._disableDelayedDragEvents();
      sortables.splice(sortables.indexOf(this.el), 1);
      this.el = el3 = null;
    },
    _hideClone: function _hideClone() {
      if (!cloneHidden) {
        pluginEvent2("hideClone", this);
        if (Sortable.eventCanceled)
          return;
        css(cloneEl, "display", "none");
        if (this.options.removeCloneOnHide && cloneEl.parentNode) {
          cloneEl.parentNode.removeChild(cloneEl);
        }
        cloneHidden = true;
      }
    },
    _showClone: function _showClone(putSortable2) {
      if (putSortable2.lastPutMode !== "clone") {
        this._hideClone();
        return;
      }
      if (cloneHidden) {
        pluginEvent2("showClone", this);
        if (Sortable.eventCanceled)
          return;
        if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
          rootEl.insertBefore(cloneEl, dragEl);
        } else if (nextEl) {
          rootEl.insertBefore(cloneEl, nextEl);
        } else {
          rootEl.appendChild(cloneEl);
        }
        if (this.options.group.revertClone) {
          this.animate(dragEl, cloneEl);
        }
        css(cloneEl, "display", "");
        cloneHidden = false;
      }
    }
  };
  function _globalDragOver(evt) {
    if (evt.dataTransfer) {
      evt.dataTransfer.dropEffect = "move";
    }
    evt.cancelable && evt.preventDefault();
  }
  function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
    var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent("move", {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent("Event");
      evt.initEvent("move", true, true);
    }
    evt.to = toEl;
    evt.from = fromEl;
    evt.dragged = dragEl2;
    evt.draggedRect = dragRect;
    evt.related = targetEl || toEl;
    evt.relatedRect = targetRect || getRect(toEl);
    evt.willInsertAfter = willInsertAfter;
    evt.originalEvent = originalEvent;
    fromEl.dispatchEvent(evt);
    if (onMoveFn) {
      retVal = onMoveFn.call(sortable, evt, originalEvent);
    }
    return retVal;
  }
  function _disableDraggable(el3) {
    el3.draggable = false;
  }
  function _unsilent() {
    _silent = false;
  }
  function _ghostIsFirst(evt, vertical, sortable) {
    var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
    var spacer = 10;
    return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
  }
  function _ghostIsLast(evt, vertical, sortable) {
    var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
    var spacer = 10;
    return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
  }
  function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
    var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
    if (!invertSwap) {
      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
        if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
          pastFirstInvertThresh = true;
        }
        if (!pastFirstInvertThresh) {
          if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
            return -lastDirection;
          }
        } else {
          invert = true;
        }
      } else {
        if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
          return _getInsertDirection(target);
        }
      }
    }
    invert = invert || invertSwap;
    if (invert) {
      if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
      }
    }
    return 0;
  }
  function _getInsertDirection(target) {
    if (index(dragEl) < index(target)) {
      return 1;
    } else {
      return -1;
    }
  }
  function _generateId(el3) {
    var str = el3.tagName + el3.className + el3.src + el3.href + el3.textContent, i = str.length, sum = 0;
    while (i--) {
      sum += str.charCodeAt(i);
    }
    return sum.toString(36);
  }
  function _saveInputCheckedState(root) {
    savedInputChecked.length = 0;
    var inputs = root.getElementsByTagName("input");
    var idx = inputs.length;
    while (idx--) {
      var el3 = inputs[idx];
      el3.checked && savedInputChecked.push(el3);
    }
  }
  function _nextTick(fn2) {
    return setTimeout(fn2, 0);
  }
  function _cancelNextTick(id2) {
    return clearTimeout(id2);
  }
  if (documentExists) {
    on(document, "touchmove", function(evt) {
      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
        evt.preventDefault();
      }
    });
  }
  Sortable.utils = {
    on,
    off,
    css,
    find: find2,
    is: function is17(el3, selector) {
      return !!closest(el3, selector, el3, false);
    },
    extend: extend2,
    throttle,
    closest,
    toggleClass,
    clone,
    index,
    nextTick: _nextTick,
    cancelNextTick: _cancelNextTick,
    detectDirection: _detectDirection,
    getChild
  };
  Sortable.get = function(element) {
    return element[expando];
  };
  Sortable.mount = function() {
    for (var _len = arguments.length, plugins3 = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins3[_key] = arguments[_key];
    }
    if (plugins3[0].constructor === Array)
      plugins3 = plugins3[0];
    plugins3.forEach(function(plugin) {
      if (!plugin.prototype || !plugin.prototype.constructor) {
        throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
      }
      if (plugin.utils)
        Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
      PluginManager.mount(plugin);
    });
  };
  Sortable.create = function(el3, options) {
    return new Sortable(el3, options);
  };
  Sortable.version = version2;
  var autoScrolls = [];
  var scrollEl;
  var scrollRootEl;
  var scrolling = false;
  var lastAutoScrollX;
  var lastAutoScrollY;
  var touchEvt$1;
  var pointerElemChangedInterval;
  function AutoScrollPlugin() {
    function AutoScroll() {
      this.defaults = {
        scroll: true,
        forceAutoScrollFallback: false,
        scrollSensitivity: 30,
        scrollSpeed: 10,
        bubbleScroll: true
      };
      for (var fn2 in this) {
        if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
          this[fn2] = this[fn2].bind(this);
        }
      }
    }
    AutoScroll.prototype = {
      dragStarted: function dragStarted(_ref) {
        var originalEvent = _ref.originalEvent;
        if (this.sortable.nativeDraggable) {
          on(document, "dragover", this._handleAutoScroll);
        } else {
          if (this.options.supportPointer) {
            on(document, "pointermove", this._handleFallbackAutoScroll);
          } else if (originalEvent.touches) {
            on(document, "touchmove", this._handleFallbackAutoScroll);
          } else {
            on(document, "mousemove", this._handleFallbackAutoScroll);
          }
        }
      },
      dragOverCompleted: function dragOverCompleted(_ref2) {
        var originalEvent = _ref2.originalEvent;
        if (!this.options.dragOverBubble && !originalEvent.rootEl) {
          this._handleAutoScroll(originalEvent);
        }
      },
      drop: function drop3() {
        if (this.sortable.nativeDraggable) {
          off(document, "dragover", this._handleAutoScroll);
        } else {
          off(document, "pointermove", this._handleFallbackAutoScroll);
          off(document, "touchmove", this._handleFallbackAutoScroll);
          off(document, "mousemove", this._handleFallbackAutoScroll);
        }
        clearPointerElemChangedInterval();
        clearAutoScrolls();
        cancelThrottle();
      },
      nulling: function nulling() {
        touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
        autoScrolls.length = 0;
      },
      _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
        this._handleAutoScroll(evt, true);
      },
      _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
        var _this = this;
        var x = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y2);
        touchEvt$1 = evt;
        if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
          autoScroll(evt, this.options, elem, fallback);
          var ogElemScroller = getParentAutoScrollElement(elem, true);
          if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y2 !== lastAutoScrollY)) {
            pointerElemChangedInterval && clearPointerElemChangedInterval();
            pointerElemChangedInterval = setInterval(function() {
              var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y2), true);
              if (newElem !== ogElemScroller) {
                ogElemScroller = newElem;
                clearAutoScrolls();
              }
              autoScroll(evt, _this.options, newElem, fallback);
            }, 10);
            lastAutoScrollX = x;
            lastAutoScrollY = y2;
          }
        } else {
          if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
            clearAutoScrolls();
            return;
          }
          autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
        }
      }
    };
    return _extends(AutoScroll, {
      pluginName: "scroll",
      initializeByDefault: true
    });
  }
  function clearAutoScrolls() {
    autoScrolls.forEach(function(autoScroll2) {
      clearInterval(autoScroll2.pid);
    });
    autoScrolls = [];
  }
  function clearPointerElemChangedInterval() {
    clearInterval(pointerElemChangedInterval);
  }
  var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
    if (!options.scroll)
      return;
    var x = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
    var scrollThisInstance = false, scrollCustomFn;
    if (scrollRootEl !== rootEl2) {
      scrollRootEl = rootEl2;
      clearAutoScrolls();
      scrollEl = options.scroll;
      scrollCustomFn = options.scrollFn;
      if (scrollEl === true) {
        scrollEl = getParentAutoScrollElement(rootEl2, true);
      }
    }
    var layersOut = 0;
    var currentParent = scrollEl;
    do {
      var el3 = currentParent, rect = getRect(el3), top2 = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el3.scrollWidth, scrollHeight = el3.scrollHeight, elCSS = css(el3), scrollPosX = el3.scrollLeft, scrollPosY = el3.scrollTop;
      if (el3 === winScroller) {
        canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
        canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
      } else {
        canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
        canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
      }
      var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
      var vy = canScrollY && (Math.abs(bottom - y2) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top2 - y2) <= sens && !!scrollPosY);
      if (!autoScrolls[layersOut]) {
        for (var i = 0; i <= layersOut; i++) {
          if (!autoScrolls[i]) {
            autoScrolls[i] = {};
          }
        }
      }
      if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el3) {
        autoScrolls[layersOut].el = el3;
        autoScrolls[layersOut].vx = vx;
        autoScrolls[layersOut].vy = vy;
        clearInterval(autoScrolls[layersOut].pid);
        if (vx != 0 || vy != 0) {
          scrollThisInstance = true;
          autoScrolls[layersOut].pid = setInterval(function() {
            if (isFallback && this.layer === 0) {
              Sortable.active._onTouchMove(touchEvt$1);
            }
            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
            if (typeof scrollCustomFn === "function") {
              if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
                return;
              }
            }
            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
          }.bind({
            layer: layersOut
          }), 24);
        }
      }
      layersOut++;
    } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
    scrolling = scrollThisInstance;
  }, 30);
  var drop = function drop2(_ref) {
    var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
    if (!originalEvent)
      return;
    var toSortable = putSortable2 || activeSortable;
    hideGhostForTarget();
    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
    var target = document.elementFromPoint(touch.clientX, touch.clientY);
    unhideGhostForTarget();
    if (toSortable && !toSortable.el.contains(target)) {
      dispatchSortableEvent("spill");
      this.onSpill({
        dragEl: dragEl2,
        putSortable: putSortable2
      });
    }
  };
  function Revert() {
  }
  Revert.prototype = {
    startIndex: null,
    dragStart: function dragStart(_ref2) {
      var oldDraggableIndex2 = _ref2.oldDraggableIndex;
      this.startIndex = oldDraggableIndex2;
    },
    onSpill: function onSpill(_ref3) {
      var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
      this.sortable.captureAnimationState();
      if (putSortable2) {
        putSortable2.captureAnimationState();
      }
      var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
      if (nextSibling) {
        this.sortable.el.insertBefore(dragEl2, nextSibling);
      } else {
        this.sortable.el.appendChild(dragEl2);
      }
      this.sortable.animateAll();
      if (putSortable2) {
        putSortable2.animateAll();
      }
    },
    drop
  };
  _extends(Revert, {
    pluginName: "revertOnSpill"
  });
  function Remove() {
  }
  Remove.prototype = {
    onSpill: function onSpill2(_ref4) {
      var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
      var parentSortable = putSortable2 || this.sortable;
      parentSortable.captureAnimationState();
      dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
      parentSortable.animateAll();
    },
    drop
  };
  _extends(Remove, {
    pluginName: "removeOnSpill"
  });
  Sortable.mount(new AutoScrollPlugin());
  Sortable.mount(Remove, Revert);
  var sortable_esm_default = Sortable;

  // static/js/parsons.ts
  function loadParsonsExercise(level3, exercise) {
    $("#next_parson_button").hide();
    let parameters = new URLSearchParams(window.location.search);
    let url = "/parsons/get-exercise/" + level3 + "/" + exercise;
    if (parameters.has("keyword_language")) {
      url += "/" + parameters.get("keyword_language");
    }
    $.ajax({
      type: "GET",
      url,
      dataType: "json"
    }).done(function(response) {
      $("#parsons_container").show();
      $("#next_parson_button").attr("current_exercise", exercise);
      resetView();
      updateHeader(exercise);
      showExercise(response);
      updateNextExerciseButton(level3, exercise);
    }).fail(function(err) {
      modal.notifyError(err.responseText);
    });
  }
  function resetView() {
    stopit();
    if (Object.keys(editorDict).length === 0) {
      initializeParsons();
    }
    $("#output").empty();
    $(".parsons_goal_line_container").removeClass("border-green-500 border-red-500");
  }
  function updateHeader(exercise) {
    $(".parsons_header_text_container").hide();
    $(".step").removeClass("current");
    $("#parsons_header_text_" + exercise).show();
    $("#parsons_header_" + exercise).addClass("current");
  }
  var editorDict = {};
  function showExercise(response) {
    const code_lines = parse_code_string_into_dict(response.code);
    let keys = Object.keys(code_lines);
    $(".parsons_start_line_container").hide();
    $(".parsons_goal_line_container").hide();
    fisherYatesShuffle(keys);
    keys.forEach((key, i) => {
      const valueObj = code_lines[key];
      const counter = i + 1;
      const goalEditor = editorDict[i + 1];
      goalEditor.contents = valueObj;
      document.getElementById("parsons_line_data_" + counter).dataset["index"] = key;
      document.getElementById("parsons_line_data_" + counter).dataset["code"] = valueObj;
      $("#parsons_line_" + counter).show();
    });
    let parsons = document.getElementById("parsons_code_container");
    sortable_esm_default.create(parsons, {
      animation: 150,
      onStart: () => {
        $(".parsons_goal_line_container").removeClass("border-green-500 border-red-500");
      }
    });
    $("#parsons_explanation_story").text(response.story);
  }
  function updateNextExerciseButton(level3, exercise) {
    const max_exercise = $("#next_parson_button").attr("max_exercise") || 1;
    if (exercise < max_exercise) {
      $("#next_parson_button").on("click", () => loadParsonsExercise(level3, exercise + 1));
    } else {
      $("#next_parson_button").off("click");
    }
  }
  function parse_code_string_into_dict(code) {
    const splitted_code = code.split(/\r?\n/).filter((e) => String(e).trim());
    let code_lines = {};
    for (let index3 = 0; index3 < splitted_code.length; index3++) {
      code_lines[index3 + 1] = splitted_code[index3];
    }
    return code_lines;
  }
  function get_parsons_code() {
    let code = "";
    let order = new Array();
    let mistake = false;
    document.querySelectorAll("#parsons_code_container > div > div").forEach((element, key) => {
      if (!$(element).is(":visible")) {
        return;
      }
      const parent = element.parentElement;
      let text = element.dataset["code"] || "";
      if (text.length > 1) {
        code += text + "\n";
      }
      parent.classList.remove("border-green-500");
      parent.classList.remove("border-red-500");
      const index3 = element.dataset["index"] || 999;
      if (index3 == key + 1) {
        parent.classList.add("border-green-500");
      } else {
        mistake = true;
        parent.classList.add("border-red-500");
      }
      order.push(index3);
    });
    store_parsons_attempt(order, !mistake);
    if (mistake) {
      return "";
    }
    return code.replace(/ +$/mg, "");
  }
  function fisherYatesShuffle(xs) {
    for (let i = xs.length - 1; i >= 1; i--) {
      const j2 = Math.floor(Math.random() * i);
      const h3 = xs[j2];
      xs[j2] = xs[i];
      xs[i] = h3;
    }
  }
  function initializeParsons() {
    if (Object.keys(editorDict).length > 0) {
      return;
    }
    const editorCreator3 = new HedyCodeMirrorEditorCreator();
    const parsonCodeContainers = document.querySelectorAll("#parsons_code_container > div > pre");
    parsonCodeContainers.forEach((container, i) => {
      const editor = editorCreator3.initializeReadOnlyEditor(container, "ltr");
      editorDict[i + 1] = editor;
    });
  }

  // static/js/browser-helpers/on-element-becomes-visible.ts
  var SCROLL_HANDLERS = new Array();
  function isInView(elem) {
    var docViewTop = $(window).scrollTop();
    var docViewBottom = docViewTop + $(window).height();
    var elemTop = $(elem).offset().top;
    return elemTop <= docViewBottom && elemTop >= docViewTop;
  }
  function checkNow() {
    for (let i = 0; i < SCROLL_HANDLERS.length; ) {
      const [element, handler2] = SCROLL_HANDLERS[i];
      if (isInView(element)) {
        handler2();
        SCROLL_HANDLERS.splice(i, 1);
      } else {
        i += 1;
      }
    }
  }
  $(window).on("scroll", checkNow);
  function onElementBecomesVisible(element, handler2) {
    if (isInView(element)) {
      handler2();
    } else {
      SCROLL_HANDLERS.push([element, handler2]);
    }
  }

  // static/js/ace-editor.ts
  var MOVE_CURSOR_TO_END = 1;
  var BP_DISABLED_LINE = "ace_breakpoint";
  var HedyAceEditor = class {
    constructor(element, isReadOnly, editorType, dir = "ltr") {
      this.editorEvent = new EventEmitter({
        change: true,
        guttermousedown: true,
        changeBreakpoint: true,
        click: true
      });
      this.markerClasses = new Map();
      this.strikeMarkers = new Map();
      this._editor = ace.edit(element);
      this.isReadOnly = isReadOnly;
      this._editor.setTheme("ace/theme/monokai");
      if (isReadOnly) {
        this._editor.setValue(this._editor.getValue().trimRight(), -1);
        this._editor.renderer.$cursorLayer.element.style.display = "none";
        this._editor.setOptions({
          readOnly: editorType === EditorType.MAIN,
          showGutter: false,
          showPrintMargin: false,
          highlightActiveLine: false
        });
        this._editor.renderer.setScrollMargin(3, 3, 10, 20);
        this._editor.setOptions({ maxLines: Infinity });
        if (editorType === EditorType.CHEATSHEET) {
          this._editor.setOptions({ minLines: 1 });
        } else if (editorType === EditorType.COMMON_MISTAKES) {
          this._editor.setOptions({
            showGutter: true,
            showPrintMargin: true,
            highlightActiveLine: true,
            minLines: 5
          });
        } else if (editorType === EditorType.PARSONS) {
          this._editor.setOptions({
            minLines: 1,
            showGutter: false,
            showPrintMargin: false,
            highlightActiveLine: false
          });
        } else if (editorType === EditorType.EXAMPLE) {
          this._editor.setOptions({ minLines: 2 });
        }
      } else {
        if (editorType === EditorType.MAIN) {
          this._editor.setShowPrintMargin(false);
          this._editor.renderer.setScrollMargin(0, 0, 0, 20);
        }
      }
      if (theLevel) {
        this.setHighlighterForLevel(theLevel);
      }
      if (dir === "rtl") {
        this._editor.setOptions({ rtl: true });
      }
    }
    setHighlighterForLevel(level3) {
      const mode = this.getHighlighter(level3);
      this._editor.session.setMode(mode);
    }
    get contents() {
      return this._editor.getValue();
    }
    set contents(content2) {
      this._editor.setValue(content2, MOVE_CURSOR_TO_END);
    }
    get isReadOnly() {
      return this._editor.getReadOnly();
    }
    set isReadOnly(isReadMode) {
      this._editor.setReadOnly(isReadMode);
    }
    resize() {
      console.warn("Oops! editor.resize() should not have been called anymore");
      this._editor.resize();
    }
    focus() {
      this._editor.focus();
    }
    clearErrors() {
      this._editor.session.clearAnnotations();
      for (const marker of this.findMarkers("editor-error")) {
        this.removeMarker(marker);
      }
    }
    moveCursorToEndOfFile() {
      this._editor.navigateFileEnd();
    }
    clearSelection() {
      this._editor.clearSelection();
    }
    clearBreakpoints() {
      this._editor.session.clearBreakpoints();
    }
    getDeactivatedLines() {
      return this._editor.session.getBreakpoints();
    }
    getHighlighter(level3) {
      return `ace/mode/level${level3}`;
    }
    trimTrailingSpace() {
      try {
        const whitespace = ace.require("ace/ext/whitespace");
        whitespace.trimTrailingSpace(this._editor.session, true);
      } catch (e) {
        console.error(e);
      }
    }
    on(key, handler2) {
      const ret = this.editorEvent.on(key, handler2);
      if (key == "changeBreakpoint") {
        this._editor.session.on(key, handler2);
      } else {
        this._editor.addEventListener(key, handler2);
      }
      return ret;
    }
    highlightError(row, col) {
      if (col === void 0) {
        this.addMarker(new ace.Range(row - 1, 1, row - 1, 2), "editor-error", "fullLine");
        return;
      }
      const length = this._editor.session.getLine(row - 1).slice(col - 1).split(/(\s+)/)[0].length;
      if (length > 0) {
        this.addMarker(new ace.Range(row - 1, col - 1, row - 1, col - 1 + length), "editor-error", "text");
      } else {
        this.addMarker(new ace.Range(row - 1, 1, row - 1, 2), "editor-error", "fullLine");
      }
    }
    setIncorrectLine(range10, lineIndex) {
      const aceRange = new ace.Range(range10.startLine - 1, range10.startColumn - 1, range10.endLine - 1, range10.endColumn - 1);
      this.addMarker(aceRange, `ace_incorrect_hedy_code_${lineIndex}`, "text", true);
    }
    clearIncorrectLines() {
      const markers = this._editor.session.getMarkers(true);
      if (markers) {
        for (const index3 in markers) {
          let marker = markers[index3];
          if (marker.clazz.includes("ace_incorrect_hedy_code")) {
            this.removeMarker(Number(index3));
          }
        }
      }
    }
    setDebuggerCurrentLine(line, startPos, finishPos) {
      if (this.currentLineMarker) {
        this.removeMarker(this.currentLineMarker.id);
      }
      if (line === void 0) {
        this.currentLineMarker = void 0;
        return;
      }
      line = line - 1;
      let id2;
      if (startPos === void 0 || finishPos === void 0) {
        id2 = this.addMarker(new ace.Range(line, 0, line, 999), "debugger-current-line", "fullLine");
      } else {
        id2 = this.addMarker(new ace.Range(line, startPos - 1, line, finishPos - 1), "debugger-current-line", "text");
      }
      this.currentLineMarker = { line, id: id2 };
    }
    strikethroughLines(lines) {
      const struckLines = new Set(lines);
      const noLongerStruck = Array.from(this.strikeMarkers.entries()).filter(([line, _]) => !struckLines.has(line));
      for (const [line, id2] of noLongerStruck) {
        this.removeMarker(id2);
        this.strikeMarkers.delete(line);
      }
      const newlyStruck = lines.filter((line) => !this.strikeMarkers.has(line));
      for (const line of newlyStruck) {
        const id2 = this.addMarker(new ace.Range(line, 0, line, 999), "disabled-line", "text", true);
        this.strikeMarkers.set(line, id2);
      }
    }
    addMarker(range10, klass, scope, inFront = false) {
      const id2 = this._editor.session.addMarker(range10, klass, scope, inFront);
      this.markerClasses.set(id2, klass);
      return id2;
    }
    removeMarker(id2) {
      this._editor.session.removeMarker(id2);
      this.markerClasses.delete(id2);
    }
    findMarkers(klass) {
      return Array.from(this.markerClasses.entries()).filter(([_, k]) => k === klass).map(([id2, _]) => id2);
    }
    getActiveContents(debugLine2) {
      let code = this._editor.session.getValue();
      const breakpoints = this.getDeactivatedLines();
      if (code) {
        let lines = code.split("\n");
        if (debugLine2 != null) {
          lines = lines.slice(0, parseInt(debugLine2) + 1);
        }
        for (let i = 0; i < lines.length; i++) {
          if (breakpoints[i] == BP_DISABLED_LINE) {
            lines[i] = "";
          }
        }
        code = lines.join("\n");
      }
      return code;
    }
    skipFaultyHandler() {
      $(document).on("click", "div[class*=ace_content], div[class*=ace_incorrect_hedy_code]", function(e) {
        let className = e.target.className;
        if ($("div[class*=ace_incorrect_hedy_code]")[0]) {
          if (className === "ace_content") {
            $("#okbox").hide();
            $("#warningbox").hide();
            $("#errorbox").hide();
          } else {
            let mapIndex = className;
            mapIndex = mapIndex.replace("ace_incorrect_hedy_code_", "");
            mapIndex = mapIndex.replace("ace_start ace_br15", "");
            let mapError = theGlobalSourcemap[Number(mapIndex)];
            $("#okbox").hide();
            $("#warningbox").hide();
            $("#errorbox").hide();
            error.show(ClientMessages["Transpile_error"], mapError.error);
          }
        }
      });
    }
  };

  // static/js/debugging.ts
  var theGlobalEditor2;
  var theLevel2;
  var theLanguage;
  var TRADUCTION2;
  var variable_view = false;
  var step_debugger = false;
  var fullLineCommands = [
    "print",
    "echo",
    "assign",
    "sleep",
    "assign_list",
    "add",
    "remove",
    "ask",
    "command"
  ];
  var blockCommands = [
    "ifs",
    "ifelse",
    "ifpressed_else",
    "repeat",
    "ifpressed",
    "elses",
    "ifpressed_elses",
    "for_list",
    "for_loop",
    "while_loop",
    "elifs",
    "ifpressed_elifs"
  ];
  var ifRegex = "((__if__) *[^\n ]+ *((__is__)|(__in__)) *[^\n ]+) *.*";
  var repeatRegex = "((__repeat__) *[^\n ]+ *(__times__)) *[^\n ]+ *.+";
  var elseRegex = "^(__else__) *[^\n ]+.+$";
  function hide_if_no_variables() {
    if ($("#variables #variable-list li").length == 0) {
      $("#variable_button").hide();
    } else {
      $("#variable_button").show();
    }
  }
  function show_variables() {
    if (variable_view === true) {
      const variableList = $("#variable-list");
      if (variableList.hasClass("hidden")) {
        variableList.removeClass("hidden");
      }
    }
  }
  function load_variables(variables) {
    if (variable_view === true) {
      variables = clean_variables(variables);
      const variableList = $("#variable-list");
      variableList.empty();
      for (const i in variables) {
        if (variables[i][1]) {
          variableList.append(`<li style=color:${variables[i][2]}>${variables[i][0]}: ${variables[i][1]}</li>`);
        }
      }
      hide_if_no_variables();
    }
  }
  function special_style_for_variable(variable) {
    let result = "";
    let parsedVariable = parseInt(variable.v);
    if (typeof parsedVariable == "number" && !isNaN(parsedVariable)) {
      result = "#ffffff";
    }
    if (typeof variable.v == "string" && isNaN(parsedVariable)) {
      result = "#ffffff";
    }
    if (typeof variable.v == "boolean") {
      result = "#ffffff";
    }
    if (variable.tp$name == "list") {
      result = "#ffffff";
    }
    return result;
  }
  function clean_variables(variables) {
    const new_variables = [];
    const unwanted_variables = ["random", "time", "int_saver", "int_$rw$", "turtle", "t"];
    for (const variable in variables) {
      if (!variable.includes("__") && !unwanted_variables.includes(variable)) {
        let extraStyle = special_style_for_variable(variables[variable]);
        let name2 = unfixReserved(variable);
        let newTuple = [name2, variables[variable].v, extraStyle];
        new_variables.push(newTuple);
      }
    }
    return new_variables;
  }
  function unfixReserved(name2) {
    return name2.replace(/_\$rw\$$/, "");
  }
  var BP_DISABLED_LINE2 = "ace_breakpoint";
  function initializeDebugger(options) {
    theGlobalEditor2 = options.editor;
    theLevel2 = options.level;
    theLanguage = options.language;
    let TRADUCTIONS = convert(highlighting_trad_default);
    let lang = options.keywordLanguage;
    if (!TRADUCTIONS.has(lang)) {
      lang = "en";
    }
    TRADUCTION2 = TRADUCTIONS.get(lang);
    if (!variable_view) {
      $("#variables").hide();
      $("#variable_button").hide();
    }
    if (options.level > 0) {
      let level3 = options.level;
      step_debugger = level3 <= 700;
    }
    if (!step_debugger) {
      $("#debug_button").hide();
    }
    if (options.level != 0) {
      let level3 = options.level;
      variable_view = level3 >= 2;
      hide_if_no_variables();
    }
    initializeBreakpoints(options.editor);
  }
  function initializeBreakpoints(editor) {
    editor.on("guttermousedown", function(e) {
      const target = e.domEvent.target;
      if (target.className.indexOf("ace_gutter-cell") == -1)
        return;
      if (e.clientX > 25 + target.getBoundingClientRect().left)
        return;
      const breakpoints = getBreakpoints(e.editor);
      let row = e.getDocumentPosition().row;
      if (breakpoints[row] === void 0 && row !== e.editor.getLastVisibleRow() + 1) {
        if (get_shift_key(event)) {
          let highest_key = row;
          for (const key in breakpoints) {
            const number_key = parseInt(key);
            if (number_key < row) {
              highest_key = number_key;
            }
          }
          for (let i = highest_key; i <= row; i++) {
            e.editor.session.setBreakpoint(i, BP_DISABLED_LINE2);
          }
        } else {
          e.editor.session.setBreakpoint(row, BP_DISABLED_LINE2);
        }
      } else {
        e.editor.session.clearBreakpoint(row);
      }
      e.stop();
    });
    editor.on("changeBreakpoint", function() {
      if (theGlobalEditor2 instanceof HedyAceEditor) {
        const breakpoints = theGlobalEditor2.getDeactivatedLines();
        const disabledLines = Object.entries(breakpoints).filter(([_, bpClass]) => bpClass === BP_DISABLED_LINE2).map(([line, _]) => line).map((x) => parseInt(x, 10));
        theGlobalEditor2.strikethroughLines(disabledLines);
      }
    });
  }
  function get_shift_key(event2) {
    if (event2.shiftKey) {
      return true;
    }
    return false;
  }
  function debugRun() {
    if (theLevel2 && theLanguage) {
      runit(theLevel2, theLanguage, "", "run", function() {
        $("#output").focus();
      });
    }
  }
  function startDebug() {
    if (step_debugger === true) {
      var debugButton = $("#debug_button");
      debugButton.hide();
      var continueButton = $("#debug_continue");
      var stopButton = $("#debug_stop");
      var resetButton = $("#debug_restart");
      var runButtonContainer = $("#runButtonContainer");
      runButtonContainer.hide();
      continueButton.show();
      stopButton.show();
      resetButton.show();
    }
  }
  function resetDebug() {
    if (step_debugger === true) {
      var storage = window.localStorage;
      var continueButton = $("#debug_continue");
      continueButton.show();
      storage.setItem("debugLine", "0");
      clearDebugVariables();
      markCurrentDebuggerLine();
      debugRun();
    }
  }
  function stopDebug() {
    if (step_debugger === true) {
      var debugButton = $("#debug_button");
      debugButton.show();
      var continueButton = $("#debug_continue");
      var stopButton = $("#debug_stop");
      var resetButton = $("#debug_restart");
      var runButtonContainer = $("#runButtonContainer");
      $("#stopit").hide();
      $("#runit").show();
      runButtonContainer.show();
      continueButton.hide();
      stopButton.hide();
      resetButton.hide();
      var storage = window.localStorage;
      storage.removeItem("debugLine");
      clearDebugVariables();
      markCurrentDebuggerLine();
    }
  }
  function clearDebugVariables() {
    var storage = window.localStorage;
    var keysToRemove = __spreadValues({}, localStorage);
    for (var key in keysToRemove) {
      if (key.includes("prompt-")) {
        storage.removeItem(key);
      }
    }
  }
  function incrementDebugLine() {
    const active_suspension = theGlobalDebugger.getActiveSuspension();
    const suspension_info = theGlobalDebugger.getSuspensionInfo(active_suspension);
    const lineNumber = suspension_info.lineno;
    load_variables(suspension_info.variables);
    const ifRegexTranslated = ifRegex.replace("__if__", TRADUCTION2.get("if")).replace("__is__", TRADUCTION2.get("is")).replace("__in__", TRADUCTION2.get("in"));
    const repeatRegexTranslated = repeatRegex.replace("__repeat__", TRADUCTION2.get("repeat")).replace("__times__", TRADUCTION2.get("times"));
    const elseRegexTranslated = elseRegex.replace("__else__", TRADUCTION2.get("else"));
    const ifRe = new RegExp(ifRegexTranslated, "gu");
    const repeatRe = new RegExp(repeatRegexTranslated, "gu");
    const elseRe = new RegExp(elseRegexTranslated, "gu");
    if (!lineNumber)
      return;
    for (const [_, map3] of Object.entries(theGlobalSourcemap)) {
      const startingLine = map3.python_range.from_line + theGlobalDebugger.get_code_starting_line();
      const finishingLine = map3.python_range.to_line + theGlobalDebugger.get_code_starting_line();
      if (lineNumber >= startingLine && lineNumber <= finishingLine) {
        if (fullLineCommands.includes(map3.command)) {
          const lines = theGlobalEditor2.contents.split("\n");
          const line = lines[map3.hedy_range.from_line - 1];
          const ifMatches = ifRe.exec(line);
          const repeatMatches = repeatRe.exec(line);
          const elseMatches = elseRe.exec(line);
          if (ifMatches || repeatMatches || elseMatches) {
            theGlobalEditor2.setDebuggerCurrentLine(map3.hedy_range.from_line, map3.hedy_range.from_column, map3.hedy_range.to_column - 1);
          } else {
            theGlobalEditor2.setDebuggerCurrentLine(map3.hedy_range.from_line);
          }
          break;
        } else if (theLevel2 <= 7 && blockCommands.includes(map3.command)) {
          const lines = theGlobalEditor2.contents.split("\n");
          let line;
          if (map3.hedy_range.from_line < map3.hedy_range.to_line) {
            line = lines[map3.hedy_range.from_line - 1];
          } else {
            const fullLine = lines[map3.hedy_range.from_line - 1];
            line = fullLine.substring(map3.hedy_range.from_column - 1, map3.hedy_range.to_column - 1);
          }
          const activeLine = theGlobalDebugger.get_source_line(lineNumber - 1);
          if (activeLine.match(/ *if/)) {
            const ifMatches = ifRe.exec(line);
            if (ifMatches) {
              const length = ifMatches[1].length;
              theGlobalEditor2.setDebuggerCurrentLine(map3.hedy_range.from_line, map3.hedy_range.from_column, map3.hedy_range.from_column + length - 1);
              break;
            }
          } else if (activeLine.match(/ *for/)) {
            const repeatMatches = repeatRe.exec(line);
            if (repeatMatches) {
              const length = repeatMatches[1].length;
              theGlobalEditor2.setDebuggerCurrentLine(map3.hedy_range.from_line, map3.hedy_range.from_column, map3.hedy_range.from_column + length - 1);
              break;
            }
          }
        } else if (theLevel2 >= 8 && blockCommands.includes(map3.command)) {
          theGlobalEditor2.setDebuggerCurrentLine(map3.hedy_range.from_line);
          break;
        }
      }
    }
  }
  function markCurrentDebuggerLine() {
    if (!step_debugger) {
      return;
    }
    const storage = window.localStorage;
    var debugLine2 = storage == null ? void 0 : storage.getItem("debugLine");
    if (debugLine2 != null) {
      var debugLineNumber = parseInt(debugLine2, 10);
      theGlobalEditor2.setDebuggerCurrentLine(debugLineNumber);
    } else {
      theGlobalEditor2.setDebuggerCurrentLine(void 0);
    }
  }
  function getBreakpoints(editor) {
    return editor.session.getBreakpoints();
  }

  // static/js/local.ts
  function localSave(key, data) {
    var _a3;
    (_a3 = window.localStorage) == null ? void 0 : _a3.setItem(key, JSON.stringify(data));
  }
  function localDelete(key) {
    var _a3;
    (_a3 = window.localStorage) == null ? void 0 : _a3.removeItem(key);
  }
  function localLoad(key) {
    var _a3;
    const value = (_a3 = window.localStorage) == null ? void 0 : _a3.getItem(key);
    try {
      return value ? JSON.parse(value) : void 0;
    } catch (e) {
      return void 0;
    }
  }
  function localLoadOnce(key) {
    const ret = localLoad(key);
    if (ret !== void 0) {
      localDelete(key);
    }
    return ret;
  }

  // static/js/teachers.ts
  var import_dompurify = __toModule(require_purify());
  var editorCreator = new HedyCodeMirrorEditorCreator();
  function create_class(class_name_prompt) {
    modal.prompt(class_name_prompt, "", function(class_name) {
      $.ajax({
        type: "POST",
        url: "/class",
        data: JSON.stringify({
          name: class_name
        }),
        contentType: "application/json",
        dataType: "json"
      }).done(function(response) {
        if (response.achievement) {
          showAchievements(response.achievement, false, "/for-teachers/customize-class/" + response.id);
        } else {
          window.location.pathname = "/for-teachers/customize-class/" + response.id;
        }
      }).fail(function(err) {
        return modal.notifyError(err.responseText);
      });
    });
  }
  function rename_class(id2, class_name_prompt) {
    modal.prompt(class_name_prompt, "", function(class_name) {
      $.ajax({
        type: "PUT",
        url: "/class/" + id2,
        data: JSON.stringify({
          name: class_name
        }),
        contentType: "application/json",
        dataType: "json"
      }).done(function(response) {
        if (response.achievement) {
          showAchievements(response.achievement, true, "");
        } else {
          location.reload();
        }
      }).fail(function(err) {
        return modal.notifyError(err.responseText);
      });
    });
  }
  function duplicate_class(id2, teacher_classes, second_teacher_prompt, prompt, defaultValue = "") {
    if (teacher_classes) {
      modal.confirm(second_teacher_prompt, function() {
        apiDuplicateClass(id2, prompt, true, defaultValue);
      }, function() {
        apiDuplicateClass(id2, prompt, false, defaultValue);
      });
    } else {
      apiDuplicateClass(id2, prompt, false, defaultValue);
    }
  }
  function apiDuplicateClass(id2, prompt, second_teacher, defaultValue = "") {
    modal.prompt(prompt, defaultValue, function(class_name) {
      $.ajax({
        type: "POST",
        url: "/duplicate_class",
        data: JSON.stringify({
          id: id2,
          name: class_name,
          second_teacher
        }),
        contentType: "application/json",
        dataType: "json"
      }).done(function(response) {
        if (response.second_teachers && second_teacher == true) {
          for (const secondTeacher of response.second_teachers) {
            $.ajax({
              type: "POST",
              url: "/invite-second-teacher",
              data: JSON.stringify({
                username: secondTeacher.username,
                class_id: response.id
              }),
              contentType: "application/json",
              dataType: "json"
            }).fail(function(err) {
              modal.notifyError(err.responseText);
            });
          }
        }
        if (response.achievement) {
          showAchievements(response.achievement, true, "");
        } else {
          location.reload();
        }
      }).fail(function(err) {
        return modal.notifyError(err.responseText);
      });
    });
  }
  function delete_class(id2, prompt) {
    modal.confirm(prompt, function() {
      $.ajax({
        type: "DELETE",
        url: "/class/" + id2,
        contentType: "application/json",
        dataType: "json"
      }).done(function(response) {
        if (response.achievement) {
          showAchievements(response.achievement, true, "");
        } else {
          location.reload();
        }
      }).fail(function(err) {
        modal.notifyError(err.responseText);
      });
    });
  }
  function join_class(id2, name2) {
    $.ajax({
      type: "POST",
      url: "/class/join",
      contentType: "application/json",
      data: JSON.stringify({
        id: id2,
        name: name2
      }),
      dataType: "json"
    }).done(function(response) {
      if (response.achievement) {
        showAchievements(response.achievement, false, "/programs");
      } else {
        window.location.pathname = "/programs";
      }
    }).fail(function(err) {
      if (err.status == 403) {
        return modal.confirm(err.responseText, function() {
          localStorage.setItem("hedy-join", JSON.stringify({ id: id2, name: name2 }));
          window.location.pathname = "/login";
        });
      } else {
        modal.notifyError(err.responseText || ClientMessages["Connection_error"]);
      }
    });
  }
  function invite_student(class_id, prompt, url = "/invite-student") {
    modal.prompt(prompt, "", function(username) {
      $.ajax({
        type: "POST",
        url,
        data: JSON.stringify({
          username,
          class_id
        }),
        contentType: "application/json",
        dataType: "json"
      }).done(function() {
        location.reload();
      }).fail(function(err) {
        modal.notifyError(err.responseText);
      });
    });
  }
  function remove_student_invite(username, class_id, prompt) {
    return modal.confirm(prompt, function() {
      $.ajax({
        type: "POST",
        url: "/remove_student_invite",
        data: JSON.stringify({
          username,
          class_id
        }),
        contentType: "application/json",
        dataType: "json"
      }).done(function() {
        location.reload();
      }).fail(function(err) {
        return modal.notifyError(err.responseText);
      });
    });
  }
  function remove_student(class_id, student_id, prompt) {
    modal.confirm(prompt, function() {
      $.ajax({
        type: "DELETE",
        url: "/class/" + class_id + "/student/" + student_id,
        contentType: "application/json",
        dataType: "json"
      }).done(function(response) {
        if (response.achievement) {
          showAchievements(response.achievement, true, "");
        } else {
          location.reload();
        }
      }).fail(function(err) {
        modal.notifyError(err.responseText);
      });
    });
  }
  function update_db_adventure(adventure_id) {
    const adventure_name = $("#custom_adventure_name").val();
    const levels = $("#custom_adventure_levels").val();
    const content2 = import_dompurify.default.sanitize($("#custom_adventure_content").val());
    const agree_public = $("#agree_public").prop("checked");
    const language2 = $("#language").val();
    $.ajax({
      type: "POST",
      url: "/for-teachers/customize-adventure",
      data: JSON.stringify({
        id: adventure_id,
        name: adventure_name,
        content: content2,
        public: agree_public,
        language: language2,
        levels
      }),
      contentType: "application/json",
      dataType: "json"
    }).done(function(response) {
      modal.notifySuccess(response.success);
    }).fail(function(err) {
      modal.notifyError(err.responseText);
    });
  }
  function update_adventure(adventure_id, first_edit, prompt) {
    if (!first_edit) {
      modal.confirm(prompt, function() {
        update_db_adventure(adventure_id);
      });
    } else {
      update_db_adventure(adventure_id);
    }
  }
  function show_preview(content2) {
    const name2 = $("#custom_adventure_name").val();
    if (typeof name2 !== "string") {
      throw new Error(`Expected name to be string, got '${name2}'`);
    }
    const levels = $("#custom_adventure_levels").val();
    if (typeof levels !== "object") {
      throw new Error(`Expected level to be a list, got '${levels}'`);
    }
    let container = $("<div>");
    container.addClass("preview border border-black px-8 py-4 text-left rounded-lg bg-gray-200 text-black");
    container.css("white-space", "pre-wrap");
    container.css("width", "40em");
    container.html(content2);
    modal.preview(container, name2);
    for (const preview of $(".preview pre").get()) {
      $(preview).addClass("text-lg rounded");
      const dir = $("body").attr("dir");
      const codeNode = preview.querySelector("code");
      let code;
      if (codeNode) {
        codeNode.hidden = true;
        code = codeNode.innerText;
      } else {
        code = preview.textContent || "";
        preview.textContent = "";
      }
      const exampleEditor = editorCreator.initializeReadOnlyEditor(preview, dir);
      exampleEditor.contents = code.trimEnd();
      for (const level3 of levels) {
        initializeTranslation({
          keywordLanguage: theKeywordLanguage,
          level: parseInt(level3, 10)
        });
        exampleEditor.setHighlighterForLevel(parseInt(level3, 10));
      }
    }
  }
  function preview_adventure() {
    let content2 = import_dompurify.default.sanitize($("#custom_adventure_content").val());
    $.ajax({
      type: "POST",
      url: "/for-teachers/preview-adventure",
      data: JSON.stringify({
        code: content2
      }),
      contentType: "application/json",
      dataType: "json"
    }).done(function(response) {
      show_preview(response.code);
    }).fail(function(err) {
      modal.notifyError(err.responseText);
    });
  }
  function delete_adventure(adventure_id, prompt) {
    modal.confirm(prompt, function() {
      $.ajax({
        type: "DELETE",
        url: "/for-teachers/customize-adventure/" + adventure_id,
        contentType: "application/json",
        dataType: "json"
      }).done(function() {
        window.location.href = "/for-teachers";
      }).fail(function(err) {
        modal.notifyError(err.responseText);
      });
    });
  }
  function change_password_student(username, enter_password, password_prompt) {
    modal.prompt(enter_password + " " + username + ":", "", function(password) {
      modal.confirm(password_prompt, function() {
        $.ajax({
          type: "POST",
          url: "/auth/change_student_password",
          data: JSON.stringify({
            username,
            password
          }),
          contentType: "application/json",
          dataType: "json"
        }).done(function(response) {
          modal.notifySuccess(response.success);
        }).fail(function(err) {
          modal.notifyError(err.responseText);
        });
      });
    });
  }
  function show_doc_section(section_key) {
    $(".section-button").each(function() {
      if ($(this).hasClass("blue-btn")) {
        $(this).removeClass("blue-btn");
        $(this).addClass("green-btn");
      }
    });
    if ($("#section-" + section_key).is(":visible")) {
      $("#button-" + section_key).removeClass("blue-btn");
      $("#button-" + section_key).addClass("green-btn");
      $(".section").hide();
    } else {
      $("#button-" + section_key).removeClass("green-btn");
      $("#button-" + section_key).addClass("blue-btn");
      $(".section").hide();
      $(".common-mistakes-section").hide();
      $("#section-" + section_key).toggle();
    }
  }
  function save_customizations(class_id) {
    let levels = [];
    $("[id^=enable_level_]").each(function() {
      if ($(this).is(":checked")) {
        levels.push($(this).attr("level"));
      }
    });
    let other_settings = [];
    $(".other_settings_checkbox").each(function() {
      if ($(this).prop("checked")) {
        other_settings.push($(this).attr("id"));
      }
    });
    let level_thresholds = {};
    $(".threshold_settings_value").each(function() {
      if ($(this).val() != "") {
        level_thresholds[$(this).attr("id")] = $(this).val();
      }
    });
    let opening_dates = {};
    $("[id^=opening_date_level_]").each(function() {
      opening_dates[$(this).attr("level")] = $(this).val();
    });
    $.ajax({
      type: "POST",
      url: "/for-teachers/customize-class/" + class_id,
      data: JSON.stringify({
        levels,
        opening_dates,
        other_settings,
        level_thresholds
      }),
      contentType: "application/json",
      dataType: "json"
    }).done(function(response) {
      if (response.achievement) {
        showAchievements(response.achievement, false, "");
      }
      modal.notifySuccess(response.success);
      clearUnsavedChanges();
      $("#remove_customizations_button").removeClass("hidden");
    }).fail(function(err) {
      modal.notifyError(err.responseText);
    });
  }
  function restore_customization_to_default(prompt) {
    modal.confirm(prompt, function() {
      let active_level_id = $("[id^=level-]")[0].id;
      let active_level = active_level_id.split("-")[1];
      htmx.ajax("POST", `/for-teachers/restore-customizations?level=${active_level}`, "#adventure-dragger").then(() => {
        $(".other_settings_checkbox").prop("checked", false);
        $(".opening_date_input").prop("type", "text").blur().val("").prop("disabled", false).attr("placeholder", ClientMessages.directly_available).each(function() {
          if ($(this).hasClass("bg-green-300")) {
            $(this).removeClass("bg-green-300").addClass("bg-gray-200");
          }
        });
        $("[id^=enable_level_]").prop("checked", true);
        setLevelStateIndicator(active_level);
        modal.notifySuccess(ClientMessages.customization_deleted);
      });
    });
  }
  function enable_level(level3) {
    markUnsavedChanges();
    if ($("#enable_level_" + level3).is(":checked")) {
      $("#opening_date_level_" + level3).prop("disabled", false).attr("type", "text").attr("placeholder", ClientMessages.directly_available).removeClass("bg-green-300").addClass("bg-gray-200");
    } else {
      $("#opening_date_level_" + level3).prop("disabled", true).attr("type", "text").attr("placeholder", ClientMessages.disabled).val("");
    }
    if ($("#level-" + level3).is(":visible")) {
      setLevelStateIndicator(level3);
    }
  }
  function setDateLevelInputColor(level3) {
    var date_string = $("#opening_date_level_" + level3).val();
    var input_date = new Date(date_string);
    var today_date = new Date();
    if (input_date > today_date) {
      $("#opening_date_level_" + level3).removeClass("bg-gray-200").addClass("bg-green-300");
    } else {
      $("#opening_date_level_" + level3).removeClass("bg-green-300").addClass("bg-gray-200");
    }
    if ($("#level-" + level3).is(":visible")) {
      setLevelStateIndicator(level3);
    }
  }
  function add_account_placeholder() {
    let row = $("#account_row_unique").clone();
    row.removeClass("hidden");
    row.attr("id", "");
    row.find(":input").each(function() {
      if ($(this).prop("id") != "classes") {
        $(this).prop("required", true);
      }
    });
    for (let x = 0; x < 5; x++) {
      row.clone().appendTo("#account_rows_container");
    }
  }
  function generate_passwords() {
    if (!$("#passwords_toggle").is(":checked")) {
      $(".passwords_input").val("");
      $(".passwords_input").prop("disabled", false);
      return;
    }
    $(".account_row").each(function() {
      if ($(this).is(":visible")) {
        $(this).find(":input").each(function() {
          if ($(this).attr("id") == "password") {
            const random_password = generateRandomString(6);
            $(this).val(random_password);
          }
        });
      }
    });
    $(".passwords_input").prop("disabled", true);
  }
  function append_classname() {
    const classname = $("#classes").val();
    $(".usernames_input").each(function() {
      $(this).val($(this).val() + "_" + classname);
    });
  }
  function create_accounts(prompt) {
    modal.confirm(prompt, function() {
      $("#account_rows_container").find(":input").each(function() {
        $(this).removeClass("border-2 border-red-500");
        $(this).removeAttr("required");
      });
      let accounts = [];
      $(".account_row").each(function() {
        if ($(this).is(":visible")) {
          let account = {};
          $(this).find(":input").each(function() {
            account[$(this).attr("name")] = $(this).val();
          });
          accounts.push(account);
        }
      });
      $.ajax({
        type: "POST",
        url: "/for-teachers/create-accounts",
        data: JSON.stringify({
          accounts
        }),
        contentType: "application/json",
        dataType: "json"
      }).done(function(response) {
        if (response.error) {
          modal.notifyError(response.error);
          $("#account_rows_container").find(":input").each(function() {
            if ($(this).val() == response.value) {
              $(this).addClass("border-2 border-red-500");
            }
          });
          return;
        } else {
          modal.notifySuccess(response.success);
          if ($("input[name='download_credentials_checkbox']:checked").val() == "yes") {
            download_login_credentials(accounts);
          }
          $("#account_rows_container").find(":input").each(function() {
            $(this).val("");
          });
        }
      }).fail(function(err) {
        modal.notifyError(err.responseText);
      });
    });
  }
  function download_login_credentials(accounts) {
    let csvContent = "data:text/csv;charset=utf-8,";
    csvContent += "Username, Password\r\n";
    accounts.forEach(function(account) {
      let row = account.username + "," + account.password;
      csvContent += row + "\r\n";
    });
    var encodedUri = encodeURI(csvContent);
    var link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "accounts.csv");
    document.body.appendChild(link);
    link.click();
  }
  function copy_join_link(link, success2) {
    var sampleTextarea = document.createElement("textarea");
    document.body.appendChild(sampleTextarea);
    sampleTextarea.value = link;
    sampleTextarea.select();
    document.execCommand("copy");
    document.body.removeChild(sampleTextarea);
    modal.notifySuccess(success2);
  }
  function generateRandomString(length) {
    var text = "";
    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (var i = 0; i < length; i++) {
      text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
  }
  function initializeTeacherPage(options) {
    if (options.welcome_teacher) {
      modal.notifySuccess(ClientMessages.teacher_welcome, 3e4);
    }
    if (options.tutorial) {
      startTeacherTutorial();
    }
  }
  function setLevelStateIndicator(level3) {
    $("[id^=state-]").addClass("hidden");
    if ($("#opening_date_level_" + level3).is(":disabled")) {
      $("#state-disabled").removeClass("hidden");
    } else if ($("#opening_date_level_" + level3).val() === "") {
      $("#state-accessible").removeClass("hidden");
    } else {
      var date_string = $("#opening_date_level_" + level3).val();
      var input_date = new Date(date_string);
      var today_date = new Date();
      if (input_date > today_date) {
        $("#opening_date").text(date_string);
        $("#state-future").removeClass("hidden");
      } else {
        $("#state-accessible").removeClass("hidden");
      }
    }
  }
  function initializeCustomizeClassPage(options) {
    $(document).ready(function() {
      $("input").on("change", function() {
        markUnsavedChanges();
      });
      $("#back_to_class").on("click", () => {
        function backToClass() {
          window.location.href = `/for-teachers/class/${options.class_id}`;
        }
        if (hasUnsavedChanges()) {
          modal.confirm(ClientMessages.unsaved_class_changes, () => {
            clearUnsavedChanges();
            backToClass();
          });
        } else {
          backToClass();
        }
      });
      $("[id^=opening_date_level_]").each(function() {
        setDateLevelInputColor($(this).attr("level"));
      });
      $("#levels-dropdown").on("change", function() {
        var level3 = $(this).val();
        setLevelStateIndicator(level3);
      });
    });
  }
  function initializeClassOverviewPage(_options) {
    $(".attribute").change(function() {
      const attribute = $(this).attr("id");
      if (!this.checked) {
        $("#" + attribute + "_header").hide();
        $("." + attribute + "_cell").hide();
      } else {
        $("#" + attribute + "_header").show();
        $("." + attribute + "_cell").show();
      }
    });
  }

  // static/js/comm.ts
  function postJson(url, data) {
    if (window.fetch !== void 0) {
      return postJsonUsingFetch(url, data);
    }
    return new Promise((ok, ko2) => {
      $.ajax(__spreadProps(__spreadValues({
        type: "POST",
        url
      }, data ? { data: JSON.stringify(data) } : {}), {
        contentType: "application/json; charset=utf-8",
        dataType: "json"
      })).done((response) => {
        ok(response);
      }).fail((err) => {
        ko2(ajaxError(err));
      });
    });
  }
  async function postJsonUsingFetch(url, data) {
    let response;
    try {
      response = await fetch(url, __spreadProps(__spreadValues({
        method: "POST",
        credentials: "include",
        keepalive: true
      }, data ? { body: JSON.stringify(data) } : {}), {
        headers: {
          "Content-Type": "application/json; charset=utf-8",
          "Accept": "application/json"
        }
      }));
    } catch (err) {
      throw Object.assign(new Error(err.message), {
        internetError: true
      });
    }
    if (response.status !== 200) {
      let errorMessage = await response.text();
      try {
        const parsed = JSON.parse(errorMessage);
        if (parsed.error) {
          errorMessage = parsed.error;
        }
      } catch (e) {
        if (errorMessage.length > 500) {
          errorMessage = `the server responded with an error (${response.status} ${response.statusText})`;
        }
      }
      throw Object.assign(new Error(errorMessage), {
        responseText: errorMessage,
        status: response.status
      });
    }
    return response.json();
  }
  function postNoResponse(url, data) {
    return new Promise((ok, ko2) => {
      $.ajax(__spreadValues({
        type: "POST",
        url,
        contentType: "application/json; charset=utf-8"
      }, data ? { data: JSON.stringify(data) } : {})).done(() => {
        ok();
      }).fail((err) => {
        ko2(ajaxError(err));
      });
    });
  }
  function ajaxError(err) {
    const error2 = new Error(err.responseText);
    return Object.assign(error2, {
      responseText: err.responseText,
      status: err.status,
      internetError: err.readyState < 4
    });
  }

  // static/js/auth.ts
  var REDIRECT_AFTER_LOGIN_KEY = "login-redirect";
  function initializeLoginLinks() {
    $('a[href="/login"]').on("click", () => {
      comeBackHereAfterLogin();
    });
  }
  function comeBackHereAfterLogin() {
    localSave(REDIRECT_AFTER_LOGIN_KEY, {
      url: window.location.toString()
    });
  }
  function convertFormJSON(form) {
    let result = {};
    $.each($(form).serializeArray(), function() {
      if (result[this.name]) {
        if ($.isArray(result[this.name])) {
          result[this.name] = $.merge(result[this.name], Array(this.value));
        } else {
          result[this.name] = $.merge(Array(result[this.name]), Array(this.value));
        }
      } else {
        if (this.value) {
          result[this.name] = this.value;
        }
      }
    });
    return result;
  }
  function redirect(where) {
    where = "/" + where;
    window.location.pathname = where;
  }
  async function logout() {
    await postNoResponse("/auth/logout");
    window.location.reload();
  }
  function destroy2(confirmation) {
    modal.confirm(confirmation, async () => {
      await postNoResponse("/auth/destroy");
      redirect("");
    });
  }
  function destroy_public(confirmation) {
    modal.confirm(confirmation, async () => {
      await postNoResponse("/auth/destroy_public");
      location.reload();
    });
  }
  async function request_teacher_account() {
    tryCatchPopup(async () => {
      const response = await postJson("/auth/request_teacher");
      modal.notifySuccess(response.message);
      setTimeout(function() {
        location.reload();
      }, 2e3);
    });
  }
  function initializeFormSubmits() {
    $("form#signup").on("submit", async function(e) {
      e.preventDefault();
      tryCatchPopup(async () => {
        await postNoResponse("/auth/signup", convertFormJSON($(this)));
        afterLogin({ "first_time": true });
      });
    });
    $("form#login").on("submit", function(e) {
      e.preventDefault();
      tryCatchPopup(async () => {
        const response = await postJson("/auth/login", convertFormJSON($(this)));
        if (response["first_time"]) {
          return afterLogin({ "first_time": true });
        }
        return afterLogin({ "admin": response["admin"] || false, "teacher": response["teacher"] });
      });
    });
    $("form#profile").on("submit", function(e) {
      e.preventDefault();
      tryCatchPopup(async () => {
        const response = await postJson("/profile", convertFormJSON($(this)));
        if (response.reload) {
          modal.notifySuccess(response.message, 2e3);
          setTimeout(function() {
            location.reload();
          }, 2e3);
        } else {
          modal.notifySuccess(response.message);
        }
      });
    });
    $("form#change_password").on("submit", function(e) {
      e.preventDefault();
      tryCatchPopup(async () => {
        const response = await postJson("/auth/change_password", convertFormJSON($(this)));
        modal.notifySuccess(response.message);
      });
    });
    $("form#recover").on("submit", function(e) {
      e.preventDefault();
      tryCatchPopup(async () => {
        const response = await postJson("/auth/recover", convertFormJSON($(this)));
        modal.notifySuccess(response.message);
        $("form#recover").trigger("reset");
      });
    });
    $("form#reset").on("submit", function(e) {
      e.preventDefault();
      tryCatchPopup(async () => {
        const response = await postJson("/auth/reset", convertFormJSON($(this)));
        modal.notifySuccess(response.message, 2e3);
        $("form#reset").trigger("reset");
        setTimeout(function() {
          redirect("login");
        }, 2e3);
      });
    });
    $("form#public_profile").on("submit", function(e) {
      e.preventDefault();
      tryCatchPopup(async () => {
        const response = await postJson("/auth/public_profile", convertFormJSON($(this)));
        modal.notifySuccess(response.message, 2e3);
        if (response.achievement) {
          showAchievements(response.achievement, true, "");
        } else {
          setTimeout(function() {
            location.reload();
          }, 2e3);
        }
      });
    });
    $("#language").on("change", function() {
      const lang = $(this).val();
      $("#keyword_language").val("en");
      if (lang == "en" || !$("#" + lang + "_option").length) {
        $("#keyword_lang_container").hide();
      } else {
        $(".keyword_lang_option").hide();
        $("#en_option").show();
        $("#" + lang + "_option").show();
        $("#keyword_lang_container").show();
      }
    });
  }
  function markAsTeacher(checkbox, username, is_teacher, pending_request) {
    $(checkbox).prop("checked", false);
    let text = "Are you sure you want to remove " + username + " as a teacher?";
    if (is_teacher) {
      text = "Are you sure you want to make " + username + " a teacher?";
    }
    modal.confirm(text, async () => {
      try {
        await postNoResponse("/admin/markAsTeacher", {
          username,
          is_teacher
        });
        location.reload();
      } catch (e) {
        console.error(e);
        modal.notifyError(["Error when", is_teacher ? "marking" : "unmarking", "user", username, "as teacher"].join(" "));
      }
    }, async () => {
      if (pending_request) {
        await postJson("/admin/markAsTeacher", {
          username,
          is_teacher: false
        });
        location.reload();
      }
    });
  }
  function changeUserEmail(username, email) {
    modal.prompt("Please enter the corrected email", email, async function(correctedEmail) {
      if (correctedEmail === email)
        return;
      try {
        await postJson("/admin/changeUserEmail", {
          username,
          email: correctedEmail
        });
        location.reload();
      } catch (e) {
        modal.notifyError(["Error when changing the email for user", username].join(" "));
      }
    });
  }
  function edit_user_tags(username) {
    tryCatchPopup(async () => {
      const response = await postJson("/admin/getUserTags", {
        username
      });
      console.log(response);
      $("#modal-mask").show();
      $("#tags_username").text(username);
      $(".tags-input").prop("checked", false);
      if (response.tags) {
        console.log(response.tags);
        if (jQuery.inArray("certified_teacher", response.tags) !== -1) {
          $("#certified-tag-input").prop("checked", true);
        }
        if (jQuery.inArray("distinguished_user", response.tags) !== -1) {
          $("#distinguished-tag-input").prop("checked", true);
        }
        if (jQuery.inArray("contributor", response.tags) !== -1) {
          $("#contributor-tag-input").prop("checked", true);
        }
      }
      $("#modal-tags").show();
    });
  }
  function update_user_tags() {
    tryCatchPopup(async () => {
      const username = $("#tags_username").text();
      const certified = $("#certified-tag-input").prop("checked");
      const distinguished = $("#distinguished-tag-input").prop("checked");
      const contributor = $("#contributor-tag-input").prop("checked");
      await postJson("/admin/updateUserTags", {
        username,
        certified,
        distinguished,
        contributor
      });
      $("#modal-mask").hide();
      $("#modal-tags").hide();
      modal.notifySuccess("Tags successfully updated");
    });
  }
  async function afterLogin(loginData) {
    var _a3;
    const { url } = (_a3 = localLoadOnce(REDIRECT_AFTER_LOGIN_KEY)) != null ? _a3 : {};
    if (url) {
      window.location = url;
      return;
    }
    const joinClassString = localStorage.getItem("hedy-join");
    const joinClass = joinClassString ? JSON.parse(joinClassString) : void 0;
    if (joinClass) {
      localStorage.removeItem("hedy-join");
      return join_class(joinClass.id, joinClass.name);
    }
    if (loginData["first_time"]) {
      return redirect("landing-page/1");
    }
    if (loginData["admin"]) {
      return redirect("admin");
    }
    if (loginData["teacher"]) {
      return redirect("for-teachers");
    }
    redirect("landing-page");
  }

  // static/js/local-save-warning.ts
  var SHOW_AFTER_RUN_CLICKS = 10;
  var MIN_LINES_TO_WARN = 20;
  var SHOW_AFTER_MINUTES = 10;
  var LocalSaveWarning = class {
    constructor() {
      this.runCounter = 0;
      this.loggedIn = false;
      this.programLength = 0;
      this.reset();
    }
    setLoggedIn() {
      this.loggedIn = true;
    }
    clickRun() {
      this.runCounter += 1;
      if (this.runCounter >= SHOW_AFTER_RUN_CLICKS) {
        this.display(true);
      }
    }
    setProgramLength(lines) {
      this.programLength = lines;
    }
    switchTab() {
      this.reset();
      const startTime = Date.now();
      if (this.timer) {
        clearInterval(this.timer);
      }
      this.timer = setInterval(() => {
        if (this.programLength >= MIN_LINES_TO_WARN) {
          this.display(true);
        }
        if (Date.now() - startTime >= SHOW_AFTER_MINUTES * 6e4) {
          this.display(true);
        }
      }, 6e4);
    }
    reset() {
      this.runCounter = 0;
      this.programLength = 0;
      this.display(false);
    }
    display(show) {
      if (this.loggedIn) {
        return;
      }
      $("#not-logged-in-warning").toggle(show);
    }
  };

  // static/js/app.ts
  var theGlobalDebugger;
  var theGlobalEditor;
  var theModalEditor;
  var theGlobalSourcemap;
  var theLocalSaveWarning = new LocalSaveWarning();
  var editorCreator2 = new HedyCodeMirrorEditorCreator();
  var last_code;
  var pygameRunning = false;
  var askPromptOpen = false;
  var theAdventures = {};
  var theLevel = 0;
  var theLanguage2 = "";
  var theKeywordLanguage = "en";
  var theStaticRoot = "";
  var currentTab;
  var theUserIsLoggedIn;
  var synth = new PolySynth(Synth).toDestination();
  var pygame_suffix = `# coding=utf8
pygame_end = True
pygame.quit()
`;
  var slides_template = `
<!DOCTYPE html>
<html class="sl-root decks export offline loaded">

<head>
	<meta name="viewport"
		content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<title>Slides Level - 1</title>
	<link rel="stylesheet" type="text/css" href="lib/offline-v2.css">
</head>

<body class="reveal-viewport theme-font-montserrat theme-color-white-blue">
	<div class="reveal">
		<div class="slides">
			{replace}
		</div>
	</div>

	<!-- Initialize the presentation -->
	<script>
		Reveal.initialize({
			width: 960,
			height: 700,
			margin: 0.05,


			hash: true,
			controls: true,
			progress: true,
			mouseWheel: false,
			showNotes: false,
			slideNumber: false,
			fragmentInURL: true,

			autoSlide: 0,
			autoSlideStoppable: true,

			autoAnimateMatcher: SL.deck.AutoAnimate.matcher,

			center: false,
			shuffle: false,
			loop: false,
			rtl: false,
			navigationMode: "default",

			transition: "slide",
			backgroundTransition: "slide",

			highlight: {
				escapeHTML: false
			},

			plugins: [RevealZoom, RevealNotes, RevealMarkdown, RevealHighlight]
		});
	<\/script>
</body>
</html>
`;
  function initializeApp(options) {
    var _a3;
    theLevel = options.level;
    theKeywordLanguage = options.keywordLanguage;
    theStaticRoot = (_a3 = options.staticRoot) != null ? _a3 : "";
    theStaticRoot = theStaticRoot === "/" ? "" : theStaticRoot;
    initializeSyntaxHighlighter({
      keywordLanguage: options.keywordLanguage
    });
    initializeCopyToClipboard();
    $(document).on("click", function(event2) {
      if (!$(event2.target).closest(".dropdown").length) {
        $(".dropdown-menu").slideUp("medium");
        $(".cheatsheet-menu").slideUp("medium");
        return;
      }
      const allDropdowns = $(".dropdown-menu");
      for (const dd2 of allDropdowns) {
        const c2 = $(dd2).closest(".dropdown")[0];
        if (!$(event2.target).closest(c2).length) {
          $(dd2).slideUp("fast");
        }
      }
    });
    $("#search_language").on("keyup", function() {
      let search_query = $("#search_language").val().toLowerCase();
      $(".language").each(function() {
        if ($(this).html().toLowerCase().includes(search_query)) {
          $(this).show();
        } else {
          $(this).hide();
        }
      });
    });
    $('*[data-autosubmit="true"]').on("change", (ev) => {
      $(ev.target).closest("form").trigger("submit");
    });
    initializeLoginLinks();
  }
  function initializeCodePage(options) {
    var _a3;
    theUserIsLoggedIn = !!options.current_user_name;
    if (theUserIsLoggedIn) {
      theLocalSaveWarning.setLoggedIn();
    }
    theAdventures = Object.fromEntries(((_a3 = options.adventures) != null ? _a3 : []).map((a) => [a.short_name, a]));
    if (theLevel != options.level) {
      throw new Error(`initializeApp set level to ${JSON.stringify(theLevel)} but initializeCodePage sets it to ${JSON.stringify(options.level)}`);
    }
    theLanguage2 = options.lang;
    const $editor = $("#editor");
    if ($editor.length) {
      const dir = $("body").attr("dir");
      theGlobalEditor = editorCreator2.initializeEditorWithGutter($editor, EditorType.MAIN, dir);
      initializeTranslation({ keywordLanguage: theKeywordLanguage, level: theLevel });
      attachMainEditorEvents(theGlobalEditor);
      initializeDebugger({
        editor: theGlobalEditor,
        level: theLevel,
        language: theLanguage2,
        keywordLanguage: theKeywordLanguage
      });
    }
    const anchor = window.location.hash.substring(1);
    const validAnchor = [...Object.keys(theAdventures), "parsons", "quiz"].includes(anchor) ? anchor : void 0;
    const tabs = new Tabs({
      initialTab: validAnchor != null ? validAnchor : options.initial_tab
    });
    tabs.on("beforeSwitch", () => {
      saveIfNecessary();
    });
    tabs.on("afterSwitch", (ev) => {
      currentTab = ev.newTab;
      const adventure = theAdventures[currentTab];
      if (!options.suppress_save_and_load_for_slides) {
        const programFromLs = localLoad(currentTabLsKey());
        if (programFromLs && adventure) {
          adventure.editor_contents = programFromLs.code;
          adventure.save_name = programFromLs.saveName;
          adventure.save_info = "local-storage";
        }
      }
      reconfigurePageBasedOnTab();
      checkNow();
      theLocalSaveWarning.switchTab();
    });
    initializeSpeech();
    if (options.start_tutorial) {
      startIntroTutorial();
    }
    $("#share_program_button").on("click", () => $("#share-modal").show());
    $("#hand_in_button").on("click", () => $("#hand-in-modal").show());
    initializeShareProgramButtons();
    initializeHandInButton();
    if (options.suppress_save_and_load_for_slides) {
      disableAutomaticSaving();
    }
    window.addEventListener("beforeunload", () => saveIfNecessary(), { capture: true });
    $("#program_name").on("blur", () => saveIfNecessary());
  }
  function attachMainEditorEvents(editor) {
    editor.on("change", () => {
      theLocalSaveWarning.setProgramLength(theGlobalEditor.contents.split("\n").length);
    });
    editor.on("change", function() {
      if (askPromptOpen) {
        stopit();
        theGlobalEditor.focus();
      }
      if ($("#ask-modal").is(":visible"))
        $("#inline-modal").hide();
      askPromptOpen = false;
      $("#runit").css("background-color", "");
      theGlobalEditor.clearErrors();
      theGlobalEditor.clearIncorrectLines();
      stopDebug();
    });
    editor.on("click", (event2) => {
      editor.skipFaultyHandler(event2);
    });
    let altPressed;
    window.addEventListener("keydown", function(ev) {
      const keyCode = ev.keyCode;
      if (keyCode === 18) {
        altPressed = true;
        return;
      }
      if (keyCode === 13 && altPressed) {
        if (!theLevel || !theLanguage2) {
          throw new Error("Oh no");
        }
        runit(theLevel, theLanguage2, "", "run", function() {
          $("#output").focus();
        });
      }
      if (keyCode === 37 && document.activeElement === document.getElementById("output")) {
        theGlobalEditor.focus();
        theGlobalEditor.moveCursorToEndOfFile();
      }
    });
    window.addEventListener("keyup", function(ev) {
      triggerAutomaticSave();
      const keyCode = ev.keyCode;
      if (keyCode === 18) {
        altPressed = false;
        return;
      }
    });
  }
  function initializeViewProgramPage(options) {
    theLevel = options.level;
    theLanguage2 = options.lang;
    const dir = $("body").attr("dir");
    theGlobalEditor = editorCreator2.initializeEditorWithGutter($("#editor"), EditorType.MAIN, dir);
    initializeTranslation({
      keywordLanguage: options.lang,
      level: options.level
    });
    attachMainEditorEvents(theGlobalEditor);
    theGlobalEditor.contents = options.code;
    initializeDebugger({
      editor: theGlobalEditor,
      level: theLevel,
      language: theLanguage2,
      keywordLanguage: theKeywordLanguage
    });
  }
  function initializeHighlightedCodeBlocks(where) {
    const dir = $("body").attr("dir");
    initializeParsons();
    if (theLevel) {
      initializeTranslation({
        keywordLanguage: theKeywordLanguage,
        level: theLevel
      });
    }
    for (const container of $(where).find(".turn-pre-into-ace").get()) {
      for (const preview of $(container).find("pre").get()) {
        $(preview).addClass("relative text-lg rounded overflow-x-hidden").attr("lang", theKeywordLanguage);
        onElementBecomesVisible(preview, () => {
          const codeNode = preview.querySelector("code");
          let code;
          if (codeNode) {
            codeNode.hidden = true;
            code = codeNode.innerText;
          } else {
            code = preview.textContent || "";
            preview.textContent = "";
          }
          const exampleEditor = editorCreator2.initializeReadOnlyEditor(preview, dir);
          exampleEditor.contents = code;
          exampleEditor.contents = exampleEditor.contents.trimEnd();
          if ($(preview).hasClass("show-copy-button") || $(container).hasClass("show-copy-button")) {
            const buttonContainer = $("<div>").addClass("absolute ltr:right-0 rtl:left-0 top-0 mx-1 mt-1").appendTo(preview);
            let symbol = "\u21E5";
            if (dir === "rtl") {
              symbol = "\u21E4";
            }
            $("<button>").css({ fontFamily: "sans-serif" }).addClass("yellow-btn").text(symbol).appendTo(buttonContainer).click(function() {
              if (!(theGlobalEditor == null ? void 0 : theGlobalEditor.isReadOnly)) {
                theGlobalEditor.contents = exampleEditor.contents + "\n";
              }
              update_view("main_editor_keyword_selector", $(preview).attr("lang"));
              stopit();
              clearOutput();
            });
          }
          const levelStr = $(preview).attr("level");
          const lang = $(preview).attr("lang");
          if (levelStr && lang) {
            initializeTranslation({
              keywordLanguage: lang,
              level: parseInt(levelStr, 10)
            });
            exampleEditor.setHighlighterForLevel(parseInt(levelStr, 10));
          }
        });
      }
    }
  }
  function getHighlighter(level3) {
    return `ace/mode/level${level3}`;
  }
  function stopit() {
    if (pygameRunning) {
      Sk.insertPyGameEvent("quit");
      Sk.unbindPygameListeners();
      pygameRunning = false;
      document.onkeydown = null;
      $("#pygame-modal").hide();
      $("#stopit").hide();
      $("#runit").show();
    } else {
      Sk.execLimit = 1;
      clearTimeouts();
      $("#stopit").hide();
      $("#runit").show();
      if ($("#ask-modal").is(":visible")) {
        $("#ask-modal form").submit();
        $("#ask-modal").hide();
      }
    }
    askPromptOpen = false;
  }
  function clearOutput() {
    const outputDiv = $("#output");
    const variableButton = outputDiv.find("#variable_button");
    const variables = outputDiv.find("#variables");
    outputDiv.empty();
    outputDiv.addClass("overflow-auto");
    outputDiv.append(variableButton);
    outputDiv.append(variables);
    error.hide();
    success.hide();
    const buttonsDiv = $("#dynamic-buttons");
    buttonsDiv.empty();
    buttonsDiv.hide();
  }
  async function runit(level3, lang, disabled_prompt, run_type, cb2) {
    const adventureName = currentTab;
    if (askPromptOpen) {
      if (disabled_prompt) {
        return modal.notifyError(disabled_prompt);
      }
      return;
    }
    theLocalSaveWarning.clickRun();
    if (typeof Sk.unbindPygameListeners === "function") {
      Sk.unbindPygameListeners();
    }
    Sk.execLimit = 1;
    $("#runit").hide();
    $("#stopit").show();
    $("#saveFilesContainer").hide();
    if (run_type !== "continue") {
      clearOutput();
    }
    try {
      var editor = theGlobalEditor;
      var code = "";
      if ($("#parsons_container").is(":visible")) {
        code = get_parsons_code();
        if (!code) {
          editor.clearErrors();
          stopit();
          return;
        } else {
          if ($("#next_parson_button").attr("onclick")) {
            $("#next_parson_button").show();
          }
        }
      } else {
        code = get_active_and_trimmed_code();
        if (code.length == 0) {
          editor.clearErrors();
          stopit();
          return;
        }
      }
      editor.clearErrors();
      removeBulb();
      const adventure = theAdventures[adventureName];
      let program_data;
      if (run_type === "run" || run_type === "debug") {
        try {
          cancelPendingAutomaticSave();
          let data = {
            level: `${level3}`,
            code,
            lang,
            skip_faulty: false,
            is_debug: run_type === "debug",
            tutorial: $("#code_output").hasClass("z-40"),
            read_aloud: !!$("#speak_dropdown").val(),
            adventure_name: adventureName,
            program_id: isServerSaveInfo(adventure == null ? void 0 : adventure.save_info) ? adventure.save_info.id : void 0,
            save_name: saveNameFromInput()
          };
          let response = await postJsonWithAchievements("/parse", data);
          program_data = response;
          console.log("Response", response);
          if (response.Warning && $("#editor").is(":visible")) {
            error.showWarning(ClientMessages["Transpile_warning"], response.Warning);
          }
          showAchievements(response.achievements, false, "");
          if (adventure && response.save_info) {
            adventure.save_info = response.save_info;
            adventure.editor_contents = code;
          }
          if (response.Error) {
            error.show(ClientMessages["Transpile_error"], response.Error);
            if (response.Location && response.Location[0] != "?") {
              theGlobalEditor.highlightError(response.Location[0], response.Location[1]);
            }
            $("#stopit").hide();
            $("#runit").show();
            return;
          }
        } catch (e) {
          console.error(e);
          if (e.internetError) {
            error.show(ClientMessages["Connection_error"], ClientMessages["CheckInternet"]);
          } else {
            error.show(ClientMessages["Other_error"], ClientMessages["ServerError"]);
          }
        }
      } else {
        program_data = theGlobalDebugger.get_program_data();
      }
      runPythonProgram(program_data.Code, program_data.source_map, program_data.has_turtle, program_data.has_pygame, program_data.has_sleep, program_data.has_clear, program_data.has_music, program_data.Warning, cb2, run_type).catch(function(err) {
        if (err != null) {
          error.show(ClientMessages["Execute_error"], err.message);
          reportClientError(level3, code, err.message);
        }
      });
    } catch (e) {
      modal.notifyError(e.responseText);
    }
  }
  async function saveMachineFiles() {
    const response = await postJsonWithAchievements("/generate_machine_files", {
      level: theLevel,
      code: get_active_and_trimmed_code(),
      lang: theLanguage2
    });
    if (response.filename) {
      window.location.replace("/download_machine_files/" + response.filename);
    }
  }
  var ACHIEVEMENTS_PUSHED = {};
  async function pushAchievement(achievement) {
    if (ACHIEVEMENTS_PUSHED[achievement]) {
      return;
    }
    ACHIEVEMENTS_PUSHED[achievement] = true;
    try {
      const response = await postJson("/achievements/push-achievement", { achievement });
      showAchievements(response.achievements, false, "");
    } catch (e) {
    }
  }
  function closeAchievement() {
    $("#achievement_pop-up").hide();
    if ($("#achievement_pop-up").attr("reload")) {
      $("#achievement_pop-up").removeAttr("reload");
      $("#achievement_pop-up").removeAttr("redirect");
      return location.reload();
    }
    if ($("#achievement_pop-up").attr("redirect")) {
      const redirect2 = $("#achievement_pop-up").attr("redirect");
      $("#achievement_pop-up").removeAttr("reload");
      $("#achievement_pop-up").removeAttr("redirect");
      return window.location.pathname = redirect2;
    }
    $("#achievement_pop-up").removeAttr("reload");
    $("#achievement_pop-up").removeAttr("redirect");
  }
  async function showAchievements(achievements, reload, redirect2) {
    if (!achievements || achievements.length === 0) {
      return;
    }
    for (const achievement of achievements) {
      await showAchievement(achievement);
    }
    if (reload) {
      $("#achievement_pop-up").attr("reload", "true");
      setTimeout(function() {
        $("#achievement_pop-up").removeAttr("reload");
        $("#achievement_pop-up").removeAttr("redirect");
        location.reload();
      }, achievements.length * 6e3);
    }
    if (redirect2) {
      $("#achievement_pop-up").attr("redirect", redirect2);
      setTimeout(function() {
        $("#achievement_pop-up").removeAttr("reload");
        $("#achievement_pop-up").removeAttr("redirect");
        window.location.pathname = redirect2;
      }, achievements.length * 6e3);
    }
  }
  function showAchievement(achievement) {
    return new Promise((resolve2) => {
      $("#achievement_reached_title").text('"' + achievement[0] + '"');
      $("#achievement_reached_text").text(achievement[1]);
      $("#achievement_reached_statics").text(achievement[2]);
      $("#achievement_pop-up").fadeIn(1e3, function() {
        setTimeout(function() {
          $("#achievement_pop-up").fadeOut(1e3);
        }, 4e3);
      });
      setTimeout(() => {
        resolve2();
        ;
      }, 6e3);
    });
  }
  function removeBulb() {
    const repair_button = $("#repair_button");
    repair_button.hide();
  }
  function tryPaletteCode(exampleCode) {
    if (theGlobalEditor == null ? void 0 : theGlobalEditor.isReadOnly) {
      return;
    }
    theGlobalEditor.contents = exampleCode + "\n";
    if (!($("#editor").attr("lang") == "en")) {
      $("#editor").attr("lang", "en");
      update_view("main_editor_keyword_selector", "en");
    }
  }
  function viewProgramLink(programId) {
    return window.location.origin + "/hedy/" + programId + "/view";
  }
  async function delete_program(id2, index3, prompt) {
    await modal.confirmP(prompt);
    await tryCatchPopup(async () => {
      const response = await postJsonWithAchievements("/programs/delete", { id: id2 });
      showAchievements(response.achievement, true, "");
      $("#program_" + index3).remove();
      modal.notifySuccess(response.message);
    });
  }
  function set_favourite(index3) {
    $(".favourite_program_container").removeClass("text-yellow-400");
    $(".favourite_program_container").addClass("text-white");
    $("#favourite_program_container_" + index3).removeClass("text-white");
    $("#favourite_program_container_" + index3).addClass("text-yellow-400");
  }
  async function set_favourite_program(id2, index3, prompt) {
    await modal.confirmP(prompt);
    await tryCatchPopup(async () => {
      const response = await postJsonWithAchievements("/programs/set_favourite", { id: id2 });
      set_favourite(index3);
      modal.notifySuccess(response.message);
    });
  }
  function change_to_submitted(index3) {
    $("#non_submitted_button_container_" + index3).remove();
    $("#submitted_button_container_" + index3).show();
    $("#submitted_header_" + index3).show();
    $("#program_" + index3).removeClass("border-orange-400");
    $("#program_" + index3).addClass("border-gray-400 bg-gray-400");
  }
  function submit_program(id2, index3) {
    tryCatchPopup(async () => {
      await postJsonWithAchievements("/programs/submit", { id: id2 });
      change_to_submitted(index3);
    });
  }
  async function set_explore_favourite(id2, favourite) {
    let prompt = `Are you sure you want to remove this program as a "Hedy's choice" program?`;
    if (favourite) {
      prompt = `Are you sure you want to set this program as a "Hedy's choice" program?`;
    }
    await modal.confirmP(prompt);
    await tryCatchPopup(async () => {
      const response = await postJsonWithAchievements("/programs/set_hedy_choice", {
        id: id2,
        favourite
      });
      modal.notifySuccess(response.message);
      $("#" + id2).toggleClass("text-white", favourite !== 1);
      $("#" + id2).toggleClass("text-yellow-500", favourite === 1);
    });
  }
  function report_program(prompt, id2) {
    tryCatchPopup(async () => {
      await modal.confirmP(prompt);
      const response = await postJsonWithAchievements("/programs/report", { id: id2 });
      modal.notifySuccess(response.message);
    });
  }
  function copy_to_clipboard(string2, prompt) {
    var _a3, _b;
    var el3 = document.createElement("textarea");
    el3.value = string2;
    el3.setAttribute("readonly", "");
    el3.style.position = "absolute";
    el3.style.left = "-9999px";
    document.body.appendChild(el3);
    const selection2 = document.getSelection();
    const originalSelection = selection2 && selection2.rangeCount > 0 ? selection2.getRangeAt(0) : void 0;
    el3.select();
    document.execCommand("copy");
    document.body.removeChild(el3);
    if (originalSelection) {
      (_a3 = document.getSelection()) == null ? void 0 : _a3.removeAllRanges();
      (_b = document.getSelection()) == null ? void 0 : _b.addRange(originalSelection);
    }
    modal.hide();
    modal.notifySuccess(prompt, 3e3);
  }
  function reportClientError(level3, code, client_error) {
    postJsonWithAchievements("/report_error", {
      level: `${level3}`,
      code,
      page: window.location.href,
      client_error
    });
  }
  window.onerror = function reportClientException(message, source, line_number, column_number, error2) {
    postJsonWithAchievements("/client_exception", {
      message,
      source,
      line_number,
      column_number,
      error: error2,
      url: window.location.href,
      user_agent: navigator.userAgent
    });
  };
  function runPythonProgram(code, sourceMap, hasTurtle, hasPygame, hasSleep, hasClear, hasMusic, hasWarnings, cb2, run_type) {
    let outputDiv = $("#output");
    let skip_faulty_found_errors = false;
    let warning_box_shown = false;
    if (sourceMap) {
      theGlobalSourcemap = sourceMap;
      for (const index3 in sourceMap) {
        const map3 = sourceMap[index3];
        const range10 = {
          startLine: map3.hedy_range.from_line,
          startColumn: map3.hedy_range.from_column,
          endLine: map3.hedy_range.to_line,
          endColumn: map3.hedy_range.to_column
        };
        if (map3.error != null) {
          skip_faulty_found_errors = true;
          theGlobalEditor.setIncorrectLine(range10, Number(index3));
        }
        if (skip_faulty_found_errors && !warning_box_shown) {
          error.showFadingWarning(ClientMessages["Execute_error"], ClientMessages["Errors_found"]);
          warning_box_shown = true;
        }
      }
    }
    let skulptExternalLibraries = {
      "./extensions.js": {
        path: theStaticRoot + "/vendor/skulpt-stdlib-extensions.js"
      }
    };
    Sk.pre = "output";
    const turtleConfig = Sk.TurtleGraphics || (Sk.TurtleGraphics = {});
    turtleConfig.target = "turtlecanvas";
    if ($("#adventures-tab").is(":hidden")) {
      turtleConfig.height = 600;
      turtleConfig.worldHeight = 600;
    } else if ($("#turtlecanvas").attr("raw") == "yes") {
      turtleConfig.height = 150;
      turtleConfig.worldHeight = 250;
    } else {
      turtleConfig.height = 300;
      turtleConfig.worldHeight = 300;
    }
    turtleConfig.width = outputDiv.width();
    turtleConfig.worldWidth = outputDiv.width();
    let code_prefix = normal_prefix;
    if (!hasTurtle && !hasPygame) {
      $("#turtlecanvas").empty();
    }
    if (hasTurtle) {
      code_prefix += turtle_prefix;
      $("#turtlecanvas").show();
    }
    if (hasMusic) {
      code_prefix += music_prefix;
      $("#turtlecanvas").show();
    }
    if (hasPygame) {
      skulptExternalLibraries = {
        "./extensions.js": {
          path: theStaticRoot + "/vendor/skulpt-stdlib-extensions.js"
        },
        "./pygame.js": {
          path: theStaticRoot + "/vendor/pygame_4_skulpt/init.js"
        },
        "./display.js": {
          path: theStaticRoot + "/vendor/pygame_4_skulpt/display.js"
        },
        "./draw.js": {
          path: theStaticRoot + "/vendor/pygame_4_skulpt/draw.js"
        },
        "./event.js": {
          path: theStaticRoot + "/vendor/pygame_4_skulpt/event.js"
        },
        "./font.js": {
          path: theStaticRoot + "/vendor/pygame_4_skulpt/font.js"
        },
        "./image.js": {
          path: theStaticRoot + "/vendor/pygame_4_skulpt/image.js"
        },
        "./key.js": {
          path: theStaticRoot + "/vendor/pygame_4_skulpt/key.js"
        },
        "./mouse.js": {
          path: theStaticRoot + "/vendor/pygame_4_skulpt/mouse.js"
        },
        "./transform.js": {
          path: theStaticRoot + "/vendor/pygame_4_skulpt/transform.js"
        },
        "./locals.js": {
          path: theStaticRoot + "/vendor/pygame_4_skulpt/locals.js"
        },
        "./time.js": {
          path: theStaticRoot + "/vendor/pygame_4_skulpt/time.js"
        },
        "./version.js": {
          path: theStaticRoot + "/vendor/pygame_4_skulpt/version.js"
        },
        "./buttons.js": {
          path: theStaticRoot + "/js/buttons.js"
        }
      };
      code_prefix += pygame_prefix;
      initSkulpt4Pygame();
      initCanvas4PyGame();
      let pygameModal = $("#pygame-modal");
      const codeContainsInputFunctionBeforePygame = new RegExp("input\\([\\s\\S]*\\)[\\s\\S]*while not pygame_end", "gm").test(code);
      if (!codeContainsInputFunctionBeforePygame) {
        pygameModal.show();
      }
      if (hasTurtle) {
        pygameModal.addClass("absolute");
        pygameModal.addClass("bottom-0");
        pygameModal.addClass("w-full");
      } else {
        pygameModal.removeClass("absolute");
        pygameModal.removeClass("bottom-0");
        pygameModal.removeClass("w-full");
      }
      document.onkeydown = animateKeys;
      pygameRunning = true;
    }
    code = code_prefix + code;
    if (hasPygame)
      code += pygame_suffix;
    if (run_type === "run") {
      Sk.configure({
        output: outf,
        read: builtinRead,
        inputfun: inputFromInlineModal,
        inputfunTakesPrompt: true,
        setTimeout: timeout,
        __future__: Sk.python3,
        timeoutMsg: function() {
          $("#stopit").hide();
          $("#runit").show();
          $("#runit").show();
          if (Sk.execLimit != 1) {
            pushAchievement("hedy_hacking");
            return ClientMessages["Program_too_long"];
          } else {
            return null;
          }
        },
        execLimit: function() {
          const level3 = theLevel;
          if (hasTurtle || hasPygame || hasMusic) {
            return 6e6;
          }
          if (level3 < 7) {
            return 3e6;
          }
          return hasSleep ? 2e4 : 5e3;
        }()
      });
      Sk.builtins.play = new Sk.builtin.func((notes) => {
        const note_name = notes.v;
        synth.triggerAttackRelease(note_name, "16n");
      });
      return Sk.misceval.asyncToPromise(() => Sk.importMainWithBody("<stdin>", false, code, true), {
        "*": () => {
        }
      }).then(function(_mod) {
        console.log("Program executed");
        const pythonVariables = Sk.globals;
        load_variables(pythonVariables);
        $("#stopit").hide();
        $("#runit").show();
        if (hasPygame) {
          document.onkeydown = null;
          $("#pygame-modal").hide();
        }
        if (hasTurtle) {
          $("#saveFilesContainer").show();
        }
        if (!hasClear && $("#output").is(":empty") && $("#turtlecanvas").is(":empty")) {
          pushAchievement("error_or_empty");
          error.showWarning(ClientMessages["Transpile_warning"], ClientMessages["Empty_output"]);
          return;
        }
        if (!hasWarnings && code !== last_code) {
          showSuccesMessage();
          last_code = code;
        }
        if (cb2)
          cb2();
      }).catch(function(err) {
        const errorMessage = errorMessageFromSkulptError(err) || null;
        if (!errorMessage) {
          throw null;
        }
        throw new Error(errorMessage);
      });
    } else if (run_type === "debug") {
      theGlobalDebugger = new Sk.Debugger("<stdin>", incrementDebugLine, stopDebug);
      theGlobalSourcemap = sourceMap;
      Sk.configure({
        output: outf,
        read: builtinRead,
        inputfun: inputFromInlineModal,
        inputfunTakesPrompt: true,
        __future__: Sk.python3,
        debugging: true,
        breakpoints: theGlobalDebugger.check_breakpoints.bind(theGlobalDebugger),
        execLimit: null
      });
      let lines = code.split("\n");
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].includes("# __BREAKPOINT__") && !lines[i].includes("x__x__x__x")) {
          theGlobalDebugger.add_breakpoint("<stdin>.py", i + 1, "0", false);
        }
      }
      if (!hasWarnings && code !== last_code && !skip_faulty_found_errors) {
        last_code = code;
      }
      theGlobalDebugger.set_code_starting_line(code_prefix.split("\n").length - 1);
      theGlobalDebugger.set_code_lines(code.split("\n"));
      theGlobalDebugger.set_program_data({
        Code: code,
        source_map: sourceMap,
        has_turtle: hasTurtle,
        has_pygame: hasPygame,
        has_clear: hasClear,
        has_music: hasMusic,
        Warning: hasWarnings
      });
      startDebug();
      return theGlobalDebugger.startDebugger(() => Sk.importMainWithBody("<stdin>", false, code, true), theGlobalDebugger).then(function() {
        console.log("Program executed");
        $("#stopit").hide();
        $("#runit").show();
        stopDebug();
        if (hasPygame) {
          document.onkeydown = null;
          $("#pygame-modal").hide();
        }
        if (hasTurtle) {
          $("#saveFilesContainer").show();
        }
        if (cb2)
          cb2();
      }).catch(function(err) {
        const errorMessage = errorMessageFromSkulptError(err) || null;
        if (!errorMessage) {
          throw null;
        }
        throw new Error(errorMessage);
      });
    } else {
      return theGlobalDebugger.continueForward().catch(function(err) {
        console.error(err);
        const errorMessage = errorMessageFromSkulptError(err) || null;
        if (!errorMessage) {
          throw null;
        }
        throw new Error(errorMessage);
      });
    }
    function errorMessageFromSkulptError(err) {
      const message = err.args && err.args.v && err.args.v[0] && err.args.v[0].v;
      return message;
    }
    function addToOutput(text, color19) {
      $("<span>").text(text).css({ color: color19 }).appendTo(outputDiv);
      scrollOutputToBottom();
    }
    function outf(text) {
      addToOutput(text, "white");
      speak(text);
    }
    function builtinRead(x) {
      if (x in skulptExternalLibraries) {
        const tmpPath = skulptExternalLibraries[x]["path"];
        if (x === "./pygame.js") {
          return Sk.misceval.promiseToSuspension(fetch(tmpPath).then((r) => r.text()));
        } else {
          let request = new XMLHttpRequest();
          request.open("GET", tmpPath, false);
          request.send();
          if (request.status !== 200) {
            return void 0;
          }
          return request.responseText;
        }
      }
      if (Sk.builtinFiles === void 0 || Sk.builtinFiles["files"][x] === void 0)
        throw "File not found: '" + x + "'";
      return Sk.builtinFiles["files"][x];
    }
    function inputFromInlineModal(prompt) {
      var storage = window.localStorage;
      var debug = storage.getItem("debugLine");
      if (storage.getItem("prompt-" + prompt) == null) {
        Sk.execStart = new Date(new Date().getTime() + 1e3 * 60 * 60 * 24 * 365);
        $("#turtlecanvas").hide();
        if (pygameRunning) {
          Sk.unbindPygameListeners();
          document.onkeydown = null;
          $("#pygame-modal").hide();
        }
        return new Promise(function(ok) {
          askPromptOpen = true;
          const input2 = $('#ask-modal input[type="text"]');
          $("#ask-modal .caption").text(prompt);
          input2.val("");
          input2.attr("placeholder", prompt);
          speak(prompt);
          setTimeout(function() {
            input2.focus();
          }, 0);
          $("#ask-modal form").one("submit", function(event2) {
            askPromptOpen = false;
            event2.preventDefault();
            $("#ask-modal").hide();
            if (hasTurtle) {
              $("#turtlecanvas").show();
            }
            if (pygameRunning) {
              Sk.bindPygameListeners();
              document.onkeydown = animateKeys;
              if (!hasTurtle) {
                $("#pygame-modal").show();
              }
            }
            Sk.execStart = new Date();
            setTimeout(function() {
              ok(input2.val());
              if (debug != null) {
                storage.setItem("prompt-" + prompt, input2.val().toString());
              }
              $("#output").focus();
            }, 0);
            return false;
          });
          $("#ask-modal").show();
          scrollOutputToBottom();
        });
      } else {
        return new Promise(function(ok) {
          ok(storage.getItem("prompt-" + prompt));
        });
      }
    }
  }
  function resetTurtleTarget() {
    if (Sk.TurtleGraphics !== void 0) {
      let selector = Sk.TurtleGraphics.target;
      let target = typeof selector === "string" ? document.getElementById(selector) : selector;
      if (target !== null && target !== void 0) {
        while (target.firstChild) {
          target.removeChild(target.firstChild);
        }
        return target;
      }
    }
    return null;
  }
  function animateKeys(event2) {
    const keyColors = ["#cbd5e0", "#bee3f8", "#4299e1", "#ff617b", "#ae81ea", "#68d391"];
    const output = $("#output");
    if (output !== null) {
      let keyElement = $("<div></div>");
      output.append(keyElement);
      keyElement.text(event2.key);
      keyElement.css("color", keyColors[Math.floor(Math.random() * keyColors.length)]);
      keyElement.addClass("animate-keys");
      setTimeout(function() {
        keyElement.remove();
      }, 1500);
    }
  }
  function initCanvas4PyGame() {
    let currentTarget = resetTurtleTarget();
    let div1 = document.createElement("div");
    if (currentTarget !== null) {
      currentTarget.appendChild(div1);
      $(div1).addClass("modal");
      $(div1).css("text-align", "center");
      $(div1).css("display", "none");
      let div2 = document.createElement("div");
      $(div2).addClass("modal-dialog modal-lg");
      $(div2).css("display", "inline-block");
      $(div2).width(void 0 + 42);
      $(div2).attr("role", "document");
      div1.appendChild(div2);
      let div3 = document.createElement("div");
      $(div3).addClass("modal-content");
      div2.appendChild(div3);
      let div4 = document.createElement("div");
      $(div4).addClass("modal-header d-flex justify-content-between");
      let div5 = document.createElement("div");
      $(div5).addClass("modal-body");
      let div6 = document.createElement("div");
      $(div6).addClass("modal-footer");
      let div7 = document.createElement("div");
      $(div7).addClass("col-md-8");
      let div8 = document.createElement("div");
      $(div8).addClass("col-md-4");
      div3.appendChild(div4);
      div3.appendChild(div5);
      div3.appendChild(div6);
      $(Sk.main_canvas).css("border", "none");
      $(Sk.main_canvas).css("display", "none");
      div5.appendChild(Sk.main_canvas);
    }
  }
  function initSkulpt4Pygame() {
    Sk.main_canvas = document.createElement("canvas");
    Sk.configure({
      killableWhile: true,
      killableFor: true,
      __future__: Sk.python3
    });
  }
  function speak(text) {
    var selectedURI = $("#speak_dropdown").val();
    if (!selectedURI) {
      return;
    }
    var voice = window.speechSynthesis.getVoices().filter((v) => v.voiceURI === selectedURI)[0];
    if (voice) {
      let utterance = new SpeechSynthesisUtterance(text);
      utterance.voice = voice;
      utterance.rate = 0.9;
      speechSynthesis.speak(utterance);
    }
    pushAchievement("make_some_noise");
  }
  function initializeSpeech() {
    const isBeingTested = !!window.Cypress;
    if (!window.speechSynthesis && !isBeingTested) {
      return;
    }
    if (!theLanguage2) {
      return;
    }
    let attempts = 0;
    const timer = setInterval(function() {
      attempts += 1;
      const voices = findVoices(theLanguage2);
      if (voices.length > 0 || isBeingTested) {
        for (const voice of voices) {
          $("#speak_dropdown").append($("<option>").attr("value", voice.voiceURI).text("\u{1F4E3} " + voice.name));
        }
        $("#speak_container").show();
        clearInterval(timer);
      }
      if (attempts >= 20) {
        clearInterval(timer);
      }
    }, 100);
    function findVoices(lang) {
      const m = lang.match(/^([a-z]+)/i);
      if (!m) {
        return [];
      }
      const simpleLang = m[1];
      if (!window.speechSynthesis) {
        return [];
      }
      return window.speechSynthesis.getVoices().filter((voice) => voice.lang.startsWith(simpleLang));
    }
  }
  function load_quiz(level3) {
    $('*[data-tabtarget="quiz"]').html('<iframe id="quiz-iframe" class="w-full" title="Quiz" src="/quiz/start/' + level3 + '"></iframe>');
  }
  function showVariableView() {
    const variables = $("#variables");
    if (variables.is(":hidden")) {
      variables.show();
      $("#variables").trigger("click");
    } else {
      variables.hide();
    }
  }
  async function store_parsons_attempt(order, correct) {
    try {
      await postJsonWithAchievements("/store_parsons_order", {
        level: theLevel,
        exercise: $("#next_parson_button").attr("current_exercise"),
        order,
        correct
      });
    } catch (e) {
      console.error(e);
    }
    ;
  }
  function get_active_and_trimmed_code() {
    theGlobalEditor.trimTrailingSpace();
    const storage = window.localStorage;
    const debugLine2 = storage.getItem("debugLine");
    return theGlobalEditor.getActiveContents(debugLine2);
  }
  function getEditorContents() {
    return theGlobalEditor.contents;
  }
  function confetti_cannon() {
    const canvas = document.getElementById("confetti");
    if (canvas) {
      canvas.classList.remove("hidden");
      const jsConfetti = new JSConfetti({ canvas });
      setTimeout(function() {
        canvas.classList.add("hidden");
      }, 3e3);
      let adventures = $("#adventures");
      let currentAdventure = $(adventures).find(".tab-selected").attr("data-tab");
      let customLevels = ["turtle", "rock", "haunted", "restaurant", "fortune", "songs", "dice"];
      if (customLevels.includes(currentAdventure)) {
        let currentAdventureConfetti = getConfettiForAdventure(currentAdventure != null ? currentAdventure : "");
        jsConfetti.addConfetti({
          emojis: currentAdventureConfetti,
          emojiSize: 45,
          confettiNumber: 100
        });
      } else {
        jsConfetti.addConfetti();
      }
      const confettiButton = document.getElementById("confetti-button");
      if (confettiButton) {
        confettiButton.classList.add("hidden");
      }
    }
  }
  function getConfettiForAdventure(adventure) {
    if (ClientMessages[adventure]) {
      return Array.from(ClientMessages[adventure]).filter((x) => x !== "," && x !== " ");
    }
    return [["\u{1F308}"], ["\u26A1\uFE0F"], ["\u{1F4A5}"], ["\u2728"], ["\u{1F4AB}"]];
  }
  function scrollOutputToBottom() {
    const outputDiv = $("#output");
    outputDiv.scrollTop(outputDiv.prop("scrollHeight"));
  }
  function modalStepOne(level3) {
    createModal(level3);
    let $modalEditor = $("#modal-editor");
    if ($modalEditor.length) {
      const dir = $("body").attr("dir");
      theModalEditor = editorCreator2.initializeEditorWithGutter($modalEditor, EditorType.MODAL, dir);
    }
  }
  function showSuccesMessage() {
    removeBulb();
    var allsuccessmessages = ClientMessages["Transpile_success"].split("\n");
    var randomnum = Math.floor(Math.random() * allsuccessmessages.length);
    success.show(allsuccessmessages[randomnum]);
  }
  function createModal(level3) {
    let editor = `<div id='modal-editor' class="w-full flex-1 text-lg rounded" style='height:200px; width:50vw;'></div>`.replace("{level}", level3.toString());
    let title = ClientMessages["Program_repair"];
    modal.repair(editor, 0, title);
  }
  function toggleDevelopersMode(event2 = "click", enforceDevMode) {
    let enable = false;
    switch (event2) {
      case "load":
        const lastSelection = window.localStorage.getItem("developer_mode") === "true";
        enable = enforceDevMode || lastSelection;
        $("#developers_toggle").prop("checked", enable);
        break;
      case "click":
        enable = $("#developers_toggle").prop("checked");
        window.localStorage.setItem("developer_mode", `${enable}`);
        if (enable) {
          pushAchievement("lets_focus");
        }
        break;
    }
    $("#adventures").toggle(!enable);
    if (currentTab === "parsons")
      return;
    $("[data-devmodeheight]").each((_, el3) => {
      const heights = $(el3).data("devmodeheight").split(",");
      $(el3).css("height", heights[enable ? 1 : 0]);
    });
  }
  async function tryCatchErrorBox(cb2) {
    try {
      return await cb2();
    } catch (e) {
      console.log("Error", e);
      error.show(ClientMessages["Transpile_error"], e.message);
    }
  }
  function toggle_keyword_language(current_lang, new_lang) {
    tryCatchErrorBox(async () => {
      const response = await postJsonWithAchievements("/translate_keywords", {
        code: theGlobalEditor.contents,
        start_lang: current_lang,
        goal_lang: new_lang,
        level: theLevel
      });
      if (response.success) {
        const code = response.code;
        theGlobalEditor.contents = code;
        const saveName = saveNameFromInput();
        localSave(currentTabLsKey(), { saveName, code });
        $("#editor").attr("lang", new_lang);
        const hash = window.location.hash;
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);
        urlParams.set("keyword_language", new_lang);
        window.location.search = urlParams.toString();
        window.open(hash, "_self");
      }
    });
  }
  function toggle_blur_code() {
    $(".blur-toggle").toggle();
    if ($("#editor").attr("blurred") == "true") {
      $("#editor").css("filter", "");
      $("#editor").css("-webkit-filter", "");
      $("#editor").attr("blurred", "false");
    } else {
      $("#editor").css("filter", "blur(3px)");
      $("#editor").css("-webkit-filter", "blur(3px)");
      $("#editor").attr("blurred", "true");
    }
  }
  async function change_language(lang) {
    await tryCatchPopup(async () => {
      const response = await postJsonWithAchievements("/change_language", { lang });
      if (response.succes) {
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);
        if (urlParams.get("keyword_language") !== null) {
          urlParams.set("keyword_language", "en");
        }
        if (urlParams.get("language") !== null) {
          urlParams.set("language", lang);
          window.location.search = urlParams.toString();
        } else {
          location.reload();
        }
      }
    });
  }
  async function postJsonWithAchievements(url, data) {
    const response = await postJson(url, data);
    showAchievements(response.achievement, true, "");
    return response;
  }
  function update_view(selector_container, new_lang) {
    $("#" + selector_container + " > div").map(function() {
      if ($(this).attr("lang") == new_lang) {
        $(this).show();
      } else {
        $(this).hide();
      }
    });
  }
  function select_profile_image(image) {
    $(".profile_image").removeClass("border-2 border-blue-600");
    $("#profile_image_" + image).addClass("border-2 border-blue-600");
    $("#image").val(image);
  }
  function filter_admin() {
    const params = {};
    const filter = $("#admin_filter_category").val();
    params["filter"] = filter;
    if ($("#hidden-page-input").val()) {
      params["page"] = $("#hidden-page-input").val();
    }
    switch (filter) {
      case "email":
      case "username":
        params["substring"] = $("#email_filter_input").val();
        break;
      case "language":
        params["language"] = $("#language_filter_input").val();
        break;
      case "keyword_language":
        params["keyword_language"] = $("#keyword_language_filter_input").val();
        break;
      default:
        params["start"] = $("#admin_start_date").val();
        params["end"] = $("#admin_end_date").val();
        break;
    }
    const queryString = Object.entries(params).map(([k, v]) => k + "=" + encodeURIComponent(v)).join("&");
    window.open("?" + queryString, "_self");
  }
  function hide_editor() {
    $("#fold_in_toggle_container").hide();
    $("#code_editor").toggle();
    $("#code_output").addClass("col-span-2");
    $("#fold_out_toggle_container").show();
  }
  function show_editor() {
    $("#fold_out_toggle_container").hide();
    $("#code_editor").toggle();
    $("#code_output").removeClass("col-span-2");
    $("#fold_in_toggle_container").show();
  }
  var timers = [];
  var timeout = (func, delay) => {
    let id2;
    const wrapper = () => {
      let idx = timers.indexOf(id2);
      if (idx > -1) {
        timers.splice(idx, 1);
      }
      func();
    };
    id2 = window.setTimeout(wrapper, delay);
    timers.push(id2);
  };
  var clearTimeouts = () => {
    timers.forEach(clearTimeout);
    timers = [];
  };
  function downloadSlides(level3) {
    var iframe = document.getElementById(`level-${level3}-slides`);
    iframe.setAttribute("src", `/slides/${level3}`);
    $(`#level-${level3}-slides`).on("load", function() {
      var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
      var slides = innerDoc.getElementsByTagName("section");
      var slidesHTML = "";
      for (let i = 0; i < slides.length; i++) {
        var innerIframe = slides[i].getElementsByTagName("iframe");
        for (let j2 = 0; j2 < innerIframe.length; j2++) {
          var a = document.createElement("a");
          a.href = "https://www.hedy.org" + innerIframe[j2].getAttribute("src");
          a.appendChild(document.createTextNode(a.href));
          slides[i].appendChild(a);
          slides[i].removeChild(innerIframe[j2]);
        }
        slidesHTML += "\n" + slides[i].outerHTML;
      }
      var template = slides_template.replace("{replace}", slidesHTML);
      var zip = (0, import_jszip.default)();
      zip.file("index.html", template);
      zip.folder("lib");
      zip.folder(`hedy-level-${level3}`);
      zip.generateAsync({ type: "blob" }).then(function(content2) {
        download(content2, `hedy-level-${level3}.zip`, "zip");
      });
    });
  }
  function download(data, filename, type) {
    var file = new Blob([data], { type });
    var a = document.createElement("a"), url = URL.createObjectURL(file);
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(function() {
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }, 0);
  }
  function resetWindow() {
    $("#warningbox").hide();
    $("#errorbox").hide();
    $("#okbox").hide();
    $("#repair_button").hide();
    const output = $("#output");
    const variable_button = $(output).find("#variable_button");
    const variables = $(output).find("#variables");
    output.empty();
    $("#turtlecanvas").empty();
    output.append(variable_button);
    output.append(variables);
    theGlobalEditor == null ? void 0 : theGlobalEditor.clearSelection();
    theGlobalEditor == null ? void 0 : theGlobalEditor.clearBreakpoints();
  }
  function updatePageElements() {
    var _a3;
    const isCodeTab = !(currentTab === "quiz" || currentTab === "parsons");
    $("#adventures-tab").toggle(!(isCodeTab && $("#developers_toggle").is(":checked")));
    $("#developers_toggle_container").toggle(isCodeTab);
    $("#level-header input").toggle(isCodeTab);
    $("#parsons_code_container").toggle(currentTab === "parsons");
    $("#editor-area").toggle(isCodeTab || currentTab === "parsons");
    $("#editor").toggle(isCodeTab);
    $("#debug_container").toggle(isCodeTab);
    $("#program_name_container").toggle(isCodeTab);
    theGlobalEditor.isReadOnly = false;
    const adventure = theAdventures[currentTab];
    if (adventure) {
      const saveInfo = isServerSaveInfo(adventure.save_info) ? adventure.save_info : { id: "*dummy*" };
      const isPublic = !!saveInfo.public;
      $("#share_program_button").toggleClass("active-bluebar-btn", isPublic);
      $(`#share-${isPublic ? "public" : "private"}`).prop("checked", true);
      $('[data-view="if-public"]').toggle(isPublic);
      $('[data-view="if-public-url"]').toggle(!!saveInfo.public_url);
      $('input[data-view="public-url"]').val((_a3 = saveInfo.public_url) != null ? _a3 : "");
      const isSubmitted = !!saveInfo.submitted;
      $("#hand_in_button").toggleClass("active-bluebar-btn", isSubmitted);
      $('[data-view="if-submitted"]').toggle(isSubmitted);
      $('[data-view="if-not-submitted"]').toggle(!isSubmitted);
      theGlobalEditor.isReadOnly = isSubmitted;
    }
  }
  function reconfigurePageBasedOnTab() {
    resetWindow();
    updatePageElements();
    if (currentTab === "parsons") {
      loadParsonsExercise(theLevel, 1);
      document.getElementById("code_editor").style.height = "100%";
      document.getElementById("code_output").style.height = "100%";
      return;
    } else {
      $("[data-devmodeheight]").each((_, el3) => {
        const heights = $(el3).data("devmodeheight").split(",");
        $(el3).css("height", heights[0]);
      });
    }
    const adventure = theAdventures[currentTab];
    if (adventure) {
      $("#program_name").val(adventure.save_name);
      theGlobalEditor.contents = adventure.editor_contents;
    }
  }
  function closeContainingModal(target) {
    $(target).closest('[data-modal="true"]').hide();
  }
  function initializeShareProgramButtons() {
    $('input[type="radio"][name="public"]').on("change", (ev) => {
      if (ev.target.checked) {
        const isPublic = $(ev.target).val() === "1" ? true : false;
        const adventure = theAdventures[currentTab];
        tryCatchPopup(async () => {
          await saveIfNecessary();
          const saveInfo = isServerSaveInfo(adventure == null ? void 0 : adventure.save_info) ? adventure == null ? void 0 : adventure.save_info : void 0;
          if (!saveInfo) {
            throw new Error("This program does not have an id");
          }
          const response = await postJsonWithAchievements("/programs/share", {
            id: saveInfo.id,
            public: isPublic
          });
          modal.notifySuccess(response.message);
          if (response.save_info) {
            adventure.save_info = response.save_info;
          }
          updatePageElements();
        });
      }
    });
  }
  function initializeHandInButton() {
    $("#do_hand_in_button").on("click", () => {
      const adventure = theAdventures[currentTab];
      tryCatchPopup(async () => {
        await saveIfNecessary();
        const saveInfo = isServerSaveInfo(adventure == null ? void 0 : adventure.save_info) ? adventure.save_info : void 0;
        if (!saveInfo) {
          throw new Error("This program does not have an id");
        }
        const response = await postJsonWithAchievements("/programs/submit", {
          id: saveInfo.id
        });
        modal.notifySuccess(response.message);
        if (response.save_info) {
          adventure.save_info = response.save_info;
        }
        updatePageElements();
      });
    });
  }
  function initializeCopyToClipboard() {
    $('[data-action="copy-to-clipboard"]').on("click", (ev) => {
      const text = $(ev.target).closest('[data-copy="container"]').find("input").val();
      if (typeof text === "string") {
        copy_to_clipboard(text, ClientMessages.copy_link_to_share);
      }
    });
  }
  function saveNameFromInput() {
    return $("#program_name").val();
  }
  function programNeedsSaving(adventureName) {
    const adventure = theAdventures[adventureName];
    if (!adventure) {
      return false;
    }
    const programChanged = theGlobalEditor.contents !== adventure.editor_contents;
    const nameChanged = $("#program_name").val() !== adventure.save_name;
    const localStorageCanBeSavedToServer = theUserIsLoggedIn && adventure.save_info === "local-storage";
    const isUnchangeable = isServerSaveInfo(adventure.save_info) ? adventure.save_info.submitted : false;
    const wasSavedBefore = adventure.save_info !== void 0;
    const suspiciouslySmallFraction = 0.5;
    const programSuspiciouslyShrunk = wasSavedBefore && theGlobalEditor.contents.length < adventure.editor_contents.length * suspiciouslySmallFraction;
    return (programChanged || nameChanged || localStorageCanBeSavedToServer) && !isUnchangeable && !programSuspiciouslyShrunk;
  }
  var saveTimer;
  function triggerAutomaticSave() {
    const saveSeconds = 20;
    cancelPendingAutomaticSave();
    saveTimer = window.setTimeout(() => saveIfNecessary(), saveSeconds * 1e3);
  }
  function cancelPendingAutomaticSave() {
    if (saveTimer) {
      window.clearTimeout(saveTimer);
    }
  }
  var autoSaveEnabled = true;
  function disableAutomaticSaving() {
    autoSaveEnabled = false;
  }
  async function saveIfNecessary() {
    if (!autoSaveEnabled) {
      return;
    }
    const adventureName = currentTab;
    const adventure = theAdventures[adventureName];
    if (!programNeedsSaving(adventureName) || !adventure) {
      return;
    }
    console.info("Saving program automatically...");
    const code = theGlobalEditor.contents;
    const saveName = saveNameFromInput();
    if (theUserIsLoggedIn && saveName) {
      const saveInfo = isServerSaveInfo(adventure.save_info) ? adventure.save_info : void 0;
      const response = await postJsonWithAchievements("/programs", {
        level: theLevel,
        lang: theLanguage2,
        name: saveName,
        code,
        adventure_name: adventureName,
        program_id: saveInfo == null ? void 0 : saveInfo.id,
        share: saveInfo == null ? void 0 : saveInfo.public
      });
      adventure.editor_contents = code;
      if (response.save_info) {
        adventure.save_info = response.save_info;
      }
      localDelete(currentTabLsKey());
    } else {
      localSave(currentTabLsKey(), { saveName, code });
      adventure.editor_contents = code;
    }
  }
  function currentTabLsKey() {
    return `save-${currentTab}-${theLevel}`;
  }
  async function share_program(id2, index3, Public, prompt) {
    await modal.confirmP(prompt);
    await tryCatchPopup(async () => {
      const response = await postJsonWithAchievements("/programs/share", { id: id2, public: Public });
      showAchievements(response.achievement, true, "");
      if (Public) {
        change_shared(true, index3);
      } else {
        change_shared(false, index3);
      }
      modal.notifySuccess(response.message);
    });
  }
  function change_shared(shared, index3) {
    if (index3 == -1) {
      return;
    }
    if (shared) {
      $("#non_public_button_container_" + index3).hide();
      $("#public_button_container_" + index3).show();
      $("#favourite_program_container_" + index3).show();
    } else {
      $("#modal-copy-button").hide();
      $("#public_button_container_" + index3).hide();
      $("#non_public_button_container_" + index3).show();
      $("#favourite_program_container_" + index3).hide();
      $("#favourite_program_container_" + index3).removeClass("text-yellow-400");
      $("#favourite_program_container_" + index3).addClass("text-white");
    }
  }
  function goToLevel(level3) {
    const hash = window.location.hash;
    let newPath = window.location.pathname.replace(/\/\d+/, `/${level3}`);
    if (!newPath.includes(level3)) {
      newPath = window.location.pathname + `/${level3}`;
    }
    window.location.pathname = newPath;
    window.location.hash = hash;
  }

  // static/js/htmx-integration.ts
  htmx.defineExtension("disable-element", {
    onEvent: function(name2, evt) {
      var _a3;
      let elt = evt.detail.elt;
      if (!elt.getAttribute) {
        return;
      }
      let target = (_a3 = elt.getAttribute("hx-disable-element")) != null ? _a3 : "self";
      let targetElement = target == "self" ? elt : document.querySelector(target);
      if (name2 === "htmx:beforeRequest" && targetElement) {
        targetElement.disabled = true;
      } else if (name2 == "htmx:afterRequest" && targetElement) {
        targetElement.disabled = false;
      }
    }
  });
  htmx.onLoad((content2) => {
    initializeHighlightedCodeBlocks(content2);
    var sortables2 = content2.querySelectorAll(".sortable");
    for (let i = 0; i < sortables2.length; i++) {
      var sortable = sortables2[i];
      new sortable_esm_default(sortable, {
        animation: 150,
        ghostClass: "drop-adventures-active"
      });
    }
  });
  htmx.on("htmx:responseError", (ev) => {
    const event2 = ev;
    const xhr = event2.detail.xhr;
    const genericError = event2.detail.error;
    modal.notifyError(xhr.responseText.length < 1e3 ? xhr.responseText : genericError);
  });
  htmx.on("htmx:sendError", () => {
    modal.notifyError(`${ClientMessages.Connection_error} ${ClientMessages.CheckInternet}`);
  });
  htmx.on("displayAchievements", (ev) => {
    const payloads = ev.detail.value;
    for (const payload of payloads) {
      const achievement = payload["achievement"];
      showAchievements(achievement, payload["reload"], payload["redirect"]);
    }
  });

  // node_modules/chart.js/dist/chunks/helpers.segment.mjs
  function noop() {
  }
  var uid = function() {
    let id2 = 0;
    return function() {
      return id2++;
    };
  }();
  function isNullOrUndef(value) {
    return value === null || typeof value === "undefined";
  }
  function isArray2(value) {
    if (Array.isArray && Array.isArray(value)) {
      return true;
    }
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
      return true;
    }
    return false;
  }
  function isObject2(value) {
    return value !== null && Object.prototype.toString.call(value) === "[object Object]";
  }
  var isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
  function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
  }
  function valueOrDefault(value, defaultValue) {
    return typeof value === "undefined" ? defaultValue : value;
  }
  var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
  var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
  function callback(fn2, args, thisArg) {
    if (fn2 && typeof fn2.call === "function") {
      return fn2.apply(thisArg, args);
    }
  }
  function each(loopable, fn2, thisArg, reverse) {
    let i, len, keys;
    if (isArray2(loopable)) {
      len = loopable.length;
      if (reverse) {
        for (i = len - 1; i >= 0; i--) {
          fn2.call(thisArg, loopable[i], i);
        }
      } else {
        for (i = 0; i < len; i++) {
          fn2.call(thisArg, loopable[i], i);
        }
      }
    } else if (isObject2(loopable)) {
      keys = Object.keys(loopable);
      len = keys.length;
      for (i = 0; i < len; i++) {
        fn2.call(thisArg, loopable[keys[i]], keys[i]);
      }
    }
  }
  function _elementsEqual(a02, a1) {
    let i, ilen, v0, v1;
    if (!a02 || !a1 || a02.length !== a1.length) {
      return false;
    }
    for (i = 0, ilen = a02.length; i < ilen; ++i) {
      v0 = a02[i];
      v1 = a1[i];
      if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
        return false;
      }
    }
    return true;
  }
  function clone$1(source) {
    if (isArray2(source)) {
      return source.map(clone$1);
    }
    if (isObject2(source)) {
      const target = Object.create(null);
      const keys = Object.keys(source);
      const klen = keys.length;
      let k = 0;
      for (; k < klen; ++k) {
        target[keys[k]] = clone$1(source[keys[k]]);
      }
      return target;
    }
    return source;
  }
  function isValidKey(key) {
    return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
  }
  function _merger(key, target, source, options) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject2(tval) && isObject2(sval)) {
      merge(tval, sval, options);
    } else {
      target[key] = clone$1(sval);
    }
  }
  function merge(target, source, options) {
    const sources = isArray2(source) ? source : [source];
    const ilen = sources.length;
    if (!isObject2(target)) {
      return target;
    }
    options = options || {};
    const merger = options.merger || _merger;
    for (let i = 0; i < ilen; ++i) {
      source = sources[i];
      if (!isObject2(source)) {
        continue;
      }
      const keys = Object.keys(source);
      for (let k = 0, klen = keys.length; k < klen; ++k) {
        merger(keys[k], target, source, options);
      }
    }
    return target;
  }
  function mergeIf(target, source) {
    return merge(target, source, { merger: _mergerIf });
  }
  function _mergerIf(key, target, source) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject2(tval) && isObject2(sval)) {
      mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
      target[key] = clone$1(sval);
    }
  }
  var keyResolvers = {
    "": (v) => v,
    x: (o) => o.x,
    y: (o) => o.y
  };
  function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
  }
  function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj) => {
      for (const k of keys) {
        if (k === "") {
          break;
        }
        obj = obj && obj[k];
      }
      return obj;
    };
  }
  function _splitKey(key) {
    const parts = key.split(".");
    const keys = [];
    let tmp = "";
    for (const part of parts) {
      tmp += part;
      if (tmp.endsWith("\\")) {
        tmp = tmp.slice(0, -1) + ".";
      } else {
        keys.push(tmp);
        tmp = "";
      }
    }
    return keys;
  }
  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  var defined = (value) => typeof value !== "undefined";
  var isFunction2 = (value) => typeof value === "function";
  var setsEqual = (a, b) => {
    if (a.size !== b.size) {
      return false;
    }
    for (const item of a) {
      if (!b.has(item)) {
        return false;
      }
    }
    return true;
  };
  function _isClickEvent(e) {
    return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
  }
  var PI = Math.PI;
  var TAU = 2 * PI;
  var PITAU = TAU + PI;
  var INFINITY = Number.POSITIVE_INFINITY;
  var RAD_PER_DEG = PI / 180;
  var HALF_PI = PI / 2;
  var QUARTER_PI = PI / 4;
  var TWO_THIRDS_PI = PI * 2 / 3;
  var log10 = Math.log10;
  var sign = Math.sign;
  function niceNum(range10) {
    const roundedRange = Math.round(range10);
    range10 = almostEquals(range10, roundedRange, range10 / 1e3) ? roundedRange : range10;
    const niceRange = Math.pow(10, Math.floor(log10(range10)));
    const fraction = range10 / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
  }
  function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i;
    for (i = 1; i < sqrt; i++) {
      if (value % i === 0) {
        result.push(i);
        result.push(value / i);
      }
    }
    if (sqrt === (sqrt | 0)) {
      result.push(sqrt);
    }
    result.sort((a, b) => a - b).pop();
    return result;
  }
  function isNumber2(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }
  function almostEquals(x, y2, epsilon) {
    return Math.abs(x - y2) < epsilon;
  }
  function almostWhole(x, epsilon) {
    const rounded = Math.round(x);
    return rounded - epsilon <= x && rounded + epsilon >= x;
  }
  function _setMinAndMaxByKey(array, target, property) {
    let i, ilen, value;
    for (i = 0, ilen = array.length; i < ilen; i++) {
      value = array[i][property];
      if (!isNaN(value)) {
        target.min = Math.min(target.min, value);
        target.max = Math.max(target.max, value);
      }
    }
  }
  function toRadians(degrees) {
    return degrees * (PI / 180);
  }
  function toDegrees(radians) {
    return radians * (180 / PI);
  }
  function _decimalPlaces(x) {
    if (!isNumberFinite(x)) {
      return;
    }
    let e = 1;
    let p = 0;
    while (Math.round(x * e) / e !== x) {
      e *= 10;
      p++;
    }
    return p;
  }
  function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
      angle += TAU;
    }
    return {
      angle,
      distance: radialDistanceFromCenter
    };
  }
  function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
  }
  function _angleDiff(a, b) {
    return (a - b + PITAU) % TAU - PI;
  }
  function _normalizeAngle(a) {
    return (a % TAU + TAU) % TAU;
  }
  function _angleBetween(angle, start2, end, sameAngleIsFullCircle) {
    const a = _normalizeAngle(angle);
    const s = _normalizeAngle(start2);
    const e = _normalizeAngle(end);
    const angleToStart = _normalizeAngle(s - a);
    const angleToEnd = _normalizeAngle(e - a);
    const startToAngle = _normalizeAngle(a - s);
    const endToAngle = _normalizeAngle(a - e);
    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
  }
  function _limitValue(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
  }
  function _isBetween(value, start2, end, epsilon = 1e-6) {
    return value >= Math.min(start2, end) - epsilon && value <= Math.max(start2, end) + epsilon;
  }
  function _lookup(table, value, cmp) {
    cmp = cmp || ((index3) => table[index3] < value);
    let hi3 = table.length - 1;
    let lo2 = 0;
    let mid;
    while (hi3 - lo2 > 1) {
      mid = lo2 + hi3 >> 1;
      if (cmp(mid)) {
        lo2 = mid;
      } else {
        hi3 = mid;
      }
    }
    return { lo: lo2, hi: hi3 };
  }
  var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index3) => table[index3][key] <= value : (index3) => table[index3][key] < value);
  var _rlookupByKey = (table, key, value) => _lookup(table, value, (index3) => table[index3][key] >= value);
  function _filterBetween(values, min, max) {
    let start2 = 0;
    let end = values.length;
    while (start2 < end && values[start2] < min) {
      start2++;
    }
    while (end > start2 && values[end - 1] > max) {
      end--;
    }
    return start2 > 0 || end < values.length ? values.slice(start2, end) : values;
  }
  var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
  function listenArrayEvents(array, listener) {
    if (array._chartjs) {
      array._chartjs.listeners.push(listener);
      return;
    }
    Object.defineProperty(array, "_chartjs", {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [listener]
      }
    });
    arrayEvents.forEach((key) => {
      const method = "_onData" + _capitalize(key);
      const base2 = array[key];
      Object.defineProperty(array, key, {
        configurable: true,
        enumerable: false,
        value(...args) {
          const res = base2.apply(this, args);
          array._chartjs.listeners.forEach((object) => {
            if (typeof object[method] === "function") {
              object[method](...args);
            }
          });
          return res;
        }
      });
    });
  }
  function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) {
      return;
    }
    const listeners = stub.listeners;
    const index3 = listeners.indexOf(listener);
    if (index3 !== -1) {
      listeners.splice(index3, 1);
    }
    if (listeners.length > 0) {
      return;
    }
    arrayEvents.forEach((key) => {
      delete array[key];
    });
    delete array._chartjs;
  }
  function _arrayUnique(items) {
    const set2 = new Set();
    let i, ilen;
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      set2.add(items[i]);
    }
    if (set2.size === ilen) {
      return items;
    }
    return Array.from(set2);
  }
  var requestAnimFrame = function() {
    if (typeof window === "undefined") {
      return function(callback2) {
        return callback2();
      };
    }
    return window.requestAnimationFrame;
  }();
  function throttled(fn2, thisArg, updateFn) {
    const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
    let ticking = false;
    let args = [];
    return function(...rest) {
      args = updateArgs(rest);
      if (!ticking) {
        ticking = true;
        requestAnimFrame.call(window, () => {
          ticking = false;
          fn2.apply(thisArg, args);
        });
      }
    };
  }
  function debounce(fn2, delay) {
    let timeout2;
    return function(...args) {
      if (delay) {
        clearTimeout(timeout2);
        timeout2 = setTimeout(fn2, delay, args);
      } else {
        fn2.apply(this, args);
      }
      return delay;
    };
  }
  var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
  var _alignStartEnd = (align, start2, end) => align === "start" ? start2 : align === "end" ? end : (start2 + end) / 2;
  var _textX = (align, left, right, rtl) => {
    const check = rtl ? "left" : "right";
    return align === check ? right : align === "center" ? (left + right) / 2 : left;
  };
  function _getStartAndCountOfVisiblePoints(meta2, points, animationsDisabled) {
    const pointCount = points.length;
    let start2 = 0;
    let count = pointCount;
    if (meta2._sorted) {
      const { iScale, _parsed } = meta2;
      const axis = iScale.axis;
      const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
      if (minDefined) {
        start2 = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
      }
      if (maxDefined) {
        count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start2, pointCount) - start2;
      } else {
        count = pointCount - start2;
      }
    }
    return { start: start2, count };
  }
  function _scaleRangesChanged(meta2) {
    const { xScale, yScale, _scaleRanges } = meta2;
    const newRanges = {
      xmin: xScale.min,
      xmax: xScale.max,
      ymin: yScale.min,
      ymax: yScale.max
    };
    if (!_scaleRanges) {
      meta2._scaleRanges = newRanges;
      return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
  }
  var atEdge = (t2) => t2 === 0 || t2 === 1;
  var elasticIn = (t2, s, p) => -(Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s) * TAU / p));
  var elasticOut = (t2, s, p) => Math.pow(2, -10 * t2) * Math.sin((t2 - s) * TAU / p) + 1;
  var effects = {
    linear: (t2) => t2,
    easeInQuad: (t2) => t2 * t2,
    easeOutQuad: (t2) => -t2 * (t2 - 2),
    easeInOutQuad: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1),
    easeInCubic: (t2) => t2 * t2 * t2,
    easeOutCubic: (t2) => (t2 -= 1) * t2 * t2 + 1,
    easeInOutCubic: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2),
    easeInQuart: (t2) => t2 * t2 * t2 * t2,
    easeOutQuart: (t2) => -((t2 -= 1) * t2 * t2 * t2 - 1),
    easeInOutQuart: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2),
    easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
    easeOutQuint: (t2) => (t2 -= 1) * t2 * t2 * t2 * t2 + 1,
    easeInOutQuint: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2),
    easeInSine: (t2) => -Math.cos(t2 * HALF_PI) + 1,
    easeOutSine: (t2) => Math.sin(t2 * HALF_PI),
    easeInOutSine: (t2) => -0.5 * (Math.cos(PI * t2) - 1),
    easeInExpo: (t2) => t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1)),
    easeOutExpo: (t2) => t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1,
    easeInOutExpo: (t2) => atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 10 * (t2 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t2 * 2 - 1)) + 2),
    easeInCirc: (t2) => t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1),
    easeOutCirc: (t2) => Math.sqrt(1 - (t2 -= 1) * t2),
    easeInOutCirc: (t2) => (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1),
    easeInElastic: (t2) => atEdge(t2) ? t2 : elasticIn(t2, 0.075, 0.3),
    easeOutElastic: (t2) => atEdge(t2) ? t2 : elasticOut(t2, 0.075, 0.3),
    easeInOutElastic(t2) {
      const s = 0.1125;
      const p = 0.45;
      return atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * elasticIn(t2 * 2, s, p) : 0.5 + 0.5 * elasticOut(t2 * 2 - 1, s, p);
    },
    easeInBack(t2) {
      const s = 1.70158;
      return t2 * t2 * ((s + 1) * t2 - s);
    },
    easeOutBack(t2) {
      const s = 1.70158;
      return (t2 -= 1) * t2 * ((s + 1) * t2 + s) + 1;
    },
    easeInOutBack(t2) {
      let s = 1.70158;
      if ((t2 /= 0.5) < 1) {
        return 0.5 * (t2 * t2 * (((s *= 1.525) + 1) * t2 - s));
      }
      return 0.5 * ((t2 -= 2) * t2 * (((s *= 1.525) + 1) * t2 + s) + 2);
    },
    easeInBounce: (t2) => 1 - effects.easeOutBounce(1 - t2),
    easeOutBounce(t2) {
      const m = 7.5625;
      const d2 = 2.75;
      if (t2 < 1 / d2) {
        return m * t2 * t2;
      }
      if (t2 < 2 / d2) {
        return m * (t2 -= 1.5 / d2) * t2 + 0.75;
      }
      if (t2 < 2.5 / d2) {
        return m * (t2 -= 2.25 / d2) * t2 + 0.9375;
      }
      return m * (t2 -= 2.625 / d2) * t2 + 0.984375;
    },
    easeInOutBounce: (t2) => t2 < 0.5 ? effects.easeInBounce(t2 * 2) * 0.5 : effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5
  };
  function round(v) {
    return v + 0.5 | 0;
  }
  var lim = (v, l, h3) => Math.max(Math.min(v, h3), l);
  function p2b(v) {
    return lim(round(v * 2.55), 0, 255);
  }
  function n2b(v) {
    return lim(round(v * 255), 0, 255);
  }
  function b2n(v) {
    return lim(round(v / 2.55) / 100, 0, 1);
  }
  function n2p(v) {
    return lim(round(v * 100), 0, 100);
  }
  var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
  var hex = [..."0123456789ABCDEF"];
  var h1 = (b) => hex[b & 15];
  var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
  var eq = (b) => (b & 240) >> 4 === (b & 15);
  var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
  function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === "#") {
      if (len === 4 || len === 5) {
        ret = {
          r: 255 & map$1[str[1]] * 17,
          g: 255 & map$1[str[2]] * 17,
          b: 255 & map$1[str[3]] * 17,
          a: len === 5 ? map$1[str[4]] * 17 : 255
        };
      } else if (len === 7 || len === 9) {
        ret = {
          r: map$1[str[1]] << 4 | map$1[str[2]],
          g: map$1[str[3]] << 4 | map$1[str[4]],
          b: map$1[str[5]] << 4 | map$1[str[6]],
          a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
        };
      }
    }
    return ret;
  }
  var alpha = (a, f) => a < 255 ? f(a) : "";
  function hexString(v) {
    var f = isShort(v) ? h1 : h2;
    return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
  }
  var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
  function hsl2rgbn(h3, s, l) {
    const a = s * Math.min(l, 1 - l);
    const f = (n, k = (n + h3 / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return [f(0), f(8), f(4)];
  }
  function hsv2rgbn(h3, s, v) {
    const f = (n, k = (n + h3 / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    return [f(5), f(3), f(1)];
  }
  function hwb2rgbn(h3, w, b) {
    const rgb = hsl2rgbn(h3, 1, 0.5);
    let i;
    if (w + b > 1) {
      i = 1 / (w + b);
      w *= i;
      b *= i;
    }
    for (i = 0; i < 3; i++) {
      rgb[i] *= 1 - w - b;
      rgb[i] += w;
    }
    return rgb;
  }
  function hueValue(r, g, b, d2, max) {
    if (r === max) {
      return (g - b) / d2 + (g < b ? 6 : 0);
    }
    if (g === max) {
      return (b - r) / d2 + 2;
    }
    return (r - g) / d2 + 4;
  }
  function rgb2hsl(v) {
    const range10 = 255;
    const r = v.r / range10;
    const g = v.g / range10;
    const b = v.b / range10;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (max + min) / 2;
    let h3, s, d2;
    if (max !== min) {
      d2 = max - min;
      s = l > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
      h3 = hueValue(r, g, b, d2, max);
      h3 = h3 * 60 + 0.5;
    }
    return [h3 | 0, s || 0, l];
  }
  function calln(f, a, b, c2) {
    return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c2)).map(n2b);
  }
  function hsl2rgb(h3, s, l) {
    return calln(hsl2rgbn, h3, s, l);
  }
  function hwb2rgb(h3, w, b) {
    return calln(hwb2rgbn, h3, w, b);
  }
  function hsv2rgb(h3, s, v) {
    return calln(hsv2rgbn, h3, s, v);
  }
  function hue(h3) {
    return (h3 % 360 + 360) % 360;
  }
  function hueParse(str) {
    const m = HUE_RE.exec(str);
    let a = 255;
    let v;
    if (!m) {
      return;
    }
    if (m[5] !== v) {
      a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
    }
    const h3 = hue(+m[2]);
    const p1 = +m[3] / 100;
    const p2 = +m[4] / 100;
    if (m[1] === "hwb") {
      v = hwb2rgb(h3, p1, p2);
    } else if (m[1] === "hsv") {
      v = hsv2rgb(h3, p1, p2);
    } else {
      v = hsl2rgb(h3, p1, p2);
    }
    return {
      r: v[0],
      g: v[1],
      b: v[2],
      a
    };
  }
  function rotate(v, deg) {
    var h3 = rgb2hsl(v);
    h3[0] = hue(h3[0] + deg);
    h3 = hsl2rgb(h3);
    v.r = h3[0];
    v.g = h3[1];
    v.b = h3[2];
  }
  function hslString(v) {
    if (!v) {
      return;
    }
    const a = rgb2hsl(v);
    const h3 = a[0];
    const s = n2p(a[1]);
    const l = n2p(a[2]);
    return v.a < 255 ? `hsla(${h3}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h3}, ${s}%, ${l}%)`;
  }
  var map = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
  };
  var names$1 = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
  };
  function unpack() {
    const unpacked = {};
    const keys = Object.keys(names$1);
    const tkeys = Object.keys(map);
    let i, j2, k, ok, nk;
    for (i = 0; i < keys.length; i++) {
      ok = nk = keys[i];
      for (j2 = 0; j2 < tkeys.length; j2++) {
        k = tkeys[j2];
        nk = nk.replace(k, map[k]);
      }
      k = parseInt(names$1[ok], 16);
      unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
    }
    return unpacked;
  }
  var names;
  function nameParse(str) {
    if (!names) {
      names = unpack();
      names.transparent = [0, 0, 0, 0];
    }
    const a = names[str.toLowerCase()];
    return a && {
      r: a[0],
      g: a[1],
      b: a[2],
      a: a.length === 4 ? a[3] : 255
    };
  }
  var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  function rgbParse(str) {
    const m = RGB_RE.exec(str);
    let a = 255;
    let r, g, b;
    if (!m) {
      return;
    }
    if (m[7] !== r) {
      const v = +m[7];
      a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
    }
    r = +m[1];
    g = +m[3];
    b = +m[5];
    r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
    g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
    b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
    return {
      r,
      g,
      b,
      a
    };
  }
  function rgbString(v) {
    return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
  }
  var to8 = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
  var from16 = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  function interpolate(rgb1, rgb2, t2) {
    const r = from16(b2n(rgb1.r));
    const g = from16(b2n(rgb1.g));
    const b = from16(b2n(rgb1.b));
    return {
      r: n2b(to8(r + t2 * (from16(b2n(rgb2.r)) - r))),
      g: n2b(to8(g + t2 * (from16(b2n(rgb2.g)) - g))),
      b: n2b(to8(b + t2 * (from16(b2n(rgb2.b)) - b))),
      a: rgb1.a + t2 * (rgb2.a - rgb1.a)
    };
  }
  function modHSL(v, i, ratio) {
    if (v) {
      let tmp = rgb2hsl(v);
      tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
      tmp = hsl2rgb(tmp);
      v.r = tmp[0];
      v.g = tmp[1];
      v.b = tmp[2];
    }
  }
  function clone2(v, proto) {
    return v ? Object.assign(proto || {}, v) : v;
  }
  function fromObject(input2) {
    var v = { r: 0, g: 0, b: 0, a: 255 };
    if (Array.isArray(input2)) {
      if (input2.length >= 3) {
        v = { r: input2[0], g: input2[1], b: input2[2], a: 255 };
        if (input2.length > 3) {
          v.a = n2b(input2[3]);
        }
      }
    } else {
      v = clone2(input2, { r: 0, g: 0, b: 0, a: 1 });
      v.a = n2b(v.a);
    }
    return v;
  }
  function functionParse(str) {
    if (str.charAt(0) === "r") {
      return rgbParse(str);
    }
    return hueParse(str);
  }
  var Color = class {
    constructor(input2) {
      if (input2 instanceof Color) {
        return input2;
      }
      const type = typeof input2;
      let v;
      if (type === "object") {
        v = fromObject(input2);
      } else if (type === "string") {
        v = hexParse(input2) || nameParse(input2) || functionParse(input2);
      }
      this._rgb = v;
      this._valid = !!v;
    }
    get valid() {
      return this._valid;
    }
    get rgb() {
      var v = clone2(this._rgb);
      if (v) {
        v.a = b2n(v.a);
      }
      return v;
    }
    set rgb(obj) {
      this._rgb = fromObject(obj);
    }
    rgbString() {
      return this._valid ? rgbString(this._rgb) : void 0;
    }
    hexString() {
      return this._valid ? hexString(this._rgb) : void 0;
    }
    hslString() {
      return this._valid ? hslString(this._rgb) : void 0;
    }
    mix(color19, weight) {
      if (color19) {
        const c1 = this.rgb;
        const c2 = color19.rgb;
        let w2;
        const p = weight === w2 ? 0.5 : weight;
        const w = 2 * p - 1;
        const a = c1.a - c2.a;
        const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        w2 = 1 - w1;
        c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
        c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
        c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
        c1.a = p * c1.a + (1 - p) * c2.a;
        this.rgb = c1;
      }
      return this;
    }
    interpolate(color19, t2) {
      if (color19) {
        this._rgb = interpolate(this._rgb, color19._rgb, t2);
      }
      return this;
    }
    clone() {
      return new Color(this.rgb);
    }
    alpha(a) {
      this._rgb.a = n2b(a);
      return this;
    }
    clearer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 - ratio;
      return this;
    }
    greyscale() {
      const rgb = this._rgb;
      const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
      rgb.r = rgb.g = rgb.b = val;
      return this;
    }
    opaquer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 + ratio;
      return this;
    }
    negate() {
      const v = this._rgb;
      v.r = 255 - v.r;
      v.g = 255 - v.g;
      v.b = 255 - v.b;
      return this;
    }
    lighten(ratio) {
      modHSL(this._rgb, 2, ratio);
      return this;
    }
    darken(ratio) {
      modHSL(this._rgb, 2, -ratio);
      return this;
    }
    saturate(ratio) {
      modHSL(this._rgb, 1, ratio);
      return this;
    }
    desaturate(ratio) {
      modHSL(this._rgb, 1, -ratio);
      return this;
    }
    rotate(deg) {
      rotate(this._rgb, deg);
      return this;
    }
  };
  function index_esm(input2) {
    return new Color(input2);
  }
  function isPatternOrGradient(value) {
    if (value && typeof value === "object") {
      const type = value.toString();
      return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
    }
    return false;
  }
  function color18(value) {
    return isPatternOrGradient(value) ? value : index_esm(value);
  }
  function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
  }
  var overrides2 = Object.create(null);
  var descriptors = Object.create(null);
  function getScope$1(node, key) {
    if (!key) {
      return node;
    }
    const keys = key.split(".");
    for (let i = 0, n = keys.length; i < n; ++i) {
      const k = keys[i];
      node = node[k] || (node[k] = Object.create(null));
    }
    return node;
  }
  function set(root, scope, values) {
    if (typeof scope === "string") {
      return merge(getScope$1(root, scope), values);
    }
    return merge(getScope$1(root, ""), scope);
  }
  var Defaults = class {
    constructor(_descriptors2) {
      this.animation = void 0;
      this.backgroundColor = "rgba(0,0,0,0.1)";
      this.borderColor = "rgba(0,0,0,0.1)";
      this.color = "#666";
      this.datasets = {};
      this.devicePixelRatio = (context2) => context2.chart.platform.getDevicePixelRatio();
      this.elements = {};
      this.events = [
        "mousemove",
        "mouseout",
        "click",
        "touchstart",
        "touchmove"
      ];
      this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      };
      this.hover = {};
      this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
      this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
      this.hoverColor = (ctx, options) => getHoverColor(options.color);
      this.indexAxis = "x";
      this.interaction = {
        mode: "nearest",
        intersect: true,
        includeInvisible: false
      };
      this.maintainAspectRatio = true;
      this.onHover = null;
      this.onClick = null;
      this.parsing = true;
      this.plugins = {};
      this.responsive = true;
      this.scale = void 0;
      this.scales = {};
      this.showLine = true;
      this.drawActiveElementsOnTop = true;
      this.describe(_descriptors2);
    }
    set(scope, values) {
      return set(this, scope, values);
    }
    get(scope) {
      return getScope$1(this, scope);
    }
    describe(scope, values) {
      return set(descriptors, scope, values);
    }
    override(scope, values) {
      return set(overrides2, scope, values);
    }
    route(scope, name2, targetScope, targetName) {
      const scopeObject = getScope$1(this, scope);
      const targetScopeObject = getScope$1(this, targetScope);
      const privateName = "_" + name2;
      Object.defineProperties(scopeObject, {
        [privateName]: {
          value: scopeObject[name2],
          writable: true
        },
        [name2]: {
          enumerable: true,
          get() {
            const local = this[privateName];
            const target = targetScopeObject[targetName];
            if (isObject2(local)) {
              return Object.assign({}, target, local);
            }
            return valueOrDefault(local, target);
          },
          set(value) {
            this[privateName] = value;
          }
        }
      });
    }
  };
  var defaults3 = new Defaults({
    _scriptable: (name2) => !name2.startsWith("on"),
    _indexable: (name2) => name2 !== "events",
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: false,
      _indexable: false
    }
  });
  function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
      return null;
    }
    return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
  }
  function _measureText(ctx, data, gc2, longest, string2) {
    let textWidth = data[string2];
    if (!textWidth) {
      textWidth = data[string2] = ctx.measureText(string2).width;
      gc2.push(string2);
    }
    if (textWidth > longest) {
      longest = textWidth;
    }
    return longest;
  }
  function _longestText(ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    let data = cache.data = cache.data || {};
    let gc2 = cache.garbageCollect = cache.garbageCollect || [];
    if (cache.font !== font) {
      data = cache.data = {};
      gc2 = cache.garbageCollect = [];
      cache.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i, j2, jlen, thing, nestedThing;
    for (i = 0; i < ilen; i++) {
      thing = arrayOfThings[i];
      if (thing !== void 0 && thing !== null && isArray2(thing) !== true) {
        longest = _measureText(ctx, data, gc2, longest, thing);
      } else if (isArray2(thing)) {
        for (j2 = 0, jlen = thing.length; j2 < jlen; j2++) {
          nestedThing = thing[j2];
          if (nestedThing !== void 0 && nestedThing !== null && !isArray2(nestedThing)) {
            longest = _measureText(ctx, data, gc2, longest, nestedThing);
          }
        }
      }
    }
    ctx.restore();
    const gcLen = gc2.length / 2;
    if (gcLen > arrayOfThings.length) {
      for (i = 0; i < gcLen; i++) {
        delete data[gc2[i]];
      }
      gc2.splice(0, gcLen);
    }
    return longest;
  }
  function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
  }
  function clearCanvas(canvas, ctx) {
    ctx = ctx || canvas.getContext("2d");
    ctx.save();
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  function drawPoint(ctx, options, x, y2) {
    drawPointLegend(ctx, options, x, y2, null);
  }
  function drawPointLegend(ctx, options, x, y2, w) {
    let type, xOffset, yOffset, size, cornerRadius, width;
    const style = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === "object") {
      type = style.toString();
      if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
        ctx.save();
        ctx.translate(x, y2);
        ctx.rotate(rad);
        ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
        ctx.restore();
        return;
      }
    }
    if (isNaN(radius) || radius <= 0) {
      return;
    }
    ctx.beginPath();
    switch (style) {
      default:
        if (w) {
          ctx.ellipse(x, y2, w / 2, radius, 0, 0, TAU);
        } else {
          ctx.arc(x, y2, radius, 0, TAU);
        }
        ctx.closePath();
        break;
      case "triangle":
        ctx.moveTo(x + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
        ctx.closePath();
        break;
      case "rectRounded":
        cornerRadius = radius * 0.516;
        size = radius - cornerRadius;
        xOffset = Math.cos(rad + QUARTER_PI) * size;
        yOffset = Math.sin(rad + QUARTER_PI) * size;
        ctx.arc(x - xOffset, y2 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
        ctx.arc(x + yOffset, y2 - xOffset, cornerRadius, rad - HALF_PI, rad);
        ctx.arc(x + xOffset, y2 + yOffset, cornerRadius, rad, rad + HALF_PI);
        ctx.arc(x - yOffset, y2 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
        ctx.closePath();
        break;
      case "rect":
        if (!rotation) {
          size = Math.SQRT1_2 * radius;
          width = w ? w / 2 : size;
          ctx.rect(x - width, y2 - size, 2 * width, 2 * size);
          break;
        }
        rad += QUARTER_PI;
      case "rectRot":
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y2 - yOffset);
        ctx.lineTo(x + yOffset, y2 - xOffset);
        ctx.lineTo(x + xOffset, y2 + yOffset);
        ctx.lineTo(x - yOffset, y2 + xOffset);
        ctx.closePath();
        break;
      case "crossRot":
        rad += QUARTER_PI;
      case "cross":
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y2 - yOffset);
        ctx.lineTo(x + xOffset, y2 + yOffset);
        ctx.moveTo(x + yOffset, y2 - xOffset);
        ctx.lineTo(x - yOffset, y2 + xOffset);
        break;
      case "star":
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y2 - yOffset);
        ctx.lineTo(x + xOffset, y2 + yOffset);
        ctx.moveTo(x + yOffset, y2 - xOffset);
        ctx.lineTo(x - yOffset, y2 + xOffset);
        rad += QUARTER_PI;
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y2 - yOffset);
        ctx.lineTo(x + xOffset, y2 + yOffset);
        ctx.moveTo(x + yOffset, y2 - xOffset);
        ctx.lineTo(x - yOffset, y2 + xOffset);
        break;
      case "line":
        xOffset = w ? w / 2 : Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y2 - yOffset);
        ctx.lineTo(x + xOffset, y2 + yOffset);
        break;
      case "dash":
        ctx.moveTo(x, y2);
        ctx.lineTo(x + Math.cos(rad) * radius, y2 + Math.sin(rad) * radius);
        break;
    }
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  function _isPointInArea(point, area, margin) {
    margin = margin || 0.5;
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
  }
  function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
  }
  function unclipArea(ctx) {
    ctx.restore();
  }
  function _steppedLineTo(ctx, previous, target, flip, mode) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    if (mode === "middle") {
      const midpoint = (previous.x + target.x) / 2;
      ctx.lineTo(midpoint, previous.y);
      ctx.lineTo(midpoint, target.y);
    } else if (mode === "after" !== !!flip) {
      ctx.lineTo(previous.x, target.y);
    } else {
      ctx.lineTo(target.x, previous.y);
    }
    ctx.lineTo(target.x, target.y);
  }
  function _bezierCurveTo(ctx, previous, target, flip) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
  }
  function renderText(ctx, text, x, y2, font, opts = {}) {
    const lines = isArray2(text) ? text : [text];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
    let i, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for (i = 0; i < lines.length; ++i) {
      line = lines[i];
      if (stroke) {
        if (opts.strokeColor) {
          ctx.strokeStyle = opts.strokeColor;
        }
        if (!isNullOrUndef(opts.strokeWidth)) {
          ctx.lineWidth = opts.strokeWidth;
        }
        ctx.strokeText(line, x, y2, opts.maxWidth);
      }
      ctx.fillText(line, x, y2, opts.maxWidth);
      decorateText(ctx, x, y2, line, opts);
      y2 += font.lineHeight;
    }
    ctx.restore();
  }
  function setRenderOpts(ctx, opts) {
    if (opts.translation) {
      ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
      ctx.rotate(opts.rotation);
    }
    if (opts.color) {
      ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
      ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
      ctx.textBaseline = opts.textBaseline;
    }
  }
  function decorateText(ctx, x, y2, line, opts) {
    if (opts.strikethrough || opts.underline) {
      const metrics = ctx.measureText(line);
      const left = x - metrics.actualBoundingBoxLeft;
      const right = x + metrics.actualBoundingBoxRight;
      const top2 = y2 - metrics.actualBoundingBoxAscent;
      const bottom = y2 + metrics.actualBoundingBoxDescent;
      const yDecoration = opts.strikethrough ? (top2 + bottom) / 2 : bottom;
      ctx.strokeStyle = ctx.fillStyle;
      ctx.beginPath();
      ctx.lineWidth = opts.decorationWidth || 2;
      ctx.moveTo(left, yDecoration);
      ctx.lineTo(right, yDecoration);
      ctx.stroke();
    }
  }
  function addRoundedRectPath(ctx, rect) {
    const { x, y: y2, w, h: h3, radius } = rect;
    ctx.arc(x + radius.topLeft, y2 + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
    ctx.lineTo(x, y2 + h3 - radius.bottomLeft);
    ctx.arc(x + radius.bottomLeft, y2 + h3 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    ctx.lineTo(x + w - radius.bottomRight, y2 + h3);
    ctx.arc(x + w - radius.bottomRight, y2 + h3 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    ctx.lineTo(x + w, y2 + radius.topRight);
    ctx.arc(x + w - radius.topRight, y2 + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    ctx.lineTo(x + radius.topLeft, y2);
  }
  var LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
  var FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
  function toLineHeight(value, size) {
    const matches2 = ("" + value).match(LINE_HEIGHT);
    if (!matches2 || matches2[1] === "normal") {
      return size * 1.2;
    }
    value = +matches2[2];
    switch (matches2[3]) {
      case "px":
        return value;
      case "%":
        value /= 100;
        break;
    }
    return size * value;
  }
  var numberOrZero = (v) => +v || 0;
  function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject2(props);
    const keys = objProps ? Object.keys(props) : props;
    const read = isObject2(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
    for (const prop of keys) {
      ret[prop] = numberOrZero(read(prop));
    }
    return ret;
  }
  function toTRBL(value) {
    return _readValueToProps(value, { top: "y", right: "x", bottom: "y", left: "x" });
  }
  function toTRBLCorners(value) {
    return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
  }
  function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
  }
  function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults3.font;
    let size = valueOrDefault(options.size, fallback.size);
    if (typeof size === "string") {
      size = parseInt(size, 10);
    }
    let style = valueOrDefault(options.style, fallback.style);
    if (style && !("" + style).match(FONT_STYLE)) {
      console.warn('Invalid font style specified: "' + style + '"');
      style = "";
    }
    const font = {
      family: valueOrDefault(options.family, fallback.family),
      lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
      size,
      style,
      weight: valueOrDefault(options.weight, fallback.weight),
      string: ""
    };
    font.string = toFontString(font);
    return font;
  }
  function resolve(inputs, context2, index3, info) {
    let cacheable = true;
    let i, ilen, value;
    for (i = 0, ilen = inputs.length; i < ilen; ++i) {
      value = inputs[i];
      if (value === void 0) {
        continue;
      }
      if (context2 !== void 0 && typeof value === "function") {
        value = value(context2);
        cacheable = false;
      }
      if (index3 !== void 0 && isArray2(value)) {
        value = value[index3 % value.length];
        cacheable = false;
      }
      if (value !== void 0) {
        if (info && !cacheable) {
          info.cacheable = false;
        }
        return value;
      }
    }
  }
  function _addGrace(minmax, grace, beginAtZero) {
    const { min, max } = minmax;
    const change = toDimension(grace, (max - min) / 2);
    const keepZero = (value, add17) => beginAtZero && value === 0 ? 0 : value + add17;
    return {
      min: keepZero(min, -Math.abs(change)),
      max: keepZero(max, change)
    };
  }
  function createContext(parentContext, context2) {
    return Object.assign(Object.create(parentContext), context2);
  }
  function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
    if (!defined(fallback)) {
      fallback = _resolve("_fallback", scopes);
    }
    const cache = {
      [Symbol.toStringTag]: "Object",
      _cacheable: true,
      _scopes: scopes,
      _rootScopes: rootScopes,
      _fallback: fallback,
      _getTarget: getTarget,
      override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
    };
    return new Proxy(cache, {
      deleteProperty(target, prop) {
        delete target[prop];
        delete target._keys;
        delete scopes[0][prop];
        return true;
      },
      get(target, prop) {
        return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
      },
      getOwnPropertyDescriptor(target, prop) {
        return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
      },
      getPrototypeOf() {
        return Reflect.getPrototypeOf(scopes[0]);
      },
      has(target, prop) {
        return getKeysFromAllScopes(target).includes(prop);
      },
      ownKeys(target) {
        return getKeysFromAllScopes(target);
      },
      set(target, prop, value) {
        const storage = target._storage || (target._storage = getTarget());
        target[prop] = storage[prop] = value;
        delete target._keys;
        return true;
      }
    });
  }
  function _attachContext(proxy, context2, subProxy, descriptorDefaults) {
    const cache = {
      _cacheable: false,
      _proxy: proxy,
      _context: context2,
      _subProxy: subProxy,
      _stack: new Set(),
      _descriptors: _descriptors(proxy, descriptorDefaults),
      setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
      override: (scope) => _attachContext(proxy.override(scope), context2, subProxy, descriptorDefaults)
    };
    return new Proxy(cache, {
      deleteProperty(target, prop) {
        delete target[prop];
        delete proxy[prop];
        return true;
      },
      get(target, prop, receiver) {
        return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
      },
      getOwnPropertyDescriptor(target, prop) {
        return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
      },
      getPrototypeOf() {
        return Reflect.getPrototypeOf(proxy);
      },
      has(target, prop) {
        return Reflect.has(proxy, prop);
      },
      ownKeys() {
        return Reflect.ownKeys(proxy);
      },
      set(target, prop, value) {
        proxy[prop] = value;
        delete target[prop];
        return true;
      }
    });
  }
  function _descriptors(proxy, defaults4 = { scriptable: true, indexable: true }) {
    const { _scriptable = defaults4.scriptable, _indexable = defaults4.indexable, _allKeys = defaults4.allKeys } = proxy;
    return {
      allKeys: _allKeys,
      scriptable: _scriptable,
      indexable: _indexable,
      isScriptable: isFunction2(_scriptable) ? _scriptable : () => _scriptable,
      isIndexable: isFunction2(_indexable) ? _indexable : () => _indexable
    };
  }
  var readKey = (prefix, name2) => prefix ? prefix + _capitalize(name2) : name2;
  var needsSubResolver = (prop, value) => isObject2(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
  function _cached(target, prop, resolve2) {
    if (Object.prototype.hasOwnProperty.call(target, prop)) {
      return target[prop];
    }
    const value = resolve2();
    target[prop] = value;
    return value;
  }
  function _resolveWithContext(target, prop, receiver) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    let value = _proxy[prop];
    if (isFunction2(value) && descriptors2.isScriptable(prop)) {
      value = _resolveScriptable(prop, value, target, receiver);
    }
    if (isArray2(value) && value.length) {
      value = _resolveArray(prop, value, target, descriptors2.isIndexable);
    }
    if (needsSubResolver(prop, value)) {
      value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
    }
    return value;
  }
  function _resolveScriptable(prop, value, target, receiver) {
    const { _proxy, _context, _subProxy, _stack } = target;
    if (_stack.has(prop)) {
      throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
    }
    _stack.add(prop);
    value = value(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) {
      value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    }
    return value;
  }
  function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    if (defined(_context.index) && isIndexable(prop)) {
      value = value[_context.index % value.length];
    } else if (isObject2(value[0])) {
      const arr = value;
      const scopes = _proxy._scopes.filter((s) => s !== arr);
      value = [];
      for (const item of arr) {
        const resolver = createSubResolver(scopes, _proxy, prop, item);
        value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
      }
    }
    return value;
  }
  function resolveFallback(fallback, prop, value) {
    return isFunction2(fallback) ? fallback(prop, value) : fallback;
  }
  var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
  function addScopes(set2, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes) {
      const scope = getScope(key, parent);
      if (scope) {
        set2.add(scope);
        const fallback = resolveFallback(scope._fallback, key, value);
        if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
          return fallback;
        }
      } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
        return null;
      }
    }
    return false;
  }
  function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [...parentScopes, ...rootScopes];
    const set2 = new Set();
    set2.add(value);
    let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
    if (key === null) {
      return false;
    }
    if (defined(fallback) && fallback !== prop) {
      key = addScopesFromKey(set2, allScopes, fallback, key, value);
      if (key === null) {
        return false;
      }
    }
    return _createResolver(Array.from(set2), [""], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
  }
  function addScopesFromKey(set2, allScopes, key, fallback, item) {
    while (key) {
      key = addScopes(set2, allScopes, key, fallback, item);
    }
    return key;
  }
  function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
      parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray2(target) && isObject2(value)) {
      return value;
    }
    return target;
  }
  function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix of prefixes) {
      value = _resolve(readKey(prefix, prop), scopes);
      if (defined(value)) {
        return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
      }
    }
  }
  function _resolve(key, scopes) {
    for (const scope of scopes) {
      if (!scope) {
        continue;
      }
      const value = scope[key];
      if (defined(value)) {
        return value;
      }
    }
  }
  function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) {
      keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys;
  }
  function resolveKeysFromAllScopes(scopes) {
    const set2 = new Set();
    for (const scope of scopes) {
      for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
        set2.add(key);
      }
    }
    return Array.from(set2);
  }
  function _parseObjectDataRadialScale(meta2, data, start2, count) {
    const { iScale } = meta2;
    const { key = "r" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index3, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index3 = i + start2;
      item = data[index3];
      parsed[i] = {
        r: iScale.parse(resolveObjectKey(item, key), index3)
      };
    }
    return parsed;
  }
  var EPSILON2 = Number.EPSILON || 1e-14;
  var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
  var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
  function splineCurve(firstPoint, middlePoint, afterPoint, t2) {
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa2 = t2 * s01;
    const fb2 = t2 * s12;
    return {
      previous: {
        x: current.x - fa2 * (next.x - previous.x),
        y: current.y - fa2 * (next.y - previous.y)
      },
      next: {
        x: current.x + fb2 * (next.x - previous.x),
        y: current.y + fb2 * (next.y - previous.y)
      }
    };
  }
  function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i = 0; i < pointsLen - 1; ++i) {
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent || !pointAfter) {
        continue;
      }
      if (almostEquals(deltaK[i], 0, EPSILON2)) {
        mK[i] = mK[i + 1] = 0;
        continue;
      }
      alphaK = mK[i] / deltaK[i];
      betaK = mK[i + 1] / deltaK[i];
      squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
      if (squaredMagnitude <= 9) {
        continue;
      }
      tauK = 3 / Math.sqrt(squaredMagnitude);
      mK[i] = alphaK * tauK * deltaK[i];
      mK[i + 1] = betaK * tauK * deltaK[i];
    }
  }
  function monotoneCompute(points, mK, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i = 0; i < pointsLen; ++i) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent) {
        continue;
      }
      const iPixel = pointCurrent[indexAxis];
      const vPixel = pointCurrent[valueAxis];
      if (pointBefore) {
        delta = (iPixel - pointBefore[indexAxis]) / 3;
        pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
        pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
      }
      if (pointAfter) {
        delta = (pointAfter[indexAxis] - iPixel) / 3;
        pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
        pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
      }
    }
  }
  function splineCurveMonotone(points, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    let i, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (i = 0; i < pointsLen; ++i) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent) {
        continue;
      }
      if (pointAfter) {
        const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
        deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
      }
      mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
  }
  function capControlPoint(pt2, min, max) {
    return Math.max(Math.min(pt2, max), min);
  }
  function capBezierPoints(points, area) {
    let i, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      inAreaPrev = inArea;
      inArea = inAreaNext;
      inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
      if (!inArea) {
        continue;
      }
      point = points[i];
      if (inAreaPrev) {
        point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
        point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
      }
      if (inAreaNext) {
        point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
        point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
      }
    }
  }
  function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
    let i, ilen, point, controlPoints;
    if (options.spanGaps) {
      points = points.filter((pt2) => !pt2.skip);
    }
    if (options.cubicInterpolationMode === "monotone") {
      splineCurveMonotone(points, indexAxis);
    } else {
      let prev = loop ? points[points.length - 1] : points[0];
      for (i = 0, ilen = points.length; i < ilen; ++i) {
        point = points[i];
        controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
        point.cp1x = controlPoints.previous.x;
        point.cp1y = controlPoints.previous.y;
        point.cp2x = controlPoints.next.x;
        point.cp2y = controlPoints.next.y;
        prev = point;
      }
    }
    if (options.capBezierPoints) {
      capBezierPoints(points, area);
    }
  }
  function _isDomSupported() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === "[object ShadowRoot]") {
      parent = parent.host;
    }
    return parent;
  }
  function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === "string") {
      valueInPixels = parseInt(styleValue, 10);
      if (styleValue.indexOf("%") !== -1) {
        valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
      }
    } else {
      valueInPixels = styleValue;
    }
    return valueInPixels;
  }
  var getComputedStyle2 = (element) => window.getComputedStyle(element, null);
  function getStyle(el3, property) {
    return getComputedStyle2(el3).getPropertyValue(property);
  }
  var positions = ["top", "right", "bottom", "left"];
  function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? "-" + suffix : "";
    for (let i = 0; i < 4; i++) {
      const pos = positions[i];
      result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
  }
  var useOffsetPos = (x, y2, target) => (x > 0 || y2 > 0) && (!target || !target.shadowRoot);
  function getCanvasPosition(e, canvas) {
    const touches = e.touches;
    const source = touches && touches.length ? touches[0] : e;
    const { offsetX, offsetY } = source;
    let box = false;
    let x, y2;
    if (useOffsetPos(offsetX, offsetY, e.target)) {
      x = offsetX;
      y2 = offsetY;
    } else {
      const rect = canvas.getBoundingClientRect();
      x = source.clientX - rect.left;
      y2 = source.clientY - rect.top;
      box = true;
    }
    return { x, y: y2, box };
  }
  function getRelativePosition(evt, chart) {
    if ("native" in evt) {
      return evt;
    }
    const { canvas, currentDevicePixelRatio } = chart;
    const style = getComputedStyle2(canvas);
    const borderBox = style.boxSizing === "border-box";
    const paddings = getPositionedStyle(style, "padding");
    const borders = getPositionedStyle(style, "border", "width");
    const { x, y: y2, box } = getCanvasPosition(evt, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width, height } = chart;
    if (borderBox) {
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    return {
      x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
      y: Math.round((y2 - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
  }
  function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === void 0 || height === void 0) {
      const container = _getParentNode(canvas);
      if (!container) {
        width = canvas.clientWidth;
        height = canvas.clientHeight;
      } else {
        const rect = container.getBoundingClientRect();
        const containerStyle = getComputedStyle2(container);
        const containerBorder = getPositionedStyle(containerStyle, "border", "width");
        const containerPadding = getPositionedStyle(containerStyle, "padding");
        width = rect.width - containerPadding.width - containerBorder.width;
        height = rect.height - containerPadding.height - containerBorder.height;
        maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
        maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
      }
    }
    return {
      width,
      height,
      maxWidth: maxWidth || INFINITY,
      maxHeight: maxHeight || INFINITY
    };
  }
  var round1 = (v) => Math.round(v * 10) / 10;
  function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle2(canvas);
    const margins = getPositionedStyle(style, "margin");
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width, height } = containerSize;
    if (style.boxSizing === "content-box") {
      const borders = getPositionedStyle(style, "border", "width");
      const paddings = getPositionedStyle(style, "padding");
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
      height = round1(width / 2);
    }
    return {
      width,
      height
    };
  }
  function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = deviceHeight / pixelRatio;
    chart.width = deviceWidth / pixelRatio;
    const canvas = chart.canvas;
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
      canvas.style.height = `${chart.height}px`;
      canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
      chart.currentDevicePixelRatio = pixelRatio;
      canvas.height = deviceHeight;
      canvas.width = deviceWidth;
      chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      return true;
    }
    return false;
  }
  var supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
      const options = {
        get passive() {
          passiveSupported = true;
          return false;
        }
      };
      window.addEventListener("test", null, options);
      window.removeEventListener("test", null, options);
    } catch (e) {
    }
    return passiveSupported;
  }();
  function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches2 = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches2 ? +matches2[1] : void 0;
  }
  function _pointInLine(p1, p2, t2, mode) {
    return {
      x: p1.x + t2 * (p2.x - p1.x),
      y: p1.y + t2 * (p2.y - p1.y)
    };
  }
  function _steppedInterpolation(p1, p2, t2, mode) {
    return {
      x: p1.x + t2 * (p2.x - p1.x),
      y: mode === "middle" ? t2 < 0.5 ? p1.y : p2.y : mode === "after" ? t2 < 1 ? p1.y : p2.y : t2 > 0 ? p2.y : p1.y
    };
  }
  function _bezierInterpolation(p1, p2, t2, mode) {
    const cp1 = { x: p1.cp2x, y: p1.cp2y };
    const cp2 = { x: p2.cp1x, y: p2.cp1y };
    const a = _pointInLine(p1, cp1, t2);
    const b = _pointInLine(cp1, cp2, t2);
    const c2 = _pointInLine(cp2, p2, t2);
    const d2 = _pointInLine(a, b, t2);
    const e = _pointInLine(b, c2, t2);
    return _pointInLine(d2, e, t2);
  }
  var intlCache = new Map();
  function getNumberFormat(locale, options) {
    options = options || {};
    const cacheKey = locale + JSON.stringify(options);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
      formatter = new Intl.NumberFormat(locale, options);
      intlCache.set(cacheKey, formatter);
    }
    return formatter;
  }
  function formatNumber2(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
  }
  var getRightToLeftAdapter = function(rectX, width) {
    return {
      x(x) {
        return rectX + rectX + width - x;
      },
      setWidth(w) {
        width = w;
      },
      textAlign(align) {
        if (align === "center") {
          return align;
        }
        return align === "right" ? "left" : "right";
      },
      xPlus(x, value) {
        return x - value;
      },
      leftForLtr(x, itemWidth) {
        return x - itemWidth;
      }
    };
  };
  var getLeftToRightAdapter = function() {
    return {
      x(x) {
        return x;
      },
      setWidth(w) {
      },
      textAlign(align) {
        return align;
      },
      xPlus(x, value) {
        return x + value;
      },
      leftForLtr(x, _itemWidth) {
        return x;
      }
    };
  };
  function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
  }
  function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === "ltr" || direction === "rtl") {
      style = ctx.canvas.style;
      original = [
        style.getPropertyValue("direction"),
        style.getPropertyPriority("direction")
      ];
      style.setProperty("direction", direction, "important");
      ctx.prevTextDirection = original;
    }
  }
  function restoreTextDirection(ctx, original) {
    if (original !== void 0) {
      delete ctx.prevTextDirection;
      ctx.canvas.style.setProperty("direction", original[0], original[1]);
    }
  }
  function propertyFn(property) {
    if (property === "angle") {
      return {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle
      };
    }
    return {
      between: _isBetween,
      compare: (a, b) => a - b,
      normalize: (x) => x
    };
  }
  function normalizeSegment({ start: start2, end, count, loop, style }) {
    return {
      start: start2 % count,
      end: end % count,
      loop: loop && (end - start2 + 1) % count === 0,
      style
    };
  }
  function getSegment(segment, points, bounds) {
    const { property, start: startBound, end: endBound } = bounds;
    const { between, normalize } = propertyFn(property);
    const count = points.length;
    let { start: start2, end, loop } = segment;
    let i, ilen;
    if (loop) {
      start2 += count;
      end += count;
      for (i = 0, ilen = count; i < ilen; ++i) {
        if (!between(normalize(points[start2 % count][property]), startBound, endBound)) {
          break;
        }
        start2--;
        end--;
      }
      start2 %= count;
      end %= count;
    }
    if (end < start2) {
      end += count;
    }
    return { start: start2, end, loop, style: segment.style };
  }
  function _boundSegment(segment, points, bounds) {
    if (!bounds) {
      return [segment];
    }
    const { property, start: startBound, end: endBound } = bounds;
    const count = points.length;
    const { compare: compare2, between, normalize } = propertyFn(property);
    const { start: start2, end, loop, style } = getSegment(segment, points, bounds);
    const result = [];
    let inside2 = false;
    let subStart = null;
    let value, point, prevValue;
    const startIsBefore = () => between(startBound, prevValue, value) && compare2(startBound, prevValue) !== 0;
    const endIsBefore = () => compare2(endBound, value) === 0 || between(endBound, prevValue, value);
    const shouldStart = () => inside2 || startIsBefore();
    const shouldStop = () => !inside2 || endIsBefore();
    for (let i = start2, prev = start2; i <= end; ++i) {
      point = points[i % count];
      if (point.skip) {
        continue;
      }
      value = normalize(point[property]);
      if (value === prevValue) {
        continue;
      }
      inside2 = between(value, startBound, endBound);
      if (subStart === null && shouldStart()) {
        subStart = compare2(value, startBound) === 0 ? i : prev;
      }
      if (subStart !== null && shouldStop()) {
        result.push(normalizeSegment({ start: subStart, end: i, loop, count, style }));
        subStart = null;
      }
      prev = i;
      prevValue = value;
    }
    if (subStart !== null) {
      result.push(normalizeSegment({ start: subStart, end, loop, count, style }));
    }
    return result;
  }
  function _boundSegments(line, bounds) {
    const result = [];
    const segments = line.segments;
    for (let i = 0; i < segments.length; i++) {
      const sub = _boundSegment(segments[i], line.points, bounds);
      if (sub.length) {
        result.push(...sub);
      }
    }
    return result;
  }
  function findStartAndEnd(points, count, loop, spanGaps) {
    let start2 = 0;
    let end = count - 1;
    if (loop && !spanGaps) {
      while (start2 < count && !points[start2].skip) {
        start2++;
      }
    }
    while (start2 < count && points[start2].skip) {
      start2++;
    }
    start2 %= count;
    if (loop) {
      end += start2;
    }
    while (end > start2 && points[end % count].skip) {
      end--;
    }
    end %= count;
    return { start: start2, end };
  }
  function solidSegments(points, start2, max, loop) {
    const count = points.length;
    const result = [];
    let last = start2;
    let prev = points[start2];
    let end;
    for (end = start2 + 1; end <= max; ++end) {
      const cur = points[end % count];
      if (cur.skip || cur.stop) {
        if (!prev.skip) {
          loop = false;
          result.push({ start: start2 % count, end: (end - 1) % count, loop });
          start2 = last = cur.stop ? end : null;
        }
      } else {
        last = end;
        if (prev.skip) {
          start2 = end;
        }
      }
      prev = cur;
    }
    if (last !== null) {
      result.push({ start: start2 % count, end: last % count, loop });
    }
    return result;
  }
  function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) {
      return [];
    }
    const loop = !!line._loop;
    const { start: start2, end } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) {
      return splitByStyles(line, [{ start: start2, end, loop }], points, segmentOptions);
    }
    const max = end < start2 ? end + count : end;
    const completeLoop = !!line._fullLoop && start2 === 0 && end === count - 1;
    return splitByStyles(line, solidSegments(points, start2, max, completeLoop), points, segmentOptions);
  }
  function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) {
      return segments;
    }
    return doSplitByStyles(line, segments, points, segmentOptions);
  }
  function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start2 = segments[0].start;
    let i = start2;
    function addStyle(s, e, l, st2) {
      const dir = spanGaps ? -1 : 1;
      if (s === e) {
        return;
      }
      s += count;
      while (points[s % count].skip) {
        s -= dir;
      }
      while (points[e % count].skip) {
        e += dir;
      }
      if (s % count !== e % count) {
        result.push({ start: s % count, end: e % count, loop: l, style: st2 });
        prevStyle = st2;
        start2 = e % count;
      }
    }
    for (const segment of segments) {
      start2 = spanGaps ? start2 : segment.start;
      let prev = points[start2 % count];
      let style;
      for (i = start2 + 1; i <= segment.end; i++) {
        const pt2 = points[i % count];
        style = readStyle(segmentOptions.setContext(createContext(chartContext, {
          type: "segment",
          p0: prev,
          p1: pt2,
          p0DataIndex: (i - 1) % count,
          p1DataIndex: i % count,
          datasetIndex
        })));
        if (styleChanged(style, prevStyle)) {
          addStyle(start2, i - 1, segment.loop, prevStyle);
        }
        prev = pt2;
        prevStyle = style;
      }
      if (start2 < i - 1) {
        addStyle(start2, i - 1, segment.loop, prevStyle);
      }
    }
    return result;
  }
  function readStyle(options) {
    return {
      backgroundColor: options.backgroundColor,
      borderCapStyle: options.borderCapStyle,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderJoinStyle: options.borderJoinStyle,
      borderWidth: options.borderWidth,
      borderColor: options.borderColor
    };
  }
  function styleChanged(style, prevStyle) {
    return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
  }

  // node_modules/chart.js/dist/chart.mjs
  var Animator = class {
    constructor() {
      this._request = null;
      this._charts = new Map();
      this._running = false;
      this._lastDate = void 0;
    }
    _notify(chart, anims, date, type) {
      const callbacks = anims.listeners[type];
      const numSteps = anims.duration;
      callbacks.forEach((fn2) => fn2({
        chart,
        initial: anims.initial,
        numSteps,
        currentStep: Math.min(date - anims.start, numSteps)
      }));
    }
    _refresh() {
      if (this._request) {
        return;
      }
      this._running = true;
      this._request = requestAnimFrame.call(window, () => {
        this._update();
        this._request = null;
        if (this._running) {
          this._refresh();
        }
      });
    }
    _update(date = Date.now()) {
      let remaining = 0;
      this._charts.forEach((anims, chart) => {
        if (!anims.running || !anims.items.length) {
          return;
        }
        const items = anims.items;
        let i = items.length - 1;
        let draw2 = false;
        let item;
        for (; i >= 0; --i) {
          item = items[i];
          if (item._active) {
            if (item._total > anims.duration) {
              anims.duration = item._total;
            }
            item.tick(date);
            draw2 = true;
          } else {
            items[i] = items[items.length - 1];
            items.pop();
          }
        }
        if (draw2) {
          chart.draw();
          this._notify(chart, anims, date, "progress");
        }
        if (!items.length) {
          anims.running = false;
          this._notify(chart, anims, date, "complete");
          anims.initial = false;
        }
        remaining += items.length;
      });
      this._lastDate = date;
      if (remaining === 0) {
        this._running = false;
      }
    }
    _getAnims(chart) {
      const charts = this._charts;
      let anims = charts.get(chart);
      if (!anims) {
        anims = {
          running: false,
          initial: true,
          items: [],
          listeners: {
            complete: [],
            progress: []
          }
        };
        charts.set(chart, anims);
      }
      return anims;
    }
    listen(chart, event2, cb2) {
      this._getAnims(chart).listeners[event2].push(cb2);
    }
    add(chart, items) {
      if (!items || !items.length) {
        return;
      }
      this._getAnims(chart).items.push(...items);
    }
    has(chart) {
      return this._getAnims(chart).items.length > 0;
    }
    start(chart) {
      const anims = this._charts.get(chart);
      if (!anims) {
        return;
      }
      anims.running = true;
      anims.start = Date.now();
      anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
      this._refresh();
    }
    running(chart) {
      if (!this._running) {
        return false;
      }
      const anims = this._charts.get(chart);
      if (!anims || !anims.running || !anims.items.length) {
        return false;
      }
      return true;
    }
    stop(chart) {
      const anims = this._charts.get(chart);
      if (!anims || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      for (; i >= 0; --i) {
        items[i].cancel();
      }
      anims.items = [];
      this._notify(chart, anims, Date.now(), "complete");
    }
    remove(chart) {
      return this._charts.delete(chart);
    }
  };
  var animator = new Animator();
  var transparent = "transparent";
  var interpolators = {
    boolean(from17, to10, factor) {
      return factor > 0.5 ? to10 : from17;
    },
    color(from17, to10, factor) {
      const c0 = color18(from17 || transparent);
      const c1 = c0.valid && color18(to10 || transparent);
      return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to10;
    },
    number(from17, to10, factor) {
      return from17 + (to10 - from17) * factor;
    }
  };
  var Animation = class {
    constructor(cfg, target, prop, to10) {
      const currentValue = target[prop];
      to10 = resolve([cfg.to, to10, currentValue, cfg.from]);
      const from17 = resolve([cfg.from, currentValue, to10]);
      this._active = true;
      this._fn = cfg.fn || interpolators[cfg.type || typeof from17];
      this._easing = effects[cfg.easing] || effects.linear;
      this._start = Math.floor(Date.now() + (cfg.delay || 0));
      this._duration = this._total = Math.floor(cfg.duration);
      this._loop = !!cfg.loop;
      this._target = target;
      this._prop = prop;
      this._from = from17;
      this._to = to10;
      this._promises = void 0;
    }
    active() {
      return this._active;
    }
    update(cfg, to10, date) {
      if (this._active) {
        this._notify(false);
        const currentValue = this._target[this._prop];
        const elapsed = date - this._start;
        const remain = this._duration - elapsed;
        this._start = date;
        this._duration = Math.floor(Math.max(remain, cfg.duration));
        this._total += elapsed;
        this._loop = !!cfg.loop;
        this._to = resolve([cfg.to, to10, currentValue, cfg.from]);
        this._from = resolve([cfg.from, currentValue, to10]);
      }
    }
    cancel() {
      if (this._active) {
        this.tick(Date.now());
        this._active = false;
        this._notify(false);
      }
    }
    tick(date) {
      const elapsed = date - this._start;
      const duration = this._duration;
      const prop = this._prop;
      const from17 = this._from;
      const loop = this._loop;
      const to10 = this._to;
      let factor;
      this._active = from17 !== to10 && (loop || elapsed < duration);
      if (!this._active) {
        this._target[prop] = to10;
        this._notify(true);
        return;
      }
      if (elapsed < 0) {
        this._target[prop] = from17;
        return;
      }
      factor = elapsed / duration % 2;
      factor = loop && factor > 1 ? 2 - factor : factor;
      factor = this._easing(Math.min(1, Math.max(0, factor)));
      this._target[prop] = this._fn(from17, to10, factor);
    }
    wait() {
      const promises = this._promises || (this._promises = []);
      return new Promise((res, rej) => {
        promises.push({ res, rej });
      });
    }
    _notify(resolved) {
      const method = resolved ? "res" : "rej";
      const promises = this._promises || [];
      for (let i = 0; i < promises.length; i++) {
        promises[i][method]();
      }
    }
  };
  var numbers = ["x", "y", "borderWidth", "radius", "tension"];
  var colors = ["color", "borderColor", "backgroundColor"];
  defaults3.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  var animationOptions = Object.keys(defaults3.animation);
  defaults3.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name2) => name2 !== "onProgress" && name2 !== "onComplete" && name2 !== "fn"
  });
  defaults3.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults3.describe("animations", {
    _fallback: "animation"
  });
  defaults3.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v) => v | 0
        }
      }
    }
  });
  var Animations = class {
    constructor(chart, config) {
      this._chart = chart;
      this._properties = new Map();
      this.configure(config);
    }
    configure(config) {
      if (!isObject2(config)) {
        return;
      }
      const animatedProps = this._properties;
      Object.getOwnPropertyNames(config).forEach((key) => {
        const cfg = config[key];
        if (!isObject2(cfg)) {
          return;
        }
        const resolved = {};
        for (const option2 of animationOptions) {
          resolved[option2] = cfg[option2];
        }
        (isArray2(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
          if (prop === key || !animatedProps.has(prop)) {
            animatedProps.set(prop, resolved);
          }
        });
      });
    }
    _animateOptions(target, values) {
      const newOptions = values.options;
      const options = resolveTargetOptions(target, newOptions);
      if (!options) {
        return [];
      }
      const animations = this._createAnimations(options, newOptions);
      if (newOptions.$shared) {
        awaitAll(target.options.$animations, newOptions).then(() => {
          target.options = newOptions;
        }, () => {
        });
      }
      return animations;
    }
    _createAnimations(target, values) {
      const animatedProps = this._properties;
      const animations = [];
      const running = target.$animations || (target.$animations = {});
      const props = Object.keys(values);
      const date = Date.now();
      let i;
      for (i = props.length - 1; i >= 0; --i) {
        const prop = props[i];
        if (prop.charAt(0) === "$") {
          continue;
        }
        if (prop === "options") {
          animations.push(...this._animateOptions(target, values));
          continue;
        }
        const value = values[prop];
        let animation = running[prop];
        const cfg = animatedProps.get(prop);
        if (animation) {
          if (cfg && animation.active()) {
            animation.update(cfg, value, date);
            continue;
          } else {
            animation.cancel();
          }
        }
        if (!cfg || !cfg.duration) {
          target[prop] = value;
          continue;
        }
        running[prop] = animation = new Animation(cfg, target, prop, value);
        animations.push(animation);
      }
      return animations;
    }
    update(target, values) {
      if (this._properties.size === 0) {
        Object.assign(target, values);
        return;
      }
      const animations = this._createAnimations(target, values);
      if (animations.length) {
        animator.add(this._chart, animations);
        return true;
      }
    }
  };
  function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for (let i = 0; i < keys.length; i++) {
      const anim = animations[keys[i]];
      if (anim && anim.active()) {
        running.push(anim.wait());
      }
    }
    return Promise.all(running);
  }
  function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
      return;
    }
    let options = target.options;
    if (!options) {
      target.options = newOptions;
      return;
    }
    if (options.$shared) {
      target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
    }
    return options;
  }
  function scaleClip(scale, allowedOverflow) {
    const opts = scale && scale.options || {};
    const reverse = opts.reverse;
    const min = opts.min === void 0 ? allowedOverflow : 0;
    const max = opts.max === void 0 ? allowedOverflow : 0;
    return {
      start: reverse ? max : min,
      end: reverse ? min : max
    };
  }
  function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
      return false;
    }
    const x = scaleClip(xScale, allowedOverflow);
    const y2 = scaleClip(yScale, allowedOverflow);
    return {
      top: y2.end,
      right: x.end,
      bottom: y2.start,
      left: x.start
    };
  }
  function toClip(value) {
    let t2, r, b, l;
    if (isObject2(value)) {
      t2 = value.top;
      r = value.right;
      b = value.bottom;
      l = value.left;
    } else {
      t2 = r = b = l = value;
    }
    return {
      top: t2,
      right: r,
      bottom: b,
      left: l,
      disabled: value === false
    };
  }
  function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      keys.push(metasets[i].index);
    }
    return keys;
  }
  function applyStack(stack, value, dsIndex, options = {}) {
    const keys = stack.keys;
    const singleMode = options.mode === "single";
    let i, ilen, datasetIndex, otherValue;
    if (value === null) {
      return;
    }
    for (i = 0, ilen = keys.length; i < ilen; ++i) {
      datasetIndex = +keys[i];
      if (datasetIndex === dsIndex) {
        if (options.all) {
          continue;
        }
        break;
      }
      otherValue = stack.values[datasetIndex];
      if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
        value += otherValue;
      }
    }
    return value;
  }
  function convertObjectDataToArray(data) {
    const keys = Object.keys(data);
    const adata = new Array(keys.length);
    let i, ilen, key;
    for (i = 0, ilen = keys.length; i < ilen; ++i) {
      key = keys[i];
      adata[i] = {
        x: key,
        y: data[key]
      };
    }
    return adata;
  }
  function isStacked(scale, meta2) {
    const stacked = scale && scale.options.stacked;
    return stacked || stacked === void 0 && meta2.stack !== void 0;
  }
  function getStackKey(indexScale, valueScale, meta2) {
    return `${indexScale.id}.${valueScale.id}.${meta2.stack || meta2.type}`;
  }
  function getUserBounds(scale) {
    const { min, max, minDefined, maxDefined } = scale.getUserBounds();
    return {
      min: minDefined ? min : Number.NEGATIVE_INFINITY,
      max: maxDefined ? max : Number.POSITIVE_INFINITY
    };
  }
  function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
  }
  function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta2 of vScale.getMatchingVisibleMetas(type).reverse()) {
      const value = stack[meta2.index];
      if (positive && value > 0 || !positive && value < 0) {
        return meta2.index;
      }
    }
    return null;
  }
  function updateStacks(controller, parsed) {
    const { chart, _cachedMeta: meta2 } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale, vScale, index: datasetIndex } = meta2;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta2);
    const ilen = parsed.length;
    let stack;
    for (let i = 0; i < ilen; ++i) {
      const item = parsed[i];
      const { [iAxis]: index3, [vAxis]: value } = item;
      const itemStacks = item._stacks || (item._stacks = {});
      stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index3);
      stack[datasetIndex] = value;
      stack._top = getLastIndexInStack(stack, vScale, true, meta2.type);
      stack._bottom = getLastIndexInStack(stack, vScale, false, meta2.type);
    }
  }
  function getFirstScaleId(chart, axis) {
    const scales2 = chart.scales;
    return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
  }
  function createDatasetContext(parent, index3) {
    return createContext(parent, {
      active: false,
      dataset: void 0,
      datasetIndex: index3,
      index: index3,
      mode: "default",
      type: "dataset"
    });
  }
  function createDataContext(parent, index3, element) {
    return createContext(parent, {
      active: false,
      dataIndex: index3,
      parsed: void 0,
      raw: void 0,
      element,
      index: index3,
      mode: "default",
      type: "data"
    });
  }
  function clearStacks(meta2, items) {
    const datasetIndex = meta2.controller.index;
    const axis = meta2.vScale && meta2.vScale.axis;
    if (!axis) {
      return;
    }
    items = items || meta2._parsed;
    for (const parsed of items) {
      const stacks = parsed._stacks;
      if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
        return;
      }
      delete stacks[axis][datasetIndex];
    }
  }
  var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
  var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
  var createStack = (canStack, meta2, chart) => canStack && !meta2.hidden && meta2._stacked && { keys: getSortedDatasetIndices(chart, true), values: null };
  var DatasetController = class {
    constructor(chart, datasetIndex) {
      this.chart = chart;
      this._ctx = chart.ctx;
      this.index = datasetIndex;
      this._cachedDataOpts = {};
      this._cachedMeta = this.getMeta();
      this._type = this._cachedMeta.type;
      this.options = void 0;
      this._parsing = false;
      this._data = void 0;
      this._objectData = void 0;
      this._sharedOptions = void 0;
      this._drawStart = void 0;
      this._drawCount = void 0;
      this.enableOptionSharing = false;
      this.supportsDecimation = false;
      this.$context = void 0;
      this._syncList = [];
      this.initialize();
    }
    initialize() {
      const meta2 = this._cachedMeta;
      this.configure();
      this.linkScales();
      meta2._stacked = isStacked(meta2.vScale, meta2);
      this.addElements();
    }
    updateIndex(datasetIndex) {
      if (this.index !== datasetIndex) {
        clearStacks(this._cachedMeta);
      }
      this.index = datasetIndex;
    }
    linkScales() {
      const chart = this.chart;
      const meta2 = this._cachedMeta;
      const dataset = this.getDataset();
      const chooseId = (axis, x, y2, r) => axis === "x" ? x : axis === "r" ? r : y2;
      const xid = meta2.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
      const yid = meta2.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
      const rid = meta2.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
      const indexAxis = meta2.indexAxis;
      const iid = meta2.iAxisID = chooseId(indexAxis, xid, yid, rid);
      const vid = meta2.vAxisID = chooseId(indexAxis, yid, xid, rid);
      meta2.xScale = this.getScaleForId(xid);
      meta2.yScale = this.getScaleForId(yid);
      meta2.rScale = this.getScaleForId(rid);
      meta2.iScale = this.getScaleForId(iid);
      meta2.vScale = this.getScaleForId(vid);
    }
    getDataset() {
      return this.chart.data.datasets[this.index];
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(scaleID) {
      return this.chart.scales[scaleID];
    }
    _getOtherScale(scale) {
      const meta2 = this._cachedMeta;
      return scale === meta2.iScale ? meta2.vScale : meta2.iScale;
    }
    reset() {
      this._update("reset");
    }
    _destroy() {
      const meta2 = this._cachedMeta;
      if (this._data) {
        unlistenArrayEvents(this._data, this);
      }
      if (meta2._stacked) {
        clearStacks(meta2);
      }
    }
    _dataCheck() {
      const dataset = this.getDataset();
      const data = dataset.data || (dataset.data = []);
      const _data = this._data;
      if (isObject2(data)) {
        this._data = convertObjectDataToArray(data);
      } else if (_data !== data) {
        if (_data) {
          unlistenArrayEvents(_data, this);
          const meta2 = this._cachedMeta;
          clearStacks(meta2);
          meta2._parsed = [];
        }
        if (data && Object.isExtensible(data)) {
          listenArrayEvents(data, this);
        }
        this._syncList = [];
        this._data = data;
      }
    }
    addElements() {
      const meta2 = this._cachedMeta;
      this._dataCheck();
      if (this.datasetElementType) {
        meta2.dataset = new this.datasetElementType();
      }
    }
    buildOrUpdateElements(resetNewElements) {
      const meta2 = this._cachedMeta;
      const dataset = this.getDataset();
      let stackChanged = false;
      this._dataCheck();
      const oldStacked = meta2._stacked;
      meta2._stacked = isStacked(meta2.vScale, meta2);
      if (meta2.stack !== dataset.stack) {
        stackChanged = true;
        clearStacks(meta2);
        meta2.stack = dataset.stack;
      }
      this._resyncElements(resetNewElements);
      if (stackChanged || oldStacked !== meta2._stacked) {
        updateStacks(this, meta2._parsed);
      }
    }
    configure() {
      const config = this.chart.config;
      const scopeKeys = config.datasetScopeKeys(this._type);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
      this.options = config.createResolver(scopes, this.getContext());
      this._parsing = this.options.parsing;
      this._cachedDataOpts = {};
    }
    parse(start2, count) {
      const { _cachedMeta: meta2, _data: data } = this;
      const { iScale, _stacked } = meta2;
      const iAxis = iScale.axis;
      let sorted = start2 === 0 && count === data.length ? true : meta2._sorted;
      let prev = start2 > 0 && meta2._parsed[start2 - 1];
      let i, cur, parsed;
      if (this._parsing === false) {
        meta2._parsed = data;
        meta2._sorted = true;
        parsed = data;
      } else {
        if (isArray2(data[start2])) {
          parsed = this.parseArrayData(meta2, data, start2, count);
        } else if (isObject2(data[start2])) {
          parsed = this.parseObjectData(meta2, data, start2, count);
        } else {
          parsed = this.parsePrimitiveData(meta2, data, start2, count);
        }
        const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
        for (i = 0; i < count; ++i) {
          meta2._parsed[i + start2] = cur = parsed[i];
          if (sorted) {
            if (isNotInOrderComparedToPrev()) {
              sorted = false;
            }
            prev = cur;
          }
        }
        meta2._sorted = sorted;
      }
      if (_stacked) {
        updateStacks(this, parsed);
      }
    }
    parsePrimitiveData(meta2, data, start2, count) {
      const { iScale, vScale } = meta2;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const labels = iScale.getLabels();
      const singleScale = iScale === vScale;
      const parsed = new Array(count);
      let i, ilen, index3;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index3 = i + start2;
        parsed[i] = {
          [iAxis]: singleScale || iScale.parse(labels[index3], index3),
          [vAxis]: vScale.parse(data[index3], index3)
        };
      }
      return parsed;
    }
    parseArrayData(meta2, data, start2, count) {
      const { xScale, yScale } = meta2;
      const parsed = new Array(count);
      let i, ilen, index3, item;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index3 = i + start2;
        item = data[index3];
        parsed[i] = {
          x: xScale.parse(item[0], index3),
          y: yScale.parse(item[1], index3)
        };
      }
      return parsed;
    }
    parseObjectData(meta2, data, start2, count) {
      const { xScale, yScale } = meta2;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const parsed = new Array(count);
      let i, ilen, index3, item;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index3 = i + start2;
        item = data[index3];
        parsed[i] = {
          x: xScale.parse(resolveObjectKey(item, xAxisKey), index3),
          y: yScale.parse(resolveObjectKey(item, yAxisKey), index3)
        };
      }
      return parsed;
    }
    getParsed(index3) {
      return this._cachedMeta._parsed[index3];
    }
    getDataElement(index3) {
      return this._cachedMeta.data[index3];
    }
    applyStack(scale, parsed, mode) {
      const chart = this.chart;
      const meta2 = this._cachedMeta;
      const value = parsed[scale.axis];
      const stack = {
        keys: getSortedDatasetIndices(chart, true),
        values: parsed._stacks[scale.axis]
      };
      return applyStack(stack, value, meta2.index, { mode });
    }
    updateRangeFromParsed(range10, scale, parsed, stack) {
      const parsedValue = parsed[scale.axis];
      let value = parsedValue === null ? NaN : parsedValue;
      const values = stack && parsed._stacks[scale.axis];
      if (stack && values) {
        stack.values = values;
        value = applyStack(stack, parsedValue, this._cachedMeta.index);
      }
      range10.min = Math.min(range10.min, value);
      range10.max = Math.max(range10.max, value);
    }
    getMinMax(scale, canStack) {
      const meta2 = this._cachedMeta;
      const _parsed = meta2._parsed;
      const sorted = meta2._sorted && scale === meta2.iScale;
      const ilen = _parsed.length;
      const otherScale = this._getOtherScale(scale);
      const stack = createStack(canStack, meta2, this.chart);
      const range10 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
      const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
      let i, parsed;
      function _skip() {
        parsed = _parsed[i];
        const otherValue = parsed[otherScale.axis];
        return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
      }
      for (i = 0; i < ilen; ++i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range10, scale, parsed, stack);
        if (sorted) {
          break;
        }
      }
      if (sorted) {
        for (i = ilen - 1; i >= 0; --i) {
          if (_skip()) {
            continue;
          }
          this.updateRangeFromParsed(range10, scale, parsed, stack);
          break;
        }
      }
      return range10;
    }
    getAllParsedValues(scale) {
      const parsed = this._cachedMeta._parsed;
      const values = [];
      let i, ilen, value;
      for (i = 0, ilen = parsed.length; i < ilen; ++i) {
        value = parsed[i][scale.axis];
        if (isNumberFinite(value)) {
          values.push(value);
        }
      }
      return values;
    }
    getMaxOverflow() {
      return false;
    }
    getLabelAndValue(index3) {
      const meta2 = this._cachedMeta;
      const iScale = meta2.iScale;
      const vScale = meta2.vScale;
      const parsed = this.getParsed(index3);
      return {
        label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
        value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
      };
    }
    _update(mode) {
      const meta2 = this._cachedMeta;
      this.update(mode || "default");
      meta2._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta2.xScale, meta2.yScale, this.getMaxOverflow())));
    }
    update(mode) {
    }
    draw() {
      const ctx = this._ctx;
      const chart = this.chart;
      const meta2 = this._cachedMeta;
      const elements2 = meta2.data || [];
      const area = chart.chartArea;
      const active = [];
      const start2 = this._drawStart || 0;
      const count = this._drawCount || elements2.length - start2;
      const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
      let i;
      if (meta2.dataset) {
        meta2.dataset.draw(ctx, area, start2, count);
      }
      for (i = start2; i < start2 + count; ++i) {
        const element = elements2[i];
        if (element.hidden) {
          continue;
        }
        if (element.active && drawActiveElementsOnTop) {
          active.push(element);
        } else {
          element.draw(ctx, area);
        }
      }
      for (i = 0; i < active.length; ++i) {
        active[i].draw(ctx, area);
      }
    }
    getStyle(index3, active) {
      const mode = active ? "active" : "default";
      return index3 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index3 || 0, mode);
    }
    getContext(index3, active, mode) {
      const dataset = this.getDataset();
      let context2;
      if (index3 >= 0 && index3 < this._cachedMeta.data.length) {
        const element = this._cachedMeta.data[index3];
        context2 = element.$context || (element.$context = createDataContext(this.getContext(), index3, element));
        context2.parsed = this.getParsed(index3);
        context2.raw = dataset.data[index3];
        context2.index = context2.dataIndex = index3;
      } else {
        context2 = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
        context2.dataset = dataset;
        context2.index = context2.datasetIndex = this.index;
      }
      context2.active = !!active;
      context2.mode = mode;
      return context2;
    }
    resolveDatasetElementOptions(mode) {
      return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
    resolveDataElementOptions(index3, mode) {
      return this._resolveElementOptions(this.dataElementType.id, mode, index3);
    }
    _resolveElementOptions(elementType, mode = "default", index3) {
      const active = mode === "active";
      const cache = this._cachedDataOpts;
      const cacheKey = elementType + "-" + mode;
      const cached = cache[cacheKey];
      const sharing = this.enableOptionSharing && defined(index3);
      if (cached) {
        return cloneIfNotShared(cached, sharing);
      }
      const config = this.chart.config;
      const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
      const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      const names2 = Object.keys(defaults3.elements[elementType]);
      const context2 = () => this.getContext(index3, active);
      const values = config.resolveNamedOptions(scopes, names2, context2, prefixes);
      if (values.$shared) {
        values.$shared = sharing;
        cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
      }
      return values;
    }
    _resolveAnimations(index3, transition, active) {
      const chart = this.chart;
      const cache = this._cachedDataOpts;
      const cacheKey = `animation-${transition}`;
      const cached = cache[cacheKey];
      if (cached) {
        return cached;
      }
      let options;
      if (chart.options.animation !== false) {
        const config = this.chart.config;
        const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        options = config.createResolver(scopes, this.getContext(index3, active, transition));
      }
      const animations = new Animations(chart, options && options.animations);
      if (options && options._cacheable) {
        cache[cacheKey] = Object.freeze(animations);
      }
      return animations;
    }
    getSharedOptions(options) {
      if (!options.$shared) {
        return;
      }
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
    }
    includeOptions(mode, sharedOptions) {
      return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
    _getSharedOptions(start2, mode) {
      const firstOpts = this.resolveDataElementOptions(start2, mode);
      const previouslySharedOptions = this._sharedOptions;
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
      return { sharedOptions, includeOptions };
    }
    updateElement(element, index3, properties, mode) {
      if (isDirectUpdateMode(mode)) {
        Object.assign(element, properties);
      } else {
        this._resolveAnimations(index3, mode).update(element, properties);
      }
    }
    updateSharedOptions(sharedOptions, mode, newOptions) {
      if (sharedOptions && !isDirectUpdateMode(mode)) {
        this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
      }
    }
    _setStyle(element, index3, mode, active) {
      element.active = active;
      const options = this.getStyle(index3, active);
      this._resolveAnimations(index3, mode, active).update(element, {
        options: !active && this.getSharedOptions(options) || options
      });
    }
    removeHoverStyle(element, datasetIndex, index3) {
      this._setStyle(element, index3, "active", false);
    }
    setHoverStyle(element, datasetIndex, index3) {
      this._setStyle(element, index3, "active", true);
    }
    _removeDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", false);
      }
    }
    _setDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", true);
      }
    }
    _resyncElements(resetNewElements) {
      const data = this._data;
      const elements2 = this._cachedMeta.data;
      for (const [method, arg1, arg2] of this._syncList) {
        this[method](arg1, arg2);
      }
      this._syncList = [];
      const numMeta = elements2.length;
      const numData = data.length;
      const count = Math.min(numData, numMeta);
      if (count) {
        this.parse(0, count);
      }
      if (numData > numMeta) {
        this._insertElements(numMeta, numData - numMeta, resetNewElements);
      } else if (numData < numMeta) {
        this._removeElements(numData, numMeta - numData);
      }
    }
    _insertElements(start2, count, resetNewElements = true) {
      const meta2 = this._cachedMeta;
      const data = meta2.data;
      const end = start2 + count;
      let i;
      const move = (arr) => {
        arr.length += count;
        for (i = arr.length - 1; i >= end; i--) {
          arr[i] = arr[i - count];
        }
      };
      move(data);
      for (i = start2; i < end; ++i) {
        data[i] = new this.dataElementType();
      }
      if (this._parsing) {
        move(meta2._parsed);
      }
      this.parse(start2, count);
      if (resetNewElements) {
        this.updateElements(data, start2, count, "reset");
      }
    }
    updateElements(element, start2, count, mode) {
    }
    _removeElements(start2, count) {
      const meta2 = this._cachedMeta;
      if (this._parsing) {
        const removed = meta2._parsed.splice(start2, count);
        if (meta2._stacked) {
          clearStacks(meta2, removed);
        }
      }
      meta2.data.splice(start2, count);
    }
    _sync(args) {
      if (this._parsing) {
        this._syncList.push(args);
      } else {
        const [method, arg1, arg2] = args;
        this[method](arg1, arg2);
      }
      this.chart._dataChanges.push([this.index, ...args]);
    }
    _onDataPush() {
      const count = arguments.length;
      this._sync(["_insertElements", this.getDataset().data.length - count, count]);
    }
    _onDataPop() {
      this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
    }
    _onDataShift() {
      this._sync(["_removeElements", 0, 1]);
    }
    _onDataSplice(start2, count) {
      if (count) {
        this._sync(["_removeElements", start2, count]);
      }
      const newCount = arguments.length - 2;
      if (newCount) {
        this._sync(["_insertElements", start2, newCount]);
      }
    }
    _onDataUnshift() {
      this._sync(["_insertElements", 0, arguments.length]);
    }
  };
  DatasetController.defaults = {};
  DatasetController.prototype.datasetElementType = null;
  DatasetController.prototype.dataElementType = null;
  function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
      const visibleMetas = scale.getMatchingVisibleMetas(type);
      let values = [];
      for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
        values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
      }
      scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
    }
    return scale._cache.$bar;
  }
  function computeMinSampleSize(meta2) {
    const scale = meta2.iScale;
    const values = getAllScaleValues(scale, meta2.type);
    let min = scale._length;
    let i, ilen, curr, prev;
    const updateMinAndPrev = () => {
      if (curr === 32767 || curr === -32768) {
        return;
      }
      if (defined(prev)) {
        min = Math.min(min, Math.abs(curr - prev) || min);
      }
      prev = curr;
    };
    for (i = 0, ilen = values.length; i < ilen; ++i) {
      curr = scale.getPixelForValue(values[i]);
      updateMinAndPrev();
    }
    prev = void 0;
    for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
      curr = scale.getPixelForTick(i);
      updateMinAndPrev();
    }
    return min;
  }
  function computeFitCategoryTraits(index3, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size, ratio;
    if (isNullOrUndef(thickness)) {
      size = ruler.min * options.categoryPercentage;
      ratio = options.barPercentage;
    } else {
      size = thickness * stackCount;
      ratio = 1;
    }
    return {
      chunk: size / stackCount,
      ratio,
      start: ruler.pixels[index3] - size / 2
    };
  }
  function computeFlexCategoryTraits(index3, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index3];
    let prev = index3 > 0 ? pixels[index3 - 1] : null;
    let next = index3 < pixels.length - 1 ? pixels[index3 + 1] : null;
    const percent = options.categoryPercentage;
    if (prev === null) {
      prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
      next = curr + curr - prev;
    }
    const start2 = curr - (curr - Math.min(prev, next)) / 2 * percent;
    const size = Math.abs(next - prev) / 2 * percent;
    return {
      chunk: size / stackCount,
      ratio: options.barPercentage,
      start: start2
    };
  }
  function parseFloatBar(entry, item, vScale, i) {
    const startValue = vScale.parse(entry[0], i);
    const endValue = vScale.parse(entry[1], i);
    const min = Math.min(startValue, endValue);
    const max = Math.max(startValue, endValue);
    let barStart = min;
    let barEnd = max;
    if (Math.abs(min) > Math.abs(max)) {
      barStart = max;
      barEnd = min;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
      barStart,
      barEnd,
      start: startValue,
      end: endValue,
      min,
      max
    };
  }
  function parseValue(entry, item, vScale, i) {
    if (isArray2(entry)) {
      parseFloatBar(entry, item, vScale, i);
    } else {
      item[vScale.axis] = vScale.parse(entry, i);
    }
    return item;
  }
  function parseArrayOrPrimitive(meta2, data, start2, count) {
    const iScale = meta2.iScale;
    const vScale = meta2.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i, ilen, item, entry;
    for (i = start2, ilen = start2 + count; i < ilen; ++i) {
      entry = data[i];
      item = {};
      item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
      parsed.push(parseValue(entry, item, vScale, i));
    }
    return parsed;
  }
  function isFloatBar(custom) {
    return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
  }
  function barSign(size, vScale, actualBase) {
    if (size !== 0) {
      return sign(size);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
  }
  function borderProps(properties) {
    let reverse, start2, end, top2, bottom;
    if (properties.horizontal) {
      reverse = properties.base > properties.x;
      start2 = "left";
      end = "right";
    } else {
      reverse = properties.base < properties.y;
      start2 = "bottom";
      end = "top";
    }
    if (reverse) {
      top2 = "end";
      bottom = "start";
    } else {
      top2 = "start";
      bottom = "end";
    }
    return { start: start2, end, reverse, top: top2, bottom };
  }
  function setBorderSkipped(properties, options, stack, index3) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
      properties.borderSkipped = res;
      return;
    }
    if (edge === true) {
      properties.borderSkipped = { top: true, right: true, bottom: true, left: true };
      return;
    }
    const { start: start2, end, reverse, top: top2, bottom } = borderProps(properties);
    if (edge === "middle" && stack) {
      properties.enableBorderRadius = true;
      if ((stack._top || 0) === index3) {
        edge = top2;
      } else if ((stack._bottom || 0) === index3) {
        edge = bottom;
      } else {
        res[parseEdge(bottom, start2, end, reverse)] = true;
        edge = top2;
      }
    }
    res[parseEdge(edge, start2, end, reverse)] = true;
    properties.borderSkipped = res;
  }
  function parseEdge(edge, a, b, reverse) {
    if (reverse) {
      edge = swap(edge, a, b);
      edge = startEnd(edge, b, a);
    } else {
      edge = startEnd(edge, a, b);
    }
    return edge;
  }
  function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
  }
  function startEnd(v, start2, end) {
    return v === "start" ? start2 : v === "end" ? end : v;
  }
  function setInflateAmount(properties, { inflateAmount }, ratio) {
    properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
  }
  var BarController = class extends DatasetController {
    parsePrimitiveData(meta2, data, start2, count) {
      return parseArrayOrPrimitive(meta2, data, start2, count);
    }
    parseArrayData(meta2, data, start2, count) {
      return parseArrayOrPrimitive(meta2, data, start2, count);
    }
    parseObjectData(meta2, data, start2, count) {
      const { iScale, vScale } = meta2;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
      const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
      const parsed = [];
      let i, ilen, item, obj;
      for (i = start2, ilen = start2 + count; i < ilen; ++i) {
        obj = data[i];
        item = {};
        item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
        parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
      }
      return parsed;
    }
    updateRangeFromParsed(range10, scale, parsed, stack) {
      super.updateRangeFromParsed(range10, scale, parsed, stack);
      const custom = parsed._custom;
      if (custom && scale === this._cachedMeta.vScale) {
        range10.min = Math.min(range10.min, custom.min);
        range10.max = Math.max(range10.max, custom.max);
      }
    }
    getMaxOverflow() {
      return 0;
    }
    getLabelAndValue(index3) {
      const meta2 = this._cachedMeta;
      const { iScale, vScale } = meta2;
      const parsed = this.getParsed(index3);
      const custom = parsed._custom;
      const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
      return {
        label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
        value
      };
    }
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
      const meta2 = this._cachedMeta;
      meta2.stack = this.getDataset().stack;
    }
    update(mode) {
      const meta2 = this._cachedMeta;
      this.updateElements(meta2.data, 0, meta2.data.length, mode);
    }
    updateElements(bars, start2, count, mode) {
      const reset = mode === "reset";
      const { index: index3, _cachedMeta: { vScale } } = this;
      const base2 = vScale.getBasePixel();
      const horizontal = vScale.isHorizontal();
      const ruler = this._getRuler();
      const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
      for (let i = start2; i < start2 + count; i++) {
        const parsed = this.getParsed(i);
        const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? { base: base2, head: base2 } : this._calculateBarValuePixels(i);
        const ipixels = this._calculateBarIndexPixels(i, ruler);
        const stack = (parsed._stacks || {})[vScale.axis];
        const properties = {
          horizontal,
          base: vpixels.base,
          enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index3 === stack._top || index3 === stack._bottom),
          x: horizontal ? vpixels.head : ipixels.center,
          y: horizontal ? ipixels.center : vpixels.head,
          height: horizontal ? ipixels.size : Math.abs(vpixels.size),
          width: horizontal ? Math.abs(vpixels.size) : ipixels.size
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
        }
        const options = properties.options || bars[i].options;
        setBorderSkipped(properties, options, stack, index3);
        setInflateAmount(properties, options, ruler.ratio);
        this.updateElement(bars[i], i, properties, mode);
      }
    }
    _getStacks(last, dataIndex) {
      const { iScale } = this._cachedMeta;
      const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta2) => meta2.controller.options.grouped);
      const stacked = iScale.options.stacked;
      const stacks = [];
      const skipNull = (meta2) => {
        const parsed = meta2.controller.getParsed(dataIndex);
        const val = parsed && parsed[meta2.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          return true;
        }
      };
      for (const meta2 of metasets) {
        if (dataIndex !== void 0 && skipNull(meta2)) {
          continue;
        }
        if (stacked === false || stacks.indexOf(meta2.stack) === -1 || stacked === void 0 && meta2.stack === void 0) {
          stacks.push(meta2.stack);
        }
        if (meta2.index === last) {
          break;
        }
      }
      if (!stacks.length) {
        stacks.push(void 0);
      }
      return stacks;
    }
    _getStackCount(index3) {
      return this._getStacks(void 0, index3).length;
    }
    _getStackIndex(datasetIndex, name2, dataIndex) {
      const stacks = this._getStacks(datasetIndex, dataIndex);
      const index3 = name2 !== void 0 ? stacks.indexOf(name2) : -1;
      return index3 === -1 ? stacks.length - 1 : index3;
    }
    _getRuler() {
      const opts = this.options;
      const meta2 = this._cachedMeta;
      const iScale = meta2.iScale;
      const pixels = [];
      let i, ilen;
      for (i = 0, ilen = meta2.data.length; i < ilen; ++i) {
        pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
      }
      const barThickness = opts.barThickness;
      const min = barThickness || computeMinSampleSize(meta2);
      return {
        min,
        pixels,
        start: iScale._startPixel,
        end: iScale._endPixel,
        stackCount: this._getStackCount(),
        scale: iScale,
        grouped: opts.grouped,
        ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
      };
    }
    _calculateBarValuePixels(index3) {
      const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
      const actualBase = baseValue || 0;
      const parsed = this.getParsed(index3);
      const custom = parsed._custom;
      const floating = isFloatBar(custom);
      let value = parsed[vScale.axis];
      let start2 = 0;
      let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
      let head, size;
      if (length !== value) {
        start2 = length - value;
        length = value;
      }
      if (floating) {
        value = custom.barStart;
        length = custom.barEnd - custom.barStart;
        if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
          start2 = 0;
        }
        start2 += value;
      }
      const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start2;
      let base2 = vScale.getPixelForValue(startValue);
      if (this.chart.getDataVisibility(index3)) {
        head = vScale.getPixelForValue(start2 + length);
      } else {
        head = base2;
      }
      size = head - base2;
      if (Math.abs(size) < minBarLength) {
        size = barSign(size, vScale, actualBase) * minBarLength;
        if (value === actualBase) {
          base2 -= size / 2;
        }
        const startPixel = vScale.getPixelForDecimal(0);
        const endPixel = vScale.getPixelForDecimal(1);
        const min = Math.min(startPixel, endPixel);
        const max = Math.max(startPixel, endPixel);
        base2 = Math.max(Math.min(base2, max), min);
        head = base2 + size;
      }
      if (base2 === vScale.getPixelForValue(actualBase)) {
        const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
        base2 += halfGrid;
        size -= halfGrid;
      }
      return {
        size,
        base: base2,
        head,
        center: head + size / 2
      };
    }
    _calculateBarIndexPixels(index3, ruler) {
      const scale = ruler.scale;
      const options = this.options;
      const skipNull = options.skipNull;
      const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
      let center, size;
      if (ruler.grouped) {
        const stackCount = skipNull ? this._getStackCount(index3) : ruler.stackCount;
        const range10 = options.barThickness === "flex" ? computeFlexCategoryTraits(index3, ruler, options, stackCount) : computeFitCategoryTraits(index3, ruler, options, stackCount);
        const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index3 : void 0);
        center = range10.start + range10.chunk * stackIndex + range10.chunk / 2;
        size = Math.min(maxBarThickness, range10.chunk * range10.ratio);
      } else {
        center = scale.getPixelForValue(this.getParsed(index3)[scale.axis], index3);
        size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
      }
      return {
        base: center - size / 2,
        head: center + size / 2,
        center,
        size
      };
    }
    draw() {
      const meta2 = this._cachedMeta;
      const vScale = meta2.vScale;
      const rects = meta2.data;
      const ilen = rects.length;
      let i = 0;
      for (; i < ilen; ++i) {
        if (this.getParsed(i)[vScale.axis] !== null) {
          rects[i].draw(this._ctx);
        }
      }
    }
  };
  BarController.id = "bar";
  BarController.defaults = {
    datasetElementType: false,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "base", "width", "height"]
      }
    }
  };
  BarController.overrides = {
    scales: {
      _index_: {
        type: "category",
        offset: true,
        grid: {
          offset: true
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: true
      }
    }
  };
  var BubbleController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
    }
    parsePrimitiveData(meta2, data, start2, count) {
      const parsed = super.parsePrimitiveData(meta2, data, start2, count);
      for (let i = 0; i < parsed.length; i++) {
        parsed[i]._custom = this.resolveDataElementOptions(i + start2).radius;
      }
      return parsed;
    }
    parseArrayData(meta2, data, start2, count) {
      const parsed = super.parseArrayData(meta2, data, start2, count);
      for (let i = 0; i < parsed.length; i++) {
        const item = data[start2 + i];
        parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start2).radius);
      }
      return parsed;
    }
    parseObjectData(meta2, data, start2, count) {
      const parsed = super.parseObjectData(meta2, data, start2, count);
      for (let i = 0; i < parsed.length; i++) {
        const item = data[start2 + i];
        parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start2).radius);
      }
      return parsed;
    }
    getMaxOverflow() {
      const data = this._cachedMeta.data;
      let max = 0;
      for (let i = data.length - 1; i >= 0; --i) {
        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max > 0 && max;
    }
    getLabelAndValue(index3) {
      const meta2 = this._cachedMeta;
      const { xScale, yScale } = meta2;
      const parsed = this.getParsed(index3);
      const x = xScale.getLabelForValue(parsed.x);
      const y2 = yScale.getLabelForValue(parsed.y);
      const r = parsed._custom;
      return {
        label: meta2.label,
        value: "(" + x + ", " + y2 + (r ? ", " + r : "") + ")"
      };
    }
    update(mode) {
      const points = this._cachedMeta.data;
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start2, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      for (let i = start2; i < start2 + count; i++) {
        const point = points[i];
        const parsed = !reset && this.getParsed(i);
        const properties = {};
        const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
        const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
        properties.skip = isNaN(iPixel) || isNaN(vPixel);
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
          if (reset) {
            properties.options.radius = 0;
          }
        }
        this.updateElement(point, i, properties, mode);
      }
    }
    resolveDataElementOptions(index3, mode) {
      const parsed = this.getParsed(index3);
      let values = super.resolveDataElementOptions(index3, mode);
      if (values.$shared) {
        values = Object.assign({}, values, { $shared: false });
      }
      const radius = values.radius;
      if (mode !== "active") {
        values.radius = 0;
      }
      values.radius += valueOrDefault(parsed && parsed._custom, radius);
      return values;
    }
  };
  BubbleController.id = "bubble";
  BubbleController.defaults = {
    datasetElementType: false,
    dataElementType: "point",
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "borderWidth", "radius"]
      }
    }
  };
  BubbleController.overrides = {
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    },
    plugins: {
      tooltip: {
        callbacks: {
          title() {
            return "";
          }
        }
      }
    }
  };
  function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < TAU) {
      const startAngle = rotation;
      const endAngle = startAngle + circumference;
      const startX = Math.cos(startAngle);
      const startY = Math.sin(startAngle);
      const endX = Math.cos(endAngle);
      const endY = Math.sin(endAngle);
      const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
      const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
      const maxX = calcMax(0, startX, endX);
      const maxY = calcMax(HALF_PI, startY, endY);
      const minX = calcMin(PI, startX, endX);
      const minY = calcMin(PI + HALF_PI, startY, endY);
      ratioX = (maxX - minX) / 2;
      ratioY = (maxY - minY) / 2;
      offsetX = -(maxX + minX) / 2;
      offsetY = -(maxY + minY) / 2;
    }
    return { ratioX, ratioY, offsetX, offsetY };
  }
  var DoughnutController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.enableOptionSharing = true;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.offsetX = void 0;
      this.offsetY = void 0;
    }
    linkScales() {
    }
    parse(start2, count) {
      const data = this.getDataset().data;
      const meta2 = this._cachedMeta;
      if (this._parsing === false) {
        meta2._parsed = data;
      } else {
        let getter = (i2) => +data[i2];
        if (isObject2(data[start2])) {
          const { key = "value" } = this._parsing;
          getter = (i2) => +resolveObjectKey(data[i2], key);
        }
        let i, ilen;
        for (i = start2, ilen = start2 + count; i < ilen; ++i) {
          meta2._parsed[i] = getter(i);
        }
      }
    }
    _getRotation() {
      return toRadians(this.options.rotation - 90);
    }
    _getCircumference() {
      return toRadians(this.options.circumference);
    }
    _getRotationExtents() {
      let min = TAU;
      let max = -TAU;
      for (let i = 0; i < this.chart.data.datasets.length; ++i) {
        if (this.chart.isDatasetVisible(i)) {
          const controller = this.chart.getDatasetMeta(i).controller;
          const rotation = controller._getRotation();
          const circumference = controller._getCircumference();
          min = Math.min(min, rotation);
          max = Math.max(max, rotation + circumference);
        }
      }
      return {
        rotation: min,
        circumference: max - min
      };
    }
    update(mode) {
      const chart = this.chart;
      const { chartArea } = chart;
      const meta2 = this._cachedMeta;
      const arcs = meta2.data;
      const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
      const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
      const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
      const chartWeight = this._getRingWeight(this.index);
      const { circumference, rotation } = this._getRotationExtents();
      const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
      const maxWidth = (chartArea.width - spacing) / ratioX;
      const maxHeight = (chartArea.height - spacing) / ratioY;
      const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
      const outerRadius = toDimension(this.options.radius, maxRadius);
      const innerRadius = Math.max(outerRadius * cutout, 0);
      const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
      this.offsetX = offsetX * outerRadius;
      this.offsetY = offsetY * outerRadius;
      meta2.total = this.calculateTotal();
      this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
      this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    _circumference(i, reset) {
      const opts = this.options;
      const meta2 = this._cachedMeta;
      const circumference = this._getCircumference();
      if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta2._parsed[i] === null || meta2.data[i].hidden) {
        return 0;
      }
      return this.calculateCircumference(meta2._parsed[i] * circumference / TAU);
    }
    updateElements(arcs, start2, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const centerX = (chartArea.left + chartArea.right) / 2;
      const centerY = (chartArea.top + chartArea.bottom) / 2;
      const animateScale = reset && animationOpts.animateScale;
      const innerRadius = animateScale ? 0 : this.innerRadius;
      const outerRadius = animateScale ? 0 : this.outerRadius;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
      let startAngle = this._getRotation();
      let i;
      for (i = 0; i < start2; ++i) {
        startAngle += this._circumference(i, reset);
      }
      for (i = start2; i < start2 + count; ++i) {
        const circumference = this._circumference(i, reset);
        const arc = arcs[i];
        const properties = {
          x: centerX + this.offsetX,
          y: centerY + this.offsetY,
          startAngle,
          endAngle: startAngle + circumference,
          circumference,
          outerRadius,
          innerRadius
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
        }
        startAngle += circumference;
        this.updateElement(arc, i, properties, mode);
      }
    }
    calculateTotal() {
      const meta2 = this._cachedMeta;
      const metaData = meta2.data;
      let total = 0;
      let i;
      for (i = 0; i < metaData.length; i++) {
        const value = meta2._parsed[i];
        if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
          total += Math.abs(value);
        }
      }
      return total;
    }
    calculateCircumference(value) {
      const total = this._cachedMeta.total;
      if (total > 0 && !isNaN(value)) {
        return TAU * (Math.abs(value) / total);
      }
      return 0;
    }
    getLabelAndValue(index3) {
      const meta2 = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber2(meta2._parsed[index3], chart.options.locale);
      return {
        label: labels[index3] || "",
        value
      };
    }
    getMaxBorderWidth(arcs) {
      let max = 0;
      const chart = this.chart;
      let i, ilen, meta2, controller, options;
      if (!arcs) {
        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            meta2 = chart.getDatasetMeta(i);
            arcs = meta2.data;
            controller = meta2.controller;
            break;
          }
        }
      }
      if (!arcs) {
        return 0;
      }
      for (i = 0, ilen = arcs.length; i < ilen; ++i) {
        options = controller.resolveDataElementOptions(i);
        if (options.borderAlign !== "inner") {
          max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
        }
      }
      return max;
    }
    getMaxOffset(arcs) {
      let max = 0;
      for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
        const options = this.resolveDataElementOptions(i);
        max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
      }
      return max;
    }
    _getRingWeightOffset(datasetIndex) {
      let ringWeightOffset = 0;
      for (let i = 0; i < datasetIndex; ++i) {
        if (this.chart.isDatasetVisible(i)) {
          ringWeightOffset += this._getRingWeight(i);
        }
      }
      return ringWeightOffset;
    }
    _getRingWeight(datasetIndex) {
      return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
    _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
  };
  DoughnutController.id = "doughnut";
  DoughnutController.defaults = {
    datasetElementType: false,
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: false
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  };
  DoughnutController.descriptors = {
    _scriptable: (name2) => name2 !== "spacing",
    _indexable: (name2) => name2 !== "spacing"
  };
  DoughnutController.overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle } } = chart.legend.options;
              return data.labels.map((label, i) => {
                const meta2 = chart.getDatasetMeta(0);
                const style = meta2.controller.getStyle(i);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i),
                  index: i
                };
              });
            }
            return [];
          }
        },
        onClick(e, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      },
      tooltip: {
        callbacks: {
          title() {
            return "";
          },
          label(tooltipItem) {
            let dataLabel = tooltipItem.label;
            const value = ": " + tooltipItem.formattedValue;
            if (isArray2(dataLabel)) {
              dataLabel = dataLabel.slice();
              dataLabel[0] += value;
            } else {
              dataLabel += value;
            }
            return dataLabel;
          }
        }
      }
    }
  };
  var LineController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      this.supportsDecimation = true;
      super.initialize();
    }
    update(mode) {
      const meta2 = this._cachedMeta;
      const { dataset: line, data: points = [], _dataset } = meta2;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start: start2, count } = _getStartAndCountOfVisiblePoints(meta2, points, animationsDisabled);
      this._drawStart = start2;
      this._drawCount = count;
      if (_scaleRangesChanged(meta2)) {
        start2 = 0;
        count = points.length;
      }
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
      this.updateElements(points, start2, count, mode);
    }
    updateElements(points, start2, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber2(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      let prevParsed = start2 > 0 && this.getParsed(start2 - 1);
      for (let i = start2; i < start2 + count; ++i) {
        const point = points[i];
        const parsed = this.getParsed(i);
        const properties = directUpdate ? point : {};
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i, properties, mode);
        }
        prevParsed = parsed;
      }
    }
    getMaxOverflow() {
      const meta2 = this._cachedMeta;
      const dataset = meta2.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      const data = meta2.data || [];
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
      const meta2 = this._cachedMeta;
      meta2.dataset.updateControlPoints(this.chart.chartArea, meta2.iScale.axis);
      super.draw();
    }
  };
  LineController.id = "line";
  LineController.defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: true,
    spanGaps: false
  };
  LineController.overrides = {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  };
  var PolarAreaController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.innerRadius = void 0;
      this.outerRadius = void 0;
    }
    getLabelAndValue(index3) {
      const meta2 = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber2(meta2._parsed[index3].r, chart.options.locale);
      return {
        label: labels[index3] || "",
        value
      };
    }
    parseObjectData(meta2, data, start2, count) {
      return _parseObjectDataRadialScale.bind(this)(meta2, data, start2, count);
    }
    update(mode) {
      const arcs = this._cachedMeta.data;
      this._updateRadius();
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    getMinMax() {
      const meta2 = this._cachedMeta;
      const range10 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
      meta2.data.forEach((element, index3) => {
        const parsed = this.getParsed(index3).r;
        if (!isNaN(parsed) && this.chart.getDataVisibility(index3)) {
          if (parsed < range10.min) {
            range10.min = parsed;
          }
          if (parsed > range10.max) {
            range10.max = parsed;
          }
        }
      });
      return range10;
    }
    _updateRadius() {
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
      const outerRadius = Math.max(minSize / 2, 0);
      const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
      const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
      this.outerRadius = outerRadius - radiusLength * this.index;
      this.innerRadius = this.outerRadius - radiusLength;
    }
    updateElements(arcs, start2, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const scale = this._cachedMeta.rScale;
      const centerX = scale.xCenter;
      const centerY = scale.yCenter;
      const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
      let angle = datasetStartAngle;
      let i;
      const defaultAngle = 360 / this.countVisibleElements();
      for (i = 0; i < start2; ++i) {
        angle += this._computeAngle(i, mode, defaultAngle);
      }
      for (i = start2; i < start2 + count; i++) {
        const arc = arcs[i];
        let startAngle = angle;
        let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
        let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
        angle = endAngle;
        if (reset) {
          if (animationOpts.animateScale) {
            outerRadius = 0;
          }
          if (animationOpts.animateRotate) {
            startAngle = endAngle = datasetStartAngle;
          }
        }
        const properties = {
          x: centerX,
          y: centerY,
          innerRadius: 0,
          outerRadius,
          startAngle,
          endAngle,
          options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
        };
        this.updateElement(arc, i, properties, mode);
      }
    }
    countVisibleElements() {
      const meta2 = this._cachedMeta;
      let count = 0;
      meta2.data.forEach((element, index3) => {
        if (!isNaN(this.getParsed(index3).r) && this.chart.getDataVisibility(index3)) {
          count++;
        }
      });
      return count;
    }
    _computeAngle(index3, mode, defaultAngle) {
      return this.chart.getDataVisibility(index3) ? toRadians(this.resolveDataElementOptions(index3, mode).angle || defaultAngle) : 0;
    }
  };
  PolarAreaController.id = "polarArea";
  PolarAreaController.defaults = {
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: true
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
      }
    },
    indexAxis: "r",
    startAngle: 0
  };
  PolarAreaController.overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle } } = chart.legend.options;
              return data.labels.map((label, i) => {
                const meta2 = chart.getDatasetMeta(0);
                const style = meta2.controller.getStyle(i);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i),
                  index: i
                };
              });
            }
            return [];
          }
        },
        onClick(e, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      },
      tooltip: {
        callbacks: {
          title() {
            return "";
          },
          label(context2) {
            return context2.chart.data.labels[context2.dataIndex] + ": " + context2.formattedValue;
          }
        }
      }
    },
    scales: {
      r: {
        type: "radialLinear",
        angleLines: {
          display: false
        },
        beginAtZero: true,
        grid: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        startAngle: 0
      }
    }
  };
  var PieController = class extends DoughnutController {
  };
  PieController.id = "pie";
  PieController.defaults = {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  };
  var RadarController = class extends DatasetController {
    getLabelAndValue(index3) {
      const vScale = this._cachedMeta.vScale;
      const parsed = this.getParsed(index3);
      return {
        label: vScale.getLabels()[index3],
        value: "" + vScale.getLabelForValue(parsed[vScale.axis])
      };
    }
    parseObjectData(meta2, data, start2, count) {
      return _parseObjectDataRadialScale.bind(this)(meta2, data, start2, count);
    }
    update(mode) {
      const meta2 = this._cachedMeta;
      const line = meta2.dataset;
      const points = meta2.data || [];
      const labels = meta2.iScale.getLabels();
      line.points = points;
      if (mode !== "resize") {
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
          options.borderWidth = 0;
        }
        const properties = {
          _loop: true,
          _fullLoop: labels.length === points.length,
          options
        };
        this.updateElement(line, void 0, properties, mode);
      }
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start2, count, mode) {
      const scale = this._cachedMeta.rScale;
      const reset = mode === "reset";
      for (let i = start2; i < start2 + count; i++) {
        const point = points[i];
        const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
        const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
        const x = reset ? scale.xCenter : pointPosition.x;
        const y2 = reset ? scale.yCenter : pointPosition.y;
        const properties = {
          x,
          y: y2,
          angle: pointPosition.angle,
          skip: isNaN(x) || isNaN(y2),
          options
        };
        this.updateElement(point, i, properties, mode);
      }
    }
  };
  RadarController.id = "radar";
  RadarController.defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    indexAxis: "r",
    showLine: true,
    elements: {
      line: {
        fill: "start"
      }
    }
  };
  RadarController.overrides = {
    aspectRatio: 1,
    scales: {
      r: {
        type: "radialLinear"
      }
    }
  };
  var Element2 = class {
    constructor() {
      this.x = void 0;
      this.y = void 0;
      this.active = false;
      this.options = void 0;
      this.$animations = void 0;
    }
    tooltipPosition(useFinalPosition) {
      const { x, y: y2 } = this.getProps(["x", "y"], useFinalPosition);
      return { x, y: y2 };
    }
    hasValue() {
      return isNumber2(this.x) && isNumber2(this.y);
    }
    getProps(props, final) {
      const anims = this.$animations;
      if (!final || !anims) {
        return this;
      }
      const ret = {};
      props.forEach((prop) => {
        ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
      });
      return ret;
    }
  };
  Element2.defaults = {};
  Element2.defaultRoutes = void 0;
  var formatters = {
    values(value) {
      return isArray2(value) ? value : "" + value;
    },
    numeric(tickValue, index3, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const locale = this.chart.options.locale;
      let notation;
      let delta = tickValue;
      if (ticks.length > 1) {
        const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
        if (maxTick < 1e-4 || maxTick > 1e15) {
          notation = "scientific";
        }
        delta = calculateDelta(tickValue, ticks);
      }
      const logDelta = log10(Math.abs(delta));
      const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
      const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
      Object.assign(options, this.options.ticks.format);
      return formatNumber2(tickValue, locale, options);
    },
    logarithmic(tickValue, index3, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
      if (remain === 1 || remain === 2 || remain === 5) {
        return formatters.numeric.call(this, tickValue, index3, ticks);
      }
      return "";
    }
  };
  function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
      delta = tickValue - Math.floor(tickValue);
    }
    return delta;
  }
  var Ticks = { formatters };
  defaults3.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawBorder: true,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false,
      borderDash: [],
      borderDashOffset: 0,
      borderWidth: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults3.route("scale.ticks", "color", "", "color");
  defaults3.route("scale.grid", "color", "", "borderColor");
  defaults3.route("scale.grid", "borderColor", "", "borderColor");
  defaults3.route("scale.title", "color", "", "color");
  defaults3.describe("scale", {
    _fallback: false,
    _scriptable: (name2) => !name2.startsWith("before") && !name2.startsWith("after") && name2 !== "callback" && name2 !== "parser",
    _indexable: (name2) => name2 !== "borderDash" && name2 !== "tickBorderDash"
  });
  defaults3.describe("scales", {
    _fallback: "scale"
  });
  defaults3.describe("scale.ticks", {
    _scriptable: (name2) => name2 !== "backdropPadding" && name2 !== "callback",
    _indexable: (name2) => name2 !== "backdropPadding"
  });
  function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
      skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
      return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
      let i, ilen;
      const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
      skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
      for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
        skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
      }
      skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
      return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
  }
  function determineMaxTicks(scale) {
    const offset = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
  }
  function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
      return Math.max(spacing, 1);
    }
    const factors = _factorize(evenMajorSpacing);
    for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
      const factor = factors[i];
      if (factor > spacing) {
        return factor;
      }
    }
    return Math.max(spacing, 1);
  }
  function getMajorIndices(ticks) {
    const result = [];
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (ticks[i].major) {
        result.push(i);
      }
    }
    return result;
  }
  function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i;
    spacing = Math.ceil(spacing);
    for (i = 0; i < ticks.length; i++) {
      if (i === next) {
        newTicks.push(ticks[i]);
        count++;
        next = majorIndices[count * spacing];
      }
    }
  }
  function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start2 = valueOrDefault(majorStart, 0);
    const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
      length = majorEnd - majorStart;
      spacing = length / Math.floor(length / spacing);
    }
    next = start2;
    while (next < 0) {
      count++;
      next = Math.round(start2 + count * spacing);
    }
    for (i = Math.max(start2, 0); i < end; i++) {
      if (i === next) {
        newTicks.push(ticks[i]);
        count++;
        next = Math.round(start2 + count * spacing);
      }
    }
  }
  function getEvenSpacing(arr) {
    const len = arr.length;
    let i, diff;
    if (len < 2) {
      return false;
    }
    for (diff = arr[0], i = 1; i < len; ++i) {
      if (arr[i] - arr[i - 1] !== diff) {
        return false;
      }
    }
    return diff;
  }
  var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
  var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
  function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i = 0;
    for (; i < len; i += increment) {
      result.push(arr[Math.floor(i)]);
    }
    return result;
  }
  function getPixelForGridLine(scale, index3, offsetGridLines) {
    const length = scale.ticks.length;
    const validIndex2 = Math.min(index3, length - 1);
    const start2 = scale._startPixel;
    const end = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex2);
    let offset;
    if (offsetGridLines) {
      if (length === 1) {
        offset = Math.max(lineValue - start2, end - lineValue);
      } else if (index3 === 0) {
        offset = (scale.getPixelForTick(1) - lineValue) / 2;
      } else {
        offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
      }
      lineValue += validIndex2 < index3 ? offset : -offset;
      if (lineValue < start2 - epsilon || lineValue > end + epsilon) {
        return;
      }
    }
    return lineValue;
  }
  function garbageCollect(caches, length) {
    each(caches, (cache) => {
      const gc2 = cache.gc;
      const gcLen = gc2.length / 2;
      let i;
      if (gcLen > length) {
        for (i = 0; i < gcLen; ++i) {
          delete cache.data[gc2[i]];
        }
        gc2.splice(0, gcLen);
      }
    });
  }
  function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
  }
  function getTitleHeight(options, fallback) {
    if (!options.display) {
      return 0;
    }
    const font = toFont(options.font, fallback);
    const padding = toPadding(options.padding);
    const lines = isArray2(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
  }
  function createScaleContext(parent, scale) {
    return createContext(parent, {
      scale,
      type: "scale"
    });
  }
  function createTickContext(parent, index3, tick) {
    return createContext(parent, {
      tick,
      index: index3,
      type: "tick"
    });
  }
  function titleAlign(align, position, reverse) {
    let ret = _toLeftRightCenter(align);
    if (reverse && position !== "right" || !reverse && position === "right") {
      ret = reverseAlign(ret);
    }
    return ret;
  }
  function titleArgs(scale, offset, position, align) {
    const { top: top2, left, bottom, right, chart } = scale;
    const { chartArea, scales: scales2 } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom - top2;
    const width = right - left;
    if (scale.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      if (isObject2(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
      } else if (position === "center") {
        titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
      } else {
        titleY = offsetFromEdge(scale, position, offset);
      }
      maxWidth = right - left;
    } else {
      if (isObject2(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
      } else if (position === "center") {
        titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
      } else {
        titleX = offsetFromEdge(scale, position, offset);
      }
      titleY = _alignStartEnd(align, bottom, top2);
      rotation = position === "left" ? -HALF_PI : HALF_PI;
    }
    return { titleX, titleY, maxWidth, rotation };
  }
  var Scale2 = class extends Element2 {
    constructor(cfg) {
      super();
      this.id = cfg.id;
      this.type = cfg.type;
      this.options = void 0;
      this.ctx = cfg.ctx;
      this.chart = cfg.chart;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      this.maxWidth = void 0;
      this.maxHeight = void 0;
      this.paddingTop = void 0;
      this.paddingBottom = void 0;
      this.paddingLeft = void 0;
      this.paddingRight = void 0;
      this.axis = void 0;
      this.labelRotation = void 0;
      this.min = void 0;
      this.max = void 0;
      this._range = void 0;
      this.ticks = [];
      this._gridLineItems = null;
      this._labelItems = null;
      this._labelSizes = null;
      this._length = 0;
      this._maxLength = 0;
      this._longestTextCache = {};
      this._startPixel = void 0;
      this._endPixel = void 0;
      this._reversePixels = false;
      this._userMax = void 0;
      this._userMin = void 0;
      this._suggestedMax = void 0;
      this._suggestedMin = void 0;
      this._ticksLength = 0;
      this._borderValue = 0;
      this._cache = {};
      this._dataLimitsCached = false;
      this.$context = void 0;
    }
    init(options) {
      this.options = options.setContext(this.getContext());
      this.axis = options.axis;
      this._userMin = this.parse(options.min);
      this._userMax = this.parse(options.max);
      this._suggestedMin = this.parse(options.suggestedMin);
      this._suggestedMax = this.parse(options.suggestedMax);
    }
    parse(raw, index3) {
      return raw;
    }
    getUserBounds() {
      let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
      _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
      _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
      _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
      _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
      return {
        min: finiteOrDefault(_userMin, _suggestedMin),
        max: finiteOrDefault(_userMax, _suggestedMax),
        minDefined: isNumberFinite(_userMin),
        maxDefined: isNumberFinite(_userMax)
      };
    }
    getMinMax(canStack) {
      let { min, max, minDefined, maxDefined } = this.getUserBounds();
      let range10;
      if (minDefined && maxDefined) {
        return { min, max };
      }
      const metas = this.getMatchingVisibleMetas();
      for (let i = 0, ilen = metas.length; i < ilen; ++i) {
        range10 = metas[i].controller.getMinMax(this, canStack);
        if (!minDefined) {
          min = Math.min(min, range10.min);
        }
        if (!maxDefined) {
          max = Math.max(max, range10.max);
        }
      }
      min = maxDefined && min > max ? max : min;
      max = minDefined && min > max ? min : max;
      return {
        min: finiteOrDefault(min, finiteOrDefault(max, min)),
        max: finiteOrDefault(max, finiteOrDefault(min, max))
      };
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      };
    }
    getTicks() {
      return this.ticks;
    }
    getLabels() {
      const data = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
    }
    beforeLayout() {
      this._cache = {};
      this._dataLimitsCached = false;
    }
    beforeUpdate() {
      callback(this.options.beforeUpdate, [this]);
    }
    update(maxWidth, maxHeight, margins) {
      const { beginAtZero, grace, ticks: tickOpts } = this.options;
      const sampleSize = tickOpts.sampleSize;
      this.beforeUpdate();
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, margins);
      this.ticks = null;
      this._labelSizes = null;
      this._gridLineItems = null;
      this._labelItems = null;
      this.beforeSetDimensions();
      this.setDimensions();
      this.afterSetDimensions();
      this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
      if (!this._dataLimitsCached) {
        this.beforeDataLimits();
        this.determineDataLimits();
        this.afterDataLimits();
        this._range = _addGrace(this, grace, beginAtZero);
        this._dataLimitsCached = true;
      }
      this.beforeBuildTicks();
      this.ticks = this.buildTicks() || [];
      this.afterBuildTicks();
      const samplingEnabled = sampleSize < this.ticks.length;
      this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
      this.configure();
      this.beforeCalculateLabelRotation();
      this.calculateLabelRotation();
      this.afterCalculateLabelRotation();
      if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
        this.ticks = autoSkip(this, this.ticks);
        this._labelSizes = null;
        this.afterAutoSkip();
      }
      if (samplingEnabled) {
        this._convertTicksToLabels(this.ticks);
      }
      this.beforeFit();
      this.fit();
      this.afterFit();
      this.afterUpdate();
    }
    configure() {
      let reversePixels = this.options.reverse;
      let startPixel, endPixel;
      if (this.isHorizontal()) {
        startPixel = this.left;
        endPixel = this.right;
      } else {
        startPixel = this.top;
        endPixel = this.bottom;
        reversePixels = !reversePixels;
      }
      this._startPixel = startPixel;
      this._endPixel = endPixel;
      this._reversePixels = reversePixels;
      this._length = endPixel - startPixel;
      this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
      callback(this.options.afterUpdate, [this]);
    }
    beforeSetDimensions() {
      callback(this.options.beforeSetDimensions, [this]);
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = 0;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = 0;
        this.bottom = this.height;
      }
      this.paddingLeft = 0;
      this.paddingTop = 0;
      this.paddingRight = 0;
      this.paddingBottom = 0;
    }
    afterSetDimensions() {
      callback(this.options.afterSetDimensions, [this]);
    }
    _callHooks(name2) {
      this.chart.notifyPlugins(name2, this.getContext());
      callback(this.options[name2], [this]);
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {
    }
    afterDataLimits() {
      this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
      return [];
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
      callback(this.options.beforeTickToLabelConversion, [this]);
    }
    generateTickLabels(ticks) {
      const tickOpts = this.options.ticks;
      let i, ilen, tick;
      for (i = 0, ilen = ticks.length; i < ilen; i++) {
        tick = ticks[i];
        tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);
      }
    }
    afterTickToLabelConversion() {
      callback(this.options.afterTickToLabelConversion, [this]);
    }
    beforeCalculateLabelRotation() {
      callback(this.options.beforeCalculateLabelRotation, [this]);
    }
    calculateLabelRotation() {
      const options = this.options;
      const tickOpts = options.ticks;
      const numTicks = this.ticks.length;
      const minRotation = tickOpts.minRotation || 0;
      const maxRotation = tickOpts.maxRotation;
      let labelRotation = minRotation;
      let tickWidth, maxHeight, maxLabelDiagonal;
      if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
        this.labelRotation = minRotation;
        return;
      }
      const labelSizes = this._getLabelSizes();
      const maxLabelWidth = labelSizes.widest.width;
      const maxLabelHeight = labelSizes.highest.height;
      const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
      tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
      if (maxLabelWidth + 6 > tickWidth) {
        tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
        maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
        maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
        labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
        labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
      }
      this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
      callback(this.options.afterCalculateLabelRotation, [this]);
    }
    afterAutoSkip() {
    }
    beforeFit() {
      callback(this.options.beforeFit, [this]);
    }
    fit() {
      const minSize = {
        width: 0,
        height: 0
      };
      const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
      const display = this._isVisible();
      const isHorizontal = this.isHorizontal();
      if (display) {
        const titleHeight = getTitleHeight(titleOpts, chart.options.font);
        if (isHorizontal) {
          minSize.width = this.maxWidth;
          minSize.height = getTickMarkLength(gridOpts) + titleHeight;
        } else {
          minSize.height = this.maxHeight;
          minSize.width = getTickMarkLength(gridOpts) + titleHeight;
        }
        if (tickOpts.display && this.ticks.length) {
          const { first, last, widest, highest } = this._getLabelSizes();
          const tickPadding = tickOpts.padding * 2;
          const angleRadians = toRadians(this.labelRotation);
          const cos = Math.cos(angleRadians);
          const sin = Math.sin(angleRadians);
          if (isHorizontal) {
            const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
            minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
          } else {
            const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
            minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
          }
          this._calculatePadding(first, last, sin, cos);
        }
      }
      this._handleMargins();
      if (isHorizontal) {
        this.width = this._length = chart.width - this._margins.left - this._margins.right;
        this.height = minSize.height;
      } else {
        this.width = minSize.width;
        this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
      }
    }
    _calculatePadding(first, last, sin, cos) {
      const { ticks: { align, padding }, position } = this.options;
      const isRotated = this.labelRotation !== 0;
      const labelsBelowTicks = position !== "top" && this.axis === "x";
      if (this.isHorizontal()) {
        const offsetLeft = this.getPixelForTick(0) - this.left;
        const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
        let paddingLeft = 0;
        let paddingRight = 0;
        if (isRotated) {
          if (labelsBelowTicks) {
            paddingLeft = cos * first.width;
            paddingRight = sin * last.height;
          } else {
            paddingLeft = sin * first.height;
            paddingRight = cos * last.width;
          }
        } else if (align === "start") {
          paddingRight = last.width;
        } else if (align === "end") {
          paddingLeft = first.width;
        } else if (align !== "inner") {
          paddingLeft = first.width / 2;
          paddingRight = last.width / 2;
        }
        this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
        this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
      } else {
        let paddingTop = last.height / 2;
        let paddingBottom = first.height / 2;
        if (align === "start") {
          paddingTop = 0;
          paddingBottom = first.height;
        } else if (align === "end") {
          paddingTop = last.height;
          paddingBottom = 0;
        }
        this.paddingTop = paddingTop + padding;
        this.paddingBottom = paddingBottom + padding;
      }
    }
    _handleMargins() {
      if (this._margins) {
        this._margins.left = Math.max(this.paddingLeft, this._margins.left);
        this._margins.top = Math.max(this.paddingTop, this._margins.top);
        this._margins.right = Math.max(this.paddingRight, this._margins.right);
        this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
      }
    }
    afterFit() {
      callback(this.options.afterFit, [this]);
    }
    isHorizontal() {
      const { axis, position } = this.options;
      return position === "top" || position === "bottom" || axis === "x";
    }
    isFullSize() {
      return this.options.fullSize;
    }
    _convertTicksToLabels(ticks) {
      this.beforeTickToLabelConversion();
      this.generateTickLabels(ticks);
      let i, ilen;
      for (i = 0, ilen = ticks.length; i < ilen; i++) {
        if (isNullOrUndef(ticks[i].label)) {
          ticks.splice(i, 1);
          ilen--;
          i--;
        }
      }
      this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
      let labelSizes = this._labelSizes;
      if (!labelSizes) {
        const sampleSize = this.options.ticks.sampleSize;
        let ticks = this.ticks;
        if (sampleSize < ticks.length) {
          ticks = sample(ticks, sampleSize);
        }
        this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
      }
      return labelSizes;
    }
    _computeLabelSizes(ticks, length) {
      const { ctx, _longestTextCache: caches } = this;
      const widths = [];
      const heights = [];
      let widestLabelSize = 0;
      let highestLabelSize = 0;
      let i, j2, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
      for (i = 0; i < length; ++i) {
        label = ticks[i].label;
        tickFont = this._resolveTickFontOptions(i);
        ctx.font = fontString = tickFont.string;
        cache = caches[fontString] = caches[fontString] || { data: {}, gc: [] };
        lineHeight = tickFont.lineHeight;
        width = height = 0;
        if (!isNullOrUndef(label) && !isArray2(label)) {
          width = _measureText(ctx, cache.data, cache.gc, width, label);
          height = lineHeight;
        } else if (isArray2(label)) {
          for (j2 = 0, jlen = label.length; j2 < jlen; ++j2) {
            nestedLabel = label[j2];
            if (!isNullOrUndef(nestedLabel) && !isArray2(nestedLabel)) {
              width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
              height += lineHeight;
            }
          }
        }
        widths.push(width);
        heights.push(height);
        widestLabelSize = Math.max(width, widestLabelSize);
        highestLabelSize = Math.max(height, highestLabelSize);
      }
      garbageCollect(caches, length);
      const widest = widths.indexOf(widestLabelSize);
      const highest = heights.indexOf(highestLabelSize);
      const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
      return {
        first: valueAt(0),
        last: valueAt(length - 1),
        widest: valueAt(widest),
        highest: valueAt(highest),
        widths,
        heights
      };
    }
    getLabelForValue(value) {
      return value;
    }
    getPixelForValue(value, index3) {
      return NaN;
    }
    getValueForPixel(pixel) {
    }
    getPixelForTick(index3) {
      const ticks = this.ticks;
      if (index3 < 0 || index3 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index3].value);
    }
    getPixelForDecimal(decimal) {
      if (this._reversePixels) {
        decimal = 1 - decimal;
      }
      const pixel = this._startPixel + decimal * this._length;
      return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
    }
    getDecimalForPixel(pixel) {
      const decimal = (pixel - this._startPixel) / this._length;
      return this._reversePixels ? 1 - decimal : decimal;
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
      const { min, max } = this;
      return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
    }
    getContext(index3) {
      const ticks = this.ticks || [];
      if (index3 >= 0 && index3 < ticks.length) {
        const tick = ticks[index3];
        return tick.$context || (tick.$context = createTickContext(this.getContext(), index3, tick));
      }
      return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
    _tickSize() {
      const optionTicks = this.options.ticks;
      const rot = toRadians(this.labelRotation);
      const cos = Math.abs(Math.cos(rot));
      const sin = Math.abs(Math.sin(rot));
      const labelSizes = this._getLabelSizes();
      const padding = optionTicks.autoSkipPadding || 0;
      const w = labelSizes ? labelSizes.widest.width + padding : 0;
      const h3 = labelSizes ? labelSizes.highest.height + padding : 0;
      return this.isHorizontal() ? h3 * cos > w * sin ? w / cos : h3 / sin : h3 * sin < w * cos ? h3 / cos : w / sin;
    }
    _isVisible() {
      const display = this.options.display;
      if (display !== "auto") {
        return !!display;
      }
      return this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(chartArea) {
      const axis = this.axis;
      const chart = this.chart;
      const options = this.options;
      const { grid, position } = options;
      const offset = grid.offset;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const ticksLength = ticks.length + (offset ? 1 : 0);
      const tl3 = getTickMarkLength(grid);
      const items = [];
      const borderOpts = grid.setContext(this.getContext());
      const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
      const axisHalfWidth = axisWidth / 2;
      const alignBorderValue = function(pixel) {
        return _alignPixel(chart, pixel, axisWidth);
      };
      let borderValue, i, lineValue, alignedLineValue;
      let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
      if (position === "top") {
        borderValue = alignBorderValue(this.bottom);
        ty1 = this.bottom - tl3;
        ty2 = borderValue - axisHalfWidth;
        y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
        y2 = chartArea.bottom;
      } else if (position === "bottom") {
        borderValue = alignBorderValue(this.top);
        y1 = chartArea.top;
        y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
        ty1 = borderValue + axisHalfWidth;
        ty2 = this.top + tl3;
      } else if (position === "left") {
        borderValue = alignBorderValue(this.right);
        tx1 = this.right - tl3;
        tx2 = borderValue - axisHalfWidth;
        x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
        x2 = chartArea.right;
      } else if (position === "right") {
        borderValue = alignBorderValue(this.left);
        x1 = chartArea.left;
        x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
        tx1 = borderValue + axisHalfWidth;
        tx2 = this.left + tl3;
      } else if (axis === "x") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        y1 = chartArea.top;
        y2 = chartArea.bottom;
        ty1 = borderValue + axisHalfWidth;
        ty2 = ty1 + tl3;
      } else if (axis === "y") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        tx1 = borderValue - axisHalfWidth;
        tx2 = tx1 - tl3;
        x1 = chartArea.left;
        x2 = chartArea.right;
      }
      const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
      const step = Math.max(1, Math.ceil(ticksLength / limit));
      for (i = 0; i < ticksLength; i += step) {
        const optsAtIndex = grid.setContext(this.getContext(i));
        const lineWidth = optsAtIndex.lineWidth;
        const lineColor = optsAtIndex.color;
        const borderDash = optsAtIndex.borderDash || [];
        const borderDashOffset = optsAtIndex.borderDashOffset;
        const tickWidth = optsAtIndex.tickWidth;
        const tickColor = optsAtIndex.tickColor;
        const tickBorderDash = optsAtIndex.tickBorderDash || [];
        const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
        lineValue = getPixelForGridLine(this, i, offset);
        if (lineValue === void 0) {
          continue;
        }
        alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
        if (isHorizontal) {
          tx1 = tx2 = x1 = x2 = alignedLineValue;
        } else {
          ty1 = ty2 = y1 = y2 = alignedLineValue;
        }
        items.push({
          tx1,
          ty1,
          tx2,
          ty2,
          x1,
          y1,
          x2,
          y2,
          width: lineWidth,
          color: lineColor,
          borderDash,
          borderDashOffset,
          tickWidth,
          tickColor,
          tickBorderDash,
          tickBorderDashOffset
        });
      }
      this._ticksLength = ticksLength;
      this._borderValue = borderValue;
      return items;
    }
    _computeLabelItems(chartArea) {
      const axis = this.axis;
      const options = this.options;
      const { position, ticks: optionTicks } = options;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const { align, crossAlign, padding, mirror } = optionTicks;
      const tl3 = getTickMarkLength(options.grid);
      const tickAndPadding = tl3 + padding;
      const hTickAndPadding = mirror ? -padding : tickAndPadding;
      const rotation = -toRadians(this.labelRotation);
      const items = [];
      let i, ilen, tick, label, x, y2, textAlign, pixel, font, lineHeight, lineCount, textOffset;
      let textBaseline = "middle";
      if (position === "top") {
        y2 = this.bottom - hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "bottom") {
        y2 = this.top + hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "left") {
        const ret = this._getYAxisLabelAlignment(tl3);
        textAlign = ret.textAlign;
        x = ret.x;
      } else if (position === "right") {
        const ret = this._getYAxisLabelAlignment(tl3);
        textAlign = ret.textAlign;
        x = ret.x;
      } else if (axis === "x") {
        if (position === "center") {
          y2 = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          y2 = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
        }
        textAlign = this._getXAxisLabelAlignment();
      } else if (axis === "y") {
        if (position === "center") {
          x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          x = this.chart.scales[positionAxisID].getPixelForValue(value);
        }
        textAlign = this._getYAxisLabelAlignment(tl3).textAlign;
      }
      if (axis === "y") {
        if (align === "start") {
          textBaseline = "top";
        } else if (align === "end") {
          textBaseline = "bottom";
        }
      }
      const labelSizes = this._getLabelSizes();
      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        tick = ticks[i];
        label = tick.label;
        const optsAtIndex = optionTicks.setContext(this.getContext(i));
        pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
        font = this._resolveTickFontOptions(i);
        lineHeight = font.lineHeight;
        lineCount = isArray2(label) ? label.length : 1;
        const halfCount = lineCount / 2;
        const color19 = optsAtIndex.color;
        const strokeColor = optsAtIndex.textStrokeColor;
        const strokeWidth = optsAtIndex.textStrokeWidth;
        let tickTextAlign = textAlign;
        if (isHorizontal) {
          x = pixel;
          if (textAlign === "inner") {
            if (i === ilen - 1) {
              tickTextAlign = !this.options.reverse ? "right" : "left";
            } else if (i === 0) {
              tickTextAlign = !this.options.reverse ? "left" : "right";
            } else {
              tickTextAlign = "center";
            }
          }
          if (position === "top") {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = -lineCount * lineHeight + lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
            } else {
              textOffset = -labelSizes.highest.height + lineHeight / 2;
            }
          } else {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
            } else {
              textOffset = labelSizes.highest.height - lineCount * lineHeight;
            }
          }
          if (mirror) {
            textOffset *= -1;
          }
        } else {
          y2 = pixel;
          textOffset = (1 - lineCount) * lineHeight / 2;
        }
        let backdrop;
        if (optsAtIndex.showLabelBackdrop) {
          const labelPadding = toPadding(optsAtIndex.backdropPadding);
          const height = labelSizes.heights[i];
          const width = labelSizes.widths[i];
          let top2 = y2 + textOffset - labelPadding.top;
          let left = x - labelPadding.left;
          switch (textBaseline) {
            case "middle":
              top2 -= height / 2;
              break;
            case "bottom":
              top2 -= height;
              break;
          }
          switch (textAlign) {
            case "center":
              left -= width / 2;
              break;
            case "right":
              left -= width;
              break;
          }
          backdrop = {
            left,
            top: top2,
            width: width + labelPadding.width,
            height: height + labelPadding.height,
            color: optsAtIndex.backdropColor
          };
        }
        items.push({
          rotation,
          label,
          font,
          color: color19,
          strokeColor,
          strokeWidth,
          textOffset,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [x, y2],
          backdrop
        });
      }
      return items;
    }
    _getXAxisLabelAlignment() {
      const { position, ticks } = this.options;
      const rotation = -toRadians(this.labelRotation);
      if (rotation) {
        return position === "top" ? "left" : "right";
      }
      let align = "center";
      if (ticks.align === "start") {
        align = "left";
      } else if (ticks.align === "end") {
        align = "right";
      } else if (ticks.align === "inner") {
        align = "inner";
      }
      return align;
    }
    _getYAxisLabelAlignment(tl3) {
      const { position, ticks: { crossAlign, mirror, padding } } = this.options;
      const labelSizes = this._getLabelSizes();
      const tickAndPadding = tl3 + padding;
      const widest = labelSizes.widest.width;
      let textAlign;
      let x;
      if (position === "left") {
        if (mirror) {
          x = this.right + padding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x += widest / 2;
          } else {
            textAlign = "right";
            x += widest;
          }
        } else {
          x = this.right - tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x -= widest / 2;
          } else {
            textAlign = "left";
            x = this.left;
          }
        }
      } else if (position === "right") {
        if (mirror) {
          x = this.left + padding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x -= widest / 2;
          } else {
            textAlign = "left";
            x -= widest;
          }
        } else {
          x = this.left + tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x += widest / 2;
          } else {
            textAlign = "right";
            x = this.right;
          }
        }
      } else {
        textAlign = "right";
      }
      return { textAlign, x };
    }
    _computeLabelArea() {
      if (this.options.ticks.mirror) {
        return;
      }
      const chart = this.chart;
      const position = this.options.position;
      if (position === "left" || position === "right") {
        return { top: 0, left: this.left, bottom: chart.height, right: this.right };
      }
      if (position === "top" || position === "bottom") {
        return { top: this.top, left: 0, bottom: this.bottom, right: chart.width };
      }
    }
    drawBackground() {
      const { ctx, options: { backgroundColor }, left, top: top2, width, height } = this;
      if (backgroundColor) {
        ctx.save();
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(left, top2, width, height);
        ctx.restore();
      }
    }
    getLineWidthForValue(value) {
      const grid = this.options.grid;
      if (!this._isVisible() || !grid.display) {
        return 0;
      }
      const ticks = this.ticks;
      const index3 = ticks.findIndex((t2) => t2.value === value);
      if (index3 >= 0) {
        const opts = grid.setContext(this.getContext(index3));
        return opts.lineWidth;
      }
      return 0;
    }
    drawGrid(chartArea) {
      const grid = this.options.grid;
      const ctx = this.ctx;
      const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
      let i, ilen;
      const drawLine = (p1, p2, style) => {
        if (!style.width || !style.color) {
          return;
        }
        ctx.save();
        ctx.lineWidth = style.width;
        ctx.strokeStyle = style.color;
        ctx.setLineDash(style.borderDash || []);
        ctx.lineDashOffset = style.borderDashOffset;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        ctx.restore();
      };
      if (grid.display) {
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          const item = items[i];
          if (grid.drawOnChartArea) {
            drawLine({ x: item.x1, y: item.y1 }, { x: item.x2, y: item.y2 }, item);
          }
          if (grid.drawTicks) {
            drawLine({ x: item.tx1, y: item.ty1 }, { x: item.tx2, y: item.ty2 }, {
              color: item.tickColor,
              width: item.tickWidth,
              borderDash: item.tickBorderDash,
              borderDashOffset: item.tickBorderDashOffset
            });
          }
        }
      }
    }
    drawBorder() {
      const { chart, ctx, options: { grid } } = this;
      const borderOpts = grid.setContext(this.getContext());
      const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
      if (!axisWidth) {
        return;
      }
      const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
      const borderValue = this._borderValue;
      let x1, x2, y1, y2;
      if (this.isHorizontal()) {
        x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
        x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
        y1 = y2 = borderValue;
      } else {
        y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
        y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
        x1 = x2 = borderValue;
      }
      ctx.save();
      ctx.lineWidth = borderOpts.borderWidth;
      ctx.strokeStyle = borderOpts.borderColor;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.restore();
    }
    drawLabels(chartArea) {
      const optionTicks = this.options.ticks;
      if (!optionTicks.display) {
        return;
      }
      const ctx = this.ctx;
      const area = this._computeLabelArea();
      if (area) {
        clipArea(ctx, area);
      }
      const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
      let i, ilen;
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        const tickFont = item.font;
        const label = item.label;
        if (item.backdrop) {
          ctx.fillStyle = item.backdrop.color;
          ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
        }
        let y2 = item.textOffset;
        renderText(ctx, label, 0, y2, tickFont, item);
      }
      if (area) {
        unclipArea(ctx);
      }
    }
    drawTitle() {
      const { ctx, options: { position, title, reverse } } = this;
      if (!title.display) {
        return;
      }
      const font = toFont(title.font);
      const padding = toPadding(title.padding);
      const align = title.align;
      let offset = font.lineHeight / 2;
      if (position === "bottom" || position === "center" || isObject2(position)) {
        offset += padding.bottom;
        if (isArray2(title.text)) {
          offset += font.lineHeight * (title.text.length - 1);
        }
      } else {
        offset += padding.top;
      }
      const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
      renderText(ctx, title.text, 0, 0, font, {
        color: title.color,
        maxWidth,
        rotation,
        textAlign: titleAlign(align, position, reverse),
        textBaseline: "middle",
        translation: [titleX, titleY]
      });
    }
    draw(chartArea) {
      if (!this._isVisible()) {
        return;
      }
      this.drawBackground();
      this.drawGrid(chartArea);
      this.drawBorder();
      this.drawTitle();
      this.drawLabels(chartArea);
    }
    _layers() {
      const opts = this.options;
      const tz = opts.ticks && opts.ticks.z || 0;
      const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
      if (!this._isVisible() || this.draw !== Scale2.prototype.draw) {
        return [{
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }];
      }
      return [{
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      }, {
        z: gz + 1,
        draw: () => {
          this.drawBorder();
        }
      }, {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }];
    }
    getMatchingVisibleMetas(type) {
      const metas = this.chart.getSortedVisibleDatasetMetas();
      const axisID = this.axis + "AxisID";
      const result = [];
      let i, ilen;
      for (i = 0, ilen = metas.length; i < ilen; ++i) {
        const meta2 = metas[i];
        if (meta2[axisID] === this.id && (!type || meta2.type === type)) {
          result.push(meta2);
        }
      }
      return result;
    }
    _resolveTickFontOptions(index3) {
      const opts = this.options.ticks.setContext(this.getContext(index3));
      return toFont(opts.font);
    }
    _maxDigits() {
      const fontSize = this._resolveTickFontOptions(0).lineHeight;
      return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
  };
  var TypedRegistry = class {
    constructor(type, scope, override) {
      this.type = type;
      this.scope = scope;
      this.override = override;
      this.items = Object.create(null);
    }
    isForType(type) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
    register(item) {
      const proto = Object.getPrototypeOf(item);
      let parentScope;
      if (isIChartComponent(proto)) {
        parentScope = this.register(proto);
      }
      const items = this.items;
      const id2 = item.id;
      const scope = this.scope + "." + id2;
      if (!id2) {
        throw new Error("class does not have id: " + item);
      }
      if (id2 in items) {
        return scope;
      }
      items[id2] = item;
      registerDefaults(item, scope, parentScope);
      if (this.override) {
        defaults3.override(item.id, item.overrides);
      }
      return scope;
    }
    get(id2) {
      return this.items[id2];
    }
    unregister(item) {
      const items = this.items;
      const id2 = item.id;
      const scope = this.scope;
      if (id2 in items) {
        delete items[id2];
      }
      if (scope && id2 in defaults3[scope]) {
        delete defaults3[scope][id2];
        if (this.override) {
          delete overrides2[id2];
        }
      }
    }
  };
  function registerDefaults(item, scope, parentScope) {
    const itemDefaults = merge(Object.create(null), [
      parentScope ? defaults3.get(parentScope) : {},
      defaults3.get(scope),
      item.defaults
    ]);
    defaults3.set(scope, itemDefaults);
    if (item.defaultRoutes) {
      routeDefaults(scope, item.defaultRoutes);
    }
    if (item.descriptors) {
      defaults3.describe(scope, item.descriptors);
    }
  }
  function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property) => {
      const propertyParts = property.split(".");
      const sourceName = propertyParts.pop();
      const sourceScope = [scope].concat(propertyParts).join(".");
      const parts = routes[property].split(".");
      const targetName = parts.pop();
      const targetScope = parts.join(".");
      defaults3.route(sourceScope, sourceName, targetScope, targetName);
    });
  }
  function isIChartComponent(proto) {
    return "id" in proto && "defaults" in proto;
  }
  var Registry = class {
    constructor() {
      this.controllers = new TypedRegistry(DatasetController, "datasets", true);
      this.elements = new TypedRegistry(Element2, "elements");
      this.plugins = new TypedRegistry(Object, "plugins");
      this.scales = new TypedRegistry(Scale2, "scales");
      this._typedRegistries = [this.controllers, this.scales, this.elements];
    }
    add(...args) {
      this._each("register", args);
    }
    remove(...args) {
      this._each("unregister", args);
    }
    addControllers(...args) {
      this._each("register", args, this.controllers);
    }
    addElements(...args) {
      this._each("register", args, this.elements);
    }
    addPlugins(...args) {
      this._each("register", args, this.plugins);
    }
    addScales(...args) {
      this._each("register", args, this.scales);
    }
    getController(id2) {
      return this._get(id2, this.controllers, "controller");
    }
    getElement(id2) {
      return this._get(id2, this.elements, "element");
    }
    getPlugin(id2) {
      return this._get(id2, this.plugins, "plugin");
    }
    getScale(id2) {
      return this._get(id2, this.scales, "scale");
    }
    removeControllers(...args) {
      this._each("unregister", args, this.controllers);
    }
    removeElements(...args) {
      this._each("unregister", args, this.elements);
    }
    removePlugins(...args) {
      this._each("unregister", args, this.plugins);
    }
    removeScales(...args) {
      this._each("unregister", args, this.scales);
    }
    _each(method, args, typedRegistry) {
      [...args].forEach((arg) => {
        const reg = typedRegistry || this._getRegistryForType(arg);
        if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
          this._exec(method, reg, arg);
        } else {
          each(arg, (item) => {
            const itemReg = typedRegistry || this._getRegistryForType(item);
            this._exec(method, itemReg, item);
          });
        }
      });
    }
    _exec(method, registry2, component) {
      const camelMethod = _capitalize(method);
      callback(component["before" + camelMethod], [], component);
      registry2[method](component);
      callback(component["after" + camelMethod], [], component);
    }
    _getRegistryForType(type) {
      for (let i = 0; i < this._typedRegistries.length; i++) {
        const reg = this._typedRegistries[i];
        if (reg.isForType(type)) {
          return reg;
        }
      }
      return this.plugins;
    }
    _get(id2, typedRegistry, type) {
      const item = typedRegistry.get(id2);
      if (item === void 0) {
        throw new Error('"' + id2 + '" is not a registered ' + type + ".");
      }
      return item;
    }
  };
  var registry = new Registry();
  var ScatterController = class extends DatasetController {
    update(mode) {
      const meta2 = this._cachedMeta;
      const { data: points = [] } = meta2;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start: start2, count } = _getStartAndCountOfVisiblePoints(meta2, points, animationsDisabled);
      this._drawStart = start2;
      this._drawCount = count;
      if (_scaleRangesChanged(meta2)) {
        start2 = 0;
        count = points.length;
      }
      if (this.options.showLine) {
        const { dataset: line, _dataset } = meta2;
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        options.segment = this.options.segment;
        this.updateElement(line, void 0, {
          animated: !animationsDisabled,
          options
        }, mode);
      }
      this.updateElements(points, start2, count, mode);
    }
    addElements() {
      const { showLine } = this.options;
      if (!this.datasetElementType && showLine) {
        this.datasetElementType = registry.getElement("line");
      }
      super.addElements();
    }
    updateElements(points, start2, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const firstOpts = this.resolveDataElementOptions(start2, mode);
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber2(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      let prevParsed = start2 > 0 && this.getParsed(start2 - 1);
      for (let i = start2; i < start2 + count; ++i) {
        const point = points[i];
        const parsed = this.getParsed(i);
        const properties = directUpdate ? point : {};
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i, properties, mode);
        }
        prevParsed = parsed;
      }
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
    getMaxOverflow() {
      const meta2 = this._cachedMeta;
      const data = meta2.data || [];
      if (!this.options.showLine) {
        let max = 0;
        for (let i = data.length - 1; i >= 0; --i) {
          max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
        }
        return max > 0 && max;
      }
      const dataset = meta2.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
  };
  ScatterController.id = "scatter";
  ScatterController.defaults = {
    datasetElementType: false,
    dataElementType: "point",
    showLine: false,
    fill: false
  };
  ScatterController.overrides = {
    interaction: {
      mode: "point"
    },
    plugins: {
      tooltip: {
        callbacks: {
          title() {
            return "";
          },
          label(item) {
            return "(" + item.label + ", " + item.formattedValue + ")";
          }
        }
      }
    },
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  };
  var controllers = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BarController,
    BubbleController,
    DoughnutController,
    LineController,
    PolarAreaController,
    PieController,
    RadarController,
    ScatterController
  });
  function abstract() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
  }
  var DateAdapter = class {
    constructor(options) {
      this.options = options || {};
    }
    init(chartOptions) {
    }
    formats() {
      return abstract();
    }
    parse(value, format) {
      return abstract();
    }
    format(timestamp, format) {
      return abstract();
    }
    add(timestamp, amount, unit) {
      return abstract();
    }
    diff(a, b, unit) {
      return abstract();
    }
    startOf(timestamp, unit, weekday) {
      return abstract();
    }
    endOf(timestamp, unit) {
      return abstract();
    }
  };
  DateAdapter.override = function(members) {
    Object.assign(DateAdapter.prototype, members);
  };
  var adapters = {
    _date: DateAdapter
  };
  function binarySearch(metaset, axis, value, intersect) {
    const { controller, data, _sorted } = metaset;
    const iScale = controller._cachedMeta.iScale;
    if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
      const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
      if (!intersect) {
        return lookupMethod(data, axis, value);
      } else if (controller._sharedOptions) {
        const el3 = data[0];
        const range10 = typeof el3.getRange === "function" && el3.getRange(axis);
        if (range10) {
          const start2 = lookupMethod(data, axis, value - range10);
          const end = lookupMethod(data, axis, value + range10);
          return { lo: start2.lo, hi: end.hi };
        }
      }
    }
    return { lo: 0, hi: data.length - 1 };
  }
  function evaluateInteractionItems(chart, axis, position, handler2, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
      const { index: index3, data } = metasets[i];
      const { lo: lo2, hi: hi3 } = binarySearch(metasets[i], axis, value, intersect);
      for (let j2 = lo2; j2 <= hi3; ++j2) {
        const element = data[j2];
        if (!element.skip) {
          handler2(element, index3, j2);
        }
      }
    }
  }
  function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf("x") !== -1;
    const useY = axis.indexOf("y") !== -1;
    return function(pt1, pt2) {
      const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
      const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
  }
  function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return items;
    }
    const evaluationFunc = function(element, datasetIndex, index3) {
      if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
        return;
      }
      if (element.inRange(position.x, position.y, useFinalPosition)) {
        items.push({ element, datasetIndex, index: index3 });
      }
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
  }
  function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index3) {
      const { startAngle, endAngle } = element.getProps(["startAngle", "endAngle"], useFinalPosition);
      const { angle } = getAngleFromPoint(element, { x: position.x, y: position.y });
      if (_angleBetween(angle, startAngle, endAngle)) {
        items.push({ element, datasetIndex, index: index3 });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index3) {
      const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
      if (intersect && !inRange2) {
        return;
      }
      const center = element.getCenterPoint(useFinalPosition);
      const pointInArea = !!includeInvisible || chart.isPointInArea(center);
      if (!pointInArea && !inRange2) {
        return;
      }
      const distance = distanceMetric(position, center);
      if (distance < minDistance) {
        items = [{ element, datasetIndex, index: index3 }];
        minDistance = distance;
      } else if (distance === minDistance) {
        items.push({ element, datasetIndex, index: index3 });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return [];
    }
    return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
  }
  function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index3) => {
      if (element[rangeMethod](position[axis], useFinalPosition)) {
        items.push({ element, datasetIndex, index: index3 });
        intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
      }
    });
    if (intersect && !intersectsItem) {
      return [];
    }
    return items;
  }
  var Interaction = {
    evaluateInteractionItems,
    modes: {
      index(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "x";
        const includeInvisible = options.includeInvisible || false;
        const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        const elements2 = [];
        if (!items.length) {
          return [];
        }
        chart.getSortedVisibleDatasetMetas().forEach((meta2) => {
          const index3 = items[0].index;
          const element = meta2.data[index3];
          if (element && !element.skip) {
            elements2.push({ element, datasetIndex: meta2.index, index: index3 });
          }
        });
        return elements2;
      },
      dataset(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        if (items.length > 0) {
          const datasetIndex = items[0].datasetIndex;
          const data = chart.getDatasetMeta(datasetIndex).data;
          items = [];
          for (let i = 0; i < data.length; ++i) {
            items.push({ element: data[i], datasetIndex, index: i });
          }
        }
        return items;
      },
      point(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
      },
      nearest(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
      },
      x(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
      },
      y(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
      }
    }
  };
  var STATIC_POSITIONS = ["left", "top", "right", "bottom"];
  function filterByPosition(array, position) {
    return array.filter((v) => v.pos === position);
  }
  function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
  }
  function sortByWeight(array, reverse) {
    return array.sort((a, b) => {
      const v0 = reverse ? b : a;
      const v1 = reverse ? a : b;
      return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
  }
  function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i, ilen, box, pos, stack, stackWeight;
    for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
      box = boxes[i];
      ({ position: pos, options: { stack, stackWeight = 1 } } = box);
      layoutBoxes.push({
        index: i,
        box,
        pos,
        horizontal: box.isHorizontal(),
        weight: box.weight,
        stack: stack && pos + stack,
        stackWeight
      });
    }
    return layoutBoxes;
  }
  function buildStacks(layouts2) {
    const stacks = {};
    for (const wrap of layouts2) {
      const { stack, pos, stackWeight } = wrap;
      if (!stack || !STATIC_POSITIONS.includes(pos)) {
        continue;
      }
      const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
      _stack.count++;
      _stack.weight += stackWeight;
    }
    return stacks;
  }
  function setLayoutDims(layouts2, params) {
    const stacks = buildStacks(layouts2);
    const { vBoxMaxWidth, hBoxMaxHeight } = params;
    let i, ilen, layout;
    for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
      layout = layouts2[i];
      const { fullSize } = layout.box;
      const stack = stacks[layout.stack];
      const factor = stack && layout.stackWeight / stack.weight;
      if (layout.horizontal) {
        layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
        layout.height = hBoxMaxHeight;
      } else {
        layout.width = vBoxMaxWidth;
        layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
      }
    }
    return stacks;
  }
  function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
    const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
    const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
    const top2 = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
    const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
    return {
      fullSize,
      leftAndTop: left.concat(top2),
      rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
      chartArea: filterByPosition(layoutBoxes, "chartArea"),
      vertical: left.concat(right).concat(centerVertical),
      horizontal: top2.concat(bottom).concat(centerHorizontal)
    };
  }
  function getCombinedMax(maxPadding, chartArea, a, b) {
    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
  }
  function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
  }
  function updateDims(chartArea, params, layout, stacks) {
    const { pos, box } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!isObject2(pos)) {
      if (layout.size) {
        chartArea[pos] -= layout.size;
      }
      const stack = stacks[layout.stack] || { size: 0, count: 1 };
      stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
      layout.size = stack.size / stack.count;
      chartArea[pos] += layout.size;
    }
    if (box.getPadding) {
      updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
  }
  function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
      const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
      chartArea[pos] += change;
      return change;
    }
    chartArea.y += updatePos("top");
    chartArea.x += updatePos("left");
    updatePos("right");
    updatePos("bottom");
  }
  function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions2) {
      const margin = { left: 0, top: 0, right: 0, bottom: 0 };
      positions2.forEach((pos) => {
        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
      });
      return margin;
    }
    return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
  }
  function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i, ilen, layout, box, refit, changed;
    for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
      layout = boxes[i];
      box = layout.box;
      box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
      const { same, other } = updateDims(chartArea, params, layout, stacks);
      refit |= same && refitBoxes.length;
      changed = changed || other;
      if (!box.fullSize) {
        refitBoxes.push(layout);
      }
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
  }
  function setBoxDims(box, left, top2, width, height) {
    box.top = top2;
    box.left = left;
    box.right = left + width;
    box.bottom = top2 + height;
    box.width = width;
    box.height = height;
  }
  function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x, y: y2 } = chartArea;
    for (const layout of boxes) {
      const box = layout.box;
      const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
      const weight = layout.stackWeight / stack.weight || 1;
      if (layout.horizontal) {
        const width = chartArea.w * weight;
        const height = stack.size || box.height;
        if (defined(stack.start)) {
          y2 = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, userPadding.left, y2, params.outerWidth - userPadding.right - userPadding.left, height);
        } else {
          setBoxDims(box, chartArea.left + stack.placed, y2, width, height);
        }
        stack.start = y2;
        stack.placed += width;
        y2 = box.bottom;
      } else {
        const height = chartArea.h * weight;
        const width = stack.size || box.width;
        if (defined(stack.start)) {
          x = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
        } else {
          setBoxDims(box, x, chartArea.top + stack.placed, width, height);
        }
        stack.start = x;
        stack.placed += height;
        x = box.right;
      }
    }
    chartArea.x = x;
    chartArea.y = y2;
  }
  defaults3.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
  var layouts = {
    addBox(chart, item) {
      if (!chart.boxes) {
        chart.boxes = [];
      }
      item.fullSize = item.fullSize || false;
      item.position = item.position || "top";
      item.weight = item.weight || 0;
      item._layers = item._layers || function() {
        return [{
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }];
      };
      chart.boxes.push(item);
    },
    removeBox(chart, layoutItem) {
      const index3 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
      if (index3 !== -1) {
        chart.boxes.splice(index3, 1);
      }
    },
    configure(chart, item, options) {
      item.fullSize = options.fullSize;
      item.position = options.position;
      item.weight = options.weight;
    },
    update(chart, width, height, minPadding) {
      if (!chart) {
        return;
      }
      const padding = toPadding(chart.options.layout.padding);
      const availableWidth = Math.max(width - padding.width, 0);
      const availableHeight = Math.max(height - padding.height, 0);
      const boxes = buildLayoutBoxes(chart.boxes);
      const verticalBoxes = boxes.vertical;
      const horizontalBoxes = boxes.horizontal;
      each(chart.boxes, (box) => {
        if (typeof box.beforeLayout === "function") {
          box.beforeLayout();
        }
      });
      const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
      const params = Object.freeze({
        outerWidth: width,
        outerHeight: height,
        padding,
        availableWidth,
        availableHeight,
        vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
        hBoxMaxHeight: availableHeight / 2
      });
      const maxPadding = Object.assign({}, padding);
      updateMaxPadding(maxPadding, toPadding(minPadding));
      const chartArea = Object.assign({
        maxPadding,
        w: availableWidth,
        h: availableHeight,
        x: padding.left,
        y: padding.top
      }, padding);
      const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
      fitBoxes(boxes.fullSize, chartArea, params, stacks);
      fitBoxes(verticalBoxes, chartArea, params, stacks);
      if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
        fitBoxes(verticalBoxes, chartArea, params, stacks);
      }
      handleMaxPadding(chartArea);
      placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
      chartArea.x += chartArea.w;
      chartArea.y += chartArea.h;
      placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
      chart.chartArea = {
        left: chartArea.left,
        top: chartArea.top,
        right: chartArea.left + chartArea.w,
        bottom: chartArea.top + chartArea.h,
        height: chartArea.h,
        width: chartArea.w
      };
      each(boxes.chartArea, (layout) => {
        const box = layout.box;
        Object.assign(box, chart.chartArea);
        box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
      });
    }
  };
  var BasePlatform = class {
    acquireContext(canvas, aspectRatio) {
    }
    releaseContext(context2) {
      return false;
    }
    addEventListener(chart, type, listener) {
    }
    removeEventListener(chart, type, listener) {
    }
    getDevicePixelRatio() {
      return 1;
    }
    getMaximumSize(element, width, height, aspectRatio) {
      width = Math.max(0, width || element.width);
      height = height || element.height;
      return {
        width,
        height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
      };
    }
    isAttached(canvas) {
      return true;
    }
    updateConfig(config) {
    }
  };
  var BasicPlatform = class extends BasePlatform {
    acquireContext(item) {
      return item && item.getContext && item.getContext("2d") || null;
    }
    updateConfig(config) {
      config.options.animation = false;
    }
  };
  var EXPANDO_KEY = "$chartjs";
  var EVENT_TYPES = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
  };
  var isNullOrEmpty = (value) => value === null || value === "";
  function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute("height");
    const renderWidth = canvas.getAttribute("width");
    canvas[EXPANDO_KEY] = {
      initial: {
        height: renderHeight,
        width: renderWidth,
        style: {
          display: style.display,
          height: style.height,
          width: style.width
        }
      }
    };
    style.display = style.display || "block";
    style.boxSizing = style.boxSizing || "border-box";
    if (isNullOrEmpty(renderWidth)) {
      const displayWidth = readUsedSize(canvas, "width");
      if (displayWidth !== void 0) {
        canvas.width = displayWidth;
      }
    }
    if (isNullOrEmpty(renderHeight)) {
      if (canvas.style.height === "") {
        canvas.height = canvas.width / (aspectRatio || 2);
      } else {
        const displayHeight = readUsedSize(canvas, "height");
        if (displayHeight !== void 0) {
          canvas.height = displayHeight;
        }
      }
    }
    return canvas;
  }
  var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
  function addListener(node, type, listener) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
  function removeListener(chart, type, listener) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
  function fromNativeEvent(event2, chart) {
    const type = EVENT_TYPES[event2.type] || event2.type;
    const { x, y: y2 } = getRelativePosition(event2, chart);
    return {
      type,
      chart,
      native: event2,
      x: x !== void 0 ? x : null,
      y: y2 !== void 0 ? y2 : null
    };
  }
  function nodeListContains(nodeList, canvas) {
    for (const node of nodeList) {
      if (node === canvas || node.contains(canvas)) {
        return true;
      }
    }
  }
  function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.addedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, { childList: true, subtree: true });
    return observer;
  }
  function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.removedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, { childList: true, subtree: true });
    return observer;
  }
  var drpListeningCharts = new Map();
  var oldDevicePixelRatio = 0;
  function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
      return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart) => {
      if (chart.currentDevicePixelRatio !== dpr) {
        resize();
      }
    });
  }
  function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) {
      window.addEventListener("resize", onWindowResize);
    }
    drpListeningCharts.set(chart, resize);
  }
  function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
      window.removeEventListener("resize", onWindowResize);
    }
  }
  function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      return;
    }
    const resize = throttled((width, height) => {
      const w = container.clientWidth;
      listener(width, height);
      if (w < container.clientWidth) {
        listener();
      }
    }, window);
    const observer = new ResizeObserver((entries) => {
      const entry = entries[0];
      const width = entry.contentRect.width;
      const height = entry.contentRect.height;
      if (width === 0 && height === 0) {
        return;
      }
      resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
  }
  function releaseObserver(chart, type, observer) {
    if (observer) {
      observer.disconnect();
    }
    if (type === "resize") {
      unlistenDevicePixelRatioChanges(chart);
    }
  }
  function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = throttled((event2) => {
      if (chart.ctx !== null) {
        listener(fromNativeEvent(event2, chart));
      }
    }, chart, (args) => {
      const event2 = args[0];
      return [event2, event2.offsetX, event2.offsetY];
    });
    addListener(canvas, type, proxy);
    return proxy;
  }
  var DomPlatform = class extends BasePlatform {
    acquireContext(canvas, aspectRatio) {
      const context2 = canvas && canvas.getContext && canvas.getContext("2d");
      if (context2 && context2.canvas === canvas) {
        initCanvas(canvas, aspectRatio);
        return context2;
      }
      return null;
    }
    releaseContext(context2) {
      const canvas = context2.canvas;
      if (!canvas[EXPANDO_KEY]) {
        return false;
      }
      const initial = canvas[EXPANDO_KEY].initial;
      ["height", "width"].forEach((prop) => {
        const value = initial[prop];
        if (isNullOrUndef(value)) {
          canvas.removeAttribute(prop);
        } else {
          canvas.setAttribute(prop, value);
        }
      });
      const style = initial.style || {};
      Object.keys(style).forEach((key) => {
        canvas.style[key] = style[key];
      });
      canvas.width = canvas.width;
      delete canvas[EXPANDO_KEY];
      return true;
    }
    addEventListener(chart, type, listener) {
      this.removeEventListener(chart, type);
      const proxies = chart.$proxies || (chart.$proxies = {});
      const handlers2 = {
        attach: createAttachObserver,
        detach: createDetachObserver,
        resize: createResizeObserver
      };
      const handler2 = handlers2[type] || createProxyAndListen;
      proxies[type] = handler2(chart, type, listener);
    }
    removeEventListener(chart, type) {
      const proxies = chart.$proxies || (chart.$proxies = {});
      const proxy = proxies[type];
      if (!proxy) {
        return;
      }
      const handlers2 = {
        attach: releaseObserver,
        detach: releaseObserver,
        resize: releaseObserver
      };
      const handler2 = handlers2[type] || removeListener;
      handler2(chart, type, proxy);
      proxies[type] = void 0;
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio;
    }
    getMaximumSize(canvas, width, height, aspectRatio) {
      return getMaximumSize(canvas, width, height, aspectRatio);
    }
    isAttached(canvas) {
      const container = _getParentNode(canvas);
      return !!(container && container.isConnected);
    }
  };
  function _detectPlatform(canvas) {
    if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
      return BasicPlatform;
    }
    return DomPlatform;
  }
  var PluginService = class {
    constructor() {
      this._init = [];
    }
    notify(chart, hook, args, filter) {
      if (hook === "beforeInit") {
        this._init = this._createDescriptors(chart, true);
        this._notify(this._init, chart, "install");
      }
      const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
      const result = this._notify(descriptors2, chart, hook, args);
      if (hook === "afterDestroy") {
        this._notify(descriptors2, chart, "stop");
        this._notify(this._init, chart, "uninstall");
      }
      return result;
    }
    _notify(descriptors2, chart, hook, args) {
      args = args || {};
      for (const descriptor of descriptors2) {
        const plugin = descriptor.plugin;
        const method = plugin[hook];
        const params = [chart, args, descriptor.options];
        if (callback(method, params, plugin) === false && args.cancelable) {
          return false;
        }
      }
      return true;
    }
    invalidate() {
      if (!isNullOrUndef(this._cache)) {
        this._oldCache = this._cache;
        this._cache = void 0;
      }
    }
    _descriptors(chart) {
      if (this._cache) {
        return this._cache;
      }
      const descriptors2 = this._cache = this._createDescriptors(chart);
      this._notifyStateChanges(chart);
      return descriptors2;
    }
    _createDescriptors(chart, all) {
      const config = chart && chart.config;
      const options = valueOrDefault(config.options && config.options.plugins, {});
      const plugins3 = allPlugins(config);
      return options === false && !all ? [] : createDescriptors(chart, plugins3, options, all);
    }
    _notifyStateChanges(chart) {
      const previousDescriptors = this._oldCache || [];
      const descriptors2 = this._cache;
      const diff = (a, b) => a.filter((x) => !b.some((y2) => x.plugin.id === y2.plugin.id));
      this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
      this._notify(diff(descriptors2, previousDescriptors), chart, "start");
    }
  };
  function allPlugins(config) {
    const localIds = {};
    const plugins3 = [];
    const keys = Object.keys(registry.plugins.items);
    for (let i = 0; i < keys.length; i++) {
      plugins3.push(registry.getPlugin(keys[i]));
    }
    const local = config.plugins || [];
    for (let i = 0; i < local.length; i++) {
      const plugin = local[i];
      if (plugins3.indexOf(plugin) === -1) {
        plugins3.push(plugin);
        localIds[plugin.id] = true;
      }
    }
    return { plugins: plugins3, localIds };
  }
  function getOpts(options, all) {
    if (!all && options === false) {
      return null;
    }
    if (options === true) {
      return {};
    }
    return options;
  }
  function createDescriptors(chart, { plugins: plugins3, localIds }, options, all) {
    const result = [];
    const context2 = chart.getContext();
    for (const plugin of plugins3) {
      const id2 = plugin.id;
      const opts = getOpts(options[id2], all);
      if (opts === null) {
        continue;
      }
      result.push({
        plugin,
        options: pluginOpts(chart.config, { plugin, local: localIds[id2] }, opts, context2)
      });
    }
    return result;
  }
  function pluginOpts(config, { plugin, local }, opts, context2) {
    const keys = config.pluginScopeKeys(plugin);
    const scopes = config.getOptionScopes(opts, keys);
    if (local && plugin.defaults) {
      scopes.push(plugin.defaults);
    }
    return config.createResolver(scopes, context2, [""], {
      scriptable: false,
      indexable: false,
      allKeys: true
    });
  }
  function getIndexAxis(type, options) {
    const datasetDefaults = defaults3.datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
  }
  function getAxisFromDefaultScaleID(id2, indexAxis) {
    let axis = id2;
    if (id2 === "_index_") {
      axis = indexAxis;
    } else if (id2 === "_value_") {
      axis = indexAxis === "x" ? "y" : "x";
    }
    return axis;
  }
  function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? "_index_" : "_value_";
  }
  function axisFromPosition(position) {
    if (position === "top" || position === "bottom") {
      return "x";
    }
    if (position === "left" || position === "right") {
      return "y";
    }
  }
  function determineAxis(id2, scaleOptions) {
    if (id2 === "x" || id2 === "y") {
      return id2;
    }
    return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id2.charAt(0).toLowerCase();
  }
  function mergeScaleConfig(config, options) {
    const chartDefaults = overrides2[config.type] || { scales: {} };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const firstIDs = Object.create(null);
    const scales2 = Object.create(null);
    Object.keys(configScales).forEach((id2) => {
      const scaleConf = configScales[id2];
      if (!isObject2(scaleConf)) {
        return console.error(`Invalid scale configuration for scale: ${id2}`);
      }
      if (scaleConf._proxy) {
        return console.warn(`Ignoring resolver passed as options for scale: ${id2}`);
      }
      const axis = determineAxis(id2, scaleConf);
      const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
      const defaultScaleOptions = chartDefaults.scales || {};
      firstIDs[axis] = firstIDs[axis] || id2;
      scales2[id2] = mergeIf(Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
    });
    config.data.datasets.forEach((dataset) => {
      const type = dataset.type || config.type;
      const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
      const datasetDefaults = overrides2[type] || {};
      const defaultScaleOptions = datasetDefaults.scales || {};
      Object.keys(defaultScaleOptions).forEach((defaultID) => {
        const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
        const id2 = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
        scales2[id2] = scales2[id2] || Object.create(null);
        mergeIf(scales2[id2], [{ axis }, configScales[id2], defaultScaleOptions[defaultID]]);
      });
    });
    Object.keys(scales2).forEach((key) => {
      const scale = scales2[key];
      mergeIf(scale, [defaults3.scales[scale.type], defaults3.scale]);
    });
    return scales2;
  }
  function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = valueOrDefault(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
  }
  function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
  }
  function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
  }
  var keyCache = new Map();
  var keysCached = new Set();
  function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
      keys = generate();
      keyCache.set(cacheKey, keys);
      keysCached.add(keys);
    }
    return keys;
  }
  var addIfFound = (set2, obj, key) => {
    const opts = resolveObjectKey(obj, key);
    if (opts !== void 0) {
      set2.add(opts);
    }
  };
  var Config = class {
    constructor(config) {
      this._config = initConfig(config);
      this._scopeCache = new Map();
      this._resolverCache = new Map();
    }
    get platform() {
      return this._config.platform;
    }
    get type() {
      return this._config.type;
    }
    set type(type) {
      this._config.type = type;
    }
    get data() {
      return this._config.data;
    }
    set data(data) {
      this._config.data = initData(data);
    }
    get options() {
      return this._config.options;
    }
    set options(options) {
      this._config.options = options;
    }
    get plugins() {
      return this._config.plugins;
    }
    update() {
      const config = this._config;
      this.clearCache();
      initOptions(config);
    }
    clearCache() {
      this._scopeCache.clear();
      this._resolverCache.clear();
    }
    datasetScopeKeys(datasetType) {
      return cachedKeys(datasetType, () => [[
        `datasets.${datasetType}`,
        ""
      ]]);
    }
    datasetAnimationScopeKeys(datasetType, transition) {
      return cachedKeys(`${datasetType}.transition.${transition}`, () => [
        [
          `datasets.${datasetType}.transitions.${transition}`,
          `transitions.${transition}`
        ],
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetElementScopeKeys(datasetType, elementType) {
      return cachedKeys(`${datasetType}-${elementType}`, () => [[
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]]);
    }
    pluginScopeKeys(plugin) {
      const id2 = plugin.id;
      const type = this.type;
      return cachedKeys(`${type}-plugin-${id2}`, () => [[
        `plugins.${id2}`,
        ...plugin.additionalOptionScopes || []
      ]]);
    }
    _cachedScopes(mainScope, resetCache) {
      const _scopeCache = this._scopeCache;
      let cache = _scopeCache.get(mainScope);
      if (!cache || resetCache) {
        cache = new Map();
        _scopeCache.set(mainScope, cache);
      }
      return cache;
    }
    getOptionScopes(mainScope, keyLists, resetCache) {
      const { options, type } = this;
      const cache = this._cachedScopes(mainScope, resetCache);
      const cached = cache.get(keyLists);
      if (cached) {
        return cached;
      }
      const scopes = new Set();
      keyLists.forEach((keys) => {
        if (mainScope) {
          scopes.add(mainScope);
          keys.forEach((key) => addIfFound(scopes, mainScope, key));
        }
        keys.forEach((key) => addIfFound(scopes, options, key));
        keys.forEach((key) => addIfFound(scopes, overrides2[type] || {}, key));
        keys.forEach((key) => addIfFound(scopes, defaults3, key));
        keys.forEach((key) => addIfFound(scopes, descriptors, key));
      });
      const array = Array.from(scopes);
      if (array.length === 0) {
        array.push(Object.create(null));
      }
      if (keysCached.has(keyLists)) {
        cache.set(keyLists, array);
      }
      return array;
    }
    chartOptionScopes() {
      const { options, type } = this;
      return [
        options,
        overrides2[type] || {},
        defaults3.datasets[type] || {},
        { type },
        defaults3,
        descriptors
      ];
    }
    resolveNamedOptions(scopes, names2, context2, prefixes = [""]) {
      const result = { $shared: true };
      const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
      let options = resolver;
      if (needContext(resolver, names2)) {
        result.$shared = false;
        context2 = isFunction2(context2) ? context2() : context2;
        const subResolver = this.createResolver(scopes, context2, subPrefixes);
        options = _attachContext(resolver, context2, subResolver);
      }
      for (const prop of names2) {
        result[prop] = options[prop];
      }
      return result;
    }
    createResolver(scopes, context2, prefixes = [""], descriptorDefaults) {
      const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
      return isObject2(context2) ? _attachContext(resolver, context2, void 0, descriptorDefaults) : resolver;
    }
  };
  function getResolver(resolverCache, scopes, prefixes) {
    let cache = resolverCache.get(scopes);
    if (!cache) {
      cache = new Map();
      resolverCache.set(scopes, cache);
    }
    const cacheKey = prefixes.join();
    let cached = cache.get(cacheKey);
    if (!cached) {
      const resolver = _createResolver(scopes, prefixes);
      cached = {
        resolver,
        subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
      };
      cache.set(cacheKey, cached);
    }
    return cached;
  }
  var hasFunction = (value) => isObject2(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction2(value[key]), false);
  function needContext(proxy, names2) {
    const { isScriptable, isIndexable } = _descriptors(proxy);
    for (const prop of names2) {
      const scriptable = isScriptable(prop);
      const indexable = isIndexable(prop);
      const value = (indexable || scriptable) && proxy[prop];
      if (scriptable && (isFunction2(value) || hasFunction(value)) || indexable && isArray2(value)) {
        return true;
      }
    }
    return false;
  }
  var version3 = "3.9.1";
  var KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
  function positionIsHorizontal(position, axis) {
    return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
  }
  function compare2Level(l1, l2) {
    return function(a, b) {
      return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
    };
  }
  function onAnimationsComplete(context2) {
    const chart = context2.chart;
    const animationOptions2 = chart.options.animation;
    chart.notifyPlugins("afterRender");
    callback(animationOptions2 && animationOptions2.onComplete, [context2], chart);
  }
  function onAnimationProgress(context2) {
    const chart = context2.chart;
    const animationOptions2 = chart.options.animation;
    callback(animationOptions2 && animationOptions2.onProgress, [context2], chart);
  }
  function getCanvas(item) {
    if (_isDomSupported() && typeof item === "string") {
      item = document.getElementById(item);
    } else if (item && item.length) {
      item = item[0];
    }
    if (item && item.canvas) {
      item = item.canvas;
    }
    return item;
  }
  var instances = {};
  var getChart = (key) => {
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c2) => c2.canvas === canvas).pop();
  };
  function moveNumericKeys(obj, start2, move) {
    const keys = Object.keys(obj);
    for (const key of keys) {
      const intKey = +key;
      if (intKey >= start2) {
        const value = obj[key];
        delete obj[key];
        if (move > 0 || intKey > start2) {
          obj[intKey + move] = value;
        }
      }
    }
  }
  function determineLastEvent(e, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e.type === "mouseout") {
      return null;
    }
    if (isClick) {
      return lastEvent;
    }
    return e;
  }
  var Chart = class {
    constructor(item, userConfig) {
      const config = this.config = new Config(userConfig);
      const initialCanvas = getCanvas(item);
      const existingChart = getChart(initialCanvas);
      if (existingChart) {
        throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
      }
      const options = config.createResolver(config.chartOptionScopes(), this.getContext());
      this.platform = new (config.platform || _detectPlatform(initialCanvas))();
      this.platform.updateConfig(config);
      const context2 = this.platform.acquireContext(initialCanvas, options.aspectRatio);
      const canvas = context2 && context2.canvas;
      const height = canvas && canvas.height;
      const width = canvas && canvas.width;
      this.id = uid();
      this.ctx = context2;
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this._options = options;
      this._aspectRatio = this.aspectRatio;
      this._layers = [];
      this._metasets = [];
      this._stacks = void 0;
      this.boxes = [];
      this.currentDevicePixelRatio = void 0;
      this.chartArea = void 0;
      this._active = [];
      this._lastEvent = void 0;
      this._listeners = {};
      this._responsiveListeners = void 0;
      this._sortedMetasets = [];
      this.scales = {};
      this._plugins = new PluginService();
      this.$proxies = {};
      this._hiddenIndices = {};
      this.attached = false;
      this._animationsDisabled = void 0;
      this.$context = void 0;
      this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
      this._dataChanges = [];
      instances[this.id] = this;
      if (!context2 || !canvas) {
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }
      animator.listen(this, "complete", onAnimationsComplete);
      animator.listen(this, "progress", onAnimationProgress);
      this._initialize();
      if (this.attached) {
        this.update();
      }
    }
    get aspectRatio() {
      const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
      if (!isNullOrUndef(aspectRatio)) {
        return aspectRatio;
      }
      if (maintainAspectRatio && _aspectRatio) {
        return _aspectRatio;
      }
      return height ? width / height : null;
    }
    get data() {
      return this.config.data;
    }
    set data(data) {
      this.config.data = data;
    }
    get options() {
      return this._options;
    }
    set options(options) {
      this.config.options = options;
    }
    _initialize() {
      this.notifyPlugins("beforeInit");
      if (this.options.responsive) {
        this.resize();
      } else {
        retinaScale(this, this.options.devicePixelRatio);
      }
      this.bindEvents();
      this.notifyPlugins("afterInit");
      return this;
    }
    clear() {
      clearCanvas(this.canvas, this.ctx);
      return this;
    }
    stop() {
      animator.stop(this);
      return this;
    }
    resize(width, height) {
      if (!animator.running(this)) {
        this._resize(width, height);
      } else {
        this._resizeBeforeDraw = { width, height };
      }
    }
    _resize(width, height) {
      const options = this.options;
      const canvas = this.canvas;
      const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
      const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
      const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
      const mode = this.width ? "resize" : "attach";
      this.width = newSize.width;
      this.height = newSize.height;
      this._aspectRatio = this.aspectRatio;
      if (!retinaScale(this, newRatio, true)) {
        return;
      }
      this.notifyPlugins("resize", { size: newSize });
      callback(options.onResize, [this, newSize], this);
      if (this.attached) {
        if (this._doResize(mode)) {
          this.render();
        }
      }
    }
    ensureScalesHaveIDs() {
      const options = this.options;
      const scalesOptions = options.scales || {};
      each(scalesOptions, (axisOptions, axisID) => {
        axisOptions.id = axisID;
      });
    }
    buildOrUpdateScales() {
      const options = this.options;
      const scaleOpts = options.scales;
      const scales2 = this.scales;
      const updated = Object.keys(scales2).reduce((obj, id2) => {
        obj[id2] = false;
        return obj;
      }, {});
      let items = [];
      if (scaleOpts) {
        items = items.concat(Object.keys(scaleOpts).map((id2) => {
          const scaleOptions = scaleOpts[id2];
          const axis = determineAxis(id2, scaleOptions);
          const isRadial = axis === "r";
          const isHorizontal = axis === "x";
          return {
            options: scaleOptions,
            dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
            dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
          };
        }));
      }
      each(items, (item) => {
        const scaleOptions = item.options;
        const id2 = scaleOptions.id;
        const axis = determineAxis(id2, scaleOptions);
        const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
        if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
          scaleOptions.position = item.dposition;
        }
        updated[id2] = true;
        let scale = null;
        if (id2 in scales2 && scales2[id2].type === scaleType) {
          scale = scales2[id2];
        } else {
          const scaleClass = registry.getScale(scaleType);
          scale = new scaleClass({
            id: id2,
            type: scaleType,
            ctx: this.ctx,
            chart: this
          });
          scales2[scale.id] = scale;
        }
        scale.init(scaleOptions, options);
      });
      each(updated, (hasUpdated, id2) => {
        if (!hasUpdated) {
          delete scales2[id2];
        }
      });
      each(scales2, (scale) => {
        layouts.configure(this, scale, scale.options);
        layouts.addBox(this, scale);
      });
    }
    _updateMetasets() {
      const metasets = this._metasets;
      const numData = this.data.datasets.length;
      const numMeta = metasets.length;
      metasets.sort((a, b) => a.index - b.index);
      if (numMeta > numData) {
        for (let i = numData; i < numMeta; ++i) {
          this._destroyDatasetMeta(i);
        }
        metasets.splice(numData, numMeta - numData);
      }
      this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
    }
    _removeUnreferencedMetasets() {
      const { _metasets: metasets, data: { datasets } } = this;
      if (metasets.length > datasets.length) {
        delete this._stacks;
      }
      metasets.forEach((meta2, index3) => {
        if (datasets.filter((x) => x === meta2._dataset).length === 0) {
          this._destroyDatasetMeta(index3);
        }
      });
    }
    buildOrUpdateControllers() {
      const newControllers = [];
      const datasets = this.data.datasets;
      let i, ilen;
      this._removeUnreferencedMetasets();
      for (i = 0, ilen = datasets.length; i < ilen; i++) {
        const dataset = datasets[i];
        let meta2 = this.getDatasetMeta(i);
        const type = dataset.type || this.config.type;
        if (meta2.type && meta2.type !== type) {
          this._destroyDatasetMeta(i);
          meta2 = this.getDatasetMeta(i);
        }
        meta2.type = type;
        meta2.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
        meta2.order = dataset.order || 0;
        meta2.index = i;
        meta2.label = "" + dataset.label;
        meta2.visible = this.isDatasetVisible(i);
        if (meta2.controller) {
          meta2.controller.updateIndex(i);
          meta2.controller.linkScales();
        } else {
          const ControllerClass = registry.getController(type);
          const { datasetElementType, dataElementType } = defaults3.datasets[type];
          Object.assign(ControllerClass.prototype, {
            dataElementType: registry.getElement(dataElementType),
            datasetElementType: datasetElementType && registry.getElement(datasetElementType)
          });
          meta2.controller = new ControllerClass(this, i);
          newControllers.push(meta2.controller);
        }
      }
      this._updateMetasets();
      return newControllers;
    }
    _resetElements() {
      each(this.data.datasets, (dataset, datasetIndex) => {
        this.getDatasetMeta(datasetIndex).controller.reset();
      }, this);
    }
    reset() {
      this._resetElements();
      this.notifyPlugins("reset");
    }
    update(mode) {
      const config = this.config;
      config.update();
      const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
      const animsDisabled = this._animationsDisabled = !options.animation;
      this._updateScales();
      this._checkEventBindings();
      this._updateHiddenIndices();
      this._plugins.invalidate();
      if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
        return;
      }
      const newControllers = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let minPadding = 0;
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
        const { controller } = this.getDatasetMeta(i);
        const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
        controller.buildOrUpdateElements(reset);
        minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
      }
      minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
      this._updateLayout(minPadding);
      if (!animsDisabled) {
        each(newControllers, (controller) => {
          controller.reset();
        });
      }
      this._updateDatasets(mode);
      this.notifyPlugins("afterUpdate", { mode });
      this._layers.sort(compare2Level("z", "_idx"));
      const { _active, _lastEvent } = this;
      if (_lastEvent) {
        this._eventHandler(_lastEvent, true);
      } else if (_active.length) {
        this._updateHoverStyles(_active, _active, true);
      }
      this.render();
    }
    _updateScales() {
      each(this.scales, (scale) => {
        layouts.removeBox(this, scale);
      });
      this.ensureScalesHaveIDs();
      this.buildOrUpdateScales();
    }
    _checkEventBindings() {
      const options = this.options;
      const existingEvents = new Set(Object.keys(this._listeners));
      const newEvents = new Set(options.events);
      if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
        this.unbindEvents();
        this.bindEvents();
      }
    }
    _updateHiddenIndices() {
      const { _hiddenIndices } = this;
      const changes = this._getUniformDataChanges() || [];
      for (const { method, start: start2, count } of changes) {
        const move = method === "_removeElements" ? -count : count;
        moveNumericKeys(_hiddenIndices, start2, move);
      }
    }
    _getUniformDataChanges() {
      const _dataChanges = this._dataChanges;
      if (!_dataChanges || !_dataChanges.length) {
        return;
      }
      this._dataChanges = [];
      const datasetCount = this.data.datasets.length;
      const makeSet = (idx) => new Set(_dataChanges.filter((c2) => c2[0] === idx).map((c2, i) => i + "," + c2.splice(1).join(",")));
      const changeSet = makeSet(0);
      for (let i = 1; i < datasetCount; i++) {
        if (!setsEqual(changeSet, makeSet(i))) {
          return;
        }
      }
      return Array.from(changeSet).map((c2) => c2.split(",")).map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
    }
    _updateLayout(minPadding) {
      if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
        return;
      }
      layouts.update(this, this.width, this.height, minPadding);
      const area = this.chartArea;
      const noArea = area.width <= 0 || area.height <= 0;
      this._layers = [];
      each(this.boxes, (box) => {
        if (noArea && box.position === "chartArea") {
          return;
        }
        if (box.configure) {
          box.configure();
        }
        this._layers.push(...box._layers());
      }, this);
      this._layers.forEach((item, index3) => {
        item._idx = index3;
      });
      this.notifyPlugins("afterLayout");
    }
    _updateDatasets(mode) {
      if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
        return;
      }
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this.getDatasetMeta(i).controller.configure();
      }
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this._updateDataset(i, isFunction2(mode) ? mode({ datasetIndex: i }) : mode);
      }
      this.notifyPlugins("afterDatasetsUpdate", { mode });
    }
    _updateDataset(index3, mode) {
      const meta2 = this.getDatasetMeta(index3);
      const args = { meta: meta2, index: index3, mode, cancelable: true };
      if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
        return;
      }
      meta2.controller._update(mode);
      args.cancelable = false;
      this.notifyPlugins("afterDatasetUpdate", args);
    }
    render() {
      if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
        return;
      }
      if (animator.has(this)) {
        if (this.attached && !animator.running(this)) {
          animator.start(this);
        }
      } else {
        this.draw();
        onAnimationsComplete({ chart: this });
      }
    }
    draw() {
      let i;
      if (this._resizeBeforeDraw) {
        const { width, height } = this._resizeBeforeDraw;
        this._resize(width, height);
        this._resizeBeforeDraw = null;
      }
      this.clear();
      if (this.width <= 0 || this.height <= 0) {
        return;
      }
      if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
        return;
      }
      const layers = this._layers;
      for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
        layers[i].draw(this.chartArea);
      }
      this._drawDatasets();
      for (; i < layers.length; ++i) {
        layers[i].draw(this.chartArea);
      }
      this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(filterVisible) {
      const metasets = this._sortedMetasets;
      const result = [];
      let i, ilen;
      for (i = 0, ilen = metasets.length; i < ilen; ++i) {
        const meta2 = metasets[i];
        if (!filterVisible || meta2.visible) {
          result.push(meta2);
        }
      }
      return result;
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
      if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
        return;
      }
      const metasets = this.getSortedVisibleDatasetMetas();
      for (let i = metasets.length - 1; i >= 0; --i) {
        this._drawDataset(metasets[i]);
      }
      this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(meta2) {
      const ctx = this.ctx;
      const clip2 = meta2._clip;
      const useClip = !clip2.disabled;
      const area = this.chartArea;
      const args = {
        meta: meta2,
        index: meta2.index,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
        return;
      }
      if (useClip) {
        clipArea(ctx, {
          left: clip2.left === false ? 0 : area.left - clip2.left,
          right: clip2.right === false ? this.width : area.right + clip2.right,
          top: clip2.top === false ? 0 : area.top - clip2.top,
          bottom: clip2.bottom === false ? this.height : area.bottom + clip2.bottom
        });
      }
      meta2.controller.draw();
      if (useClip) {
        unclipArea(ctx);
      }
      args.cancelable = false;
      this.notifyPlugins("afterDatasetDraw", args);
    }
    isPointInArea(point) {
      return _isPointInArea(point, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e, mode, options, useFinalPosition) {
      const method = Interaction.modes[mode];
      if (typeof method === "function") {
        return method(this, e, options, useFinalPosition);
      }
      return [];
    }
    getDatasetMeta(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      const metasets = this._metasets;
      let meta2 = metasets.filter((x) => x && x._dataset === dataset).pop();
      if (!meta2) {
        meta2 = {
          type: null,
          data: [],
          dataset: null,
          controller: null,
          hidden: null,
          xAxisID: null,
          yAxisID: null,
          order: dataset && dataset.order || 0,
          index: datasetIndex,
          _dataset: dataset,
          _parsed: [],
          _sorted: false
        };
        metasets.push(meta2);
      }
      return meta2;
    }
    getContext() {
      return this.$context || (this.$context = createContext(null, { chart: this, type: "chart" }));
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      if (!dataset) {
        return false;
      }
      const meta2 = this.getDatasetMeta(datasetIndex);
      return typeof meta2.hidden === "boolean" ? !meta2.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
      const meta2 = this.getDatasetMeta(datasetIndex);
      meta2.hidden = !visible;
    }
    toggleDataVisibility(index3) {
      this._hiddenIndices[index3] = !this._hiddenIndices[index3];
    }
    getDataVisibility(index3) {
      return !this._hiddenIndices[index3];
    }
    _updateVisibility(datasetIndex, dataIndex, visible) {
      const mode = visible ? "show" : "hide";
      const meta2 = this.getDatasetMeta(datasetIndex);
      const anims = meta2.controller._resolveAnimations(void 0, mode);
      if (defined(dataIndex)) {
        meta2.data[dataIndex].hidden = !visible;
        this.update();
      } else {
        this.setDatasetVisibility(datasetIndex, visible);
        anims.update(meta2, { visible });
        this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
      }
    }
    hide(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, true);
    }
    _destroyDatasetMeta(datasetIndex) {
      const meta2 = this._metasets[datasetIndex];
      if (meta2 && meta2.controller) {
        meta2.controller._destroy();
      }
      delete this._metasets[datasetIndex];
    }
    _stop() {
      let i, ilen;
      this.stop();
      animator.remove(this);
      for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this._destroyDatasetMeta(i);
      }
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const { canvas, ctx } = this;
      this._stop();
      this.config.clearCache();
      if (canvas) {
        this.unbindEvents();
        clearCanvas(canvas, ctx);
        this.platform.releaseContext(ctx);
        this.canvas = null;
        this.ctx = null;
      }
      this.notifyPlugins("destroy");
      delete instances[this.id];
      this.notifyPlugins("afterDestroy");
    }
    toBase64Image(...args) {
      return this.canvas.toDataURL(...args);
    }
    bindEvents() {
      this.bindUserEvents();
      if (this.options.responsive) {
        this.bindResponsiveEvents();
      } else {
        this.attached = true;
      }
    }
    bindUserEvents() {
      const listeners = this._listeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const listener = (e, x, y2) => {
        e.offsetX = x;
        e.offsetY = y2;
        this._eventHandler(e);
      };
      each(this.options.events, (type) => _add(type, listener));
    }
    bindResponsiveEvents() {
      if (!this._responsiveListeners) {
        this._responsiveListeners = {};
      }
      const listeners = this._responsiveListeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const _remove = (type, listener2) => {
        if (listeners[type]) {
          platform.removeEventListener(this, type, listener2);
          delete listeners[type];
        }
      };
      const listener = (width, height) => {
        if (this.canvas) {
          this.resize(width, height);
        }
      };
      let detached;
      const attached = () => {
        _remove("attach", attached);
        this.attached = true;
        this.resize();
        _add("resize", listener);
        _add("detach", detached);
      };
      detached = () => {
        this.attached = false;
        _remove("resize", listener);
        this._stop();
        this._resize(0, 0);
        _add("attach", attached);
      };
      if (platform.isAttached(this.canvas)) {
        attached();
      } else {
        detached();
      }
    }
    unbindEvents() {
      each(this._listeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._listeners = {};
      each(this._responsiveListeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._responsiveListeners = void 0;
    }
    updateHoverStyle(items, mode, enabled) {
      const prefix = enabled ? "set" : "remove";
      let meta2, item, i, ilen;
      if (mode === "dataset") {
        meta2 = this.getDatasetMeta(items[0].datasetIndex);
        meta2.controller["_" + prefix + "DatasetHoverStyle"]();
      }
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        item = items[i];
        const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
        if (controller) {
          controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
        }
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements) {
      const lastActive = this._active || [];
      const active = activeElements.map(({ datasetIndex, index: index3 }) => {
        const meta2 = this.getDatasetMeta(datasetIndex);
        if (!meta2) {
          throw new Error("No dataset found at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta2.data[index3],
          index: index3
        };
      });
      const changed = !_elementsEqual(active, lastActive);
      if (changed) {
        this._active = active;
        this._lastEvent = null;
        this._updateHoverStyles(active, lastActive);
      }
    }
    notifyPlugins(hook, args, filter) {
      return this._plugins.notify(this, hook, args, filter);
    }
    _updateHoverStyles(active, lastActive, replay) {
      const hoverOptions = this.options.hover;
      const diff = (a, b) => a.filter((x) => !b.some((y2) => x.datasetIndex === y2.datasetIndex && x.index === y2.index));
      const deactivated = diff(lastActive, active);
      const activated = replay ? active : diff(active, lastActive);
      if (deactivated.length) {
        this.updateHoverStyle(deactivated, hoverOptions.mode, false);
      }
      if (activated.length && hoverOptions.mode) {
        this.updateHoverStyle(activated, hoverOptions.mode, true);
      }
    }
    _eventHandler(e, replay) {
      const args = {
        event: e,
        replay,
        cancelable: true,
        inChartArea: this.isPointInArea(e)
      };
      const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
      if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
        return;
      }
      const changed = this._handleEvent(e, replay, args.inChartArea);
      args.cancelable = false;
      this.notifyPlugins("afterEvent", args, eventFilter);
      if (changed || args.changed) {
        this.render();
      }
      return this;
    }
    _handleEvent(e, replay, inChartArea) {
      const { _active: lastActive = [], options } = this;
      const useFinalPosition = replay;
      const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
      const isClick = _isClickEvent(e);
      const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
      if (inChartArea) {
        this._lastEvent = null;
        callback(options.onHover, [e, active, this], this);
        if (isClick) {
          callback(options.onClick, [e, active, this], this);
        }
      }
      const changed = !_elementsEqual(active, lastActive);
      if (changed || replay) {
        this._active = active;
        this._updateHoverStyles(active, lastActive, replay);
      }
      this._lastEvent = lastEvent;
      return changed;
    }
    _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
      if (e.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const hoverOptions = this.options.hover;
      return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
  };
  var invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());
  var enumerable = true;
  Object.defineProperties(Chart, {
    defaults: {
      enumerable,
      value: defaults3
    },
    instances: {
      enumerable,
      value: instances
    },
    overrides: {
      enumerable,
      value: overrides2
    },
    registry: {
      enumerable,
      value: registry
    },
    version: {
      enumerable,
      value: version3
    },
    getChart: {
      enumerable,
      value: getChart
    },
    register: {
      enumerable,
      value: (...items) => {
        registry.add(...items);
        invalidatePlugins();
      }
    },
    unregister: {
      enumerable,
      value: (...items) => {
        registry.remove(...items);
        invalidatePlugins();
      }
    }
  });
  function clipArc(ctx, element, endAngle) {
    const { startAngle, pixelMargin, x, y: y2, outerRadius, innerRadius } = element;
    let angleMargin = pixelMargin / outerRadius;
    ctx.beginPath();
    ctx.arc(x, y2, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
      angleMargin = pixelMargin / innerRadius;
      ctx.arc(x, y2, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
      ctx.arc(x, y2, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
    }
    ctx.closePath();
    ctx.clip();
  }
  function toRadiusCorners(value) {
    return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
  }
  function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    const computeOuterLimit = (val) => {
      const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
      return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
      outerStart: computeOuterLimit(o.outerStart),
      outerEnd: computeOuterLimit(o.outerEnd),
      innerStart: _limitValue(o.innerStart, 0, innerLimit),
      innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
    };
  }
  function rThetaToXY(r, theta, x, y2) {
    return {
      x: x + r * Math.cos(theta),
      y: y2 + r * Math.sin(theta)
    };
  }
  function pathArc(ctx, element, offset, spacing, end, circular) {
    const { x, y: y2, startAngle: start2, pixelMargin, innerRadius: innerR } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha2 = end - start2;
    if (spacing) {
      const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
      const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
      const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
      const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
      spacingOffset = (alpha2 - adjustedAngle) / 2;
    }
    const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
    const angleOffset = (alpha2 - beta) / 2;
    const startAngle = start2 + angleOffset + spacingOffset;
    const endAngle = end - angleOffset - spacingOffset;
    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
      ctx.arc(x, y2, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
      if (outerEnd > 0) {
        const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y2);
        ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
      }
      const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y2);
      ctx.lineTo(p4.x, p4.y);
      if (innerEnd > 0) {
        const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y2);
        ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
      }
      ctx.arc(x, y2, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
      if (innerStart > 0) {
        const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y2);
        ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
      }
      const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y2);
      ctx.lineTo(p8.x, p8.y);
      if (outerStart > 0) {
        const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y2);
        ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
      }
    } else {
      ctx.moveTo(x, y2);
      const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
      const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y2;
      ctx.lineTo(outerStartX, outerStartY);
      const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
      const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y2;
      ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
  }
  function drawArc(ctx, element, offset, spacing, circular) {
    const { fullCircles, startAngle, circumference } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset, spacing, startAngle + TAU, circular);
      for (let i = 0; i < fullCircles; ++i) {
        ctx.fill();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + circumference % TAU;
        if (circumference % TAU === 0) {
          endAngle += TAU;
        }
      }
    }
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
  }
  function drawFullCircleBorders(ctx, element, inner) {
    const { x, y: y2, startAngle, pixelMargin, fullCircles } = element;
    const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
    const innerRadius = element.innerRadius + pixelMargin;
    let i;
    if (inner) {
      clipArc(ctx, element, startAngle + TAU);
    }
    ctx.beginPath();
    ctx.arc(x, y2, innerRadius, startAngle + TAU, startAngle, true);
    for (i = 0; i < fullCircles; ++i) {
      ctx.stroke();
    }
    ctx.beginPath();
    ctx.arc(x, y2, outerRadius, startAngle, startAngle + TAU);
    for (i = 0; i < fullCircles; ++i) {
      ctx.stroke();
    }
  }
  function drawBorder(ctx, element, offset, spacing, endAngle, circular) {
    const { options } = element;
    const { borderWidth, borderJoinStyle } = options;
    const inner = options.borderAlign === "inner";
    if (!borderWidth) {
      return;
    }
    if (inner) {
      ctx.lineWidth = borderWidth * 2;
      ctx.lineJoin = borderJoinStyle || "round";
    } else {
      ctx.lineWidth = borderWidth;
      ctx.lineJoin = borderJoinStyle || "bevel";
    }
    if (element.fullCircles) {
      drawFullCircleBorders(ctx, element, inner);
    }
    if (inner) {
      clipArc(ctx, element, endAngle);
    }
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.stroke();
  }
  var ArcElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.circumference = void 0;
      this.startAngle = void 0;
      this.endAngle = void 0;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.pixelMargin = 0;
      this.fullCircles = 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(chartX, chartY, useFinalPosition) {
      const point = this.getProps(["x", "y"], useFinalPosition);
      const { angle, distance } = getAngleFromPoint(point, { x: chartX, y: chartY });
      const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "circumference"
      ], useFinalPosition);
      const rAdjust = this.options.spacing / 2;
      const _circumference = valueOrDefault(circumference, endAngle - startAngle);
      const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
      const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
      return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
      const { x, y: y2, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "circumference"
      ], useFinalPosition);
      const { offset, spacing } = this.options;
      const halfAngle = (startAngle + endAngle) / 2;
      const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
      return {
        x: x + Math.cos(halfAngle) * halfRadius,
        y: y2 + Math.sin(halfAngle) * halfRadius
      };
    }
    tooltipPosition(useFinalPosition) {
      return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
      const { options, circumference } = this;
      const offset = (options.offset || 0) / 2;
      const spacing = (options.spacing || 0) / 2;
      const circular = options.circular;
      this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
      this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
      if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
        return;
      }
      ctx.save();
      let radiusOffset = 0;
      if (offset) {
        radiusOffset = offset / 2;
        const halfAngle = (this.startAngle + this.endAngle) / 2;
        ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
        if (this.circumference >= PI) {
          radiusOffset = offset;
        }
      }
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);
      drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);
      ctx.restore();
    }
  };
  ArcElement.id = "arc";
  ArcElement.defaults = {
    borderAlign: "center",
    borderColor: "#fff",
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: true
  };
  ArcElement.defaultRoutes = {
    backgroundColor: "backgroundColor"
  };
  function setStyle(ctx, options, style = options) {
    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
  }
  function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
  }
  function getLineMethod(options) {
    if (options.stepped) {
      return _steppedLineTo;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierCurveTo;
    }
    return lineTo;
  }
  function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
    const { start: segmentStart, end: segmentEnd } = segment;
    const start2 = Math.max(paramsStart, segmentStart);
    const end = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
      count,
      start: start2,
      loop: segment.loop,
      ilen: end < start2 && !outside ? count + end - start2 : end - start2
    };
  }
  function pathSegment(ctx, line, segment, params) {
    const { points, options } = line;
    const { count, start: start2, loop, ilen } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options);
    let { move = true, reverse } = params || {};
    let i, point, prev;
    for (i = 0; i <= ilen; ++i) {
      point = points[(start2 + (reverse ? ilen - i : i)) % count];
      if (point.skip) {
        continue;
      } else if (move) {
        ctx.moveTo(point.x, point.y);
        move = false;
      } else {
        lineMethod(ctx, prev, point, reverse, options.stepped);
      }
      prev = point;
    }
    if (loop) {
      point = points[(start2 + (reverse ? ilen : 0)) % count];
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    return !!loop;
  }
  function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count, start: start2, ilen } = pathVars(points, segment, params);
    const { move = true, reverse } = params || {};
    let avgX = 0;
    let countX = 0;
    let i, point, prevX, minY, maxY, lastY;
    const pointIndex = (index3) => (start2 + (reverse ? ilen - index3 : index3)) % count;
    const drawX = () => {
      if (minY !== maxY) {
        ctx.lineTo(avgX, maxY);
        ctx.lineTo(avgX, minY);
        ctx.lineTo(avgX, lastY);
      }
    };
    if (move) {
      point = points[pointIndex(0)];
      ctx.moveTo(point.x, point.y);
    }
    for (i = 0; i <= ilen; ++i) {
      point = points[pointIndex(i)];
      if (point.skip) {
        continue;
      }
      const x = point.x;
      const y2 = point.y;
      const truncX = x | 0;
      if (truncX === prevX) {
        if (y2 < minY) {
          minY = y2;
        } else if (y2 > maxY) {
          maxY = y2;
        }
        avgX = (countX * avgX + x) / ++countX;
      } else {
        drawX();
        ctx.lineTo(x, y2);
        prevX = truncX;
        countX = 0;
        minY = maxY = y2;
      }
      lastY = y2;
    }
    drawX();
  }
  function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
  }
  function _getInterpolationMethod(options) {
    if (options.stepped) {
      return _steppedInterpolation;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierInterpolation;
    }
    return _pointInLine;
  }
  function strokePathWithCache(ctx, line, start2, count) {
    let path = line._path;
    if (!path) {
      path = line._path = new Path2D();
      if (line.path(path, start2, count)) {
        path.closePath();
      }
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
  }
  function strokePathDirect(ctx, line, start2, count) {
    const { segments, options } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments) {
      setStyle(ctx, options, segment.style);
      ctx.beginPath();
      if (segmentMethod(ctx, line, segment, { start: start2, end: start2 + count - 1 })) {
        ctx.closePath();
      }
      ctx.stroke();
    }
  }
  var usePath2D = typeof Path2D === "function";
  function draw(ctx, line, start2, count) {
    if (usePath2D && !line.options.segment) {
      strokePathWithCache(ctx, line, start2, count);
    } else {
      strokePathDirect(ctx, line, start2, count);
    }
  }
  var LineElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.animated = true;
      this.options = void 0;
      this._chart = void 0;
      this._loop = void 0;
      this._fullLoop = void 0;
      this._path = void 0;
      this._points = void 0;
      this._segments = void 0;
      this._decimated = false;
      this._pointsUpdated = false;
      this._datasetIndex = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    updateControlPoints(chartArea, indexAxis) {
      const options = this.options;
      if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
        const loop = options.spanGaps ? this._loop : this._fullLoop;
        _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
        this._pointsUpdated = true;
      }
    }
    set points(points) {
      this._points = points;
      delete this._segments;
      delete this._path;
      this._pointsUpdated = false;
    }
    get points() {
      return this._points;
    }
    get segments() {
      return this._segments || (this._segments = _computeSegments(this, this.options.segment));
    }
    first() {
      const segments = this.segments;
      const points = this.points;
      return segments.length && points[segments[0].start];
    }
    last() {
      const segments = this.segments;
      const points = this.points;
      const count = segments.length;
      return count && points[segments[count - 1].end];
    }
    interpolate(point, property) {
      const options = this.options;
      const value = point[property];
      const points = this.points;
      const segments = _boundSegments(this, { property, start: value, end: value });
      if (!segments.length) {
        return;
      }
      const result = [];
      const _interpolate = _getInterpolationMethod(options);
      let i, ilen;
      for (i = 0, ilen = segments.length; i < ilen; ++i) {
        const { start: start2, end } = segments[i];
        const p1 = points[start2];
        const p2 = points[end];
        if (p1 === p2) {
          result.push(p1);
          continue;
        }
        const t2 = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
        const interpolated = _interpolate(p1, p2, t2, options.stepped);
        interpolated[property] = point[property];
        result.push(interpolated);
      }
      return result.length === 1 ? result[0] : result;
    }
    pathSegment(ctx, segment, params) {
      const segmentMethod = _getSegmentMethod(this);
      return segmentMethod(ctx, this, segment, params);
    }
    path(ctx, start2, count) {
      const segments = this.segments;
      const segmentMethod = _getSegmentMethod(this);
      let loop = this._loop;
      start2 = start2 || 0;
      count = count || this.points.length - start2;
      for (const segment of segments) {
        loop &= segmentMethod(ctx, this, segment, { start: start2, end: start2 + count - 1 });
      }
      return !!loop;
    }
    draw(ctx, chartArea, start2, count) {
      const options = this.options || {};
      const points = this.points || [];
      if (points.length && options.borderWidth) {
        ctx.save();
        draw(ctx, this, start2, count);
        ctx.restore();
      }
      if (this.animated) {
        this._pointsUpdated = false;
        this._path = void 0;
      }
    }
  };
  LineElement.id = "line";
  LineElement.defaults = {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: "default",
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
  };
  LineElement.defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  LineElement.descriptors = {
    _scriptable: true,
    _indexable: (name2) => name2 !== "borderDash" && name2 !== "fill"
  };
  function inRange$1(el3, pos, axis, useFinalPosition) {
    const options = el3.options;
    const { [axis]: value } = el3.getProps([axis], useFinalPosition);
    return Math.abs(pos - value) < options.radius + options.hitRadius;
  }
  var PointElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.parsed = void 0;
      this.skip = void 0;
      this.stop = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      const options = this.options;
      const { x, y: y2 } = this.getProps(["x", "y"], useFinalPosition);
      return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y2, 2) < Math.pow(options.hitRadius + options.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange$1(this, mouseX, "x", useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange$1(this, mouseY, "y", useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x, y: y2 } = this.getProps(["x", "y"], useFinalPosition);
      return { x, y: y2 };
    }
    size(options) {
      options = options || this.options || {};
      let radius = options.radius || 0;
      radius = Math.max(radius, radius && options.hoverRadius || 0);
      const borderWidth = radius && options.borderWidth || 0;
      return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
      const options = this.options;
      if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
        return;
      }
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.fillStyle = options.backgroundColor;
      drawPoint(ctx, options, this.x, this.y);
    }
    getRange() {
      const options = this.options || {};
      return options.radius + options.hitRadius;
    }
  };
  PointElement.id = "point";
  PointElement.defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  };
  PointElement.defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  function getBarBounds(bar, useFinalPosition) {
    const { x, y: y2, base: base2, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
    let left, right, top2, bottom, half;
    if (bar.horizontal) {
      half = height / 2;
      left = Math.min(x, base2);
      right = Math.max(x, base2);
      top2 = y2 - half;
      bottom = y2 + half;
    } else {
      half = width / 2;
      left = x - half;
      right = x + half;
      top2 = Math.min(y2, base2);
      bottom = Math.max(y2, base2);
    }
    return { left, top: top2, right, bottom };
  }
  function skipOrLimit(skip2, value, min, max) {
    return skip2 ? 0 : _limitValue(value, min, max);
  }
  function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip2 = bar.borderSkipped;
    const o = toTRBL(value);
    return {
      t: skipOrLimit(skip2.top, o.top, 0, maxH),
      r: skipOrLimit(skip2.right, o.right, 0, maxW),
      b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
      l: skipOrLimit(skip2.left, o.left, 0, maxW)
    };
  }
  function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
    const value = bar.options.borderRadius;
    const o = toTRBLCorners(value);
    const maxR = Math.min(maxW, maxH);
    const skip2 = bar.borderSkipped;
    const enableBorder = enableBorderRadius || isObject2(value);
    return {
      topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
      topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
      bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
      bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
    };
  }
  function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
      outer: {
        x: bounds.left,
        y: bounds.top,
        w: width,
        h: height,
        radius
      },
      inner: {
        x: bounds.left + border.l,
        y: bounds.top + border.t,
        w: width - border.l - border.r,
        h: height - border.t - border.b,
        radius: {
          topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
          topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
          bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
          bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
        }
      }
    };
  }
  function inRange(bar, x, y2, useFinalPosition) {
    const skipX = x === null;
    const skipY = y2 === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y2, bounds.top, bounds.bottom));
  }
  function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
  }
  function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
  }
  function inflateRect(rect, amount, refRect = {}) {
    const x = rect.x !== refRect.x ? -amount : 0;
    const y2 = rect.y !== refRect.y ? -amount : 0;
    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
    const h3 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y2;
    return {
      x: rect.x + x,
      y: rect.y + y2,
      w: rect.w + w,
      h: rect.h + h3,
      radius: rect.radius
    };
  }
  var BarElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.horizontal = void 0;
      this.base = void 0;
      this.width = void 0;
      this.height = void 0;
      this.inflateAmount = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    draw(ctx) {
      const { inflateAmount, options: { borderColor, backgroundColor } } = this;
      const { inner, outer } = boundingRects(this);
      const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
      ctx.save();
      if (outer.w !== inner.w || outer.h !== inner.h) {
        ctx.beginPath();
        addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
        ctx.clip();
        addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
        ctx.fillStyle = borderColor;
        ctx.fill("evenodd");
      }
      ctx.beginPath();
      addRectPath(ctx, inflateRect(inner, inflateAmount));
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x, y: y2, base: base2, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
      return {
        x: horizontal ? (x + base2) / 2 : x,
        y: horizontal ? y2 : (y2 + base2) / 2
      };
    }
    getRange(axis) {
      return axis === "x" ? this.width / 2 : this.height / 2;
    }
  };
  BarElement.id = "bar";
  BarElement.defaults = {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  };
  BarElement.defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  var elements = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcElement,
    LineElement,
    PointElement,
    BarElement
  });
  function lttbDecimation(data, start2, count, availableWidth, options) {
    const samples = options.samples || availableWidth;
    if (samples >= count) {
      return data.slice(start2, start2 + count);
    }
    const decimated = [];
    const bucketWidth = (count - 2) / (samples - 2);
    let sampledIndex = 0;
    const endIndex = start2 + count - 1;
    let a = start2;
    let i, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data[a];
    for (i = 0; i < samples - 2; i++) {
      let avgX = 0;
      let avgY = 0;
      let j2;
      const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start2;
      const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start2;
      const avgRangeLength = avgRangeEnd - avgRangeStart;
      for (j2 = avgRangeStart; j2 < avgRangeEnd; j2++) {
        avgX += data[j2].x;
        avgY += data[j2].y;
      }
      avgX /= avgRangeLength;
      avgY /= avgRangeLength;
      const rangeOffs = Math.floor(i * bucketWidth) + 1 + start2;
      const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start2;
      const { x: pointAx, y: pointAy } = data[a];
      maxArea = area = -1;
      for (j2 = rangeOffs; j2 < rangeTo; j2++) {
        area = 0.5 * Math.abs((pointAx - avgX) * (data[j2].y - pointAy) - (pointAx - data[j2].x) * (avgY - pointAy));
        if (area > maxArea) {
          maxArea = area;
          maxAreaPoint = data[j2];
          nextA = j2;
        }
      }
      decimated[sampledIndex++] = maxAreaPoint;
      a = nextA;
    }
    decimated[sampledIndex++] = data[endIndex];
    return decimated;
  }
  function minMaxDecimation(data, start2, count, availableWidth) {
    let avgX = 0;
    let countX = 0;
    let i, point, x, y2, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    const decimated = [];
    const endIndex = start2 + count - 1;
    const xMin = data[start2].x;
    const xMax = data[endIndex].x;
    const dx = xMax - xMin;
    for (i = start2; i < start2 + count; ++i) {
      point = data[i];
      x = (point.x - xMin) / dx * availableWidth;
      y2 = point.y;
      const truncX = x | 0;
      if (truncX === prevX) {
        if (y2 < minY) {
          minY = y2;
          minIndex = i;
        } else if (y2 > maxY) {
          maxY = y2;
          maxIndex = i;
        }
        avgX = (countX * avgX + point.x) / ++countX;
      } else {
        const lastIndex = i - 1;
        if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
          const intermediateIndex1 = Math.min(minIndex, maxIndex);
          const intermediateIndex2 = Math.max(minIndex, maxIndex);
          if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
            decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex1]), {
              x: avgX
            }));
          }
          if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
            decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex2]), {
              x: avgX
            }));
          }
        }
        if (i > 0 && lastIndex !== startIndex) {
          decimated.push(data[lastIndex]);
        }
        decimated.push(point);
        prevX = truncX;
        countX = 0;
        minY = maxY = y2;
        minIndex = maxIndex = startIndex = i;
      }
    }
    return decimated;
  }
  function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
      const data = dataset._data;
      delete dataset._decimated;
      delete dataset._data;
      Object.defineProperty(dataset, "data", { value: data });
    }
  }
  function cleanDecimatedData(chart) {
    chart.data.datasets.forEach((dataset) => {
      cleanDecimatedDataset(dataset);
    });
  }
  function getStartAndCountOfVisiblePointsSimplified(meta2, points) {
    const pointCount = points.length;
    let start2 = 0;
    let count;
    const { iScale } = meta2;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start2 = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start2, pointCount) - start2;
    } else {
      count = pointCount - start2;
    }
    return { start: start2, count };
  }
  var plugin_decimation = {
    id: "decimation",
    defaults: {
      algorithm: "min-max",
      enabled: false
    },
    beforeElementsUpdate: (chart, args, options) => {
      if (!options.enabled) {
        cleanDecimatedData(chart);
        return;
      }
      const availableWidth = chart.width;
      chart.data.datasets.forEach((dataset, datasetIndex) => {
        const { _data, indexAxis } = dataset;
        const meta2 = chart.getDatasetMeta(datasetIndex);
        const data = _data || dataset.data;
        if (resolve([indexAxis, chart.options.indexAxis]) === "y") {
          return;
        }
        if (!meta2.controller.supportsDecimation) {
          return;
        }
        const xAxis = chart.scales[meta2.xAxisID];
        if (xAxis.type !== "linear" && xAxis.type !== "time") {
          return;
        }
        if (chart.options.parsing) {
          return;
        }
        let { start: start2, count } = getStartAndCountOfVisiblePointsSimplified(meta2, data);
        const threshold = options.threshold || 4 * availableWidth;
        if (count <= threshold) {
          cleanDecimatedDataset(dataset);
          return;
        }
        if (isNullOrUndef(_data)) {
          dataset._data = data;
          delete dataset.data;
          Object.defineProperty(dataset, "data", {
            configurable: true,
            enumerable: true,
            get: function() {
              return this._decimated;
            },
            set: function(d2) {
              this._data = d2;
            }
          });
        }
        let decimated;
        switch (options.algorithm) {
          case "lttb":
            decimated = lttbDecimation(data, start2, count, availableWidth, options);
            break;
          case "min-max":
            decimated = minMaxDecimation(data, start2, count, availableWidth);
            break;
          default:
            throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
        }
        dataset._decimated = decimated;
      });
    },
    destroy(chart) {
      cleanDecimatedData(chart);
    }
  };
  function _segments(line, target, property) {
    const segments = line.segments;
    const points = line.points;
    const tpoints = target.points;
    const parts = [];
    for (const segment of segments) {
      let { start: start2, end } = segment;
      end = _findSegmentEnd(start2, end, points);
      const bounds = _getBounds(property, points[start2], points[end], segment.loop);
      if (!target.segments) {
        parts.push({
          source: segment,
          target: bounds,
          start: points[start2],
          end: points[end]
        });
        continue;
      }
      const targetSegments = _boundSegments(target, bounds);
      for (const tgt of targetSegments) {
        const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
        const fillSources = _boundSegment(segment, points, subBounds);
        for (const fillSource of fillSources) {
          parts.push({
            source: fillSource,
            target: tgt,
            start: {
              [property]: _getEdge(bounds, subBounds, "start", Math.max)
            },
            end: {
              [property]: _getEdge(bounds, subBounds, "end", Math.min)
            }
          });
        }
      }
    }
    return parts;
  }
  function _getBounds(property, first, last, loop) {
    if (loop) {
      return;
    }
    let start2 = first[property];
    let end = last[property];
    if (property === "angle") {
      start2 = _normalizeAngle(start2);
      end = _normalizeAngle(end);
    }
    return { property, start: start2, end };
  }
  function _pointsFromSegments(boundary, line) {
    const { x = null, y: y2 = null } = boundary || {};
    const linePoints = line.points;
    const points = [];
    line.segments.forEach(({ start: start2, end }) => {
      end = _findSegmentEnd(start2, end, linePoints);
      const first = linePoints[start2];
      const last = linePoints[end];
      if (y2 !== null) {
        points.push({ x: first.x, y: y2 });
        points.push({ x: last.x, y: y2 });
      } else if (x !== null) {
        points.push({ x, y: first.y });
        points.push({ x, y: last.y });
      }
    });
    return points;
  }
  function _findSegmentEnd(start2, end, points) {
    for (; end > start2; end--) {
      const point = points[end];
      if (!isNaN(point.x) && !isNaN(point.y)) {
        break;
      }
    }
    return end;
  }
  function _getEdge(a, b, prop, fn2) {
    if (a && b) {
      return fn2(a[prop], b[prop]);
    }
    return a ? a[prop] : b ? b[prop] : 0;
  }
  function _createBoundaryLine(boundary, line) {
    let points = [];
    let _loop = false;
    if (isArray2(boundary)) {
      _loop = true;
      points = boundary;
    } else {
      points = _pointsFromSegments(boundary, line);
    }
    return points.length ? new LineElement({
      points,
      options: { tension: 0 },
      _loop,
      _fullLoop: _loop
    }) : null;
  }
  function _shouldApplyFill(source) {
    return source && source.fill !== false;
  }
  function _resolveTarget(sources, index3, propagate) {
    const source = sources[index3];
    let fill2 = source.fill;
    const visited = [index3];
    let target;
    if (!propagate) {
      return fill2;
    }
    while (fill2 !== false && visited.indexOf(fill2) === -1) {
      if (!isNumberFinite(fill2)) {
        return fill2;
      }
      target = sources[fill2];
      if (!target) {
        return false;
      }
      if (target.visible) {
        return fill2;
      }
      visited.push(fill2);
      fill2 = target.fill;
    }
    return false;
  }
  function _decodeFill(line, index3, count) {
    const fill2 = parseFillOption(line);
    if (isObject2(fill2)) {
      return isNaN(fill2.value) ? false : fill2;
    }
    let target = parseFloat(fill2);
    if (isNumberFinite(target) && Math.floor(target) === target) {
      return decodeTargetIndex(fill2[0], index3, target, count);
    }
    return ["origin", "start", "end", "stack", "shape"].indexOf(fill2) >= 0 && fill2;
  }
  function decodeTargetIndex(firstCh, index3, target, count) {
    if (firstCh === "-" || firstCh === "+") {
      target = index3 + target;
    }
    if (target === index3 || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  function _getTargetPixel(fill2, scale) {
    let pixel = null;
    if (fill2 === "start") {
      pixel = scale.bottom;
    } else if (fill2 === "end") {
      pixel = scale.top;
    } else if (isObject2(fill2)) {
      pixel = scale.getPixelForValue(fill2.value);
    } else if (scale.getBasePixel) {
      pixel = scale.getBasePixel();
    }
    return pixel;
  }
  function _getTargetValue(fill2, scale, startValue) {
    let value;
    if (fill2 === "start") {
      value = startValue;
    } else if (fill2 === "end") {
      value = scale.options.reverse ? scale.min : scale.max;
    } else if (isObject2(fill2)) {
      value = fill2.value;
    } else {
      value = scale.getBaseValue();
    }
    return value;
  }
  function parseFillOption(line) {
    const options = line.options;
    const fillOption = options.fill;
    let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
    if (fill2 === void 0) {
      fill2 = !!options.backgroundColor;
    }
    if (fill2 === false || fill2 === null) {
      return false;
    }
    if (fill2 === true) {
      return "origin";
    }
    return fill2;
  }
  function _buildStackLine(source) {
    const { scale, index: index3, line } = source;
    const points = [];
    const segments = line.segments;
    const sourcePoints = line.points;
    const linesBelow = getLinesBelow(scale, index3);
    linesBelow.push(_createBoundaryLine({ x: null, y: scale.bottom }, line));
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      for (let j2 = segment.start; j2 <= segment.end; j2++) {
        addPointsBelow(points, sourcePoints[j2], linesBelow);
      }
    }
    return new LineElement({ points, options: {} });
  }
  function getLinesBelow(scale, index3) {
    const below = [];
    const metas = scale.getMatchingVisibleMetas("line");
    for (let i = 0; i < metas.length; i++) {
      const meta2 = metas[i];
      if (meta2.index === index3) {
        break;
      }
      if (!meta2.hidden) {
        below.unshift(meta2.dataset);
      }
    }
    return below;
  }
  function addPointsBelow(points, sourcePoint, linesBelow) {
    const postponed = [];
    for (let j2 = 0; j2 < linesBelow.length; j2++) {
      const line = linesBelow[j2];
      const { first, last, point } = findPoint(line, sourcePoint, "x");
      if (!point || first && last) {
        continue;
      }
      if (first) {
        postponed.unshift(point);
      } else {
        points.push(point);
        if (!last) {
          break;
        }
      }
    }
    points.push(...postponed);
  }
  function findPoint(line, sourcePoint, property) {
    const point = line.interpolate(sourcePoint, property);
    if (!point) {
      return {};
    }
    const pointValue = point[property];
    const segments = line.segments;
    const linePoints = line.points;
    let first = false;
    let last = false;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      const firstValue = linePoints[segment.start][property];
      const lastValue = linePoints[segment.end][property];
      if (_isBetween(pointValue, firstValue, lastValue)) {
        first = pointValue === firstValue;
        last = pointValue === lastValue;
        break;
      }
    }
    return { first, last, point };
  }
  var simpleArc = class {
    constructor(opts) {
      this.x = opts.x;
      this.y = opts.y;
      this.radius = opts.radius;
    }
    pathSegment(ctx, bounds, opts) {
      const { x, y: y2, radius } = this;
      bounds = bounds || { start: 0, end: TAU };
      ctx.arc(x, y2, radius, bounds.end, bounds.start, true);
      return !opts.bounds;
    }
    interpolate(point) {
      const { x, y: y2, radius } = this;
      const angle = point.angle;
      return {
        x: x + Math.cos(angle) * radius,
        y: y2 + Math.sin(angle) * radius,
        angle
      };
    }
  };
  function _getTarget(source) {
    const { chart, fill: fill2, line } = source;
    if (isNumberFinite(fill2)) {
      return getLineByIndex(chart, fill2);
    }
    if (fill2 === "stack") {
      return _buildStackLine(source);
    }
    if (fill2 === "shape") {
      return true;
    }
    const boundary = computeBoundary(source);
    if (boundary instanceof simpleArc) {
      return boundary;
    }
    return _createBoundaryLine(boundary, line);
  }
  function getLineByIndex(chart, index3) {
    const meta2 = chart.getDatasetMeta(index3);
    const visible = meta2 && chart.isDatasetVisible(index3);
    return visible ? meta2.dataset : null;
  }
  function computeBoundary(source) {
    const scale = source.scale || {};
    if (scale.getPointPositionForValue) {
      return computeCircularBoundary(source);
    }
    return computeLinearBoundary(source);
  }
  function computeLinearBoundary(source) {
    const { scale = {}, fill: fill2 } = source;
    const pixel = _getTargetPixel(fill2, scale);
    if (isNumberFinite(pixel)) {
      const horizontal = scale.isHorizontal();
      return {
        x: horizontal ? pixel : null,
        y: horizontal ? null : pixel
      };
    }
    return null;
  }
  function computeCircularBoundary(source) {
    const { scale, fill: fill2 } = source;
    const options = scale.options;
    const length = scale.getLabels().length;
    const start2 = options.reverse ? scale.max : scale.min;
    const value = _getTargetValue(fill2, scale, start2);
    const target = [];
    if (options.grid.circular) {
      const center = scale.getPointPositionForValue(0, start2);
      return new simpleArc({
        x: center.x,
        y: center.y,
        radius: scale.getDistanceFromCenterForValue(value)
      });
    }
    for (let i = 0; i < length; ++i) {
      target.push(scale.getPointPositionForValue(i, value));
    }
    return target;
  }
  function _drawfill(ctx, source, area) {
    const target = _getTarget(source);
    const { line, scale, axis } = source;
    const lineOpts = line.options;
    const fillOption = lineOpts.fill;
    const color19 = lineOpts.backgroundColor;
    const { above = color19, below = color19 } = fillOption || {};
    if (target && line.points.length) {
      clipArea(ctx, area);
      doFill(ctx, { line, target, above, below, area, scale, axis });
      unclipArea(ctx);
    }
  }
  function doFill(ctx, cfg) {
    const { line, target, above, below, area, scale } = cfg;
    const property = line._loop ? "angle" : cfg.axis;
    ctx.save();
    if (property === "x" && below !== above) {
      clipVertical(ctx, target, area.top);
      fill(ctx, { line, target, color: above, scale, property });
      ctx.restore();
      ctx.save();
      clipVertical(ctx, target, area.bottom);
    }
    fill(ctx, { line, target, color: below, scale, property });
    ctx.restore();
  }
  function clipVertical(ctx, target, clipY) {
    const { segments, points } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments) {
      const { start: start2, end } = segment;
      const firstPoint = points[start2];
      const lastPoint = points[_findSegmentEnd(start2, end, points)];
      if (first) {
        ctx.moveTo(firstPoint.x, firstPoint.y);
        first = false;
      } else {
        ctx.lineTo(firstPoint.x, clipY);
        ctx.lineTo(firstPoint.x, firstPoint.y);
      }
      lineLoop = !!target.pathSegment(ctx, segment, { move: lineLoop });
      if (lineLoop) {
        ctx.closePath();
      } else {
        ctx.lineTo(lastPoint.x, clipY);
      }
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
  }
  function fill(ctx, cfg) {
    const { line, target, property, color: color19, scale } = cfg;
    const segments = _segments(line, target, property);
    for (const { source: src, target: tgt, start: start2, end } of segments) {
      const { style: { backgroundColor = color19 } = {} } = src;
      const notShape = target !== true;
      ctx.save();
      ctx.fillStyle = backgroundColor;
      clipBounds(ctx, scale, notShape && _getBounds(property, start2, end));
      ctx.beginPath();
      const lineLoop = !!line.pathSegment(ctx, src);
      let loop;
      if (notShape) {
        if (lineLoop) {
          ctx.closePath();
        } else {
          interpolatedLineTo(ctx, target, end, property);
        }
        const targetLoop = !!target.pathSegment(ctx, tgt, { move: lineLoop, reverse: true });
        loop = lineLoop && targetLoop;
        if (!loop) {
          interpolatedLineTo(ctx, target, start2, property);
        }
      }
      ctx.closePath();
      ctx.fill(loop ? "evenodd" : "nonzero");
      ctx.restore();
    }
  }
  function clipBounds(ctx, scale, bounds) {
    const { top: top2, bottom } = scale.chart.chartArea;
    const { property, start: start2, end } = bounds || {};
    if (property === "x") {
      ctx.beginPath();
      ctx.rect(start2, top2, end - start2, bottom - top2);
      ctx.clip();
    }
  }
  function interpolatedLineTo(ctx, target, point, property) {
    const interpolatedPoint = target.interpolate(point, property);
    if (interpolatedPoint) {
      ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
    }
  }
  var index2 = {
    id: "filler",
    afterDatasetsUpdate(chart, _args, options) {
      const count = (chart.data.datasets || []).length;
      const sources = [];
      let meta2, i, line, source;
      for (i = 0; i < count; ++i) {
        meta2 = chart.getDatasetMeta(i);
        line = meta2.dataset;
        source = null;
        if (line && line.options && line instanceof LineElement) {
          source = {
            visible: chart.isDatasetVisible(i),
            index: i,
            fill: _decodeFill(line, i, count),
            chart,
            axis: meta2.controller.options.indexAxis,
            scale: meta2.vScale,
            line
          };
        }
        meta2.$filler = source;
        sources.push(source);
      }
      for (i = 0; i < count; ++i) {
        source = sources[i];
        if (!source || source.fill === false) {
          continue;
        }
        source.fill = _resolveTarget(sources, i, options.propagate);
      }
    },
    beforeDraw(chart, _args, options) {
      const draw2 = options.drawTime === "beforeDraw";
      const metasets = chart.getSortedVisibleDatasetMetas();
      const area = chart.chartArea;
      for (let i = metasets.length - 1; i >= 0; --i) {
        const source = metasets[i].$filler;
        if (!source) {
          continue;
        }
        source.line.updateControlPoints(area, source.axis);
        if (draw2 && source.fill) {
          _drawfill(chart.ctx, source, area);
        }
      }
    },
    beforeDatasetsDraw(chart, _args, options) {
      if (options.drawTime !== "beforeDatasetsDraw") {
        return;
      }
      const metasets = chart.getSortedVisibleDatasetMetas();
      for (let i = metasets.length - 1; i >= 0; --i) {
        const source = metasets[i].$filler;
        if (_shouldApplyFill(source)) {
          _drawfill(chart.ctx, source, chart.chartArea);
        }
      }
    },
    beforeDatasetDraw(chart, args, options) {
      const source = args.meta.$filler;
      if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
        return;
      }
      _drawfill(chart.ctx, source, chart.chartArea);
    },
    defaults: {
      propagate: true,
      drawTime: "beforeDatasetDraw"
    }
  };
  var getBoxSize = (labelOpts, fontSize) => {
    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
    if (labelOpts.usePointStyle) {
      boxHeight = Math.min(boxHeight, fontSize);
      boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
      boxWidth,
      boxHeight,
      itemHeight: Math.max(fontSize, boxHeight)
    };
  };
  var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
  var Legend = class extends Element2 {
    constructor(config) {
      super();
      this._added = false;
      this.legendHitBoxes = [];
      this._hoveredItem = null;
      this.doughnutMode = false;
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this.legendItems = void 0;
      this.columnSizes = void 0;
      this.lineWidths = void 0;
      this.maxHeight = void 0;
      this.maxWidth = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.height = void 0;
      this.width = void 0;
      this._margins = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight, margins) {
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins;
      this.setDimensions();
      this.buildLabels();
      this.fit();
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = this._margins.left;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = this._margins.top;
        this.bottom = this.height;
      }
    }
    buildLabels() {
      const labelOpts = this.options.labels || {};
      let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
      if (labelOpts.filter) {
        legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
      }
      if (labelOpts.sort) {
        legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
      }
      if (this.options.reverse) {
        legendItems.reverse();
      }
      this.legendItems = legendItems;
    }
    fit() {
      const { options, ctx } = this;
      if (!options.display) {
        this.width = this.height = 0;
        return;
      }
      const labelOpts = options.labels;
      const labelFont = toFont(labelOpts.font);
      const fontSize = labelFont.size;
      const titleHeight = this._computeTitleHeight();
      const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
      let width, height;
      ctx.font = labelFont.string;
      if (this.isHorizontal()) {
        width = this.maxWidth;
        height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
      } else {
        height = this.maxHeight;
        width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
      }
      this.width = Math.min(width, options.maxWidth || this.maxWidth);
      this.height = Math.min(height, options.maxHeight || this.maxHeight);
    }
    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
      const { ctx, maxWidth, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const lineWidths = this.lineWidths = [0];
      const lineHeight = itemHeight + padding;
      let totalHeight = titleHeight;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      let row = -1;
      let top2 = -lineHeight;
      this.legendItems.forEach((legendItem, i) => {
        const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
        if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
          totalHeight += lineHeight;
          lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
          top2 += lineHeight;
          row++;
        }
        hitboxes[i] = { left: 0, top: top2, row, width: itemWidth, height: itemHeight };
        lineWidths[lineWidths.length - 1] += itemWidth + padding;
      });
      return totalHeight;
    }
    _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
      const { ctx, maxHeight, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const columnSizes = this.columnSizes = [];
      const heightLimit = maxHeight - titleHeight;
      let totalWidth = padding;
      let currentColWidth = 0;
      let currentColHeight = 0;
      let left = 0;
      let col = 0;
      this.legendItems.forEach((legendItem, i) => {
        const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
        if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
          totalWidth += currentColWidth + padding;
          columnSizes.push({ width: currentColWidth, height: currentColHeight });
          left += currentColWidth + padding;
          col++;
          currentColWidth = currentColHeight = 0;
        }
        hitboxes[i] = { left, top: currentColHeight, col, width: itemWidth, height: itemHeight };
        currentColWidth = Math.max(currentColWidth, itemWidth);
        currentColHeight += itemHeight + padding;
      });
      totalWidth += currentColWidth;
      columnSizes.push({ width: currentColWidth, height: currentColHeight });
      return totalWidth;
    }
    adjustHitBoxes() {
      if (!this.options.display) {
        return;
      }
      const titleHeight = this._computeTitleHeight();
      const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
      const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
      if (this.isHorizontal()) {
        let row = 0;
        let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        for (const hitbox of hitboxes) {
          if (row !== hitbox.row) {
            row = hitbox.row;
            left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
          }
          hitbox.top += this.top + titleHeight + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
          left += hitbox.width + padding;
        }
      } else {
        let col = 0;
        let top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        for (const hitbox of hitboxes) {
          if (hitbox.col !== col) {
            col = hitbox.col;
            top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
          }
          hitbox.top = top2;
          hitbox.left += this.left + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
          top2 += hitbox.height + padding;
        }
      }
    }
    isHorizontal() {
      return this.options.position === "top" || this.options.position === "bottom";
    }
    draw() {
      if (this.options.display) {
        const ctx = this.ctx;
        clipArea(ctx, this);
        this._draw();
        unclipArea(ctx);
      }
    }
    _draw() {
      const { options: opts, columnSizes, lineWidths, ctx } = this;
      const { align, labels: labelOpts } = opts;
      const defaultColor = defaults3.color;
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const labelFont = toFont(labelOpts.font);
      const { color: fontColor, padding } = labelOpts;
      const fontSize = labelFont.size;
      const halfFontSize = fontSize / 2;
      let cursor;
      this.drawTitle();
      ctx.textAlign = rtlHelper.textAlign("left");
      ctx.textBaseline = "middle";
      ctx.lineWidth = 0.5;
      ctx.font = labelFont.string;
      const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
      const drawLegendBox = function(x, y2, legendItem) {
        if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
          return;
        }
        ctx.save();
        const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
        ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
        ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
        ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
        ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
        if (labelOpts.usePointStyle) {
          const drawOptions = {
            radius: boxHeight * Math.SQRT2 / 2,
            pointStyle: legendItem.pointStyle,
            rotation: legendItem.rotation,
            borderWidth: lineWidth
          };
          const centerX = rtlHelper.xPlus(x, boxWidth / 2);
          const centerY = y2 + halfFontSize;
          drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
        } else {
          const yBoxTop = y2 + Math.max((fontSize - boxHeight) / 2, 0);
          const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
          const borderRadius = toTRBLCorners(legendItem.borderRadius);
          ctx.beginPath();
          if (Object.values(borderRadius).some((v) => v !== 0)) {
            addRoundedRectPath(ctx, {
              x: xBoxLeft,
              y: yBoxTop,
              w: boxWidth,
              h: boxHeight,
              radius: borderRadius
            });
          } else {
            ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
          }
          ctx.fill();
          if (lineWidth !== 0) {
            ctx.stroke();
          }
        }
        ctx.restore();
      };
      const fillText = function(x, y2, legendItem) {
        renderText(ctx, legendItem.text, x, y2 + itemHeight / 2, labelFont, {
          strikethrough: legendItem.hidden,
          textAlign: rtlHelper.textAlign(legendItem.textAlign)
        });
      };
      const isHorizontal = this.isHorizontal();
      const titleHeight = this._computeTitleHeight();
      if (isHorizontal) {
        cursor = {
          x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
          y: this.top + padding + titleHeight,
          line: 0
        };
      } else {
        cursor = {
          x: this.left + padding,
          y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
          line: 0
        };
      }
      overrideTextDirection(this.ctx, opts.textDirection);
      const lineHeight = itemHeight + padding;
      this.legendItems.forEach((legendItem, i) => {
        ctx.strokeStyle = legendItem.fontColor || fontColor;
        ctx.fillStyle = legendItem.fontColor || fontColor;
        const textWidth = ctx.measureText(legendItem.text).width;
        const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
        const width = boxWidth + halfFontSize + textWidth;
        let x = cursor.x;
        let y2 = cursor.y;
        rtlHelper.setWidth(this.width);
        if (isHorizontal) {
          if (i > 0 && x + width + padding > this.right) {
            y2 = cursor.y += lineHeight;
            cursor.line++;
            x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
          }
        } else if (i > 0 && y2 + lineHeight > this.bottom) {
          x = cursor.x = x + columnSizes[cursor.line].width + padding;
          cursor.line++;
          y2 = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
        }
        const realX = rtlHelper.x(x);
        drawLegendBox(realX, y2, legendItem);
        x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
        fillText(rtlHelper.x(x), y2, legendItem);
        if (isHorizontal) {
          cursor.x += width + padding;
        } else {
          cursor.y += lineHeight;
        }
      });
      restoreTextDirection(this.ctx, opts.textDirection);
    }
    drawTitle() {
      const opts = this.options;
      const titleOpts = opts.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      if (!titleOpts.display) {
        return;
      }
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const ctx = this.ctx;
      const position = titleOpts.position;
      const halfFontSize = titleFont.size / 2;
      const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
      let y2;
      let left = this.left;
      let maxWidth = this.width;
      if (this.isHorizontal()) {
        maxWidth = Math.max(...this.lineWidths);
        y2 = this.top + topPaddingPlusHalfFontSize;
        left = _alignStartEnd(opts.align, left, this.right - maxWidth);
      } else {
        const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
        y2 = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
      }
      const x = _alignStartEnd(position, left, left + maxWidth);
      ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
      ctx.textBaseline = "middle";
      ctx.strokeStyle = titleOpts.color;
      ctx.fillStyle = titleOpts.color;
      ctx.font = titleFont.string;
      renderText(ctx, titleOpts.text, x, y2, titleFont);
    }
    _computeTitleHeight() {
      const titleOpts = this.options.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
    _getLegendItemAt(x, y2) {
      let i, hitBox, lh2;
      if (_isBetween(x, this.left, this.right) && _isBetween(y2, this.top, this.bottom)) {
        lh2 = this.legendHitBoxes;
        for (i = 0; i < lh2.length; ++i) {
          hitBox = lh2[i];
          if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y2, hitBox.top, hitBox.top + hitBox.height)) {
            return this.legendItems[i];
          }
        }
      }
      return null;
    }
    handleEvent(e) {
      const opts = this.options;
      if (!isListened(e.type, opts)) {
        return;
      }
      const hoveredItem = this._getLegendItemAt(e.x, e.y);
      if (e.type === "mousemove" || e.type === "mouseout") {
        const previous = this._hoveredItem;
        const sameItem = itemsEqual(previous, hoveredItem);
        if (previous && !sameItem) {
          callback(opts.onLeave, [e, previous, this], this);
        }
        this._hoveredItem = hoveredItem;
        if (hoveredItem && !sameItem) {
          callback(opts.onHover, [e, hoveredItem, this], this);
        }
      } else if (hoveredItem) {
        callback(opts.onClick, [e, hoveredItem, this], this);
      }
    }
  };
  function isListened(type, opts) {
    if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
      return true;
    }
    if (opts.onClick && (type === "click" || type === "mouseup")) {
      return true;
    }
    return false;
  }
  var plugin_legend = {
    id: "legend",
    _element: Legend,
    start(chart, _args, options) {
      const legend = chart.legend = new Legend({ ctx: chart.ctx, options, chart });
      layouts.configure(chart, legend, options);
      layouts.addBox(chart, legend);
    },
    stop(chart) {
      layouts.removeBox(chart, chart.legend);
      delete chart.legend;
    },
    beforeUpdate(chart, _args, options) {
      const legend = chart.legend;
      layouts.configure(chart, legend, options);
      legend.options = options;
    },
    afterUpdate(chart) {
      const legend = chart.legend;
      legend.buildLabels();
      legend.adjustHitBoxes();
    },
    afterEvent(chart, args) {
      if (!args.replay) {
        chart.legend.handleEvent(args.event);
      }
    },
    defaults: {
      display: true,
      position: "top",
      align: "center",
      fullSize: true,
      reverse: false,
      weight: 1e3,
      onClick(e, legendItem, legend) {
        const index3 = legendItem.datasetIndex;
        const ci2 = legend.chart;
        if (ci2.isDatasetVisible(index3)) {
          ci2.hide(index3);
          legendItem.hidden = true;
        } else {
          ci2.show(index3);
          legendItem.hidden = false;
        }
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: (ctx) => ctx.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(chart) {
          const datasets = chart.data.datasets;
          const { labels: { usePointStyle, pointStyle, textAlign, color: color19 } } = chart.legend.options;
          return chart._getSortedDatasetMetas().map((meta2) => {
            const style = meta2.controller.getStyle(usePointStyle ? 0 : void 0);
            const borderWidth = toPadding(style.borderWidth);
            return {
              text: datasets[meta2.index].label,
              fillStyle: style.backgroundColor,
              fontColor: color19,
              hidden: !meta2.visible,
              lineCap: style.borderCapStyle,
              lineDash: style.borderDash,
              lineDashOffset: style.borderDashOffset,
              lineJoin: style.borderJoinStyle,
              lineWidth: (borderWidth.width + borderWidth.height) / 4,
              strokeStyle: style.borderColor,
              pointStyle: pointStyle || style.pointStyle,
              rotation: style.rotation,
              textAlign: textAlign || style.textAlign,
              borderRadius: 0,
              datasetIndex: meta2.index
            };
          }, this);
        }
      },
      title: {
        color: (ctx) => ctx.chart.options.color,
        display: false,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: (name2) => !name2.startsWith("on"),
      labels: {
        _scriptable: (name2) => !["generateLabels", "filter", "sort"].includes(name2)
      }
    }
  };
  var Title = class extends Element2 {
    constructor(config) {
      super();
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this._padding = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight) {
      const opts = this.options;
      this.left = 0;
      this.top = 0;
      if (!opts.display) {
        this.width = this.height = this.right = this.bottom = 0;
        return;
      }
      this.width = this.right = maxWidth;
      this.height = this.bottom = maxHeight;
      const lineCount = isArray2(opts.text) ? opts.text.length : 1;
      this._padding = toPadding(opts.padding);
      const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
      if (this.isHorizontal()) {
        this.height = textSize;
      } else {
        this.width = textSize;
      }
    }
    isHorizontal() {
      const pos = this.options.position;
      return pos === "top" || pos === "bottom";
    }
    _drawArgs(offset) {
      const { top: top2, left, bottom, right, options } = this;
      const align = options.align;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      if (this.isHorizontal()) {
        titleX = _alignStartEnd(align, left, right);
        titleY = top2 + offset;
        maxWidth = right - left;
      } else {
        if (options.position === "left") {
          titleX = left + offset;
          titleY = _alignStartEnd(align, bottom, top2);
          rotation = PI * -0.5;
        } else {
          titleX = right - offset;
          titleY = _alignStartEnd(align, top2, bottom);
          rotation = PI * 0.5;
        }
        maxWidth = bottom - top2;
      }
      return { titleX, titleY, maxWidth, rotation };
    }
    draw() {
      const ctx = this.ctx;
      const opts = this.options;
      if (!opts.display) {
        return;
      }
      const fontOpts = toFont(opts.font);
      const lineHeight = fontOpts.lineHeight;
      const offset = lineHeight / 2 + this._padding.top;
      const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
      renderText(ctx, opts.text, 0, 0, fontOpts, {
        color: opts.color,
        maxWidth,
        rotation,
        textAlign: _toLeftRightCenter(opts.align),
        textBaseline: "middle",
        translation: [titleX, titleY]
      });
    }
  };
  function createTitle(chart, titleOpts) {
    const title = new Title({
      ctx: chart.ctx,
      options: titleOpts,
      chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
  }
  var plugin_title = {
    id: "title",
    _element: Title,
    start(chart, _args, options) {
      createTitle(chart, options);
    },
    stop(chart) {
      const titleBlock = chart.titleBlock;
      layouts.removeBox(chart, titleBlock);
      delete chart.titleBlock;
    },
    beforeUpdate(chart, _args, options) {
      const title = chart.titleBlock;
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "bold"
      },
      fullSize: true,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var map2 = new WeakMap();
  var plugin_subtitle = {
    id: "subtitle",
    start(chart, _args, options) {
      const title = new Title({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, title, options);
      layouts.addBox(chart, title);
      map2.set(chart, title);
    },
    stop(chart) {
      layouts.removeBox(chart, map2.get(chart));
      map2.delete(chart);
    },
    beforeUpdate(chart, _args, options) {
      const title = map2.get(chart);
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "normal"
      },
      fullSize: true,
      padding: 0,
      position: "top",
      text: "",
      weight: 1500
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var positioners = {
    average(items) {
      if (!items.length) {
        return false;
      }
      let i, len;
      let x = 0;
      let y2 = 0;
      let count = 0;
      for (i = 0, len = items.length; i < len; ++i) {
        const el3 = items[i].element;
        if (el3 && el3.hasValue()) {
          const pos = el3.tooltipPosition();
          x += pos.x;
          y2 += pos.y;
          ++count;
        }
      }
      return {
        x: x / count,
        y: y2 / count
      };
    },
    nearest(items, eventPosition) {
      if (!items.length) {
        return false;
      }
      let x = eventPosition.x;
      let y2 = eventPosition.y;
      let minDistance = Number.POSITIVE_INFINITY;
      let i, len, nearestElement;
      for (i = 0, len = items.length; i < len; ++i) {
        const el3 = items[i].element;
        if (el3 && el3.hasValue()) {
          const center = el3.getCenterPoint();
          const d2 = distanceBetweenPoints(eventPosition, center);
          if (d2 < minDistance) {
            minDistance = d2;
            nearestElement = el3;
          }
        }
      }
      if (nearestElement) {
        const tp = nearestElement.tooltipPosition();
        x = tp.x;
        y2 = tp.y;
      }
      return {
        x,
        y: y2
      };
    }
  };
  function pushOrConcat(base2, toPush) {
    if (toPush) {
      if (isArray2(toPush)) {
        Array.prototype.push.apply(base2, toPush);
      } else {
        base2.push(toPush);
      }
    }
    return base2;
  }
  function splitNewlines(str) {
    if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
      return str.split("\n");
    }
    return str;
  }
  function createTooltipItem(chart, item) {
    const { element, datasetIndex, index: index3 } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label, value } = controller.getLabelAndValue(index3);
    return {
      chart,
      label,
      parsed: controller.getParsed(index3),
      raw: chart.data.datasets[datasetIndex].data[index3],
      formattedValue: value,
      dataset: controller.getDataset(),
      dataIndex: index3,
      datasetIndex,
      element
    };
  }
  function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body, footer, title } = tooltip;
    const { boxWidth, boxHeight } = options;
    const bodyFont = toFont(options.bodyFont);
    const titleFont = toFont(options.titleFont);
    const footerFont = toFont(options.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = toPadding(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
      height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    }
    if (combinedBodyLength) {
      const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
      height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) {
      height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function(line) {
      width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    each(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    each(body, (bodyItem) => {
      each(bodyItem.before, maxLineWidth);
      each(bodyItem.lines, maxLineWidth);
      each(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    each(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return { width, height };
  }
  function determineYAlign(chart, size) {
    const { y: y2, height } = size;
    if (y2 < height / 2) {
      return "top";
    } else if (y2 > chart.height - height / 2) {
      return "bottom";
    }
    return "center";
  }
  function doesNotFitWithAlign(xAlign, chart, options, size) {
    const { x, width } = size;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === "left" && x + width + caret > chart.width) {
      return true;
    }
    if (xAlign === "right" && x - width - caret < 0) {
      return true;
    }
  }
  function determineXAlign(chart, options, size, yAlign) {
    const { x, width } = size;
    const { width: chartWidth, chartArea: { left, right } } = chart;
    let xAlign = "center";
    if (yAlign === "center") {
      xAlign = x <= (left + right) / 2 ? "left" : "right";
    } else if (x <= width / 2) {
      xAlign = "left";
    } else if (x >= chartWidth - width / 2) {
      xAlign = "right";
    }
    if (doesNotFitWithAlign(xAlign, chart, options, size)) {
      xAlign = "center";
    }
    return xAlign;
  }
  function determineAlignment(chart, options, size) {
    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
    return {
      xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
      yAlign
    };
  }
  function alignX(size, xAlign) {
    let { x, width } = size;
    if (xAlign === "right") {
      x -= width;
    } else if (xAlign === "center") {
      x -= width / 2;
    }
    return x;
  }
  function alignY(size, yAlign, paddingAndSize) {
    let { y: y2, height } = size;
    if (yAlign === "top") {
      y2 += paddingAndSize;
    } else if (yAlign === "bottom") {
      y2 -= height + paddingAndSize;
    } else {
      y2 -= height / 2;
    }
    return y2;
  }
  function getBackgroundPoint(options, size, alignment, chart) {
    const { caretSize, caretPadding, cornerRadius } = options;
    const { xAlign, yAlign } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    let x = alignX(size, xAlign);
    const y2 = alignY(size, yAlign, paddingAndSize);
    if (yAlign === "center") {
      if (xAlign === "left") {
        x += paddingAndSize;
      } else if (xAlign === "right") {
        x -= paddingAndSize;
      }
    } else if (xAlign === "left") {
      x -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === "right") {
      x += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
      x: _limitValue(x, 0, chart.width - size.width),
      y: _limitValue(y2, 0, chart.height - size.height)
    };
  }
  function getAlignedX(tooltip, align, options) {
    const padding = toPadding(options.padding);
    return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
  }
  function getBeforeAfterBodyLines(callback2) {
    return pushOrConcat([], splitNewlines(callback2));
  }
  function createTooltipContext(parent, tooltip, tooltipItems) {
    return createContext(parent, {
      tooltip,
      tooltipItems,
      type: "tooltip"
    });
  }
  function overrideCallbacks(callbacks, context2) {
    const override = context2 && context2.dataset && context2.dataset.tooltip && context2.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
  }
  var Tooltip = class extends Element2 {
    constructor(config) {
      super();
      this.opacity = 0;
      this._active = [];
      this._eventPosition = void 0;
      this._size = void 0;
      this._cachedAnimations = void 0;
      this._tooltipItems = [];
      this.$animations = void 0;
      this.$context = void 0;
      this.chart = config.chart || config._chart;
      this._chart = this.chart;
      this.options = config.options;
      this.dataPoints = void 0;
      this.title = void 0;
      this.beforeBody = void 0;
      this.body = void 0;
      this.afterBody = void 0;
      this.footer = void 0;
      this.xAlign = void 0;
      this.yAlign = void 0;
      this.x = void 0;
      this.y = void 0;
      this.height = void 0;
      this.width = void 0;
      this.caretX = void 0;
      this.caretY = void 0;
      this.labelColors = void 0;
      this.labelPointStyles = void 0;
      this.labelTextColors = void 0;
    }
    initialize(options) {
      this.options = options;
      this._cachedAnimations = void 0;
      this.$context = void 0;
    }
    _resolveAnimations() {
      const cached = this._cachedAnimations;
      if (cached) {
        return cached;
      }
      const chart = this.chart;
      const options = this.options.setContext(this.getContext());
      const opts = options.enabled && chart.options.animation && options.animations;
      const animations = new Animations(this.chart, opts);
      if (opts._cacheable) {
        this._cachedAnimations = Object.freeze(animations);
      }
      return animations;
    }
    getContext() {
      return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context2, options) {
      const { callbacks } = options;
      const beforeTitle = callbacks.beforeTitle.apply(this, [context2]);
      const title = callbacks.title.apply(this, [context2]);
      const afterTitle = callbacks.afterTitle.apply(this, [context2]);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeTitle));
      lines = pushOrConcat(lines, splitNewlines(title));
      lines = pushOrConcat(lines, splitNewlines(afterTitle));
      return lines;
    }
    getBeforeBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
    }
    getBody(tooltipItems, options) {
      const { callbacks } = options;
      const bodyItems = [];
      each(tooltipItems, (context2) => {
        const bodyItem = {
          before: [],
          lines: [],
          after: []
        };
        const scoped = overrideCallbacks(callbacks, context2);
        pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context2)));
        pushOrConcat(bodyItem.lines, scoped.label.call(this, context2));
        pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context2)));
        bodyItems.push(bodyItem);
      });
      return bodyItems;
    }
    getAfterBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
    }
    getFooter(tooltipItems, options) {
      const { callbacks } = options;
      const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
      const footer = callbacks.footer.apply(this, [tooltipItems]);
      const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeFooter));
      lines = pushOrConcat(lines, splitNewlines(footer));
      lines = pushOrConcat(lines, splitNewlines(afterFooter));
      return lines;
    }
    _createItems(options) {
      const active = this._active;
      const data = this.chart.data;
      const labelColors = [];
      const labelPointStyles = [];
      const labelTextColors = [];
      let tooltipItems = [];
      let i, len;
      for (i = 0, len = active.length; i < len; ++i) {
        tooltipItems.push(createTooltipItem(this.chart, active[i]));
      }
      if (options.filter) {
        tooltipItems = tooltipItems.filter((element, index3, array) => options.filter(element, index3, array, data));
      }
      if (options.itemSort) {
        tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
      }
      each(tooltipItems, (context2) => {
        const scoped = overrideCallbacks(options.callbacks, context2);
        labelColors.push(scoped.labelColor.call(this, context2));
        labelPointStyles.push(scoped.labelPointStyle.call(this, context2));
        labelTextColors.push(scoped.labelTextColor.call(this, context2));
      });
      this.labelColors = labelColors;
      this.labelPointStyles = labelPointStyles;
      this.labelTextColors = labelTextColors;
      this.dataPoints = tooltipItems;
      return tooltipItems;
    }
    update(changed, replay) {
      const options = this.options.setContext(this.getContext());
      const active = this._active;
      let properties;
      let tooltipItems = [];
      if (!active.length) {
        if (this.opacity !== 0) {
          properties = {
            opacity: 0
          };
        }
      } else {
        const position = positioners[options.position].call(this, active, this._eventPosition);
        tooltipItems = this._createItems(options);
        this.title = this.getTitle(tooltipItems, options);
        this.beforeBody = this.getBeforeBody(tooltipItems, options);
        this.body = this.getBody(tooltipItems, options);
        this.afterBody = this.getAfterBody(tooltipItems, options);
        this.footer = this.getFooter(tooltipItems, options);
        const size = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, size);
        const alignment = determineAlignment(this.chart, options, positionAndSize);
        const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        properties = {
          opacity: 1,
          x: backgroundPoint.x,
          y: backgroundPoint.y,
          width: size.width,
          height: size.height,
          caretX: position.x,
          caretY: position.y
        };
      }
      this._tooltipItems = tooltipItems;
      this.$context = void 0;
      if (properties) {
        this._resolveAnimations().update(this, properties);
      }
      if (changed && options.external) {
        options.external.call(this, { chart: this.chart, tooltip: this, replay });
      }
    }
    drawCaret(tooltipPoint, ctx, size, options) {
      const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
      ctx.lineTo(caretPosition.x1, caretPosition.y1);
      ctx.lineTo(caretPosition.x2, caretPosition.y2);
      ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size, options) {
      const { xAlign, yAlign } = this;
      const { caretSize, cornerRadius } = options;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
      const { x: ptX, y: ptY } = tooltipPoint;
      const { width, height } = size;
      let x1, x2, x3, y1, y2, y3;
      if (yAlign === "center") {
        y2 = ptY + height / 2;
        if (xAlign === "left") {
          x1 = ptX;
          x2 = x1 - caretSize;
          y1 = y2 + caretSize;
          y3 = y2 - caretSize;
        } else {
          x1 = ptX + width;
          x2 = x1 + caretSize;
          y1 = y2 - caretSize;
          y3 = y2 + caretSize;
        }
        x3 = x1;
      } else {
        if (xAlign === "left") {
          x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
        } else if (xAlign === "right") {
          x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
        } else {
          x2 = this.caretX;
        }
        if (yAlign === "top") {
          y1 = ptY;
          y2 = y1 - caretSize;
          x1 = x2 - caretSize;
          x3 = x2 + caretSize;
        } else {
          y1 = ptY + height;
          y2 = y1 + caretSize;
          x1 = x2 + caretSize;
          x3 = x2 - caretSize;
        }
        y3 = y1;
      }
      return { x1, x2, x3, y1, y2, y3 };
    }
    drawTitle(pt2, ctx, options) {
      const title = this.title;
      const length = title.length;
      let titleFont, titleSpacing, i;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt2.x = getAlignedX(this, options.titleAlign, options);
        ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
        ctx.textBaseline = "middle";
        titleFont = toFont(options.titleFont);
        titleSpacing = options.titleSpacing;
        ctx.fillStyle = options.titleColor;
        ctx.font = titleFont.string;
        for (i = 0; i < length; ++i) {
          ctx.fillText(title[i], rtlHelper.x(pt2.x), pt2.y + titleFont.lineHeight / 2);
          pt2.y += titleFont.lineHeight + titleSpacing;
          if (i + 1 === length) {
            pt2.y += options.titleMarginBottom - titleSpacing;
          }
        }
      }
    }
    _drawColorBox(ctx, pt2, i, rtlHelper, options) {
      const labelColors = this.labelColors[i];
      const labelPointStyle = this.labelPointStyles[i];
      const { boxHeight, boxWidth, boxPadding } = options;
      const bodyFont = toFont(options.bodyFont);
      const colorX = getAlignedX(this, "left", options);
      const rtlColorX = rtlHelper.x(colorX);
      const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
      const colorY = pt2.y + yOffSet;
      if (options.usePointStyle) {
        const drawOptions = {
          radius: Math.min(boxWidth, boxHeight) / 2,
          pointStyle: labelPointStyle.pointStyle,
          rotation: labelPointStyle.rotation,
          borderWidth: 1
        };
        const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
        const centerY = colorY + boxHeight / 2;
        ctx.strokeStyle = options.multiKeyBackground;
        ctx.fillStyle = options.multiKeyBackground;
        drawPoint(ctx, drawOptions, centerX, centerY);
        ctx.strokeStyle = labelColors.borderColor;
        ctx.fillStyle = labelColors.backgroundColor;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        ctx.lineWidth = isObject2(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
        ctx.strokeStyle = labelColors.borderColor;
        ctx.setLineDash(labelColors.borderDash || []);
        ctx.lineDashOffset = labelColors.borderDashOffset || 0;
        const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
        const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
        const borderRadius = toTRBLCorners(labelColors.borderRadius);
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          ctx.beginPath();
          ctx.fillStyle = options.multiKeyBackground;
          addRoundedRectPath(ctx, {
            x: outerX,
            y: colorY,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = labelColors.backgroundColor;
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: innerX,
            y: colorY + 1,
            w: boxWidth - 2,
            h: boxHeight - 2,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillStyle = options.multiKeyBackground;
          ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
          ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
          ctx.fillStyle = labelColors.backgroundColor;
          ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
        }
      }
      ctx.fillStyle = this.labelTextColors[i];
    }
    drawBody(pt2, ctx, options) {
      const { body } = this;
      const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
      const bodyFont = toFont(options.bodyFont);
      let bodyLineHeight = bodyFont.lineHeight;
      let xLinePadding = 0;
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      const fillLineOfText = function(line) {
        ctx.fillText(line, rtlHelper.x(pt2.x + xLinePadding), pt2.y + bodyLineHeight / 2);
        pt2.y += bodyLineHeight + bodySpacing;
      };
      const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
      let bodyItem, textColor, lines, i, j2, ilen, jlen;
      ctx.textAlign = bodyAlign;
      ctx.textBaseline = "middle";
      ctx.font = bodyFont.string;
      pt2.x = getAlignedX(this, bodyAlignForCalculation, options);
      ctx.fillStyle = options.bodyColor;
      each(this.beforeBody, fillLineOfText);
      xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
      for (i = 0, ilen = body.length; i < ilen; ++i) {
        bodyItem = body[i];
        textColor = this.labelTextColors[i];
        ctx.fillStyle = textColor;
        each(bodyItem.before, fillLineOfText);
        lines = bodyItem.lines;
        if (displayColors && lines.length) {
          this._drawColorBox(ctx, pt2, i, rtlHelper, options);
          bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
        }
        for (j2 = 0, jlen = lines.length; j2 < jlen; ++j2) {
          fillLineOfText(lines[j2]);
          bodyLineHeight = bodyFont.lineHeight;
        }
        each(bodyItem.after, fillLineOfText);
      }
      xLinePadding = 0;
      bodyLineHeight = bodyFont.lineHeight;
      each(this.afterBody, fillLineOfText);
      pt2.y -= bodySpacing;
    }
    drawFooter(pt2, ctx, options) {
      const footer = this.footer;
      const length = footer.length;
      let footerFont, i;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt2.x = getAlignedX(this, options.footerAlign, options);
        pt2.y += options.footerMarginTop;
        ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
        ctx.textBaseline = "middle";
        footerFont = toFont(options.footerFont);
        ctx.fillStyle = options.footerColor;
        ctx.font = footerFont.string;
        for (i = 0; i < length; ++i) {
          ctx.fillText(footer[i], rtlHelper.x(pt2.x), pt2.y + footerFont.lineHeight / 2);
          pt2.y += footerFont.lineHeight + options.footerSpacing;
        }
      }
    }
    drawBackground(pt2, ctx, tooltipSize, options) {
      const { xAlign, yAlign } = this;
      const { x, y: y2 } = pt2;
      const { width, height } = tooltipSize;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.beginPath();
      ctx.moveTo(x + topLeft, y2);
      if (yAlign === "top") {
        this.drawCaret(pt2, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + width - topRight, y2);
      ctx.quadraticCurveTo(x + width, y2, x + width, y2 + topRight);
      if (yAlign === "center" && xAlign === "right") {
        this.drawCaret(pt2, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + width, y2 + height - bottomRight);
      ctx.quadraticCurveTo(x + width, y2 + height, x + width - bottomRight, y2 + height);
      if (yAlign === "bottom") {
        this.drawCaret(pt2, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + bottomLeft, y2 + height);
      ctx.quadraticCurveTo(x, y2 + height, x, y2 + height - bottomLeft);
      if (yAlign === "center" && xAlign === "left") {
        this.drawCaret(pt2, ctx, tooltipSize, options);
      }
      ctx.lineTo(x, y2 + topLeft);
      ctx.quadraticCurveTo(x, y2, x + topLeft, y2);
      ctx.closePath();
      ctx.fill();
      if (options.borderWidth > 0) {
        ctx.stroke();
      }
    }
    _updateAnimationTarget(options) {
      const chart = this.chart;
      const anims = this.$animations;
      const animX = anims && anims.x;
      const animY = anims && anims.y;
      if (animX || animY) {
        const position = positioners[options.position].call(this, this._active, this._eventPosition);
        if (!position) {
          return;
        }
        const size = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, this._size);
        const alignment = determineAlignment(chart, options, positionAndSize);
        const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
        if (animX._to !== point.x || animY._to !== point.y) {
          this.xAlign = alignment.xAlign;
          this.yAlign = alignment.yAlign;
          this.width = size.width;
          this.height = size.height;
          this.caretX = position.x;
          this.caretY = position.y;
          this._resolveAnimations().update(this, point);
        }
      }
    }
    _willRender() {
      return !!this.opacity;
    }
    draw(ctx) {
      const options = this.options.setContext(this.getContext());
      let opacity = this.opacity;
      if (!opacity) {
        return;
      }
      this._updateAnimationTarget(options);
      const tooltipSize = {
        width: this.width,
        height: this.height
      };
      const pt2 = {
        x: this.x,
        y: this.y
      };
      opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
      const padding = toPadding(options.padding);
      const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
      if (options.enabled && hasTooltipContent) {
        ctx.save();
        ctx.globalAlpha = opacity;
        this.drawBackground(pt2, ctx, tooltipSize, options);
        overrideTextDirection(ctx, options.textDirection);
        pt2.y += padding.top;
        this.drawTitle(pt2, ctx, options);
        this.drawBody(pt2, ctx, options);
        this.drawFooter(pt2, ctx, options);
        restoreTextDirection(ctx, options.textDirection);
        ctx.restore();
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements, eventPosition) {
      const lastActive = this._active;
      const active = activeElements.map(({ datasetIndex, index: index3 }) => {
        const meta2 = this.chart.getDatasetMeta(datasetIndex);
        if (!meta2) {
          throw new Error("Cannot find a dataset at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta2.data[index3],
          index: index3
        };
      });
      const changed = !_elementsEqual(lastActive, active);
      const positionChanged = this._positionChanged(active, eventPosition);
      if (changed || positionChanged) {
        this._active = active;
        this._eventPosition = eventPosition;
        this._ignoreReplayEvents = true;
        this.update(true);
      }
    }
    handleEvent(e, replay, inChartArea = true) {
      if (replay && this._ignoreReplayEvents) {
        return false;
      }
      this._ignoreReplayEvents = false;
      const options = this.options;
      const lastActive = this._active || [];
      const active = this._getActiveElements(e, lastActive, replay, inChartArea);
      const positionChanged = this._positionChanged(active, e);
      const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
      if (changed) {
        this._active = active;
        if (options.enabled || options.external) {
          this._eventPosition = {
            x: e.x,
            y: e.y
          };
          this.update(true, replay);
        }
      }
      return changed;
    }
    _getActiveElements(e, lastActive, replay, inChartArea) {
      const options = this.options;
      if (e.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
      if (options.reverse) {
        active.reverse();
      }
      return active;
    }
    _positionChanged(active, e) {
      const { caretX, caretY, options } = this;
      const position = positioners[options.position].call(this, active, e);
      return position !== false && (caretX !== position.x || caretY !== position.y);
    }
  };
  Tooltip.positioners = positioners;
  var plugin_tooltip = {
    id: "tooltip",
    _element: Tooltip,
    positioners,
    afterInit(chart, _args, options) {
      if (options) {
        chart.tooltip = new Tooltip({ chart, options });
      }
    },
    beforeUpdate(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    reset(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    afterDraw(chart) {
      const tooltip = chart.tooltip;
      if (tooltip && tooltip._willRender()) {
        const args = {
          tooltip
        };
        if (chart.notifyPlugins("beforeTooltipDraw", args) === false) {
          return;
        }
        tooltip.draw(chart.ctx);
        chart.notifyPlugins("afterTooltipDraw", args);
      }
    },
    afterEvent(chart, args) {
      if (chart.tooltip) {
        const useFinalPosition = args.replay;
        if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
          args.changed = true;
        }
      }
    },
    defaults: {
      enabled: true,
      external: null,
      position: "average",
      backgroundColor: "rgba(0,0,0,0.8)",
      titleColor: "#fff",
      titleFont: {
        weight: "bold"
      },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: "left",
      bodyColor: "#fff",
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: "left",
      footerColor: "#fff",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: {
        weight: "bold"
      },
      footerAlign: "left",
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (ctx, opts) => opts.bodyFont.size,
      boxWidth: (ctx, opts) => opts.bodyFont.size,
      multiKeyBackground: "#fff",
      displayColors: true,
      boxPadding: 0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      animation: {
        duration: 400,
        easing: "easeOutQuart"
      },
      animations: {
        numbers: {
          type: "number",
          properties: ["x", "y", "width", "height", "caretX", "caretY"]
        },
        opacity: {
          easing: "linear",
          duration: 200
        }
      },
      callbacks: {
        beforeTitle: noop,
        title(tooltipItems) {
          if (tooltipItems.length > 0) {
            const item = tooltipItems[0];
            const labels = item.chart.data.labels;
            const labelCount = labels ? labels.length : 0;
            if (this && this.options && this.options.mode === "dataset") {
              return item.dataset.label || "";
            } else if (item.label) {
              return item.label;
            } else if (labelCount > 0 && item.dataIndex < labelCount) {
              return labels[item.dataIndex];
            }
          }
          return "";
        },
        afterTitle: noop,
        beforeBody: noop,
        beforeLabel: noop,
        label(tooltipItem) {
          if (this && this.options && this.options.mode === "dataset") {
            return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
          }
          let label = tooltipItem.dataset.label || "";
          if (label) {
            label += ": ";
          }
          const value = tooltipItem.formattedValue;
          if (!isNullOrUndef(value)) {
            label += value;
          }
          return label;
        },
        labelColor(tooltipItem) {
          const meta2 = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
          const options = meta2.controller.getStyle(tooltipItem.dataIndex);
          return {
            borderColor: options.borderColor,
            backgroundColor: options.backgroundColor,
            borderWidth: options.borderWidth,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderRadius: 0
          };
        },
        labelTextColor() {
          return this.options.bodyColor;
        },
        labelPointStyle(tooltipItem) {
          const meta2 = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
          const options = meta2.controller.getStyle(tooltipItem.dataIndex);
          return {
            pointStyle: options.pointStyle,
            rotation: options.rotation
          };
        },
        afterLabel: noop,
        afterBody: noop,
        beforeFooter: noop,
        footer: noop,
        afterFooter: noop
      }
    },
    defaultRoutes: {
      bodyFont: "font",
      footerFont: "font",
      titleFont: "font"
    },
    descriptors: {
      _scriptable: (name2) => name2 !== "filter" && name2 !== "itemSort" && name2 !== "external",
      _indexable: false,
      callbacks: {
        _scriptable: false,
        _indexable: false
      },
      animation: {
        _fallback: false
      },
      animations: {
        _fallback: "animation"
      }
    },
    additionalOptionScopes: ["interaction"]
  };
  var plugins2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Decimation: plugin_decimation,
    Filler: index2,
    Legend: plugin_legend,
    SubTitle: plugin_subtitle,
    Title: plugin_title,
    Tooltip: plugin_tooltip
  });
  var addIfString = (labels, raw, index3, addedLabels) => {
    if (typeof raw === "string") {
      index3 = labels.push(raw) - 1;
      addedLabels.unshift({ index: index3, label: raw });
    } else if (isNaN(raw)) {
      index3 = null;
    }
    return index3;
  };
  function findOrAddLabel(labels, raw, index3, addedLabels) {
    const first = labels.indexOf(raw);
    if (first === -1) {
      return addIfString(labels, raw, index3, addedLabels);
    }
    const last = labels.lastIndexOf(raw);
    return first !== last ? index3 : first;
  }
  var validIndex = (index3, max) => index3 === null ? null : _limitValue(Math.round(index3), 0, max);
  var CategoryScale = class extends Scale2 {
    constructor(cfg) {
      super(cfg);
      this._startValue = void 0;
      this._valueRange = 0;
      this._addedLabels = [];
    }
    init(scaleOptions) {
      const added = this._addedLabels;
      if (added.length) {
        const labels = this.getLabels();
        for (const { index: index3, label } of added) {
          if (labels[index3] === label) {
            labels.splice(index3, 1);
          }
        }
        this._addedLabels = [];
      }
      super.init(scaleOptions);
    }
    parse(raw, index3) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      const labels = this.getLabels();
      index3 = isFinite(index3) && labels[index3] === raw ? index3 : findOrAddLabel(labels, raw, valueOrDefault(index3, raw), this._addedLabels);
      return validIndex(index3, labels.length - 1);
    }
    determineDataLimits() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min, max } = this.getMinMax(true);
      if (this.options.bounds === "ticks") {
        if (!minDefined) {
          min = 0;
        }
        if (!maxDefined) {
          max = this.getLabels().length - 1;
        }
      }
      this.min = min;
      this.max = max;
    }
    buildTicks() {
      const min = this.min;
      const max = this.max;
      const offset = this.options.offset;
      const ticks = [];
      let labels = this.getLabels();
      labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
      this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
      this._startValue = this.min - (offset ? 0.5 : 0);
      for (let value = min; value <= max; value++) {
        ticks.push({ value });
      }
      return ticks;
    }
    getLabelForValue(value) {
      const labels = this.getLabels();
      if (value >= 0 && value < labels.length) {
        return labels[value];
      }
      return value;
    }
    configure() {
      super.configure();
      if (!this.isHorizontal()) {
        this._reversePixels = !this._reversePixels;
      }
    }
    getPixelForValue(value) {
      if (typeof value !== "number") {
        value = this.parse(value);
      }
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index3) {
      const ticks = this.ticks;
      if (index3 < 0 || index3 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index3].value);
    }
    getValueForPixel(pixel) {
      return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
      return this.bottom;
    }
  };
  CategoryScale.id = "category";
  CategoryScale.defaults = {
    ticks: {
      callback: CategoryScale.prototype.getLabelForValue
    }
  };
  function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin, max: rmax } = dataRange;
    const minDefined = !isNullOrUndef(min);
    const maxDefined = !isNullOrUndef(max);
    const countDefined = !isNullOrUndef(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
      return [{ value: rmin }, { value: rmax }];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
      spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
    }
    if (!isNullOrUndef(precision)) {
      factor = Math.pow(10, precision);
      spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === "ticks") {
      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
      niceMin = rmin;
      niceMax = rmax;
    }
    if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
      numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
      spacing = (max - min) / numSpaces;
      niceMin = min;
      niceMax = max;
    } else if (countDefined) {
      niceMin = minDefined ? min : niceMin;
      niceMax = maxDefined ? max : niceMax;
      numSpaces = count - 1;
      spacing = (niceMax - niceMin) / numSpaces;
    } else {
      numSpaces = (niceMax - niceMin) / spacing;
      if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }
    }
    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j2 = 0;
    if (minDefined) {
      if (includeBounds && niceMin !== min) {
        ticks.push({ value: min });
        if (niceMin < min) {
          j2++;
        }
        if (almostEquals(Math.round((niceMin + j2 * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
          j2++;
        }
      } else if (niceMin < min) {
        j2++;
      }
    }
    for (; j2 < numSpaces; ++j2) {
      ticks.push({ value: Math.round((niceMin + j2 * spacing) * factor) / factor });
    }
    if (maxDefined && includeBounds && niceMax !== max) {
      if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
        ticks[ticks.length - 1].value = max;
      } else {
        ticks.push({ value: max });
      }
    } else if (!maxDefined || niceMax === max) {
      ticks.push({ value: niceMax });
    }
    return ticks;
  }
  function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
    const rad = toRadians(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
    const length = 0.75 * minSpacing * ("" + value).length;
    return Math.min(minSpacing / ratio, length);
  }
  var LinearScaleBase = class extends Scale2 {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._endValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index3) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
        return null;
      }
      return +raw;
    }
    handleTickRangeOptions() {
      const { beginAtZero } = this.options;
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min, max } = this;
      const setMin = (v) => min = minDefined ? min : v;
      const setMax = (v) => max = maxDefined ? max : v;
      if (beginAtZero) {
        const minSign = sign(min);
        const maxSign = sign(max);
        if (minSign < 0 && maxSign < 0) {
          setMax(0);
        } else if (minSign > 0 && maxSign > 0) {
          setMin(0);
        }
      }
      if (min === max) {
        let offset = 1;
        if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
          offset = Math.abs(max * 0.05);
        }
        setMax(max + offset);
        if (!beginAtZero) {
          setMin(min - offset);
        }
      }
      this.min = min;
      this.max = max;
    }
    getTickLimit() {
      const tickOpts = this.options.ticks;
      let { maxTicksLimit, stepSize } = tickOpts;
      let maxTicks;
      if (stepSize) {
        maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
        if (maxTicks > 1e3) {
          console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
          maxTicks = 1e3;
        }
      } else {
        maxTicks = this.computeTickLimit();
        maxTicksLimit = maxTicksLimit || 11;
      }
      if (maxTicksLimit) {
        maxTicks = Math.min(maxTicksLimit, maxTicks);
      }
      return maxTicks;
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
      const opts = this.options;
      const tickOpts = opts.ticks;
      let maxTicks = this.getTickLimit();
      maxTicks = Math.max(2, maxTicks);
      const numericGeneratorOptions = {
        maxTicks,
        bounds: opts.bounds,
        min: opts.min,
        max: opts.max,
        precision: tickOpts.precision,
        step: tickOpts.stepSize,
        count: tickOpts.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: tickOpts.minRotation || 0,
        includeBounds: tickOpts.includeBounds !== false
      };
      const dataRange = this._range || this;
      const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    configure() {
      const ticks = this.ticks;
      let start2 = this.min;
      let end = this.max;
      super.configure();
      if (this.options.offset && ticks.length) {
        const offset = (end - start2) / Math.max(ticks.length - 1, 1) / 2;
        start2 -= offset;
        end += offset;
      }
      this._startValue = start2;
      this._endValue = end;
      this._valueRange = end - start2;
    }
    getLabelForValue(value) {
      return formatNumber2(value, this.chart.options.locale, this.options.ticks.format);
    }
  };
  var LinearScale = class extends LinearScaleBase {
    determineDataLimits() {
      const { min, max } = this.getMinMax(true);
      this.min = isNumberFinite(min) ? min : 0;
      this.max = isNumberFinite(max) ? max : 1;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      const horizontal = this.isHorizontal();
      const length = horizontal ? this.width : this.height;
      const minRotation = toRadians(this.options.ticks.minRotation);
      const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
      const tickFont = this._resolveTickFontOptions(0);
      return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
  };
  LinearScale.id = "linear";
  LinearScale.defaults = {
    ticks: {
      callback: Ticks.formatters.numeric
    }
  };
  function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
    return remain === 1;
  }
  function generateTicks(generationOptions, dataRange) {
    const endExp = Math.floor(log10(dataRange.max));
    const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
    const ticks = [];
    let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
    let exp = Math.floor(log10(tickVal));
    let significand = Math.floor(tickVal / Math.pow(10, exp));
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    do {
      ticks.push({ value: tickVal, major: isMajor(tickVal) });
      ++significand;
      if (significand === 10) {
        significand = 1;
        ++exp;
        precision = exp >= 0 ? 1 : precision;
      }
      tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
    } while (exp < endExp || exp === endExp && significand < endSignificand);
    const lastTick = finiteOrDefault(generationOptions.max, tickVal);
    ticks.push({ value: lastTick, major: isMajor(tickVal) });
    return ticks;
  }
  var LogarithmicScale = class extends Scale2 {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index3) {
      const value = LinearScaleBase.prototype.parse.apply(this, [raw, index3]);
      if (value === 0) {
        this._zero = true;
        return void 0;
      }
      return isNumberFinite(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
      const { min, max } = this.getMinMax(true);
      this.min = isNumberFinite(min) ? Math.max(0, min) : null;
      this.max = isNumberFinite(max) ? Math.max(0, max) : null;
      if (this.options.beginAtZero) {
        this._zero = true;
      }
      this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let min = this.min;
      let max = this.max;
      const setMin = (v) => min = minDefined ? min : v;
      const setMax = (v) => max = maxDefined ? max : v;
      const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
      if (min === max) {
        if (min <= 0) {
          setMin(1);
          setMax(10);
        } else {
          setMin(exp(min, -1));
          setMax(exp(max, 1));
        }
      }
      if (min <= 0) {
        setMin(exp(max, -1));
      }
      if (max <= 0) {
        setMax(exp(min, 1));
      }
      if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
        setMin(exp(min, -1));
      }
      this.min = min;
      this.max = max;
    }
    buildTicks() {
      const opts = this.options;
      const generationOptions = {
        min: this._userMin,
        max: this._userMax
      };
      const ticks = generateTicks(generationOptions, this);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    getLabelForValue(value) {
      return value === void 0 ? "0" : formatNumber2(value, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
      const start2 = this.min;
      super.configure();
      this._startValue = log10(start2);
      this._valueRange = log10(this.max) - log10(start2);
    }
    getPixelForValue(value) {
      if (value === void 0 || value === 0) {
        value = this.min;
      }
      if (value === null || isNaN(value)) {
        return NaN;
      }
      return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      const decimal = this.getDecimalForPixel(pixel);
      return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
  };
  LogarithmicScale.id = "logarithmic";
  LogarithmicScale.defaults = {
    ticks: {
      callback: Ticks.formatters.logarithmic,
      major: {
        enabled: true
      }
    }
  };
  function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
      const padding = toPadding(tickOpts.backdropPadding);
      return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults3.font.size) + padding.height;
    }
    return 0;
  }
  function measureLabelSize(ctx, font, label) {
    label = isArray2(label) ? label : [label];
    return {
      w: _longestText(ctx, font.string, label),
      h: label.length * font.lineHeight
    };
  }
  function determineLimits(angle, pos, size, min, max) {
    if (angle === min || angle === max) {
      return {
        start: pos - size / 2,
        end: pos + size / 2
      };
    } else if (angle < min || angle > max) {
      return {
        start: pos - size,
        end: pos
      };
    }
    return {
      start: pos,
      end: pos + size
    };
  }
  function fitWithPointLabels(scale) {
    const orig = {
      l: scale.left + scale._padding.left,
      r: scale.right - scale._padding.right,
      t: scale.top + scale._padding.top,
      b: scale.bottom - scale._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
    for (let i = 0; i < valueCount; i++) {
      const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
      padding[i] = opts.padding;
      const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
      const plFont = toFont(opts.font);
      const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
      labelSizes[i] = textSize;
      const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
      const angle = Math.round(toDegrees(angleRadians));
      const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
      const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
      updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
  }
  function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x = 0;
    let y2 = 0;
    if (hLimits.start < orig.l) {
      x = (orig.l - hLimits.start) / sin;
      limits.l = Math.min(limits.l, orig.l - x);
    } else if (hLimits.end > orig.r) {
      x = (hLimits.end - orig.r) / sin;
      limits.r = Math.max(limits.r, orig.r + x);
    }
    if (vLimits.start < orig.t) {
      y2 = (orig.t - vLimits.start) / cos;
      limits.t = Math.min(limits.t, orig.t - y2);
    } else if (vLimits.end > orig.b) {
      y2 = (vLimits.end - orig.b) / cos;
      limits.b = Math.max(limits.b, orig.b + y2);
    }
  }
  function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const extra = getTickBackdropHeight(opts) / 2;
    const outerDistance = scale.drawingArea;
    const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
    for (let i = 0; i < valueCount; i++) {
      const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
      const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
      const size = labelSizes[i];
      const y2 = yForAngle(pointLabelPosition.y, size.h, angle);
      const textAlign = getTextAlignForAngle(angle);
      const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
      items.push({
        x: pointLabelPosition.x,
        y: y2,
        textAlign,
        left,
        top: y2,
        right: left + size.w,
        bottom: y2 + size.h
      });
    }
    return items;
  }
  function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
      return "center";
    } else if (angle < 180) {
      return "left";
    }
    return "right";
  }
  function leftForTextAlign(x, w, align) {
    if (align === "right") {
      x -= w;
    } else if (align === "center") {
      x -= w / 2;
    }
    return x;
  }
  function yForAngle(y2, h3, angle) {
    if (angle === 90 || angle === 270) {
      y2 -= h3 / 2;
    } else if (angle > 270 || angle < 90) {
      y2 -= h3;
    }
    return y2;
  }
  function drawPointLabels(scale, labelCount) {
    const { ctx, options: { pointLabels } } = scale;
    for (let i = labelCount - 1; i >= 0; i--) {
      const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
      const plFont = toFont(optsAtIndex.font);
      const { x, y: y2, textAlign, left, top: top2, right, bottom } = scale._pointLabelItems[i];
      const { backdropColor } = optsAtIndex;
      if (!isNullOrUndef(backdropColor)) {
        const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillStyle = backdropColor;
        const backdropLeft = left - padding.left;
        const backdropTop = top2 - padding.top;
        const backdropWidth = right - left + padding.width;
        const backdropHeight = bottom - top2 + padding.height;
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: backdropLeft,
            y: backdropTop,
            w: backdropWidth,
            h: backdropHeight,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
        }
      }
      renderText(ctx, scale._pointLabels[i], x, y2 + plFont.lineHeight / 2, plFont, {
        color: optsAtIndex.color,
        textAlign,
        textBaseline: "middle"
      });
    }
  }
  function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx } = scale;
    if (circular) {
      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
    } else {
      let pointPosition = scale.getPointPosition(0, radius);
      ctx.moveTo(pointPosition.x, pointPosition.y);
      for (let i = 1; i < labelCount; i++) {
        pointPosition = scale.getPointPosition(i, radius);
        ctx.lineTo(pointPosition.x, pointPosition.y);
      }
    }
  }
  function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color: color19, lineWidth } = gridLineOpts;
    if (!circular && !labelCount || !color19 || !lineWidth || radius < 0) {
      return;
    }
    ctx.save();
    ctx.strokeStyle = color19;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(gridLineOpts.borderDash);
    ctx.lineDashOffset = gridLineOpts.borderDashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  function createPointLabelContext(parent, index3, label) {
    return createContext(parent, {
      label,
      index: index3,
      type: "pointLabel"
    });
  }
  var RadialLinearScale = class extends LinearScaleBase {
    constructor(cfg) {
      super(cfg);
      this.xCenter = void 0;
      this.yCenter = void 0;
      this.drawingArea = void 0;
      this._pointLabels = [];
      this._pointLabelItems = [];
    }
    setDimensions() {
      const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
      const w = this.width = this.maxWidth - padding.width;
      const h3 = this.height = this.maxHeight - padding.height;
      this.xCenter = Math.floor(this.left + w / 2 + padding.left);
      this.yCenter = Math.floor(this.top + h3 / 2 + padding.top);
      this.drawingArea = Math.floor(Math.min(w, h3) / 2);
    }
    determineDataLimits() {
      const { min, max } = this.getMinMax(false);
      this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
      this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
      LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
      this._pointLabels = this.getLabels().map((value, index3) => {
        const label = callback(this.options.pointLabels.callback, [value, index3], this);
        return label || label === 0 ? label : "";
      }).filter((v, i) => this.chart.getDataVisibility(i));
    }
    fit() {
      const opts = this.options;
      if (opts.display && opts.pointLabels.display) {
        fitWithPointLabels(this);
      } else {
        this.setCenterPoint(0, 0, 0, 0);
      }
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
      this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
      this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
      this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index3) {
      const angleMultiplier = TAU / (this._pointLabels.length || 1);
      const startAngle = this.options.startAngle || 0;
      return _normalizeAngle(index3 * angleMultiplier + toRadians(startAngle));
    }
    getDistanceFromCenterForValue(value) {
      if (isNullOrUndef(value)) {
        return NaN;
      }
      const scalingFactor = this.drawingArea / (this.max - this.min);
      if (this.options.reverse) {
        return (this.max - value) * scalingFactor;
      }
      return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
      if (isNullOrUndef(distance)) {
        return NaN;
      }
      const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
      return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index3) {
      const pointLabels = this._pointLabels || [];
      if (index3 >= 0 && index3 < pointLabels.length) {
        const pointLabel = pointLabels[index3];
        return createPointLabelContext(this.getContext(), index3, pointLabel);
      }
    }
    getPointPosition(index3, distanceFromCenter, additionalAngle = 0) {
      const angle = this.getIndexAngle(index3) - HALF_PI + additionalAngle;
      return {
        x: Math.cos(angle) * distanceFromCenter + this.xCenter,
        y: Math.sin(angle) * distanceFromCenter + this.yCenter,
        angle
      };
    }
    getPointPositionForValue(index3, value) {
      return this.getPointPosition(index3, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index3) {
      return this.getPointPositionForValue(index3 || 0, this.getBaseValue());
    }
    getPointLabelPosition(index3) {
      const { left, top: top2, right, bottom } = this._pointLabelItems[index3];
      return {
        left,
        top: top2,
        right,
        bottom
      };
    }
    drawBackground() {
      const { backgroundColor, grid: { circular } } = this.options;
      if (backgroundColor) {
        const ctx = this.ctx;
        ctx.save();
        ctx.beginPath();
        pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
        ctx.closePath();
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
      }
    }
    drawGrid() {
      const ctx = this.ctx;
      const opts = this.options;
      const { angleLines, grid } = opts;
      const labelCount = this._pointLabels.length;
      let i, offset, position;
      if (opts.pointLabels.display) {
        drawPointLabels(this, labelCount);
      }
      if (grid.display) {
        this.ticks.forEach((tick, index3) => {
          if (index3 !== 0) {
            offset = this.getDistanceFromCenterForValue(tick.value);
            const optsAtIndex = grid.setContext(this.getContext(index3 - 1));
            drawRadiusLine(this, optsAtIndex, offset, labelCount);
          }
        });
      }
      if (angleLines.display) {
        ctx.save();
        for (i = labelCount - 1; i >= 0; i--) {
          const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
          const { color: color19, lineWidth } = optsAtIndex;
          if (!lineWidth || !color19) {
            continue;
          }
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = color19;
          ctx.setLineDash(optsAtIndex.borderDash);
          ctx.lineDashOffset = optsAtIndex.borderDashOffset;
          offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
          position = this.getPointPosition(i, offset);
          ctx.beginPath();
          ctx.moveTo(this.xCenter, this.yCenter);
          ctx.lineTo(position.x, position.y);
          ctx.stroke();
        }
        ctx.restore();
      }
    }
    drawBorder() {
    }
    drawLabels() {
      const ctx = this.ctx;
      const opts = this.options;
      const tickOpts = opts.ticks;
      if (!tickOpts.display) {
        return;
      }
      const startAngle = this.getIndexAngle(0);
      let offset, width;
      ctx.save();
      ctx.translate(this.xCenter, this.yCenter);
      ctx.rotate(startAngle);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      this.ticks.forEach((tick, index3) => {
        if (index3 === 0 && !opts.reverse) {
          return;
        }
        const optsAtIndex = tickOpts.setContext(this.getContext(index3));
        const tickFont = toFont(optsAtIndex.font);
        offset = this.getDistanceFromCenterForValue(this.ticks[index3].value);
        if (optsAtIndex.showLabelBackdrop) {
          ctx.font = tickFont.string;
          width = ctx.measureText(tick.label).width;
          ctx.fillStyle = optsAtIndex.backdropColor;
          const padding = toPadding(optsAtIndex.backdropPadding);
          ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
        }
        renderText(ctx, tick.label, 0, -offset, tickFont, {
          color: optsAtIndex.color
        });
      });
      ctx.restore();
    }
    drawTitle() {
    }
  };
  RadialLinearScale.id = "radialLinear";
  RadialLinearScale.defaults = {
    display: true,
    animate: true,
    position: "chartArea",
    angleLines: {
      display: true,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    grid: {
      circular: false
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: true,
      callback: Ticks.formatters.numeric
    },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: true,
      font: {
        size: 10
      },
      callback(label) {
        return label;
      },
      padding: 5,
      centerPointLabels: false
    }
  };
  RadialLinearScale.defaultRoutes = {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
  };
  RadialLinearScale.descriptors = {
    angleLines: {
      _fallback: "grid"
    }
  };
  var INTERVALS = {
    millisecond: { common: true, size: 1, steps: 1e3 },
    second: { common: true, size: 1e3, steps: 60 },
    minute: { common: true, size: 6e4, steps: 60 },
    hour: { common: true, size: 36e5, steps: 24 },
    day: { common: true, size: 864e5, steps: 30 },
    week: { common: false, size: 6048e5, steps: 4 },
    month: { common: true, size: 2628e6, steps: 12 },
    quarter: { common: false, size: 7884e6, steps: 4 },
    year: { common: true, size: 3154e7 }
  };
  var UNITS = Object.keys(INTERVALS);
  function sorter(a, b) {
    return a - b;
  }
  function parse(scale, input2) {
    if (isNullOrUndef(input2)) {
      return null;
    }
    const adapter = scale._adapter;
    const { parser: parser19, round: round2, isoWeekday } = scale._parseOpts;
    let value = input2;
    if (typeof parser19 === "function") {
      value = parser19(value);
    }
    if (!isNumberFinite(value)) {
      value = typeof parser19 === "string" ? adapter.parse(value, parser19) : adapter.parse(value);
    }
    if (value === null) {
      return null;
    }
    if (round2) {
      value = round2 === "week" && (isNumber2(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
    }
    return +value;
  }
  function determineUnitForAutoTicks(minUnit, min, max, capacity) {
    const ilen = UNITS.length;
    for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
      const interval = INTERVALS[UNITS[i]];
      const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
      if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
        return UNITS[i];
      }
    }
    return UNITS[ilen - 1];
  }
  function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
    for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
      const unit = UNITS[i];
      if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
        return unit;
      }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
  }
  function determineMajorUnit(unit) {
    for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
      if (INTERVALS[UNITS[i]].common) {
        return UNITS[i];
      }
    }
  }
  function addTick(ticks, time, timestamps) {
    if (!timestamps) {
      ticks[time] = true;
    } else if (timestamps.length) {
      const { lo: lo2, hi: hi3 } = _lookup(timestamps, time);
      const timestamp = timestamps[lo2] >= time ? timestamps[lo2] : timestamps[hi3];
      ticks[timestamp] = true;
    }
  }
  function setMajorTicks(scale, ticks, map3, majorUnit) {
    const adapter = scale._adapter;
    const first = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index3;
    for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
      index3 = map3[major];
      if (index3 >= 0) {
        ticks[index3].major = true;
      }
    }
    return ticks;
  }
  function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
    const map3 = {};
    const ilen = values.length;
    let i, value;
    for (i = 0; i < ilen; ++i) {
      value = values[i];
      map3[value] = i;
      ticks.push({
        value,
        major: false
      });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
  }
  var TimeScale = class extends Scale2 {
    constructor(props) {
      super(props);
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
      this._unit = "day";
      this._majorUnit = void 0;
      this._offsets = {};
      this._normalized = false;
      this._parseOpts = void 0;
    }
    init(scaleOpts, opts) {
      const time = scaleOpts.time || (scaleOpts.time = {});
      const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
      adapter.init(opts);
      mergeIf(time.displayFormats, adapter.formats());
      this._parseOpts = {
        parser: time.parser,
        round: time.round,
        isoWeekday: time.isoWeekday
      };
      super.init(scaleOpts);
      this._normalized = opts.normalized;
    }
    parse(raw, index3) {
      if (raw === void 0) {
        return null;
      }
      return parse(this, raw);
    }
    beforeLayout() {
      super.beforeLayout();
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
    }
    determineDataLimits() {
      const options = this.options;
      const adapter = this._adapter;
      const unit = options.time.unit || "day";
      let { min, max, minDefined, maxDefined } = this.getUserBounds();
      function _applyBounds(bounds) {
        if (!minDefined && !isNaN(bounds.min)) {
          min = Math.min(min, bounds.min);
        }
        if (!maxDefined && !isNaN(bounds.max)) {
          max = Math.max(max, bounds.max);
        }
      }
      if (!minDefined || !maxDefined) {
        _applyBounds(this._getLabelBounds());
        if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
          _applyBounds(this.getMinMax(false));
        }
      }
      min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
      max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
      this.min = Math.min(min, max - 1);
      this.max = Math.max(min + 1, max);
    }
    _getLabelBounds() {
      const arr = this.getLabelTimestamps();
      let min = Number.POSITIVE_INFINITY;
      let max = Number.NEGATIVE_INFINITY;
      if (arr.length) {
        min = arr[0];
        max = arr[arr.length - 1];
      }
      return { min, max };
    }
    buildTicks() {
      const options = this.options;
      const timeOpts = options.time;
      const tickOpts = options.ticks;
      const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
      if (options.bounds === "ticks" && timestamps.length) {
        this.min = this._userMin || timestamps[0];
        this.max = this._userMax || timestamps[timestamps.length - 1];
      }
      const min = this.min;
      const max = this.max;
      const ticks = _filterBetween(timestamps, min, max);
      this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
      this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
      this.initOffsets(timestamps);
      if (options.reverse) {
        ticks.reverse();
      }
      return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
      if (this.options.offsetAfterAutoskip) {
        this.initOffsets(this.ticks.map((tick) => +tick.value));
      }
    }
    initOffsets(timestamps) {
      let start2 = 0;
      let end = 0;
      let first, last;
      if (this.options.offset && timestamps.length) {
        first = this.getDecimalForValue(timestamps[0]);
        if (timestamps.length === 1) {
          start2 = 1 - first;
        } else {
          start2 = (this.getDecimalForValue(timestamps[1]) - first) / 2;
        }
        last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
        if (timestamps.length === 1) {
          end = last;
        } else {
          end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
        }
      }
      const limit = timestamps.length < 3 ? 0.5 : 0.25;
      start2 = _limitValue(start2, 0, limit);
      end = _limitValue(end, 0, limit);
      this._offsets = { start: start2, end, factor: 1 / (start2 + 1 + end) };
    }
    _generate() {
      const adapter = this._adapter;
      const min = this.min;
      const max = this.max;
      const options = this.options;
      const timeOpts = options.time;
      const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
      const stepSize = valueOrDefault(timeOpts.stepSize, 1);
      const weekday = minor === "week" ? timeOpts.isoWeekday : false;
      const hasWeekday = isNumber2(weekday) || weekday === true;
      const ticks = {};
      let first = min;
      let time, count;
      if (hasWeekday) {
        first = +adapter.startOf(first, "isoWeek", weekday);
      }
      first = +adapter.startOf(first, hasWeekday ? "day" : minor);
      if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
        throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
      }
      const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
      for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
        addTick(ticks, time, timestamps);
      }
      if (time === max || options.bounds === "ticks" || count === 1) {
        addTick(ticks, time, timestamps);
      }
      return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
    }
    getLabelForValue(value) {
      const adapter = this._adapter;
      const timeOpts = this.options.time;
      if (timeOpts.tooltipFormat) {
        return adapter.format(value, timeOpts.tooltipFormat);
      }
      return adapter.format(value, timeOpts.displayFormats.datetime);
    }
    _tickFormatFunction(time, index3, ticks, format) {
      const options = this.options;
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const majorUnit = this._majorUnit;
      const minorFormat = unit && formats[unit];
      const majorFormat = majorUnit && formats[majorUnit];
      const tick = ticks[index3];
      const major = majorUnit && majorFormat && tick && tick.major;
      const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
      const formatter = options.ticks.callback;
      return formatter ? callback(formatter, [label, index3, ticks], this) : label;
    }
    generateTickLabels(ticks) {
      let i, ilen, tick;
      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        tick = ticks[i];
        tick.label = this._tickFormatFunction(tick.value, i, ticks);
      }
    }
    getDecimalForValue(value) {
      return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
    getPixelForValue(value) {
      const offsets = this._offsets;
      const pos = this.getDecimalForValue(value);
      return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return this.min + pos * (this.max - this.min);
    }
    _getLabelSize(label) {
      const ticksOpts = this.options.ticks;
      const tickLabelWidth = this.ctx.measureText(label).width;
      const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
      const cosRotation = Math.cos(angle);
      const sinRotation = Math.sin(angle);
      const tickFontSize = this._resolveTickFontOptions(0).size;
      return {
        w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
        h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
      };
    }
    _getLabelCapacity(exampleTime) {
      const timeOpts = this.options.time;
      const displayFormats = timeOpts.displayFormats;
      const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
      const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
      const size = this._getLabelSize(exampleLabel);
      const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
      return capacity > 0 ? capacity : 1;
    }
    getDataTimestamps() {
      let timestamps = this._cache.data || [];
      let i, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const metas = this.getMatchingVisibleMetas();
      if (this._normalized && metas.length) {
        return this._cache.data = metas[0].controller.getAllParsedValues(this);
      }
      for (i = 0, ilen = metas.length; i < ilen; ++i) {
        timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
      }
      return this._cache.data = this.normalize(timestamps);
    }
    getLabelTimestamps() {
      const timestamps = this._cache.labels || [];
      let i, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const labels = this.getLabels();
      for (i = 0, ilen = labels.length; i < ilen; ++i) {
        timestamps.push(parse(this, labels[i]));
      }
      return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
    normalize(values) {
      return _arrayUnique(values.sort(sorter));
    }
  };
  TimeScale.id = "time";
  TimeScale.defaults = {
    bounds: "data",
    adapters: {},
    time: {
      parser: false,
      unit: false,
      round: false,
      isoWeekday: false,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      major: {
        enabled: false
      }
    }
  };
  function interpolate2(table, val, reverse) {
    let lo2 = 0;
    let hi3 = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
      if (val >= table[lo2].pos && val <= table[hi3].pos) {
        ({ lo: lo2, hi: hi3 } = _lookupByKey(table, "pos", val));
      }
      ({ pos: prevSource, time: prevTarget } = table[lo2]);
      ({ pos: nextSource, time: nextTarget } = table[hi3]);
    } else {
      if (val >= table[lo2].time && val <= table[hi3].time) {
        ({ lo: lo2, hi: hi3 } = _lookupByKey(table, "time", val));
      }
      ({ time: prevSource, pos: prevTarget } = table[lo2]);
      ({ time: nextSource, pos: nextTarget } = table[hi3]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
  }
  var TimeSeriesScale = class extends TimeScale {
    constructor(props) {
      super(props);
      this._table = [];
      this._minPos = void 0;
      this._tableRange = void 0;
    }
    initOffsets() {
      const timestamps = this._getTimestampsForTable();
      const table = this._table = this.buildLookupTable(timestamps);
      this._minPos = interpolate2(table, this.min);
      this._tableRange = interpolate2(table, this.max) - this._minPos;
      super.initOffsets(timestamps);
    }
    buildLookupTable(timestamps) {
      const { min, max } = this;
      const items = [];
      const table = [];
      let i, ilen, prev, curr, next;
      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        curr = timestamps[i];
        if (curr >= min && curr <= max) {
          items.push(curr);
        }
      }
      if (items.length < 2) {
        return [
          { time: min, pos: 0 },
          { time: max, pos: 1 }
        ];
      }
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        next = items[i + 1];
        prev = items[i - 1];
        curr = items[i];
        if (Math.round((next + prev) / 2) !== curr) {
          table.push({ time: curr, pos: i / (ilen - 1) });
        }
      }
      return table;
    }
    _getTimestampsForTable() {
      let timestamps = this._cache.all || [];
      if (timestamps.length) {
        return timestamps;
      }
      const data = this.getDataTimestamps();
      const label = this.getLabelTimestamps();
      if (data.length && label.length) {
        timestamps = this.normalize(data.concat(label));
      } else {
        timestamps = data.length ? data : label;
      }
      timestamps = this._cache.all = timestamps;
      return timestamps;
    }
    getDecimalForValue(value) {
      return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
    }
  };
  TimeSeriesScale.id = "timeseries";
  TimeSeriesScale.defaults = TimeScale.defaults;
  var scales = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    CategoryScale,
    LinearScale,
    LogarithmicScale,
    RadialLinearScale,
    TimeScale,
    TimeSeriesScale
  });
  var registerables = [
    controllers,
    elements,
    plugins2,
    scales
  ];

  // static/js/statistics.ts
  if (registerables) {
    Chart.register(...registerables);
  }
  function resolve_student(class_id, error_id, prompt) {
    modal.confirm(prompt, function() {
      $.ajax({
        type: "DELETE",
        url: "/live_stats/class/" + class_id + "/error/" + error_id,
        contentType: "application/json",
        dataType: "json"
      }).done(function(response) {
        if (response.achievement) {
          showAchievements(response.achievement, true, "");
        } else {
          location.reload();
        }
      }).fail(function(err) {
        modal.notifyError(err.responseText);
      });
    });
  }
  function InitLineChart(data, labels) {
    const ctx = document.getElementById("runsOverTime");
    new Chart(ctx, {
      type: "line",
      data: {
        labels: labels.map(String),
        datasets: [{
          data,
          fill: false,
          pointBackgroundColor: function(context2) {
            var index3 = context2.dataIndex;
            var value = context2.dataset.data[index3];
            if (value === 0) {
              return "red";
            } else if (value === 1) {
              return "green";
            }
            return "blue";
          },
          borderColor: "rgba(0, 0, 255, 0.6)",
          borderWidth: 1
        }]
      },
      options: {
        scales: {
          y: {
            ticks: {
              callback: function(index3) {
                if (index3 === 0) {
                  return "Fail";
                } else if (index3 === 1) {
                  return "Success";
                }
                return "";
              }
            }
          }
        },
        plugins: {
          legend: {
            display: false
          }
        }
      }
    });
  }
  function toggle_show_students_class_overview(adventure) {
    var adventure_panel = "div[id='adventure_panel_" + adventure + "']";
    if ($(adventure_panel).hasClass("hidden")) {
      $(adventure_panel).removeClass("hidden");
      $(adventure_panel).addClass("block");
    } else {
      $(adventure_panel).removeClass("block");
      $(adventure_panel).addClass("hidden");
    }
  }
  var sleep17 = (ms2) => new Promise((r) => setTimeout(r, ms2));

  // static/js/logs.ts
  var logs = {
    initialize: function() {
      $("#logs-spinner").hide();
      $("#search-logs-failed-msg").hide();
      $("#search-logs-empty-msg").hide();
      const today = new Date().toISOString().split("T")[0];
      $("#logs-start-date").val(today + " 00:00:00");
      $("#logs-end-date").val(today + " 23:59:59");
    },
    searchProgramLogs: function(classId) {
      var raw_data = $("#logs-search-form").serializeArray();
      var payload = {};
      $.map(raw_data, function(n) {
        payload[n["name"]] = n["value"];
      });
      payload["class_id"] = classId;
      $("#search-logs-empty-msg").hide();
      $("#search-logs-failed-msg").hide();
      $("#logs-spinner").show();
      $("#logs-load-more").hide();
      $("#search-logs-button").prop("disabled", true);
      $("#search-logs-table tbody").html("");
      const self2 = this;
      $.ajax({ type: "POST", url: "/logs/query", data: JSON.stringify(payload), contentType: "application/json; charset=utf-8" }).done(function(response) {
        if (response["query_status"] === "SUCCEEDED") {
          self2.logsExecutionQueryId = response["query_execution_id"];
          self2.logsNextToken = "";
          self2.fetchProgramLogsResults();
        } else {
          $("#search-logs-failed-msg").show();
        }
      }).fail(function(error2) {
        $("#search-logs-failed-msg").show();
        console.log(error2);
      }).always(function() {
        $("#logs-spinner").hide();
        $("#search-logs-button").prop("disabled", false);
      });
      return false;
    },
    logsExecutionQueryId: "",
    logsNextToken: "",
    fetchProgramLogsResults: function() {
      $("#logs-spinner").show();
      $("#search-logs-empty-msg").hide();
      $("#logs-load-more").hide();
      const data = {
        query_execution_id: this.logsExecutionQueryId,
        next_token: this.logsNextToken ? this.logsNextToken : void 0
      };
      const self2 = this;
      $.get("/logs/results", data).done(function(response) {
        const $logsTable = $("#search-logs-table tbody");
        response.data.forEach((e) => {
          $logsTable.append(`<tr>           <td class="border px-2">${e.date}</td>           <td class="border px-2">${e.level}</td>           <td class="border px-2">${e.lang || ""}</td>           <td class="border px-2 break-words">${e.username || ""}</td>           <td class="border px-2 break-words">${e.exception || ""}</td>           <td class="border px-2 max-w-md">             <button class="green-btn float-right top-2 right-2" onclick=hedyApp.logs.copyCode(this)>\u21E5</button>             <pre class="break-words">${e.code}</pre>           </td></tr>`);
        });
        if (response.data.length == 0) {
          $("#search-logs-empty-msg").show();
        }
        self2.logsNextToken = response.next_token;
      }).fail(function(error2) {
        console.log(error2);
      }).always(function() {
        $("#logs-spinner").hide();
        if (self2.logsNextToken) {
          $("#logs-load-more").show();
        }
      });
      return false;
    },
    copyCode: function(el3) {
      const copyButton = $(el3);
      if (navigator.clipboard === void 0) {
        updateCopyButtonText(copyButton, "Failed!");
      } else {
        navigator.clipboard.writeText(copyButton.next().text()).then(function() {
          updateCopyButtonText(copyButton, "Copied!");
        }, function() {
          updateCopyButtonText(copyButton, "Failed!");
        });
      }
      return false;
    }
  };
  function updateCopyButtonText(copyBtn, text) {
    copyBtn.text(text);
    setTimeout(function() {
      copyBtn.html("\u21E5");
    }, 2e3);
  }

  // static/js/admin.ts
  function initializeAdminUserPage(_options) {
    $(".attribute").change(function() {
      const attribute = $(this).attr("id");
      if (!this.checked) {
        $("#" + attribute + "_header").hide();
        $("." + attribute + "_cell").hide();
      } else {
        $("#" + attribute + "_header").show();
        $("." + attribute + "_cell").show();
      }
    });
    $("#admin_filter_category").change(function() {
      $(".filter_input").hide();
      if ($("#admin_filter_category").val() == "email" || $("#admin_filter_category").val() == "username") {
        $("#email_filter_input").show();
      } else if ($("#admin_filter_category").val() == "language") {
        $("#language_filter_input").show();
      } else if ($("#admin_filter_category").val() == "keyword_language") {
        $("#keyword_language_filter_input").show();
      } else {
        $("#date_filter_input").show();
      }
    });
    $("#next_page_btn").click(function() {
      var token = $("#next_page_btn").data("page_token");
      console.log(token);
      $("#hidden-page-input").attr("value", token);
      $("#filterform").submit();
    });
  }

  // static/js/initialize.ts
  function initialize(options) {
    var _a3;
    setClientMessageLanguage(options.lang);
    initializeApp({
      level: options.level,
      keywordLanguage: options.keyword_language,
      staticRoot: options.staticRoot
    });
    initializeFormSubmits();
    initializeTutorial();
    switch ((_a3 = options.javascriptPageOptions) == null ? void 0 : _a3.page) {
      case "code":
        initializeCodePage(options.javascriptPageOptions);
        break;
      case "customize-class":
        initializeCustomizeClassPage(options.javascriptPageOptions);
        break;
      case "for-teachers":
        initializeTeacherPage(options.javascriptPageOptions);
        break;
      case "class-overview":
        initializeClassOverviewPage(options.javascriptPageOptions);
        break;
      case "view-program":
        initializeViewProgramPage(options.javascriptPageOptions);
        break;
      case "admin-users":
        initializeAdminUserPage(options.javascriptPageOptions);
        break;
    }
    if (options.logs) {
      logs.initialize();
    }
  }

  // node_modules/tw-elements/dist/js/tw-elements.es.min.js
  var Tn = (() => {
    const s = {};
    let t2 = 1;
    return {
      set(e, i, n) {
        typeof e[i] > "u" && (e[i] = {
          key: i,
          id: t2
        }, t2++), s[e[i].id] = n;
      },
      get(e, i) {
        if (!e || typeof e[i] > "u")
          return null;
        const n = e[i];
        return n.key === i ? s[n.id] : null;
      },
      delete(e, i) {
        if (typeof e[i] > "u")
          return;
        const n = e[i];
        n.key === i && (delete s[n.id], delete e[i]);
      }
    };
  })();
  var y = {
    setData(s, t2, e) {
      Tn.set(s, t2, e);
    },
    getData(s, t2) {
      return Tn.get(s, t2);
    },
    removeData(s, t2) {
      Tn.delete(s, t2);
    }
  };
  var Wh = 1e6;
  var Fh = 1e3;
  var xo = "transitionend";
  var Yh = (s) => s == null ? `${s}` : {}.toString.call(s).match(/\s([a-z]+)/i)[1].toLowerCase();
  var rt = (s) => {
    do
      s += Math.floor(Math.random() * Wh);
    while (document.getElementById(s));
    return s;
  };
  var Ul = (s) => {
    let t2 = s.getAttribute("data-te-target");
    if (!t2 || t2 === "#") {
      let e = s.getAttribute("href");
      if (!e || !e.includes("#") && !e.startsWith("."))
        return null;
      e.includes("#") && !e.startsWith("#") && (e = `#${e.split("#")[1]}`), t2 = e && e !== "#" ? e.trim() : null;
    }
    return t2;
  };
  var qo = (s) => {
    const t2 = Ul(s);
    return t2 && document.querySelector(t2) ? t2 : null;
  };
  var Jt = (s) => {
    const t2 = Ul(s);
    return t2 ? document.querySelector(t2) : null;
  };
  var jh = (s) => {
    if (!s)
      return 0;
    let { transitionDuration: t2, transitionDelay: e } = window.getComputedStyle(s);
    const i = Number.parseFloat(t2), n = Number.parseFloat(e);
    return !i && !n ? 0 : (t2 = t2.split(",")[0], e = e.split(",")[0], (Number.parseFloat(t2) + Number.parseFloat(e)) * Fh);
  };
  var Xl = (s) => {
    s.dispatchEvent(new Event(xo));
  };
  var je = (s) => !s || typeof s != "object" ? false : (typeof s.jquery < "u" && (s = s[0]), typeof s.nodeType < "u");
  var te2 = (s) => je(s) ? s.jquery ? s[0] : s : typeof s == "string" && s.length > 0 ? document.querySelector(s) : null;
  var D = (s, t2, e) => {
    Object.keys(e).forEach((i) => {
      const n = e[i], o = t2[i], r = o && je(o) ? "element" : Yh(o);
      if (!new RegExp(n).test(r))
        throw new Error(`${s.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${n}".`);
    });
  };
  var Nt = (s) => {
    if (!s || s.getClientRects().length === 0)
      return false;
    if (s.style && s.parentNode && s.parentNode.style) {
      const t2 = getComputedStyle(s), e = getComputedStyle(s.parentNode);
      return getComputedStyle(s).getPropertyValue("visibility") === "visible" || t2.display !== "none" && e.display !== "none" && t2.visibility !== "hidden";
    }
    return false;
  };
  var ge = (s) => !s || s.nodeType !== Node.ELEMENT_NODE || s.classList.contains("disabled") ? true : typeof s.disabled < "u" ? s.disabled : s.hasAttribute("disabled") && s.getAttribute("disabled") !== "false";
  var Gl = (s) => {
    if (!document.documentElement.attachShadow)
      return null;
    if (typeof s.getRootNode == "function") {
      const t2 = s.getRootNode();
      return t2 instanceof ShadowRoot ? t2 : null;
    }
    return s instanceof ShadowRoot ? s : s.parentNode ? Gl(s.parentNode) : null;
  };
  var tn2 = () => function() {
  };
  var ql = () => {
    const { jQuery: s } = window;
    return s && !document.body.hasAttribute("data-te-no-jquery") ? s : null;
  };
  var En = [];
  var Zl = (s) => {
    document.readyState === "loading" ? (En.length || document.addEventListener("DOMContentLoaded", () => {
      En.forEach((t2) => t2());
    }), En.push(s)) : s();
  };
  var F = () => document.documentElement.dir === "rtl";
  var $2 = (s) => document.createElement(s);
  var me = (s) => {
    typeof s == "function" && s();
  };
  var Ql = (s, t2, e = true) => {
    if (!e) {
      me(s);
      return;
    }
    const i = 5, n = jh(t2) + i;
    let o = false;
    const r = ({ target: a }) => {
      a === t2 && (o = true, t2.removeEventListener(xo, r), me(s));
    };
    t2.addEventListener(xo, r), setTimeout(() => {
      o || Xl(t2);
    }, n);
  };
  var zh = /[^.]*(?=\..*)\.|.*/;
  var Uh = /\..*/;
  var Xh = /::\d+$/;
  var Cn = {};
  var xr = 1;
  var Gh = {
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  };
  var qh = /^(mouseenter|mouseleave)/i;
  var tc = /* @__PURE__ */ new Set([
    "click",
    "dblclick",
    "mouseup",
    "mousedown",
    "contextmenu",
    "mousewheel",
    "DOMMouseScroll",
    "mouseover",
    "mouseout",
    "mousemove",
    "selectstart",
    "selectend",
    "keydown",
    "keypress",
    "keyup",
    "orientationchange",
    "touchstart",
    "touchmove",
    "touchend",
    "touchcancel",
    "pointerdown",
    "pointermove",
    "pointerup",
    "pointerleave",
    "pointercancel",
    "gesturestart",
    "gesturechange",
    "gestureend",
    "focus",
    "blur",
    "change",
    "reset",
    "select",
    "submit",
    "focusin",
    "focusout",
    "load",
    "unload",
    "beforeunload",
    "resize",
    "move",
    "DOMContentLoaded",
    "readystatechange",
    "error",
    "abort",
    "scroll"
  ]);
  function ec(s, t2) {
    return t2 && `${t2}::${xr++}` || s.uidEvent || xr++;
  }
  function ic(s) {
    const t2 = ec(s);
    return s.uidEvent = t2, Cn[t2] = Cn[t2] || {}, Cn[t2];
  }
  function Zh(s, t2) {
    return function e(i) {
      return i.delegateTarget = s, e.oneOff && c.off(s, i.type, t2), t2.apply(s, [i]);
    };
  }
  function Qh(s, t2, e) {
    return function i(n) {
      const o = s.querySelectorAll(t2);
      for (let { target: r } = n; r && r !== this; r = r.parentNode)
        for (let a = o.length; a--; "")
          if (o[a] === r)
            return n.delegateTarget = r, i.oneOff && c.off(s, n.type, e), e.apply(r, [n]);
      return null;
    };
  }
  function sc(s, t2, e = null) {
    const i = Object.keys(s);
    for (let n = 0, o = i.length; n < o; n++) {
      const r = s[i[n]];
      if (r.originalHandler === t2 && r.delegationSelector === e)
        return r;
    }
    return null;
  }
  function nc(s, t2, e) {
    const i = typeof t2 == "string", n = i ? e : t2;
    let o = oc(s);
    return tc.has(o) || (o = s), [i, n, o];
  }
  function Or(s, t2, e, i, n) {
    if (typeof t2 != "string" || !s)
      return;
    if (e || (e = i, i = null), qh.test(t2)) {
      const g = (m) => function(b) {
        if (!b.relatedTarget || b.relatedTarget !== b.delegateTarget && !b.delegateTarget.contains(b.relatedTarget))
          return m.call(this, b);
      };
      i ? i = g(i) : e = g(e);
    }
    const [o, r, a] = nc(t2, e, i), l = ic(s), p = l[a] || (l[a] = {}), u = sc(p, r, o ? e : null);
    if (u) {
      u.oneOff = u.oneOff && n;
      return;
    }
    const _ = ec(r, t2.replace(zh, "")), f = o ? Qh(s, e, i) : Zh(s, e);
    f.delegationSelector = o ? e : null, f.originalHandler = r, f.oneOff = n, f.uidEvent = _, p[_] = f, s.addEventListener(a, f, o);
  }
  function Oo(s, t2, e, i, n) {
    const o = sc(t2[e], i, n);
    o && (s.removeEventListener(e, o, !!n), delete t2[e][o.uidEvent]);
  }
  function Jh(s, t2, e, i) {
    const n = t2[e] || {};
    Object.keys(n).forEach((o) => {
      if (o.includes(i)) {
        const r = n[o];
        Oo(s, t2, e, r.originalHandler, r.delegationSelector);
      }
    });
  }
  function oc(s) {
    return s = s.replace(Uh, ""), Gh[s] || s;
  }
  var c = {
    on(s, t2, e, i) {
      Or(s, t2, e, i, false);
    },
    one(s, t2, e, i) {
      Or(s, t2, e, i, true);
    },
    off(s, t2, e, i) {
      if (typeof t2 != "string" || !s)
        return;
      const [n, o, r] = nc(t2, e, i), a = r !== t2, l = ic(s), p = t2.startsWith(".");
      if (typeof o < "u") {
        if (!l || !l[r])
          return;
        Oo(s, l, r, o, n ? e : null);
        return;
      }
      p && Object.keys(l).forEach((_) => {
        Jh(s, l, _, t2.slice(1));
      });
      const u = l[r] || {};
      Object.keys(u).forEach((_) => {
        const f = _.replace(Xh, "");
        if (!a || t2.includes(f)) {
          const g = u[_];
          Oo(s, l, r, g.originalHandler, g.delegationSelector);
        }
      });
    },
    trigger(s, t2, e) {
      if (typeof t2 != "string" || !s)
        return null;
      const i = ql(), n = oc(t2), o = t2 !== n, r = tc.has(n);
      let a, l = true, p = true, u = false, _ = null;
      return o && i && (a = i.Event(t2, e), i(s).trigger(a), l = !a.isPropagationStopped(), p = !a.isImmediatePropagationStopped(), u = a.isDefaultPrevented()), r ? (_ = document.createEvent("HTMLEvents"), _.initEvent(n, l, true)) : _ = new CustomEvent(t2, {
        bubbles: l,
        cancelable: true
      }), typeof e < "u" && Object.keys(e).forEach((f) => {
        Object.defineProperty(_, f, {
          get() {
            return e[f];
          }
        });
      }), u && _.preventDefault(), p && s.dispatchEvent(_), _.defaultPrevented && typeof a < "u" && a.preventDefault(), _;
    }
  };
  var td = "5.1.3";
  var gt = class {
    constructor(t2) {
      t2 = te2(t2), t2 && (this._element = t2, y.setData(this._element, this.constructor.DATA_KEY, this));
    }
    dispose() {
      y.removeData(this._element, this.constructor.DATA_KEY), c.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t2) => {
        this[t2] = null;
      });
    }
    _queueCallback(t2, e, i = true) {
      Ql(t2, e, i);
    }
    static getInstance(t2) {
      return y.getData(te2(t2), this.DATA_KEY);
    }
    static getOrCreateInstance(t2, e = {}) {
      return this.getInstance(t2) || new this(t2, typeof e == "object" ? e : null);
    }
    static get VERSION() {
      return td;
    }
    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }
    static get DATA_KEY() {
      return `te.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
  };
  var Q = "top";
  var dt = "bottom";
  var ut = "right";
  var J = "left";
  var Hi = "auto";
  var ti = [Q, dt, ut, J];
  var Te = "start";
  var Ke = "end";
  var ac = "clippingParents";
  var Zo = "viewport";
  var $e = "popper";
  var lc = "reference";
  var So = /* @__PURE__ */ ti.reduce(function(s, t2) {
    return s.concat([t2 + "-" + Te, t2 + "-" + Ke]);
  }, []);
  var Qo = /* @__PURE__ */ [].concat(ti, [Hi]).reduce(function(s, t2) {
    return s.concat([t2, t2 + "-" + Te, t2 + "-" + Ke]);
  }, []);
  var cc = "beforeRead";
  var hc = "read";
  var dc = "afterRead";
  var uc = "beforeMain";
  var pc = "main";
  var _c = "afterMain";
  var fc = "beforeWrite";
  var mc = "write";
  var gc = "afterWrite";
  var en2 = [cc, hc, dc, uc, pc, _c, fc, mc, gc];
  function Mt(s) {
    return s ? (s.nodeName || "").toLowerCase() : null;
  }
  function pt(s) {
    if (s == null)
      return window;
    if (s.toString() !== "[object Window]") {
      var t2 = s.ownerDocument;
      return t2 && t2.defaultView || window;
    }
    return s;
  }
  function Ee(s) {
    var t2 = pt(s).Element;
    return s instanceof t2 || s instanceof Element;
  }
  function ht(s) {
    var t2 = pt(s).HTMLElement;
    return s instanceof t2 || s instanceof HTMLElement;
  }
  function Jo(s) {
    if (typeof ShadowRoot > "u")
      return false;
    var t2 = pt(s).ShadowRoot;
    return s instanceof t2 || s instanceof ShadowRoot;
  }
  function sd(s) {
    var t2 = s.state;
    Object.keys(t2.elements).forEach(function(e) {
      var i = t2.styles[e] || {}, n = t2.attributes[e] || {}, o = t2.elements[e];
      !ht(o) || !Mt(o) || (Object.assign(o.style, i), Object.keys(n).forEach(function(r) {
        var a = n[r];
        a === false ? o.removeAttribute(r) : o.setAttribute(r, a === true ? "" : a);
      }));
    });
  }
  function nd(s) {
    var t2 = s.state, e = {
      popper: {
        position: t2.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    return Object.assign(t2.elements.popper.style, e.popper), t2.styles = e, t2.elements.arrow && Object.assign(t2.elements.arrow.style, e.arrow), function() {
      Object.keys(t2.elements).forEach(function(i) {
        var n = t2.elements[i], o = t2.attributes[i] || {}, r = Object.keys(t2.styles.hasOwnProperty(i) ? t2.styles[i] : e[i]), a = r.reduce(function(l, p) {
          return l[p] = "", l;
        }, {});
        !ht(n) || !Mt(n) || (Object.assign(n.style, a), Object.keys(o).forEach(function(l) {
          n.removeAttribute(l);
        }));
      });
    };
  }
  var tr2 = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: sd,
    effect: nd,
    requires: ["computeStyles"]
  };
  function Tt(s) {
    return s.split("-")[0];
  }
  var be = Math.max;
  var sn = Math.min;
  var ze = Math.round;
  function Io() {
    var s = navigator.userAgentData;
    return s != null && s.brands && Array.isArray(s.brands) ? s.brands.map(function(t2) {
      return t2.brand + "/" + t2.version;
    }).join(" ") : navigator.userAgent;
  }
  function bc() {
    return !/^((?!chrome|android).)*safari/i.test(Io());
  }
  function Ue(s, t2, e) {
    t2 === void 0 && (t2 = false), e === void 0 && (e = false);
    var i = s.getBoundingClientRect(), n = 1, o = 1;
    t2 && ht(s) && (n = s.offsetWidth > 0 && ze(i.width) / s.offsetWidth || 1, o = s.offsetHeight > 0 && ze(i.height) / s.offsetHeight || 1);
    var r = Ee(s) ? pt(s) : window, a = r.visualViewport, l = !bc() && e, p = (i.left + (l && a ? a.offsetLeft : 0)) / n, u = (i.top + (l && a ? a.offsetTop : 0)) / o, _ = i.width / n, f = i.height / o;
    return {
      width: _,
      height: f,
      top: u,
      right: p + _,
      bottom: u + f,
      left: p,
      x: p,
      y: u
    };
  }
  function er(s) {
    var t2 = Ue(s), e = s.offsetWidth, i = s.offsetHeight;
    return Math.abs(t2.width - e) <= 1 && (e = t2.width), Math.abs(t2.height - i) <= 1 && (i = t2.height), {
      x: s.offsetLeft,
      y: s.offsetTop,
      width: e,
      height: i
    };
  }
  function vc(s, t2) {
    var e = t2.getRootNode && t2.getRootNode();
    if (s.contains(t2))
      return true;
    if (e && Jo(e)) {
      var i = t2;
      do {
        if (i && s.isSameNode(i))
          return true;
        i = i.parentNode || i.host;
      } while (i);
    }
    return false;
  }
  function Ct(s) {
    return pt(s).getComputedStyle(s);
  }
  function od(s) {
    return ["table", "td", "th"].indexOf(Mt(s)) >= 0;
  }
  function ee(s) {
    return ((Ee(s) ? s.ownerDocument : s.document) || window.document).documentElement;
  }
  function rn(s) {
    return Mt(s) === "html" ? s : s.assignedSlot || s.parentNode || (Jo(s) ? s.host : null) || ee(s);
  }
  function Sr(s) {
    return !ht(s) || Ct(s).position === "fixed" ? null : s.offsetParent;
  }
  function rd(s) {
    var t2 = /firefox/i.test(Io()), e = /Trident/i.test(Io());
    if (e && ht(s)) {
      var i = Ct(s);
      if (i.position === "fixed")
        return null;
    }
    var n = rn(s);
    for (Jo(n) && (n = n.host); ht(n) && ["html", "body"].indexOf(Mt(n)) < 0; ) {
      var o = Ct(n);
      if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t2 && o.willChange === "filter" || t2 && o.filter && o.filter !== "none")
        return n;
      n = n.parentNode;
    }
    return null;
  }
  function Vi(s) {
    for (var t2 = pt(s), e = Sr(s); e && od(e) && Ct(e).position === "static"; )
      e = Sr(e);
    return e && (Mt(e) === "html" || Mt(e) === "body" && Ct(e).position === "static") ? t2 : e || rd(s) || t2;
  }
  function ir(s) {
    return ["top", "bottom"].indexOf(s) >= 0 ? "x" : "y";
  }
  function Si(s, t2, e) {
    return be(s, sn(t2, e));
  }
  function ad(s, t2, e) {
    var i = Si(s, t2, e);
    return i > e ? e : i;
  }
  function Tc() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  function Ec(s) {
    return Object.assign({}, Tc(), s);
  }
  function Cc(s, t2) {
    return t2.reduce(function(e, i) {
      return e[i] = s, e;
    }, {});
  }
  var ld = function(t2, e) {
    return t2 = typeof t2 == "function" ? t2(Object.assign({}, e.rects, {
      placement: e.placement
    })) : t2, Ec(typeof t2 != "number" ? t2 : Cc(t2, ti));
  };
  function cd(s) {
    var t2, e = s.state, i = s.name, n = s.options, o = e.elements.arrow, r = e.modifiersData.popperOffsets, a = Tt(e.placement), l = ir(a), p = [J, ut].indexOf(a) >= 0, u = p ? "height" : "width";
    if (!(!o || !r)) {
      var _ = ld(n.padding, e), f = er(o), g = l === "y" ? Q : J, m = l === "y" ? dt : ut, b = e.rects.reference[u] + e.rects.reference[l] - r[l] - e.rects.popper[u], v = r[l] - e.rects.reference[l], C2 = Vi(o), w = C2 ? l === "y" ? C2.clientHeight || 0 : C2.clientWidth || 0 : 0, E = b / 2 - v / 2, T = _[g], A = w - f[u] - _[m], k = w / 2 - f[u] / 2 + E, I = Si(T, k, A), O = l;
      e.modifiersData[i] = (t2 = {}, t2[O] = I, t2.centerOffset = I - k, t2);
    }
  }
  function hd(s) {
    var t2 = s.state, e = s.options, i = e.element, n = i === void 0 ? "[data-popper-arrow]" : i;
    if (n != null && !(typeof n == "string" && (n = t2.elements.popper.querySelector(n), !n))) {
      if ({}.NODE_ENV !== "production" && (ht(n) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !vc(t2.elements.popper, n)) {
        ({}).NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
        return;
      }
      t2.elements.arrow = n;
    }
  }
  var Ac = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: cd,
    effect: hd,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function Xe(s) {
    return s.split("-")[1];
  }
  var dd = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function ud(s, t2) {
    var e = s.x, i = s.y, n = t2.devicePixelRatio || 1;
    return {
      x: ze(e * n) / n || 0,
      y: ze(i * n) / n || 0
    };
  }
  function Ir(s) {
    var t2, e = s.popper, i = s.popperRect, n = s.placement, o = s.variation, r = s.offsets, a = s.position, l = s.gpuAcceleration, p = s.adaptive, u = s.roundOffsets, _ = s.isFixed, f = r.x, g = f === void 0 ? 0 : f, m = r.y, b = m === void 0 ? 0 : m, v = typeof u == "function" ? u({
      x: g,
      y: b
    }) : {
      x: g,
      y: b
    };
    g = v.x, b = v.y;
    var C2 = r.hasOwnProperty("x"), w = r.hasOwnProperty("y"), E = J, T = Q, A = window;
    if (p) {
      var k = Vi(e), I = "clientHeight", O = "clientWidth";
      if (k === pt(e) && (k = ee(e), Ct(k).position !== "static" && a === "absolute" && (I = "scrollHeight", O = "scrollWidth")), k = k, n === Q || (n === J || n === ut) && o === Ke) {
        T = dt;
        var x = _ && k === A && A.visualViewport ? A.visualViewport.height : k[I];
        b -= x - i.height, b *= l ? 1 : -1;
      }
      if (n === J || (n === Q || n === dt) && o === Ke) {
        E = ut;
        var L = _ && k === A && A.visualViewport ? A.visualViewport.width : k[O];
        g -= L - i.width, g *= l ? 1 : -1;
      }
    }
    var S = Object.assign({
      position: a
    }, p && dd), N = u === true ? ud({
      x: g,
      y: b
    }, pt(e)) : {
      x: g,
      y: b
    };
    if (g = N.x, b = N.y, l) {
      var P;
      return Object.assign({}, S, (P = {}, P[T] = w ? "0" : "", P[E] = C2 ? "0" : "", P.transform = (A.devicePixelRatio || 1) <= 1 ? "translate(" + g + "px, " + b + "px)" : "translate3d(" + g + "px, " + b + "px, 0)", P));
    }
    return Object.assign({}, S, (t2 = {}, t2[T] = w ? b + "px" : "", t2[E] = C2 ? g + "px" : "", t2.transform = "", t2));
  }
  function pd(s) {
    var t2 = s.state, e = s.options, i = e.gpuAcceleration, n = i === void 0 ? true : i, o = e.adaptive, r = o === void 0 ? true : o, a = e.roundOffsets, l = a === void 0 ? true : a;
    if ({}.NODE_ENV !== "production") {
      var p = Ct(t2.elements.popper).transitionProperty || "";
      r && ["transform", "top", "right", "bottom", "left"].some(function(_) {
        return p.indexOf(_) >= 0;
      }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
    var u = {
      placement: Tt(t2.placement),
      variation: Xe(t2.placement),
      popper: t2.elements.popper,
      popperRect: t2.rects.popper,
      gpuAcceleration: n,
      isFixed: t2.options.strategy === "fixed"
    };
    t2.modifiersData.popperOffsets != null && (t2.styles.popper = Object.assign({}, t2.styles.popper, Ir(Object.assign({}, u, {
      offsets: t2.modifiersData.popperOffsets,
      position: t2.options.strategy,
      adaptive: r,
      roundOffsets: l
    })))), t2.modifiersData.arrow != null && (t2.styles.arrow = Object.assign({}, t2.styles.arrow, Ir(Object.assign({}, u, {
      offsets: t2.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets: l
    })))), t2.attributes.popper = Object.assign({}, t2.attributes.popper, {
      "data-popper-placement": t2.placement
    });
  }
  var sr2 = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: pd,
    data: {}
  };
  var ts = {
    passive: true
  };
  function _d(s) {
    var t2 = s.state, e = s.instance, i = s.options, n = i.scroll, o = n === void 0 ? true : n, r = i.resize, a = r === void 0 ? true : r, l = pt(t2.elements.popper), p = [].concat(t2.scrollParents.reference, t2.scrollParents.popper);
    return o && p.forEach(function(u) {
      u.addEventListener("scroll", e.update, ts);
    }), a && l.addEventListener("resize", e.update, ts), function() {
      o && p.forEach(function(u) {
        u.removeEventListener("scroll", e.update, ts);
      }), a && l.removeEventListener("resize", e.update, ts);
    };
  }
  var nr = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function() {
    },
    effect: _d,
    data: {}
  };
  var fd = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function Ms(s) {
    return s.replace(/left|right|bottom|top/g, function(t2) {
      return fd[t2];
    });
  }
  var md = {
    start: "end",
    end: "start"
  };
  function Dr(s) {
    return s.replace(/start|end/g, function(t2) {
      return md[t2];
    });
  }
  function or7(s) {
    var t2 = pt(s), e = t2.pageXOffset, i = t2.pageYOffset;
    return {
      scrollLeft: e,
      scrollTop: i
    };
  }
  function rr(s) {
    return Ue(ee(s)).left + or7(s).scrollLeft;
  }
  function gd(s, t2) {
    var e = pt(s), i = ee(s), n = e.visualViewport, o = i.clientWidth, r = i.clientHeight, a = 0, l = 0;
    if (n) {
      o = n.width, r = n.height;
      var p = bc();
      (p || !p && t2 === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
    }
    return {
      width: o,
      height: r,
      x: a + rr(s),
      y: l
    };
  }
  function bd(s) {
    var t2, e = ee(s), i = or7(s), n = (t2 = s.ownerDocument) == null ? void 0 : t2.body, o = be(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), r = be(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -i.scrollLeft + rr(s), l = -i.scrollTop;
    return Ct(n || e).direction === "rtl" && (a += be(e.clientWidth, n ? n.clientWidth : 0) - o), {
      width: o,
      height: r,
      x: a,
      y: l
    };
  }
  function ar2(s) {
    var t2 = Ct(s), e = t2.overflow, i = t2.overflowX, n = t2.overflowY;
    return /auto|scroll|overlay|hidden/.test(e + n + i);
  }
  function yc(s) {
    return ["html", "body", "#document"].indexOf(Mt(s)) >= 0 ? s.ownerDocument.body : ht(s) && ar2(s) ? s : yc(rn(s));
  }
  function Ii(s, t2) {
    var e;
    t2 === void 0 && (t2 = []);
    var i = yc(s), n = i === ((e = s.ownerDocument) == null ? void 0 : e.body), o = pt(i), r = n ? [o].concat(o.visualViewport || [], ar2(i) ? i : []) : i, a = t2.concat(r);
    return n ? a : a.concat(Ii(rn(r)));
  }
  function Do(s) {
    return Object.assign({}, s, {
      left: s.x,
      top: s.y,
      right: s.x + s.width,
      bottom: s.y + s.height
    });
  }
  function vd(s, t2) {
    var e = Ue(s, false, t2 === "fixed");
    return e.top = e.top + s.clientTop, e.left = e.left + s.clientLeft, e.bottom = e.top + s.clientHeight, e.right = e.left + s.clientWidth, e.width = s.clientWidth, e.height = s.clientHeight, e.x = e.left, e.y = e.top, e;
  }
  function $r(s, t2, e) {
    return t2 === Zo ? Do(gd(s, e)) : Ee(t2) ? vd(t2, e) : Do(bd(ee(s)));
  }
  function Td(s) {
    var t2 = Ii(rn(s)), e = ["absolute", "fixed"].indexOf(Ct(s).position) >= 0, i = e && ht(s) ? Vi(s) : s;
    return Ee(i) ? t2.filter(function(n) {
      return Ee(n) && vc(n, i) && Mt(n) !== "body";
    }) : [];
  }
  function Ed(s, t2, e, i) {
    var n = t2 === "clippingParents" ? Td(s) : [].concat(t2), o = [].concat(n, [e]), r = o[0], a = o.reduce(function(l, p) {
      var u = $r(s, p, i);
      return l.top = be(u.top, l.top), l.right = sn(u.right, l.right), l.bottom = sn(u.bottom, l.bottom), l.left = be(u.left, l.left), l;
    }, $r(s, r, i));
    return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
  }
  function wc(s) {
    var t2 = s.reference, e = s.element, i = s.placement, n = i ? Tt(i) : null, o = i ? Xe(i) : null, r = t2.x + t2.width / 2 - e.width / 2, a = t2.y + t2.height / 2 - e.height / 2, l;
    switch (n) {
      case Q:
        l = {
          x: r,
          y: t2.y - e.height
        };
        break;
      case dt:
        l = {
          x: r,
          y: t2.y + t2.height
        };
        break;
      case ut:
        l = {
          x: t2.x + t2.width,
          y: a
        };
        break;
      case J:
        l = {
          x: t2.x - e.width,
          y: a
        };
        break;
      default:
        l = {
          x: t2.x,
          y: t2.y
        };
    }
    var p = n ? ir(n) : null;
    if (p != null) {
      var u = p === "y" ? "height" : "width";
      switch (o) {
        case Te:
          l[p] = l[p] - (t2[u] / 2 - e[u] / 2);
          break;
        case Ke:
          l[p] = l[p] + (t2[u] / 2 - e[u] / 2);
          break;
      }
    }
    return l;
  }
  function Ge(s, t2) {
    t2 === void 0 && (t2 = {});
    var e = t2, i = e.placement, n = i === void 0 ? s.placement : i, o = e.strategy, r = o === void 0 ? s.strategy : o, a = e.boundary, l = a === void 0 ? ac : a, p = e.rootBoundary, u = p === void 0 ? Zo : p, _ = e.elementContext, f = _ === void 0 ? $e : _, g = e.altBoundary, m = g === void 0 ? false : g, b = e.padding, v = b === void 0 ? 0 : b, C2 = Ec(typeof v != "number" ? v : Cc(v, ti)), w = f === $e ? lc : $e, E = s.rects.popper, T = s.elements[m ? w : f], A = Ed(Ee(T) ? T : T.contextElement || ee(s.elements.popper), l, u, r), k = Ue(s.elements.reference), I = wc({
      reference: k,
      element: E,
      strategy: "absolute",
      placement: n
    }), O = Do(Object.assign({}, E, I)), x = f === $e ? O : k, L = {
      top: A.top - x.top + C2.top,
      bottom: x.bottom - A.bottom + C2.bottom,
      left: A.left - x.left + C2.left,
      right: x.right - A.right + C2.right
    }, S = s.modifiersData.offset;
    if (f === $e && S) {
      var N = S[n];
      Object.keys(L).forEach(function(P) {
        var tt = [ut, dt].indexOf(P) >= 0 ? 1 : -1, et2 = [Q, dt].indexOf(P) >= 0 ? "y" : "x";
        L[P] += N[et2] * tt;
      });
    }
    return L;
  }
  function Cd(s, t2) {
    t2 === void 0 && (t2 = {});
    var e = t2, i = e.placement, n = e.boundary, o = e.rootBoundary, r = e.padding, a = e.flipVariations, l = e.allowedAutoPlacements, p = l === void 0 ? Qo : l, u = Xe(i), _ = u ? a ? So : So.filter(function(m) {
      return Xe(m) === u;
    }) : ti, f = _.filter(function(m) {
      return p.indexOf(m) >= 0;
    });
    f.length === 0 && (f = _, {}.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
    var g = f.reduce(function(m, b) {
      return m[b] = Ge(s, {
        placement: b,
        boundary: n,
        rootBoundary: o,
        padding: r
      })[Tt(b)], m;
    }, {});
    return Object.keys(g).sort(function(m, b) {
      return g[m] - g[b];
    });
  }
  function Ad(s) {
    if (Tt(s) === Hi)
      return [];
    var t2 = Ms(s);
    return [Dr(s), t2, Dr(t2)];
  }
  function yd(s) {
    var t2 = s.state, e = s.options, i = s.name;
    if (!t2.modifiersData[i]._skip) {
      for (var n = e.mainAxis, o = n === void 0 ? true : n, r = e.altAxis, a = r === void 0 ? true : r, l = e.fallbackPlacements, p = e.padding, u = e.boundary, _ = e.rootBoundary, f = e.altBoundary, g = e.flipVariations, m = g === void 0 ? true : g, b = e.allowedAutoPlacements, v = t2.options.placement, C2 = Tt(v), w = C2 === v, E = l || (w || !m ? [Ms(v)] : Ad(v)), T = [v].concat(E).reduce(function(ye, Ht) {
        return ye.concat(Tt(Ht) === Hi ? Cd(t2, {
          placement: Ht,
          boundary: u,
          rootBoundary: _,
          padding: p,
          flipVariations: m,
          allowedAutoPlacements: b
        }) : Ht);
      }, []), A = t2.rects.reference, k = t2.rects.popper, I = /* @__PURE__ */ new Map(), O = true, x = T[0], L = 0; L < T.length; L++) {
        var S = T[L], N = Tt(S), P = Xe(S) === Te, tt = [Q, dt].indexOf(N) >= 0, et2 = tt ? "width" : "height", U = Ge(t2, {
          placement: S,
          boundary: u,
          rootBoundary: _,
          altBoundary: f,
          padding: p
        }), bt = tt ? P ? ut : J : P ? dt : Q;
        A[et2] > k[et2] && (bt = Ms(bt));
        var Gi = Ms(bt), se = [];
        if (o && se.push(U[N] <= 0), a && se.push(U[bt] <= 0, U[Gi] <= 0), se.every(function(ye) {
          return ye;
        })) {
          x = S, O = false;
          break;
        }
        I.set(S, se);
      }
      if (O)
        for (var qi = m ? 3 : 1, mn = function(Ht) {
          var ri = T.find(function(Qi) {
            var ne = I.get(Qi);
            if (ne)
              return ne.slice(0, Ht).every(function(gn) {
                return gn;
              });
          });
          if (ri)
            return x = ri, "break";
        }, oi = qi; oi > 0; oi--) {
          var Zi = mn(oi);
          if (Zi === "break")
            break;
        }
      t2.placement !== x && (t2.modifiersData[i]._skip = true, t2.placement = x, t2.reset = true);
    }
  }
  var kc = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: yd,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };
  function Lr(s, t2, e) {
    return e === void 0 && (e = {
      x: 0,
      y: 0
    }), {
      top: s.top - t2.height - e.y,
      right: s.right - t2.width + e.x,
      bottom: s.bottom - t2.height + e.y,
      left: s.left - t2.width - e.x
    };
  }
  function Nr(s) {
    return [Q, ut, dt, J].some(function(t2) {
      return s[t2] >= 0;
    });
  }
  function wd(s) {
    var t2 = s.state, e = s.name, i = t2.rects.reference, n = t2.rects.popper, o = t2.modifiersData.preventOverflow, r = Ge(t2, {
      elementContext: "reference"
    }), a = Ge(t2, {
      altBoundary: true
    }), l = Lr(r, i), p = Lr(a, n, o), u = Nr(l), _ = Nr(p);
    t2.modifiersData[e] = {
      referenceClippingOffsets: l,
      popperEscapeOffsets: p,
      isReferenceHidden: u,
      hasPopperEscaped: _
    }, t2.attributes.popper = Object.assign({}, t2.attributes.popper, {
      "data-popper-reference-hidden": u,
      "data-popper-escaped": _
    });
  }
  var xc = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: wd
  };
  function kd(s, t2, e) {
    var i = Tt(s), n = [J, Q].indexOf(i) >= 0 ? -1 : 1, o = typeof e == "function" ? e(Object.assign({}, t2, {
      placement: s
    })) : e, r = o[0], a = o[1];
    return r = r || 0, a = (a || 0) * n, [J, ut].indexOf(i) >= 0 ? {
      x: a,
      y: r
    } : {
      x: r,
      y: a
    };
  }
  function xd(s) {
    var t2 = s.state, e = s.options, i = s.name, n = e.offset, o = n === void 0 ? [0, 0] : n, r = Qo.reduce(function(u, _) {
      return u[_] = kd(_, t2.rects, o), u;
    }, {}), a = r[t2.placement], l = a.x, p = a.y;
    t2.modifiersData.popperOffsets != null && (t2.modifiersData.popperOffsets.x += l, t2.modifiersData.popperOffsets.y += p), t2.modifiersData[i] = r;
  }
  var Oc = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: xd
  };
  function Od(s) {
    var t2 = s.state, e = s.name;
    t2.modifiersData[e] = wc({
      reference: t2.rects.reference,
      element: t2.rects.popper,
      strategy: "absolute",
      placement: t2.placement
    });
  }
  var lr = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: Od,
    data: {}
  };
  function Sd(s) {
    return s === "x" ? "y" : "x";
  }
  function Id(s) {
    var t2 = s.state, e = s.options, i = s.name, n = e.mainAxis, o = n === void 0 ? true : n, r = e.altAxis, a = r === void 0 ? false : r, l = e.boundary, p = e.rootBoundary, u = e.altBoundary, _ = e.padding, f = e.tether, g = f === void 0 ? true : f, m = e.tetherOffset, b = m === void 0 ? 0 : m, v = Ge(t2, {
      boundary: l,
      rootBoundary: p,
      padding: _,
      altBoundary: u
    }), C2 = Tt(t2.placement), w = Xe(t2.placement), E = !w, T = ir(C2), A = Sd(T), k = t2.modifiersData.popperOffsets, I = t2.rects.reference, O = t2.rects.popper, x = typeof b == "function" ? b(Object.assign({}, t2.rects, {
      placement: t2.placement
    })) : b, L = typeof x == "number" ? {
      mainAxis: x,
      altAxis: x
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, x), S = t2.modifiersData.offset ? t2.modifiersData.offset[t2.placement] : null, N = {
      x: 0,
      y: 0
    };
    if (k) {
      if (o) {
        var P, tt = T === "y" ? Q : J, et2 = T === "y" ? dt : ut, U = T === "y" ? "height" : "width", bt = k[T], Gi = bt + v[tt], se = bt - v[et2], qi = g ? -O[U] / 2 : 0, mn = w === Te ? I[U] : O[U], oi = w === Te ? -O[U] : -I[U], Zi = t2.elements.arrow, ye = g && Zi ? er(Zi) : {
          width: 0,
          height: 0
        }, Ht = t2.modifiersData["arrow#persistent"] ? t2.modifiersData["arrow#persistent"].padding : Tc(), ri = Ht[tt], Qi = Ht[et2], ne = Si(0, I[U], ye[U]), gn = E ? I[U] / 2 - qi - ne - ri - L.mainAxis : mn - ne - ri - L.mainAxis, Lh = E ? -I[U] / 2 + qi + ne + Qi + L.mainAxis : oi + ne + Qi + L.mainAxis, bn2 = t2.elements.arrow && Vi(t2.elements.arrow), Nh = bn2 ? T === "y" ? bn2.clientTop || 0 : bn2.clientLeft || 0 : 0, br = (P = S == null ? void 0 : S[T]) != null ? P : 0, Mh = bt + gn - br - Nh, Rh = bt + Lh - br, vr = Si(g ? sn(Gi, Mh) : Gi, bt, g ? be(se, Rh) : se);
        k[T] = vr, N[T] = vr - bt;
      }
      if (a) {
        var Tr, Ph = T === "x" ? Q : J, Bh = T === "x" ? dt : ut, oe = k[A], Ji = A === "y" ? "height" : "width", Er = oe + v[Ph], Cr = oe - v[Bh], vn = [Q, J].indexOf(C2) !== -1, Ar = (Tr = S == null ? void 0 : S[A]) != null ? Tr : 0, yr = vn ? Er : oe - I[Ji] - O[Ji] - Ar + L.altAxis, wr = vn ? oe + I[Ji] + O[Ji] - Ar - L.altAxis : Cr, kr = g && vn ? ad(yr, oe, wr) : Si(g ? yr : Er, oe, g ? wr : Cr);
        k[A] = kr, N[A] = kr - oe;
      }
      t2.modifiersData[i] = N;
    }
  }
  var Sc = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: Id,
    requiresIfExists: ["offset"]
  };
  function Dd(s) {
    return {
      scrollLeft: s.scrollLeft,
      scrollTop: s.scrollTop
    };
  }
  function $d(s) {
    return s === pt(s) || !ht(s) ? or7(s) : Dd(s);
  }
  function Ld(s) {
    var t2 = s.getBoundingClientRect(), e = ze(t2.width) / s.offsetWidth || 1, i = ze(t2.height) / s.offsetHeight || 1;
    return e !== 1 || i !== 1;
  }
  function Nd(s, t2, e) {
    e === void 0 && (e = false);
    var i = ht(t2), n = ht(t2) && Ld(t2), o = ee(t2), r = Ue(s, n, e), a = {
      scrollLeft: 0,
      scrollTop: 0
    }, l = {
      x: 0,
      y: 0
    };
    return (i || !i && !e) && ((Mt(t2) !== "body" || ar2(o)) && (a = $d(t2)), ht(t2) ? (l = Ue(t2, true), l.x += t2.clientLeft, l.y += t2.clientTop) : o && (l.x = rr(o))), {
      x: r.left + a.scrollLeft - l.x,
      y: r.top + a.scrollTop - l.y,
      width: r.width,
      height: r.height
    };
  }
  function Md(s) {
    var t2 = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), i = [];
    s.forEach(function(o) {
      t2.set(o.name, o);
    });
    function n(o) {
      e.add(o.name);
      var r = [].concat(o.requires || [], o.requiresIfExists || []);
      r.forEach(function(a) {
        if (!e.has(a)) {
          var l = t2.get(a);
          l && n(l);
        }
      }), i.push(o);
    }
    return s.forEach(function(o) {
      e.has(o.name) || n(o);
    }), i;
  }
  function Rd(s) {
    var t2 = Md(s);
    return en2.reduce(function(e, i) {
      return e.concat(t2.filter(function(n) {
        return n.phase === i;
      }));
    }, []);
  }
  function Pd(s) {
    var t2;
    return function() {
      return t2 || (t2 = new Promise(function(e) {
        Promise.resolve().then(function() {
          t2 = void 0, e(s());
        });
      })), t2;
    };
  }
  function Vt(s) {
    for (var t2 = arguments.length, e = new Array(t2 > 1 ? t2 - 1 : 0), i = 1; i < t2; i++)
      e[i - 1] = arguments[i];
    return [].concat(e).reduce(function(n, o) {
      return n.replace(/%s/, o);
    }, s);
  }
  var ae = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var Bd = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var Mr = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function Hd(s) {
    s.forEach(function(t2) {
      [].concat(Object.keys(t2), Mr).filter(function(e, i, n) {
        return n.indexOf(e) === i;
      }).forEach(function(e) {
        switch (e) {
          case "name":
            typeof t2.name != "string" && console.error(Vt(ae, String(t2.name), '"name"', '"string"', '"' + String(t2.name) + '"'));
            break;
          case "enabled":
            typeof t2.enabled != "boolean" && console.error(Vt(ae, t2.name, '"enabled"', '"boolean"', '"' + String(t2.enabled) + '"'));
            break;
          case "phase":
            en2.indexOf(t2.phase) < 0 && console.error(Vt(ae, t2.name, '"phase"', "either " + en2.join(", "), '"' + String(t2.phase) + '"'));
            break;
          case "fn":
            typeof t2.fn != "function" && console.error(Vt(ae, t2.name, '"fn"', '"function"', '"' + String(t2.fn) + '"'));
            break;
          case "effect":
            t2.effect != null && typeof t2.effect != "function" && console.error(Vt(ae, t2.name, '"effect"', '"function"', '"' + String(t2.fn) + '"'));
            break;
          case "requires":
            t2.requires != null && !Array.isArray(t2.requires) && console.error(Vt(ae, t2.name, '"requires"', '"array"', '"' + String(t2.requires) + '"'));
            break;
          case "requiresIfExists":
            Array.isArray(t2.requiresIfExists) || console.error(Vt(ae, t2.name, '"requiresIfExists"', '"array"', '"' + String(t2.requiresIfExists) + '"'));
            break;
          case "options":
          case "data":
            break;
          default:
            console.error('PopperJS: an invalid property has been provided to the "' + t2.name + '" modifier, valid properties are ' + Mr.map(function(i) {
              return '"' + i + '"';
            }).join(", ") + '; but "' + e + '" was provided.');
        }
        t2.requires && t2.requires.forEach(function(i) {
          s.find(function(n) {
            return n.name === i;
          }) == null && console.error(Vt(Bd, String(t2.name), i, i));
        });
      });
    });
  }
  function Vd(s, t2) {
    var e = /* @__PURE__ */ new Set();
    return s.filter(function(i) {
      var n = t2(i);
      if (!e.has(n))
        return e.add(n), true;
    });
  }
  function Wd(s) {
    var t2 = s.reduce(function(e, i) {
      var n = e[i.name];
      return e[i.name] = n ? Object.assign({}, n, i, {
        options: Object.assign({}, n.options, i.options),
        data: Object.assign({}, n.data, i.data)
      }) : i, e;
    }, {});
    return Object.keys(t2).map(function(e) {
      return t2[e];
    });
  }
  var Rr = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
  var Fd = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
  var Pr = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function Br() {
    for (var s = arguments.length, t2 = new Array(s), e = 0; e < s; e++)
      t2[e] = arguments[e];
    return !t2.some(function(i) {
      return !(i && typeof i.getBoundingClientRect == "function");
    });
  }
  function an(s) {
    s === void 0 && (s = {});
    var t2 = s, e = t2.defaultModifiers, i = e === void 0 ? [] : e, n = t2.defaultOptions, o = n === void 0 ? Pr : n;
    return function(a, l, p) {
      p === void 0 && (p = o);
      var u = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, Pr, o),
        modifiersData: {},
        elements: {
          reference: a,
          popper: l
        },
        attributes: {},
        styles: {}
      }, _ = [], f = false, g = {
        state: u,
        setOptions: function(C2) {
          var w = typeof C2 == "function" ? C2(u.options) : C2;
          b(), u.options = Object.assign({}, o, u.options, w), u.scrollParents = {
            reference: Ee(a) ? Ii(a) : a.contextElement ? Ii(a.contextElement) : [],
            popper: Ii(l)
          };
          var E = Rd(Wd([].concat(i, u.options.modifiers)));
          if (u.orderedModifiers = E.filter(function(S) {
            return S.enabled;
          }), {}.NODE_ENV !== "production") {
            var T = Vd([].concat(E, u.options.modifiers), function(S) {
              var N = S.name;
              return N;
            });
            if (Hd(T), Tt(u.options.placement) === Hi) {
              var A = u.orderedModifiers.find(function(S) {
                var N = S.name;
                return N === "flip";
              });
              A || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
            var k = Ct(l), I = k.marginTop, O = k.marginRight, x = k.marginBottom, L = k.marginLeft;
            [I, O, x, L].some(function(S) {
              return parseFloat(S);
            }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
          return m(), g.update();
        },
        forceUpdate: function() {
          if (!f) {
            var C2 = u.elements, w = C2.reference, E = C2.popper;
            if (!Br(w, E)) {
              ({}).NODE_ENV !== "production" && console.error(Rr);
              return;
            }
            u.rects = {
              reference: Nd(w, Vi(E), u.options.strategy === "fixed"),
              popper: er(E)
            }, u.reset = false, u.placement = u.options.placement, u.orderedModifiers.forEach(function(S) {
              return u.modifiersData[S.name] = Object.assign({}, S.data);
            });
            for (var T = 0, A = 0; A < u.orderedModifiers.length; A++) {
              if ({}.NODE_ENV !== "production" && (T += 1, T > 100)) {
                console.error(Fd);
                break;
              }
              if (u.reset === true) {
                u.reset = false, A = -1;
                continue;
              }
              var k = u.orderedModifiers[A], I = k.fn, O = k.options, x = O === void 0 ? {} : O, L = k.name;
              typeof I == "function" && (u = I({
                state: u,
                options: x,
                name: L,
                instance: g
              }) || u);
            }
          }
        },
        update: Pd(function() {
          return new Promise(function(v) {
            g.forceUpdate(), v(u);
          });
        }),
        destroy: function() {
          b(), f = true;
        }
      };
      if (!Br(a, l))
        return {}.NODE_ENV !== "production" && console.error(Rr), g;
      g.setOptions(p).then(function(v) {
        !f && p.onFirstUpdate && p.onFirstUpdate(v);
      });
      function m() {
        u.orderedModifiers.forEach(function(v) {
          var C2 = v.name, w = v.options, E = w === void 0 ? {} : w, T = v.effect;
          if (typeof T == "function") {
            var A = T({
              state: u,
              name: C2,
              instance: g,
              options: E
            }), k = function() {
            };
            _.push(A || k);
          }
        });
      }
      function b() {
        _.forEach(function(v) {
          return v();
        }), _ = [];
      }
      return g;
    };
  }
  var Yd = /* @__PURE__ */ an();
  var jd = [nr, lr, sr2, tr2];
  var Kd = /* @__PURE__ */ an({
    defaultModifiers: jd
  });
  var zd = [nr, lr, sr2, tr2, Oc, kc, Sc, Ac, xc];
  var Ce = /* @__PURE__ */ an({
    defaultModifiers: zd
  });
  var Ic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    afterMain: _c,
    afterRead: dc,
    afterWrite: gc,
    applyStyles: tr2,
    arrow: Ac,
    auto: Hi,
    basePlacements: ti,
    beforeMain: uc,
    beforeRead: cc,
    beforeWrite: fc,
    bottom: dt,
    clippingParents: ac,
    computeStyles: sr2,
    createPopper: Ce,
    createPopperBase: Yd,
    createPopperLite: Kd,
    detectOverflow: Ge,
    end: Ke,
    eventListeners: nr,
    flip: kc,
    hide: xc,
    left: J,
    main: pc,
    modifierPhases: en2,
    offset: Oc,
    placements: Qo,
    popper: $e,
    popperGenerator: an,
    popperOffsets: lr,
    preventOverflow: Sc,
    read: hc,
    reference: lc,
    right: ut,
    start: Te,
    top: Q,
    variationPlacements: So,
    viewport: Zo,
    write: mc
  }, Symbol.toStringTag, { value: "Module" }));
  function An(s) {
    return s === "true" ? true : s === "false" ? false : s === Number(s).toString() ? Number(s) : s === "" || s === "null" ? null : s;
  }
  function yn(s) {
    return s.replace(/[A-Z]/g, (t2) => `-${t2.toLowerCase()}`);
  }
  var h = {
    setDataAttribute(s, t2, e) {
      s.setAttribute(`data-te-${yn(t2)}`, e);
    },
    removeDataAttribute(s, t2) {
      s.removeAttribute(`data-te-${yn(t2)}`);
    },
    getDataAttributes(s) {
      if (!s)
        return {};
      const t2 = {};
      return Object.keys(s.dataset).filter((e) => e.startsWith("te")).forEach((e) => {
        if (e.startsWith("teClass"))
          return;
        let i = e.replace(/^te/, "");
        i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t2[i] = An(s.dataset[e]);
      }), t2;
    },
    getDataClassAttributes(s) {
      if (!s)
        return {};
      const t2 = __spreadValues({}, s.dataset);
      return Object.keys(t2).filter((e) => e.startsWith("teClass")).forEach((e) => {
        let i = e.replace(/^teClass/, "");
        i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t2[i] = An(t2[e]);
      }), t2;
    },
    getDataAttribute(s, t2) {
      return An(s.getAttribute(`data-te-${yn(t2)}`));
    },
    offset(s) {
      const t2 = s.getBoundingClientRect();
      return {
        top: t2.top + document.body.scrollTop,
        left: t2.left + document.body.scrollLeft
      };
    },
    position(s) {
      return {
        top: s.offsetTop,
        left: s.offsetLeft
      };
    },
    style(s, t2) {
      Object.assign(s.style, t2);
    },
    toggleClass(s, t2) {
      s && wn(t2).forEach((e) => {
        s.classList.contains(e) ? s.classList.remove(e) : s.classList.add(e);
      });
    },
    addClass(s, t2) {
      wn(t2).forEach((e) => !s.classList.contains(e) && s.classList.add(e));
    },
    addStyle(s, t2) {
      Object.keys(t2).forEach((e) => {
        s.style[e] = t2[e];
      });
    },
    removeClass(s, t2) {
      wn(t2).forEach((e) => s.classList.contains(e) && s.classList.remove(e));
    },
    hasClass(s, t2) {
      return s.classList.contains(t2);
    },
    maxOffset(s) {
      const t2 = s.getBoundingClientRect();
      return {
        top: t2.top + Math.max(document.body.scrollTop, document.documentElement.scrollTop, window.scrollY),
        left: t2.left + Math.max(document.body.scrollLeft, document.documentElement.scrollLeft, window.scrollX)
      };
    }
  };
  function wn(s) {
    return typeof s == "string" ? s.split(" ") : Array.isArray(s) ? s : false;
  }
  var Ud = 3;
  var d = {
    closest(s, t2) {
      return s.closest(t2);
    },
    matches(s, t2) {
      return s.matches(t2);
    },
    find(s, t2 = document.documentElement) {
      return [].concat(...Element.prototype.querySelectorAll.call(t2, s));
    },
    findOne(s, t2 = document.documentElement) {
      return Element.prototype.querySelector.call(t2, s);
    },
    children(s, t2) {
      return [].concat(...s.children).filter((i) => i.matches(t2));
    },
    parents(s, t2) {
      const e = [];
      let i = s.parentNode;
      for (; i && i.nodeType === Node.ELEMENT_NODE && i.nodeType !== Ud; )
        this.matches(i, t2) && e.push(i), i = i.parentNode;
      return e;
    },
    prev(s, t2) {
      let e = s.previousElementSibling;
      for (; e; ) {
        if (e.matches(t2))
          return [e];
        e = e.previousElementSibling;
      }
      return [];
    },
    next(s, t2) {
      let e = s.nextElementSibling;
      for (; e; ) {
        if (this.matches(e, t2))
          return [e];
        e = e.nextElementSibling;
      }
      return [];
    },
    focusableChildren(s) {
      const t2 = [
        "a",
        "button",
        "input",
        "textarea",
        "select",
        "details",
        "[tabindex]",
        '[contenteditable="true"]'
      ].map((e) => `${e}:not([tabindex^="-"])`).join(", ");
      return this.find(t2, s).filter((e) => !ge(e) && Nt(e));
    }
  };
  var Xd = "te.dropdown";
  var Ae = `.${Xd}`;
  var cr = ".data-api";
  var Rs = "Escape";
  var $o = "ArrowUp";
  var Ps = "ArrowDown";
  var qd = new RegExp(`${$o}|${Ps}|${Rs}`);
  var Zd = `hide${Ae}`;
  var Qd = `hidden${Ae}`;
  var Jd = `show${Ae}`;
  var tu = `shown${Ae}`;
  var eu = `click${Ae}${cr}`;
  var Wr = `keydown${Ae}${cr}`;
  var iu = `keyup${Ae}${cr}`;
  var cu = F() ? "top-end" : "top-start";
  var hu2 = F() ? "top-start" : "top-end";
  var du = F() ? "bottom-end" : "bottom-start";
  var uu = F() ? "bottom-start" : "bottom-end";
  var pu = F() ? "left-start" : "right-start";
  var _u = F() ? "right-start" : "left-start";
  var Dc = "te.collapse";
  var ln = `.${Dc}`;
  var Tu = `show${ln}`;
  var Eu = `shown${ln}`;
  var Cu = `hide${ln}`;
  var Au = `hidden${ln}`;
  var Me = "data-te-collapse-item";
  var jr = `:scope [${Me}] [${Me}]`;
  var $c = "backdrop";
  var Xr = `mousedown.te.${$c}`;
  var $u = "te.offcanvas";
  var ei = `.${$u}`;
  var Lu = ".data-api";
  var Nu = `load${ei}${Lu}`;
  var Bu = `show${ei}`;
  var Hu = `shown${ei}`;
  var Vu = `hide${ei}`;
  var Wu = `hidden${ei}`;
  var Fu = `keydown.dismiss${ei}`;
  var Yu = "te.alert";
  var Lc = `.${Yu}`;
  var ju = `close${Lc}`;
  var Ku = `closed${Lc}`;
  var Gu = "te.carousel";
  var _t = `.${Gu}`;
  var Nc = ".data-api";
  var qu = "ArrowLeft";
  var Zu = "ArrowRight";
  var _e = "left";
  var mi2 = "right";
  var sp = {
    [qu]: mi2,
    [Zu]: _e
  };
  var np = `slide${_t}`;
  var $n = `slid${_t}`;
  var op = `keydown${_t}`;
  var rp = `mouseenter${_t}`;
  var ap = `mouseleave${_t}`;
  var lp = `touchstart${_t}`;
  var cp = `touchmove${_t}`;
  var hp = `touchend${_t}`;
  var dp = `pointerdown${_t}`;
  var up = `pointerup${_t}`;
  var pp = `dragstart${_t}`;
  var _p = `load${_t}${Nc}`;
  var fp = `click${_t}${Nc}`;
  var Mc = "[data-te-carousel-active]";
  var dr = "[data-te-carousel-item]";
  var we = `${Mc}${dr}`;
  var Ep = `${dr} img`;
  var Op = "te.modal";
  var At = `.${Op}`;
  var $p = `hide${At}`;
  var Lp = `hidePrevented${At}`;
  var Np = `hidden${At}`;
  var Mp = `show${At}`;
  var Rp = `shown${At}`;
  var na = `resize${At}`;
  var oa = `click.dismiss${At}`;
  var ra = `keydown.dismiss${At}`;
  var Pp = `mouseup.dismiss${At}`;
  var aa = `mousedown.dismiss${At}`;
  var Hp = /* @__PURE__ */ new Set([
    "background",
    "cite",
    "href",
    "itemtype",
    "longdesc",
    "poster",
    "src",
    "xlink:href"
  ]);
  var Vp = /^aria-[\w-]*$/i;
  var Wp = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
  var Fp = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
  var Yp = (s, t2) => {
    const e = s.nodeName.toLowerCase();
    if (t2.includes(e))
      return Hp.has(e) ? !!(Wp.test(s.nodeValue) || Fp.test(s.nodeValue)) : true;
    const i = t2.filter((n) => n instanceof RegExp);
    for (let n = 0, o = i.length; n < o; n++)
      if (i[n].test(e))
        return true;
    return false;
  };
  var jp = {
    "*": ["class", "dir", "id", "lang", "role", Vp],
    a: ["target", "href", "title", "rel"],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ["src", "srcset", "alt", "title", "width", "height"],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  };
  function ha(s, t2, e) {
    if (!s.length)
      return s;
    if (e && typeof e == "function")
      return e(s);
    const n = new window.DOMParser().parseFromString(s, "text/html"), o = [].concat(...n.body.querySelectorAll("*"));
    for (let r = 0, a = o.length; r < a; r++) {
      const l = o[r], p = l.nodeName.toLowerCase();
      if (!Object.keys(t2).includes(p)) {
        l.remove();
        continue;
      }
      const u = [].concat(...l.attributes), _ = [].concat(t2["*"] || [], t2[p] || []);
      u.forEach((f) => {
        Yp(f, _) || l.removeAttribute(f.nodeName);
      });
    }
    return n.body.innerHTML;
  }
  var da2 = "tooltip";
  var Kp = "te.tooltip";
  var wt = `.${Kp}`;
  var zp = "te-tooltip";
  var Up = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]);
  var Xp = {
    animation: "boolean",
    template: "string",
    title: "(string|element|function)",
    trigger: "string",
    delay: "(number|object)",
    html: "boolean",
    selector: "(string|boolean)",
    placement: "(string|function)",
    offset: "(array|string|function)",
    container: "(string|element|boolean)",
    fallbackPlacements: "array",
    boundary: "(string|element)",
    customClass: "(string|function)",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    allowList: "object",
    popperConfig: "(null|object|function)"
  };
  var Gp = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: F() ? "left" : "right",
    BOTTOM: "bottom",
    LEFT: F() ? "right" : "left"
  };
  var qp = {
    animation: true,
    template: '<div class="opacity-0 transition-opacity duration-300 ease-in-out absolute z-[1080] block m-0 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal" role="tooltip"><div data-te-tooltip-inner-ref class="tooltip-inner max-w-[200px] text-sm py-1.5 px-4 text-white text-center bg-[#6d6d6d] rounded"></div></div>',
    trigger: "hover focus",
    title: "",
    delay: 0,
    html: false,
    selector: false,
    placement: "top",
    offset: [0, 0],
    container: false,
    fallbackPlacements: ["top", "right", "bottom", "left"],
    boundary: "clippingParents",
    customClass: "",
    sanitize: true,
    sanitizeFn: null,
    allowList: jp,
    popperConfig: { hide: true }
  };
  var Zp = {
    HIDE: `hide${wt}`,
    HIDDEN: `hidden${wt}`,
    SHOW: `show${wt}`,
    SHOWN: `shown${wt}`,
    INSERTED: `inserted${wt}`,
    CLICK: `click${wt}`,
    FOCUSIN: `focusin${wt}`,
    FOCUSOUT: `focusout${wt}`,
    MOUSEENTER: `mouseenter${wt}`,
    MOUSELEAVE: `mouseleave${wt}`
  };
  var Qp = "fade";
  var Jp = "modal";
  var Mn = "show";
  var ci = "show";
  var Rn = "out";
  var ua = ".tooltip-inner";
  var pa = `.${Jp}`;
  var _a2 = "hide.te.modal";
  var hi2 = "hover";
  var Pn = "focus";
  var t_ = "click";
  var e_ = "manual";
  var ii = class extends gt {
    constructor(t2, e) {
      if (typeof Ic > "u")
        throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
      super(t2), this._isEnabled = true, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners();
    }
    static get Default() {
      return qp;
    }
    static get NAME() {
      return da2;
    }
    static get Event() {
      return Zp;
    }
    static get DefaultType() {
      return Xp;
    }
    enable() {
      this._isEnabled = true;
    }
    disable() {
      this._isEnabled = false;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle(t2) {
      if (this._isEnabled)
        if (t2) {
          const e = this._initializeOnDelegatedTarget(t2);
          e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);
        } else {
          if (this.getTipElement().classList.contains(Mn)) {
            this._leave(null, this);
            return;
          }
          this._enter(null, this);
        }
    }
    dispose() {
      clearTimeout(this._timeout), c.off(this._element.closest(pa), _a2, this._hideModalHandler), this.tip && this.tip.remove(), this._disposePopper(), super.dispose();
    }
    show() {
      if (this._element.style.display === "none")
        throw new Error("Please use show on visible elements");
      if (!(this.isWithContent() && this._isEnabled))
        return;
      const t2 = c.trigger(this._element, this.constructor.Event.SHOW), e = Gl(this._element), i = e === null ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);
      if (t2.defaultPrevented || !i)
        return;
      this.constructor.NAME === "tooltip" && this.tip && this.getTitle() !== this.tip.querySelector(ua).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null);
      const n = this.getTipElement(), o = rt(this.constructor.NAME);
      n.setAttribute("id", o), this._element.setAttribute("aria-describedby", o), this._config.animation && setTimeout(() => {
        this.tip.classList.add("opacity-100"), this.tip.classList.remove("opacity-0");
      }, 100);
      const r = typeof this._config.placement == "function" ? this._config.placement.call(this, n, this._element) : this._config.placement, a = this._getAttachment(r);
      this._addAttachmentClass(a);
      const { container: l } = this._config;
      if (y.setData(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l.append(n), c.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = Ce(this._element, n, this._getPopperConfig(a)), n.getAttribute("id").includes("tooltip"))
        switch (r) {
          case "bottom":
            n.classList.add("py-[0.4rem]");
            break;
          case "left":
            n.classList.add("px-[0.4rem]");
            break;
          case "right":
            n.classList.add("px-[0.4rem]");
            break;
          default:
            n.classList.add("py-[0.4rem]");
            break;
        }
      const u = this._resolvePossibleFunction(this._config.customClass);
      u && n.classList.add(...u.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((g) => {
        c.on(g, "mouseover", tn2);
      });
      const _ = () => {
        const g = this._hoverState;
        this._hoverState = null, c.trigger(this._element, this.constructor.Event.SHOWN), g === Rn && this._leave(null, this);
      }, f = this.tip.classList.contains("transition-opacity");
      this._queueCallback(_, this.tip, f);
    }
    hide() {
      if (!this._popper)
        return;
      const t2 = this.getTipElement(), e = () => {
        this._isWithActiveTrigger() || (this._hoverState !== ci && t2.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), c.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper());
      };
      if (c.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented)
        return;
      t2.classList.add("opacity-0"), t2.classList.remove("opacity-100"), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((o) => c.off(o, "mouseover", tn2)), this._activeTrigger[t_] = false, this._activeTrigger[Pn] = false, this._activeTrigger[hi2] = false;
      const n = this.tip.classList.contains("opacity-0");
      this._queueCallback(e, this.tip, n), this._hoverState = "";
    }
    update() {
      this._popper !== null && this._popper.update();
    }
    isWithContent() {
      return !!this.getTitle();
    }
    getTipElement() {
      if (this.tip)
        return this.tip;
      const t2 = document.createElement("div");
      t2.innerHTML = this._config.template;
      const e = t2.children[0];
      return this.setContent(e), e.classList.remove(Qp, Mn), this.tip = e, this.tip;
    }
    setContent(t2) {
      this._sanitizeAndSetContent(t2, this.getTitle(), ua);
    }
    _sanitizeAndSetContent(t2, e, i) {
      const n = d.findOne(i, t2);
      if (!e && n) {
        n.remove();
        return;
      }
      this.setElementContent(n, e);
    }
    setElementContent(t2, e) {
      if (t2 !== null) {
        if (je(e)) {
          e = te2(e), this._config.html ? e.parentNode !== t2 && (t2.innerHTML = "", t2.append(e)) : t2.textContent = e.textContent;
          return;
        }
        this._config.html ? (this._config.sanitize && (e = ha(e, this._config.allowList, this._config.sanitizeFn)), t2.innerHTML = e) : t2.textContent = e;
      }
    }
    getTitle() {
      const t2 = this._element.getAttribute("data-te-original-title") || this._config.title;
      return this._resolvePossibleFunction(t2);
    }
    updateAttachment(t2) {
      return t2 === "right" ? "end" : t2 === "left" ? "start" : t2;
    }
    _initializeOnDelegatedTarget(t2, e) {
      return e || this.constructor.getOrCreateInstance(t2.delegateTarget, this._getDelegateConfig());
    }
    _getOffset() {
      const { offset: t2 } = this._config;
      return typeof t2 == "string" ? t2.split(",").map((e) => Number.parseInt(e, 10)) : typeof t2 == "function" ? (e) => t2(e, this._element) : t2;
    }
    _resolvePossibleFunction(t2) {
      return typeof t2 == "function" ? t2.call(this._element) : t2;
    }
    _getPopperConfig(t2) {
      const e = {
        placement: t2,
        modifiers: [
          {
            name: "flip",
            options: {
              fallbackPlacements: this._config.fallbackPlacements
            }
          },
          {
            name: "offset",
            options: {
              offset: this._getOffset()
            }
          },
          {
            name: "preventOverflow",
            options: {
              boundary: this._config.boundary
            }
          },
          {
            name: "arrow",
            options: {
              element: `.${this.constructor.NAME}-arrow`
            }
          },
          {
            name: "onChange",
            enabled: true,
            phase: "afterWrite",
            fn: (i) => this._handlePopperPlacementChange(i)
          }
        ],
        onFirstUpdate: (i) => {
          i.options.placement !== i.placement && this._handlePopperPlacementChange(i);
        }
      };
      return __spreadValues(__spreadValues({}, e), typeof this._config.popperConfig == "function" ? this._config.popperConfig(e) : this._config.popperConfig);
    }
    _addAttachmentClass(t2) {
      this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(t2)}`);
    }
    _getAttachment(t2) {
      return Gp[t2.toUpperCase()];
    }
    _setListeners() {
      this._config.trigger.split(" ").forEach((e) => {
        if (e === "click")
          c.on(this._element, this.constructor.Event.CLICK, this._config.selector, (i) => this.toggle(i));
        else if (e !== e_) {
          const i = e === hi2 ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, n = e === hi2 ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
          c.on(this._element, i, this._config.selector, (o) => this._enter(o)), c.on(this._element, n, this._config.selector, (o) => this._leave(o));
        }
      }), this._hideModalHandler = () => {
        this._element && this.hide();
      }, c.on(this._element.closest(pa), _a2, this._hideModalHandler), this._config.selector ? this._config = __spreadProps(__spreadValues({}, this._config), {
        trigger: "manual",
        selector: ""
      }) : this._fixTitle();
    }
    _fixTitle() {
      const t2 = this._element.getAttribute("title"), e = typeof this._element.getAttribute("data-te-original-title");
      (t2 || e !== "string") && (this._element.setAttribute("data-te-original-title", t2 || ""), t2 && !this._element.getAttribute("aria-label") && !this._element.textContent && this._element.setAttribute("aria-label", t2), this._element.setAttribute("title", ""));
    }
    _enter(t2, e) {
      if (e = this._initializeOnDelegatedTarget(t2, e), t2 && (e._activeTrigger[t2.type === "focusin" ? Pn : hi2] = true), e.getTipElement().classList.contains(Mn) || e._hoverState === ci) {
        e._hoverState = ci;
        return;
      }
      if (clearTimeout(e._timeout), e._hoverState = ci, !e._config.delay || !e._config.delay.show) {
        e.show();
        return;
      }
      e._timeout = setTimeout(() => {
        e._hoverState === ci && e.show();
      }, e._config.delay.show);
    }
    _leave(t2, e) {
      if (e = this._initializeOnDelegatedTarget(t2, e), t2 && (e._activeTrigger[t2.type === "focusout" ? Pn : hi2] = e._element.contains(t2.relatedTarget)), !e._isWithActiveTrigger()) {
        if (clearTimeout(e._timeout), e._hoverState = Rn, !e._config.delay || !e._config.delay.hide) {
          e.hide();
          return;
        }
        e._timeout = setTimeout(() => {
          e._hoverState === Rn && e.hide();
        }, e._config.delay.hide);
      }
    }
    _isWithActiveTrigger() {
      for (const t2 in this._activeTrigger)
        if (this._activeTrigger[t2])
          return true;
      return false;
    }
    _getConfig(t2) {
      const e = h.getDataAttributes(this._element);
      return Object.keys(e).forEach((i) => {
        Up.has(i) && delete e[i];
      }), t2 = __spreadValues(__spreadValues(__spreadValues({}, this.constructor.Default), e), typeof t2 == "object" && t2 ? t2 : {}), t2.container = t2.container === false ? document.body : te2(t2.container), typeof t2.delay == "number" && (t2.delay = {
        show: t2.delay,
        hide: t2.delay
      }), typeof t2.title == "number" && (t2.title = t2.title.toString()), typeof t2.content == "number" && (t2.content = t2.content.toString()), D(da2, t2, this.constructor.DefaultType), t2.sanitize && (t2.template = ha(t2.template, t2.allowList, t2.sanitizeFn)), t2;
    }
    _getDelegateConfig() {
      const t2 = {};
      for (const e in this._config)
        this.constructor.Default[e] !== this._config[e] && (t2[e] = this._config[e]);
      return t2;
    }
    _cleanTipClass() {
      const t2 = this.getTipElement(), e = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, "g"), i = t2.getAttribute("class").match(e);
      i !== null && i.length > 0 && i.map((n) => n.trim()).forEach((n) => t2.classList.remove(n));
    }
    _getBasicClassPrefix() {
      return zp;
    }
    _handlePopperPlacementChange(t2) {
      const { state: e } = t2;
      e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));
    }
    _disposePopper() {
      this._popper && (this._popper.destroy(), this._popper = null);
    }
    static jQueryInterface(t2) {
      return this.each(function() {
        const e = ii.getOrCreateInstance(this, t2);
        if (typeof t2 == "string") {
          if (typeof e[t2] > "u")
            throw new TypeError(`No method named "${t2}"`);
          e[t2]();
        }
      });
    }
  };
  var s_ = "te.popover";
  var kt = `.${s_}`;
  var o_ = __spreadProps(__spreadValues({}, ii.Default), {
    placement: "right",
    offset: [0, 8],
    trigger: "click",
    content: "",
    template: '<div class="opacity-0 transition-opacity duration-150 ease-in-out absolute top-0 left-0 z-[1070] block max-w-[267px] break-words bg-white bg-clip-padding border border-neutral-100 rounded-lg shadow-[0_0px_3px_0_rgba(0,0,0,0.07),0_2px_2px_0_rgba(0,0,0,0.04)] text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal dark:bg-neutral-700 dark:border-0 dark:text-white data-[popper-reference-hidden]:hidden" role="tooltip"><h3 class="popover-header py-2 px-4 mb-0 border-b-2 border-neutral-100 rounded-t-lg font-medium empty:hidden dark:border-neutral-500"></h3><div class="popover-body p-4 text-[#212529] dark:text-white"></div></div>'
  });
  var r_ = __spreadProps(__spreadValues({}, ii.DefaultType), {
    content: "(string|element|function)"
  });
  var a_ = {
    HIDE: `hide${kt}`,
    HIDDEN: `hidden${kt}`,
    SHOW: `show${kt}`,
    SHOWN: `shown${kt}`,
    INSERTED: `inserted${kt}`,
    CLICK: `click${kt}`,
    FOCUSIN: `focusin${kt}`,
    FOCUSOUT: `focusout${kt}`,
    MOUSEENTER: `mouseenter${kt}`,
    MOUSELEAVE: `mouseleave${kt}`
  };
  var h_ = "te.scrollspy";
  var ur2 = `.${h_}`;
  var __ = `activate${ur2}`;
  var f_ = `scroll${ur2}`;
  var Pc = "[data-te-dropdown-item-ref]";
  var Mo = "[data-te-nav-link-ref]";
  var Bc = "[data-te-list-group-item-ref]";
  var Vn = `${Mo}, ${Bc}, ${Pc}`;
  var E_ = "te.tab";
  var hn = `.${E_}`;
  var C_ = `hide${hn}`;
  var A_ = `hidden${hn}`;
  var y_ = `show${hn}`;
  var w_ = `shown${hn}`;
  var Le = "data-te-tab-active";
  var Hs = "data-te-nav-active";
  var ba = `[${Le}]`;
  var S_ = `[${Hs}]`;
  var N_ = "te.toast";
  var ie3 = `.${N_}`;
  var M_ = `mouseover${ie3}`;
  var R_ = `mouseout${ie3}`;
  var P_ = `focusin${ie3}`;
  var B_ = `focusout${ie3}`;
  var H_ = `hide${ie3}`;
  var V_ = `hidden${ie3}`;
  var W_ = `show${ie3}`;
  var F_ = `shown${ie3}`;
  (() => {
    var s = { 454: (i, n, o) => {
      o.d(n, { Z: () => l });
      var r = o(645), a = o.n(r)()(function(p) {
        return p[1];
      });
      a.push([i.id, "INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}", ""]);
      const l = a;
    }, 645: (i) => {
      i.exports = function(n) {
        var o = [];
        return o.toString = function() {
          return this.map(function(r) {
            var a = n(r);
            return r[2] ? "@media ".concat(r[2], " {").concat(a, "}") : a;
          }).join("");
        }, o.i = function(r, a, l) {
          typeof r == "string" && (r = [[null, r, ""]]);
          var p = {};
          if (l)
            for (var u = 0; u < this.length; u++) {
              var _ = this[u][0];
              _ != null && (p[_] = true);
            }
          for (var f = 0; f < r.length; f++) {
            var g = [].concat(r[f]);
            l && p[g[0]] || (a && (g[2] ? g[2] = "".concat(a, " and ").concat(g[2]) : g[2] = a), o.push(g));
          }
        }, o;
      };
    }, 810: () => {
      (function() {
        if (typeof window < "u")
          try {
            var i = new window.CustomEvent("test", { cancelable: true });
            if (i.preventDefault(), i.defaultPrevented !== true)
              throw new Error("Could not prevent default");
          } catch (e2) {
            var n = function(r, a) {
              var l, p;
              return (a = a || {}).bubbles = !!a.bubbles, a.cancelable = !!a.cancelable, (l = document.createEvent("CustomEvent")).initCustomEvent(r, a.bubbles, a.cancelable, a.detail), p = l.preventDefault, l.preventDefault = function() {
                p.call(this);
                try {
                  Object.defineProperty(this, "defaultPrevented", { get: function() {
                    return true;
                  } });
                } catch (e3) {
                  this.defaultPrevented = true;
                }
              }, l;
            };
            n.prototype = window.Event.prototype, window.CustomEvent = n;
          }
      })();
    }, 379: (i, n, o) => {
      var r, a = function() {
        var E = {};
        return function(T) {
          if (E[T] === void 0) {
            var A = document.querySelector(T);
            if (window.HTMLIFrameElement && A instanceof window.HTMLIFrameElement)
              try {
                A = A.contentDocument.head;
              } catch (e2) {
                A = null;
              }
            E[T] = A;
          }
          return E[T];
        };
      }(), l = [];
      function p(E) {
        for (var T = -1, A = 0; A < l.length; A++)
          if (l[A].identifier === E) {
            T = A;
            break;
          }
        return T;
      }
      function u(E, T) {
        for (var A = {}, k = [], I = 0; I < E.length; I++) {
          var O = E[I], x = T.base ? O[0] + T.base : O[0], L = A[x] || 0, S = "".concat(x, " ").concat(L);
          A[x] = L + 1;
          var N = p(S), P = { css: O[1], media: O[2], sourceMap: O[3] };
          N !== -1 ? (l[N].references++, l[N].updater(P)) : l.push({ identifier: S, updater: w(P, T), references: 1 }), k.push(S);
        }
        return k;
      }
      function _(E) {
        var T = document.createElement("style"), A = E.attributes || {};
        if (A.nonce === void 0) {
          var k = o.nc;
          k && (A.nonce = k);
        }
        if (Object.keys(A).forEach(function(O) {
          T.setAttribute(O, A[O]);
        }), typeof E.insert == "function")
          E.insert(T);
        else {
          var I = a(E.insert || "head");
          if (!I)
            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
          I.appendChild(T);
        }
        return T;
      }
      var f, g = (f = [], function(E, T) {
        return f[E] = T, f.filter(Boolean).join(`
`);
      });
      function m(E, T, A, k) {
        var I = A ? "" : k.media ? "@media ".concat(k.media, " {").concat(k.css, "}") : k.css;
        if (E.styleSheet)
          E.styleSheet.cssText = g(T, I);
        else {
          var O = document.createTextNode(I), x = E.childNodes;
          x[T] && E.removeChild(x[T]), x.length ? E.insertBefore(O, x[T]) : E.appendChild(O);
        }
      }
      function b(E, T, A) {
        var k = A.css, I = A.media, O = A.sourceMap;
        if (I ? E.setAttribute("media", I) : E.removeAttribute("media"), O && typeof btoa < "u" && (k += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(O)))), " */")), E.styleSheet)
          E.styleSheet.cssText = k;
        else {
          for (; E.firstChild; )
            E.removeChild(E.firstChild);
          E.appendChild(document.createTextNode(k));
        }
      }
      var v = null, C2 = 0;
      function w(E, T) {
        var A, k, I;
        if (T.singleton) {
          var O = C2++;
          A = v || (v = _(T)), k = m.bind(null, A, O, false), I = m.bind(null, A, O, true);
        } else
          A = _(T), k = b.bind(null, A, T), I = function() {
            (function(x) {
              if (x.parentNode === null)
                return false;
              x.parentNode.removeChild(x);
            })(A);
          };
        return k(E), function(x) {
          if (x) {
            if (x.css === E.css && x.media === E.media && x.sourceMap === E.sourceMap)
              return;
            k(E = x);
          } else
            I();
        };
      }
      i.exports = function(E, T) {
        (T = T || {}).singleton || typeof T.singleton == "boolean" || (T.singleton = (r === void 0 && (r = !!(window && document && document.all && !window.atob)), r));
        var A = u(E = E || [], T);
        return function(k) {
          if (k = k || [], Object.prototype.toString.call(k) === "[object Array]") {
            for (var I = 0; I < A.length; I++) {
              var O = p(A[I]);
              l[O].references--;
            }
            for (var x = u(k, T), L = 0; L < A.length; L++) {
              var S = p(A[L]);
              l[S].references === 0 && (l[S].updater(), l.splice(S, 1));
            }
            A = x;
          }
        };
      };
    } }, t2 = {};
    function e(i) {
      var n = t2[i];
      if (n !== void 0)
        return n.exports;
      var o = t2[i] = { id: i, exports: {} };
      return s[i](o, o.exports, e), o.exports;
    }
    e.n = (i) => {
      var n = i && i.__esModule ? () => i.default : () => i;
      return e.d(n, { a: n }), n;
    }, e.d = (i, n) => {
      for (var o in n)
        e.o(n, o) && !e.o(i, o) && Object.defineProperty(i, o, { enumerable: true, get: n[o] });
    }, e.o = (i, n) => Object.prototype.hasOwnProperty.call(i, n), (() => {
      var i = e(379), n = e.n(i), o = e(454);
      function r(l) {
        if (!l.hasAttribute("autocompleted")) {
          l.setAttribute("autocompleted", "");
          var p = new window.CustomEvent("onautocomplete", { bubbles: true, cancelable: true, detail: null });
          l.dispatchEvent(p) || (l.value = "");
        }
      }
      function a(l) {
        l.hasAttribute("autocompleted") && (l.removeAttribute("autocompleted"), l.dispatchEvent(new window.CustomEvent("onautocomplete", { bubbles: true, cancelable: false, detail: null })));
      }
      n()(o.Z, { insert: "head", singleton: false }), o.Z.locals, e(810), document.addEventListener("animationstart", function(l) {
        l.animationName === "onautofillstart" ? r(l.target) : a(l.target);
      }, true), document.addEventListener("input", function(l) {
        l.inputType !== "insertReplacementText" && "data" in l ? a(l.target) : r(l.target);
      }, true);
    })();
  })();
  var Yn = "input";
  var os = "te.input";
  var Wc = "data-te-input-wrapper-init";
  var Fc = "data-te-input-notch-ref";
  var Yc = "data-te-input-notch-leading-ref";
  var jc = "data-te-input-notch-middle-ref";
  var z_ = "data-te-input-notch-trailing-ref";
  var U_ = "data-te-input-helper-ref";
  var X_ = "data-te-input-placeholder-active";
  var Ft = "data-te-input-state-active";
  var Ca = "data-te-input-focused";
  var Aa = "data-te-input-form-counter";
  var de2 = `[${Wc}] input`;
  var ue = `[${Wc}] textarea`;
  var ke = `[${Fc}]`;
  var ya = `[${Yc}]`;
  var wa = `[${jc}]`;
  var G_ = `[${U_}]`;
  var q_ = {
    inputFormWhite: false
  };
  var Z_ = {
    inputFormWhite: "(boolean)"
  };
  var Kc = {
    notch: "group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none",
    notchLeading: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0",
    notchLeadingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
    notchLeadingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[-1px_0_0_#ffffff,_0_1px_0_0_#ffffff,_0_-1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
    notchMiddle: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent",
    notchMiddleNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
    notchMiddleWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
    notchTrailing: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0",
    notchTrailingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
    notchTrailingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[1px_0_0_#ffffff,_0_-1px_0_0_#ffffff,_0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
    counter: "text-right leading-[1.6]"
  };
  var Q_ = {
    notch: "string",
    notchLeading: "string",
    notchLeadingNormal: "string",
    notchLeadingWhite: "string",
    notchMiddle: "string",
    notchMiddleNormal: "string",
    notchMiddleWhite: "string",
    notchTrailing: "string",
    notchTrailingNormal: "string",
    notchTrailingWhite: "string",
    counter: "string"
  };
  var V = class {
    constructor(t2, e, i) {
      this._config = this._getConfig(e, t2), this._element = t2, this._classes = this._getClasses(i), this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = false, this._helper = null, this._counter = false, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (y.setData(t2, os, this), this.init());
    }
    static get NAME() {
      return Yn;
    }
    get input() {
      return d.findOne("input", this._element) || d.findOne("textarea", this._element);
    }
    init() {
      this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._getEvents(), this._initiated = true);
    }
    update() {
      this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter();
    }
    forceActive() {
      this.input.setAttribute(Ft, ""), d.findOne(ke, this.input.parentNode).setAttribute(Ft, "");
    }
    forceInactive() {
      this.input.removeAttribute(Ft), d.findOne(ke, this.input.parentNode).removeAttribute(Ft);
    }
    dispose() {
      this._removeBorder(), y.removeData(this._element, os), this._element = null;
    }
    _getConfig(t2, e) {
      return t2 = __spreadValues(__spreadValues(__spreadValues({}, q_), h.getDataAttributes(e)), typeof t2 == "object" ? t2 : {}), D(Yn, t2, Z_), t2;
    }
    _getClasses(t2) {
      const e = h.getDataClassAttributes(this._element);
      return t2 = __spreadValues(__spreadValues(__spreadValues({}, Kc), e), t2), D(Yn, t2, Q_), t2;
    }
    _getLabelData() {
      this._label = d.findOne("label", this._element), this._label === null ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder());
    }
    _getHelper() {
      this._helper = d.findOne(G_, this._element);
    }
    _getCounter() {
      this._counter = h.getDataAttribute(this.input, "inputShowcounter"), this._counter && (this._maxLength = this.input.maxLength, this._showCounter());
    }
    _getEvents() {
      c.on(document, "focus", de2, V.activate(new V())), c.on(document, "input", de2, V.activate(new V())), c.on(document, "blur", de2, V.deactivate(new V())), c.on(document, "focus", ue, V.activate(new V())), c.on(document, "input", ue, V.activate(new V())), c.on(document, "blur", ue, V.deactivate(new V())), c.on(window, "shown.te.modal", (t2) => {
        d.find(de2, t2.target).forEach((e) => {
          const i = V.getInstance(e.parentNode);
          i && i.update();
        }), d.find(ue, t2.target).forEach((e) => {
          const i = V.getInstance(e.parentNode);
          i && i.update();
        });
      }), c.on(window, "shown.te.dropdown", (t2) => {
        const e = t2.target.parentNode.querySelector("[data-te-dropdown-menu-ref]");
        e && (d.find(de2, e).forEach((i) => {
          const n = V.getInstance(i.parentNode);
          n && n.update();
        }), d.find(ue, e).forEach((i) => {
          const n = V.getInstance(i.parentNode);
          n && n.update();
        }));
      }), c.on(window, "shown.te.tab", (t2) => {
        let e;
        t2.target.href ? e = t2.target.href.split("#")[1] : e = h.getDataAttribute(t2.target, "target").split("#")[1];
        const i = d.findOne(`#${e}`);
        d.find(de2, i).forEach((n) => {
          const o = V.getInstance(n.parentNode);
          o && o.update();
        }), d.find(ue, i).forEach((n) => {
          const o = V.getInstance(n.parentNode);
          o && o.update();
        });
      }), c.on(window, "reset", (t2) => {
        d.find(de2, t2.target).forEach((e) => {
          const i = V.getInstance(e.parentNode);
          i && i.forceInactive();
        }), d.find(ue, t2.target).forEach((e) => {
          const i = V.getInstance(e.parentNode);
          i && i.forceInactive();
        });
      }), c.on(window, "onautocomplete", (t2) => {
        const e = V.getInstance(t2.target.parentNode);
        !e || !t2.cancelable || e.forceActive();
      });
    }
    _showCounter() {
      if (d.find(`[${Aa}]`, this._element).length > 0)
        return;
      this._counterElement = document.createElement("div"), h.addClass(this._counterElement, this._classes.counter), this._counterElement.setAttribute(Aa, "");
      const e = this.input.value.length;
      this._counterElement.innerHTML = `${e} / ${this._maxLength}`, this._helper.appendChild(this._counterElement), this._bindCounter();
    }
    _bindCounter() {
      c.on(this.input, "input", () => {
        const t2 = this.input.value.length;
        this._counterElement.innerHTML = `${t2} / ${this._maxLength}`;
      });
    }
    _toggleDefaultDatePlaceholder(t2 = this.input) {
      if (!(t2.getAttribute("type") === "date"))
        return;
      !(document.activeElement === t2) && !t2.value ? t2.style.opacity = 0 : t2.style.opacity = 1;
    }
    _showPlaceholder() {
      this.input.setAttribute(X_, "");
    }
    _getNotchData() {
      this._notchMiddle = d.findOne(wa, this._element), this._notchLeading = d.findOne(ya, this._element);
    }
    _getLabelWidth() {
      this._labelWidth = this._label.clientWidth * 0.8 + 8;
    }
    _getLabelPositionInInputGroup() {
      if (this._labelMarginLeft = 0, !this._element.hasAttribute("data-te-input-group-ref"))
        return;
      const t2 = this.input, e = d.prev(t2, "[data-te-input-group-text-ref]")[0];
      e === void 0 ? this._labelMarginLeft = 0 : this._labelMarginLeft = e.offsetWidth - 1;
    }
    _applyDivs() {
      const t2 = this._config.inputFormWhite ? this._classes.notchLeadingWhite : this._classes.notchLeadingNormal, e = this._config.inputFormWhite ? this._classes.notchMiddleWhite : this._classes.notchMiddleNormal, i = this._config.inputFormWhite ? this._classes.notchTrailingWhite : this._classes.notchTrailingNormal, n = d.find(ke, this._element), o = $2("div");
      h.addClass(o, this._classes.notch), o.setAttribute(Fc, ""), this._notchLeading = $2("div"), h.addClass(this._notchLeading, `${this._classes.notchLeading} ${t2}`), this._notchLeading.setAttribute(Yc, ""), this._notchMiddle = $2("div"), h.addClass(this._notchMiddle, `${this._classes.notchMiddle} ${e}`), this._notchMiddle.setAttribute(jc, ""), this._notchTrailing = $2("div"), h.addClass(this._notchTrailing, `${this._classes.notchTrailing} ${i}`), this._notchTrailing.setAttribute(z_, ""), !(n.length >= 1) && (o.append(this._notchLeading), o.append(this._notchMiddle), o.append(this._notchTrailing), this._element.append(o));
    }
    _applyNotch() {
      this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);
    }
    _removeBorder() {
      const t2 = d.findOne(ke, this._element);
      t2 && t2.remove();
    }
    _activate(t2) {
      Zl(() => {
        this._getElements(t2);
        const e = t2 ? t2.target : this.input, i = d.findOne(ke, this._element);
        t2 && t2.type === "focus" && i && i.setAttribute(Ca, ""), e.value !== "" && (e.setAttribute(Ft, ""), i && i.setAttribute(Ft, "")), this._toggleDefaultDatePlaceholder(e);
      });
    }
    _getElements(t2) {
      if (t2 && (this._element = t2.target.parentNode, this._label = d.findOne("label", this._element)), t2 && this._label) {
        const e = this._labelWidth;
        this._getLabelData(), e !== this._labelWidth && (this._notchMiddle = d.findOne(wa, t2.target.parentNode), this._notchLeading = d.findOne(ya, t2.target.parentNode), this._applyNotch());
      }
    }
    _deactivate(t2) {
      const e = t2 ? t2.target : this.input, i = d.findOne(ke, e.parentNode);
      i.removeAttribute(Ca), e.value === "" && (e.removeAttribute(Ft), i.removeAttribute(Ft)), this._toggleDefaultDatePlaceholder(e);
    }
    static activate(t2) {
      return function(e) {
        t2._activate(e);
      };
    }
    static deactivate(t2) {
      return function(e) {
        t2._deactivate(e);
      };
    }
    static jQueryInterface(t2, e) {
      return this.each(function() {
        let i = y.getData(this, os);
        const n = typeof t2 == "object" && t2;
        if (!(!i && /dispose/.test(t2)) && (i || (i = new V(this, n)), typeof t2 == "string")) {
          if (typeof i[t2] > "u")
            throw new TypeError(`No method named "${t2}"`);
          i[t2](e);
        }
      });
    }
    static getInstance(t2) {
      return y.getData(t2, os);
    }
    static getOrCreateInstance(t2, e = {}) {
      return this.getInstance(t2) || new this(t2, typeof e == "object" ? e : null);
    }
  };
  var at13 = 38;
  var z = 40;
  var We = 36;
  var Fe = 35;
  var ct = 13;
  var Fi = 27;
  var Pi = 9;
  var zs = "te.datepicker";
  var dn = `.${zs}`;
  var Rf = ".data-api";
  var Pf = `close${dn}`;
  var Bf = `open${dn}`;
  var Hf = `dateChange${dn}`;
  var hs = `click${dn}${Rf}`;
  var Uc = "data-te-datepicker-modal-container-ref";
  var Xc = "data-te-datepicker-dropdown-container-ref";
  var Vf = `[${Uc}]`;
  var Wf = `[${Xc}]`;
  var $i = "timepicker";
  var M = `data-te-${$i}`;
  var Us = `te.${$i}`;
  var Rt = `.${Us}`;
  var Pt = ".data-api";
  var Ba = `click${Rt}${Pt}`;
  var _s = `keydown${Rt}${Pt}`;
  var Ha = `mousedown${Rt}${Pt}`;
  var Va = `mouseup${Rt}${Pt}`;
  var Wa = `mousemove${Rt}${Pt}`;
  var Fa = `mouseleave${Rt}${Pt}`;
  var Ya = `mouseover${Rt}${Pt}`;
  var ja2 = `touchmove${Rt}${Pt}`;
  var Ka = `touchend${Rt}${Pt}`;
  var za = `touchstart${Rt}${Pt}`;
  var Fm = `[${M}-am]`;
  var Ym = `[${M}-pm]`;
  var jm = `[${M}-format24]`;
  var fs = `[${M}-current]`;
  var ms = `[${M}-hour-mode]`;
  var Km = `[${M}-toggle-button]`;
  var Gn = `${M}-cancel`;
  var Ua = `${M}-clear`;
  var qn = `${M}-submit`;
  var zm = `${M}-icon`;
  var Zn = `${M}-icon-up`;
  var Qn = `${M}-icon-down`;
  var Um = `${M}-icon-inline-hour`;
  var Xm = `${M}-icon-inline-minute`;
  var Xa = `${M}-inline-hour-icons`;
  var Gm = `${M}-current-inline`;
  var Zm = `${M}-invalid-feedback`;
  var Jn = `${M}-is-invalid`;
  var Yt = `${M}-disabled`;
  var H = `${M}-active`;
  var Qm = `${M}-input`;
  var pe = `${M}-clock`;
  var di = `${M}-clock-inner`;
  var to9 = `${M}-wrapper`;
  var Ga = `${M}-clock-wrapper`;
  var gs = `${M}-hour`;
  var eo2 = `${M}-minute`;
  var bs = `${M}-tips-element`;
  var K = `${M}-tips-hours`;
  var X = `${M}-tips-minutes`;
  var lt = `${M}-tips-inner`;
  var vs = `${M}-tips-inner-element`;
  var qa = `${M}-middle-dot`;
  var io = `${M}-hand-pointer`;
  var so = `${M}-circle`;
  var Za = `${M}-modal`;
  var pg = F() ? 100 : -100;
  var _g = F() ? -100 : 100;
  var Ho = "stepper";
  var Xs = "te.stepper";
  var pn = `.${Xs}`;
  var Yi = `data-te-${Ho}`;
  var Ja = `mousedown${pn}`;
  var tl2 = `keydown${pn}`;
  var vg = `keyup${pn}`;
  var el2 = `resize${pn}`;
  var jt = `[${Yi}-step-ref]`;
  var G = `[${Yi}-head-ref]`;
  var il = `[${Yi}-head-text-ref]`;
  var Es = `[${Yi}-head-icon-ref]`;
  var st = `[${Yi}-content-ref]`;
  var sl = "data-te-input-state-active";
  var Cs = "data-te-input-selected";
  var nl2 = "data-te-input-multiple-active";
  var ol = "[data-te-form-check-input]";
  var rl = class {
    constructor(t2, e, i, n, o, r, a, l, p, u, _) {
      this.id = t2, this.nativeOption = e, this.multiple = i, this.value = n, this.label = o, this.selected = r, this.disabled = a, this.hidden = l, this.secondaryText = p, this.groupId = u, this.icon = _, this.node = null, this.active = false;
    }
    select() {
      this.multiple ? this._selectMultiple() : this._selectSingle();
    }
    _selectSingle() {
      this.selected || (this.node.setAttribute(Cs, ""), this.node.setAttribute("aria-selected", true), this.selected = true, this.nativeOption && (this.nativeOption.selected = true));
    }
    _selectMultiple() {
      if (!this.selected) {
        const t2 = d.findOne(ol, this.node);
        t2.checked = true, this.node.setAttribute(Cs, ""), this.node.setAttribute("aria-selected", true), this.selected = true, this.nativeOption && (this.nativeOption.selected = true);
      }
    }
    deselect() {
      this.multiple ? this._deselectMultiple() : this._deselectSingle();
    }
    _deselectSingle() {
      this.selected && (this.node.removeAttribute(Cs), this.node.setAttribute("aria-selected", false), this.selected = false, this.nativeOption && (this.nativeOption.selected = false));
    }
    _deselectMultiple() {
      if (this.selected) {
        const t2 = d.findOne(ol, this.node);
        t2.checked = false, this.node.removeAttribute(Cs), this.node.setAttribute("aria-selected", false), this.selected = false, this.nativeOption && (this.nativeOption.selected = false);
      }
    }
    setNode(t2) {
      this.node = t2;
    }
    setActiveStyles() {
      if (!this.active) {
        if (this.multiple) {
          this.node.setAttribute(nl2, "");
          return;
        }
        this.active = true, this.node.setAttribute(sl, "");
      }
    }
    removeActiveStyles() {
      this.active && (this.active = false, this.node.removeAttribute(sl)), this.multiple && this.node.removeAttribute(nl2);
    }
  };
  var Tg = class {
    constructor(t2 = false) {
      this._multiple = t2, this._selections = [];
    }
    select(t2) {
      this._multiple ? this._selections.push(t2) : this._selections = [t2];
    }
    deselect(t2) {
      if (this._multiple) {
        const e = this._selections.findIndex((i) => t2 === i);
        this._selections.splice(e, 1);
      } else
        this._selections = [];
    }
    clear() {
      this._selections = [];
    }
    get selection() {
      return this._selections[0];
    }
    get selections() {
      return this._selections;
    }
    get label() {
      return this._selections[0] && this.selection.label;
    }
    get labels() {
      return this._selections.map((t2) => t2.label).join(", ");
    }
    get value() {
      return this.selections[0] && this.selection.value;
    }
    get values() {
      return this._selections.map((t2) => t2.value);
    }
  };
  function Vo(s) {
    return s.filter((t2) => !t2.disabled).every((t2) => t2.selected);
  }
  var Eg = "data-te-select-form-outline-ref";
  var Cg = "data-te-select-wrapper-ref";
  var Ag = "data-te-select-input-ref";
  var yg = "data-te-select-clear-btn-ref";
  var wg = "data-te-select-dropdown-container-ref";
  var kg = "data-te-select-dropdown-ref";
  var xg = "data-te-select-options-wrapper-ref";
  var Og = "data-te-select-options-list-ref";
  var Sg = "data-te-select-input-filter-ref";
  var Jc = "data-te-select-option-ref";
  var Ig = "data-te-select-option-all-ref";
  var Dg = "data-te-select-option-text-ref";
  var $g = "data-te-form-check-input";
  var Lg = "data-te-select-option-group-ref";
  var Ng = "data-te-select-option-group-label-ref";
  var th2 = "data-te-select-selected";
  var Mg = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
</svg>
`;
  var Rg = (s) => {
    s.code === "Tab" || s.code === "Esc" || s.preventDefault();
  };
  function As(s, t2, e, i, n) {
    t2.selectSize === "default" && h.addClass(s, e), t2.selectSize === "sm" && h.addClass(s, i), t2.selectSize === "lg" && h.addClass(s, n);
  }
  function Pg(s, t2, e, i, n) {
    const o = document.createElement("div");
    o.setAttribute("id", s), o.setAttribute(Cg, "");
    const r = $2("div");
    r.setAttribute(Eg, ""), h.addClass(r, i.formOutline);
    const a = $2("input"), l = t2.selectFilter ? "combobox" : "listbox", p = t2.multiple ? "true" : "false", u = t2.disabled ? "true" : "false";
    a.setAttribute(Ag, ""), h.addClass(a, i.selectInput), As(a, t2, i.selectInputSizeDefault, i.selectInputSizeSm, i.selectInputSizeLg), t2.selectFormWhite && h.addClass(a, i.selectInputWhite), a.setAttribute("type", "text"), a.setAttribute("role", l), a.setAttribute("aria-multiselectable", p), a.setAttribute("aria-disabled", u), a.setAttribute("aria-haspopup", "true"), a.setAttribute("aria-expanded", false), a.name = n, t2.tabIndex && a.setAttribute("tabIndex", t2.tabIndex), t2.disabled && a.setAttribute("disabled", ""), t2.selectPlaceholder !== "" && a.setAttribute("placeholder", t2.selectPlaceholder), t2.selectValidation ? (h.addStyle(a, {
      "pointer-events": "none",
      "caret-color": "transparent"
    }), h.addStyle(r, { cursor: "pointer" })) : a.setAttribute("readonly", "true"), t2.selectValidation && (a.setAttribute("required", "true"), a.setAttribute("aria-required", "true"), a.addEventListener("keydown", Rg));
    const _ = $2("div");
    h.addClass(_, i.selectValidationValid);
    const f = document.createTextNode(`${t2.selectValidFeedback}`);
    _.appendChild(f);
    const g = $2("div");
    h.addClass(g, i.selectValidationInvalid);
    const m = document.createTextNode(`${t2.selectInvalidFeedback}`);
    g.appendChild(m);
    const b = $2("span");
    b.setAttribute(yg, ""), h.addClass(b, i.selectClearBtn), As(b, t2, i.selectClearBtnDefault, i.selectClearBtnSm, i.selectClearBtnLg), t2.selectFormWhite && h.addClass(b, i.selectClearBtnWhite);
    const v = document.createTextNode("\u2715");
    b.appendChild(v), b.setAttribute("tabindex", "0");
    const C2 = $2("span");
    return h.addClass(C2, i.selectArrow), As(C2, t2, i.selectArrowDefault, i.selectArrowSm, i.selectArrowLg), t2.selectFormWhite && h.addClass(C2, i.selectArrowWhite), C2.innerHTML = Mg, r.appendChild(a), e && (h.addClass(e, i.selectLabel), As(e, t2, i.selectLabelSizeDefault, i.selectLabelSizeSm, i.selectLabelSizeLg), t2.selectFormWhite && h.addClass(e, i.selectLabelWhite), r.appendChild(e)), t2.selectValidation && (r.appendChild(_), r.appendChild(g)), t2.selectClearButton && r.appendChild(b), r.appendChild(C2), o.appendChild(r), o;
  }
  function al(s, t2, e, i, n, o, r, a) {
    const l = document.createElement("div");
    l.setAttribute(wg, ""), h.addClass(l, a.selectDropdownContainer), l.setAttribute("id", `${s}`), l.style.width = `${e}px`;
    const p = document.createElement("div");
    p.setAttribute("tabindex", 0), p.setAttribute(kg, ""), h.addClass(p, a.dropdown);
    const u = $2("div");
    u.setAttribute(xg, ""), h.addClass(u, a.optionsWrapper), h.addClass(u, a.optionsWrapperScrollbar), u.style.maxHeight = `${i}px`;
    const _ = eh(o, n, t2, a);
    return u.appendChild(_), t2.selectFilter && p.appendChild(Bg(t2.selectSearchPlaceholder, a)), p.appendChild(u), r && p.appendChild(r), l.appendChild(p), l;
  }
  function eh(s, t2, e, i) {
    const n = $2("div");
    n.setAttribute(Og, ""), h.addClass(n, i.optionsList);
    let o;
    return e.multiple ? o = Vg(s, t2, e, i) : o = Hg(s, e, i), o.forEach((r) => {
      n.appendChild(r);
    }), n;
  }
  function Bg(s, t2) {
    const e = $2("div");
    h.addClass(e, t2.inputGroup);
    const i = $2("input");
    return i.setAttribute(Sg, ""), h.addClass(i, t2.selectFilterInput), i.placeholder = s, i.setAttribute("role", "searchbox"), i.setAttribute("type", "text"), e.appendChild(i), e;
  }
  function Hg(s, t2, e) {
    return ih(s, t2, e);
  }
  function Vg(s, t2, e, i) {
    let n = null;
    e.selectAll && (n = Wg(t2, s, e, i));
    const o = ih(s, e, i);
    return n ? [n, ...o] : o;
  }
  function ih(s, t2, e) {
    const i = [];
    return s.forEach((n) => {
      if (Object.prototype.hasOwnProperty.call(n, "options")) {
        const r = Kg(n, t2, e);
        i.push(r);
      } else
        i.push(sh(n, t2, e));
    }), i;
  }
  function Wg(s, t2, e, i) {
    const n = Vo(t2), o = $2("div");
    return o.setAttribute(Jc, ""), h.addClass(o, i.selectOption), o.setAttribute(Ig, ""), h.addStyle(o, {
      height: `${e.selectOptionHeight}px`
    }), o.setAttribute("role", "option"), o.setAttribute("aria-selected", n), n && o.setAttribute(th2, ""), o.appendChild(nh(s, e, i)), s.setNode(o), o;
  }
  function sh(s, t2, e) {
    if (s.node)
      return s.node;
    const i = $2("div");
    return i.setAttribute(Jc, ""), h.addClass(i, e.selectOption), h.addStyle(i, {
      height: `${t2.selectOptionHeight}px`
    }), h.setDataAttribute(i, "id", s.id), i.setAttribute("role", "option"), i.setAttribute("aria-selected", s.selected), i.setAttribute("aria-disabled", s.disabled), s.selected && i.setAttribute(th2, ""), s.disabled && i.setAttribute("data-te-select-option-disabled", true), s.hidden && h.addClass(i, "hidden"), i.appendChild(nh(s, t2, e)), s.icon && i.appendChild(jg(s, e)), s.setNode(i), i;
  }
  function nh(s, t2, e) {
    const i = $2("span");
    i.setAttribute(Dg, ""), h.addClass(i, e.selectOptionText);
    const n = document.createTextNode(s.label);
    return t2.multiple && i.appendChild(Yg(s, e)), i.appendChild(n), (s.secondaryText || typeof s.secondaryText == "number") && i.appendChild(Fg(s.secondaryText, e)), i;
  }
  function Fg(s, t2) {
    const e = $2("span");
    h.addClass(e, t2.selectOptionSecondaryText);
    const i = document.createTextNode(s);
    return e.appendChild(i), e;
  }
  function Yg(s, t2) {
    const e = $2("input");
    e.setAttribute("type", "checkbox"), h.addClass(e, t2.formCheckInput), e.setAttribute($g, "");
    const i = $2("label");
    return s.selected && e.setAttribute("checked", true), s.disabled && e.setAttribute("disabled", true), e.appendChild(i), e;
  }
  function jg(s, t2) {
    const e = $2("span"), i = $2("img");
    return h.addClass(i, t2.selectOptionIcon), i.src = s.icon, e.appendChild(i), e;
  }
  function Kg(s, t2, e) {
    const i = $2("div");
    i.setAttribute(Lg, ""), h.addClass(i, e.selectOptionGroup), i.setAttribute("role", "group"), i.setAttribute("id", s.id), s.hidden && h.addClass(i, "hidden");
    const n = $2("label");
    return n.setAttribute(Ng, ""), h.addClass(n, e.selectOptionGroupLabel), h.addStyle(n, { height: `${t2.selectOptionHeight}px` }), n.setAttribute("for", s.id), n.textContent = s.label, i.appendChild(n), s.options.forEach((o) => {
      i.appendChild(sh(o, t2, e));
    }), i;
  }
  function zg(s, t2) {
    const e = $2("div");
    return e.innerHTML = s, h.addClass(e, t2.selectLabel), h.addClass(e, t2.selectFakeValue), e;
  }
  var oo = "select";
  var vi2 = "te.select";
  var ji = `.${vi2}`;
  var Ug = `close${ji}`;
  var Xg = `open${ji}`;
  var ll = `optionSelect${ji}`;
  var cl = `optionDeselect${ji}`;
  var Gg = `valueChange${ji}`;
  var qg = "change";
  var hl = "data-te-select-init";
  var oh = "data-te-select-no-results-ref";
  var dl = "data-te-select-open";
  var q = "data-te-input-state-active";
  var Kt = "data-te-input-focused";
  var ro2 = "data-te-input-disabled";
  var Zg = "data-te-select-option-group-label-ref";
  var Qg = "data-te-select-option-all-ref";
  var pi = "data-te-select-selected";
  var Jg = "[data-te-select-label-ref]";
  var ul = "[data-te-select-input-ref]";
  var tb = "[data-te-select-input-filter-ref]";
  var eb = "[data-te-select-dropdown-ref]";
  var ib = "[data-te-select-options-wrapper-ref]";
  var pl2 = "[data-te-select-options-list-ref]";
  var sb = "[data-te-select-option-ref]";
  var nb = "[data-te-select-clear-btn-ref]";
  var ob = "[data-te-select-custom-content-ref]";
  var rb = `[${oh}]`;
  var _l = "[data-te-select-form-outline-ref]";
  var ab = "[data-te-select-toggle]";
  var ao = "[data-te-input-notch-ref]";
  var lb = 200;
  var cb = {
    selectAutoSelect: false,
    selectContainer: "body",
    selectClearButton: false,
    disabled: false,
    selectDisplayedLabels: 5,
    selectFormWhite: false,
    multiple: false,
    selectOptionsSelectedLabel: "options selected",
    selectOptionHeight: 38,
    selectAll: true,
    selectAllLabel: "Select all",
    selectSearchPlaceholder: "Search...",
    selectSize: "default",
    selectVisibleOptions: 5,
    selectFilter: false,
    selectFilterDebounce: 300,
    selectNoResultText: "No results",
    selectValidation: false,
    selectValidFeedback: "Valid",
    selectInvalidFeedback: "Invalid",
    selectPlaceholder: ""
  };
  var hb = {
    selectAutoSelect: "boolean",
    selectContainer: "string",
    selectClearButton: "boolean",
    disabled: "boolean",
    selectDisplayedLabels: "number",
    selectFormWhite: "boolean",
    multiple: "boolean",
    selectOptionsSelectedLabel: "string",
    selectOptionHeight: "number",
    selectAll: "boolean",
    selectAllLabel: "string",
    selectSearchPlaceholder: "string",
    selectSize: "string",
    selectVisibleOptions: "number",
    selectFilter: "boolean",
    selectFilterDebounce: "number",
    selectNoResultText: "string",
    selectValidation: "boolean",
    selectValidFeedback: "string",
    selectInvalidFeedback: "string",
    selectPlaceholder: "string"
  };
  var db = {
    dropdown: "relative outline-none min-w-[100px] m-0 scale-[0.8] opacity-0 bg-white shadow-[0_2px_5px_0_rgba(0,0,0,0.16),_0_2px_10px_0_rgba(0,0,0,0.12)] transition duration-200 motion-reduce:transition-none data-[te-select-open]:scale-100 data-[te-select-open]:opacity-100 dark:bg-zinc-700",
    formCheckInput: "relative float-left mt-[0.15rem] mr-[8px] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 dark:border-neutral-600 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary dark:checked:border-primary checked:bg-primary dark:checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:ml-[0.25rem] checked:after:-mt-px checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-t-0 checked:after:border-l-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:ml-[0.25rem] checked:focus:after:-mt-px checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-t-0 checked:focus:after:border-l-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent",
    formOutline: "relative",
    initialized: "hidden",
    inputGroup: "flex items-center whitespace-nowrap p-2.5 text-center text-base font-normal leading-[1.6] text-gray-700 dark:bg-zinc-800 dark:text-gray-200 dark:placeholder:text-gray-200",
    noResult: "flex items-center px-4",
    optionsList: "list-none m-0 p-0",
    optionsWrapper: "overflow-y-auto",
    optionsWrapperScrollbar: "[&::-webkit-scrollbar]:w-1 [&::-webkit-scrollbar]:h-1 [&::-webkit-scrollbar-button]:block [&::-webkit-scrollbar-button]:h-0 [&::-webkit-scrollbar-button]:bg-transparent [&::-webkit-scrollbar-track-piece]:bg-transparent [&::-webkit-scrollbar-track-piece]:rounded-none [&::-webkit-scrollbar-track-piece]: [&::-webkit-scrollbar-track-piece]:rounded-l [&::-webkit-scrollbar-thumb]:h-[50px] [&::-webkit-scrollbar-thumb]:bg-[#999] [&::-webkit-scrollbar-thumb]:rounded",
    selectArrow: "absolute right-3 text-[0.8rem] cursor-pointer peer-focus:text-primary peer-data-[te-input-focused]:text-primary group-data-[te-was-validated]/validation:peer-valid:text-green-600 group-data-[te-was-validated]/validation:peer-invalid:text-[rgb(220,76,100)] w-5 h-5",
    selectArrowWhite: "text-gray-50 peer-focus:!text-white peer-data-[te-input-focused]:!text-white",
    selectArrowDefault: "top-2",
    selectArrowLg: "top-[13px]",
    selectArrowSm: "top-1",
    selectClearBtn: "absolute top-2 right-9 text-black cursor-pointer focus:text-primary outline-none dark:text-gray-200",
    selectClearBtnWhite: "!text-gray-50",
    selectClearBtnDefault: "top-2 text-base",
    selectClearBtnLg: "top-[11px] text-base",
    selectClearBtnSm: "top-1 text-[0.8rem]",
    selectDropdownContainer: "z-[1070]",
    selectFakeValue: "transform-none hidden data-[te-input-state-active]:block",
    selectFilterInput: "relative m-0 block w-full min-w-0 flex-auto rounded border border-solid border-gray-300 bg-transparent bg-clip-padding px-3 py-1.5 text-base font-normal text-gray-700 transition duration-300 ease-in-out motion-reduce:transition-none focus:border-primary focus:text-gray-700 focus:shadow-te-primary focus:outline-none dark:text-gray-200 dark:placeholder:text-gray-200",
    selectInput: "peer block min-h-[auto] w-full rounded border-0 bg-transparent outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0 cursor-pointer data-[te-input-disabled]:bg-[#e9ecef] data-[te-input-disabled]:cursor-default group-data-[te-was-validated]/validation:mb-4 dark:data-[te-input-disabled]:bg-zinc-600",
    selectInputWhite: "!text-gray-50",
    selectInputSizeDefault: "py-[0.32rem] px-3 leading-[1.6]",
    selectInputSizeLg: "py-[0.32rem] px-3 leading-[2.15]",
    selectInputSizeSm: "py-[0.33rem] px-3 text-xs leading-[1.5]",
    selectLabel: "pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate text-gray-500 transition-all duration-200 ease-out peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200 data-[te-input-state-active]:scale-[0.8] dark:peer-focus:text-primary",
    selectLabelWhite: "!text-gray-50",
    selectLabelSizeDefault: "pt-[0.37rem] leading-[1.6] peer-focus:-translate-y-[0.9rem] peer-data-[te-input-state-active]:-translate-y-[0.9rem] data-[te-input-state-active]:-translate-y-[0.9rem]",
    selectLabelSizeLg: "pt-[0.37rem] leading-[2.15] peer-focus:-translate-y-[1.15rem] peer-data-[te-input-state-active]:-translate-y-[1.15rem] data-[te-input-state-active]:-translate-y-[1.15rem]",
    selectLabelSizeSm: "pt-[0.37rem] text-xs leading-[1.5] peer-focus:-translate-y-[0.75rem] peer-data-[te-input-state-active]:-translate-y-[0.75rem] data-[te-input-state-active]:-translate-y-[0.75rem]",
    selectOption: "flex flex-row items-center justify-between w-full px-4 truncate text-gray-700 bg-transparent select-none cursor-pointer data-[te-input-multiple-active]:bg-black/5 hover:[&:not([data-te-select-option-disabled])]:bg-black/5 data-[te-input-state-active]:bg-black/5 data-[te-select-option-selected]:data-[te-input-state-active]:bg-black/5 data-[te-select-selected]:data-[te-select-option-disabled]:cursor-default data-[te-select-selected]:data-[te-select-option-disabled]:text-gray-400 data-[te-select-selected]:data-[te-select-option-disabled]:bg-transparent data-[te-select-option-selected]:bg-black/[0.02] data-[te-select-option-disabled]:text-gray-400 data-[te-select-option-disabled]:cursor-default group-data-[te-select-option-group-ref]/opt:pl-7 dark:text-gray-200 dark:hover:[&:not([data-te-select-option-disabled])]:bg-white/30 dark:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-selected]:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-disabled]:text-gray-400 dark:data-[te-input-multiple-active]:bg-white/30",
    selectOptionGroup: "group/opt",
    selectOptionGroupLabel: "flex flex-row items-center w-full px-4 truncate bg-transparent text-black/50 select-none dark:text-gray-300",
    selectOptionIcon: "w-7 h-7 rounded-full",
    selectOptionSecondaryText: "block text-[0.8rem] text-gray-500 dark:text-gray-300",
    selectOptionText: "group",
    selectValidationValid: "hidden absolute -mt-3 w-auto text-sm text-green-600 cursor-pointer group-data-[te-was-validated]/validation:peer-valid:block",
    selectValidationInvalid: "hidden absolute -mt-3 w-auto text-sm text-[rgb(220,76,100)] cursor-pointer group-data-[te-was-validated]/validation:peer-invalid:block"
  };
  var ub = {
    dropdown: "string",
    formCheckInput: "string",
    formOutline: "string",
    initialized: "string",
    inputGroup: "string",
    noResult: "string",
    optionsList: "string",
    optionsWrapper: "string",
    optionsWrapperScrollbar: "string",
    selectArrow: "string",
    selectArrowDefault: "string",
    selectArrowLg: "string",
    selectArrowSm: "string",
    selectClearBtn: "string",
    selectClearBtnDefault: "string",
    selectClearBtnLg: "string",
    selectClearBtnSm: "string",
    selectDropdownContainer: "string",
    selectFakeValue: "string",
    selectFilterInput: "string",
    selectInput: "string",
    selectInputSizeDefault: "string",
    selectInputSizeLg: "string",
    selectInputSizeSm: "string",
    selectLabel: "string",
    selectLabelSizeDefault: "string",
    selectLabelSizeLg: "string",
    selectLabelSizeSm: "string",
    selectOption: "string",
    selectOptionGroup: "string",
    selectOptionGroupLabel: "string",
    selectOptionIcon: "string",
    selectOptionSecondaryText: "string",
    selectOptionText: "string"
  };
  var _r = class {
    constructor(t2, e, i) {
      this._element = t2, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._config.selectPlaceholder && !this._config.multiple && this._addPlaceholderOption(), this._optionsToRender = this._getOptionsToRender(t2), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._filteredOptionsList = null, this._selectionModel = new Tg(this.multiple), this._activeOptionIndex = -1, this._activeOption = null, this._wrapperId = rt("select-wrapper-"), this._dropdownContainerId = rt("select-dropdown-container-"), this._selectAllId = rt("select-all-"), this._debounceTimeoutId = null, this._dropdownHeight = this._config.selectOptionHeight * this._config.selectVisibleOptions, this._popper = null, this._input = null, this._label = d.next(this._element, Jg)[0], this._notch = null, this._fakeValue = null, this._isFakeValueActive = false, this._customContent = d.next(t2, ob)[0], this._toggleButton = null, this._elementToggle = null, this._wrapper = null, this._inputEl = null, this._dropdownContainer = null, this._container = null, this._selectAllOption = null, this._init(), this._mutationObserver = null, this._isOpen = false, this._addMutationObserver(), this._element && y.setData(t2, vi2, this);
    }
    static get NAME() {
      return oo;
    }
    get filterInput() {
      return d.findOne(tb, this._dropdownContainer);
    }
    get dropdown() {
      return d.findOne(eb, this._dropdownContainer);
    }
    get optionsList() {
      return d.findOne(pl2, this._dropdownContainer);
    }
    get optionsWrapper() {
      return d.findOne(ib, this._dropdownContainer);
    }
    get clearButton() {
      return d.findOne(nb, this._wrapper);
    }
    get options() {
      return this._filteredOptionsList ? this._filteredOptionsList : this._plainOptions;
    }
    get value() {
      return this.multiple ? this._selectionModel.values : this._selectionModel.value;
    }
    get multiple() {
      return this._config.multiple;
    }
    get hasSelectAll() {
      return this.multiple && this._config.selectAll;
    }
    get hasSelection() {
      return this._selectionModel.selection || this._selectionModel.selections.length > 0;
    }
    _getConfig(t2) {
      const e = h.getDataAttributes(this._element);
      return t2 = __spreadValues(__spreadValues(__spreadValues({}, cb), e), t2), this._element.hasAttribute("multiple") && (t2.multiple = true), this._element.hasAttribute("disabled") && (t2.disabled = true), this._element.tabIndex && (t2.tabIndex = this._element.getAttribute("tabIndex")), D(oo, t2, hb), t2;
    }
    _getClasses(t2) {
      const e = h.getDataClassAttributes(this._element);
      return t2 = __spreadValues(__spreadValues(__spreadValues({}, db), e), t2), D(oo, t2, ub), t2;
    }
    _addPlaceholderOption() {
      const t2 = new Option("", "", true, true);
      t2.hidden = true, t2.selected = true, this._element.prepend(t2);
    }
    _getOptionsToRender(t2) {
      const e = [];
      return t2.childNodes.forEach((n) => {
        if (n.nodeName === "OPTGROUP") {
          const o = {
            id: rt("group-"),
            label: n.label,
            disabled: n.hasAttribute("disabled"),
            hidden: n.hasAttribute("hidden"),
            options: []
          };
          n.childNodes.forEach((a) => {
            a.nodeName === "OPTION" && o.options.push(this._createOptionObject(a, o));
          }), e.push(o);
        } else
          n.nodeName === "OPTION" && e.push(this._createOptionObject(n));
      }), e;
    }
    _getPlainOptions(t2) {
      if (!d.findOne("optgroup", this._element))
        return t2;
      const i = [];
      return t2.forEach((n) => {
        Object.prototype.hasOwnProperty.call(n, "options") ? n.options.forEach((r) => {
          i.push(r);
        }) : i.push(n);
      }), i;
    }
    _createOptionObject(t2, e = {}) {
      const i = rt("option-"), n = e.id ? e.id : null, o = e.disabled ? e.disabled : false, r = t2.selected || t2.hasAttribute(pi), a = t2.hasAttribute("disabled") || o, l = t2.hasAttribute("hidden") || e && e.hidden, p = this.multiple, u = t2.value, _ = t2.label, f = h.getDataAttribute(t2, "selectSecondaryText"), g = h.getDataAttribute(t2, "select-icon");
      return new rl(i, t2, p, u, _, r, a, l, f, n, g);
    }
    _getNavigationOptions() {
      const t2 = this.options.filter((e) => !e.hidden);
      return this.hasSelectAll ? [this._selectAllOption, ...t2] : t2;
    }
    _init() {
      this._renderMaterialWrapper(), this._wrapper = d.findOne(`#${this._wrapperId}`), this._input = d.findOne(ul, this._wrapper), this._config.disabled && this._input.setAttribute(ro2, "");
      const t2 = this._config.selectContainer;
      t2 === "body" ? this._container = document.body : this._container = d.findOne(t2), this._initOutlineInput(), this._setDefaultSelections(), this._updateInputValue(), this._appendFakeValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._bindComponentEvents(), this.hasSelectAll && (this._selectAllOption = this._createSelectAllOption()), this._dropdownContainer = al(this._dropdownContainerId, this._config, this._input.offsetWidth, this._dropdownHeight, this._selectAllOption, this._optionsToRender, this._customContent, this._classes), this._setFirstActiveOption(), this._listenToFocusChange();
    }
    _renderMaterialWrapper() {
      const t2 = Pg(this._wrapperId, this._config, this._label, this._classes, this._element.name);
      this._element.parentNode.insertBefore(t2, this._element), h.addClass(this._element, this._classes.initialized), t2.appendChild(this._element);
    }
    _initOutlineInput() {
      const t2 = d.findOne(_l, this._wrapper);
      new V(t2, {
        inputFormWhite: this._config.selectFormWhite
      }, this._classes).init(), this._notch = d.findOne(ao, this._wrapper);
    }
    _bindComponentEvents() {
      this._listenToComponentKeydown(), this._listenToWrapperClick(), this._listenToClearBtnClick(), this._listenToClearBtnKeydown();
    }
    _setDefaultSelections() {
      this.options.forEach((t2) => {
        t2.selected && this._selectionModel.select(t2);
      });
    }
    _listenToComponentKeydown() {
      c.on(this._wrapper, "keydown", this._handleKeydown.bind(this));
    }
    _handleKeydown(t2) {
      this._isOpen && !this._config.selectFilter ? this._handleOpenKeydown(t2) : this._handleClosedKeydown(t2);
    }
    _handleOpenKeydown(t2) {
      const e = t2.keyCode, i = e === Fi || e === at13 && t2.altKey || e === Pi;
      if (e === Pi && this._config.selectAutoSelect && !this.multiple && this._handleAutoSelection(this._activeOption), i) {
        this.close(), this._input.focus();
        return;
      }
      switch (e) {
        case z:
          this._setNextOptionActive(), this._scrollToOption(this._activeOption);
          break;
        case at13:
          this._setPreviousOptionActive(), this._scrollToOption(this._activeOption);
          break;
        case We:
          this._setFirstOptionActive(), this._scrollToOption(this._activeOption);
          break;
        case Fe:
          this._setLastOptionActive(), this._scrollToOption(this._activeOption);
          break;
        case ct:
          t2.preventDefault(), this._activeOption && (this.hasSelectAll && this._activeOptionIndex === 0 ? this._handleSelectAll() : this._handleSelection(this._activeOption));
          return;
        default:
          return;
      }
      t2.preventDefault();
    }
    _handleClosedKeydown(t2) {
      const e = t2.keyCode;
      if (e === ct && t2.preventDefault(), (e === ct || e === z && t2.altKey || e === z && this.multiple) && this.open(), this.multiple)
        switch (e) {
          case z:
            this.open();
            break;
          case at13:
            this.open();
            break;
          default:
            return;
        }
      else
        switch (e) {
          case z:
            this._setNextOptionActive(), this._handleSelection(this._activeOption);
            break;
          case at13:
            this._setPreviousOptionActive(), this._handleSelection(this._activeOption);
            break;
          case We:
            this._setFirstOptionActive(), this._handleSelection(this._activeOption);
            break;
          case Fe:
            this._setLastOptionActive(), this._handleSelection(this._activeOption);
            break;
          default:
            return;
        }
      t2.preventDefault();
    }
    _scrollToOption(t2) {
      if (!t2)
        return;
      let e;
      const i = this.options.filter((u) => !u.hidden);
      this.hasSelectAll ? e = i.indexOf(t2) + 1 : e = i.indexOf(t2);
      const n = this._getNumberOfGroupsBeforeOption(e), o = e + n, r = this.optionsWrapper, a = r.offsetHeight, l = this._config.selectOptionHeight, p = r.scrollTop;
      if (e > -1) {
        const u = o * l, _ = u + l > p + a;
        u < p ? r.scrollTop = u : _ ? r.scrollTop = u - a + l : r.scrollTop = p;
      }
    }
    _getNumberOfGroupsBeforeOption(t2) {
      const e = this.options.filter((r) => !r.hidden), i = this._optionsToRender.filter((r) => !r.hidden), n = this.hasSelectAll ? t2 - 1 : t2;
      let o = 0;
      for (let r = 0; r <= n; r++)
        e[r].groupId && i[o] && i[o].id && e[r].groupId === i[o].id && o++;
      return o;
    }
    _setNextOptionActive() {
      let t2 = this._activeOptionIndex + 1;
      const e = this._getNavigationOptions();
      if (e[t2]) {
        for (; e[t2].disabled; )
          if (t2 += 1, !e[t2])
            return;
        this._updateActiveOption(e[t2], t2);
      }
    }
    _setPreviousOptionActive() {
      let t2 = this._activeOptionIndex - 1;
      const e = this._getNavigationOptions();
      if (e[t2]) {
        for (; e[t2].disabled; )
          if (t2 -= 1, !e[t2])
            return;
        this._updateActiveOption(e[t2], t2);
      }
    }
    _setFirstOptionActive() {
      const e = this._getNavigationOptions();
      this._updateActiveOption(e[0], 0);
    }
    _setLastOptionActive() {
      const t2 = this._getNavigationOptions(), e = t2.length - 1;
      this._updateActiveOption(t2[e], e);
    }
    _updateActiveOption(t2, e) {
      const i = this._activeOption;
      i && i.removeActiveStyles(), t2.setActiveStyles(), this._activeOptionIndex = e, this._activeOption = t2;
    }
    _listenToWrapperClick() {
      c.on(this._wrapper, "click", () => {
        this.toggle();
      });
    }
    _listenToClearBtnClick() {
      c.on(this.clearButton, "click", (t2) => {
        t2.preventDefault(), t2.stopPropagation(), this._handleClear();
      });
    }
    _listenToClearBtnKeydown() {
      c.on(this.clearButton, "keydown", (t2) => {
        t2.keyCode === ct && (this._handleClear(), t2.preventDefault(), t2.stopPropagation());
      });
    }
    _handleClear() {
      if (this.multiple)
        this._selectionModel.clear(), this._deselectAllOptions(this.options), this.hasSelectAll && this._updateSelectAllState();
      else {
        const t2 = this._selectionModel.selection;
        this._selectionModel.clear(), t2.deselect();
      }
      this._fakeValue.innerHTML = "", this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(null), this._emitNativeChangeEvent();
    }
    _listenToOptionsClick() {
      c.on(this.optionsWrapper, "click", (t2) => {
        if (t2.target.hasAttribute(Zg))
          return;
        const i = t2.target.nodeName === "DIV" ? t2.target : d.closest(t2.target, sb);
        if (i.hasAttribute(Qg)) {
          this._handleSelectAll();
          return;
        }
        const o = i.dataset.teId, r = this.options.find((a) => a.id === o);
        r && !r.disabled && this._handleSelection(r);
      });
    }
    _handleSelectAll() {
      this._selectAllOption.selected ? (this._deselectAllOptions(this.options), this._selectAllOption.deselect()) : (this._selectAllOptions(this.options), this._selectAllOption.select()), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
    }
    _selectAllOptions(t2) {
      t2.forEach((e) => {
        !e.selected && !e.disabled && (this._selectionModel.select(e), e.select());
      });
    }
    _deselectAllOptions(t2) {
      t2.forEach((e) => {
        e.selected && !e.disabled && (this._selectionModel.deselect(e), e.deselect());
      });
    }
    _handleSelection(t2) {
      this.multiple ? (this._handleMultiSelection(t2), this.hasSelectAll && this._updateSelectAllState()) : this._handleSingleSelection(t2), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
    }
    _handleAutoSelection(t2) {
      this._singleOptionSelect(t2), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
    }
    _handleSingleSelection(t2) {
      this._singleOptionSelect(t2), this.close(), this._input.focus();
    }
    _singleOptionSelect(t2) {
      const e = this._selectionModel.selections[0];
      e && e !== t2 && (this._selectionModel.deselect(e), e.deselect(), e.node.setAttribute(pi, false), c.trigger(this._element, cl, {
        value: e.value
      })), (!e || e && t2 !== e) && (this._selectionModel.select(t2), t2.select(), t2.node.setAttribute(pi, true), c.trigger(this._element, ll, {
        value: t2.value
      }), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent());
    }
    _handleMultiSelection(t2) {
      t2.selected ? (this._selectionModel.deselect(t2), t2.deselect(), t2.node.setAttribute(pi, false), c.trigger(this._element, cl, {
        value: t2.value
      })) : (this._selectionModel.select(t2), t2.select(), t2.node.setAttribute(pi, true), c.trigger(this._element, ll, {
        value: t2.value
      })), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
    }
    _emitValueChangeEvent(t2) {
      c.trigger(this._element, Gg, { value: t2 });
    }
    _emitNativeChangeEvent() {
      c.trigger(this._element, qg);
    }
    _updateInputValue() {
      const t2 = this.multiple ? this._selectionModel.labels : this._selectionModel.label;
      let e;
      this.multiple && this._config.selectDisplayedLabels !== -1 && this._selectionModel.selections.length > this._config.selectDisplayedLabels ? e = `${this._selectionModel.selections.length} ${this._config.selectOptionsSelectedLabel}` : e = t2, !this.multiple && !this._isSelectionValid(this._selectionModel.selection) ? this._input.value = "" : this._isLabelEmpty(this._selectionModel.selection) ? this._input.value = " " : e ? this._input.value = e : this.multiple || !this._optionsToRender[0] ? this._input.value = "" : this._input.value = this._optionsToRender[0].label;
    }
    _isSelectionValid(t2) {
      return !(t2 && (t2.disabled || t2.value === ""));
    }
    _isLabelEmpty(t2) {
      return !!(t2 && t2.label === "");
    }
    _appendFakeValue() {
      if (!this._selectionModel.selection || this._selectionModel._multiple)
        return;
      const t2 = this._selectionModel.selection.label;
      this._fakeValue = zg(t2, this._classes), d.findOne(_l, this._wrapper).appendChild(this._fakeValue);
    }
    _updateLabelPosition() {
      const t2 = this._element.hasAttribute(hl), e = this._input.value !== "";
      this._label && (t2 && (e || this._isOpen || this._isFakeValueActive) ? (this._label.setAttribute(q, ""), this._notch.setAttribute(q, "")) : (this._label.removeAttribute(q), this._notch.removeAttribute(q, "")));
    }
    _updateLabelPositionWhileClosing() {
      this._label && (this._input.value !== "" || this._isFakeValueActive ? (this._label.setAttribute(q, ""), this._notch.setAttribute(q, "")) : (this._label.removeAttribute(q), this._notch.removeAttribute(q)));
    }
    _updateFakeLabelPosition() {
      this._fakeValue && (this._input.value === "" && this._fakeValue.innerHTML !== "" && !this._config.selectPlaceholder ? (this._isFakeValueActive = true, this._fakeValue.setAttribute(q, "")) : (this._isFakeValueActive = false, this._fakeValue.removeAttribute(q)));
    }
    _updateClearButtonVisibility() {
      if (!this.clearButton)
        return;
      this._selectionModel.selection || this._selectionModel.selections.length > 0 ? h.addStyle(this.clearButton, { display: "block" }) : h.addStyle(this.clearButton, { display: "none" });
    }
    _updateSelectAllState() {
      const t2 = this._selectAllOption.selected, e = Vo(this.options);
      !e && t2 ? this._selectAllOption.deselect() : e && !t2 && this._selectAllOption.select();
    }
    toggle() {
      this._isOpen ? this.close() : this.open();
    }
    open() {
      const t2 = this._config.disabled, e = c.trigger(this._element, Xg);
      this._isOpen || t2 || e.defaultPrevented || (this._openDropdown(), this._updateDropdownWidth(), this._setFirstActiveOption(), this._scrollToOption(this._activeOption), this._config.selectFilter && (setTimeout(() => {
        this.filterInput.focus();
      }, 0), this._listenToSelectSearch(), this._listenToDropdownKeydown()), this._listenToOptionsClick(), this._listenToOutsideClick(), this._listenToWindowResize(), this._isOpen = true, this._updateLabelPosition(), this._setInputActiveStyles());
    }
    _openDropdown() {
      this._popper = Ce(this._input, this._dropdownContainer, {
        placement: "bottom-start",
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [0, 1]
            }
          }
        ]
      }), this._container.appendChild(this._dropdownContainer), setTimeout(() => {
        this.dropdown.setAttribute(dl, "");
      }, 0);
    }
    _updateDropdownWidth() {
      const t2 = this._input.offsetWidth;
      h.addStyle(this._dropdownContainer, { width: `${t2}px` });
    }
    _setFirstActiveOption() {
      const t2 = this._getNavigationOptions(), e = this._activeOption;
      e && e.removeActiveStyles();
      const i = this.multiple ? this._selectionModel.selections[0] : this._selectionModel.selection;
      i ? (this._activeOption = i, i.setActiveStyles(), this._activeOptionIndex = t2.findIndex((n) => n === i)) : (this._activeOption = null, this._activeOptionIndex = -1);
    }
    _setInputActiveStyles() {
      this._input.setAttribute(Kt, ""), d.findOne(ao, this._wrapper).setAttribute(Kt, "");
    }
    _listenToWindowResize() {
      c.on(window, "resize", this._handleWindowResize.bind(this));
    }
    _handleWindowResize() {
      this._dropdownContainer && this._updateDropdownWidth();
    }
    _listenToSelectSearch() {
      this.filterInput.addEventListener("input", (t2) => {
        const e = t2.target.value, i = this._config.selectFilterDebounce;
        this._debounceFilter(e, i);
      });
    }
    _debounceFilter(t2, e) {
      this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {
        this._filterOptions(t2);
      }, e);
    }
    _filterOptions(t2) {
      const e = [];
      this._optionsToRender.forEach((o) => {
        const r = Object.prototype.hasOwnProperty.call(o, "options"), a = !r && o.label.toLowerCase().includes(t2.toLowerCase()), l = {};
        r && (l.label = o.label, l.options = this._filter(t2, o.options), l.options.length > 0 && e.push(l)), a && e.push(o);
      });
      const i = this._config.selectNoResultText !== "", n = e.length !== 0;
      if (n)
        this._updateOptionsListTemplate(e), this._popper.forceUpdate(), this._filteredOptionsList = this._getPlainOptions(e), this.hasSelectAll && this._updateSelectAllState(), this._setFirstActiveOption();
      else if (!n && i) {
        const o = this._getNoResultTemplate();
        this.optionsWrapper.innerHTML = o;
      }
    }
    _updateOptionsListTemplate(t2) {
      const e = d.findOne(pl2, this._dropdownContainer) || d.findOne(rb, this._dropdownContainer), i = eh(t2, this._selectAllOption, this._config, this._classes);
      this.optionsWrapper.removeChild(e), this.optionsWrapper.appendChild(i);
    }
    _getNoResultTemplate() {
      return `<div class="${this._classes.noResult}" ${oh} style="height: ${this._config.selectOptionHeight}px">${this._config.selectNoResultText}</div>`;
    }
    _filter(t2, e) {
      const i = t2.toLowerCase();
      return e.filter((n) => n.label.toLowerCase().includes(i));
    }
    _listenToDropdownKeydown() {
      c.on(this.dropdown, "keydown", this._handleOpenKeydown.bind(this));
    }
    _listenToOutsideClick() {
      this._outsideClick = this._handleOutSideClick.bind(this), c.on(document, "click", this._outsideClick);
    }
    _listenToFocusChange(t2 = true) {
      if (t2 === false) {
        c.off(this._input, "focus", () => this._notch.setAttribute(Kt, "")), c.off(this._input, "blur", () => this._notch.removeAttribute(Kt));
        return;
      }
      c.on(this._input, "focus", () => this._notch.setAttribute(Kt, "")), c.on(this._input, "blur", () => this._notch.removeAttribute(Kt));
    }
    _handleOutSideClick(t2) {
      const e = this._wrapper && this._wrapper.contains(t2.target), i = t2.target === this._dropdownContainer, n = this._dropdownContainer && this._dropdownContainer.contains(t2.target);
      let o;
      this._toggleButton || (this._elementToggle = d.find(ab)), this._elementToggle && this._elementToggle.forEach((r) => {
        const a = h.getDataAttribute(r, "select-toggle");
        (a === this._element.id || this._element.classList.contains(a)) && (this._toggleButton = r, o = this._toggleButton.contains(t2.target));
      }), !e && !i && !n && !o && this.close();
    }
    close() {
      const t2 = c.trigger(this._element, Ug);
      !this._isOpen || t2.defaultPrevented || (this._config.selectFilter && this.hasSelectAll && (this._resetFilterState(), this._updateOptionsListTemplate(this._optionsToRender), this._config.multiple && this._updateSelectAllState()), this._removeDropdownEvents(), this.dropdown.removeAttribute(dl), setTimeout(() => {
        this._input.removeAttribute(Kt), this._input.blur(), d.findOne(ao, this._wrapper).removeAttribute(Kt), this._label && !this.hasSelection && (this._label.removeAttribute(q), this._notch.setAttribute(q, ""), this._input.removeAttribute(q), this._notch.removeAttribute(q)), this._updateLabelPositionWhileClosing();
      }, 0), setTimeout(() => {
        this._container && this._dropdownContainer.parentNode === this._container && this._container.removeChild(this._dropdownContainer), this._popper.destroy(), this._isOpen = false, c.off(this.dropdown, "transitionend");
      }, lb));
    }
    _resetFilterState() {
      this.filterInput.value = "", this._filteredOptionsList = null;
    }
    _removeDropdownEvents() {
      c.off(document, "click", this._outsideClick), this._config.selectFilter && c.off(this.dropdown, "keydown"), c.off(this.optionsWrapper, "click");
    }
    _addMutationObserver() {
      this._mutationObserver = new MutationObserver(() => {
        this._wrapper && (this._updateSelections(), this._updateDisabledState());
      }), this._observeMutationObserver();
    }
    _updateSelections() {
      this._optionsToRender = this._getOptionsToRender(this._element), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._selectionModel.clear(), this._setDefaultSelections(), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this.hasSelectAll && this._updateSelectAllState();
      const t2 = this._config.filter && this.filterInput && this.filterInput.value;
      this._isOpen && !t2 ? (this._updateOptionsListTemplate(this._optionsToRender), this._setFirstActiveOption()) : this._isOpen && t2 ? (this._filterOptions(this.filterInput.value), this._setFirstActiveOption()) : this._dropdownContainer = al(this._dropdownContainerId, this._config, this._input.offsetWidth, this._dropdownHeight, this._selectAllOption, this._optionsToRender, this._customContent, this._classes);
    }
    _updateDisabledState() {
      const t2 = d.findOne(ul, this._wrapper);
      this._element.hasAttribute("disabled") ? (this._config.disabled = true, t2.setAttribute("disabled", ""), t2.setAttribute(ro2, "")) : (this._config.disabled = false, t2.removeAttribute("disabled"), t2.removeAttribute(ro2));
    }
    _observeMutationObserver() {
      this._mutationObserver && this._mutationObserver.observe(this._element, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    }
    _disconnectMutationObserver() {
      this.mutationObserver && (this._mutationObserver.disconnect(), this._mutationObserver = null);
    }
    _createSelectAllOption() {
      const t2 = this._selectAllId, e = null, i = true, n = "select-all", o = this._config.selectAllLabel, r = Vo(this.options), a = false, l = false, p = null, u = null, _ = null;
      return new rl(t2, e, i, n, o, r, a, l, p, u, _);
    }
    dispose() {
      this._removeComponentEvents(), this._destroyMaterialSelect(), this._listenToFocusChange(false), y.removeData(this._element, vi2);
    }
    _removeComponentEvents() {
      c.off(this.input, "click"), c.off(this.wrapper, this._handleKeydown.bind(this)), c.off(this.clearButton, "click"), c.off(this.clearButton, "keydown"), c.off(window, "resize", this._handleWindowResize.bind(this));
    }
    _destroyMaterialSelect() {
      this._isOpen && this.close(), this._destroyMaterialTemplate();
    }
    _destroyMaterialTemplate() {
      const t2 = this._wrapper.parentNode, e = d.find("label", this._wrapper);
      t2.appendChild(this._element), e.forEach((i) => {
        t2.appendChild(i);
      }), e.forEach((i) => {
        i.removeAttribute(q);
      }), h.removeClass(this._element, this._classes.initialized), this._element.removeAttribute(hl), t2.removeChild(this._wrapper);
    }
    setValue(t2) {
      this.options.filter((i) => i.selected).forEach((i) => i.nativeOption.selected = false), Array.isArray(t2) ? t2.forEach((i) => {
        this._selectByValue(i);
      }) : this._selectByValue(t2), this._updateSelections();
    }
    _selectByValue(t2) {
      const e = this.options.find((i) => i.value === t2);
      return e ? (e.nativeOption.selected = true, true) : false;
    }
    static jQueryInterface(t2, e) {
      return this.each(function() {
        let i = y.getData(this, vi2);
        const n = typeof t2 == "object" && t2;
        if (!(!i && /dispose/.test(t2)) && (i || (i = new _r(this, n)), typeof t2 == "string")) {
          if (typeof i[t2] > "u")
            throw new TypeError(`No method named "${t2}"`);
          i[t2](e);
        }
      });
    }
    static getInstance(t2) {
      return y.getData(t2, vi2);
    }
    static getOrCreateInstance(t2, e = {}) {
      return this.getInstance(t2) || new this(t2, typeof e == "object" ? e : null);
    }
  };
  var Gs = "chip";
  var fb = `te.${Gs}`;
  var rh = "data-te-chip-close";
  var lo = `[${rh}]`;
  var Li = "chips";
  var Ki = `data-te-${Li}`;
  var fl = `te.${Li}`;
  var Ab = `${Ki}-input-init`;
  var mt = `${Ki}-active`;
  var ml = `${Ki}-initial`;
  var ah = `${Ki}-placeholder`;
  var yb = `${Ki}-input-wrapper`;
  var Wo = "data-te-chip-init";
  var lh = "data-te-chip-close";
  var ch = "data-te-chip-text";
  var wb = `[${mt}]`;
  var Fo = `[${Wo}]`;
  var kb = `${Fo}${wb}`;
  var co = `[${lh}]`;
  var xb = `[${yb}]`;
  var Ob = `[${ch}]`;
  var Sb = `[${ah}]`;
  var Ib = "data-te-input-notch-leading-ref";
  var Db = "data-te-input-notch-middle-ref";
  var $b = `[${Ib}]`;
  var Lb = `[${Db}]`;
  var Vb = {
    inputID: rt("chips-input-"),
    parentSelector: "",
    initialValues: [{ tag: "init1" }, { tag: "init2" }],
    editable: false,
    labelText: "Example label",
    inputClasses: {},
    inputOptions: {}
  };
  var zt = {
    plugins: {
      legend: {
        labels: {
          color: "rgb(102,102,102)"
        }
      }
    }
  };
  var Ti = {
    line: {
      options: __spreadProps(__spreadValues({}, zt), {
        elements: {
          line: {
            backgroundColor: "rgba(59, 112, 202, 0.0)",
            borderColor: "rgb(59, 112, 202)",
            borderWidth: 2,
            tension: 0
          },
          point: {
            borderColor: "rgb(59, 112, 202)",
            backgroundColor: "rgb(59, 112, 202)"
          }
        },
        responsive: true,
        legend: {
          display: true
        },
        tooltips: {
          intersect: false,
          mode: "index"
        },
        datasets: {
          borderColor: "red"
        },
        scales: {
          x: {
            stacked: true,
            grid: {
              display: false
            },
            ticks: {
              fontColor: "rgba(0,0,0, 0.5)"
            }
          },
          y: {
            stacked: false,
            grid: {
              borderDash: [2],
              drawBorder: false,
              zeroLineColor: "rgba(0,0,0,0)",
              zeroLineBorderDash: [2],
              zeroLineBorderDashOffset: [2]
            },
            ticks: {
              fontColor: "rgba(0,0,0, 0.5)"
            }
          }
        }
      })
    },
    bar: {
      options: __spreadProps(__spreadValues({}, zt), {
        backgroundColor: "rgb(59, 112, 202)",
        borderWidth: 0,
        responsive: true,
        legend: {
          display: true
        },
        tooltips: {
          intersect: false,
          mode: "index"
        },
        scales: {
          x: {
            stacked: true,
            grid: {
              display: false
            },
            ticks: {
              fontColor: "rgba(0,0,0, 0.5)"
            }
          },
          y: {
            stacked: true,
            grid: {
              borderDash: [2],
              drawBorder: false,
              zeroLineColor: "rgba(0,0,0,0)",
              zeroLineBorderDash: [2],
              zeroLineBorderDashOffset: [2]
            },
            ticks: {
              fontColor: "rgba(0,0,0, 0.5)"
            }
          }
        }
      })
    },
    pie: {
      options: __spreadProps(__spreadValues({}, zt), {
        elements: {
          arc: { backgroundColor: "rgb(59, 112, 202)" }
        },
        responsive: true,
        legend: {
          display: true
        }
      })
    },
    doughnut: {
      options: __spreadProps(__spreadValues({}, zt), {
        elements: {
          arc: { backgroundColor: "rgb(59, 112, 202)" }
        },
        responsive: true,
        legend: {
          display: true
        }
      })
    },
    polarArea: {
      options: __spreadProps(__spreadValues({}, zt), {
        elements: {
          arc: { backgroundColor: "rgba(59, 112, 202, 0.5)" }
        },
        responsive: true,
        legend: {
          display: true
        }
      })
    },
    radar: {
      options: __spreadProps(__spreadValues({}, zt), {
        elements: {
          line: {
            backgroundColor: "rgba(59, 112, 202, 0.5)",
            borderColor: "rgb(59, 112, 202)",
            borderWidth: 2
          },
          point: {
            borderColor: "rgb(59, 112, 202)",
            backgroundColor: "rgb(59, 112, 202)"
          }
        },
        responsive: true,
        legend: {
          display: true
        }
      })
    },
    scatter: {
      options: __spreadProps(__spreadValues({}, zt), {
        elements: {
          line: {
            backgroundColor: "rgba(59, 112, 202, 0.5)",
            borderColor: "rgb(59, 112, 202)",
            borderWidth: 2,
            tension: 0
          },
          point: {
            borderColor: "rgb(59, 112, 202)",
            backgroundColor: "rgba(59, 112, 202, 0.5)"
          }
        },
        responsive: true,
        legend: {
          display: true
        },
        tooltips: {
          intersect: false,
          mode: "index"
        },
        datasets: {
          borderColor: "red"
        },
        scales: {
          x: {
            stacked: true,
            grid: {
              display: false
            },
            ticks: {
              fontColor: "rgba(0,0,0, 0.5)"
            }
          },
          y: {
            stacked: false,
            grid: {
              borderDash: [2],
              drawBorder: false,
              zeroLineColor: "rgba(0,0,0,0)",
              zeroLineBorderDash: [2],
              zeroLineBorderDashOffset: [2]
            },
            ticks: {
              fontColor: "rgba(0,0,0, 0.5)"
            }
          }
        }
      })
    },
    bubble: {
      options: __spreadProps(__spreadValues({}, zt), {
        elements: {
          point: {
            borderColor: "rgb(59, 112, 202)",
            backgroundColor: "rgba(59, 112, 202, 0.5)"
          }
        },
        responsive: true,
        legend: {
          display: true
        },
        scales: {
          x: {
            grid: {
              display: false
            },
            ticks: {
              fontColor: "rgba(0,0,0, 0.5)"
            }
          },
          y: {
            grid: {
              borderDash: [2],
              drawBorder: false,
              zeroLineColor: "rgba(0,0,0,0)",
              zeroLineBorderDash: [2],
              zeroLineBorderDashOffset: [2]
            },
            ticks: {
              fontColor: "rgba(0,0,0, 0.5)"
            }
          }
        }
      })
    }
  };
  var Yb = function(t2) {
    return jb(t2) && !Kb(t2);
  };
  function jb(s) {
    return !!s && typeof s == "object";
  }
  function Kb(s) {
    var t2 = Object.prototype.toString.call(s);
    return t2 === "[object RegExp]" || t2 === "[object Date]" || Xb(s);
  }
  var zb = typeof Symbol == "function" && Symbol.for;
  var Ub = zb ? Symbol.for("react.element") : 60103;
  function Xb(s) {
    return s.$$typeof === Ub;
  }
  function Gb(s) {
    return Array.isArray(s) ? [] : {};
  }
  function Bi(s, t2) {
    return t2.clone !== false && t2.isMergeableObject(s) ? Qe(Gb(s), s, t2) : s;
  }
  function qb(s, t2, e) {
    return s.concat(t2).map(function(i) {
      return Bi(i, e);
    });
  }
  function Zb(s, t2) {
    if (!t2.customMerge)
      return Qe;
    var e = t2.customMerge(s);
    return typeof e == "function" ? e : Qe;
  }
  function Qb(s) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(s).filter(function(t2) {
      return Object.propertyIsEnumerable.call(s, t2);
    }) : [];
  }
  function vl(s) {
    return Object.keys(s).concat(Qb(s));
  }
  function hh(s, t2) {
    try {
      return t2 in s;
    } catch (e) {
      return false;
    }
  }
  function Jb(s, t2) {
    return hh(s, t2) && !(Object.hasOwnProperty.call(s, t2) && Object.propertyIsEnumerable.call(s, t2));
  }
  function tv(s, t2, e) {
    var i = {};
    return e.isMergeableObject(s) && vl(s).forEach(function(n) {
      i[n] = Bi(s[n], e);
    }), vl(t2).forEach(function(n) {
      Jb(s, n) || (hh(s, n) && e.isMergeableObject(t2[n]) ? i[n] = Zb(n, e)(s[n], t2[n], e) : i[n] = Bi(t2[n], e));
    }), i;
  }
  function Qe(s, t2, e) {
    e = e || {}, e.arrayMerge = e.arrayMerge || qb, e.isMergeableObject = e.isMergeableObject || Yb, e.cloneUnlessOtherwiseSpecified = Bi;
    var i = Array.isArray(t2), n = Array.isArray(s), o = i === n;
    return o ? i ? e.arrayMerge(s, t2, e) : tv(s, t2, e) : Bi(t2, e);
  }
  Qe.all = function(t2, e) {
    if (!Array.isArray(t2))
      throw new Error("first argument should be an array");
    return t2.reduce(function(i, n) {
      return Qe(i, n, e);
    }, {});
  };
  function Lt(s) {
    return getComputedStyle(s);
  }
  function ot(s, t2) {
    for (var e in t2) {
      var i = t2[e];
      typeof i == "number" && (i = i + "px"), s.style[e] = i;
    }
    return s;
  }
  function ws(s) {
    var t2 = document.createElement("div");
    return t2.className = s, t2;
  }
  var El = typeof Element < "u" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
  function Qt(s, t2) {
    if (!El)
      throw new Error("No element matching method supported");
    return El.call(s, t2);
  }
  function Pe(s) {
    s.remove ? s.remove() : s.parentNode && s.parentNode.removeChild(s);
  }
  function Cl(s, t2) {
    return Array.prototype.filter.call(s.children, function(e) {
      return Qt(e, t2);
    });
  }
  var j = {
    main: "ps",
    rtl: "ps__rtl",
    element: {
      thumb: function(s) {
        return "ps__thumb-" + s;
      },
      rail: function(s) {
        return "ps__rail-" + s;
      },
      consuming: "ps__child--consume"
    },
    state: {
      focus: "ps--focus",
      clicking: "ps--clicking",
      active: function(s) {
        return "ps--active-" + s;
      },
      scrolling: function(s) {
        return "ps--scrolling-" + s;
      }
    }
  };
  var uh = { x: null, y: null };
  function ph(s, t2) {
    var e = s.element.classList, i = j.state.scrolling(t2);
    e.contains(i) ? clearTimeout(uh[t2]) : e.add(i);
  }
  function _h(s, t2) {
    uh[t2] = setTimeout(function() {
      return s.isAlive && s.element.classList.remove(j.state.scrolling(t2));
    }, s.settings.scrollingThreshold);
  }
  function ov(s, t2) {
    ph(s, t2), _h(s, t2);
  }
  var zi = function(t2) {
    this.element = t2, this.handlers = {};
  };
  var fh = { isEmpty: { configurable: true } };
  zi.prototype.bind = function(t2, e) {
    typeof this.handlers[t2] > "u" && (this.handlers[t2] = []), this.handlers[t2].push(e), this.element.addEventListener(t2, e, false);
  };
  zi.prototype.unbind = function(t2, e) {
    var i = this;
    this.handlers[t2] = this.handlers[t2].filter(function(n) {
      return e && n !== e ? true : (i.element.removeEventListener(t2, n, false), false);
    });
  };
  zi.prototype.unbindAll = function() {
    for (var t2 in this.handlers)
      this.unbind(t2);
  };
  fh.isEmpty.get = function() {
    var s = this;
    return Object.keys(this.handlers).every(function(t2) {
      return s.handlers[t2].length === 0;
    });
  };
  Object.defineProperties(zi.prototype, fh);
  var si = function() {
    this.eventElements = [];
  };
  si.prototype.eventElement = function(t2) {
    var e = this.eventElements.filter(function(i) {
      return i.element === t2;
    })[0];
    return e || (e = new zi(t2), this.eventElements.push(e)), e;
  };
  si.prototype.bind = function(t2, e, i) {
    this.eventElement(t2).bind(e, i);
  };
  si.prototype.unbind = function(t2, e, i) {
    var n = this.eventElement(t2);
    n.unbind(e, i), n.isEmpty && this.eventElements.splice(this.eventElements.indexOf(n), 1);
  };
  si.prototype.unbindAll = function() {
    this.eventElements.forEach(function(t2) {
      return t2.unbindAll();
    }), this.eventElements = [];
  };
  si.prototype.once = function(t2, e, i) {
    var n = this.eventElement(t2), o = function(r) {
      n.unbind(e, o), i(r);
    };
    n.bind(e, o);
  };
  function ks(s) {
    if (typeof window.CustomEvent == "function")
      return new CustomEvent(s);
    var t2 = document.createEvent("CustomEvent");
    return t2.initCustomEvent(s, false, false, void 0), t2;
  }
  function on2(s, t2, e, i, n) {
    i === void 0 && (i = true), n === void 0 && (n = false);
    var o;
    if (t2 === "top")
      o = [
        "contentHeight",
        "containerHeight",
        "scrollTop",
        "y",
        "up",
        "down"
      ];
    else if (t2 === "left")
      o = [
        "contentWidth",
        "containerWidth",
        "scrollLeft",
        "x",
        "left",
        "right"
      ];
    else
      throw new Error("A proper axis should be provided");
    rv(s, e, o, i, n);
  }
  function rv(s, t2, e, i, n) {
    var o = e[0], r = e[1], a = e[2], l = e[3], p = e[4], u = e[5];
    i === void 0 && (i = true), n === void 0 && (n = false);
    var _ = s.element;
    s.reach[l] = null, _[a] < 1 && (s.reach[l] = "start"), _[a] > s[o] - s[r] - 1 && (s.reach[l] = "end"), t2 && (_.dispatchEvent(ks("ps-scroll-" + l)), t2 < 0 ? _.dispatchEvent(ks("ps-scroll-" + p)) : t2 > 0 && _.dispatchEvent(ks("ps-scroll-" + u)), i && ov(s, l)), s.reach[l] && (t2 || n) && _.dispatchEvent(ks("ps-" + l + "-reach-" + s.reach[l]));
  }
  function W(s) {
    return parseInt(s, 10) || 0;
  }
  function av(s) {
    return Qt(s, "input,[contenteditable]") || Qt(s, "select,[contenteditable]") || Qt(s, "textarea,[contenteditable]") || Qt(s, "button,[contenteditable]");
  }
  function lv(s) {
    var t2 = Lt(s);
    return W(t2.width) + W(t2.paddingLeft) + W(t2.paddingRight) + W(t2.borderLeftWidth) + W(t2.borderRightWidth);
  }
  var Ne = {
    isWebKit: typeof document < "u" && "WebkitAppearance" in document.documentElement.style,
    supportsTouch: typeof window < "u" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
    supportsIePointer: typeof navigator < "u" && navigator.msMaxTouchPoints,
    isChrome: typeof navigator < "u" && /Chrome/i.test(navigator && navigator.userAgent)
  };
  function Bt(s) {
    var t2 = s.element, e = Math.floor(t2.scrollTop), i = t2.getBoundingClientRect();
    s.containerWidth = Math.round(i.width), s.containerHeight = Math.round(i.height), s.contentWidth = t2.scrollWidth, s.contentHeight = t2.scrollHeight, t2.contains(s.scrollbarXRail) || (Cl(t2, j.element.rail("x")).forEach(function(n) {
      return Pe(n);
    }), t2.appendChild(s.scrollbarXRail)), t2.contains(s.scrollbarYRail) || (Cl(t2, j.element.rail("y")).forEach(function(n) {
      return Pe(n);
    }), t2.appendChild(s.scrollbarYRail)), !s.settings.suppressScrollX && s.containerWidth + s.settings.scrollXMarginOffset < s.contentWidth ? (s.scrollbarXActive = true, s.railXWidth = s.containerWidth - s.railXMarginWidth, s.railXRatio = s.containerWidth / s.railXWidth, s.scrollbarXWidth = Al(s, W(s.railXWidth * s.containerWidth / s.contentWidth)), s.scrollbarXLeft = W((s.negativeScrollAdjustment + t2.scrollLeft) * (s.railXWidth - s.scrollbarXWidth) / (s.contentWidth - s.containerWidth))) : s.scrollbarXActive = false, !s.settings.suppressScrollY && s.containerHeight + s.settings.scrollYMarginOffset < s.contentHeight ? (s.scrollbarYActive = true, s.railYHeight = s.containerHeight - s.railYMarginHeight, s.railYRatio = s.containerHeight / s.railYHeight, s.scrollbarYHeight = Al(s, W(s.railYHeight * s.containerHeight / s.contentHeight)), s.scrollbarYTop = W(e * (s.railYHeight - s.scrollbarYHeight) / (s.contentHeight - s.containerHeight))) : s.scrollbarYActive = false, s.scrollbarXLeft >= s.railXWidth - s.scrollbarXWidth && (s.scrollbarXLeft = s.railXWidth - s.scrollbarXWidth), s.scrollbarYTop >= s.railYHeight - s.scrollbarYHeight && (s.scrollbarYTop = s.railYHeight - s.scrollbarYHeight), cv(t2, s), s.scrollbarXActive ? t2.classList.add(j.state.active("x")) : (t2.classList.remove(j.state.active("x")), s.scrollbarXWidth = 0, s.scrollbarXLeft = 0, t2.scrollLeft = s.isRtl === true ? s.contentWidth : 0), s.scrollbarYActive ? t2.classList.add(j.state.active("y")) : (t2.classList.remove(j.state.active("y")), s.scrollbarYHeight = 0, s.scrollbarYTop = 0, t2.scrollTop = 0);
  }
  function Al(s, t2) {
    return s.settings.minScrollbarLength && (t2 = Math.max(t2, s.settings.minScrollbarLength)), s.settings.maxScrollbarLength && (t2 = Math.min(t2, s.settings.maxScrollbarLength)), t2;
  }
  function cv(s, t2) {
    var e = { width: t2.railXWidth }, i = Math.floor(s.scrollTop);
    t2.isRtl ? e.left = t2.negativeScrollAdjustment + s.scrollLeft + t2.containerWidth - t2.contentWidth : e.left = s.scrollLeft, t2.isScrollbarXUsingBottom ? e.bottom = t2.scrollbarXBottom - i : e.top = t2.scrollbarXTop + i, ot(t2.scrollbarXRail, e);
    var n = { top: i, height: t2.railYHeight };
    t2.isScrollbarYUsingRight ? t2.isRtl ? n.right = t2.contentWidth - (t2.negativeScrollAdjustment + s.scrollLeft) - t2.scrollbarYRight - t2.scrollbarYOuterWidth - 9 : n.right = t2.scrollbarYRight - s.scrollLeft : t2.isRtl ? n.left = t2.negativeScrollAdjustment + s.scrollLeft + t2.containerWidth * 2 - t2.contentWidth - t2.scrollbarYLeft - t2.scrollbarYOuterWidth : n.left = t2.scrollbarYLeft + s.scrollLeft, ot(t2.scrollbarYRail, n), ot(t2.scrollbarX, {
      left: t2.scrollbarXLeft,
      width: t2.scrollbarXWidth - t2.railBorderXWidth
    }), ot(t2.scrollbarY, {
      top: t2.scrollbarYTop,
      height: t2.scrollbarYHeight - t2.railBorderYWidth
    });
  }
  function hv(s) {
    s.element, s.event.bind(s.scrollbarY, "mousedown", function(t2) {
      return t2.stopPropagation();
    }), s.event.bind(s.scrollbarYRail, "mousedown", function(t2) {
      var e = t2.pageY - window.pageYOffset - s.scrollbarYRail.getBoundingClientRect().top, i = e > s.scrollbarYTop ? 1 : -1;
      s.element.scrollTop += i * s.containerHeight, Bt(s), t2.stopPropagation();
    }), s.event.bind(s.scrollbarX, "mousedown", function(t2) {
      return t2.stopPropagation();
    }), s.event.bind(s.scrollbarXRail, "mousedown", function(t2) {
      var e = t2.pageX - window.pageXOffset - s.scrollbarXRail.getBoundingClientRect().left, i = e > s.scrollbarXLeft ? 1 : -1;
      s.element.scrollLeft += i * s.containerWidth, Bt(s), t2.stopPropagation();
    });
  }
  function dv(s) {
    yl(s, [
      "containerWidth",
      "contentWidth",
      "pageX",
      "railXWidth",
      "scrollbarX",
      "scrollbarXWidth",
      "scrollLeft",
      "x",
      "scrollbarXRail"
    ]), yl(s, [
      "containerHeight",
      "contentHeight",
      "pageY",
      "railYHeight",
      "scrollbarY",
      "scrollbarYHeight",
      "scrollTop",
      "y",
      "scrollbarYRail"
    ]);
  }
  function yl(s, t2) {
    var e = t2[0], i = t2[1], n = t2[2], o = t2[3], r = t2[4], a = t2[5], l = t2[6], p = t2[7], u = t2[8], _ = s.element, f = null, g = null, m = null;
    function b(w) {
      w.touches && w.touches[0] && (w[n] = w.touches[0].pageY), _[l] = f + m * (w[n] - g), ph(s, p), Bt(s), w.stopPropagation(), w.type.startsWith("touch") && w.changedTouches.length > 1 && w.preventDefault();
    }
    function v() {
      _h(s, p), s[u].classList.remove(j.state.clicking), s.event.unbind(s.ownerDocument, "mousemove", b);
    }
    function C2(w, E) {
      f = _[l], E && w.touches && (w[n] = w.touches[0].pageY), g = w[n], m = (s[i] - s[e]) / (s[o] - s[a]), E ? s.event.bind(s.ownerDocument, "touchmove", b) : (s.event.bind(s.ownerDocument, "mousemove", b), s.event.once(s.ownerDocument, "mouseup", v), w.preventDefault()), s[u].classList.add(j.state.clicking), w.stopPropagation();
    }
    s.event.bind(s[r], "mousedown", function(w) {
      C2(w);
    }), s.event.bind(s[r], "touchstart", function(w) {
      C2(w, true);
    });
  }
  function uv(s) {
    var t2 = s.element, e = function() {
      return Qt(t2, ":hover");
    }, i = function() {
      return Qt(s.scrollbarX, ":focus") || Qt(s.scrollbarY, ":focus");
    };
    function n(o, r) {
      var a = Math.floor(t2.scrollTop);
      if (o === 0) {
        if (!s.scrollbarYActive)
          return false;
        if (a === 0 && r > 0 || a >= s.contentHeight - s.containerHeight && r < 0)
          return !s.settings.wheelPropagation;
      }
      var l = t2.scrollLeft;
      if (r === 0) {
        if (!s.scrollbarXActive)
          return false;
        if (l === 0 && o < 0 || l >= s.contentWidth - s.containerWidth && o > 0)
          return !s.settings.wheelPropagation;
      }
      return true;
    }
    s.event.bind(s.ownerDocument, "keydown", function(o) {
      if (!(o.isDefaultPrevented && o.isDefaultPrevented() || o.defaultPrevented) && !(!e() && !i())) {
        var r = document.activeElement ? document.activeElement : s.ownerDocument.activeElement;
        if (r) {
          if (r.tagName === "IFRAME")
            r = r.contentDocument.activeElement;
          else
            for (; r.shadowRoot; )
              r = r.shadowRoot.activeElement;
          if (av(r))
            return;
        }
        var a = 0, l = 0;
        switch (o.which) {
          case 37:
            o.metaKey ? a = -s.contentWidth : o.altKey ? a = -s.containerWidth : a = -30;
            break;
          case 38:
            o.metaKey ? l = s.contentHeight : o.altKey ? l = s.containerHeight : l = 30;
            break;
          case 39:
            o.metaKey ? a = s.contentWidth : o.altKey ? a = s.containerWidth : a = 30;
            break;
          case 40:
            o.metaKey ? l = -s.contentHeight : o.altKey ? l = -s.containerHeight : l = -30;
            break;
          case 32:
            o.shiftKey ? l = s.containerHeight : l = -s.containerHeight;
            break;
          case 33:
            l = s.containerHeight;
            break;
          case 34:
            l = -s.containerHeight;
            break;
          case 36:
            l = s.contentHeight;
            break;
          case 35:
            l = -s.contentHeight;
            break;
          default:
            return;
        }
        s.settings.suppressScrollX && a !== 0 || s.settings.suppressScrollY && l !== 0 || (t2.scrollTop -= l, t2.scrollLeft += a, Bt(s), n(a, l) && o.preventDefault());
      }
    });
  }
  function pv(s) {
    var t2 = s.element;
    function e(r, a) {
      var l = Math.floor(t2.scrollTop), p = t2.scrollTop === 0, u = l + t2.offsetHeight === t2.scrollHeight, _ = t2.scrollLeft === 0, f = t2.scrollLeft + t2.offsetWidth === t2.scrollWidth, g;
      return Math.abs(a) > Math.abs(r) ? g = p || u : g = _ || f, g ? !s.settings.wheelPropagation : true;
    }
    function i(r) {
      var a = r.deltaX, l = -1 * r.deltaY;
      return (typeof a > "u" || typeof l > "u") && (a = -1 * r.wheelDeltaX / 6, l = r.wheelDeltaY / 6), r.deltaMode && r.deltaMode === 1 && (a *= 10, l *= 10), a !== a && l !== l && (a = 0, l = r.wheelDelta), r.shiftKey ? [-l, -a] : [a, l];
    }
    function n(r, a, l) {
      if (!Ne.isWebKit && t2.querySelector("select:focus"))
        return true;
      if (!t2.contains(r))
        return false;
      for (var p = r; p && p !== t2; ) {
        if (p.classList.contains(j.element.consuming))
          return true;
        var u = Lt(p);
        if (l && u.overflowY.match(/(scroll|auto)/)) {
          var _ = p.scrollHeight - p.clientHeight;
          if (_ > 0 && (p.scrollTop > 0 && l < 0 || p.scrollTop < _ && l > 0))
            return true;
        }
        if (a && u.overflowX.match(/(scroll|auto)/)) {
          var f = p.scrollWidth - p.clientWidth;
          if (f > 0 && (p.scrollLeft > 0 && a < 0 || p.scrollLeft < f && a > 0))
            return true;
        }
        p = p.parentNode;
      }
      return false;
    }
    function o(r) {
      var a = i(r), l = a[0], p = a[1];
      if (!n(r.target, l, p)) {
        var u = false;
        s.settings.useBothWheelAxes ? s.scrollbarYActive && !s.scrollbarXActive ? (p ? t2.scrollTop -= p * s.settings.wheelSpeed : t2.scrollTop += l * s.settings.wheelSpeed, u = true) : s.scrollbarXActive && !s.scrollbarYActive && (l ? t2.scrollLeft += l * s.settings.wheelSpeed : t2.scrollLeft -= p * s.settings.wheelSpeed, u = true) : (t2.scrollTop -= p * s.settings.wheelSpeed, t2.scrollLeft += l * s.settings.wheelSpeed), Bt(s), u = u || e(l, p), u && !r.ctrlKey && (r.stopPropagation(), r.preventDefault());
      }
    }
    typeof window.onwheel < "u" ? s.event.bind(t2, "wheel", o) : typeof window.onmousewheel < "u" && s.event.bind(t2, "mousewheel", o);
  }
  function _v(s) {
    if (!Ne.supportsTouch && !Ne.supportsIePointer)
      return;
    var t2 = s.element;
    function e(m, b) {
      var v = Math.floor(t2.scrollTop), C2 = t2.scrollLeft, w = Math.abs(m), E = Math.abs(b);
      if (E > w) {
        if (b < 0 && v === s.contentHeight - s.containerHeight || b > 0 && v === 0)
          return window.scrollY === 0 && b > 0 && Ne.isChrome;
      } else if (w > E && (m < 0 && C2 === s.contentWidth - s.containerWidth || m > 0 && C2 === 0))
        return true;
      return true;
    }
    function i(m, b) {
      t2.scrollTop -= b, t2.scrollLeft -= m, Bt(s);
    }
    var n = {}, o = 0, r = {}, a = null;
    function l(m) {
      return m.targetTouches ? m.targetTouches[0] : m;
    }
    function p(m) {
      return m.pointerType && m.pointerType === "pen" && m.buttons === 0 ? false : !!(m.targetTouches && m.targetTouches.length === 1 || m.pointerType && m.pointerType !== "mouse" && m.pointerType !== m.MSPOINTER_TYPE_MOUSE);
    }
    function u(m) {
      if (p(m)) {
        var b = l(m);
        n.pageX = b.pageX, n.pageY = b.pageY, o = (/* @__PURE__ */ new Date()).getTime(), a !== null && clearInterval(a);
      }
    }
    function _(m, b, v) {
      if (!t2.contains(m))
        return false;
      for (var C2 = m; C2 && C2 !== t2; ) {
        if (C2.classList.contains(j.element.consuming))
          return true;
        var w = Lt(C2);
        if (v && w.overflowY.match(/(scroll|auto)/)) {
          var E = C2.scrollHeight - C2.clientHeight;
          if (E > 0 && (C2.scrollTop > 0 && v < 0 || C2.scrollTop < E && v > 0))
            return true;
        }
        if (b && w.overflowX.match(/(scroll|auto)/)) {
          var T = C2.scrollWidth - C2.clientWidth;
          if (T > 0 && (C2.scrollLeft > 0 && b < 0 || C2.scrollLeft < T && b > 0))
            return true;
        }
        C2 = C2.parentNode;
      }
      return false;
    }
    function f(m) {
      if (p(m)) {
        var b = l(m), v = { pageX: b.pageX, pageY: b.pageY }, C2 = v.pageX - n.pageX, w = v.pageY - n.pageY;
        if (_(m.target, C2, w))
          return;
        i(C2, w), n = v;
        var E = (/* @__PURE__ */ new Date()).getTime(), T = E - o;
        T > 0 && (r.x = C2 / T, r.y = w / T, o = E), e(C2, w) && m.preventDefault();
      }
    }
    function g() {
      s.settings.swipeEasing && (clearInterval(a), a = setInterval(function() {
        if (s.isInitialized) {
          clearInterval(a);
          return;
        }
        if (!r.x && !r.y) {
          clearInterval(a);
          return;
        }
        if (Math.abs(r.x) < 0.01 && Math.abs(r.y) < 0.01) {
          clearInterval(a);
          return;
        }
        if (!s.element) {
          clearInterval(a);
          return;
        }
        i(r.x * 30, r.y * 30), r.x *= 0.8, r.y *= 0.8;
      }, 10));
    }
    Ne.supportsTouch ? (s.event.bind(t2, "touchstart", u), s.event.bind(t2, "touchmove", f), s.event.bind(t2, "touchend", g)) : Ne.supportsIePointer && (window.PointerEvent ? (s.event.bind(t2, "pointerdown", u), s.event.bind(t2, "pointermove", f), s.event.bind(t2, "pointerup", g)) : window.MSPointerEvent && (s.event.bind(t2, "MSPointerDown", u), s.event.bind(t2, "MSPointerMove", f), s.event.bind(t2, "MSPointerUp", g)));
  }
  var fv = function() {
    return {
      handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
      maxScrollbarLength: null,
      minScrollbarLength: null,
      scrollingThreshold: 1e3,
      scrollXMarginOffset: 0,
      scrollYMarginOffset: 0,
      suppressScrollX: false,
      suppressScrollY: false,
      swipeEasing: true,
      useBothWheelAxes: false,
      wheelPropagation: true,
      wheelSpeed: 1
    };
  };
  var mv = {
    "click-rail": hv,
    "drag-thumb": dv,
    keyboard: uv,
    wheel: pv,
    touch: _v
  };
  var Ui = function(t2, e) {
    var i = this;
    if (e === void 0 && (e = {}), typeof t2 == "string" && (t2 = document.querySelector(t2)), !t2 || !t2.nodeName)
      throw new Error("no element is specified to initialize PerfectScrollbar");
    this.element = t2, t2.classList.add(j.main), this.settings = fv();
    for (var n in e)
      this.settings[n] = e[n];
    this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
    var o = function() {
      return t2.classList.add(j.state.focus);
    }, r = function() {
      return t2.classList.remove(j.state.focus);
    };
    this.isRtl = Lt(t2).direction === "rtl", this.isRtl === true && t2.classList.add(j.rtl), this.isNegativeScroll = function() {
      var p = t2.scrollLeft, u = null;
      return t2.scrollLeft = -1, u = t2.scrollLeft < 0, t2.scrollLeft = p, u;
    }(), this.negativeScrollAdjustment = this.isNegativeScroll ? t2.scrollWidth - t2.clientWidth : 0, this.event = new si(), this.ownerDocument = t2.ownerDocument || document, this.scrollbarXRail = ws(j.element.rail("x")), t2.appendChild(this.scrollbarXRail), this.scrollbarX = ws(j.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", o), this.event.bind(this.scrollbarX, "blur", r), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
    var a = Lt(this.scrollbarXRail);
    this.scrollbarXBottom = parseInt(a.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = false, this.scrollbarXTop = W(a.top)) : this.isScrollbarXUsingBottom = true, this.railBorderXWidth = W(a.borderLeftWidth) + W(a.borderRightWidth), ot(this.scrollbarXRail, { display: "block" }), this.railXMarginWidth = W(a.marginLeft) + W(a.marginRight), ot(this.scrollbarXRail, { display: "" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = ws(j.element.rail("y")), t2.appendChild(this.scrollbarYRail), this.scrollbarY = ws(j.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", o), this.event.bind(this.scrollbarY, "blur", r), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
    var l = Lt(this.scrollbarYRail);
    this.scrollbarYRight = parseInt(l.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = false, this.scrollbarYLeft = W(l.left)) : this.isScrollbarYUsingRight = true, this.scrollbarYOuterWidth = this.isRtl ? lv(this.scrollbarY) : null, this.railBorderYWidth = W(l.borderTopWidth) + W(l.borderBottomWidth), ot(this.scrollbarYRail, { display: "block" }), this.railYMarginHeight = W(l.marginTop) + W(l.marginBottom), ot(this.scrollbarYRail, { display: "" }), this.railYHeight = null, this.railYRatio = null, this.reach = {
      x: t2.scrollLeft <= 0 ? "start" : t2.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
      y: t2.scrollTop <= 0 ? "start" : t2.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
    }, this.isAlive = true, this.settings.handlers.forEach(function(p) {
      return mv[p](i);
    }), this.lastScrollTop = Math.floor(t2.scrollTop), this.lastScrollLeft = t2.scrollLeft, this.event.bind(this.element, "scroll", function(p) {
      return i.onScroll(p);
    }), Bt(this);
  };
  Ui.prototype.update = function() {
    this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, ot(this.scrollbarXRail, { display: "block" }), ot(this.scrollbarYRail, { display: "block" }), this.railXMarginWidth = W(Lt(this.scrollbarXRail).marginLeft) + W(Lt(this.scrollbarXRail).marginRight), this.railYMarginHeight = W(Lt(this.scrollbarYRail).marginTop) + W(Lt(this.scrollbarYRail).marginBottom), ot(this.scrollbarXRail, { display: "none" }), ot(this.scrollbarYRail, { display: "none" }), Bt(this), on2(this, "top", 0, false, true), on2(this, "left", 0, false, true), ot(this.scrollbarXRail, { display: "" }), ot(this.scrollbarYRail, { display: "" }));
  };
  Ui.prototype.onScroll = function(t2) {
    this.isAlive && (Bt(this), on2(this, "top", this.element.scrollTop - this.lastScrollTop), on2(this, "left", this.element.scrollLeft - this.lastScrollLeft), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);
  };
  Ui.prototype.destroy = function() {
    this.isAlive && (this.event.unbindAll(), Pe(this.scrollbarX), Pe(this.scrollbarY), Pe(this.scrollbarXRail), Pe(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = false);
  };
  Ui.prototype.removePsClasses = function() {
    this.element.className = this.element.className.split(" ").filter(function(t2) {
      return !t2.match(/^ps([-_].+|)$/);
    }).join(" ");
  };
  var Ot = "te";
  var St = "ps";
  var _o = [
    { te: `scrollX.${Ot}.${St}`, ps: "ps-scroll-x" },
    { te: `scrollY.${Ot}.${St}`, ps: "ps-scroll-y" },
    { te: `scrollUp.${Ot}.${St}`, ps: "ps-scroll-up" },
    { te: `scrollDown.${Ot}.${St}`, ps: "ps-scroll-down" },
    { te: `scrollLeft.${Ot}.${St}`, ps: "ps-scroll-left" },
    { te: `scrollRight.${Ot}.${St}`, ps: "ps-scroll-right" },
    { te: `scrollXEnd.${Ot}.${St}`, ps: "ps-x-reach-end" },
    { te: `scrollYEnd.${Ot}.${St}`, ps: "ps-y-reach-end" },
    { te: `scrollXStart.${Ot}.${St}`, ps: "ps-x-reach-start" },
    { te: `scrollYStart.${Ot}.${St}`, ps: "ps-y-reach-start" }
  ];
  var Ni = "datatable";
  var ft = `data-te-${Ni}`;
  var Ei = `te.${Ni}`;
  var _n = `.${Ei}`;
  var Vv = `[${ft}-inner-ref]`;
  var fo = `[${ft}-cell-ref]`;
  var Wv = `[${ft}-header-ref]`;
  var Fv = `[${ft}-header-checkbox-ref]`;
  var Yv = `[${ft}-pagination-right-ref]`;
  var jv = `[${ft}-pagination-left-ref]`;
  var Kv = `[${ft}-pagination-start-ref]`;
  var zv = `[${ft}-pagination-end-ref]`;
  var Uv = `[${ft}-pagination-nav-ref]`;
  var Xv = `[${ft}-select-ref]`;
  var mo = `[${ft}-sort-icon-ref]`;
  var fi2 = `[${ft}-row-ref]`;
  var go = `[${ft}-row-checkbox-ref]`;
  var Gv = `selectRows${_n}`;
  var xl = `render${_n}`;
  var qv = `rowClick${_n}`;
  var Zv = `update${_n}`;
  var qs = "te.rating";
  var ni = `.${qs}`;
  var Sl = `onSelect${ni}`;
  var rE = `onHover${ni}`;
  var Il = `keyup${ni}`;
  var Dl = `focusout${ni}`;
  var $l = `keydown${ni}`;
  var Ll = `mousedown${ni}`;
  var Ci = "te.popconfirm";
  var bh = `.${Ci}`;
  var aE = `cancel${bh}`;
  var lE = `confirm${bh}`;
  var Ai = "te.lightbox";
  var fE = `.${Ai}`;
  var mE = ".data-api";
  var Ie = `click${fE}${mE}`;
  var Th = "[data-te-lightbox-init]";
  var gE = `${Th} img:not([data-te-lightbox-disabled])`;
  var IE = {
    isRequired: "This is required",
    isEmail: "Please enter a valid email address",
    isLongerThan: "This field must be longer than {length} characters",
    isShorterThan: "This field must be shorter than {length} characters",
    isChecked: "This is required",
    isPhone: "Please enter a valid phone number",
    isNumber: "Expected value with type Number",
    isString: "Expected value with type String",
    isBoolean: "Expected value with type Boolean",
    isDate: "Please enter a valid date",
    is12hFormat: "Please enter a valid time in 12h format",
    is24hFormat: "Please enter a valid time in 24h format"
  };
  var DE = {
    isRequired: (s, t2) => (s == null ? void 0 : s.trim()) ? true : t2,
    isEmail: (s, t2) => /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(s) ? true : t2,
    isLongerThan: (s, t2, e) => s.length > e ? true : t2.replace("{length}", e),
    isShorterThan: (s, t2, e) => s.length < e ? true : t2.replace("{length}", e),
    isChecked: (s) => s ? true : "This is required",
    isPhone: (s, t2) => s.length === 9 ? true : t2,
    isNumber: (s, t2) => s && !isNaN(Number(s)) ? true : t2,
    isString: (s, t2) => typeof s == "string" ? true : t2,
    isBoolean: (s, t2) => typeof s == "boolean" ? true : t2,
    isDate: (s, t2) => {
      const e = /^([0-9]{1,2})\/([0-9]{1,2})\/([0-9]{4})$/;
      return s.match(e) ? true : t2;
    },
    is12hFormat: (s, t2) => {
      const e = /^(0?[1-9]|1[0-2]):[0-5][0-9] [APap][mM]$/;
      return s.match(e) ? true : t2;
    },
    is24hFormat: (s, t2) => {
      const e = /^(?:[01]\d|2[0-3]):[0-5][0-9]$/;
      return s.match(e) ? true : t2;
    }
  };
  var Eo = "validation";
  var jo = "te.validation";
  var fn = `.${jo}`;
  var Eh = "data-te-validate";
  var Os = "data-te-validated";
  var Ss = "data-te-validation-state";
  var Is = "data-te-validation-feedback";
  var Co = "data-te-valid-feedback";
  var Ds = "data-te-invalid-feedback";
  var Rl = "data-te-validation-ruleset";
  var $E = "data-te-submit-btn-ref";
  var LE = `[${Eh}]`;
  var NE = "[data-te-input-notch-ref] div";
  var ME = `[${$E}]`;
  var RE = `validated${fn}`;
  var PE = `valid${fn}`;
  var BE = `invalid${fn}`;
  var HE = `changed${fn}`;
  var VE = {
    validFeedback: "string",
    invalidFeedback: "string",
    disableFeedback: "boolean",
    customRules: "object",
    customErrorMessages: "object",
    activeValidation: "boolean",
    submitCallback: "(function|null)"
  };
  var Pl = {
    validFeedback: "Looks good!",
    invalidFeedback: "Something is wrong!",
    disableFeedback: false,
    customRules: {},
    customErrorMessages: {},
    activeValidation: false,
    submitCallback: null
  };
  var WE = {
    notchLeadingValid: "border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[-1px_0_0_#14a44d,_0_1px_0_0_#14a44d,_0_-1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]",
    notchMiddleValid: "border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[0_1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]",
    notchTrailingValid: "border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[1px_0_0_#14a44d,_0_-1px_0_0_#14a44d,_0_1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]",
    notchLeadingInvalid: "border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[-1px_0_0_#dc4c64,_0_1px_0_0_#dc4c64,_0_-1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]",
    notchMiddleInvalid: "border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[0_1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]",
    notchTrailingInvalid: "border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[1px_0_0_#dc4c64,_0_-1px_0_0_#dc4c64,_0_1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]",
    basicInputValid: "!border-[#14a44d] focus:!border-[#14a44d] focus:!shadow-[inset_0_0_0_1px_#14a44d]",
    basicInputInvalid: "!border-[#dc4c64] focus:!border-[#dc4c64] focus:!shadow-[inset_0_0_0_1px_#dc4c64]",
    checkboxValid: "checked:!border-[#14a44d] checked:!bg-[#14a44d] checked:after:!bg-[#14a44d]",
    checkboxInvalid: "checked:!border-[#dc4c64] checked:!bg-[#dc4c64] checked:after:!bg-[#dc4c64]",
    radioValid: "checked:!border-[#14a44d] checked:after:!bg-[#14a44d]",
    radioInvalid: "checked:!border-[#dc4c64] checked:after:!bg-[#dc4c64]",
    labelValid: "!text-[#14a44d]",
    labelInvalid: "!text-[#dc4c64]",
    validFeedback: "absolute top-full left-0 m-1 w-auto text-sm text-[#14a44d] animate-[fade-in_0.3s_both]",
    invalidFeedback: "absolute top-full left-0 m-1 w-auto text-sm text-[#dc4c64] animate-[fade-in_0.3s_both]",
    elementValidated: "mb-8"
  };
  var FE = {
    notchLeadingValid: "string",
    notchMiddleValid: "string",
    notchTrailingValid: "string",
    notchLeadingInvalid: "string",
    notchMiddleInvalid: "string",
    notchTrailingInvalid: "string",
    basicInputValid: "string",
    basicInputInvalid: "string",
    checkboxValid: "string",
    checkboxInvalid: "string",
    radioValid: "string",
    radioInvalid: "string",
    labelValid: "string",
    labelInvalid: "string",
    validFeedback: "string",
    invalidFeedback: "string",
    elementValidated: "string"
  };
  var Ch = class extends gt {
    constructor(t2, e, i) {
      super(t2), this._element = t2, this._element && y.setData(t2, jo, this), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._isValid = true, this._shouldApplyInputEvents = true, this._submitCallback = null, this._errorMessages = __spreadValues(__spreadValues({}, IE), this._config.customErrorMessages), this._validationElements = this._getValidationElements(), this._validationElements.forEach(({ element: n, input: o }) => {
        this._createFeedbackWrapper(n, o);
      }), this._validationObserver = this._watchForValidationChanges(), this._validationObserver.observe(this._element, { attributes: true }), this._submitButton = null, this._handleSubmitButton(), this._validationResult = [];
    }
    static get DefaultType() {
      return VE;
    }
    static get Default() {
      return Pl;
    }
    static get NAME() {
      return Eo;
    }
    dispose() {
      var t2;
      (t2 = this._validationObserver) == null || t2.disconnect(), this._validationObserver = null, this._submitCallback = null, this._element.removeAttribute(Os), this._removeValidationTraces(), this._validationResult = [], this._submitButton && c.off(this._submitButton, "click"), this._config.activeValidation && (this._validationElements.forEach((e) => {
        const { input: i } = e;
        c.off(i, "input");
      }), this._shouldApplyInputEvents = true);
    }
    _removeValidationTraces() {
      this._removeFeedbackWrapper(), this._validationElements.forEach(({ element: t2, classes: e, initialHTML: i }) => {
        t2.className = e, t2.innerHTML = i, t2.removeAttribute(Ss), t2.removeAttribute(Ds), t2.removeAttribute(Co);
      }), this._validationElements = [];
    }
    _getValidationElements() {
      return d.find(LE, this._element).map((e) => {
        const i = d.findOne("input", e) || d.findOne("textarea", e);
        return {
          id: i.name || i.id || rt("validation-"),
          element: e,
          type: e.getAttribute(Eh),
          input: i,
          validFeedback: e.getAttribute(Co),
          invalidFeedback: e.getAttribute(Ds),
          classes: e.className,
          initialHTML: e.innerHTML,
          ruleset: e.getAttribute(Rl)
        };
      });
    }
    _createFeedbackWrapper(t2, e) {
      if (t2.querySelectorAll(`[${Is}]`).length > 0)
        return;
      const i = document.createElement("span");
      i.setAttribute(Is, ""), e.parentNode.appendChild(i);
    }
    _removeFeedbackWrapper() {
      d.find(`[${Is}]`, this._element).forEach((e) => {
        e.remove();
      });
    }
    _watchForValidationChanges() {
      return new MutationObserver((e) => {
        e.forEach((i) => {
          const { attributeName: n } = i;
          n === Os && (this._handleValidation(), this._config.activeValidation && this._shouldApplyInputEvents && this._applyInputEvents());
        });
      });
    }
    _handleValidation() {
      this._element.getAttribute(Os) && (this._validationResult = [], this._isValid = true, this._validationElements.forEach((t2) => this._validateSingleElement(t2)), this._emitEvents(this._isValid), this._submitCallback && this._submitCallback(this._isValid));
    }
    _validateSingleElement(t2) {
      var p;
      const { element: e, type: i, input: n, ruleset: o, id: r } = t2;
      o && this._validateByRuleset(t2);
      const a = e.getAttribute(Ss);
      if (a !== "valid" && a !== "invalid")
        return;
      const l = a.replace(a.charAt(0), a.charAt(0).toUpperCase());
      i === "input" && this._restyleNotches(e, l), i === "basic" && this._restyleBasicInputs(n, l), (i === "checkbox" || i === "radio") && this._restyleCheckboxes(n, l, i), this._restyleLabels(e, l), a === "invalid" && (this._isValid = false), this._config.disableFeedback || this._applyFeedback(e, a), c.trigger(this._element, HE, {
        value: {
          name: r,
          result: a,
          validation: (p = this._validationResult[r]) == null ? void 0 : p.validation
        }
      });
    }
    _validateByRuleset({ element: t2, type: e, invalidFeedback: i, input: n, id: o }) {
      const r = this._getRuleset(t2);
      if (!r.length)
        return;
      const a = e === "checkbox" || e === "radio" ? n.checked : n.value;
      let l = "", p = [];
      for (const u of r) {
        const _ = u.callback(a, this._errorMessages[u.name] || this._config.invalidFeedback, u.parameter);
        p.push({
          result: _ === true,
          name: u.name,
          fullName: u.fullName
        }), typeof _ == "string" && !l && (l = _);
      }
      if (this._validationResult[o] = { element: t2, validation: p }, !l) {
        t2.setAttribute(Ss, "valid");
        return;
      }
      t2.setAttribute(Ss, "invalid"), i || t2.setAttribute(Ds, l);
    }
    _handleInputChange(t2) {
      this._validateSingleElement(t2);
    }
    _getRuleset(t2) {
      const i = t2.getAttribute(Rl).split("|");
      let n = [];
      const o = __spreadValues(__spreadValues({}, DE), this._config.customRules);
      return i.forEach((r) => {
        const a = this._getRuleData(r, o);
        a.callback ? n.push(a) : console.warn(`Rule ${r} does not exist`);
      }), n;
    }
    _getRuleData(t2, e) {
      const i = t2.split("(");
      return {
        callback: e[i[0]],
        parameter: i[1] ? i[1].split(")")[0] : null,
        name: i[0],
        fullName: t2
      };
    }
    _applyFeedback(t2, e) {
      const i = d.findOne(`[${Is}]`, t2), n = t2.getAttribute(Co) || this._config.validFeedback, o = t2.getAttribute(Ds) || this._config.invalidFeedback;
      h.addClass(t2, this._classes.elementValidated), i.textContent = e === "valid" ? n : o, i.className = this._classes[e === "valid" ? "validFeedback" : "invalidFeedback"];
    }
    _restyleCheckboxes(t2, e, i) {
      h.removeClass(t2, this._classes.checkboxValid), h.removeClass(t2, this._classes.checkboxInvalid), h.addClass(t2, this._classes[`${i}${e}`]);
    }
    _restyleBasicInputs(t2, e) {
      h.removeClass(t2, this._classes.basicInputValid), h.removeClass(t2, this._classes.basicInputInvalid), h.addClass(t2, this._classes[`basicInput${e}`]);
    }
    _restyleNotches(t2, e) {
      d.find(NE, t2).forEach((n, o) => {
        let r = o === 0 ? "notchLeading" : o === 1 ? "notchMiddle" : "notchTrailing";
        n.className = "", h.addClass(n, Kc[r]), r += e, h.addClass(n, this._classes[r]);
      });
    }
    _restyleLabels(t2, e) {
      const i = d.find("label", t2);
      i.length && i.forEach((n) => {
        h.removeClass(n, this._classes.labelValid), h.removeClass(n, this._classes.labelInvalid), h.addClass(n, this._classes[`label${e}`]);
      });
    }
    _emitEvents(t2) {
      if (c.trigger(this._element, RE), t2) {
        c.trigger(this._element, PE, {
          value: this._validationResult
        });
        return;
      }
      c.trigger(this._element, BE, {
        value: this._validationResult
      });
    }
    _applyInputEvents() {
      this._validationElements.forEach((t2) => {
        const { input: e } = t2;
        c.on(e, "input", () => this._handleInputChange(t2));
      }), this._shouldApplyInputEvents = false;
    }
    _handleSubmitButton() {
      this._submitButton = d.findOne(ME, this._element), this._submitButton && c.on(this._submitButton, "click", (t2) => this._handleSubmitButtonClick(t2));
    }
    _handleSubmitButtonClick(t2) {
      if (this._element.setAttribute(Os, true), this._config.submitCallback) {
        this._submitCallback = (e) => this._config.submitCallback(t2, e);
        return;
      }
    }
    _getConfig(t2) {
      return t2 = __spreadValues(__spreadValues(__spreadValues({}, Pl), h.getDataAttributes(this._element)), typeof t2 == "object" && t2 ? t2 : {}), D(Eo, t2, this.constructor.DefaultType), t2;
    }
    _getClasses(t2) {
      const e = h.getDataClassAttributes(this._element);
      return t2 = __spreadValues(__spreadValues(__spreadValues({}, WE), e), t2), D(Eo, t2, FE), t2;
    }
    static getInstance(t2) {
      return y.getData(t2, jo);
    }
    static getOrCreateInstance(t2, e = {}) {
      return this.getInstance(t2) || new this(t2, typeof e == "object" ? e : null);
    }
    static jQueryInterface(t2) {
      return this.each(function() {
        const e = Ch.getOrCreateInstance(this);
        if (typeof t2 == "string") {
          if (e[t2] === void 0 || t2.startsWith("_") || t2 === "constructor")
            throw new TypeError(`No method named "${t2}"`);
          e[t2](this);
        }
      });
    }
  };
  var qt = "pan";
  var ZE = `${qt}start`;
  var QE = `${qt}end`;
  var JE = `${qt}move`;
  var Ye = "pinch";
  var o0 = `${Ye}end`;
  var r0 = `${Ye}start`;
  var a0 = `${Ye}move`;
  var Mi = "rotate";
  var _0 = `${Mi}end`;
  var f0 = `${Mi}start`;
  var Ko = "touch";
  var wo = `te.${Ko}`;
  var zo = "smoothScroll";
  var yi = `te.${zo}`;
  var mr = `.${yi}`;
  var A0 = `scrollStart${mr}`;
  var y0 = `scrollEnd${mr}`;
  var w0 = `scrollCancel${mr}`;
  var wi = "te.clipboard";
  var D0 = `.${wi}`;
  var N0 = `copy${D0}`;
  var Xo = "infiniteScroll";
  var Ls = `te.${Xo}`;
  var Ri = "loadingManagement";
  var Ns = `te.${Ri}`;
  var V0 = `show.te.${Ri}`;
  var Qs = "datetimepicker";
  var ki = `te.${Qs}`;
  var gr = `.${ki}`;
  var Oh = "data-te-datepicker-init";
  var Sh = "data-te-timepicker-init";
  var oC = "data-te-date-timepicker-toggle-ref";
  var aC = "data-te-timepicker-toggle-button-ref";
  var lC = `[${Sh}]`;
  var cC = `[${Oh}]`;
  var hC = `[${oC}]`;
  var dC = `[${aC}]`;
  var mC = `open${gr}`;
  var gC = `close${gr}`;
  var bC = `datetimeChange${gr}`;
  var De = $2("div");
  var Js = "sticky";
  var xi = `te.${Js}`;
  var Dh = `.${xi}`;
  var CC = `active${Dh}`;
  var AC = `inactive${Dh}`;
  var OC = (s) => {
    Zl(() => {
      const t2 = ql();
      if (t2) {
        const e = s.NAME, i = t2.fn[e];
        t2.fn[e] = s.jQueryInterface, t2.fn[e].Constructor = s, t2.fn[e].noConflict = () => (t2.fn[e] = i, s.jQueryInterface);
      }
    });
  };
  var SC = (s, t2) => {
    c.on(document, `click.te.${s.NAME}`, t2, function(e) {
      e.preventDefault(), s.getOrCreateInstance(this).toggle();
    });
  };
  var IC = (s, t2) => {
    c.on(document, `click.te.${s.NAME}.data-api`, t2, function(e) {
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), ge(this))
        return;
      s.getOrCreateInstance(this).show();
    });
  };
  var DC = (s, t2) => {
    c.on(document, `click.te.${s.NAME}.data-api`, t2, function(e) {
      const i = Jt(this);
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), ge(this))
        return;
      c.one(i, s.EVENT_HIDDEN, () => {
        Nt(this) && this.focus();
      });
      const n = d.findOne(s.OPEN_SELECTOR);
      n && n !== i && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);
    });
  };
  var $C = (s, t2) => {
    c.on(document, `click.te.${s.NAME}`, t2, (e) => {
      e.preventDefault();
      const i = e.target.closest(t2);
      s.getOrCreateInstance(i).toggle();
    });
  };
  var LC = (s, t2) => {
    c.on(document, `click.te.${s.NAME}`, t2, function(e) {
      const i = Jt(this);
      ["A", "AREA"].includes(this.tagName) && e.preventDefault(), c.one(i, s.EVENT_SHOW, (r) => {
        r.defaultPrevented || c.one(i, s.EVENT_HIDDEN, () => {
          Nt(this) && this.focus();
        });
      });
      const n = d.findOne(`[${s.OPEN_SELECTOR}="true"]`);
      n && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);
    });
  };
  var NC = (s, t2) => {
    c.one(document, "mousedown", t2, s.autoInitial(new s()));
  };
  var MC = (s, t2) => {
    c.on(document, `click.te.${s.NAME}.data-api`, t2, function(e) {
      (e.target.tagName === "A" || e.delegateTarget && e.delegateTarget.tagName === "A") && e.preventDefault();
      const i = qo(this);
      d.find(i).forEach((o) => {
        s.getOrCreateInstance(o, { toggle: false }).toggle();
      });
    });
  };
  var RC = (s, t2) => {
    [].slice.call(document.querySelectorAll(t2)).map(function(i) {
      return new s(i);
    });
  };
  var PC = (s, t2) => {
    [].slice.call(document.querySelectorAll(t2)).map(function(i) {
      return new s(i);
    });
  };
  var BC = (s, t2) => {
    d.find(t2).forEach((e) => {
      new s(e);
    }), c.on(document, `click.te.${s.NAME}.data-api`, `${t2} img:not([data-te-lightbox-disabled])`, s.toggle());
  };
  var HC = (s, t2) => {
    const e = (o) => o[0] === "{" && o[o.length - 1] === "}" || o[0] === "[" && o[o.length - 1] === "]", i = (o) => typeof o != "string" ? o : e(o) ? JSON.parse(o.replace(/'/g, '"')) : o, n = (o) => {
      const r = {};
      return Object.keys(o).forEach((a) => {
        if (a.match(/dataset.*/)) {
          const l = a.slice(7, 8).toLowerCase().concat(a.slice(8));
          r[l] = i(o[a]);
        }
      }), r;
    };
    d.find(t2).forEach((o) => {
      if (h.getDataAttribute(o, "chart") !== "bubble" && h.getDataAttribute(o, "chart") !== "scatter") {
        const r = h.getDataAttributes(o), a = {
          data: {
            datasets: [n(r)]
          }
        };
        return r.chart && (a.type = r.chart), r.labels && (a.data.labels = JSON.parse(r.labels.replace(/'/g, '"'))), new s(o, __spreadValues(__spreadValues({}, a), Ti[a.type]));
      }
      return null;
    });
  };
  var VC = class {
    constructor() {
      this.inits = [];
    }
    get initialized() {
      return this.inits;
    }
    isInited(t2) {
      return this.inits.includes(t2);
    }
    add(t2) {
      this.isInited(t2) || this.inits.push(t2);
    }
  };
  var Go = new VC();
  var Oi = {
    alert: {
      name: "Alert",
      selector: "[data-te-alert-init]",
      isToggler: false
    },
    animation: {
      name: "Animate",
      selector: "[data-te-animation-init]",
      isToggler: false
    },
    carousel: {
      name: "Carousel",
      selector: "[data-te-carousel-init]",
      isToggler: false
    },
    chips: {
      name: "ChipsInput",
      selector: "[data-te-chips-input-init]",
      isToggler: false
    },
    chip: {
      name: "Chip",
      selector: "[data-te-chip-init]",
      isToggler: false,
      onInit: "init"
    },
    datepicker: {
      name: "Datepicker",
      selector: "[data-te-datepicker-init]",
      isToggler: false
    },
    datetimepicker: {
      name: "Datetimepicker",
      selector: "[data-te-date-timepicker-init]",
      isToggler: false
    },
    input: {
      name: "Input",
      selector: "[data-te-input-wrapper-init]",
      isToggler: false
    },
    perfectScrollbar: {
      name: "PerfectScrollbar",
      selector: "[data-te-perfect-scrollbar-init]",
      isToggler: false
    },
    rating: {
      name: "Rating",
      selector: "[data-te-rating-init]",
      isToggler: false
    },
    scrollspy: {
      name: "ScrollSpy",
      selector: "[data-te-spy='scroll']",
      isToggler: false
    },
    select: {
      name: "Select",
      selector: "[data-te-select-init]",
      isToggler: false
    },
    sidenav: {
      name: "Sidenav",
      selector: "[data-te-sidenav-init]",
      isToggler: false
    },
    stepper: {
      name: "Stepper",
      selector: "[data-te-stepper-init]",
      isToggler: false
    },
    timepicker: {
      name: "Timepicker",
      selector: "[data-te-timepicker-init]",
      isToggler: false
    },
    toast: {
      name: "Toast",
      selector: "[data-te-toast-init]",
      isToggler: false
    },
    datatable: {
      name: "Datatable",
      selector: "[data-te-datatable-init]"
    },
    popconfirm: {
      name: "Popconfirm",
      selector: "[data-te-toggle='popconfirm']"
    },
    validation: {
      name: "Validation",
      selector: "[data-te-validation-init]"
    },
    smoothScroll: {
      name: "SmoothScroll",
      selector: "a[data-te-smooth-scroll-init]"
    },
    lazyLoad: {
      name: "LazyLoad",
      selector: "[data-te-lazy-load-init]"
    },
    clipboard: {
      name: "Clipboard",
      selector: "[data-te-clipboard-init]"
    },
    infiniteScroll: {
      name: "InfiniteScroll",
      selector: "[data-te-infinite-scroll-init]"
    },
    loadingManagement: {
      name: "LoadingManagement",
      selector: "[data-te-loading-management-init]"
    },
    sticky: {
      name: "Sticky",
      selector: "[data-te-sticky-init]"
    },
    chart: {
      name: "Chart",
      selector: "[data-te-chart]",
      isToggler: false,
      advanced: HC
    },
    button: {
      name: "Button",
      selector: "[data-te-toggle='button']",
      isToggler: true,
      callback: $C
    },
    collapse: {
      name: "Collapse",
      selector: "[data-te-collapse-init]",
      isToggler: true,
      callback: MC
    },
    dropdown: {
      name: "Dropdown",
      selector: "[data-te-dropdown-toggle-ref]",
      isToggler: true,
      callback: SC
    },
    modal: {
      name: "Modal",
      selector: "[data-te-toggle='modal']",
      isToggler: true,
      callback: LC
    },
    ripple: {
      name: "Ripple",
      selector: "[data-te-ripple-init]",
      isToggler: true,
      callback: NC
    },
    offcanvas: {
      name: "Offcanvas",
      selector: "[data-te-offcanvas-toggle]",
      isToggler: true,
      callback: DC
    },
    tab: {
      name: "Tab",
      selector: "[data-te-toggle='tab'], [data-te-toggle='pill'], [data-te-toggle='list']",
      isToggler: true,
      callback: IC
    },
    tooltip: {
      name: "Tooltip",
      selector: "[data-te-toggle='tooltip']",
      isToggler: false,
      callback: RC
    },
    popover: {
      name: "Popover",
      selector: "[data-te-toggle='popover']",
      isToggler: true,
      callback: PC
    },
    lightbox: {
      name: "Lightbox",
      selector: "[data-te-lightbox-init]",
      isToggler: true,
      callback: BC
    },
    touch: {
      name: "Touch",
      selector: "[data-te-touch-init]"
    }
  };
  var WC = (s) => Oi[s.NAME] || null;
  var FC = (s, t2) => {
    if (!s || !t2.allowReinits && Go.isInited(s.NAME))
      return;
    Go.add(s.NAME);
    const e = WC(s), i = (e == null ? void 0 : e.isToggler) || false;
    if (OC(s), e != null && e.advanced) {
      e == null || e.advanced(s, e == null ? void 0 : e.selector);
      return;
    }
    if (i) {
      e == null || e.callback(s, e == null ? void 0 : e.selector);
      return;
    }
    d.find(e == null ? void 0 : e.selector).forEach((n) => {
      let o = s.getInstance(n);
      o || (o = new s(n), e != null && e.onInit && o[e.onInit]());
    });
  };
  var YC = (s, t2) => {
    s.forEach((e) => FC(e, t2));
  };
  var jC = {
    allowReinits: false,
    checkOtherImports: false
  };
  var ZC = (s, t2 = {}) => {
    t2 = __spreadValues(__spreadValues({}, jC), t2);
    const e = Object.keys(Oi).map((i) => {
      if (!!document.querySelector(Oi[i].selector)) {
        const o = s[Oi[i].name];
        return !o && !Go.isInited(i) && t2.checkOtherImports && console.warn(`Please import ${Oi[i].name} from "tw-elements" package and add it to a object parameter inside "initTE" function`), o;
      }
    });
    YC(e, t2);
  };

  // static/js/tailwind.ts
  ZC({ Validation: Ch, Select: _r });

  // static/js/public-adventures.ts
  var levelSelect = document.getElementById("level-select");
  var languageSelect = document.getElementById("language-select");
  var tagsSelect = document.getElementById("tag-select");
  var searchInput = document.getElementById("search_adventure");
  var searchTimeout;
  searchInput == null ? void 0 : searchInput.addEventListener("input", handleSearchInput);
  document.addEventListener("DOMContentLoaded", () => {
    const options = document.querySelectorAll(".option");
    options.forEach(function(option2) {
      option2.addEventListener("click", function() {
        const dropdown = option2.closest(".dropdown");
        if (!dropdown) {
          return;
        }
        const isSingleSelect = (dropdown == null ? void 0 : dropdown.getAttribute("data-type")) === "single";
        if (isSingleSelect && !option2.classList.contains("selected")) {
          const otherOptions = dropdown.querySelectorAll(".option.selected");
          otherOptions.forEach((otherOption) => otherOption.classList.remove("selected"));
        }
        let nextValue = dropdown.getAttribute("data-value");
        if (option2.classList.contains("selected")) {
          nextValue = nextValue == null ? void 0 : nextValue.replace(option2.getAttribute("data-value"), "");
          if (!isSingleSelect) {
            nextValue = nextValue.split(",").filter((v) => v).join(",");
          } else {
            return;
          }
        } else if (!isSingleSelect) {
          const currentValue = dropdown.getAttribute("data-value") || "";
          nextValue = [currentValue, option2.getAttribute("data-value") || ""].filter((v) => v).join(",");
        } else {
          nextValue = option2.getAttribute("data-value") || "";
        }
        dropdown.setAttribute("data-value", nextValue);
        option2.classList.toggle("selected");
        updateLabelText(dropdown);
        updateDOM();
      });
    });
    updateDOM();
    setTimeout(() => {
      if (!levelSelect)
        return;
      const level3 = levelSelect.getAttribute("data-value") || "";
      const cloneBtn = document.getElementById(`clone_adventure_btn_${level3}`);
      cloneBtn == null ? void 0 : cloneBtn.addEventListener("click", handleCloning);
    }, 500);
  });
  function getSelectedOptions(_options) {
    return Array.from(_options).filter((option2) => option2.classList.contains("selected")).map((option2) => {
      var _a3;
      return (_a3 = option2.textContent) == null ? void 0 : _a3.trim();
    });
  }
  function updateLabelText(dropdown) {
    const toggleButton = dropdown.querySelector(".toggle-button");
    const relativeOptions = dropdown.querySelectorAll(".option");
    const label = toggleButton.querySelector(".label");
    const selectedOptions = getSelectedOptions(relativeOptions);
    label.textContent = selectedOptions.length === 0 ? label.getAttribute("data-value") : selectedOptions.join(", ");
  }
  async function handleCloning(e) {
    const target = e.target;
    const adventureId = target.getAttribute("data-id");
    try {
      const data = await postJson(`public-adventures/clone/${adventureId}`);
      modal.notifySuccess(data.message);
      await updateDOM();
    } catch (error2) {
      modal.notifyError(error2.responseText);
    }
  }
  function handleSearchInput() {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(updateDOM, 500);
  }
  function updateURL() {
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);
    const level3 = levelSelect.getAttribute("data-value") || "";
    const lanugage = languageSelect.getAttribute("data-value") || "";
    const tags2 = tagsSelect.getAttribute("data-value") || "";
    urlParams.set("level", level3);
    urlParams.set("lang", lanugage);
    urlParams.set("tag", tags2);
    if (searchInput) {
      urlParams.set("search", searchInput.value);
    }
    window.history.pushState({}, "", `${window.location.pathname}?${urlParams.toString()}`);
  }
  async function updateDOM() {
    if (!levelSelect || !languageSelect || !tagsSelect)
      return;
    const level3 = levelSelect.getAttribute("data-value") || "";
    const lanugage = languageSelect.getAttribute("data-value") || "";
    const tags2 = tagsSelect.getAttribute("data-value") || "";
    const response = await fetch(`public-adventures/filter?tag=${tags2}&lang=${lanugage}&level=${level3}&search=${searchInput == null ? void 0 : searchInput.value}`, {
      method: "GET",
      keepalive: true,
      headers: {
        "Content-Type": "application/json; charset=utf-8",
        "Accept": "application/json"
      }
    });
    const { html, js } = await response.json();
    updateURL();
    const publicAdventuresBody = document.getElementById("public-adventures-body");
    if (publicAdventuresBody) {
      publicAdventuresBody.innerHTML = html;
      initialize({
        lang: js.lang,
        level: js.level,
        keyword_language: js.lang,
        javascriptPageOptions: js
      });
      initializeHighlightedCodeBlocks(publicAdventuresBody);
      const cloneBtn = document.getElementById(`clone_adventure_btn_${level3}`);
      cloneBtn == null ? void 0 : cloneBtn.addEventListener("click", handleCloning);
    }
  }
  return js_exports;
})();
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
/*!
 * @kurkle/color v0.2.1
 * https://github.com/kurkle/color#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v3.9.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
/*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
/*!
* Tailwind Elements 1.0.0
* 
* Tailwind Elements is an open-source UI kit of advanced components for TailwindCSS.
* Copyright © 2023 MDBootstrap.com
* 
* Unless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
* In addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.
* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
* 
*/
/*! @license DOMPurify 2.3.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.5/LICENSE */
/**
 * Tone.js
 * @author Yotam Mann
 * @license http://opensource.org/licenses/MIT MIT License
 * @copyright 2014-2019 Yotam Mann
 */
/**!
 * Sortable 1.15.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
//# sourceMappingURL=appbundle.js.map
