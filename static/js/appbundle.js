var hedyApp = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb2, mod) => function __require2() {
    return mod || (0, cb2[Object.keys(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // __tmp__/highlighting/highlighting.json
  var require_highlighting = __commonJS({
    "__tmp__/highlighting/highlighting.json"(exports, module) {
      module.exports = [
        {
          name: "level1",
          rules: {
            start: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^ *)(__ask__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "value",
                unicode: true
              },
              {
                regex: "(^ *)(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "value",
                unicode: true
              },
              {
                regex: "(^ *)(__echo__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "value",
                unicode: true
              },
              {
                regex: "(^ *)(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "value",
                unicode: true
              },
              {
                regex: "(^ *)(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "direction",
                unicode: true
              },
              {
                regex: "(^ *)(__color__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "color",
                unicode: true
              }
            ],
            value: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "value"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "value"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              }
            ],
            color: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "color"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "color"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              },
              {
                regex: "(__black__|__gray__|__white__|__green__|__blue__|__purple__|__brown__|__pink__|__red__|__orange__|__yellow__)",
                token: [
                  "text"
                ],
                unicode: true
              }
            ],
            direction: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "direction"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "direction"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              },
              {
                regex: "(__right__|__left__)",
                token: [
                  "text"
                ],
                unicode: true
              }
            ]
          }
        },
        {
          name: "level2",
          rules: {
            start: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^ *)(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "value",
                unicode: true
              },
              {
                regex: "(^ *)([\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7]+)( +)(__is__)( +)(__ask__)",
                token: [
                  "text",
                  "text",
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ],
                next: "value",
                unicode: true
              },
              {
                regex: "(^ *)([\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7]+)( +)(__is__)",
                token: [
                  "text",
                  "text",
                  "text",
                  "keyword"
                ],
                next: "value",
                unicode: true
              },
              {
                regex: "(^ *)(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "value",
                unicode: true
              },
              {
                regex: "(^ *)(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "value",
                unicode: true
              },
              {
                regex: "(^ *)(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "value",
                unicode: true
              },
              {
                regex: "(^ *)(__color__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "value",
                unicode: true
              }
            ],
            value: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "value"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "value"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              },
              {
                regex: "(__black__|__blue__|__brown__|__gray__|__green__|__orange__|__pink__|__purple__|__red__|__white__|__yellow__)",
                token: [
                  "text"
                ],
                unicode: true
              }
            ]
          }
        },
        {
          name: "level3",
          rules: {
            start: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^ *)([\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7]+)( +)(__is__)( *)(__ask__)",
                token: [
                  "text",
                  "text",
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ],
                next: "valueExpr",
                unicode: true
              },
              {
                regex: "(^ *)([\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7]+)( +)(__is__)",
                token: [
                  "text",
                  "text",
                  "text",
                  "keyword"
                ],
                next: "value",
                unicode: true
              },
              {
                regex: "(^ *)(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valueExpr",
                unicode: true
              },
              {
                regex: "(^ *)(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valueExpr",
                unicode: true
              },
              {
                regex: "(^ *)(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valueExpr",
                unicode: true
              },
              {
                regex: "(^ *)(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valueExpr",
                unicode: true
              },
              {
                regex: "(^ *)(__add__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valAdd",
                unicode: true
              },
              {
                regex: "(^ *)(__remove__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valRemove",
                unicode: true
              },
              {
                regex: "(^ *)(__color__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "value",
                unicode: true
              }
            ],
            value: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "value"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "value"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              },
              {
                regex: "(^| )(__at__)( +)(__random__)",
                token: [
                  "text",
                  "keyword",
                  "keyword",
                  "keyword"
                ],
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                unicode: true
              },
              {
                regex: "(__comma__)",
                token: [
                  "keyword"
                ],
                unicode: true
              },
              {
                regex: "(__black__|__blue__|__brown__|__gray__|__green__|__orange__|__pink__|__purple__|__red__|__white__|__yellow__)",
                token: [
                  "text"
                ],
                unicode: true
              }
            ],
            valueExpr: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "valueExpr"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "valueExpr"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              },
              {
                regex: "(^| )(__at__)( +)(__random__)",
                token: [
                  "text",
                  "keyword",
                  "keyword",
                  "keyword"
                ],
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                unicode: true
              }
            ],
            valAdd: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "valAdd"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "valAdd"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              },
              {
                regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valueTo",
                unicode: true
              },
              {
                regex: "(__black__|__blue__|__brown__|__gray__|__green__|__orange__|__pink__|__purple__|__red__|__white__|__yellow__)",
                token: [
                  "text"
                ],
                unicode: true
              }
            ],
            valueTo: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "valueTo"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "valueTo"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              }
            ],
            valRemove: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "valRemove"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "valRemove"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              },
              {
                regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valueFrom",
                unicode: true
              },
              {
                regex: "(__black__|__blue__|__brown__|__gray__|__green__|__orange__|__pink__|__purple__|__red__|__white__|__yellow__)",
                token: [
                  "text"
                ],
                unicode: true
              }
            ],
            valueFrom: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "valueFrom"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "valueFrom"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              }
            ]
          }
        },
        {
          name: "level4",
          rules: {
            start: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^ *)([\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7]+)( +)(__is__)( *)(__ask__)",
                token: [
                  "text",
                  "text",
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ],
                next: "valueExpr",
                unicode: true
              },
              {
                regex: "(^ *)([\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7]+)( +)(__is__)",
                token: [
                  "text",
                  "text",
                  "text",
                  "keyword"
                ],
                next: "value",
                unicode: true
              },
              {
                regex: "(^ *)(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valueExpr",
                unicode: true
              },
              {
                regex: "(^ *)(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valueSimple",
                unicode: true
              },
              {
                regex: "(^ *)(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valueSimple",
                unicode: true
              },
              {
                regex: "(^ *)(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valueSimple",
                unicode: true
              },
              {
                regex: "(^ *)(__color__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valueSimple",
                unicode: true
              },
              {
                regex: "(^ *)(__add__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valAdd",
                unicode: true
              },
              {
                regex: "(^ *)(__remove__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valRemove",
                unicode: true
              },
              {
                regex: "(^ *)(__clear__)",
                token: [
                  "text",
                  "event"
                ],
                unicode: true
              }
            ],
            value: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "value"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "value"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              },
              {
                regex: "(^| )(__at__)( +)(__random__)",
                token: [
                  "text",
                  "keyword",
                  "keyword",
                  "keyword"
                ],
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                unicode: true
              },
              {
                regex: "(__comma__)",
                token: [
                  "keyword"
                ],
                unicode: true
              },
              {
                regex: "(__black__|__blue__|__brown__|__gray__|__green__|__orange__|__pink__|__purple__|__red__|__white__|__yellow__)",
                token: [
                  "text"
                ],
                unicode: true
              }
            ],
            valueExpr: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "valueExpr"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "valueExpr"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              },
              {
                regex: "(^| )(__at__)( +)(__random__)",
                token: [
                  "text",
                  "keyword",
                  "keyword",
                  "keyword"
                ],
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                unicode: true
              },
              {
                regex: '"[^"]*"',
                token: "constant.character",
                unicode: true
              },
              {
                regex: "'[^']*'",
                token: "constant.character",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*\xBB",
                token: "constant.character",
                unicode: true
              },
              {
                regex: '"[^"]*$',
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*$",
                token: "text",
                next: "start",
                unicode: true
              }
            ],
            valueSimple: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "valueSimple"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "valueSimple"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              },
              {
                regex: "(^| )(__at__)( +)(__random__)",
                token: [
                  "text",
                  "keyword",
                  "keyword",
                  "keyword"
                ],
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                unicode: true
              },
              {
                regex: "(__black__|__blue__|__brown__|__gray__|__green__|__orange__|__pink__|__purple__|__red__|__white__|__yellow__)",
                token: [
                  "text"
                ],
                unicode: true
              }
            ],
            valAdd: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "valAdd"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "valAdd"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              },
              {
                regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valueTo",
                unicode: true
              },
              {
                regex: "(__black__|__blue__|__brown__|__gray__|__green__|__orange__|__pink__|__purple__|__red__|__white__|__yellow__)",
                token: [
                  "text"
                ],
                unicode: true
              }
            ],
            valueTo: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "valueTo"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "valueTo"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              }
            ],
            valRemove: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "valRemove"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "valRemove"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              },
              {
                regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "valueFrom",
                unicode: true
              },
              {
                regex: "(__black__|__blue__|__brown__|__gray__|__green__|__orange__|__pink__|__purple__|__red__|__white__|__yellow__)",
                token: [
                  "text"
                ],
                unicode: true
              }
            ],
            valueFrom: [
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "valueFrom"
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "valueFrom"
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start"
              },
              {
                regex: "(^|$)",
                token: [
                  "text"
                ],
                next: "start"
              }
            ]
          }
        },
        {
          name: "level5",
          rules: {
            start: [
              {
                regex: "(^| )(__is__)( +)(__ask__)",
                token: [
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*"',
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*'",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*\xBB",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*$',
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              }
            ]
          }
        },
        {
          name: "level6",
          rules: {
            start: [
              {
                regex: "(^| )(__is__)( +)(__ask__)",
                token: [
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "(=)( +)(__ask__)",
                token: [
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*"',
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*'",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*\xBB",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*$',
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              }
            ]
          }
        },
        {
          name: "level7",
          rules: {
            start: [
              {
                regex: "(^| )(__is__)( +)(__ask__)",
                token: [
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "(=)( +)(__ask__)",
                token: [
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*"',
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*'",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*\xBB",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*$',
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              }
            ]
          }
        },
        {
          name: "level8",
          rules: {
            start: [
              {
                regex: "(^| )(__is__)( +)(__ask__)",
                token: [
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "(=)( +)(__ask__)",
                token: [
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*"',
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*'",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*\xBB",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*$',
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              }
            ]
          }
        },
        {
          name: "level9",
          rules: {
            start: [
              {
                regex: "(^| )(__is__)( +)(__ask__)",
                token: [
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "(=)( +)(__ask__)",
                token: [
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*"',
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*'",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*\xBB",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*$',
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              }
            ]
          }
        },
        {
          name: "level10",
          rules: {
            start: [
              {
                regex: "(^| )(__is__)( +)(__ask__)",
                token: [
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "(=)( +)(__ask__)",
                token: [
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*"',
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*'",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*\xBB",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*$',
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              }
            ]
          }
        },
        {
          name: "level11",
          rules: {
            start: [
              {
                regex: "(^| )(__is__)( +)(__ask__)",
                token: [
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "(=)( +)(__ask__)",
                token: [
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*"',
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*'",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*\xBB",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*$',
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)([__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__range__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              }
            ]
          }
        },
        {
          name: "level12",
          rules: {
            start: [
              {
                regex: "(^| )(__is__)( +)(__ask__)",
                token: [
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "(=)( +)(__ask__)",
                token: [
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*"',
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*'",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*\xBB",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*$',
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__range__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__define__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "support.function"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__call__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "support.function"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__with__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__return__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              }
            ]
          }
        },
        {
          name: "level13",
          rules: {
            start: [
              {
                regex: "(^| )(__is__)( +)(__ask__)",
                token: [
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "(=)( +)(__ask__)",
                token: [
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*"',
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*'",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*\xBB",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*$',
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__range__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__and__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__or__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__define__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "support.function"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__call__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "support.function"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__with__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__return__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              }
            ]
          }
        },
        {
          name: "level14",
          rules: {
            start: [
              {
                regex: "(^| )(__is__)( +)(__ask__)",
                token: [
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "(=)( +)(__ask__)",
                token: [
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*"',
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*'",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*\xBB",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*$',
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(<)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(>)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(!)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__range__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__and__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__or__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__define__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "support.function"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__call__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "support.function"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__with__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__return__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(<)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(>)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(!)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              }
            ]
          }
        },
        {
          name: "level15",
          rules: {
            start: [
              {
                regex: "(^| )(__is__)( +)(__ask__)",
                token: [
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "(=)( +)(__ask__)",
                token: [
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*"',
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*'",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*\xBB",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*$',
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(<)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(>)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(!)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__range__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__and__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__or__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__while__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__define__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "support.function"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__call__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "support.function"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__with__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__return__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(<)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(>)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(!)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              }
            ]
          }
        },
        {
          name: "level16",
          rules: {
            start: [
              {
                regex: "(^| )(__is__)( +)(__ask__)",
                token: [
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "(=)( +)(__ask__)",
                token: [
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*"',
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*'",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*\xBB",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*$',
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(<)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(>)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(!)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\[)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\])([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__range__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__and__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__or__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__while__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__define__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "support.function"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__call__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "support.function"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__with__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__return__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(<)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(>)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(!)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\[)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\])",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              }
            ]
          }
        },
        {
          name: "level17",
          rules: {
            start: [
              {
                regex: "(^| )(__is__)( +)(__ask__)",
                token: [
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "(=)( +)(__ask__)",
                token: [
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*"',
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*'",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*\xBB",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*$',
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(<)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(>)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(!)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\[)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\])([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(:)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__range__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__and__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__or__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__while__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__define__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "support.function"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__call__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "support.function"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__with__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__return__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(<)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(>)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(!)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\[)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\])",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(:)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__elif__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              }
            ]
          }
        },
        {
          name: "level18",
          rules: {
            start: [
              {
                regex: "(^| )(__is__)( +)(__ask__)",
                token: [
                  "text",
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "(=)( +)(__ask__)",
                token: [
                  "keyword",
                  "text",
                  "keyword"
                ]
              },
              {
                regex: "#.*$",
                token: "comment",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*"',
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*'",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*\xBB",
                token: "constant.character",
                next: "start",
                unicode: true
              },
              {
                regex: '"[^"]*$',
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "'[^']*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "\xAB[^\xBB]*$",
                token: "text",
                next: "start",
                unicode: true
              },
              {
                regex: "_\\?_",
                token: "invalid",
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(_)(?= |$)",
                token: [
                  "text",
                  "invalid"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(<)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(>)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(!)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\[)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\])([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(:)([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\()([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\))([__DIGIT__]*\\.?[__DIGIT__]+)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword",
                  "variable"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__is__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__at__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__add__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to_list__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__remove__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__from__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__in__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(not_in)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__if__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__else__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__for__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__range__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__to__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__and__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__or__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__while__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__input__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__repeat__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__color__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__def__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "support.function"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__return__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__comma__)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(-)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(=)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(/)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\*)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\+)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(<)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(>)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(!)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\[)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\])",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(:)",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\()",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(\\))",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__print__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__sleep__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__forward__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__turn__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__random__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__times__)",
                token: [
                  "text",
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(__elif__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "keyword"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__black__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__blue__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__brown__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__gray__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__green__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__orange__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pink__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__purple__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__red__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__white__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__yellow__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "text"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__pressed__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              },
              {
                regex: "(^| )(__clear__)(?![\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Nl}_\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\xB7])",
                token: [
                  "text",
                  "event"
                ],
                next: "start",
                unicode: true
              }
            ]
          }
        }
      ];
    }
  });

  // __tmp__/highlighting/highlighting-trad.json
  var require_highlighting_trad = __commonJS({
    "__tmp__/highlighting/highlighting-trad.json"(exports, module) {
      module.exports = {
        ar: {
          add: "\u0640*\u0627\u0640*\u0636\u0640*\u0641\u0640*|add",
          and: "\u0640*\u0648\u0640*|and",
          ask: "\u0640*\u0627\u0640*\u0633\u0640*\u0623\u0640*\u0644\u0640*|ask",
          at: "\u0640*\u0628\u0640*\u0634\u0640*\u0643\u0640*\u0644\u0640*|at",
          black: "\u0640*\u0627\u0640*\u0633\u0640*\u0648\u0640*\u062F\u0640*|black",
          blue: "\u0640*\u0627\u0640*\u0632\u0640*\u0631\u0640*\u0642\u0640*|blue",
          brown: "\u0640*\u0628\u0640*\u0646\u0640*\u064A\u0640*|brown",
          call: "\u0640*c\u0640*a\u0640*l\u0640*l\u0640*|call",
          clear: "\u0640*c\u0640*l\u0640*e\u0640*a\u0640*r\u0640*|clear",
          color: "\u0640*\u0644\u0640*\u0648\u0640*\u0646\u0640*|color",
          comma: "\u0640*\u060C\u0640*|,",
          def: "\u0640*d\u0640*e\u0640*f\u0640*|def",
          define: "\u0640*d\u0640*e\u0640*f\u0640*i\u0640*n\u0640*e\u0640*|define",
          echo: "\u0640*\u0631\u0640*\u062F\u0640*\u062F\u0640*|echo",
          elif: "\u0640*\u0648\u0640*\u0625\u0640*\u0644\u0640*\u0627\u0640* \u0640*\u0627\u0640*\u0630\u0640*\u0627\u0640*|elif",
          else: "\u0640*\u0648\u0640*\u0625\u0640*\u0644\u0640*\u0627\u0640*|else",
          for: "\u0640*\u0644\u0640*\u0643\u0640*\u0644\u0640*|for",
          forward: "\u0640*\u062A\u0640*\u0642\u0640*\u062F\u0640*\u0645\u0640*|forward",
          from: "\u0640*\u0645\u0640*\u0646\u0640*|from",
          gray: "\u0640*\u0631\u0640*\u0645\u0640*\u0627\u0640*\u062F\u0640*\u064A\u0640*|gray",
          green: "\u0640*\u0627\u0640*\u062E\u0640*\u0636\u0640*\u0631\u0640*|green",
          if: "\u0640*\u0627\u0640*\u0630\u0640*\u0627\u0640*|if",
          in: "\u0640*\u0641\u0640*\u064A\u0640*|in",
          input: "\u0640*\u0627\u0640*\u062F\u0640*\u062E\u0640*\u0644\u0640*|input",
          is: "\u0640*\u0647\u0640*\u0648\u0640*|\u0640*\u0647\u0640*\u064A\u0640*|is",
          left: "\u0640*\u064A\u0640*\u0633\u0640*\u0627\u0640*\u0631\u0640*|left",
          length: "\u0640*\u0637\u0640*\u0648\u0640*\u0644\u0640*|length",
          or: "\u0640*\u0623\u0640*\u0648\u0640*|or",
          orange: "\u0640*\u0628\u0640*\u0631\u0640*\u062A\u0640*\u0642\u0640*\u0627\u0640*\u0644\u0640*\u064A\u0640*|orange",
          pink: "\u0640*\u0632\u0640*\u0647\u0640*\u0631\u0640*\u064A\u0640*|pink",
          pressed: "\u0640*p\u0640*r\u0640*e\u0640*s\u0640*s\u0640*e\u0640*d\u0640*|pressed",
          print: "\u0640*\u0642\u0640*\u0648\u0640*\u0644\u0640*|print",
          purple: "\u0640*\u0628\u0640*\u0646\u0640*\u0641\u0640*\u0633\u0640*\u062C\u0640*\u064A\u0640*|purple",
          random: "\u0640*\u0639\u0640*\u0634\u0640*\u0648\u0640*\u0627\u0640*\u0626\u0640*\u064A\u0640*|random",
          range: "\u0640*\u0646\u0640*\u0637\u0640*\u0627\u0640*\u0642\u0640*|range",
          red: "\u0640*\u0627\u0640*\u062D\u0640*\u0645\u0640*\u0631\u0640*|red",
          remove: "\u0640*\u0627\u0640*\u0632\u0640*\u0644\u0640*|remove",
          repeat: "\u0640*\u0643\u0640*\u0631\u0640*\u0631\u0640*|repeat",
          return: "\u0640*r\u0640*e\u0640*t\u0640*u\u0640*r\u0640*n\u0640*|return",
          right: "\u0640*\u064A\u0640*\u0645\u0640*\u064A\u0640*\u0646\u0640*|right",
          sleep: "\u0640*\u0627\u0640*\u0646\u0640*\u062A\u0640*\u0638\u0640*\u0631\u0640*|sleep",
          step: "\u0640*\u062E\u0640*\u0637\u0640*\u0648\u0640*\u0629\u0640*|step",
          times: "\u0640*\u0645\u0640*\u0631\u0640*\u0629\u0640*|times",
          to: "\u0640*\u0627\u0640*\u0644\u0640*\u0649\u0640*|to",
          to_list: "\u0640*\u0627\u0640*\u0644\u0640*\u0649\u0640*|to",
          turn: "\u0640*\u0627\u0640*\u0633\u0640*\u062A\u0640*\u062F\u0640*\u0631\u0640*|turn",
          while: "\u0640*\u0628\u0640*\u064A\u0640*\u0646\u0640*\u0645\u0640*\u0627\u0640*|while",
          white: "\u0640*\u0627\u0640*\u0628\u0640*\u064A\u0640*\u0636\u0640*|white",
          with: "\u0640*w\u0640*i\u0640*t\u0640*h\u0640*|with",
          yellow: "\u0640*\u0627\u0640*\u0635\u0640*\u0641\u0640*\u0631\u0640*|yellow",
          DIGIT: "0\u06601\u06612\u06623\u06634\u06645\u06656\u06667\u06678\u06689\u0669"
        },
        bg: {
          add: "\u0434\u043E\u0431\u0430\u0432\u0438|add",
          and: "\u0438|and",
          ask: "\u043F\u043E\u043F\u0438\u0442\u0430\u0439|ask",
          at: "\u0432|at",
          black: "\u0447\u0435\u0440\u043D\u043E|black",
          blue: "\u0441\u0438\u043D\u044C\u043E|blue",
          brown: "\u043A\u0430\u0444\u044F\u0432\u043E|brown",
          call: "\u0438\u0437\u0432\u0438\u043A\u0430\u0439|call",
          clear: "\u0438\u0437\u0447\u0438\u0441\u0442\u0438|clear",
          color: "\u0446\u0432\u044F\u0442|color",
          comma: ",",
          def: "\u0434\u0435\u0444|def",
          define: "\u0434\u0435\u0444\u0438\u043D\u0438\u0440\u0430\u0439|define",
          echo: "\u043F\u043E\u043A\u0430\u0436\u0438|echo",
          elif: "\u0438\u043D\u0430\u0447\u0435 \u0430\u043A\u043E|elif",
          else: "\u0438\u043D\u0430\u0447\u0435|else",
          for: "\u0437\u0430|for",
          forward: "\u043D\u0430\u043F\u0440\u0435\u0434|forward",
          from: "\u043E\u0442|from",
          gray: "\u0441\u0438\u0432\u043E|gray",
          green: "\u0437\u0435\u043B\u0435\u043D\u043E|green",
          if: "\u0430\u043A\u043E|if",
          in: "\u0432|in",
          input: "\u0432\u044A\u0432\u0435\u0436\u0434\u0430\u043D\u0435|input",
          is: "\u0435|is",
          left: "\u043B\u044F\u0432\u043E|left",
          length: "\u0434\u044A\u043B\u0436\u0438\u043D\u0430|length",
          or: "\u0438\u043B\u0438|or",
          orange: "\u043E\u0440\u0430\u043D\u0436\u0435\u0432\u043E|orange",
          pink: "\u0440\u043E\u0437\u043E\u0432\u043E|pink",
          pressed: "\u043D\u0430\u0442\u0438\u0441\u043D\u0430\u0442|pressed",
          print: "\u043F\u0440\u0438\u043D\u0442\u0438\u0440\u0430\u0439|print",
          purple: "\u043B\u0438\u043B\u0430\u0432\u043E|purple",
          random: "\u043F\u0440\u043E\u0438\u0437\u0432\u043E\u043B\u043D\u043E|random",
          range: "\u043E\u0431\u0445\u0432\u0430\u0442|range",
          red: "\u0447\u0435\u0440\u0432\u0435\u043D\u043E|red",
          remove: "\u043F\u0440\u0435\u043C\u0430\u0445\u043D\u0438|remove",
          repeat: "\u043F\u043E\u0432\u0442\u043E\u0440\u0438|repeat",
          return: "\u0432\u044A\u0440\u043D\u0438|return",
          right: "\u0434\u044F\u0441\u043D\u043E|right",
          sleep: "\u0441\u043F\u0438|sleep",
          step: "\u0441\u0442\u044A\u043F\u043A\u0430|step",
          times: "\u043F\u044A\u0442\u0438|times",
          to: "\u0434\u043E|to",
          to_list: "\u0434\u043E|to",
          turn: "\u0437\u0430\u0432\u0438\u0439|turn",
          while: "\u0434\u043E\u043A\u0430\u0442\u043E|while",
          white: "\u0431\u044F\u043B\u043E|white",
          with: "\u0441/\u0441\u044A\u0441|with",
          yellow: "\u0436\u044A\u043B\u0442\u043E|yellow",
          DIGIT: "0123456789"
        },
        bn: {
          add: "add",
          and: "and",
          ask: "ask",
          at: "at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "forward",
          from: "from",
          gray: "gray",
          green: "green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "left",
          length: "length",
          or: "or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "print",
          purple: "purple",
          random: "random",
          range: "range",
          red: "red",
          remove: "remove",
          repeat: "repeat",
          return: "return",
          right: "right",
          sleep: "sleep",
          step: "step",
          times: "times",
          to: "to",
          to_list: "to",
          turn: "turn",
          while: "while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        ca: {
          add: "afegeix|add",
          and: "i|and",
          ask: "pregunta|ask",
          at: "a|at",
          black: "negre|black",
          blue: "blau|blue",
          brown: "marr\xF3|brown",
          call: "crida|call",
          clear: "neteja|clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "defineix|define",
          echo: "eco|echo",
          elif: "sinosi|elif",
          else: "sino|else",
          for: "per|for",
          forward: "avan\xE7a|forward",
          from: "de|from",
          gray: "gris|gray",
          green: "verd|green",
          if: "si|if",
          in: "dins|in",
          input: "entra|input",
          is: "\xE9s|is",
          left: "esquerra|left",
          length: "mida|length",
          or: "o|or",
          orange: "taronja|orange",
          pink: "rosa|pink",
          pressed: "pressionat|pressed",
          print: "imprimeix|print",
          purple: "lila|purple",
          random: "aleatori|random",
          range: "rang|range",
          red: "vermell|red",
          remove: "esborra|remove",
          repeat: "repeteix|repeat",
          return: "retorna|return",
          right: "dreta|right",
          sleep: "dorm|sleep",
          step: "pas|step",
          times: "vegades|times",
          to: "fins|to",
          to_list: "a|to",
          turn: "gira|turn",
          while: "mentre|while",
          white: "blanc|white",
          with: "amb|with",
          yellow: "groc|yellow",
          DIGIT: "0123456789"
        },
        cs: {
          add: "add",
          and: "and",
          ask: "ask",
          at: "at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "forward",
          from: "from",
          gray: "gray",
          green: "green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "left",
          length: "length",
          or: "or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "print",
          purple: "purple",
          random: "random",
          range: "range",
          red: "red",
          remove: "remove",
          repeat: "repeat",
          return: "return",
          right: "right",
          sleep: "sleep",
          step: "step",
          times: "times",
          to: "to",
          to_list: "to",
          turn: "turn",
          while: "while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        cy: {
          add: "adio|add",
          and: "a|and",
          ask: "gofyn|ask",
          at: "ar|at",
          black: "du|black",
          blue: "glas|blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "lliw|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "adleisio|echo",
          elif: "elif",
          else: "arall|else",
          for: "ar gyfer|for",
          forward: "ymlaen|forward",
          from: "o|from",
          gray: "llwyd|gray",
          green: "gwyrdd|green",
          if: "os|if",
          in: "mewn|in",
          input: "mewnbwn|input",
          is: "yw|is",
          left: "chwith|left",
          length: "hyd|length",
          or: "neu|or",
          orange: "oren|orange",
          pink: "pinc|pink",
          pressed: "gwasgu|pressed",
          print: "argraffu|print",
          purple: "porffor|purple",
          random: "hap|random",
          range: "ystod|range",
          red: "coch|red",
          remove: "dileu|remove",
          repeat: "ailadrodd|repeat",
          return: "return",
          right: "dde|right",
          sleep: "cysgu|sleep",
          step: "cam|step",
          times: "gwaith|times",
          to: "i|to",
          to_list: "i|to",
          turn: "troi|turn",
          while: "tra|while",
          white: "gwyn|white",
          with: "with",
          yellow: "melyn|yellow",
          DIGIT: "0123456789"
        },
        da: {
          add: "add",
          and: "and",
          ask: "sp\xF8rg|ask",
          at: "at",
          black: "sort|black",
          blue: "bl\xE5|blue",
          brown: "brun|brown",
          call: "call",
          clear: "clear",
          color: "farve|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "ekko|echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "fremad|forward",
          from: "from",
          gray: "gr\xE5|gray",
          green: "gr\xF8n|green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "left",
          length: "length",
          or: "or",
          orange: "orange",
          pink: "lyser\xF8d|pink",
          pressed: "pressed",
          print: "print",
          purple: "lila|purple",
          random: "random",
          range: "range",
          red: "red",
          remove: "remove",
          repeat: "repeat",
          return: "return",
          right: "right",
          sleep: "sleep",
          step: "step",
          times: "times",
          to: "to",
          to_list: "to",
          turn: "drej|turn",
          while: "while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        de: {
          add: "addiere|add",
          and: "und|and",
          ask: "frage|ask",
          at: "an|at",
          black: "Schwarz|black",
          blue: "Blau|blue",
          brown: "Braun|brown",
          call: "call",
          clear: "abwischen|clear",
          color: "farbe|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "sofalls|elif",
          else: "sonst|else",
          for: "f\xFCr|for",
          forward: "vorw\xE4rts|forward",
          from: "aus|from",
          gray: "Grau|gray",
          green: "Gr\xFCn|green",
          if: "falls|if",
          in: "in",
          input: "eingabe|input",
          is: "ist|is",
          left: "links|left",
          length: "l\xE4nge|length",
          or: "oder|or",
          orange: "Orange|orange",
          pink: "Pink|pink",
          pressed: "gedr\xFCckt|pressed",
          print: "drucke|print",
          purple: "Lila|purple",
          random: "zuf\xE4llig|random",
          range: "bereich|range",
          red: "Rot|red",
          remove: "entferne|remove",
          repeat: "wiederhole|repeat",
          return: "return",
          right: "rechts|right",
          sleep: "schlafe|sleep",
          step: "schritt|step",
          times: "mal|times",
          to: "bis|to",
          to_list: "zu|to",
          turn: "drehe|turn",
          while: "solange|while",
          white: "Wei\xDF|white",
          with: "with",
          yellow: "Gelb|yellow",
          DIGIT: "0123456789"
        },
        el: {
          add: "add",
          and: "and",
          ask: "ask",
          at: "at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "forward",
          from: "from",
          gray: "gray",
          green: "green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "left",
          length: "length",
          or: "or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "print",
          purple: "purple",
          random: "random",
          range: "range",
          red: "red",
          remove: "remove",
          repeat: "repeat",
          return: "return",
          right: "right",
          sleep: "sleep",
          step: "step",
          times: "times",
          to: "to",
          to_list: "to",
          turn: "turn",
          while: "while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        en: {
          add: "add",
          and: "and",
          ask: "ask",
          at: "at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "forward",
          from: "from",
          gray: "gray",
          green: "green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "left",
          length: "length",
          or: "or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "print",
          purple: "purple",
          random: "random",
          range: "range",
          red: "red",
          remove: "remove",
          repeat: "repeat",
          return: "return",
          right: "right",
          sleep: "sleep",
          step: "step",
          times: "times",
          to: "to",
          to_list: "to",
          turn: "turn",
          while: "while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        eo: {
          add: "aldonu|add",
          and: "kaj|and",
          ask: "demandu|ask",
          at: "la\u016D|at",
          black: "nigra|black",
          blue: "blua|blue",
          brown: "bruna|brown",
          call: "call",
          clear: "clear",
          color: "koloro|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "e\u0125u|echo",
          elif: "alie se|elif",
          else: "alie|else",
          for: "por|for",
          forward: "anta\u016Den|forward",
          from: "el|from",
          gray: "griza|gray",
          green: "verda|green",
          if: "se|if",
          in: "en|in",
          input: "enigu|input",
          is: "estas|is",
          left: "maldekstren|left",
          length: "longo|length",
          or: "a\u016D|or",
          orange: "oran\u011Da|orange",
          pink: "rozkolora|pink",
          pressed: "pressed",
          print: "presu|print",
          purple: "purpura|purple",
          random: "hazardo|random",
          range: "intervalo|range",
          red: "ru\u011Da|red",
          remove: "forigu|remove",
          repeat: "ripetu|repeat",
          return: "return",
          right: "dekstren|right",
          sleep: "dormu|sleep",
          step: "pa\u015Do|step",
          times: "fojojn|times",
          to: "\u011Dis|to",
          to_list: "al|to",
          turn: "turnu|turn",
          while: "dum|while",
          white: "blanka|white",
          with: "with",
          yellow: "flava|yellow",
          DIGIT: "0123456789"
        },
        es: {
          add: "a\xF1adir|add",
          and: "y|and",
          ask: "preguntar|ask",
          at: "en|at",
          black: "negro|black",
          blue: "azul|blue",
          brown: "marr\xF3n|brown",
          call: "llamar|call",
          clear: "limpiar|clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "definir|define",
          echo: "eco|echo",
          elif: "sinosi|elif",
          else: "sino|else",
          for: "para|for",
          forward: "adelante|forward",
          from: "de|from",
          gray: "gris|gray",
          green: "verde|green",
          if: "si|if",
          in: "en|in",
          input: "entrada|input",
          is: "es|is",
          left: "izquierda|left",
          length: "longitud|length",
          or: "o|or",
          orange: "naranja|orange",
          pink: "rosa|pink",
          pressed: "presionada|pressed",
          print: "imprimir|print",
          purple: "p\xFArpura|purple",
          random: "aleatorio|random",
          range: "rango|range",
          red: "rojo|red",
          remove: "borrar|remove",
          repeat: "repetir|repeat",
          return: "retornar|return",
          right: "derecha|right",
          sleep: "dormir|sleep",
          step: "paso|step",
          times: "veces|times",
          to: "a|to",
          to_list: "a|to",
          turn: "girar|turn",
          while: "mientras|while",
          white: "blanco|white",
          with: "con|with",
          yellow: "amarillo|yellow",
          DIGIT: "0123456789"
        },
        et: {
          add: "lisa|add",
          and: "ja|and",
          ask: "k\xFCsi|ask",
          at: "t\xE4itsa|at",
          black: "must|black",
          blue: "sinine|blue",
          brown: "pruun|brown",
          call: "call",
          clear: "clear",
          color: "v\xE4rv|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "peegelda|echo",
          elif: "muidukui|elif",
          else: "muidu|else",
          for: "jaoks|for",
          forward: "edasi|forward",
          from: "nimistust|from",
          gray: "hall|gray",
          green: "roheline|green",
          if: "kui|if",
          in: "nimistus|in",
          input: "sisesta|input",
          is: "on|is",
          left: "vasakule|left",
          length: "pikkus|length",
          or: "v\xF5i|or",
          orange: "oran\u017E|orange",
          pink: "roosa|pink",
          pressed: "pressed",
          print: "prindi|print",
          purple: "lilla|purple",
          random: "juhuslikult|random",
          range: "vahemik|range",
          red: "punane|red",
          remove: "kustuta|remove",
          repeat: "korda|repeat",
          return: "return",
          right: "paremale|right",
          sleep: "oota|sleep",
          step: "sammuga|step",
          times: "korda|times",
          to: "kuni|to",
          to_list: "nimistusse|to",
          turn: "p\xF6\xF6ra|turn",
          while: "senikui|while",
          white: "valge|white",
          with: "with",
          yellow: "kollane|yellow",
          DIGIT: "0123456789"
        },
        fa: {
          add: "add",
          and: "and",
          ask: "\u0628\u067E\u0631\u0633|ask",
          at: "at",
          black: "\u0633\u06CC\u0627\u0647|black",
          blue: "\u0622\u0628\u06CC|blue",
          brown: "\u0642\u0647\u0648\u0647 \u0627\u06CC|brown",
          call: "call",
          clear: "clear",
          color: "\u0631\u0646\u06AF|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "\u0628\u0647 \u062C\u0644\u0648|forward",
          from: "from",
          gray: "\u062E\u0627\u06A9\u0633\u062A\u0631\u06CC|gray",
          green: "\u0633\u0628\u0632|green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "\u0686\u067E|left",
          length: "length",
          or: "or",
          orange: "\u0646\u0627\u0631\u0646\u062C\u06CC|orange",
          pink: "\u0635\u0648\u0631\u062A\u06CC|pink",
          pressed: "pressed",
          print: "\u0686\u0627\u067E|print",
          purple: "\u0628\u0646\u0641\u0634|purple",
          random: "random",
          range: "range",
          red: "\u0642\u0631\u0645\u0632|red",
          remove: "remove",
          repeat: "repeat",
          return: "return",
          right: "\u0631\u0627\u0633\u062A|right",
          sleep: "sleep",
          step: "step",
          times: "times",
          to: "to",
          to_list: "to",
          turn: "\u062F\u0648\u0631 \u0628\u0632\u0646|turn",
          while: "while",
          white: "\u0633\u0641\u06CC\u062F|white",
          with: "with",
          yellow: "\u0632\u0631\u062F|yellow",
          DIGIT: "0123456789"
        },
        fi: {
          add: "lis\xE4\xE4|add",
          and: "ja|and",
          ask: "kysy|ask",
          at: "ota|at",
          black: "musta|black",
          blue: "sininen|blue",
          brown: "ruskea|brown",
          call: "call",
          clear: "nollaa|clear",
          color: "v\xE4ri|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "kaiku|echo",
          elif: "muutenjos|elif",
          else: "muuten|else",
          for: "jokaiselle|for",
          forward: "eteenp\xE4in|forward",
          from: "listasta|from",
          gray: "harmaa|gray",
          green: "vihre\xE4|green",
          if: "jos|if",
          in: "listassa|in",
          input: "sy\xF6te|input",
          is: "on|is",
          left: "vasen|left",
          length: "pituus|length",
          or: "tai|or",
          orange: "oranssi|orange",
          pink: "vaaleanpunainen|pink",
          pressed: "painettu|pressed",
          print: "tulosta|print",
          purple: "violetti|purple",
          random: "satunnainen|random",
          range: "v\xE4li|range",
          red: "punainen|red",
          remove: "poista|remove",
          repeat: "toista|repeat",
          return: "return",
          right: "oikea|right",
          sleep: "nuku|sleep",
          step: "askel|step",
          times: "kertaa|times",
          to: "asti|to",
          to_list: "listaksi|to",
          turn: "k\xE4\xE4nny|turn",
          while: "kun|while",
          white: "valkoinen|white",
          with: "with",
          yellow: "keltainen|yellow",
          DIGIT: "0123456789"
        },
        fr: {
          add: "ajoute|add",
          and: "et|and",
          ask: "demande|ask",
          at: "au|at",
          black: "noir|black",
          blue: "bleu|blue",
          brown: "marron|brown",
          call: "call",
          clear: "effacer|clear",
          color: "couleur|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "r\xE9ponds|echo",
          elif: "sinon si|elif",
          else: "sinon|else",
          for: "pour|for",
          forward: "avance|forward",
          from: "de|from",
          gray: "gris|gray",
          green: "vert|green",
          if: "si|if",
          in: "dans|in",
          input: "demande|input",
          is: "est|is",
          left: "gauche|left",
          length: "longueur|length",
          or: "ou|or",
          orange: "orange",
          pink: "rose|pink",
          pressed: "press\xE9|pressed",
          print: "affiche|print",
          purple: "violet|purple",
          random: "hasard|random",
          range: "intervalle|range",
          red: "rouge|red",
          remove: "supprime|remove",
          repeat: "r\xE9p\xE8te|repete|repeat",
          return: "return",
          right: "droite|right",
          sleep: "dors|sleep",
          step: "pas|step",
          times: "fois|times",
          to: "\xE0|to",
          to_list: "\xE0|to",
          turn: "tourne|turn",
          while: "tant que|while",
          white: "blanc|white",
          with: "with",
          yellow: "jaune|yellow",
          DIGIT: "0123456789"
        },
        fy: {
          add: "add",
          and: "and",
          ask: "ask",
          at: "at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "forward",
          from: "from",
          gray: "gray",
          green: "green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "left",
          length: "length",
          or: "or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "print",
          purple: "purple",
          random: "random",
          range: "range",
          red: "red",
          remove: "remove",
          repeat: "repeat",
          return: "return",
          right: "right",
          sleep: "sleep",
          step: "step",
          times: "times",
          to: "to",
          to_list: "to",
          turn: "turn",
          while: "while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        he: {
          add: "\u05D4\u05D5\u05E1\u05E3|add",
          and: "\u05D5\u05D2\u05DD|and",
          ask: "\u05E9\u05D0\u05DC|ask",
          at: "\u05D1|at",
          black: "\u05E9\u05D7\u05D5\u05E8|black",
          blue: "\u05DB\u05D7\u05D5\u05DC|blue",
          brown: "\u05D7\u05D5\u05DD|brown",
          call: "call",
          clear: "clear",
          color: "\u05E6\u05D1\u05E2|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "\u05D4\u05D3\u05D4\u05D3|echo",
          elif: "\u05D0\u05D7\u05E8\u05EA\u05D0\u05DD|elif",
          else: "\u05D0\u05D7\u05E8\u05EA|else",
          for: "\u05DC\u05DB\u05DC|for",
          forward: "\u05E7\u05D3\u05D9\u05DE\u05D4|forward",
          from: "\u05DE|from",
          gray: "\u05D0\u05E4\u05D5\u05E8|gray",
          green: "\u05D9\u05E8\u05D5\u05E7|green",
          if: "\u05D0\u05DD|if",
          in: "\u05D1\u05EA\u05D5\u05DA|in",
          input: "\u05E7\u05DC\u05D8|input",
          is: "\u05D4\u05D5\u05D0|is",
          left: "\u05E9\u05DE\u05D0\u05DC\u05D4|left",
          length: "\u05D0\u05D5\u05E8\u05DA|length",
          or: "\u05D0\u05D5|or",
          orange: "\u05DB\u05EA\u05D5\u05DD|orange",
          pink: "\u05D5\u05E8\u05D5\u05D3|pink",
          pressed: "pressed",
          print: "\u05D4\u05D3\u05E4\u05E1|print",
          purple: "\u05E1\u05D2\u05D5\u05DC|purple",
          random: "\u05D0\u05E7\u05E8\u05D0\u05D9|random",
          range: "\u05D8\u05D5\u05D5\u05D7|range",
          red: "\u05D0\u05D3\u05D5\u05DD|red",
          remove: "\u05D4\u05E1\u05E8|remove",
          repeat: "\u05D7\u05D6\u05D5\u05E8|repeat",
          return: "return",
          right: "\u05D9\u05DE\u05D9\u05E0\u05D4|right",
          sleep: "\u05D4\u05DE\u05EA\u05DF|sleep",
          step: "\u05E6\u05E2\u05D3|step",
          times: "\u05E4\u05E2\u05DE\u05D9\u05DD|times",
          to: "\u05E2\u05D3|to",
          to_list: "\u05D0\u05DC|to",
          turn: "\u05E4\u05E0\u05D4|turn",
          while: "\u05DB\u05DC\u05E2\u05D5\u05D3|while",
          white: "\u05DC\u05D1\u05DF|white",
          with: "with",
          yellow: "\u05E6\u05D4\u05D5\u05D1|yellow",
          DIGIT: "0123456789"
        },
        hi: {
          add: "\u091C\u094B\u0921\u093C\u0928\u093E|add",
          and: "\u0914\u0930|and",
          ask: "\u092A\u0942\u091B\u0947\u0902|ask",
          at: "\u092A\u0930|at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "\u0917\u0942\u0902\u091C|echo",
          elif: "\u090F\u0932\u093F\u092B|elif",
          else: "\u0905\u0928\u094D\u092F\u0925\u093E|else",
          for: "\u0915\u0947 \u0932\u093F\u092F\u0947|for",
          forward: "\u0906\u0917\u0947|forward",
          from: "\u0938\u0947|from",
          gray: "gray",
          green: "green",
          if: "\u0905\u0917\u0930|if",
          in: "\u092E\u0947\u0902|in",
          input: "\u0907\u0928\u092A\u0941\u091F|input",
          is: "\u0939\u0948|is",
          left: "left",
          length: "\u0932\u0902\u092C\u093E\u0908|length",
          or: "\u092F\u093E|or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "\u092A\u094D\u0930\u093F\u0902\u091F|print",
          purple: "purple",
          random: "\u0905\u0928\u093F\u092F\u092E\u093F\u0924|random",
          range: "\u0936\u094D\u0930\u0947\u0923\u0940|range",
          red: "red",
          remove: "\u0939\u091F\u093E\u0928\u093E|remove",
          repeat: "\u0926\u094B\u0939\u0930\u093E\u0928\u093E|repeat",
          return: "return",
          right: "right",
          sleep: "\u0928\u0940\u0902\u0926|sleep",
          step: "\u0915\u093C\u0926\u092E|step",
          times: "\u092C\u093E\u0930|times",
          to: "\u0938\u0947|to",
          to_list: "\u0938\u0947|to",
          turn: "\u092E\u094B\u0921\u093C|turn",
          while: "\u0935\u094D\u0939\u093E\u0907\u0932|while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        hu: {
          add: "besz\xFAr|add",
          and: "\xE9s|and",
          ask: "k\xE9rdez|ask",
          at: "list\xE1b\xF3l|at",
          black: "fekete|black",
          blue: "k\xE9k|blue",
          brown: "barna|brown",
          call: "call",
          clear: "t\xF6rl\xE9s|clear",
          color: "sz\xEDn|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "ut\xE1noz|echo",
          elif: "egybk-ha|elif",
          else: "egy\xE9bk\xE9nt|else",
          for: "minden|for",
          forward: "el\u0151re|forward",
          from: "ebb\u0151l|from",
          gray: "sz\xFCrke|gray",
          green: "z\xF6ld|green",
          if: "ha|if",
          in: "eleme|in",
          input: "bek\xE9r|input",
          is: "egyenl\u0151|is",
          left: "balra|left",
          length: "hossz|length",
          or: "vagy|or",
          orange: "narancs|orange",
          pink: "pink",
          pressed: "lenyomva|pressed",
          print: "ki\xEDr|print",
          purple: "lila|purple",
          random: "random",
          range: "szakasz|range",
          red: "piros|red",
          remove: "kivesz|remove",
          repeat: "ism\xE9teld|repeat",
          return: "return",
          right: "jobbra|right",
          sleep: "szundi|sleep",
          step: "l\xE9p\xE9senk\xE9nt|step",
          times: "alkalommal|times",
          to: "t\u0151l|to",
          to_list: "ebbe|to",
          turn: "fordul|turn",
          while: "am\xEDg|while",
          white: "feh\xE9r|white",
          with: "with",
          yellow: "s\xE1rga|yellow",
          DIGIT: "0123456789"
        },
        id: {
          add: "tambah|add",
          and: "dan|and",
          ask: "tanya|ask",
          at: "secara|at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "warna|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "gaungkan|echo",
          elif: "lain_jika|elif",
          else: "lainnya|else",
          for: "untuk|for",
          forward: "maju|forward",
          from: "dari|from",
          gray: "gray",
          green: "green",
          if: "jika|if",
          in: "dalam|in",
          input: "masukan|input",
          is: "adalah|is",
          left: "kiri|left",
          length: "panjang|length",
          or: "atau|or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "cetak|print",
          purple: "purple",
          random: "acak|random",
          range: "batasan|range",
          red: "red",
          remove: "hapus|remove",
          repeat: "ulangi|repeat",
          return: "return",
          right: "kanan|right",
          sleep: "tidur|sleep",
          step: "langkah|step",
          times: "kali|times",
          to: "ke|to",
          to_list: "ke|to",
          turn: "belok|turn",
          while: "selama|while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        it: {
          add: "add",
          and: "e|and",
          ask: "chiedi|ask",
          at: "at",
          black: "nero|black",
          blue: "blu|blue",
          brown: "marrone|brown",
          call: "call",
          clear: "Elimina|clear",
          color: "colore|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "eco|echo",
          elif: "altrimenti se|elif",
          else: "altrimenti|else",
          for: "for",
          forward: "avanti|forward",
          from: "da|from",
          gray: "grigio|gray",
          green: "verde|green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "sinistra|left",
          length: "lunghezza|length",
          or: "or",
          orange: "arancione|orange",
          pink: "rosa|pink",
          pressed: "Premuto|pressed",
          print: "stampa|print",
          purple: "viola|purple",
          random: "a caso|random",
          range: "intervallo|range",
          red: "rosso|red",
          remove: "rimuovi|remove",
          repeat: "ripeti|repeat",
          return: "return",
          right: "right",
          sleep: "dormi|sleep",
          step: "passo|step",
          times: "volte|times",
          to: "to",
          to_list: "to",
          turn: "gira|turn",
          while: "mentre|while",
          white: "bianco|white",
          with: "with",
          yellow: "giallo|yellow",
          DIGIT: "0123456789"
        },
        ja: {
          add: "\u305F\u3059|add",
          and: "and",
          ask: "\u304D\u3051|ask",
          at: "at",
          black: "\u304F\u308D|black",
          blue: "\u3042\u304A|blue",
          brown: "\u3061\u3083\u3044\u308D|brown",
          call: "call",
          clear: "clear",
          color: "\u3044\u308D|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "\u307E\u306D|echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "\u3059\u3059\u3081|forward",
          from: "from",
          gray: "\u306F\u3044\u3044\u308D|gray",
          green: "\u307F\u3069\u308A|green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "\u3072\u3060\u308A|left",
          length: "length",
          or: "or",
          orange: "\u304A\u308C\u3093\u3058|orange",
          pink: "\u3074\u3093\u304F|pink",
          pressed: "pressed",
          print: "\u304B\u3051|print",
          purple: "\u3080\u3089\u3055\u304D|purple",
          random: "random",
          range: "range",
          red: "\u3042\u304B|red",
          remove: "remove",
          repeat: "repeat",
          return: "return",
          right: "\u307F\u304E|right",
          sleep: "\u3084\u3059\u3081|sleep",
          step: "step",
          times: "\u304B\u3044|times",
          to: "to",
          to_list: "to",
          turn: "\u307E\u308F\u308C|turn",
          while: "while",
          white: "\u3057\u308D|white",
          with: "with",
          yellow: "\u304D\u3044\u308D|yellow",
          DIGIT: "0123456789"
        },
        kmr: {
          add: "add",
          and: "and",
          ask: "ask",
          at: "at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "forward",
          from: "from",
          gray: "gray",
          green: "green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "left",
          length: "length",
          or: "or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "print",
          purple: "purple",
          random: "random",
          range: "range",
          red: "red",
          remove: "remove",
          repeat: "repeat",
          return: "return",
          right: "right",
          sleep: "sleep",
          step: "step",
          times: "times",
          to: "to",
          to_list: "to",
          turn: "turn",
          while: "while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        ko: {
          add: "add",
          and: "and",
          ask: "ask",
          at: "at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "forward",
          from: "from",
          gray: "gray",
          green: "green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "left",
          length: "length",
          or: "or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "print",
          purple: "purple",
          random: "random",
          range: "range",
          red: "red",
          remove: "remove",
          repeat: "repeat",
          return: "return",
          right: "right",
          sleep: "sleep",
          step: "step",
          times: "times",
          to: "to",
          to_list: "to",
          turn: "turn",
          while: "while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        mi: {
          add: "add",
          and: "and",
          ask: "ask",
          at: "at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "forward",
          from: "from",
          gray: "gray",
          green: "green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "left",
          length: "length",
          or: "or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "print",
          purple: "purple",
          random: "random",
          range: "range",
          red: "red",
          remove: "remove",
          repeat: "repeat",
          return: "return",
          right: "right",
          sleep: "sleep",
          step: "step",
          times: "times",
          to: "to",
          to_list: "to",
          turn: "turn",
          while: "while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        nb_NO: {
          add: "legg|add",
          and: "og|and",
          ask: "sp\xF8r|ask",
          at: "p\xE5|at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "ekko|echo",
          elif: "elhvis|elif",
          else: "ellers|else",
          for: "for",
          forward: "frem|forward",
          from: "fra|from",
          gray: "gray",
          green: "green",
          if: "hvis|if",
          in: "i|in",
          input: "inndata|input",
          is: "er|is",
          left: "venstre|left",
          length: "lengde|length",
          or: "eller|or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "skriv|print",
          purple: "purple",
          random: "tilfeldig|random",
          range: "sekvens|range",
          red: "red",
          remove: "fjern|remove",
          repeat: "gjenta|repeat",
          return: "return",
          right: "h\xF8yre|right",
          sleep: "sov|sleep",
          step: "steg|step",
          times: "ganger|times",
          to: "til|to",
          to_list: "til|to",
          turn: "snu|turn",
          while: "mens|while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        nl: {
          add: "voeg|add",
          and: "en|and",
          ask: "vraag|ask",
          at: "op|at",
          black: "zwart|black",
          blue: "blauw|blue",
          brown: "bruin|brown",
          call: "call",
          clear: "wis|clear",
          color: "kleur|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "alsanders|elif",
          else: "anders|else",
          for: "voor|for",
          forward: "vooruit|forward",
          from: "uit|from",
          gray: "grijs|gray",
          green: "groen|green",
          if: "als|if",
          in: "in",
          input: "invoer|input",
          is: "is",
          left: "links|left",
          length: "lengte|length",
          or: "of|or",
          orange: "oranje|orange",
          pink: "roze|pink",
          pressed: "ingedrukt|pressed",
          print: "print",
          purple: "paars|purple",
          random: "willekeurig|random",
          range: "bereik|range",
          red: "rood|red",
          remove: "verwijder|remove",
          repeat: "herhaal|repeat",
          return: "return",
          right: "rechts|right",
          sleep: "slaap|sleep",
          step: "stap|step",
          times: "keer|times",
          to: "tot|to",
          to_list: "toe aan|to",
          turn: "draai|turn",
          while: "zolang|while",
          white: "wit|white",
          with: "with",
          yellow: "geel|yellow",
          DIGIT: "0123456789"
        },
        pa_PK: {
          add: "\u062F\u06BE\u0646|add",
          and: "\u062A\u06D2|and",
          ask: "\u0633\u0648\u0627\u0644|ask",
          at: "\u0633\u062A\u06BE\u062A\u06CC|at",
          black: "\u06A9\u0627\u0644\u0627|black",
          blue: "\u0646\u06CC\u0644\u0627|blue",
          brown: "\u0628\u06BE\u0648\u0631\u0627|brown",
          call: "call",
          clear: "clear",
          color: "\u0631\u0646\u06AF|color",
          comma: "\u060C|,",
          def: "def",
          define: "define",
          echo: "\u0641\u06CC\u0631|echo",
          elif: "\u06C1\u0648\u0631|elif",
          else: "\u0648\u06A9\u06BE\u0631\u0627|else",
          for: "\u062C\u062F\u0648\u06BA|for",
          forward: "\u0627\u06AF\u06D2|forward",
          from: "\u0633\u0631\u0648\u062A|from",
          gray: "\u0633\u0644\u06CC\u0679\u06CC|gray",
          green: "\u06C1\u0631\u0627|green",
          if: "\u062C\u06D2|if",
          in: "\u0627\u0646\u062F\u0631|in",
          input: "\u0627\u06CC\u0646\u067E\u0679|input",
          is: "\u0633\u0645\u0627\u0646|is",
          left: "\u06A9\u06BE\u0628\u06D2|left",
          length: "\u0644\u0645\u0628\u0627\u0626\u06CC|length",
          or: "\u06CC\u0627|or",
          orange: "\u0633\u0646\u062A\u0631\u0627|orange",
          pink: "\u06AF\u0644\u0627\u0628\u06CC|pink",
          pressed: "pressed",
          print: "\u0686\u067E\u0627\u0626\u06CC|print",
          purple: "\u062C\u0627\u0645\u0646\u06CC|purple",
          random: "\u0631\u0644\u0648\u0627\u0646|random",
          range: "\u0633\u0644\u0633\u0644\u06C1|range",
          red: "\u0644\u0627\u0644|red",
          remove: "\u0645\u0679\u0627\u06A9\u06D2|remove",
          repeat: "\u062F\u06C1\u0631\u0627|repeat",
          return: "return",
          right: "\u0633\u062C\u06D2|right",
          sleep: "\u0646\u06CC\u0646\u062F|sleep",
          step: "\u0633\u0637\u0631|step",
          times: "\u0636\u0631\u0628|times",
          to: "\u0645\u0646\u0632\u0644|to",
          to_list: "\u0645\u0646\u0632\u0644|to",
          turn: "\u0645\u0648\u0691\u0646|turn",
          while: "\u062C\u062F\u06A9\u06C1|while",
          white: "\u0686\u0679\u0627|white",
          with: "with",
          yellow: "\u067E\u06CC\u0644\u0627|yellow",
          DIGIT: "0\u06F01\u06F12\u06F23\u06F34\u06F45\u06F56\u06F67\u06F78\u06F89\u06F9"
        },
        pap: {
          add: "add",
          and: "and",
          ask: "ask",
          at: "at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "forward",
          from: "from",
          gray: "gray",
          green: "green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "left",
          length: "length",
          or: "or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "print",
          purple: "purple",
          random: "random",
          range: "range",
          red: "red",
          remove: "remove",
          repeat: "repeat",
          return: "return",
          right: "right",
          sleep: "sleep",
          step: "step",
          times: "times",
          to: "to",
          to_list: "to",
          turn: "turn",
          while: "while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        pl: {
          add: "dodaj|add",
          and: "i|and",
          ask: "zapytaj|ask",
          at: "pozycja|at",
          black: "czarny|black",
          blue: "niebieski|blue",
          brown: "br\u0105zowy|brown",
          call: "call",
          clear: "wyczy\u015B\u0107|clear",
          color: "kolor|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "do\u0142\u0105cz|echo",
          elif: "albo|elif",
          else: "inaczej|else",
          for: "dla|for",
          forward: "naprz\xF3d|forward",
          from: "z|from",
          gray: "szary|gray",
          green: "zielony|green",
          if: "je\u017Celi|if",
          in: "w|in",
          input: "wprowad\u017A|input",
          is: "to|is",
          left: "lewo|left",
          length: "d\u0142ugo\u015B\u0107|length",
          or: "lub|or",
          orange: "pomara\u0144czowy|orange",
          pink: "r\xF3\u017Cowy|pink",
          pressed: "naci\u015Bni\u0119ty|pressed",
          print: "napisz|print",
          purple: "fioletowy|purple",
          random: "losowa|random",
          range: "zakres|range",
          red: "czerwony|red",
          remove: "usu\u0144|remove",
          repeat: "powt\xF3rz|repeat",
          return: "return",
          right: "prawo|right",
          sleep: "\u015Bpij|sleep",
          step: "krok|step",
          times: "razy|times",
          to: "do|to",
          to_list: "do|to",
          turn: "obr\xF3\u0107|turn",
          while: "dop\xF3ki|while",
          white: "bia\u0142y|white",
          with: "with",
          yellow: "\u017C\xF3\u0142ty|yellow",
          DIGIT: "0123456789"
        },
        pt_BR: {
          add: "some|add",
          and: "e|and",
          ask: "pergunte|ask",
          at: "em|at",
          black: "preto|black",
          blue: "azul|blue",
          brown: "marrom|brown",
          call: "call",
          clear: "limpar|clear",
          color: "cor|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "eco|echo",
          elif: "sen\xE3ose|elif",
          else: "sen\xE3o|else",
          for: "para|for",
          forward: "adiante|forward",
          from: "de|from",
          gray: "cinza|gray",
          green: "verde|green",
          if: "se|if",
          in: "em|in",
          input: "entrada|input",
          is: "\xE9|is",
          left: "esquerda|left",
          length: "comprimento|length",
          or: "ou|or",
          orange: "laranja|orange",
          pink: "rosa|pink",
          pressed: "apertado|pressed",
          print: "imprima|print",
          purple: "roxo|purple",
          random: "aleat\xF3rio|random",
          range: "intervalo|range",
          red: "vermelho|red",
          remove: "remova|remove",
          repeat: "repita|repeat",
          return: "return",
          right: "direita|right",
          sleep: "durma|sleep",
          step: "passo|step",
          times: "vezes|times",
          to: "para|to",
          to_list: "at\xE9|to",
          turn: "gire|turn",
          while: "enquanto|while",
          white: "branco|white",
          with: "with",
          yellow: "amarelo|yellow",
          DIGIT: "0123456789"
        },
        pt_PT: {
          add: "adicionar|add",
          and: "e|and",
          ask: "perguntar|ask",
          at: "em|at",
          black: "preto|black",
          blue: "azul|blue",
          brown: "castanho|brown",
          call: "call",
          clear: "clear",
          color: "cor|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "eco|echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "avan\xE7ar|forward",
          from: "de|from",
          gray: "cinzento|gray",
          green: "verde|green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "esquerda|left",
          length: "comprimento|length",
          or: "or",
          orange: "cor de laranja|orange",
          pink: "cor de rosa|pink",
          pressed: "pressed",
          print: "imprimir|print",
          purple: "roxo|purple",
          random: "random",
          range: "intervalo|range",
          red: "vermelho|red",
          remove: "remover|remove",
          repeat: "repetir|repeat",
          return: "return",
          right: "direita|right",
          sleep: "dormir|sleep",
          step: "passo|step",
          times: "vezes|times",
          to: "to",
          to_list: "para|to",
          turn: "virar|turn",
          while: "enquanto|while",
          white: "branco|white",
          with: "with",
          yellow: "amarelo|yellow",
          DIGIT: "0123456789"
        },
        ro: {
          add: "adun\u0103|add",
          and: "si|and",
          ask: "\xEEntreab\u0103|ask",
          at: "la|at",
          black: "negru|black",
          blue: "albastru|blue",
          brown: "maro|brown",
          call: "call",
          clear: "\u0219terge|clear",
          color: "culoare|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "altfel dac\u0103|elif",
          else: "else",
          for: "pentru|for",
          forward: "\xEEnainte|forward",
          from: "de la|from",
          gray: "gri|gray",
          green: "verde|green",
          if: "if",
          in: "in",
          input: "intrare|input",
          is: "is",
          left: "st\xE2nga|left",
          length: "lungime|length",
          or: "sau|or",
          orange: "portocaliu|orange",
          pink: "roz|pink",
          pressed: "ap\u0103sat|pressed",
          print: "print",
          purple: "mov|purple",
          random: "aleatoriu|random",
          range: "interval|range",
          red: "ro\u0219u|red",
          remove: "elimin\u0103|remove",
          repeat: "repet\u0103|repeat",
          return: "return",
          right: "dreapta|right",
          sleep: "sleep",
          step: "pas|step",
          times: "inmul\u021Bit|times",
          to: "c\u0103tre|to",
          to_list: "c\u0103tre|to",
          turn: "intoarce|turn",
          while: "\xEEn timp ce|while",
          white: "alb|white",
          with: "with",
          yellow: "galben|yellow",
          DIGIT: "0123456789"
        },
        ru: {
          add: "\u0434\u043E\u0431\u0430\u0432\u0438\u0442\u044C|add",
          and: "\u0438|and",
          ask: "\u0437\u0430\u043F\u0440\u043E\u0441\u0438\u0442\u044C|ask",
          at: "\u0432|at",
          black: "\u0447\u0451\u0440\u043D\u044B\u0439|black",
          blue: "\u0441\u0438\u043D\u0438\u0439|blue",
          brown: "\u043A\u043E\u0440\u0438\u0447\u043D\u0435\u0432\u044B\u0439|brown",
          call: "call",
          clear: "\u043E\u0447\u0438\u0441\u0442\u0438\u0442\u044C|clear",
          color: "\u0446\u0432\u0435\u0442|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "\u043F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C|echo",
          elif: "\u0438\u043D\u0430\u0447\u0435, \u0435\u0441\u043B\u0438|elif",
          else: "\u0438\u043D\u0430\u0447\u0435|else",
          for: "\u0434\u043B\u044F|for",
          forward: "\u0432\u043F\u0435\u0440\u0451\u0434|forward",
          from: "\u0438\u0437|from",
          gray: "\u0441\u0435\u0440\u044B\u0439|gray",
          green: "\u0437\u0435\u043B\u0451\u043D\u044B\u0439|green",
          if: "\u0435\u0441\u043B\u0438|if",
          in: "\u0432|in",
          input: "\u0432\u0432\u043E\u0434|input",
          is: "\u044D\u0442\u043E|is",
          left: "\u043D\u0430\u043B\u0435\u0432\u043E|left",
          length: "\u0434\u043B\u0438\u043D\u0430|length",
          or: "\u0438\u043B\u0438|or",
          orange: "\u043E\u0440\u0430\u043D\u0436\u0435\u0432\u044B\u0439|orange",
          pink: "\u0440\u043E\u0437\u043E\u0432\u044B\u0439|pink",
          pressed: "\u043D\u0430\u0436\u043C\u0438\u0442\u0435|pressed",
          print: "\u043F\u0435\u0447\u0430\u0442\u0430\u0442\u044C|print",
          purple: "\u043F\u0443\u0440\u043F\u0443\u0440\u043D\u044B\u0439|purple",
          random: "\u0441\u043B\u0443\u0447\u0430\u0439\u043D\u043E\u043C|random",
          range: "\u043F\u0440\u043E\u043C\u0435\u0436\u0443\u0442\u043E\u043A|range",
          red: "\u043A\u0440\u0430\u0441\u043D\u044B\u0439|red",
          remove: "\u0443\u0434\u0430\u043B\u0438\u0442\u044C|remove",
          repeat: "\u043F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C|repeat",
          return: "return",
          right: "\u043D\u0430\u043F\u0440\u0430\u0432\u043E|right",
          sleep: "\u0437\u0430\u0441\u043D\u0443\u0442\u044C|sleep",
          step: "\u0448\u0430\u0433|step",
          times: "\u0440\u0430\u0437|times",
          to: "\u0434\u043E|to",
          to_list: "\u0432|to",
          turn: "\u043F\u043E\u0432\u0435\u0440\u043D\u0443\u0442\u044C|turn",
          while: "\u043F\u043E\u043A\u0430|while",
          white: "\u0431\u0435\u043B\u044B\u0439|white",
          with: "with",
          yellow: "\u0436\u0451\u043B\u0442\u044B\u0439|yellow",
          DIGIT: "0123456789"
        },
        sq: {
          add: "shtoni|add",
          and: "dhe|and",
          ask: "pyet|ask",
          at: "n\xEB|at",
          black: "zez\xEB|black",
          blue: "blu|blue",
          brown: "kafe|brown",
          call: "thirr|call",
          clear: "pastro|clear",
          color: "ngjyr\xEB|color",
          comma: ",",
          def: "def",
          define: "defino|define",
          echo: "p\xEBrs\xEBrit|echo",
          elif: "nendryshe|elif",
          else: "ndryshe|else",
          for: "p\xEBr|for",
          forward: "p\xEBrpara|forward",
          from: "nga|from",
          gray: "gri|gray",
          green: "jeshile|green",
          if: "n\xEBse|if",
          in: "n\xEB|in",
          input: "hyrje|input",
          is: "\xEBsht\xEB|is",
          left: "majtas|left",
          length: "gjat\xEBsia|length",
          or: "ose|or",
          orange: "portokalli|orange",
          pink: "roz\xEB|pink",
          pressed: "shtypur|pressed",
          print: "printo|print",
          purple: "vjollc\xEB|purple",
          random: "rast\xEBsi|random",
          range: "varg|range",
          red: "kuqe|red",
          remove: "hiqni|remove",
          repeat: "p\xEBrs\xEBrit|repeat",
          return: "rikthe|return",
          right: "drejt\xEB|right",
          sleep: "fle|sleep",
          step: "hap|step",
          times: "her|times",
          to: "deri|to",
          to_list: "deri|to",
          turn: "kthes\xEB|turn",
          while: "derisa|while",
          white: "bardh\xEB|white",
          with: "me|with",
          yellow: "verdh\xEB|yellow",
          DIGIT: "0123456789"
        },
        sr: {
          add: "dodaj|add",
          and: "i|and",
          ask: "pitaj|ask",
          at: "na|at",
          black: "crna|black",
          blue: "plava|blue",
          brown: "braon|brown",
          call: "call",
          clear: "o\u010Disti|clear",
          color: "boja|color",
          comma: ",",
          def: "def",
          define: "defini\u0161i|define",
          echo: "poka\u017Ei|echo",
          elif: "ina\u010De ako|elif",
          else: "ina\u010De|else",
          for: "za|for",
          forward: "napred|forward",
          from: "od|from",
          gray: "siva|gray",
          green: "zelena|green",
          if: "ako|if",
          in: "u|in",
          input: "ulaz|input",
          is: "je|is",
          left: "levo|left",
          length: "du\u017Eina|length",
          or: "ili|or",
          orange: "narand\u017Easta|orange",
          pink: "roze|pink",
          pressed: "pritisnuto|pressed",
          print: "\u0161tampaj|print",
          purple: "ljubi\u010Dasta|purple",
          random: "nasumi\u010Dno|random",
          range: "opseg|range",
          red: "crvena|red",
          remove: "obri\u0161i|remove",
          repeat: "ponovi|repeat",
          return: "vrati|return",
          right: "desno|right",
          sleep: "spavanje|sleep",
          step: "korak|step",
          times: "vremena|times",
          to: "u|to",
          to_list: "u|to",
          turn: "okreni|turn",
          while: "dok|while",
          white: "bela|white",
          with: "sa|with",
          yellow: "\u017Euta|yellow",
          DIGIT: "0123456789"
        },
        sv: {
          add: "addera|add",
          and: "och|and",
          ask: "fr\xE5ga|ask",
          at: "vid|at",
          black: "svart|black",
          blue: "bl\xE5|blue",
          brown: "brun|brown",
          call: "anropa|call",
          clear: "rensa|clear",
          color: "f\xE4rg|color",
          comma: ",",
          def: "def",
          define: "definiera|define",
          echo: "eko|echo",
          elif: "anom|elif",
          else: "annars|else",
          for: "f\xF6r|for",
          forward: "fram\xE5t|forward",
          from: "fr\xE5n|from",
          gray: "gr\xE5|gray",
          green: "gr\xF6n|green",
          if: "om|if",
          in: "i|in",
          input: "inmatning|input",
          is: "\xE4r|is",
          left: "v\xE4nster|left",
          length: "l\xE4ngd|length",
          or: "eller|or",
          orange: "orange",
          pink: "rosa|pink",
          pressed: "nedtryckt|pressed",
          print: "skriv|print",
          purple: "lila|purple",
          random: "slump|random",
          range: "intervall|range",
          red: "r\xF6d|red",
          remove: "radera|remove",
          repeat: "upprepa|repeat",
          return: "returnera|return",
          right: "h\xF6ger|right",
          sleep: "sov|sleep",
          step: "steg|step",
          times: "g\xE5nger|times",
          to: "till|to",
          to_list: "till|to",
          turn: "sv\xE4ng|turn",
          while: "medan|while",
          white: "vit|white",
          with: "med|with",
          yellow: "gul|yellow",
          DIGIT: "0123456789"
        },
        sw: {
          add: "add",
          and: "and",
          ask: "ask",
          at: "at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "forward",
          from: "from",
          gray: "gray",
          green: "green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "left",
          length: "length",
          or: "or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "print",
          purple: "purple",
          random: "random",
          range: "range",
          red: "red",
          remove: "remove",
          repeat: "repeat",
          return: "return",
          right: "right",
          sleep: "sleep",
          step: "step",
          times: "times",
          to: "to",
          to_list: "to",
          turn: "turn",
          while: "while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        te: {
          add: "\u0C1C\u0C4B\u0C21\u0C3F\u0C02\u0C1A\u0C41|add",
          and: "\u0C2E\u0C30\u0C3F\u0C2F\u0C41|and",
          ask: "\u0C05\u0C21\u0C17\u0C02\u0C21\u0C3F|ask",
          at: "\u0C35\u0C26\u0C4D\u0C26|at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "\u0C2A\u0C4D\u0C30\u0C24\u0C3F\u0C27\u0C4D\u0C35\u0C28\u0C3F|echo",
          elif: "\u0C2E\u0C30\u0C4A\u0C15\u0C1F\u0C3F \u0C09\u0C02\u0C1F\u0C47|elif",
          else: "\u0C32\u0C47\u0C15\u0C2A\u0C4B\u0C24\u0C47|else",
          for: "\u0C15\u0C4B\u0C38\u0C02|for",
          forward: "\u0C2E\u0C41\u0C02\u0C26\u0C41\u0C15\u0C41|forward",
          from: "\u0C28\u0C41\u0C02\u0C21\u0C3F|from",
          gray: "gray",
          green: "green",
          if: "\u0C09\u0C02\u0C1F\u0C47|if",
          in: "\u092E\u0947\u0C32\u0C4B|in",
          input: "\u0C07\u0C28\u0C4D\u0C2A\u0C41\u0C1F\u0C4D|input",
          is: "\u0C09\u0C02\u0C26\u0C3F|is",
          left: "left",
          length: "\u0C2A\u0C4A\u0C21\u0C35\u0C41|length",
          or: "\u0C32\u0C47\u0C26\u0C3E|or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "\u0C2E\u0C41\u0C26\u0C4D\u0C30\u0C23|print",
          purple: "purple",
          random: "\u0C2F\u0C3E\u0C26\u0C43\u0C1A\u0C4D\u0C1B\u0C3F\u0C15\u0C02\u0C17\u0C3E|random",
          range: "\u0C2A\u0C30\u0C3F\u0C27\u0C3F|range",
          red: "red",
          remove: "\u0C24\u0C4A\u0C32\u0C17\u0C3F\u0C02\u0C1A\u0C41|remove",
          repeat: "\u0C2A\u0C41\u0C28\u0C30\u0C3E\u0C35\u0C43\u0C24\u0C02|repeat",
          return: "return",
          right: "right",
          sleep: "\u0C28\u0C3F\u0C26\u0C4D\u0C30|sleep",
          step: "\u0C05\u0C21\u0C41\u0C17\u0C41|step",
          times: "\u0C38\u0C3E\u0C30\u0C4D\u0C32\u0C41|times",
          to: "\u0C15\u0C41|to",
          to_list: "\u0C15\u0C41|to",
          turn: "\u0C2E\u0C32\u0C41\u0C2A\u0C41|turn",
          while: "\u0C05\u0C2F\u0C3F\u0C24\u0C47|while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        th: {
          add: "\u0E40\u0E1E\u0E34\u0E48\u0E21|add",
          and: "\u0E41\u0E25\u0E30|and",
          ask: "\u0E16\u0E32\u0E21\u0E27\u0E48\u0E32|ask",
          at: "\u0E41\u0E1A\u0E1A|at",
          black: "\u0E14\u0E33|black",
          blue: "\u0E19\u0E49\u0E33\u0E40\u0E07\u0E34\u0E19|blue",
          brown: "\u0E19\u0E49\u0E33\u0E15\u0E32\u0E25|brown",
          call: "call",
          clear: "\u0E25\u0E1A\u0E01\u0E23\u0E30\u0E14\u0E32\u0E19|clear",
          color: "\u0E2A\u0E35|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "\u0E1E\u0E39\u0E14|echo",
          elif: "\u0E2B\u0E23\u0E37\u0E2D\u0E16\u0E49\u0E32|elif",
          else: "\u0E44\u0E21\u0E48\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E31\u0E49\u0E19|else",
          for: "\u0E43\u0E2B\u0E49|for",
          forward: "\u0E40\u0E14\u0E34\u0E19\u0E2B\u0E19\u0E49\u0E32|forward",
          from: "\u0E08\u0E32\u0E01|from",
          gray: "\u0E40\u0E17\u0E32|gray",
          green: "\u0E40\u0E02\u0E35\u0E22\u0E27|green",
          if: "\u0E16\u0E49\u0E32|if",
          in: "\u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19|in",
          input: "\u0E23\u0E31\u0E1A\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25|input",
          is: "\u0E04\u0E37\u0E2D|is",
          left: "\u0E0B\u0E49\u0E32\u0E22|left",
          length: "\u0E04\u0E27\u0E32\u0E21\u0E22\u0E32\u0E27|length",
          or: "\u0E2B\u0E23\u0E37\u0E2D|or",
          orange: "\u0E2A\u0E49\u0E21|orange",
          pink: "\u0E0A\u0E21\u0E1E\u0E39|pink",
          pressed: "\u0E1B\u0E38\u0E48\u0E21\u0E17\u0E35\u0E48\u0E16\u0E39\u0E01\u0E01\u0E14|pressed",
          print: "\u0E41\u0E2A\u0E14\u0E07|print",
          purple: "\u0E21\u0E48\u0E27\u0E07|purple",
          random: "\u0E2A\u0E38\u0E48\u0E21|random",
          range: "\u0E0A\u0E48\u0E27\u0E07|range",
          red: "\u0E41\u0E14\u0E07|red",
          remove: "\u0E25\u0E1A|remove",
          repeat: "\u0E17\u0E33\u0E0B\u0E49\u0E33|repeat",
          return: "return",
          right: "\u0E02\u0E27\u0E32|right",
          sleep: "\u0E23\u0E2D|sleep",
          step: "\u0E40\u0E14\u0E34\u0E19|step",
          times: "\u0E04\u0E23\u0E31\u0E49\u0E07|times",
          to: "\u0E08\u0E19\u0E16\u0E36\u0E07|to",
          to_list: "\u0E44\u0E1B\u0E22\u0E31\u0E07|to",
          turn: "\u0E40\u0E25\u0E35\u0E49\u0E22\u0E27|turn",
          while: "\u0E40\u0E21\u0E37\u0E48\u0E2D\u0E44\u0E2B\u0E23\u0E48\u0E01\u0E47\u0E15\u0E32\u0E21\u0E17\u0E35\u0E48|while",
          white: "\u0E02\u0E32\u0E27|white",
          with: "with",
          yellow: "\u0E40\u0E2B\u0E25\u0E37\u0E2D\u0E07|yellow",
          DIGIT: "0123456789"
        },
        tl: {
          add: "add",
          and: "and",
          ask: "ask",
          at: "at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "forward",
          from: "from",
          gray: "gray",
          green: "green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "left",
          length: "length",
          or: "or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "print",
          purple: "purple",
          random: "random",
          range: "range",
          red: "red",
          remove: "remove",
          repeat: "repeat",
          return: "return",
          right: "right",
          sleep: "sleep",
          step: "step",
          times: "times",
          to: "to",
          to_list: "to",
          turn: "turn",
          while: "while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        tn: {
          add: "tsenya|add",
          and: "and",
          ask: "botsa|ask",
          at: "at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "elif",
          else: "faese|else",
          for: "for",
          forward: "forward",
          from: "from",
          gray: "gray",
          green: "green",
          if: "fa|if",
          in: "in",
          input: "input",
          is: "ke|is",
          left: "left",
          length: "length",
          or: "or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "gatisa|print",
          purple: "purple",
          random: "random",
          range: "range",
          red: "red",
          remove: "ntsha|remove",
          repeat: "repeat",
          return: "return",
          right: "right",
          sleep: "sleep",
          step: "step",
          times: "times",
          to: "to",
          to_list: "to",
          turn: "turn",
          while: "while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        },
        tr: {
          add: "ekle|add",
          and: "ve|and",
          ask: "sor|ask",
          at: "i\xE7inden|at",
          black: "siyah|black",
          blue: "mavi|blue",
          brown: "kahverengi|brown",
          call: "\xE7a\u011F\u0131r|call",
          clear: "temizle|clear",
          color: "renk|color",
          comma: ",",
          def: "tan\u0131|def",
          define: "tan\u0131mla|define",
          echo: "yank\u0131la|echo",
          elif: "de\u011File\u011Fer|elif",
          else: "de\u011Filse|else",
          for: "\u015Funun i\xE7in|for",
          forward: "ileri|forward",
          from: "\u015Furadan|from",
          gray: "gri|gray",
          green: "ye\u015Fil|green",
          if: "e\u011Fer|if",
          in: "\u015Funda|in",
          input: "girdi|input",
          is: "e\u015Fit|is",
          left: "sol|left",
          length: "uzunluk|length",
          or: "veya|or",
          orange: "turuncu|orange",
          pink: "pembe|pink",
          pressed: "bas\u0131l\u0131|pressed",
          print: "yazd\u0131r|print",
          purple: "mor|purple",
          random: "rastgele|random",
          range: "aral\u0131k|range",
          red: "k\u0131rm\u0131z\u0131|red",
          remove: "kald\u0131r|remove",
          repeat: "tekrarla|repeat",
          return: "gerid\xF6n|return",
          right: "sa\u011F|right",
          sleep: "uyu|sleep",
          step: "ad\u0131m|step",
          times: "kere|times",
          to: "\u015Furaya|to",
          to_list: "\u015Furaya|to",
          turn: "d\xF6nd\xFCr|turn",
          while: "\u015Fu iken|while",
          white: "beyaz|white",
          with: "ile|with",
          yellow: "sar\u0131|yellow",
          DIGIT: "0123456789"
        },
        uk: {
          add: "\u0434\u043E\u0434\u0430\u0439|add",
          and: "\u0456|and",
          ask: "\u0437\u0430\u043F\u0438\u0442\u0430\u0439|ask",
          at: "\u043D\u0430 \u043F\u043E\u0437\u0438\u0446\u0456\u0457|at",
          black: "\u0447\u043E\u0440\u043D\u0438\u0439|black",
          blue: "\u0441\u0438\u043D\u0456\u0439|blue",
          brown: "\u043A\u043E\u0440\u0438\u0447\u043D\u0435\u0432\u0438\u0439|brown",
          call: "call",
          clear: "\u043E\u0447\u0438\u0441\u0442\u0438\u0442\u0438|clear",
          color: "\u043A\u043E\u043B\u0456\u0440|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "\u0435\u0445\u043E|echo",
          elif: "\u0456\u043D\u0430\u043A\u0448\u0435 \u044F\u043A\u0449\u043E|elif",
          else: "\u0456\u043D\u0430\u043A\u0448\u0435|else",
          for: "\u0434\u043B\u044F|for",
          forward: "\u0432\u043F\u0435\u0440\u0435\u0434|forward",
          from: "i\u0437|\u0437|from",
          gray: "\u0441\u0456\u0440\u0438\u0439|gray",
          green: "\u0437\u0435\u043B\u0435\u043D\u0438\u0439|green",
          if: "\u044F\u043A\u0449\u043E|if",
          in: "\u0432|in",
          input: "\u0432\u0432\u0435\u0434\u0438|input",
          is: "\u0446\u0435|is",
          left: "\u0432\u043B\u0456\u0432\u043E|left",
          length: "\u0434\u043E\u0432\u0436\u0438\u043D\u0430|length",
          or: "\u0430\u0431\u043E|or",
          orange: "\u043E\u0440\u0430\u043D\u0436\u0435\u0432\u0438\u0439|orange",
          pink: "\u0440\u043E\u0436\u0435\u0432\u0438\u0439|pink",
          pressed: "\u043D\u0430\u0442\u0438\u0441\u043D\u0443\u0432|pressed",
          print: "\u0434\u0440\u0443\u043A\u0443\u0439|print",
          purple: "\u0444\u0456\u043E\u043B\u0435\u0442\u043E\u0432\u0438\u0439|purple",
          random: "\u0432\u0438\u043F\u0430\u0434\u043A\u043E\u0432\u0438\u0439|\u0432\u0438\u043F\u0430\u0434\u043A\u043E\u0432\u0456\u0439|random",
          range: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D|\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043Di|range",
          red: "\u0447\u0435\u0440\u0432\u043E\u043D\u0438\u0439|red",
          remove: "\u0432\u0438\u0434\u0430\u043B\u0438|remove",
          repeat: "\u043F\u043E\u0432\u0442\u043E\u0440\u0438|repeat",
          return: "return",
          right: "\u0432\u043F\u0440\u0430\u0432\u043E|right",
          sleep: "\u043F\u043E\u0447\u0435\u043A\u0430\u0439|sleep",
          step: "\u043A\u0440\u043E\u043A|step",
          times: "\u0440\u0430\u0437\u0456\u0432|\u0440\u0430\u0437\u0438|\u0440\u0430\u0437|times",
          to: "\u0434\u043E|to",
          to_list: "\u0434\u043E|to",
          turn: "\u043F\u043E\u0432\u0435\u0440\u043D\u0438|turn",
          while: "\u0442\u043E\u0434\u0456 \u044F\u043A|while",
          white: "\u0431\u0456\u043B\u0438\u0439|white",
          with: "with",
          yellow: "\u0436\u043E\u0432\u0442\u0438\u0439|yellow",
          DIGIT: "0123456789"
        },
        ur: {
          add: "\u0634\u0627\u0645\u0644|add",
          and: "\u0627\u0648\u0631|and",
          ask: "\u0628\u062A\u0627\u0624|ask",
          at: "\u06A9\u0648\u0626\u06CC|at",
          black: "\u06A9\u0627\u0644\u0627|black",
          blue: "\u0646\u06CC\u0644\u0627|blue",
          brown: "\u0628\u0631\u0627\u0624\u0646|brown",
          call: "call",
          clear: "\u0635\u0627\u0641|clear",
          color: "\u0631\u0646\u06AF|color",
          comma: "\u060C|,",
          def: "def",
          define: "define",
          echo: "\u067E\u06A9\u0627\u0631|echo",
          elif: "\u06CC\u0627\u0627\u06AF\u0631|elif",
          else: "\u0648\u0631\u0646\u06C1|else",
          for: "\u0641\u06CC|for",
          forward: "\u0622\u06AF\u06D2|forward",
          from: "\u0633\u06D2|from",
          gray: "\u06AF\u0631\u06D2|gray",
          green: "\u0633\u0628\u0632|green",
          if: "\u0627\u06AF\u0631|if",
          in: "\u0645\u06CC\u06BA|in",
          input: "\u0628\u062A\u0627\u0624|input",
          is: "\u06C1\u06D2|is",
          left: "\u0628\u0627\u0626\u06CC\u06BA|left",
          length: "\u0644\u0645\u0628\u0627\u0626\u06CC|length",
          or: "\u06CC\u0627|or",
          orange: "\u0627\u0648\u0631\u06CC\u0646\u062C|orange",
          pink: "\u06AF\u0644\u0627\u0628\u06CC|pink",
          pressed: "\u062F\u0628\u0627 \u06C1\u0648\u0627|pressed",
          print: "\u062F\u06A9\u06BE\u0627\u0624|print",
          purple: "\u062C\u0627\u0645\u0646\u06CC|purple",
          random: "\u0633\u0627|random",
          range: "\u062D\u062F|range",
          red: "\u0633\u0631\u062E|red",
          remove: "\u0646\u06A9\u0627\u0644\u0648|remove",
          repeat: "\u0645\u06A9\u0631\u0631|repeat",
          return: "return",
          right: "\u062F\u0627\u0626\u06CC\u06BA|right",
          sleep: "\u0622\u0631\u0627\u0645|sleep",
          step: "\u0642\u062F\u0645|step",
          times: "\u062F\u0641\u0639\u06C1|times",
          to: "\u0633\u06D2|to",
          to_list: "\u0627\u0646\u062F\u0631|to",
          turn: "\u0645\u0691\u0648|turn",
          while: "\u062C\u0628\u062A\u06A9|while",
          white: "\u0633\u0641\u06CC\u062F|white",
          with: "with",
          yellow: "\u067E\u06CC\u0644\u0627|yellow",
          DIGIT: "0123456789"
        },
        vi: {
          add: "add",
          and: "v\xE0|and",
          ask: "h\u1ECFi|ask",
          at: "at",
          black: "\u0111en|black",
          blue: "lam|blue",
          brown: "n\xE2u|brown",
          call: "call",
          clear: "clear",
          color: "m\xE0u|color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "\u0111\xE1p|echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "ti\u1EBFn|forward",
          from: "from",
          gray: "x\xE1m|gray",
          green: "l\u1EE5c|green",
          if: "n\u1EBFu|if",
          in: "in",
          input: "input",
          is: "l\xE0|is",
          left: "tr\xE1i|left",
          length: "length",
          or: "ho\u1EB7c|or",
          orange: "cam|orange",
          pink: "h\u1ED3ng|pink",
          pressed: "pressed",
          print: "xu\u1EA5t|print",
          purple: "t\xEDm|purple",
          random: "ng\u1EABu_nhi\xEAn|random",
          range: "range",
          red: "\u0111\u1ECF|red",
          remove: "remove",
          repeat: "repeat",
          return: "return",
          right: "ph\u1EA3i|right",
          sleep: "sleep",
          step: "step",
          times: "times",
          to: "to",
          to_list: "to",
          turn: "quay|turn",
          while: "while",
          white: "tr\u1EAFng|white",
          with: "with",
          yellow: "v\xE0ng|yellow",
          DIGIT: "0123456789"
        },
        zh_Hans: {
          add: "\u52A0|add",
          and: "\u5E76\u4E14|and",
          ask: "\u63D0\u95EE|ask",
          at: "\u5728|at",
          black: "\u9ED1\u8272|black",
          blue: "\u84DD\u8272|blue",
          brown: "\u68D5\u8272|brown",
          call: "call",
          clear: "\u6E05\u9664|clear",
          color: "\u989C\u8272|color",
          comma: "\uFF0C|\u3001|,",
          def: "def",
          define: "define",
          echo: "\u56DE\u58F0|echo",
          elif: "\u5426\u5219\u5982\u679C|elif",
          else: "\u5426\u5219|else",
          for: "\u53D6|for",
          forward: "\u5411\u524D|forward",
          from: "\u4ECE|from",
          gray: "\u7070\u8272|gray",
          green: "\u7EFF\u8272|green",
          if: "\u5982\u679C|if",
          in: "\u5728\u91CC\u9762|in",
          input: "\u8F93\u5165|input",
          is: "\u662F|is",
          left: "\u5DE6|left",
          length: "\u957F\u5EA6|length",
          or: "\u6216|or",
          orange: "\u6A59\u8272|orange",
          pink: "\u7C89\u7EA2\u8272|pink",
          pressed: "\u6309\u4E0B|pressed",
          print: "\u6253\u5370|print",
          purple: "\u7D2B\u8272|purple",
          random: "\u968F\u673A|random",
          range: "\u8303\u56F4|range",
          red: "\u7EA2\u8272|red",
          remove: "\u79FB\u9664|remove",
          repeat: "\u91CD\u590D|repeat",
          return: "return",
          right: "\u53F3|right",
          sleep: "\u7761\u7720|sleep",
          step: "\u6B65|step",
          times: "\u6B21|times",
          to: "\u5230|to",
          to_list: "\u5230|to",
          turn: "\u65CB\u8F6C|turn",
          while: "\u5F53\u7684\u65F6\u5019|while",
          white: "\u767D\u8272|white",
          with: "with",
          yellow: "\u9EC4\u8272|yellow",
          DIGIT: "0123456789"
        },
        zh_Hant: {
          add: "add",
          and: "and",
          ask: "ask",
          at: "at",
          black: "black",
          blue: "blue",
          brown: "brown",
          call: "call",
          clear: "clear",
          color: "color",
          comma: ",",
          def: "def",
          define: "define",
          echo: "echo",
          elif: "elif",
          else: "else",
          for: "for",
          forward: "forward",
          from: "from",
          gray: "gray",
          green: "green",
          if: "if",
          in: "in",
          input: "input",
          is: "is",
          left: "left",
          length: "length",
          or: "or",
          orange: "orange",
          pink: "pink",
          pressed: "pressed",
          print: "print",
          purple: "purple",
          random: "random",
          range: "range",
          red: "red",
          remove: "remove",
          repeat: "repeat",
          return: "return",
          right: "right",
          sleep: "sleep",
          step: "step",
          times: "times",
          to: "to",
          to_list: "to",
          turn: "turn",
          while: "while",
          white: "white",
          with: "with",
          yellow: "yellow",
          DIGIT: "0123456789"
        }
      };
    }
  });

  // __tmp__/static/js/syntaxModesRules.js
  var require_syntaxModesRules = __commonJS({
    "__tmp__/static/js/syntaxModesRules.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.convertReg = exports.convert = exports.initializeSyntaxHighlighter = void 0;
      var highlighting_json_1 = __importDefault(require_highlighting());
      var highlighting_trad_json_1 = __importDefault(require_highlighting_trad());
      function initializeSyntaxHighlighter(options) {
        let TRADUCTIONS = convert(highlighting_trad_json_1.default);
        let lang = options.keywordLanguage;
        if (!TRADUCTIONS.has(lang)) {
          lang = "en";
        }
        var TRADUCTION = TRADUCTIONS.get(lang);
        var data = JSON.stringify(highlighting_json_1.default);
        var data_tr = convertReg(data, TRADUCTION);
        var LEVELS = JSON.parse(data_tr);
        if (window.define) {
          for (const level of LEVELS) {
            define("ace/mode/" + level.name, [], function(require2, exports2, _module) {
              var oop = require2("ace/lib/oop");
              var TextMode = require2("ace/mode/text").Mode;
              var TextHighlightRules = require2("ace/mode/text_highlight_rules").TextHighlightRules;
              function ThisLevelHighlightRules() {
                this.$rules = level.rules;
                this.normalizeRules();
              }
              ;
              oop.inherits(ThisLevelHighlightRules, TextHighlightRules);
              function Mode() {
                this.HighlightRules = ThisLevelHighlightRules;
              }
              ;
              oop.inherits(Mode, TextMode);
              exports2.Mode = Mode;
            });
          }
        }
      }
      exports.initializeSyntaxHighlighter = initializeSyntaxHighlighter;
      function convert(o) {
        if (typeof o === "object") {
          let tmp = new Map(Object.entries(o));
          let ret = new Map();
          tmp.forEach((value, key) => {
            ret.set(key, convert(value));
          });
          return ret;
        } else {
          return o;
        }
      }
      exports.convert = convert;
      function convertReg(oldReg, TRAD) {
        var newReg = oldReg;
        TRAD.forEach((value, key) => {
          key = key;
          var reg = new RegExp("__" + key + "__", "g");
          newReg = newReg.replace(reg, value);
        });
        return newReg;
      }
      exports.convertReg = convertReg;
    }
  });

  // __tmp__/static/js/message-translations.js
  var require_message_translations = __commonJS({
    "__tmp__/static/js/message-translations.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TRANSLATIONS = void 0;
      exports.TRANSLATIONS = {
        "ar": {
          "CheckInternet": "\u0623\u0644\u0642\u064A \u0646\u0638\u0631\u0629 \u0625\u0630\u0627 \u0643\u0627\u0646 \u0627\u062A\u0635\u0627\u0644\u0643 \u0628\u0627\u0644\u0625\u0646\u062A\u0631\u0646\u062A \u064A\u0639\u0645\u0644 \u0628\u0634\u0643\u0644 \u0635\u062D\u064A\u062D.",
          "Connection_error": "\u0644\u0645 \u0646\u062A\u0645\u0643\u0646 \u0645\u0646 \u0627\u0644\u0648\u0635\u0648\u0644 \u0625\u0644\u0649 \u0627\u0644\u062E\u0627\u062F\u0645.",
          "Empty_output": "\u0647\u0630\u0627 \u0627\u0644\u0631\u0645\u0632 \u064A\u0639\u0645\u0644 \u0648\u0644\u0643\u0646 \u0644\u0627 \u064A\u0637\u0628\u0639 \u0623\u064A \u0634\u064A\u0621. \u0623\u0636\u0641 \u0623\u0645\u0631 \u0637\u0628\u0627\u0639\u0629 \u0625\u0644\u0649 \u0627\u0644\u0643\u0648\u062F \u0627\u0644\u062E\u0627\u0635 \u0628\u0643 \u0623\u0648 \u0627\u0633\u062A\u062E\u062F\u0645 \u0627\u0644\u0633\u0644\u062D\u0641\u0627\u0629 \u0644\u0637\u0628\u0627\u0639\u0629 \u0634\u064A\u0621 \u0645\u0627.",
          "Errors_found": "\u0644\u0642\u062F \u0642\u0645\u062A \u0628\u062E\u0637\u0623! \u0644\u0627 \u062A\u0642\u0644\u0642\u060C \u0644\u0642\u062F \u0642\u0645\u0646\u0627 \u0628\u062A\u0634\u063A\u064A\u0644 \u0627\u0644\u0628\u0631\u0646\u0627\u0645\u062C",
          "Execute_error": "\u062D\u062F\u062B \u062E\u0637\u0623 \u0645\u0627 \u0623\u062B\u0646\u0627\u0621 \u062A\u0634\u063A\u064A\u0644 \u0627\u0644\u0628\u0631\u0646\u0627\u0645\u062C.",
          "Other_error": "\u0639\u0641\u0648\u0627! \u0631\u0628\u0645\u0627 \u0627\u0631\u062A\u0643\u0628\u0646\u0627 \u062E\u0637\u0623 \u0628\u0633\u064A\u0637\u0627.",
          "Program_repair": "\u0642\u062F \u064A\u0643\u0648\u0646 \u0647\u0630\u0627 \u0647\u0648 \u0627\u0644\u0631\u0645\u0632 \u0627\u0644\u0635\u062D\u064A\u062D \u060C \u0647\u0644 \u064A\u0645\u0643\u0646\u0643 \u0625\u0635\u0644\u0627\u062D\u0647\u061F",
          "Program_too_long": "\u064A\u0633\u062A\u063A\u0631\u0642 \u0628\u0631\u0646\u0627\u0645\u062C\u0643 \u0648\u0642\u062A\u064B\u0627 \u0637\u0648\u064A\u0644\u0627\u064B \u0644\u0644\u062A\u0634\u063A\u064A\u0644.",
          "ServerError": "\u0644\u0642\u062F \u0643\u062A\u0628\u062A \u0628\u0631\u0646\u0627\u0645\u062C\u0627 \u0644\u0645 \u0646\u0643\u0646 \u0646\u062A\u0648\u0642\u0639\u0647. \u0625\u0630\u0627 \u0643\u0646\u062A \u062A\u0631\u063A\u0628 \u0641\u064A \u0627\u0644\u0645\u0633\u0627\u0639\u062F\u0629 \u060C \u0641\u0623\u0631\u0633\u0644 \u0644\u0646\u0627 \u0628\u0631\u064A\u062F\u0627 \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A\u0627 \u064A\u062D\u062A\u0648\u064A \u0639\u0644\u0649 \u0627\u0644\u0645\u0633\u062A\u0648\u0649 \u0648\u0627\u0644\u0628\u0631\u0646\u0627\u0645\u062C \u0627\u0644\u062E\u0627\u0635 \u0628\u0643 \u0639\u0644\u0649 hello@hedy.org. \u0641\u064A \u063A\u0636\u0648\u0646 \u0630\u0644\u0643 \u060C \u062C\u0631\u0628 \u0634\u064A\u0626\u0627 \u0645\u062E\u062A\u0644\u0641\u0627 \u0642\u0644\u064A\u0644\u0627 \u0648\u0623\u0644\u0642 \u0646\u0638\u0631\u0629 \u0623\u062E\u0631\u0649 \u0639\u0644\u0649 \u0627\u0644\u0623\u0645\u062B\u0644\u0629. \u0634\u0643\u0631\u0627!",
          "Transpile_error": "\u0644\u0627 \u064A\u0645\u0643\u0646\u0646\u0627 \u062A\u0634\u063A\u064A\u0644 \u0628\u0631\u0646\u0627\u0645\u062C\u0643.",
          "Transpile_success": "\u0623\u062D\u0633\u0646\u062A!\n\u0631\u0627\u0626\u0639!\n\u0623\u062D\u0633\u0646\u062A!\n\u0645\u0645\u062A\u0627\u0632!\n\u0644\u0642\u062F \u0642\u0645\u062A \u0628\u0639\u0645\u0644 \u0631\u0627\u0626\u0639!",
          "Transpile_warning": "\u062A\u062D\u0630\u064A\u0631!",
          "Unsaved_Changes": "\u0644\u062F\u064A\u0643 \u0628\u0631\u0646\u0627\u0645\u062C \u063A\u064A\u0631 \u0645\u062D\u0641\u0648\u0638. \u0647\u0644 \u062A\u0631\u064A\u062F \u0627\u0644\u0645\u063A\u0627\u062F\u0631\u0629 \u062F\u0648\u0646 \u062D\u0641\u0638\u0647\u061F",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "\u0627\u0646\u0633\u062E \u0627\u0644\u0631\u0627\u0628\u0637 \u0644\u0645\u0634\u0627\u0631\u0643\u062A\u0647",
          "customization_deleted": "\u062A\u0645 \u062D\u0630\u0641 \u0627\u0644\u062A\u062E\u0635\u064A\u0635\u0627\u062A \u0628\u0646\u062C\u0627\u062D.",
          "dice": "\u{1F3B2}",
          "directly_available": "\u0627\u0641\u062A\u062A\u062D \u0645\u0628\u0627\u0634\u0631\u0629",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "\u0645\u0633\u062A\u0648\u0649",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "\u0645\u0631\u062D\u0628\u0627\u064B \u0641\u064A \u0647\u064A\u062F\u064A! \u0628\u0643\u0644 \u0641\u062E\u0631 \u0623\u0646\u062A \u0627\u0644\u0622\u0646 \u062A\u0645\u062A\u0644\u0643 \u062D\u0633\u0627\u0628\u0627\u064B \u0643\u0645\u0639\u0644\u0645 \u0648\u0630\u0627 \u064A\u0633\u0645\u062D \u0644\u0643 \u0628\u0627\u0646\u0634\u0627\u0621 \u0635\u0641\u0648\u0641 \u0648\u062F\u0639\u0648\u0629 \u062A\u0644\u0627\u0645\u064A\u0630.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "bg": {
          "CheckInternet": "\u041F\u0440\u043E\u0431\u043B\u0435\u043C\u0438 \u0441 \u0438\u043D\u0442\u0435\u0440\u043D\u0435\u0442\u043D\u0430\u0442\u0430 \u0442\u0438 \u0432\u0440\u044A\u0437\u043A\u0430. \u0429\u0435 \u044F \u043F\u0440\u043E\u0432\u0435\u0440\u0438\u0448 \u043B\u0438.",
          "Connection_error": "\u0418\u0437\u0433\u0443\u0431\u0438\u0445\u043C\u0435 \u0432\u0440\u044A\u0437\u043A\u0430 \u0441\u044A\u0441 \u0441\u044A\u0440\u0432\u044A\u0440\u0430.",
          "Empty_output": "\u041A\u043E\u0434\u044A\u0442 \u0440\u0430\u0431\u043E\u0442\u0438, \u043D\u043E \u043D\u044F\u043C\u0430 \u043D\u0438\u0449\u043E \u0437\u0430 \u043F\u0440\u0438\u043D\u0442\u0438\u0440\u0430\u043D\u0435.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "\u041D\u0435\u0449\u043E \u0441\u0435 \u043E\u0431\u044A\u0440\u043A\u0430 \u043F\u0440\u0438 \u0438\u0437\u043F\u044A\u043B\u043D\u0435\u043D\u0438\u0435\u0442\u043E \u043D\u0430 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0430\u0442\u0430.",
          "Other_error": "\u041E\u0439! \u041C\u0430\u0439 \u0438\u043C\u0430\u043C\u0435 \u043D\u044F\u043A\u0430\u043A\u0432\u0430 \u0433\u0440\u0435\u0448\u043A\u0430 \u0432 \u043A\u043E\u0434\u0430.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "\u041F\u0442\u043E\u0433\u0440\u0430\u043C\u0430\u0442\u0430 \u0442\u0438 \u0441\u0435 \u0438\u0437\u043F\u044A\u043B\u043D\u044F\u0432\u0430 \u043F\u0440\u0435\u043A\u0430\u043B\u0435\u043D\u043E \u0434\u044A\u043B\u0433\u043E \u0432\u0440\u0435\u043C\u0435...",
          "ServerError": "\u041D\u0430\u043F\u0438\u0441\u0430\u043B(\u0430) \u0441\u0438 \u043A\u043E\u0434, \u043A\u043E\u0439\u0442\u043E \u043D\u0435 \u043E\u0447\u0430\u043A\u0432\u0430\u0445\u043C\u0435. \u041F\u043E\u043C\u043E\u0433\u043D\u0438 \u043D\u0438 \u0438 \u043D\u0438 \u0438\u0437\u043F\u0440\u0430\u0442\u0438 \u0438\u043C\u0435\u0439\u043B \u043D\u0430 hello@hedy.org \u0441 \u0438\u043C\u0435\u0442\u043E \u043D\u0430 \u043D\u0438\u0432\u043E\u0442\u043E, \u0432 \u043A\u043E\u0435\u0442\u043E \u0437\u0430\u0441\u0435\u0434\u043D\u0430. \u041F\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043B\u043D\u043E \u0431\u043B\u0430\u0433\u043E\u0434\u0430\u0440\u0438\u043C!",
          "Transpile_error": "\u041F\u0440\u043E\u0433\u0440\u0430\u043C\u0430\u0442\u0430 \u0442\u0438 \u043D\u0435 \u043C\u043E\u0436\u0435 \u0434\u0430 \u0431\u044A\u0434\u0435 \u0438\u0437\u043F\u044A\u043B\u043D\u0435\u043D\u0430.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "\u0412\u043D\u0438\u043C\u0430\u043D\u0438\u0435!",
          "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "\u041D\u0438\u0432\u043E",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "bn": {
          "CheckInternet": "Have a look if your Internet connection is working properly.",
          "Connection_error": "We couldn't reach the server.",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Something went wrong while running the program.",
          "Other_error": "Oops! Maybe we made a little mistake.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "We can't run your program.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "Warning!",
          "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "ca": {
          "CheckInternet": "Mireu si la vostra connexi\xF3 a Internet funciona correctament.",
          "Connection_error": "No hem pogut arribar al servidor.",
          "Empty_output": "Aquest codi funciona, per\xF2 no imprimeix res. Afegiu una comanda d'impressi\xF3 al vostre codi o utilitzeu la tortuga per obtenir la sortida.",
          "Errors_found": "Has com\xE8s un error! No et preocupis, encara podem executar el programa",
          "Execute_error": "S'ha produ\xEFt un error en executar el programa.",
          "Other_error": "Vaja! Potser ens hem equivocat una mica.",
          "Program_repair": "Aquest podria ser el codi correcte, el pots arreglar?",
          "Program_too_long": "El vostre programa triga massa a executar-se.",
          "ServerError": "Has escrit un programa que no esper\xE0vem. Si vols ajudar, envia'ns un correu amb el nivell i el teu programa a hello@hedy.org. Mentrestant, proveu alguna cosa una mica diferent i feu una altra ullada als exemples. Gr\xE0cies!",
          "Transpile_error": "No podem executar el vostre programa.",
          "Transpile_success": "Ben fet!\nIncre\xEFble!\nBen fet!\nExcel\xB7lent!\nHo has fet genial!",
          "Transpile_warning": "Vigila!",
          "Unsaved_Changes": "Tens un programa sense desar. Vols marxar sense desar-lo?",
          "adventures_restored": "Les aventures per defecte han estat restaurades.",
          "copy_link_to_share": "Copia l'enlla\xE7 per compartir",
          "customization_deleted": "Personalitzacions esborrades correctament.",
          "dice": "\u{1F3B2}",
          "directly_available": "Obrir directament",
          "disabled": "Desactivat",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Nivell",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5}, \u{1F3B6}",
          "teacher_welcome": "Benvinguda a Hedy! El teu compte s'ha actualitzat a compte de professorat. Aix\xF2 et permetr\xE0 crear classes i convidar alumnes.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "Hi ha canvis no guardats, segur que voleu sortir d'aquesta p\xE0gina?"
        },
        "cs": {
          "CheckInternet": "Pros\xEDm, zkontroluj sv\xE9 p\u0159ipojen\xED k Internetu.",
          "Connection_error": "Nelze se p\u0159ipojit k serveru.",
          "Empty_output": "Tento k\xF3d funguje, ale nem\xE1 \u017E\xE1dn\xFD v\xFDstup. Pou\u017Eij p\u0159\xEDkaz print do k\xF3du nebo pou\u017Eij \u017Eelvu k z\xEDsk\xE1n\xED v\xFDstupu.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "P\u0159i prov\xE1d\u011Bn\xED programu se n\u011Bco pokazilo.",
          "Other_error": "Jejda! Asi jsme n\u011Bkde ud\u011Blali men\u0161\xED chybu.",
          "Program_repair": "Tohle by mohl b\xFDt spr\xE1vn\xFD z\xE1pis k\xF3du, m\u016F\u017Ee\u0161 to opravit?",
          "Program_too_long": "Tv\u016Fj program b\u011B\u017E\xED p\u0159\xEDl\xED\u0161 dlouho.",
          "ServerError": "Napsal*a jsi program, kter\xFD jsme ne\u010Dekali. Pokud pot\u0159ebuje\u0161 pomoc, po\u0161li n\xE1m e-mail s \u010D\xEDslem \xFArovn\u011B a sv\xFDm k\xF3dem na hello@hedy.org. Mezit\xEDm m\u016F\u017Ee\u0161 zkusit \xFAkol vy\u0159e\u0161it n\u011Bjak jinak nebo se znova pod\xEDvat na p\u0159\xEDklady. D\xEDky!",
          "Transpile_error": "Nelze spustit tv\u016Fj program.",
          "Transpile_success": "Dobr\xE1 pr\xE1ce!\n\xDA\u017Easn\xE9!\nSkv\u011Bl\xE9!\nV\xFDte\u010Dn\xE9!\nVede\u0161 si v\xFDborn\u011B!",
          "Transpile_warning": "Pozor!",
          "Unsaved_Changes": "Tv\u016Fj program nen\xED ulo\u017Een\xFD. Chce\u0161 odej\xEDt bez ulo\u017Een\xED?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Zkop\xEDrovat odkaz ke sd\xEDlen\xED",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "\xDArove\u0148",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "cy": {
          "CheckInternet": "Edrychwch os yw eich cysylltiad rhyngrwyd yn gweithio'n iawn.",
          "Connection_error": "Ni allem gyrraedd y gweinydd.",
          "Empty_output": "Mae'r cod hwn yn gweithio ond nid yw'n argraffu unrhyw beth. Ychwanegwch orchymyn argraffu i'ch cod neu defnyddiwch y crwban i gael allbwn.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Aeth rhywbeth o'i le wrth redeg y rhaglen.",
          "Other_error": "\u0174ps! Efallai ein bod wedi gwneud camgymeriad bach.",
          "Program_repair": "Gallai hwn fod y cod cywir, allwch chi ei drwsio?",
          "Program_too_long": "Mae eich rhaglen yn cymryd gormod o amser i'w rhedeg.",
          "ServerError": "Fe wnaethoch chi ysgrifennu rhaglen nad oeddem yn ei disgwyl. Os ydych chi eisiau helpu, anfonwch e-bost atom gyda'r lefel a'ch rhaglen yn hello@hedy.org. Yn y cyfamser, rhowch gynnig ar rywbeth ychydig yn wahanol ac edrychwch eto ar yr enghreifftiau. Diolch!",
          "Transpile_error": "Ni allwn redeg eich rhaglen.",
          "Transpile_success": "Gwaith da!\nAnhygoel!\nDa iawn!\nArdderchog!\nFe wnaethoch chi waith gwych!",
          "Transpile_warning": "Rhybudd!",
          "Unsaved_Changes": "Mae gennych raglen heb ei chadw. Ydych chi eisiau gadael heb ei arbed?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "da": {
          "CheckInternet": "Have a look if your Internet connection is working properly.",
          "Connection_error": "We couldn't reach the server.",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Something went wrong while running the program.",
          "Other_error": "Oops! Maybe we made a little mistake.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "We can't run your program.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "Warning!",
          "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "de": {
          "CheckInternet": "Funktioniert deine Internetverbindung.",
          "Connection_error": "Wir konnten den Server nicht erreichen.",
          "Empty_output": "Dieses Programm funktioniert aber gibt nichts aus. F\xFCge ein `print` Befehl hinzu oder benutz die Schildkr\xF6t um eine Ausgabe zu bekommen.",
          "Errors_found": "Du hast einen Fehler gemacht! Keine Sorge, wir haben das Programm trotzdem ausgef\xFChrt",
          "Execute_error": "Etwas ist beim Ausf\xFChren des Programms schiefgegangen.",
          "Other_error": "Hoppla! Vielleicht haben wir einen kleinen Fehler gemacht.",
          "Program_repair": "Das k\xF6nnte der korrekte Code sein, kannst du es beheben?",
          "Program_too_long": "Dein Programm ist zu lang um es auszuf\xFChren.",
          "ServerError": "Du hast ein Programm geschrieben das wir nicht erwartet haben. Wenn du uns hlefen m\xF6chtest, dann sende eine Email an hello@hedy.org und gib darin das Level an in dem du dieses Programm geschrieben hast und f\xFCge den Programmcode hinzu. In der Zwischenzeit, probiere aus es ein bisschen anders zu formulieren und schau nochmal in die Beispiele. Danke!",
          "Transpile_error": "Wir konnten Ihr Hedy-Programm nicht lesen.",
          "Transpile_success": "Gut gemacht!\nToll!\nSehr gut gemacht!\nAusgezeichnet!\nDas hast du gro\xDFartig gemacht!",
          "Transpile_warning": "Warnung!",
          "Unsaved_Changes": "Du hast ein nicht gespeichertes Programm. M\xF6chtest du es verwerfen, ohne zu speichern?",
          "adventures_restored": "Die Standardabenteuer wurden wiederhergestellt.",
          "copy_link_to_share": "Kopiere Link zum Weitergeben",
          "customization_deleted": "Anpassungen erfolgreich gel\xF6scht.",
          "dice": "\u{1F3B2}",
          "directly_available": "Direkt \xF6ffnen",
          "disabled": "Deaktiviert",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Willkommen bei Hedy! Du bist nun eine stolze BesitzerIn eines LehrerIn Kontos, welches dir erlaubt Klassen zu erstellen und Sch\xFCler einzuladen.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "Es gibt ungespeicherte \xC4nderungen, bist du dir sicher, dass du diese Seite verlassen m\xF6chtest?"
        },
        "el": {
          "CheckInternet": "\u03A1\u03AF\u03BE\u03B5 \u03BC\u03B9\u03B1 \u03BC\u03B1\u03C4\u03B9\u03AC \u03B1\u03BD \u03B7 \u03C3\u03CD\u03BD\u03B4\u03B5\u03C3\u03B7 \u03C3\u03BF\u03C5 \u03C3\u03C4\u03BF \u0394\u03B9\u03B1\u03B4\u03AF\u03BA\u03C4\u03C5\u03BF \u03B4\u03BF\u03C5\u03BB\u03B5\u03CD\u03B5\u03B9 \u03C3\u03C9\u03C3\u03C4\u03AC.",
          "Connection_error": "\u0394\u03B5\u03BD \u03BC\u03C0\u03BF\u03C1\u03AD\u03C3\u03B1\u03BC\u03B5 \u03BD\u03B1 \u03B2\u03C1\u03BF\u03CD\u03BC\u03B5 \u03C4\u03BF \u03B4\u03B9\u03B1\u03BA\u03BF\u03BC\u03B9\u03C3\u03C4\u03AE.",
          "Empty_output": "\u0391\u03C5\u03C4\u03CC\u03C2 \u03BF \u03BA\u03CE\u03B4\u03B9\u03BA\u03B1\u03C2 \u03BB\u03B5\u03B9\u03C4\u03BF\u03C5\u03C1\u03B3\u03B5\u03AF \u03B1\u03BB\u03BB\u03AC \u03B4\u03B5\u03BD \u03B5\u03BC\u03C6\u03B1\u03BD\u03AF\u03B6\u03B5\u03B9 \u03BA\u03AC\u03C4\u03B9. \u03A0\u03C1\u03CC\u03C3\u03B8\u03B5\u03C3\u03B5 \u03BC\u03B9\u03B1 \u03B5\u03BD\u03C4\u03BF\u03BB\u03AE \u03B5\u03BC\u03C6\u03AC\u03BD\u03B9\u03C3\u03B7\u03C2 \u03C3\u03C4\u03BF\u03BD \u03BA\u03CE\u03B4\u03B9\u03BA\u03AC \u03C3\u03BF\u03C5 \u03AE \u03C7\u03C1\u03B7\u03C3\u03B9\u03BC\u03BF\u03C0\u03BF\u03AF\u03B7\u03C3\u03B5 \u03C4\u03B7 \u03C7\u03B5\u03BB\u03CE\u03BD\u03B1 \u03B3\u03B9\u03B1 \u03BD\u03B1 \u03AD\u03C7\u03B5\u03B9\u03C2 \u03AD\u03BE\u03BF\u03B4\u03BF.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "\u039A\u03AC\u03C4\u03B9 \u03C0\u03AE\u03B3\u03B5 \u03C3\u03C4\u03C1\u03B1\u03B2\u03AC \u03CC\u03C3\u03BF \u03B5\u03BA\u03C4\u03B5\u03BB\u03BF\u03CD\u03C3\u03B1\u03BC\u03B5 \u03C4\u03BF \u03C0\u03C1\u03CC\u03B3\u03C1\u03B1\u03BC\u03BC\u03B1.",
          "Other_error": "\u039F\u03C5\u03C0\u03C2! \u038A\u03C3\u03C9\u03C2 \u03BD\u03B1 \u03BA\u03AC\u03BD\u03B1\u03BC\u03B5 \u03BA\u03AC\u03C0\u03BF\u03B9\u03BF \u03BB\u03B1\u03B8\u03AC\u03BA\u03B9.",
          "Program_repair": "\u0391\u03C5\u03C4\u03CC\u03C2 \u03BC\u03C0\u03BF\u03C1\u03B5\u03AF \u03BD\u03B1 \u03B5\u03AF\u03BD\u03B1\u03B9 \u03BF \u03C3\u03C9\u03C3\u03C4\u03CC\u03C2 \u03BA\u03CE\u03B4\u03B9\u03BA\u03B1\u03C2, \u03BC\u03C0\u03BF\u03C1\u03B5\u03AF\u03C2 \u03BD\u03B1 \u03C4\u03BF\u03BD \u03B4\u03B9\u03BF\u03C1\u03B8\u03CE\u03C3\u03B5\u03B9\u03C2;",
          "Program_too_long": "\u03A4\u03BF \u03C0\u03C1\u03CC\u03B3\u03C1\u03B1\u03BC\u03BC\u03AC \u03C3\u03BF\u03C5 \u03C0\u03B1\u03AF\u03C1\u03BD\u03B5\u03B9 \u03C0\u03BF\u03BB\u03CD \u03C7\u03C1\u03CC\u03BD\u03BF \u03B3\u03B9\u03B1 \u03BD\u03B1 \u03B5\u03BA\u03C4\u03B5\u03BB\u03B5\u03C3\u03C4\u03B5\u03AF.",
          "ServerError": "\u0388\u03B3\u03C1\u03B1\u03C8\u03B5\u03C2 \u03AD\u03BD\u03B1 \u03C0\u03C1\u03CC\u03B3\u03C1\u03B1\u03BC\u03BC\u03B1 \u03C0\u03BF\u03C5 \u03B4\u03B5\u03BD \u03C0\u03B5\u03C1\u03B9\u03BC\u03AD\u03BD\u03B1\u03BC\u03B5. \u0391\u03BD \u03B8\u03AD\u03BB\u03B5\u03C4\u03B5 \u03BD\u03B1 \u03B2\u03BF\u03B7\u03B8\u03AE\u03C3\u03B5\u03B9\u03C2, \u03C3\u03C4\u03B5\u03AF\u03BB\u03B5 \u03BC\u03B1\u03C2 \u03AD\u03BD\u03B1 email \u03BC\u03B5 \u03C4\u03BF \u03B5\u03C0\u03AF\u03C0\u03B5\u03B4\u03BF \u03BA\u03B1\u03B9 \u03C4\u03BF \u03C0\u03C1\u03CC\u03B3\u03C1\u03B1\u03BC\u03BC\u03AC \u03C3\u03BF\u03C5 at hello@hedy.org. \u0395\u03BD \u03C4\u03C9 \u03BC\u03B5\u03C4\u03B1\u03BE\u03CD, \u03B4\u03BF\u03BA\u03AF\u03BC\u03B1\u03C3\u03B5 \u03BA\u03AC\u03C4\u03B9 \u03BB\u03AF\u03B3\u03BF \u03B4\u03B9\u03B1\u03C6\u03BF\u03C1\u03B5\u03C4\u03B9\u03BA\u03CC \u03BA\u03B1\u03B9 \u03C1\u03AF\u03BE\u03B5 \u03AC\u03BB\u03BB\u03B7 \u03BC\u03B9\u03B1 \u03BC\u03B1\u03C4\u03B9\u03AC \u03C3\u03C4\u03B1 \u03C0\u03B1\u03C1\u03B1\u03B4\u03B5\u03AF\u03B3\u03BC\u03B1\u03C4\u03B1. \u0395\u03C5\u03C7\u03B1\u03C1\u03B9\u03C3\u03C4\u03CE!",
          "Transpile_error": "\u0394\u03B5\u03BD \u03BC\u03C0\u03BF\u03C1\u03BF\u03CD\u03BC\u03B5 \u03BD\u03B1 \u03B5\u03BA\u03C4\u03B5\u03BB\u03AD\u03C3\u03BF\u03C5\u03BC\u03B5 \u03C4\u03BF \u03C0\u03C1\u03CC\u03B3\u03C1\u03B1\u03BC\u03BC\u03AC \u03C3\u03BF\u03C5.",
          "Transpile_success": "\u039A\u03B1\u03BB\u03AE \u03B4\u03BF\u03C5\u03BB\u03B5\u03B9\u03AC!\n\u0395\u03BE\u03B1\u03B9\u03C1\u03B5\u03C4\u03B9\u03BA\u03AC!\n\u039C\u03C0\u03C1\u03AC\u03B2\u03BF!\n\u03A5\u03C0\u03AD\u03C1\u03BF\u03C7\u03B1!\n\u03A4\u03B1 \u03C0\u03AE\u03B3\u03B5\u03C2 \u03C5\u03C0\u03AD\u03C1\u03BF\u03C7\u03B1!",
          "Transpile_warning": "\u03A0\u03C1\u03BF\u03C3\u03BF\u03C7\u03AE!",
          "Unsaved_Changes": "\u0388\u03C7\u03B5\u03B9\u03C2 \u03AD\u03BD\u03B1 \u03BC\u03B7 \u03B1\u03C0\u03BF\u03B8\u03B7\u03BA\u03B5\u03C5\u03BC\u03AD\u03BD\u03BF \u03C0\u03C1\u03CC\u03B3\u03C1\u03B1\u03BC\u03BC\u03B1. \u0398\u03AD\u03BB\u03B5\u03B9\u03C2 \u03BD\u03B1 \u03B1\u03C0\u03BF\u03C7\u03C9\u03C1\u03AE\u03C3\u03B5\u03B9\u03C2 \u03C7\u03C9\u03C1\u03AF\u03C2 \u03BD\u03B1 \u03C4\u03BF \u03B1\u03C0\u03BF\u03B8\u03B7\u03BA\u03B5\u03CD\u03C3\u03B5\u03B9\u03C2;",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "\u0391\u03BD\u03C4\u03AF\u03B3\u03C1\u03B1\u03C8\u03B5 \u03C4\u03BF\u03BD \u03C3\u03CD\u03BD\u03B4\u03B5\u03C3\u03BC\u03BF \u03B3\u03B9\u03B1 \u03BA\u03BF\u03B9\u03BD\u03AE \u03C7\u03C1\u03AE\u03C3\u03B7",
          "customization_deleted": "\u039F\u03B9 \u03C0\u03C1\u03BF\u03C3\u03B1\u03C1\u03BC\u03BF\u03B3\u03AD\u03C2 \u03B4\u03B9\u03B1\u03B3\u03C1\u03AC\u03C6\u03B7\u03C3\u03B1\u03BD \u03BC\u03B5 \u03B5\u03C0\u03B9\u03C4\u03C5\u03C7\u03AF\u03B1.",
          "dice": "\u{1F3B2}",
          "directly_available": "\u0386\u03BC\u03B5\u03C3\u03B1 \u03B1\u03BD\u03BF\u03B9\u03C7\u03C4\u03CC",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "\u0395\u03C0\u03AF\u03C0\u03B5\u03B4\u03BF",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "\u039A\u03B1\u03BB\u03CE\u03C2 \u03AE\u03C1\u03B8\u03B5\u03C2 \u03C3\u03C4\u03B7 Hedy! \u0395\u03AF\u03C3\u03B1\u03B9 \u03C0\u03BB\u03AD\u03BF\u03BD \u03C0\u03B5\u03C1\u03AE\u03C6\u03B1\u03BD\u03BF\u03C2 \u03BA\u03AC\u03C4\u03BF\u03C7\u03BF\u03C2 \u03B5\u03BD\u03CC\u03C2 \u03BB\u03BF\u03B3\u03B1\u03C1\u03B9\u03B1\u03C3\u03BC\u03BF\u03CD \u03BA\u03B1\u03B8\u03B7\u03B3\u03B7\u03C4\u03AE \u03C0\u03BF\u03C5 \u03C3\u03BF\u03C5 \u03B5\u03C0\u03B9\u03C4\u03C1\u03AD\u03C0\u03B5\u03B9 \u03BD\u03B1 \u03B4\u03B7\u03BC\u03B9\u03BF\u03C5\u03C1\u03B3\u03B5\u03AF\u03C2 \u03BC\u03B1\u03B8\u03AE\u03BC\u03B1\u03C4\u03B1 \u03BA\u03B1\u03B9 \u03BD\u03B1 \u03C0\u03C1\u03BF\u03C3\u03BA\u03B1\u03BB\u03B5\u03AF\u03C2 \u03BC\u03B1\u03B8\u03B7\u03C4\u03AD\u03C2.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "en": {
          "CheckInternet": "Have a look if your Internet connection is working properly.",
          "Connection_error": "We couldn't reach the server.",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, we still ran the program",
          "Execute_error": "Something went wrong while running the program.",
          "Other_error": "Oops! Maybe we made a little mistake.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "We can't run your program.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "Warning!",
          "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
          "adventures_restored": "The default adventures have been restored.",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "eo": {
          "CheckInternet": "Kontrolu, \u0109u via Interreta konekto funkcias \u011Duste.",
          "Connection_error": "Ni ne povis atingi la servilon.",
          "Empty_output": "Tiu kodo funkcias sed presas nenion. Enmetu presan komandon en vian kodon, a\u016D uzu la testudon por vidi ion.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Io misfunkciis dum rulado de la programo.",
          "Other_error": "Ho! Eble ni iomete eraris.",
          "Program_repair": "Tio povus esti la \u011Dusta kodo; \u0109u vi povas ripari \u011Din?",
          "Program_too_long": "Ruli vian programon bezonas troon da tempo.",
          "ServerError": "Vi verkis programon, kiun ni ne atendis. Se vi volas helpi, sendu al ni retmesa\u011Don menciantan la nivelon kaj vian programon \u0109e hello@hedy.org. Dume, provu ion alietan, kaj rerigardu la ekzemplojn. Dankon!",
          "Transpile_error": "Ni ne povas ruli vian programon.",
          "Transpile_success": "Bona laboro!\nMirinda!\nBone farita!\nBonega!\nVi bonege faris!",
          "Transpile_warning": "Atentu!",
          "Unsaved_Changes": "Via programo estas ne konservita. \u0108u vi volas foriri sen konservi \u011Din?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Rekte malfermi",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Nivelo",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "es": {
          "CheckInternet": "Revisa si tu conexi\xF3n de Internet est\xE1 funcionando correctamente.",
          "Connection_error": "No se ha podido conectar con el servidor.",
          "Empty_output": "Este c\xF3digo funciona pero no imprime nada. Agrega un comando print a tu c\xF3digo o usa una tortuga para mostrar salida.",
          "Errors_found": "\xA1Has cometido un error! No te preocupes, seguimos ejecutando el programa",
          "Execute_error": "Algo sali\xF3 mal mientras se ejecutaba el programa.",
          "Other_error": "\xA1Ups! Quiz\xE1s hemos cometido un peque\xF1o error.",
          "Program_repair": "Este podr\xEDa ser c\xF3digo correcto, \xBFlo puedes arreglar?",
          "Program_too_long": "Tu programa toma demasiado tiempo en ejecutarse.",
          "ServerError": "Escribiste un programa que no esper\xE1bamos. Si quieres ayudar, env\xEDanos un email con el nivel y tu programa a hello@hedy.org. Mientras tanto, intenta algo un poco diferente y \xE9chale otro vistazo a los ejemplos. \xA1Gracias!",
          "Transpile_error": "No podemos ejecutar este programa.",
          "Transpile_success": "\xA1Buen trabajo!\n\xA1Increible!\n\xA1Bien hecho!\n\xA1Excelente!\n\xA1Lo hiciste genial!",
          "Transpile_warning": "\xA1Cuidado!",
          "Unsaved_Changes": "Tu programa no se ha guardado. \xBFDeseas irte sin guardarlo?",
          "adventures_restored": "Se han restaurado las aventuras por defecto.",
          "copy_link_to_share": "Copiar enlace para compartir",
          "customization_deleted": "Personalizaci\xF3n eliminada.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directamente abierto",
          "disabled": "Deshabilitado",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Nivel",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "\xA1Bienvenido/a a Hedy! Tu cuenta es de tipo profesor, por lo que puedes crear clases e invitar estudiantes.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "Hay cambios sin guardar, \xBFest\xE1s seguro de que quieres abandonar esta p\xE1gina?"
        },
        "et": {
          "CheckInternet": "Kontrolli kas su interneti\xFChendus t\xF6\xF6tab korralikult.",
          "Connection_error": "Me ei saanud serveriga \xFChendust.",
          "Empty_output": "See programm t\xF6\xF6tab, aga ei kirjuta midagi ekraanile. Lisa printimise k\xE4sk oma koodi v\xF5i kasuta kilpkonna, et saada v\xE4ljundit.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Midagi l\xE4ks programmi k\xE4ivitamisel valesti.",
          "Other_error": "Oih! V\xF5ib-olla me tegime programmis v\xE4ikese vea.",
          "Program_repair": "See programm saaks olla \xF5ige, kas sa oskad seda parandada?",
          "Program_too_long": "Sinu programm v\xF5tab p\xE4rast k\xE4ivitamist liiga kaua aega.",
          "ServerError": "Sa oled kirjutanud sellise programmi, mida me ei oodanud. Kui sa tahad meid aidata, siis saada meil aadressile hello@hedy.org. Kirjuta meili oma tase ja programm. Samal ajal proovi oma programmi natukene muuta, et sa saaksid edasi minna. Vaata uuesti n\xE4idiseid, kui on vaja. Suur t\xE4nu!",
          "Transpile_error": "Me ei saa sinu programmi k\xE4ivitada.",
          "Transpile_success": "Tubli!\nV\xE4ga tubli!\nSuurep\xE4rane!\nSuper!\nV\xE4ga v\xE4ga tubli!",
          "Transpile_warning": "Hoiatus!",
          "Unsaved_Changes": "Sinu programm ei ole salvestatud. Kas sa tahad lahkuda ilma seda salvestamata?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Tere tulemast Hedy juurde! Sul on n\xFC\xFCd \xF5petaja konto. See annab sulle v\xF5imaluse klasse luua ja \xF5pilasi \xFChinema kutsuda.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "fa": {
          "CheckInternet": "\u0628\u0628\u06CC\u0646 \u0622\u06CC\u0627 \u0627\u062A\u0635\u0627\u0644 \u0627\u06CC\u0646\u062A\u0631\u0646\u062A \u0634\u0645\u0627 \u0628\u0647 \u062F\u0631\u0633\u062A\u06CC \u06A9\u0627\u0631 \u0645\u06CC \u06A9\u0646\u062F.",
          "Connection_error": "\u0646\u0645\u06CC\u062A\u0648\u0646\u06CC\u0645 \u0628\u0647 \u0633\u0631\u0648\u0631 \u062F\u0633\u062A\u0631\u0633\u06CC \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u06CC\u0645.",
          "Empty_output": "\u0627\u06CC\u0646 \u06A9\u062F \u06A9\u0627\u0631 \u0645\u06CC \u06A9\u0646\u062F \u0627\u0645\u0627 \u0686\u06CC\u0632\u06CC \u0631\u0627 \u0686\u0627\u067E \u0646\u0645\u06CC \u06A9\u0646\u062F. \u06CC\u06A9 \u062F\u0633\u062A\u0648\u0631 \u0686\u0627\u067E \u0631\u0627 \u0628\u0647 \u06A9\u062F \u062E\u0648\u062F \u0627\u0636\u0627\u0641\u0647 \u06A9\u0646 \u06CC\u0627 \u0627\u0632 \u0644\u0627\u06A9 \u067E\u0634\u062A \u0628\u0631\u0627\u06CC \u062E\u0631\u0648\u062C\u06CC \u0627\u0633\u062A\u0641\u0627\u062F\u0647 \u06A9\u0646.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "\u0647\u0646\u06AF\u0627\u0645 \u0627\u062C\u0631\u0627\u06CC \u0628\u0631\u0646\u0627\u0645\u0647 \u0645\u0634\u06A9\u0644\u06CC \u067E\u06CC\u0634 \u0622\u0645\u062F.",
          "Other_error": "\u0627\u0648\u0647! \u0645\u0645\u06A9\u0646\u0647 \u0645\u0627 \u06CC\u06A9 \u0627\u0634\u062A\u0628\u0627\u0647 \u06A9\u0648\u0686\u06A9\u06CC \u06A9\u0631\u062F\u06CC\u0645.",
          "Program_repair": "\u0627\u06CC\u0646 \u0645\u06CC\u062A\u0648\u0646\u0647 \u06A9\u062F \u0635\u062D\u06CC\u062D \u0628\u0627\u0634\u0647\u060C \u0645\u06CC\u062A\u0648\u0646\u06CC \u062F\u0631\u0633\u062A\u0634 \u06A9\u0646\u06CC\u061F",
          "Program_too_long": "\u0627\u062C\u0631\u0627\u06CC \u0628\u0631\u0646\u0627\u0645\u0647 \u0627\u062A \u062E\u06CC\u0644\u06CC \u0637\u0648\u0644 \u0645\u06CC \u06A9\u0634\u0647.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "\u0646\u0645\u06CC\u062A\u0648\u0646\u06CC \u0628\u0631\u0646\u0627\u0645\u0647 \u0627\u062A \u0631\u0627 \u0627\u062C\u0631\u0627 \u06A9\u0646\u06CC.",
          "Transpile_success": "\u0622\u0641\u0631\u06CC\u0646!\n\u0634\u06AF\u0641\u062A \u0627\u0646\u06AF\u064A\u0632\u0647!\n\u0622\u0641\u0631\u06CC\u0646!\n\u0639\u0627\u0644\u06CC!\n\u06A9\u0627\u0631\u062A \u0639\u0627\u0644\u06CC \u0628\u0648\u062F!",
          "Transpile_warning": "\u0647\u0634\u062F\u0627\u0631!",
          "Unsaved_Changes": "\u06CC\u06A9 \u0628\u0631\u0646\u0627\u0645\u0647 \u0630\u062E\u06CC\u0631\u0647 \u0646\u0634\u062F\u0647 \u062F\u0627\u0631\u06CC. \u0622\u06CC\u0627 \u0645\u06CC \u062E\u0648\u0627\u0647\u06CC \u0628\u062F\u0648\u0646 \u0630\u062E\u06CC\u0631\u0647 \u0622\u0646 \u0631\u0627 \u062A\u0631\u06A9 \u06A9\u0646\u06CC\u061F",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "fi": {
          "CheckInternet": "Have a look if your Internet connection is working properly.",
          "Connection_error": "We couldn't reach the server.",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Something went wrong while running the program.",
          "Other_error": "Oops! Maybe we made a little mistake.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "We can't run your program.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "Warning!",
          "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "fr": {
          "CheckInternet": "V\xE9rifie que ta connexion Internet fonctionne correctement.",
          "Connection_error": "Nous n\u2019avons pas r\xE9ussi \xE0 contacter le serveur.",
          "Empty_output": "Ce code fonctionne mais n'imprime rien. Ajoute une commande d'affichage \xE0 ton code ou utilise la tortue pour obtenir un r\xE9sultat.",
          "Errors_found": "Tu as fait une erreur\xA0! Ne t'inqui\xE8te pas, nous avons ex\xE9cut\xE9 quand m\xEAme le programme",
          "Execute_error": "Quelque chose s\u2019est mal pass\xE9 en ex\xE9cutant ce programme.",
          "Other_error": "Oups\xA0! Peut-\xEAtre que nous faisons une petite erreur.",
          "Program_repair": "Ceci pourrait \xEAtre le bon code, peux-tu le r\xE9parer\xA0?",
          "Program_too_long": "Ton programme prend trop de temps \xE0 s'ex\xE9cuter.",
          "ServerError": "Tu as \xE9crit un programme que nous n'attendions pas. Si tu veux nous aider, envoie-nous un email avec le niveau et ton programme \xE0 hello@hedy.org. En attendant, essaye quelque chose d'un peu diff\xE9rent et regarde \xE0 nouveau les exemples. Merci\xA0!",
          "Transpile_error": "Nous ne pouvons pas ex\xE9cuter ton programme.",
          "Transpile_success": "Bon travail\xA0!\nFantastique\xA0!\nBien jou\xE9\xA0!\nExcellent\xA0!\nTu as fait du bon travail\xA0!",
          "Transpile_warning": "Attention\xA0!",
          "Unsaved_Changes": "Le programme en cours n'a pas \xE9t\xE9 sauvegard\xE9. Souhaites-tu vraiment quitter sans le sauvegarder\xA0?",
          "adventures_restored": "Les aventures par d\xE9faut ont \xE9t\xE9 r\xE9tablies.",
          "copy_link_to_share": "Copier le lien \xE0 partager",
          "customization_deleted": "Modifications effac\xE9es avec succ\xE8s.",
          "dice": "\u{1F3B2}",
          "directly_available": "Ouvrir imm\xE9diatement",
          "disabled": "D\xE9sactiv\xE9",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Niveau",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Bienvenue chez Hedy ! Vous \xEAtes maintenant l'heureux propri\xE9taire d'un compte enseignant qui vous permet de cr\xE9er des cours et d'inviter des \xE9tudiants.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "Il y a des changements non pris en comptes, es-tu sur de vouloir quitter la page ?"
        },
        "fy": {
          "CheckInternet": "Wolst eefkes kontrolearje oft dyn internet it noch wol docht.",
          "Connection_error": "Der is in ferbiningsprobleem. It leit f\xEAst oan \xFAs, mar miskien docht dyn internet it eefkes net.",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "It draaien fan de koade gong niet hielendal goed.",
          "Other_error": "Krammele! Dat gong net goed, wy ha sels f\xEAst in programmearflater makke.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "Hast in programma skreaun dat wy net ferwachte hienen. Ast \xFAs helpe wolst, stjoer \xFAs dan in mailtsje mei in level en dyn programma nei hello@hedy.org. Besykje dyn programma in bytsje oan te passen om fierder te gean en sjochris nei de foarbylden. Dankewol!",
          "Transpile_error": "Dyn koade wie net hielendal goed.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "Tink derom!",
          "Unsaved_Changes": "Dyn programma is net bewarre. Wolst fuortgean s\xFBnder it te bewarjen?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Diellink kopi\xEBare",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "he": {
          "CheckInternet": "\u05D1\u05D3\u05E7\u05D5 \u05D0\u05DD \u05D7\u05D9\u05D1\u05D5\u05E8 \u05D4\u05D0\u05D9\u05E0\u05D8\u05E8\u05E0\u05D8 \u05E9\u05DC\u05DB\u05DD.\u05DF \u05E4\u05D5\u05E2\u05DC \u05DB\u05E8\u05D0\u05D5\u05D9.",
          "Connection_error": "\u05DC\u05D0 \u05D4\u05E6\u05DC\u05D7\u05E0\u05D5 \u05DC\u05D4\u05D2\u05D9\u05E2 \u05DC\u05E9\u05E8\u05EA.",
          "Empty_output": "\u05D4\u05E7\u05D5\u05D3 \u05D4\u05D6\u05D4 \u05E2\u05D5\u05D1\u05D3 \u05D0\u05D1\u05DC \u05DC\u05D0 \u05DE\u05D3\u05E4\u05D9\u05E1 \u05E9\u05D5\u05DD \u05D3\u05D1\u05E8. \u05D4\u05D5\u05E1\u05D9\u05E4\u05D5 \u05E4\u05E7\u05D5\u05D3\u05EA \u05D4\u05D3\u05E4\u05E1\u05D4 \u05DC\u05E7\u05D5\u05D3 \u05D0\u05D5 \u05D4\u05E9\u05EA\u05DE\u05E9\u05D5 \u05D1\u05E6\u05D1 \u05D1\u05E9\u05D1\u05D9\u05DC \u05DC\u05E7\u05D1\u05DC \u05E4\u05DC\u05D8.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "\u05DE\u05E9\u05D4\u05D5 \u05D4\u05E9\u05EA\u05D1\u05E9 \u05D1\u05DE\u05D4\u05DC\u05DA \u05D4\u05E8\u05E6\u05EA \u05D4\u05EA\u05DB\u05E0\u05D9\u05EA.",
          "Other_error": "\u05D0\u05D5\u05E4\u05E1! \u05D0\u05D5\u05DC\u05D9 \u05E2\u05E9\u05D9\u05E0\u05D5 \u05D8\u05E2\u05D5\u05EA \u05E7\u05D8\u05E0\u05D4.",
          "Program_repair": "\u05D4\u05E7\u05D5\u05D3 \u05D4\u05D6\u05D4 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05D5\u05EA \u05E0\u05DB\u05D5\u05DF, \u05D4\u05D0\u05DD \u05EA\u05D5\u05DB\u05DC\u05D5 \u05DC\u05EA\u05E7\u05DF \u05D0\u05D5\u05EA\u05D5?",
          "Program_too_long": "\u05DC\u05EA\u05D5\u05DB\u05E0\u05D9\u05EA \u05E9\u05DC\u05DA \u05DC\u05D5\u05E7\u05D7 \u05D9\u05D5\u05EA\u05E8 \u05DE\u05D3\u05D9 \u05D6\u05DE\u05DF \u05DC\u05E8\u05D5\u05E5.",
          "ServerError": "\u05DB\u05EA\u05D1\u05EA \u05EA\u05D5\u05DB\u05E0\u05D9\u05EA \u05E9\u05DC\u05D0 \u05E6\u05D9\u05E4\u05D9\u05E0\u05D5 \u05DC\u05D4. \u05D0\u05DD \u05D0\u05EA.\u05D4 \u05E8\u05D5\u05E6\u05D4 \u05E2\u05D6\u05E8\u05D4, \u05E9\u05DC\u05D7.\u05D9 \u05DC\u05E0\u05D5 \u05DE\u05D9\u05D9\u05DC \u05E2\u05DD \u05DE\u05E1\u05E4\u05E8 \u05D4\u05E8\u05DE\u05D4 \u05D5\u05D4\u05EA\u05D5\u05DB\u05E0\u05D9\u05EA \u05E9\u05DC\u05DA \u05DC- hello@hedy.org. \u05D1\u05D9\u05E0\u05EA\u05D9\u05D9\u05DD, \u05E0\u05E1\u05D4.\u05D9 \u05DE\u05E9\u05D4\u05D5 \u05E7\u05E6\u05EA \u05E9\u05D5\u05E0\u05D4 \u05D5\u05D4\u05E1\u05EA\u05DB\u05DC.\u05D9 \u05E2\u05DC \u05D4\u05D3\u05D5\u05D2\u05DE\u05D0\u05D5\u05EA. \u05EA\u05D5\u05D3\u05D4!",
          "Transpile_error": "\u05D0\u05D9\u05E0\u05E0\u05D5 \u05D9\u05DB\u05D5\u05DC\u05D9\u05DD.\u05D5\u05EA \u05DC\u05D4\u05E8\u05D9\u05E5 \u05D0\u05EA \u05D4\u05EA\u05D5\u05DB\u05E0\u05D9\u05EA \u05E9\u05DC\u05DA.",
          "Transpile_success": "\u05E2\u05D1\u05D5\u05D3\u05D4 \u05D8\u05D5\u05D1\u05D4!\n\u05DE\u05D3\u05D4\u05D9\u05DD!\n\u05DB\u05DC \u05D4\u05DB\u05D1\u05D5\u05D3!\n\u05DE\u05E6\u05D5\u05D9\u05DF!\n\u05D4\u05D9\u05D9\u05EA \u05DE\u05E2\u05D5\u05DC\u05D4!",
          "Transpile_warning": "\u05D0\u05D6\u05D4\u05E8\u05D4!",
          "Unsaved_Changes": "\u05D9\u05E9 \u05DC\u05DA \u05EA\u05DB\u05E0\u05D9\u05EA \u05E9\u05DC\u05D0 \u05E0\u05E9\u05DE\u05E8\u05D4. \u05D4\u05D0\u05DD \u05D1\u05E8\u05E6\u05D5\u05E0\u05DA \u05DC\u05E2\u05D6\u05D5\u05D1 \u05D1\u05DC\u05D9 \u05DC\u05E9\u05DE\u05D5\u05E8 \u05D0\u05D5\u05EA\u05D4?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "\u05E8\u05DE\u05D4",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "hi": {
          "CheckInternet": "\u0926\u0947\u0916\u0947\u0902 \u0915\u093F \u0906\u092A\u0915\u093E \u0907\u0902\u091F\u0930\u0928\u0947\u091F \u0915\u0928\u0947\u0915\u094D\u0936\u0928 \u0920\u0940\u0915 \u0938\u0947 \u0915\u093E\u092E \u0915\u0930 \u0930\u0939\u093E \u0939\u0948 \u092F\u093E \u0928\u0939\u0940\u0902.",
          "Connection_error": "\u0939\u092E \u0938\u0930\u094D\u0935\u0930 \u0924\u0915 \u0928\u0939\u0940\u0902 \u092A\u0939\u0941\u0902\u091A \u0938\u0915\u0947|",
          "Empty_output": "\u092F\u0939 \u0915\u094B\u0921 \u0915\u093E\u092E \u0915\u0930\u0924\u093E \u0939\u0948 \u0932\u0947\u0915\u093F\u0928 \u0915\u0941\u091B \u092D\u0940 \u092A\u094D\u0930\u093F\u0902\u091F \u0928\u0939\u0940\u0902 \u0915\u0930\u0924\u093E \u0939\u0948\u0964 \u0905\u092A\u0928\u0947 \u0915\u094B\u0921 \u092E\u0947\u0902 \u090F\u0915 \u092A\u094D\u0930\u093F\u0902\u091F \u0915\u092E\u093E\u0902\u0921 \u091C\u094B\u0921\u093C\u0947\u0902 \u092F\u093E \u0906\u0909\u091F\u092A\u0941\u091F \u092A\u094D\u0930\u093E\u092A\u094D\u0924 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u091F\u0930\u094D\u091F\u0932 \u0915\u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0947\u0902|",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "\u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E \u091A\u0932\u093E\u0924\u0947 \u0938\u092E\u092F \u0915\u0941\u091B \u0917\u0932\u0924 \u0939\u094B \u0917\u092F\u093E|",
          "Other_error": "\u0909\u092B\u093C! \u0936\u093E\u092F\u0926 \u0939\u092E\u0928\u0947 \u0925\u094B\u0921\u093C\u0940 \u0938\u0940 \u0917\u0932\u0924\u0940 \u0915\u0930 \u0926\u0940\u0964",
          "Program_repair": "\u092F\u0939 \u0938\u0939\u0940 \u0915\u094B\u0921 \u0939\u094B \u0938\u0915\u0924\u093E \u0939\u0948, \u0915\u094D\u092F\u093E \u0906\u092A \u0907\u0938\u0947 \u0920\u0940\u0915 \u0915\u0930 \u0938\u0915\u0924\u0947 \u0939\u0948\u0902?",
          "Program_too_long": "\u0906\u092A\u0915\u093E \u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E \u091A\u0932\u0928\u0947 \u092E\u0947\u0902 \u092C\u0939\u0941\u0924 \u0905\u0927\u093F\u0915 \u0938\u092E\u092F \u0932\u0947\u0924\u093E \u0939\u0948\u0964",
          "ServerError": "\u0906\u092A\u0928\u0947 \u090F\u0915 \u0910\u0938\u093E \u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E \u0932\u093F\u0916\u093E \u091C\u093F\u0938\u0915\u0940 \u0939\u092E \u0905\u092A\u0947\u0915\u094D\u0937\u093E \u0928\u0939\u0940\u0902 \u0915\u0930 \u0930\u0939\u0947 \u0925\u0947\u0964 \u092F\u0926\u093F \u0906\u092A \u092E\u0926\u0926 \u0915\u0930\u0928\u093E \u091A\u093E\u0939\u0924\u0947 \u0939\u0948\u0902, \u0924\u094B \u0939\u092E\u0947\u0902 hello@hedy.org \u092A\u0930 \u0938\u094D\u0924\u0930 \u0914\u0930 \u0905\u092A\u0928\u0947 \u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E \u0915\u0947 \u0938\u093E\u0925 \u090F\u0915 \u0908\u092E\u0947\u0932 \u092D\u0947\u091C\u0947\u0902\u0964 \u0907\u0938 \u092C\u0940\u091A, \u0915\u0941\u091B \u0905\u0932\u0917 \u0915\u0930\u0928\u0947 \u0915\u0940 \u0915\u094B\u0936\u093F\u0936 \u0915\u0930\u0947\u0902 \u0914\u0930 \u0909\u0926\u093E\u0939\u0930\u0923\u094B\u0902 \u092A\u0930 \u090F\u0915 \u0914\u0930 \u0928\u091C\u093C\u0930 \u0921\u093E\u0932\u0947\u0902\u0964 \u0927\u0928\u094D\u092F\u0935\u093E\u0926!",
          "Transpile_error": "\u0939\u092E \u0906\u092A\u0915\u093E \u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E \u0928\u0939\u0940\u0902 \u091A\u0932\u093E \u0938\u0915\u0924\u0947\u0964",
          "Transpile_success": "\u0905\u091A\u094D\u091B\u093E \u0915\u093E\u0930\u094D\u092F!\n\u0905\u0926\u094D\u092D\u0941\u0924!\n\u092C\u0939\u0941\u0924 \u092C\u0922\u093C\u093F\u092F\u093E!\n\u0909\u0924\u094D\u0915\u0943\u0937\u094D\u091F!\n\u0906\u092A\u0928\u0947 \u092C\u0939\u0941\u0924 \u0905\u091A\u094D\u091B\u093E \u0915\u093F\u092F\u093E!",
          "Transpile_warning": "\u091A\u0947\u0924\u093E\u0935\u0928\u0940!",
          "Unsaved_Changes": "\u0906\u092A\u0915\u0947 \u092A\u093E\u0938 \u090F\u0915 \u0938\u0939\u0947\u091C\u093E \u0928\u0939\u0940\u0902 \u0917\u092F\u093E \u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E \u0939\u0948\u0964 \u0915\u094D\u092F\u093E \u0906\u092A \u0907\u0938\u0947 \u0938\u0939\u0947\u091C\u0947 \u092C\u093F\u0928\u093E \u091B\u094B\u0921\u093C\u0928\u093E \u091A\u093E\u0939\u0924\u0947 \u0939\u0948\u0902?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "\u0936\u0947\u092F\u0930 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u0932\u093F\u0902\u0915 \u0915\u0949\u092A\u0940 \u0915\u0930\u0947\u0902",
          "customization_deleted": "\u0905\u0928\u0941\u0915\u0942\u0932\u0928 \u0938\u092B\u0932\u0924\u093E\u092A\u0942\u0930\u094D\u0935\u0915 \u0939\u091F\u093E \u0926\u093F\u090F \u0917\u090F\u0964",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "\u0938\u094D\u0924\u0930",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "\u0939\u0947\u0921\u0940 \u092E\u0947\u0902 \u0906\u092A\u0915\u093E \u0938\u094D\u0935\u093E\u0917\u0924 \u0939\u0948! \u0905\u092C \u0906\u092A \u090F\u0915 \u0936\u093F\u0915\u094D\u0937\u0915 \u0916\u093E\u0924\u0947 \u0915\u0947 \u0917\u0930\u094D\u0935\u093F\u0924 \u0938\u094D\u0935\u093E\u092E\u0940 \u0939\u0948\u0902 \u091C\u094B \u0906\u092A\u0915\u094B \u0915\u0915\u094D\u0937\u093E\u090F\u0902 \u092C\u0928\u093E\u0928\u0947 \u0914\u0930 \u091B\u093E\u0924\u094D\u0930\u094B\u0902 \u0915\u094B \u0906\u092E\u0902\u0924\u094D\u0930\u093F\u0924 \u0915\u0930\u0928\u0947 \u0915\u0940 \u0905\u0928\u0941\u092E\u0924\u093F \u0926\u0947\u0924\u093E \u0939\u0948\u0964",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "hu": {
          "CheckInternet": "Ellen\u0151rizd, hogy az internetkapcsolat megfelel\u0151en m\u0171k\xF6dik-e!",
          "Connection_error": "Nem tudjuk el\xE9rni a szervert.",
          "Empty_output": "M\u0171k\xF6dik a program, de nem \xEDr ki semmit. Helyezz el egy ki\xEDr\xE1st a k\xF3dban, vagy haszn\xE1ld a tekn\u0151st, hogy kimenetet kapj!",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Hiba t\xF6rt\xE9nt a program futtat\xE1sa k\xF6zben.",
          "Other_error": "Hopp\xE1! Tal\xE1n elk\xF6vett\xFCnk egy kis hib\xE1t.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "T\xFAl hossz\xFA ideig tart programod futtat\xE1sa.",
          "ServerError": "Olyan programot \xEDrt\xE1l, amire nem sz\xE1m\xEDtottunk. Ha seg\xEDteni szeretn\xE9l, k\xFCldj nek\xFCnk egy emailt a szinttel \xE9s a programmal a hello@hedy.org c\xEDmre! Id\u0151k\xF6zben pr\xF3b\xE1ld ki egy kicsit m\xE1sk\xE9pp, \xE9s n\xE9zd meg a p\xE9ld\xE1kat! K\xF6sz\xF6nj\xFCk!",
          "Transpile_error": "Nem tudjuk futtatni a k\xF3dodat.",
          "Transpile_success": "Sz\xE9p munka!\nLeny\u0171g\xF6z\u0151!\n\xDCgyes!\nKit\u0171n\u0151!\nRemek\xFCl csin\xE1ltad!",
          "Transpile_warning": "Vigy\xE1zat!",
          "Unsaved_Changes": "Nem mentett programod van. El akarsz menni ment\xE9s n\xE9lk\xFCl?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Link m\xE1sol\xE1sa a megoszt\xE1shoz",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Szint",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u{1F5FB}, \u{1F4DC}, \u2702\uFE0F",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "Biztosan elhagyod ezt az oldalt? Mentetlen v\xE1ltoztat\xE1said vannak, amik \xEDgy elveszhetnek."
        },
        "id": {
          "CheckInternet": "Cobalah cek apakah internet kamu berjalan dengan baik.",
          "Connection_error": "Kami tidak bisa terhubung dengan server.",
          "Empty_output": "Kode ini berfungsi tetapi tidak mencetak apa pun. Tambahkan print command ke dalam kode Anda atau gunakan turtle untuk mendapatkan hasil keluaran.",
          "Errors_found": "Kamu membuat kesalahan! Tidak perlu khawatir, program tetap berjalan",
          "Execute_error": "Sesuatu berjalan tidak seharusnya ketika program sedang dijalankan.",
          "Other_error": "Ups! Mungkin kamu membuat kesalahan kecil.",
          "Program_repair": "Apakah ini bisa menjadi kode yang benar, bisakah kamu memperbaikinya?",
          "Program_too_long": "Program Anda memakan waktu terlalu lama untuk berjalan.",
          "ServerError": "Kamu menuliskan sebuah program yang tidak kami duga. Jika kamu butuh bantuan, kirimkan email dengan informasi level dan program kamu ke hello@hedy.org. Sembari menunggu respon, cobalah cara lain atau lihat kembali contoh-contoh yang disediakan. Terima kasih!",
          "Transpile_error": "Kami tidak bisa menjalankan kode kamu.",
          "Transpile_success": "Kerja bagus!\nKeren!\nBagus sekali!\nBagus sekali!\nKamu sudah bagus!",
          "Transpile_warning": "Peringatan!",
          "Unsaved_Changes": "Kamu memiliki program yang belum disimpan. Apakah kamu mau keluar tanpa menyimpannya?",
          "adventures_restored": "Petualangan default telah dipulihkan.",
          "copy_link_to_share": "Salin tautan untuk berbagi",
          "customization_deleted": "Penyesuaian berhasil dihapus.",
          "dice": "\u{1F3B2}",
          "directly_available": "Terbuka langsung",
          "disabled": "Dinonaktifkan",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Selamat datang di Hedy! Anda sekarang bangga menjadi pemilik akun guru yang memungkinkan Anda membuat kelas dan mengundang siswa.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "Ada perubahan yang belum disimpan, yakin ingin meninggalkan halaman ini?"
        },
        "it": {
          "CheckInternet": "Dai un'occhiata se la tua connessione Internet funziona correttamente.",
          "Connection_error": "Non siamo riuscito a contattare il server.",
          "Empty_output": "Questo codice funziona ma non stampa nulla. Aggiungi un comando print al tuo codice o usa la tartaruga per ottenere l'output.",
          "Errors_found": "Hai fatto un errore! Non preoccuparti, abbiamo comunque eseguito il programma",
          "Execute_error": "Qualcosa \xE8 andato storto nell'esecuzione del tuo codice.",
          "Other_error": "Ops! Forse abbiamo fatto un errore.",
          "Program_repair": "Questo potrebbe essere il codice corretto, puoi risolverlo?",
          "Program_too_long": "Il tuo programma impiega troppo tempo per essere eseguito.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "Non possiamo eseguire il tuo programma.",
          "Transpile_success": "Ottimo lavoro!\nFantastico!\nBen fatto!\nEccellente!\nSei stato bravissimo!",
          "Transpile_warning": "Attenzione!",
          "Unsaved_Changes": "Hai un programma non salvato. Vuoi uscire senza salvare?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "Dado",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "fortuna",
          "haunted": "infestato",
          "level_title": "Livello",
          "restaurant": "Ristorante",
          "rock": "Roccia",
          "songs": "Suono",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "Tartaruga",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "ja": {
          "CheckInternet": "\u30A4\u30F3\u30BF\u30FC\u30CD\u30C3\u30C8\u306E\u63A5\u7D9A\u3092\u8ABF\u3079\u3066\u304F\u3060\u3055\u3044\u3002",
          "Connection_error": "\u30B5\u30FC\u30D0\u306B\u63A5\u7D9A\u3067\u304D\u307E\u305B\u3093\u3002",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Something went wrong while running the program.",
          "Other_error": "\u3042\uFF01\u591A\u5206\u3001\u79C1\u305F\u3061\u306F\u9593\u9055\u3044\u3057\u307E\u3057\u305F\u3002\u3054\u3081\u3093\u306A\u3055\u3044\u3002",
          "Program_repair": "\u3053\u306E\u30B3\u30FC\u30C9\u306F\u6B63\u89E3\u304C\u3067\u304D\u307E\u3059\u3002\u76F4\u305B\u307E\u3059\u304B\uFF1F",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "\u30D7\u30ED\u30B0\u30E9\u30E0\u3092\u5B9F\u884C\u304C\u3067\u304D\u307E\u305B\u3093\u3002",
          "Transpile_success": "\u3088\u304F\u3067\u304D\u305F\uFF01\n\u3059\u3054\u3044\uFF01\n\u3088\u304F\u3084\u3063\u305F\uFF01\n\u3048\u3089\u3044\uFF01\n\u9811\u5F35\u3063\u305F\u306D\uFF01",
          "Transpile_warning": "\u8B66\u544A\uFF01",
          "Unsaved_Changes": "\u975E\u4FDD\u5B58\u30D7\u30ED\u30B0\u30E9\u30E0\u304C\u3042\u308A\u307E\u3059\u3002\u305D\u308C\u3067\u3082\u3001\u7D42\u4E86\u3057\u307E\u3059\u304B\uFF1F",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "kmr": {
          "CheckInternet": "Have a look if your Internet connection is working properly.",
          "Connection_error": "We couldn't reach the server.",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Something went wrong while running the program.",
          "Other_error": "Oops! Maybe we made a little mistake.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "We can't run your program.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "Warning!",
          "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "ko": {
          "CheckInternet": "\uC778\uD130\uB137 \uC5F0\uACB0\uC774 \uC81C\uB300\uB85C \uC791\uB3D9\uD558\uB294\uC9C0 \uD655\uC778\uD574 \uBCF4\uC138\uC694.",
          "Connection_error": "\uC11C\uBC84\uC5D0 \uC5F0\uACB0\uC774 \uC548 \uB410\uC5B4\uC694.",
          "Empty_output": "\uC774 \uCF54\uB4DC\uB294 \uC791\uB3D9\uD558\uC9C0\uB9CC \uC544\uBB34\uAC83\uB3C4 \uC778\uC1C4\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4. \uCF54\uB4DC\uC5D0 \uC778\uC1C4 \uBA85\uB839\uC744 \uCD94\uAC00\uD558\uAC70\uB098 \uAC70\uBD81\uC774\uB97C \uC0AC\uC6A9\uD558\uC5EC \uCD9C\uB825\uC744 \uC5BB\uC73C\uC2ED\uC2DC\uC624.",
          "Errors_found": "\uD2C0\uB9B0\uAC83 \uAC19\uC544\uC694! \uAC71\uC815 \uB9C8\uC138\uC694, hedy\uB294 \uC2E4\uC218\uB97C \uCC3E\uC73C\uB824 \uD558\uACE0 \uC788\uC5B4\uC694",
          "Execute_error": "\uD504\uB85C\uADF8\uB7A8\uC744 \uC2E4\uD589\uD558\uB294 \uB3D9\uC548 \uBB38\uC81C\uAC00 \uC0DD\uACBC\uC5B4\uC694.",
          "Other_error": "\uC774\uB7F0! \uC800\uD76C\uAC00 \uC791\uC740 \uC2E4\uC218\uB97C \uD588\uB098\uBD10\uC694.",
          "Program_repair": "\uC774\uAC8C \uB9DE\uB294 \uCF54\uB4DC\uC77C \uC218\uB3C4 \uC788\uB294\uB370 \uC218\uC815 \uD574\uC8FC\uC2E4 \uC218 \uC788\uB098\uC694?",
          "Program_too_long": "\uD504\uB85C\uADF8\uB7A8\uC744 \uC2E4\uD589\uD558\uB294 \uB370 \uC2DC\uAC04\uC774 \uB108\uBB34 \uC624\uB798 \uAC78\uB9AC\uB124\uC694.",
          "ServerError": "\uB2F9\uC2E0\uC740 \uC800\uD76C\uAC00 \uC608\uC0C1\uD558\uC9C0 \uBABB\uD588\uB358 \uD504\uB85C\uADF8\uB7A8\uC744 \uC791\uC131\uD588\uC2B5\uB2C8\uB2E4. \uB9CC\uC57D \uB3C4\uC6C0\uC744 \uC8FC\uACE0 \uC2F6\uB2E4\uBA74, \uC6B0\uB9AC\uC5D0\uAC8C \uB808\uBCA8\uACFC hello@hedy.org \uC5D0 \uC788\uB294 \uB2F9\uC2E0\uC758 \uD504\uB85C\uADF8\uB7A8\uACFC \uD568\uAED8 \uC774\uBA54\uC77C\uC744 \uBCF4\uB0B4\uC8FC\uC138\uC694. \uADF8 \uB3D9\uC548, \uC870\uAE08 \uB2E4\uB978 \uAC83\uC744 \uC2DC\uB3C4\uD574\uBCF4\uACE0 \uC0AC\uB840\uB97C \uB2E4\uC2DC \uC0B4\uD3B4\uBCF4\uC138\uC694. \uAC10\uC0AC\uD569\uB2C8\uB2E4!",
          "Transpile_error": "\uD504\uB85C\uADF8\uB7A8\uC744 \uC2E4\uD589\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.",
          "Transpile_success": "\uC218\uACE0\uD558\uC168\uC5B4\uC694!\n\uCD5C\uACE0\uC5D0\uC694!\n\uC815\uB9D0 \uC798\uD558\uC168\uC5B4\uC694!\n\uD6CC\uB96D\uD574\uC694!\n\uB300\uB2E8\uD574\uC694!",
          "Transpile_warning": "\uACBD\uACE0!",
          "Unsaved_Changes": "\uC800\uC7A5\uD558\uC9C0 \uC54A\uC740 \uD504\uB85C\uADF8\uB7A8\uC774 \uC788\uC2B5\uB2C8\uB2E4. \uC800\uC7A5\uD558\uC9C0 \uC54A\uACE0 \uB098\uAC00\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
          "adventures_restored": "\uAE30\uBCF8 \uBAA8\uD5D8\uC774 \uBCF5\uAD6C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.",
          "copy_link_to_share": "\uACF5\uC720\uD560 \uB9C1\uD06C \uBCF5\uC0AC",
          "customization_deleted": "\uC0AC\uC6A9\uC790 \uC9C0\uC815\uC744 \uC131\uACF5\uC801\uC73C\uB85C \uC0AD\uC81C\uD588\uC2B5\uB2C8\uB2E4.",
          "dice": "\u{1F3B2}",
          "directly_available": "\uC9C1\uC811 \uC5F4\uB9BC",
          "disabled": "\uBE44\uD65C\uC131\uD654\uB428",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "\uB808\uBCA8",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "mi": {
          "CheckInternet": "Have a look if your Internet connection is working properly.",
          "Connection_error": "We couldn't reach the server.",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, we still ran the program",
          "Execute_error": "Something went wrong while running the program.",
          "Other_error": "Oops! Maybe we made a little mistake.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "We can't run your program.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "Warning!",
          "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
          "adventures_restored": "The default adventures have been restored.",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "nl": {
          "CheckInternet": "Controleer even of je internetverbinding het nog doet.",
          "Connection_error": "We konden niet goed met de server praten.",
          "Empty_output": "Deze code werkt wel, maar print niks. Voeg een print commando toe aan je code of gebruik de schildpad om output te krijgen.",
          "Errors_found": "Je hebt een foutje gemaakt! Maak je geen zorgen, Hedy probeert de fouten te vinden",
          "Execute_error": "Er ging iets fout bij het uitvoeren van het programma.",
          "Other_error": "Oeps! Misschien hebben wij een klein programmeerfoutje gemaakt.",
          "Program_repair": "Dit kan de correcte code zijn, kan je jouw code repareren?",
          "Program_too_long": "Jouw programma duurt te lang bij het uitvoeren.",
          "ServerError": "Je hebt een programma geschreven dat we niet verwacht hadden. Als je wilt helpen, stuur ons dan een mailtje met het level en je programma op hello@hedy.org. Probeer om verder te gaan je programma een beetje aan te passen en kijk nog eens goed naar de voorbeelden. Bedankt!",
          "Transpile_error": "We konden je code niet goed lezen.",
          "Transpile_success": "Goed gedaan!\nGa zo door!\nTopper!\nSuper!\nBravo!",
          "Transpile_warning": "Let op!",
          "Unsaved_Changes": "Jouw programma is niet opgeslagen. Wil je weggaan zonder het op te slaan?",
          "adventures_restored": "De standaardavonturen zijn terug gezet.",
          "copy_link_to_share": "Kopieer link voor delen",
          "customization_deleted": "Personalisatie succesvol verwijderd.",
          "dice": "\u{1F3B2}",
          "directly_available": "Gelijk open",
          "disabled": "Gedeactiveerd",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welkom bij Hedy! Jouw account is omgezet naar een leerkrachtenaccount. Je kan nu klassen maken en er leerlingen in uitnodigen.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "Er zijn wijzigingen nog niet opgeslagen, weet je zeker dat je terug wilt gaan?"
        },
        "no_NB": {
          "CheckInternet": "Sjekk internetttilkoblingen din, fungerer den.",
          "Connection_error": "Vi fikk ikke kontakt med serveren.",
          "Empty_output": "Denne koden virker men den skriver ikke ut noe. Legg til en print kommando til koden din eller bruk skipadden til \xE5 f\xE5 noe output.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Noe gikk feil mens vi kj\xF8rte programmet.",
          "Other_error": "Oops! Kanskje vi gjorde en liten feil.",
          "Program_repair": "Dette kan v\xE6re det korrekte programmet, kan du fikse det?",
          "Program_too_long": "Programmet ditt tok for lang tid \xE5 kj\xF8re.",
          "ServerError": "Du skrev et program vi ikke forventet oss. Om du trenger hjelp, send en epost med niv\xE5et du er p\xE5 og programmet til hello@hedy.org. I mellomtiden, pr\xF8v noe annet og ta en titt p\xE5 eksemplene. Takk!",
          "Transpile_error": "Vi kan ikke kj\xF8re programmet ditt.",
          "Transpile_success": "Godt jobbet!\nFantastisk!\nVeldig bra!\nSupert!\nDette fikk du til!",
          "Transpile_warning": "Advarsel!",
          "Unsaved_Changes": "Du har ulagrede endringer i programmet. Vil du g\xE5 uten \xE5 lagre de?",
          "adventures_restored": "The default adventures have been restored.",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "pa_PK": {
          "CheckInternet": "Have a look if your Internet connection is working properly.",
          "Connection_error": "We couldn't reach the server.",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Something went wrong while running the program.",
          "Other_error": "Oops! Maybe we made a little mistake.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "We can't run your program.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "Warning!",
          "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "pap": {
          "CheckInternet": "Have a look if your Internet connection is working properly.",
          "Connection_error": "We couldn't reach the server.",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, we still ran the program",
          "Execute_error": "Something went wrong while running the program.",
          "Other_error": "Oops! Maybe we made a little mistake.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "We can't run your program.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "Warning!",
          "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
          "adventures_restored": "The default adventures have been restored.",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "pl": {
          "CheckInternet": "Upewnij si\u0119, \u017Ce masz po\u0142\u0105czenie z Internetem.",
          "Connection_error": "B\u0142\u0105d po\u0142\u0105czenia z serwerem.",
          "Empty_output": "Ten kod dzia\u0142a, ale niczego nie wypisuje. Dodaj komend\u0119 'napisz' lub u\u017Cyj \u017C\xF3\u0142wia, by otrzyma\u0107 dane wyj\u015Bciowe.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Co\u015B posz\u0142o nie tak w trakcie wykonywania programu.",
          "Other_error": "Ups! Mo\u017Ce pope\u0142nili\u015Bmy ma\u0142y b\u0142\u0105d.",
          "Program_repair": "To mo\u017Ce by\u0107 poprawny kod, czy mo\u017Cesz go naprawi\u0107?",
          "Program_too_long": "Tw\xF3j program dzia\u0142a zbyt d\u0142ugo.",
          "ServerError": "Napisa\u0142e\u015B program, jakiego si\u0119 nie spodziewali\u015Bmy. Je\u017Celi chcesz nam pom\xF3c, wy\u015Blij wiadomo\u015B\u0107 na adres e-mail hello@hedy.org i wska\u017C poziom, na kt\xF3rym napisa\u0142e\u015B ten program oraz za\u0142\u0105cz jego kod. W mi\u0119dzyczasie spr\xF3buj czego\u015B innego i ponownie sp\xF3jrz na przyk\u0142ady. Dzi\u0119ki!",
          "Transpile_error": "Program nie mo\u017Ce zosta\u0107 uruchomiony.",
          "Transpile_success": "Dobra robota!\nWspaniale!\n\u015Awietnie!\nDoskonale!\nDobrze Ci posz\u0142o!",
          "Transpile_warning": "Ostrze\u017Cenie!",
          "Unsaved_Changes": "Tw\xF3j program nie zosta\u0142 zapisany. Chcesz wyj\u015B\u0107 mimo to?",
          "adventures_restored": "Domy\u015Blne przygody zosta\u0142y przywr\xF3cone.",
          "copy_link_to_share": "Skopiuj udost\u0119pniaj\u0105cy link",
          "customization_deleted": "Personalizacje zostaly usuni\u0119te pomy\u015Blnie.",
          "dice": "\u{1F3B2}",
          "directly_available": "Zawsze dost\u0119pne",
          "disabled": "Wy\u0142\u0105czono",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Poziom",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Witaj w Hedy! Jeste\u015B teraz dumnym posiadaczem konta nauczyciela, kt\xF3re pozwala Ci na tworzenie klas i zapraszanie uczni\xF3w.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "Strona zawiera niezapisane zmiany. Czy jeste\u015B pewien, \u017Ce chcesz wyj\u015B\u0107 bez zapisania zmian?"
        },
        "pt_BR": {
          "CheckInternet": "Verifique se a sua conex\xE3o com a Internet est\xE1 funcionando corretamente.",
          "Connection_error": "N\xF3s n\xE3o conseguimos conectar ao servidor.",
          "Empty_output": "Este c\xF3digo funciona mas n\xE3o imprime nada. Adicione um comando de impress\xE3o ou use a tartaruga para ter alguma sa\xEDda.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Alguma coisa deu errado enquanto o programa era executado.",
          "Other_error": "Opa! Talvez n\xF3s fizemos alguma coisa errada.",
          "Program_repair": "Este poderia ser o c\xF3digo correto, voc\xEA poderia corrigir ele?",
          "Program_too_long": "O seu programa leva muito tempo para executar.",
          "ServerError": "Voc\xEA escreveu um programa que n\xE3o est\xE1vamos esperando. Se voc\xEA quiser ajudar, envie-nos um email com o n\xEDvel e seu programa para hello@hedy.org. Enquanto isso, tente algo um pouco diferente e d\xEA uma outra olhada nos exemplos. Obrigado!",
          "Transpile_error": "N\xE3o conseguimos executar o seu programa.",
          "Transpile_success": "Bom trabalho!\nImpressionante!\nMuito bem!\nExcelente!\n\xD3timo!",
          "Transpile_warning": "Aviso!",
          "Unsaved_Changes": "Voc\xEA tem um programa n\xE3o salvo. Voc\xEA deseja sair sem salv\xE1-lo?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copiar link para compartilhar",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "N\xEDvel",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "pt_PT": {
          "CheckInternet": "Verifica se a tua liga\xE7\xE3o de Internet est\xE1 a funcionar correctamente.",
          "Connection_error": "N\xE3o conseguimos contactar o servidor.",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Alguma coisa correu mal enquanto execut\xE1vamos o programa.",
          "Other_error": "Oops! Talvez cometemos um pequeno erro.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "Escreveste um programa que n\xE3o est\xE1vamos \xE0 espera. Se queres ajudar, envia-nos um email com o n\xEDvel e o teu programa para hello@hedy.org. Entretanto, experimenta alguma coisa um pouco diferente e volta a olhar para os exemplos. Obrigado!",
          "Transpile_error": "N\xE3o conseguimos executar o teu programa.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "Aviso!",
          "Unsaved_Changes": "Tens um programa por guardar. Queres sair sem o guardar?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copiar liga\xE7\xE3o de partilha",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "N\xEDvel",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "tartaruga\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "ro": {
          "CheckInternet": "Verific\u0103 dac\u0103 ai semnal la internet.",
          "Connection_error": "Nu am putut contacta serverul.",
          "Empty_output": "Acest program func\u021Bioneaz\u0103 dar nu printeaz\u0103 nimic. Adaug\u0103 o comand\u0103 de printare sau folose\u0219te \u021Bestoasa s\u0103 ob\u021Bii un rezultat.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Ceva nu a func\u021Bionat corect in timpul rul\u0103rii programului.",
          "Other_error": "Opa! Este posibil s\u0103 fi f\u0103cut vreo gre\u0219eal\u0103.",
          "Program_repair": "Probabil a\u0219a arat\u0103 programul corect, po\u021Bi corecta?",
          "Program_too_long": "Rularea programului t\u0103u dureaz\u0103 prea mult.",
          "ServerError": "Ai scris un program nea\u0219teptat. Dac\u0103 ai nevoie de ajutor trimite-ne un email la: hello@hedy.org \u0219i specific\u0103 nivelul. Intre timp incearc\u0103 ceva diferit \u0219i incearc\u0103 din nou exemplele. Mul\u021Bumim!",
          "Transpile_error": "Nu putem rula program t\u0103u.",
          "Transpile_success": "Excelent!\nExtraordinar!\nFoarte bine!\nExcelent!\nFoarte bine!",
          "Transpile_warning": "Aten\u021Bie!",
          "Unsaved_Changes": "Ai un program care nu este salvat. Dore\u0219ti s\u0103 ie\u0219i f\u0103r\u0103 salvare?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "ru": {
          "CheckInternet": "\u041F\u0440\u043E\u0432\u0435\u0440\u044C \u0441\u0432\u043E\u0451 \u0438\u043D\u0442\u0435\u0440\u043D\u0435\u0442 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435.",
          "Connection_error": "\u041D\u0435 \u043C\u043E\u0433\u0443 \u043D\u0430\u0439\u0442\u0438 \u0441\u0435\u0440\u0432\u0435\u0440.",
          "Empty_output": "\u042D\u0442\u043E\u0442 \u043A\u043E\u0434 \u0440\u0430\u0431\u043E\u0442\u0430\u0435\u0442, \u043D\u043E \u043D\u0435 \u0432\u044B\u0432\u043E\u0434\u0438\u0442 \u043D\u0438\u0447\u0435\u0433\u043E. \u0414\u043E\u0431\u0430\u0432\u044C \u043A\u043E\u043C\u0430\u043D\u0434\u0443 \u043F\u0435\u0447\u0430\u0442\u044C \u0432 \u0442\u0432\u043E\u0439 \u043A\u043E\u0434 \u0438\u043B\u0438 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439 \u0447\u0435\u0440\u0435\u043F\u0430\u0448\u043A\u0435 \u0447\u0442\u043E\u0431\u044B \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0432\u044B\u0432\u043E\u0434.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "\u0427\u0442\u043E-\u0442\u043E \u043F\u043E\u0448\u043B\u043E \u043D\u0435 \u0442\u0430\u043A \u043F\u0440\u0438 \u0437\u0430\u043F\u0443\u0441\u043A\u0435 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u044B.",
          "Other_error": "\u0423\u043F\u0441, \u043A\u0430\u0436\u0435\u0442\u0441\u044F \u0432\u044B\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043E\u0447\u043A\u0430.",
          "Program_repair": "\u042D\u0442\u043E \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u044B\u0439 \u043A\u043E\u0434, \u043C\u043E\u0436\u0435\u0442\u0435 \u043B\u0438 \u0432\u044B \u0435\u0433\u043E \u0438\u0441\u043F\u0440\u0430\u0432\u0438\u0442\u044C?",
          "Program_too_long": "\u0412\u0430\u0448\u0430 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0430 \u0432\u044B\u043F\u043E\u043B\u043D\u044F\u0435\u0442\u0441\u044F \u0441\u043B\u0438\u0448\u043A\u043E\u043C \u0434\u043E\u043B\u0433\u043E.",
          "ServerError": "\u0412\u044B \u043D\u0430\u043F\u0438\u0441\u0430\u043B\u0438 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0443, \u043A\u043E\u0442\u043E\u0440\u0443\u044E \u043C\u044B \u043D\u0435 \u043E\u0436\u0438\u0434\u0430\u043B\u0438. \u0415\u0441\u043B\u0438 \u0432\u044B \u0445\u043E\u0442\u0438\u0442\u0435 \u043F\u043E\u043C\u043E\u0447\u044C, \u043F\u0440\u0438\u0448\u043B\u0438\u0442\u0435 \u043D\u0430\u043C \u043F\u0438\u0441\u044C\u043C\u043E \u0441 \u0443\u043A\u0430\u0437\u0430\u043D\u0438\u0435\u043C \u0443\u0440\u043E\u0432\u043D\u044F \u0438 \u0432\u0430\u0448\u0435\u0439 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u044B \u043F\u043E \u0430\u0434\u0440\u0435\u0441\u0443 hello@hedy.org. \u0410 \u043F\u043E\u043A\u0430 \u043F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0441\u0434\u0435\u043B\u0430\u0442\u044C \u0447\u0442\u043E-\u0442\u043E \u0434\u0440\u0443\u0433\u043E\u0435 \u0438 \u043F\u043E\u0441\u043C\u043E\u0442\u0440\u0438\u0442\u0435 \u0435\u0449\u0435 \u0440\u0430\u0437 \u043D\u0430 \u043F\u0440\u0438\u043C\u0435\u0440\u044B. \u0421\u043F\u0430\u0441\u0438\u0431\u043E!",
          "Transpile_error": "\u041C\u044B \u043D\u0435 \u043C\u043E\u0436\u0435\u043C \u0437\u0430\u043F\u0443\u0441\u0442\u0438\u0442\u044C \u0442\u0432\u043E\u044E \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0443.",
          "Transpile_success": "\u041E\u0442\u043B\u0438\u0447\u043D\u0430\u044F \u0440\u0430\u0431\u043E\u0442\u0430!\n\u041F\u043E\u0442\u0440\u044F\u0441\u0430\u044E\u0449\u0435!\n\u041E\u0442\u043B\u0438\u0447\u043D\u043E \u043F\u043E\u043B\u0443\u0447\u0438\u043B\u043E\u0441\u044C!\n\u041F\u0440\u0435\u043A\u0440\u0430\u0441\u043D\u043E!\n\u0423 \u0442\u0435\u0431\u044F \u043E\u0442\u043B\u0438\u0447\u043D\u043E \u043F\u043E\u043B\u0443\u0447\u0430\u0435\u0442\u0441\u044F!",
          "Transpile_warning": "\u0412\u043D\u0438\u043C\u0430\u043D\u0438\u0435!",
          "Unsaved_Changes": "\u0423 \u0442\u0435\u0431\u044F \u043D\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0430 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0430. \u0425\u043E\u0447\u0435\u0448\u044C \u0432\u044B\u0439\u0442\u0438 \u0431\u0435\u0437 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "\u0421\u043A\u043E\u043F\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u0441\u044B\u043B\u043A\u0443, \u0447\u0442\u043E\u0431\u044B \u043F\u043E\u0434\u0435\u043B\u0438\u0442\u044C\u0441\u044F",
          "customization_deleted": "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0443\u0434\u0430\u043B\u0435\u043D\u044B.",
          "dice": "\u{1F3B2}",
          "directly_available": "\u041F\u0440\u044F\u043C\u043E\u0435 \u043E\u0442\u043A\u0440\u044B\u0442\u0438\u0435",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "\u0423\u0440\u043E\u0432\u0435\u043D\u044C",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "\u0414\u043E\u0431\u0440\u043E \u043F\u043E\u0436\u0430\u043B\u043E\u0432\u0430\u0442\u044C \u0432 Hedy! \u0422\u0435\u043F\u0435\u0440\u044C \u0432\u044B \u044F\u0432\u043B\u044F\u0435\u0442\u0435\u0441\u044C \u0433\u043E\u0440\u0434\u044B\u043C \u0432\u043B\u0430\u0434\u0435\u043B\u044C\u0446\u0435\u043C \u0443\u0447\u0435\u0442\u043D\u043E\u0439 \u0437\u0430\u043F\u0438\u0441\u0438 \u0443\u0447\u0438\u0442\u0435\u043B\u044F, \u043A\u043E\u0442\u043E\u0440\u0430\u044F \u043F\u043E\u0437\u0432\u043E\u043B\u044F\u0435\u0442 \u0432\u0430\u043C \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C \u043A\u043B\u0430\u0441\u0441\u044B \u0438 \u043F\u0440\u0438\u0433\u043B\u0430\u0448\u0430\u0442\u044C \u0443\u0447\u0435\u043D\u0438\u043A\u043E\u0432.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "\u0415\u0441\u0442\u044C \u043D\u0435\u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u043D\u044B\u0435 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F, \u0432\u044B \u0443\u0432\u0435\u0440\u0435\u043D\u044B, \u0447\u0442\u043E \u0445\u043E\u0442\u0438\u0442\u0435 \u043F\u043E\u043A\u0438\u043D\u0443\u0442\u044C \u044D\u0442\u0443 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0443?"
        },
        "sq": {
          "CheckInternet": "Shikoni n\xEBse lidhja juaj e internetit po funksionon si\xE7 duhet.",
          "Connection_error": "Nuk arrit\xEBm dot te serveri.",
          "Empty_output": "Ky kod funksionon, por nuk printon asgj\xEB. Shtoni komand\xEBn print n\xEB kodin tuaj ose p\xEBrdorni breshk\xEBn p\xEBr t\xEB marr\xEB rezultatin.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Di\xE7ka shkoi keq gjat\xEB ekzekutimit t\xEB programit.",
          "Other_error": "Oops! Ndoshta kemi b\xEBr\xEB nj\xEB gabim t\xEB vog\xEBl.",
          "Program_repair": "Ky mund t\xEB jet\xEB kodi i duhur, a mund ta rregulloni?",
          "Program_too_long": "Programi juaj merr shum\xEB koh\xEB p\xEBr t\xEB ekzekutuar.",
          "ServerError": "Ke shkruar nj\xEB program q\xEB nuk e prisnim. N\xEBse d\xEBshironi t\xEB ndihmoni, na d\xEBrgoni nj\xEB email me nivelin dhe programin tuaj n\xEB hello@hedy.org. Nd\xEBrkoh\xEB, provoni di\xE7ka pak m\xEB ndryshe dhe hidhini nj\xEB sy shembujve. Faleminderit!",
          "Transpile_error": "Ne nuk mund ta ekzekutojm\xEB programin tuaj.",
          "Transpile_success": "Pun\xEB e mir\xEB!\nE mahnitshme!\nTe lumte!\nE shk\xEBlqyeshme!\nJu dol\xEBt shum\xEB mir\xEB!",
          "Transpile_warning": "Paralajm\xEBrim!",
          "Unsaved_Changes": "Ju keni nj\xEB program t\xEB paruajtur. D\xEBshiron t\xEB largohesh pa e ruajtur?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "sr": {
          "CheckInternet": "Proveri da li ima\u0161 internet konekciju.",
          "Connection_error": "Ne mogu dostignuti server.",
          "Empty_output": "Ovaj kod radi, ali ne prikazuje ni\u0161ta. Dodaj komandu za prikazivanje u kodu ili koristi turtle da prika\u017Ee\u0161 rezultat.",
          "Errors_found": "Napravio si gre\u0161ku! Ne brini, i dalje smo uspeli da pokrenemo program",
          "Execute_error": "Ne\u0161to se pokvarilo dok je program radio.",
          "Other_error": "Ups! Mo\u017Eda smo napravili malu gre\u0161ku.",
          "Program_repair": "Mo\u017Eda je ovo ispravan kod, mo\u017Ee\u0161 li ga popraviti?",
          "Program_too_long": "Tvoj program zahteva mnogo vremena za pokretanje.",
          "ServerError": "Napisali ste program koji nismo o\u010Dekivali. Ako \u017Eelite da pomognete, po\u0161aljite nam mejl sa nivoom i va\u0161im programom na hello@hedy.org. U me\u0111uvremenu, poku\u0161ajte ne\u0161to malo druga\u010Dije i pogledajte jo\u0161 jednom primere. Hvala!",
          "Transpile_error": "Ne mo\u017Eemo da pokrenemo tvoj program.",
          "Transpile_success": "Dobar posao!\nNeverovatno!\nDobro ura\u0111eno!\nOdli\u010Dno!\nBio si odli\u010Dan!",
          "Transpile_warning": "Upozorenje!",
          "Unsaved_Changes": "Nisi sa\u010Duvao program. \u017Deli\u0161 li da iza\u0111e\u0161 bez \u010Duvanja?",
          "adventures_restored": "Podrazumevane avanture su vra\u0107ene.",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Nivo",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "sv": {
          "CheckInternet": "Kontrollera att din internetanslutning fungerar.",
          "Connection_error": "Vi kunde inte n\xE5 servern.",
          "Empty_output": "Den h\xE4r koden fungerar men skriver inget. L\xE4gg till ett utskriftskommando till din kod eller anv\xE4nd sk\xF6ldpaddan f\xF6r att f\xE5 n\xE5got resultat.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "N\xE5got gick fel n\xE4r programmet k\xF6rdes.",
          "Other_error": "Hoppsan! Vi gjorde nog ett litet misstag.",
          "Program_repair": "Detta kan vara r\xE4tt kod; kan du laga den?",
          "Program_too_long": "Ditt program tar f\xF6r l\xE5ng tid att k\xF6ra.",
          "ServerError": "Du skrev ett program som vi inte v\xE4ntade oss. Om du vill hj\xE4lpa oss, skicka ett mejl med niv\xE5n och ditt program till hello@hedy.org. Under tiden kan du testa att \xE4ndra lite och ta en ny titt p\xE5 exemplen. Tack!",
          "Transpile_error": "Vi kan inte k\xF6ra ditt program.",
          "Transpile_success": "Bra jobbat!\nFantastiskt!\nBra jobbat!\nUtm\xE4rkt!\nBra jobbat!",
          "Transpile_warning": "Varning!",
          "Unsaved_Changes": "Ditt program \xE4r inte sparat. Vill du l\xE4mna utan att spara det?",
          "adventures_restored": "Standard\xE4ventyren har \xE5terst\xE4llts.",
          "copy_link_to_share": "Kopiera l\xE4nken f\xF6r att dela den",
          "customization_deleted": "Anpassningarna har tagits bort.",
          "dice": "\u{1F3B2}",
          "directly_available": "\xD6ppna direkt",
          "disabled": "Inaktiverad",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Niv\xE5",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "V\xE4lkommen till Hedy! Du \xE4r nu den stolta \xE4garen av ett l\xE4rarkonto som ger dig m\xF6jlighet att skapa klasser och bjuda in elever.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "Det finns osparade \xE4ndringar; \xE4r du s\xE4ker p\xE5 att du vill l\xE4mna sidan?"
        },
        "sw": {
          "CheckInternet": "Have a look if your Internet connection is working properly.",
          "Connection_error": "Hatukuweza kufikia seva.",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Matatizo fulani ilitokea wakati wa kuendesha programu.",
          "Other_error": "Oops! Labda tulifanya makosa kidogo.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "Hatuwezi kuendesha programu yako.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "Onyo!",
          "Unsaved_Changes": "Una programu ambao haujahifadhiwa. Je! Unataka kuondoka bila kuiokoa?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Kiwango",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "te": {
          "CheckInternet": "Have a look if your Internet connection is working properly.",
          "Connection_error": "We couldn't reach the server.",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Something went wrong while running the program.",
          "Other_error": "Oops! Maybe we made a little mistake.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "We can't run your program.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "Warning!",
          "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "th": {
          "CheckInternet": "\u0E40\u0E2D\u0E4B \u0E2D\u0E34\u0E19\u0E40\u0E15\u0E2D\u0E23\u0E4C\u0E40\u0E19\u0E47\u0E15\u0E21\u0E35\u0E1B\u0E31\u0E0D\u0E2B\u0E32\u0E2B\u0E23\u0E37\u0E2D\u0E40\u0E1B\u0E25\u0E48\u0E32",
          "Connection_error": "\u0E40\u0E23\u0E32\u0E15\u0E34\u0E14\u0E15\u0E48\u0E2D\u0E01\u0E31\u0E1A\u0E40\u0E0B\u0E34\u0E1F\u0E40\u0E27\u0E2D\u0E23\u0E4C\u0E44\u0E21\u0E48\u0E44\u0E14\u0E49.",
          "Empty_output": "\u0E42\u0E04\u0E49\u0E14\u0E19\u0E35\u0E49\u0E23\u0E31\u0E19\u0E44\u0E14\u0E49\u0E1B\u0E01\u0E15\u0E34\u0E19\u0E30 \u0E41\u0E15\u0E48\u0E27\u0E48\u0E32\u0E44\u0E21\u0E48\u0E44\u0E14\u0E49\u0E1E\u0E34\u0E21\u0E1E\u0E4C\u0E2D\u0E30\u0E44\u0E23\u0E2D\u0E2D\u0E01\u0E21\u0E32\u0E40\u0E25\u0E22 \u0E19\u0E48\u0E32\u0E08\u0E30\u0E25\u0E37\u0E21\u0E43\u0E0A\u0E49\u0E04\u0E33\u0E2A\u0E31\u0E48\u0E07\u0E41\u0E2A\u0E14\u0E07\u0E2B\u0E23\u0E37\u0E2D\u0E43\u0E0A\u0E49\u0E43\u0E2B\u0E49\u0E40\u0E15\u0E48\u0E32\u0E27\u0E32\u0E14\u0E23\u0E39\u0E1B\u0E2B\u0E23\u0E37\u0E2D\u0E40\u0E1B\u0E25\u0E48\u0E32",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "\u0E40\u0E01\u0E34\u0E14\u0E02\u0E49\u0E2D\u0E1C\u0E34\u0E14\u0E1E\u0E25\u0E32\u0E14\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E23\u0E31\u0E19\u0E42\u0E1B\u0E23\u0E41\u0E01\u0E23\u0E21",
          "Other_error": "\u0E2D\u0E38\u0E49\u0E22\u0E22! \u0E19\u0E48\u0E32\u0E08\u0E30\u0E1C\u0E34\u0E14\u0E1E\u0E25\u0E32\u0E14\u0E2D\u0E30\u0E44\u0E23\u0E40\u0E25\u0E47\u0E01\u0E19\u0E49\u0E2D\u0E22\u0E2B\u0E23\u0E37\u0E2D\u0E40\u0E1B\u0E25\u0E48\u0E32",
          "Program_repair": "\u0E42\u0E04\u0E49\u0E14\u0E19\u0E35\u0E49\u0E2D\u0E32\u0E08\u0E08\u0E30\u0E16\u0E39\u0E01\u0E41\u0E25\u0E49\u0E27 \u0E41\u0E15\u0E48\u0E04\u0E38\u0E13\u0E25\u0E2D\u0E07\u0E41\u0E01\u0E49\u0E2B\u0E19\u0E48\u0E2D\u0E22\u0E44\u0E14\u0E49\u0E21\u0E31\u0E49\u0E22?",
          "Program_too_long": "\u0E42\u0E1B\u0E23\u0E41\u0E01\u0E23\u0E21\u0E19\u0E35\u0E49\u0E43\u0E0A\u0E49\u0E40\u0E27\u0E25\u0E32\u0E23\u0E31\u0E19\u0E19\u0E32\u0E19\u0E40\u0E01\u0E34\u0E19\u0E44\u0E1B\u0E19\u0E30",
          "ServerError": "\u0E04\u0E38\u0E13\u0E40\u0E02\u0E35\u0E22\u0E19\u0E42\u0E1B\u0E23\u0E41\u0E01\u0E23\u0E21\u0E17\u0E35\u0E48\u0E40\u0E23\u0E32\u0E44\u0E21\u0E48\u0E04\u0E34\u0E14\u0E27\u0E48\u0E32\u0E08\u0E30\u0E21\u0E35\u0E04\u0E19\u0E40\u0E02\u0E35\u0E22\u0E19\u0E21\u0E32 \u0E40\u0E23\u0E32\u0E08\u0E30\u0E02\u0E2D\u0E1A\u0E04\u0E38\u0E13\u0E21\u0E32\u0E01\u0E16\u0E49\u0E32\u0E04\u0E38\u0E13\u0E0A\u0E48\u0E27\u0E22\u0E2A\u0E48\u0E07\u0E42\u0E1B\u0E23\u0E41\u0E01\u0E23\u0E21\u0E41\u0E25\u0E30\u0E40\u0E25\u0E40\u0E27\u0E25\u0E17\u0E35\u0E48\u0E04\u0E38\u0E13\u0E2D\u0E22\u0E39\u0E48\u0E21\u0E32\u0E17\u0E32\u0E07\u0E2D\u0E35\u0E40\u0E21\u0E25 hello@hedy.org \u0E41\u0E25\u0E30\u0E43\u0E19\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E19\u0E35\u0E49 \u0E25\u0E2D\u0E07\u0E14\u0E39\u0E15\u0E31\u0E27\u0E2D\u0E22\u0E48\u0E32\u0E07 \u0E2B\u0E23\u0E37\u0E2D\u0E25\u0E2D\u0E07\u0E40\u0E02\u0E35\u0E22\u0E19\u0E14\u0E49\u0E27\u0E22\u0E27\u0E34\u0E18\u0E35\u0E2D\u0E37\u0E48\u0E19\u0E14\u0E39\u0E01\u0E48\u0E2D\u0E19\u0E19\u0E30 \u0E02\u0E2D\u0E1A\u0E04\u0E38\u0E13\u0E21\u0E32\u0E01!",
          "Transpile_error": "\u0E42\u0E1B\u0E23\u0E41\u0E01\u0E23\u0E21\u0E19\u0E35\u0E49\u0E44\u0E21\u0E48\u0E2A\u0E32\u0E21\u0E32\u0E23\u0E16\u0E23\u0E31\u0E19\u0E44\u0E14\u0E49",
          "Transpile_success": "\u0E40\u0E01\u0E48\u0E07\u0E21\u0E32\u0E01!\n\u0E2A\u0E38\u0E14\u0E22\u0E2D\u0E14!\n\u0E22\u0E2D\u0E14\u0E40\u0E22\u0E35\u0E48\u0E22\u0E21!\n\u0E40\u0E25\u0E34\u0E28\u0E21\u0E32\u0E01!\n\u0E17\u0E33\u0E44\u0E14\u0E49\u0E14\u0E35\u0E21\u0E32\u0E01!",
          "Transpile_warning": "\u0E04\u0E33\u0E40\u0E15\u0E37\u0E2D\u0E19!",
          "Unsaved_Changes": "\u0E42\u0E1B\u0E23\u0E41\u0E01\u0E23\u0E21\u0E17\u0E35\u0E48\u0E40\u0E02\u0E35\u0E22\u0E19\u0E22\u0E31\u0E07\u0E44\u0E21\u0E48\u0E44\u0E14\u0E49\u0E40\u0E0B\u0E1F\u0E19\u0E30 \u0E08\u0E30\u0E2D\u0E2D\u0E01\u0E08\u0E32\u0E01\u0E2B\u0E19\u0E49\u0E32\u0E19\u0E35\u0E49\u0E40\u0E25\u0E22 \u0E42\u0E14\u0E22\u0E44\u0E21\u0E48\u0E40\u0E0B\u0E1F\u0E01\u0E48\u0E2D\u0E19\u0E2B\u0E23\u0E2D?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "tl": {
          "CheckInternet": "Have a look if your Internet connection is working properly.",
          "Connection_error": "We couldn't reach the server.",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Something went wrong while running the program.",
          "Other_error": "Oops! Maybe we made a little mistake.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "We can't run your program.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "Warning!",
          "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "tn": {
          "CheckInternet": "Have a look if your Internet connection is working properly.",
          "Connection_error": "We couldn't reach the server.",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Something went wrong while running the program.",
          "Other_error": "Oops! Maybe we made a little mistake.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "We can't run your program.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "Warning!",
          "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "tr": {
          "CheckInternet": "\u0130nternet ba\u011Flant\u0131n\u0131z do\u011Fru \xE7al\u0131\u015F\u0131yor mu diye bir g\xF6z at\u0131n.",
          "Connection_error": "Sunucuya ula\u015Famad\u0131k.",
          "Empty_output": "Bu kod \xE7al\u0131\u015F\u0131yor ama hi\xE7bir \u015Fey yazd\u0131rm\u0131yor. Kodunuzda bir yazd\u0131rma komutu kullan\u0131n veya bir \xE7\u0131kt\u0131 almak i\xE7in kaplumba\u011Fay\u0131 kullan\u0131n.",
          "Errors_found": "Bir hata yapt\u0131n\u0131z! Endi\u015Felenmeyin, program\u0131 yine de \xE7al\u0131\u015Ft\u0131rd\u0131k",
          "Execute_error": "Program\u0131 \xE7al\u0131\u015Ft\u0131r\u0131rken bir \u015Feyler ters gitti.",
          "Other_error": "Oops! Belki k\xFC\xE7\xFCk bir hata yapm\u0131\u015F olabiliriz.",
          "Program_repair": "Bu do\u011Fru kod olabilirdi, onu d\xFCzeltebilir misin?",
          "Program_too_long": "Program\u0131n\u0131z\u0131n \xE7al\u0131\u015Fmas\u0131 \xE7ok uzun s\xFCr\xFCyor.",
          "ServerError": "Bizim beklemedi\u011Fimiz bir program yazd\u0131n\u0131z. E\u011Fer yard\u0131m etmek isterseniz, bize hello@hedy.org adresinden ilgili seviye ve program\u0131n\u0131zla birlikte bir e-posta g\xF6nderin. Bu arada, biraz farkl\u0131 bir \u015Fey deneyin ve \xF6rneklere bir kez daha g\xF6z at\u0131n. Te\u015Fekk\xFCrler!",
          "Transpile_error": "Program\u0131n\u0131 \xE7al\u0131\u015Ft\u0131ram\u0131yoruz.",
          "Transpile_success": "Aferin!\n\u0130nan\u0131lmaz!\n\u0130yi i\u015Fti, Aferin!\nM\xFCkemmel!\n\xC7ok iyiydin!",
          "Transpile_warning": "Uyar\u0131!",
          "Unsaved_Changes": "Kaydedilmemi\u015F bir program\u0131n var. Kaydetmeden ayr\u0131lmak m\u0131 istiyorsun?",
          "adventures_restored": "Varsay\u0131lan maceralar geri y\xFCklendi.",
          "copy_link_to_share": "Payla\u015Fmak i\xE7in ba\u011Flant\u0131y\u0131 kopyalay\u0131n",
          "customization_deleted": "\xD6zelle\u015Ftirmeler ba\u015Far\u0131yla silindi.",
          "dice": "\u{1F3B2}",
          "directly_available": "Do\u011Frudan a\xE7\u0131n",
          "disabled": "Devre d\u0131\u015F\u0131",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Seviye",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Hedy'ye ho\u015F geldiniz! Art\u0131k s\u0131n\u0131flar olu\u015Fturman\u0131za ve \xF6\u011Frencileri davet etmenize olanak tan\u0131yan bir \xF6\u011Fretmen hesab\u0131n\u0131n gururlu sahibisiniz.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "Kaydedilmemi\u015F de\u011Fi\u015Fiklikler var, bu sayfadan ayr\u0131lmak istedi\u011Finize emin misiniz?"
        },
        "uk": {
          "CheckInternet": "\u041F\u0435\u0440\u0435\u0432\u0456\u0440\u0442\u0435, \u0447\u0438 \u0432\u0430\u0448\u0435 \u043F\u0456\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044F \u0434\u043E \u0406\u043D\u0442\u0435\u0440\u043D\u0435\u0442\u0443 \u043F\u0440\u0430\u0446\u044E\u0454 \u043D\u0430\u043B\u0435\u0436\u043D\u0438\u043C \u0447\u0438\u043D\u043E\u043C.",
          "Connection_error": "\u041D\u0435 \u0432\u0434\u0430\u043B\u043E\u0441\u044F \u043F\u0456\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u0438\u0441\u044F \u0434\u043E \u0441\u0435\u0440\u0432\u0435\u0440\u0430.",
          "Empty_output": "\u0426\u0435\u0439 \u043A\u043E\u0434 \u043F\u0440\u0430\u0446\u044E\u0454, \u0430\u043B\u0435 \u043D\u0456\u0447\u043E\u0433\u043E \u043D\u0435 \u0434\u0440\u0443\u043A\u0443\u0454. \u0414\u043E\u0434\u0430\u0439\u0442\u0435 \u043A\u043E\u043C\u0430\u043D\u0434\u0443 \u0434\u0440\u0443\u043A\u0443 \u0434\u043E \u0441\u0432\u043E\u0433\u043E \u043A\u043E\u0434\u0443 \u0430\u0431\u043E \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0439\u0442\u0435 \u0447\u0435\u0440\u0435\u043F\u0430\u0445\u0443, \u0449\u043E\u0431 \u043E\u0442\u0440\u0438\u043C\u0430\u0442\u0438 \u0432\u0438\u0432\u0456\u0434.",
          "Errors_found": "\u0412\u0438 \u0437\u0440\u043E\u0431\u0438\u043B\u0438 \u043F\u043E\u043C\u0438\u043B\u043A\u0443! \u041D\u0435 \u0442\u0443\u0440\u0431\u0443\u0439\u0442\u0435\u0441\u044F, \u043C\u0438 \u043F\u0440\u043E\u0434\u043E\u0432\u0438\u043C\u043E \u0432\u0438\u043A\u043E\u043D\u0443\u0432\u0430\u0442\u0438 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0443",
          "Execute_error": "\u0429\u043E\u0441\u044C \u043F\u0456\u0448\u043B\u043E \u043D\u0435 \u0442\u0430\u043A \u043F\u0456\u0434 \u0447\u0430\u0441 \u0437\u0430\u043F\u0443\u0441\u043A\u0443 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0438.",
          "Other_error": "\u041E\u0439! \u041C\u043E\u0436\u043B\u0438\u0432\u043E, \u043C\u0438 \u0442\u0440\u043E\u0445\u0438 \u043F\u043E\u043C\u0438\u043B\u0438\u043B\u0438\u0441\u044F.",
          "Program_repair": "\u0426\u0435 \u043C\u043E\u0436\u0435 \u0431\u0443\u0442\u0438 \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043E\u0434, \u0432\u0438 \u043C\u043E\u0436\u0435\u0442\u0435 \u0439\u043E\u0433\u043E \u0432\u0438\u043F\u0440\u0430\u0432\u0438\u0442\u0438?",
          "Program_too_long": "\u0412\u0430\u0448\u0430 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0430 \u0432\u0438\u043A\u043E\u043D\u0443\u0454\u0442\u044C\u0441\u044F \u043D\u0430\u0434\u0442\u043E \u0434\u043E\u0432\u0433\u043E.",
          "ServerError": "\u0412\u0438 \u043D\u0430\u043F\u0438\u0441\u0430\u043B\u0438 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0443, \u044F\u043A\u0443 \u043C\u0438 \u043D\u0435 \u043E\u0447\u0456\u043A\u0443\u0432\u0430\u043B\u0438. \u042F\u043A\u0449\u043E \u0432\u0438 \u0445\u043E\u0447\u0435\u0442\u0435 \u0434\u043E\u043F\u043E\u043C\u043E\u0433\u0442\u0438, \u043D\u0430\u0434\u0456\u0448\u043B\u0456\u0442\u044C \u043D\u0430\u043C \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u0438\u0439 \u043B\u0438\u0441\u0442 \u0456\u0437 \u0437\u0430\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F\u043C \u0440\u0456\u0432\u043D\u044F \u0442\u0430 \u0432\u0430\u0448\u043E\u0457 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0438 \u043D\u0430 hello@hedy.org. \u0422\u0438\u043C \u0447\u0430\u0441\u043E\u043C \u0441\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0449\u043E\u0441\u044C \u0442\u0440\u043E\u0445\u0438 \u0456\u043D\u0448\u0435 \u0442\u0430 \u0449\u0435 \u0440\u0430\u0437 \u043F\u043E\u0434\u0438\u0432\u0456\u0442\u044C\u0441\u044F \u043D\u0430 \u043F\u0440\u0438\u043A\u043B\u0430\u0434\u0438. \u0414\u044F\u043A\u0443\u044E!",
          "Transpile_error": "\u041C\u0438 \u043D\u0435 \u043C\u043E\u0436\u0435\u043C\u043E \u0437\u0430\u043F\u0443\u0441\u0442\u0438\u0442\u0438 \u0432\u0430\u0448\u0443 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0443.",
          "Transpile_success": "\u0413\u0430\u0440\u043D\u0430 \u0440\u043E\u0431\u043E\u0442\u0430!\n\u0414\u0438\u0432\u043E\u0432\u0438\u0436\u043D\u043E!\n\u0427\u0443\u0434\u043E\u0432\u0430 \u0440\u043E\u0431\u043E\u0442\u0430!\n\u0427\u0443\u0434\u043E\u0432\u043E!\n\u0412\u0438 \u0447\u0443\u0434\u043E\u0432\u043E \u0432\u043F\u043E\u0440\u0430\u043B\u0438\u0441\u044F!",
          "Transpile_warning": "\u041F\u043E\u043F\u0435\u0440\u0435\u0434\u0436\u0435\u043D\u043D\u044F!",
          "Unsaved_Changes": "\u0412\u0438 \u043C\u0430\u0454\u0442\u0435 \u043D\u0435\u0437\u0431\u0435\u0440\u0435\u0436\u0435\u043D\u0443 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0443. \u0412\u0438 \u0445\u043E\u0447\u0435\u0442\u0435 \u0432\u0438\u0439\u0442\u0438, \u043D\u0435 \u0437\u0431\u0435\u0440\u0456\u0433\u0448\u0438 \u0457\u0457?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "\u0421\u043A\u043E\u043F\u0456\u044E\u0439\u0442\u0435 \u043F\u043E\u0441\u0438\u043B\u0430\u043D\u043D\u044F, \u0449\u043E\u0431 \u043F\u043E\u0434\u0456\u043B\u0438\u0442\u0438\u0441\u044F",
          "customization_deleted": "\u041D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F \u0443\u0441\u043F\u0456\u0448\u043D\u043E \u0432\u0438\u0434\u0430\u043B\u0435\u043D\u043E.",
          "dice": "\u{1F3B2}",
          "directly_available": "\u0411\u0435\u0437\u043F\u043E\u0441\u0435\u0440\u0435\u0434\u043D\u044C\u043E \u0432\u0456\u0434\u043A\u0440\u0438\u0442\u0438",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "\u0420\u0456\u0432\u0435\u043D\u044C",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "ur": {
          "CheckInternet": "Have a look if your Internet connection is working properly.",
          "Connection_error": "We couldn't reach the server.",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Something went wrong while running the program.",
          "Other_error": "Oops! Maybe we made a little mistake.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "We can't run your program.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "Warning!",
          "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "vi": {
          "CheckInternet": "H\xE3y xem k\u1EBFt n\u1ED1i Internet c\u1EE7a b\u1EA1n c\xF3 ho\u1EA1t \u0111\u1ED9ng b\xECnh th\u01B0\u1EDDng kh\xF4ng.",
          "Connection_error": "Ch\xFAng t\xF4i kh\xF4ng th\u1EC3 k\u1EBFt n\u1ED1i t\u1EDBi server.",
          "Empty_output": "Ch\u01B0\u01A1ng tr\xECnh n\xE0y ho\u1EA1t \u0111\u1ED9ng nh\u01B0ng kh\xF4ng in ra g\xEC c\u1EA3. Th\xEAm l\u1EC7nh in v\xE0o ch\u01B0\u01A1ng tr\xECnh ho\u1EB7c s\u1EED d\u1EE5ng con r\xF9a \u0111\u1EC3 c\xF3 \u0111\u1EA7u ra nh\xE9.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "\u0110\xE3 x\u1EA3y ra s\u1EF1 c\u1ED1 khi ch\u1EA1y ch\u01B0\u01A1ng tr\xECnh.",
          "Other_error": "R\u1EA5t ti\u1EBFc! C\xF3 l\u1EBD ch\xFAng t\xF4i \u0111\xE3 ph\u1EA1m m\u1ED9t sai l\u1EA7m nh\u1ECF.",
          "Program_repair": "\u0110\xE2y c\xF3 th\u1EC3 l\xE0 ch\u01B0\u01A1ng tr\xECnh ch\xEDnh x\xE1c, b\u1EA1n c\xF3 th\u1EC3 s\u1EEDa n\xF3 kh\xF4ng?",
          "Program_too_long": "Ch\u01B0\u01A1ng tr\xECnh c\u1EE7a b\u1EA1n t\u1ED1n qu\xE1 nhi\u1EC1u th\u1EDDi gian \u0111\u1EC3 ch\u1EA1y.",
          "ServerError": "B\u1EA1n \u0111\xE3 vi\u1EBFt m\u1ED9t ch\u01B0\u01A1ng tr\xECnh m\xE0 ch\xFAng t\xF4i kh\xF4ng mong \u0111\u1EE3i. N\u1EBFu b\u1EA1n mu\u1ED1n tr\u1EE3 gi\xFAp, h\xE3y g\u1EEDi email cho ch\xFAng t\xF4i v\u1EC1 c\u1EA5p \u0111\u1ED9 v\xE0 ch\u01B0\u01A1ng tr\xECnh c\u1EE7a b\u1EA1n t\u1EA1i hello@hedy.org. Trong th\u1EDDi gian ch\u1EDD \u0111\u1EE3i, h\xE3y th\u1EED l\xE0m g\xEC \u0111\xF3 kh\xE1c bi\u1EC7t m\u1ED9t ch\xFAt v\xE0 xem l\u1EA1i c\xE1c v\xED d\u1EE5. Xin c\u1EA3m \u01A1n!",
          "Transpile_error": "Ch\xFAng t\xF4i kh\xF4ng th\u1EC3 ch\u1EA1y ch\u01B0\u01A1ng tr\xECnh c\u1EE7a b\u1EA1n.",
          "Transpile_success": "L\xE0m t\u1ED1t l\u1EAFm!\nR\u1EA5t tuy\u1EC7t v\u1EDDi!\nT\u1ED1t l\u1EAFm!\nHay qu\xE1!\nB\u1EA1n l\xE0m r\u1EA5t t\u1ED1t!",
          "Transpile_warning": "C\u1EA3nh b\xE1o!",
          "Unsaved_Changes": "B\u1EA1n c\xF3 m\u1ED9t ch\u01B0\u01A1ng tr\xECnh ch\u01B0a \u0111\u01B0\u1EE3c l\u01B0u. B\u1EA1n c\xF3 mu\u1ED1n tho\xE1t m\xE0 kh\xF4ng l\u01B0u n\xF3 kh\xF4ng?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F528},\u{1F4DC}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "zh_Hans": {
          "CheckInternet": "\u67E5\u770B\u4E00\u4E0B\u4F60\u7684\u7F51\u7EDC\u8FDE\u63A5\u662F\u5426\u6B63\u5E38.",
          "Connection_error": "\u6211\u4EEC\u65E0\u6CD5\u8FDE\u63A5\u5230\u670D\u52A1\u5668\u3002",
          "Empty_output": "\u8FD9\u6BB5\u4EE3\u7801\u53EF\u4EE5\u5DE5\u4F5C\uFF0C\u4F46\u6CA1\u6709\u6253\u5370\u4EFB\u4F55\u4E1C\u897F\u3002\u5728\u4F60\u7684\u4EE3\u7801\u4E2D\u6DFB\u52A0\u4E00\u4E2A\u6253\u5370\u547D\u4EE4\uFF0C\u6216\u8005\u4F7F\u7528\u4E4C\u9F9F\u6765\u83B7\u5F97\u8F93\u51FA\u3002",
          "Errors_found": "\u4F60\u641E\u9519\u4E86\uFF01\u4E0D\u8981\u7740\u6025\uFF0C\u6211\u4EEC\u4ECD\u7136\u8FD0\u884C\u8BE5\u7A0B\u5E8F",
          "Execute_error": "\u5728\u8FD0\u884C\u7A0B\u5E8F\u65F6\u51FA\u4E86\u70B9\u95EE\u9898\u3002",
          "Other_error": "\u7CDF\u7CD5\uFF01 \u4E5F\u8BB8\u6211\u4EEC\u72AF\u4E86\u4E00\u4E2A\u5C0F\u9519\u8BEF\u3002",
          "Program_repair": "\u8FD9\u53EF\u80FD\u662F\u6B63\u786E\u7684\u4EE3\u7801\uFF0C\u4F60\u80FD\u4FEE\u590D\u5B83\u5417\uFF1F",
          "Program_too_long": "\u4F60\u7684\u7A0B\u5E8F\u8FD0\u884C\u7684\u65F6\u95F4\u592A\u957F\u4E86\u3002",
          "ServerError": "\u4F60\u5199\u4E86\u4E00\u4E2A\u51FA\u4E4E\u6211\u4EEC\u610F\u6599\u7684\u7A0B\u5E8F\u3002\u5982\u679C\u60A8\u60F3\u63D0\u4F9B\u5E2E\u52A9\uFF0C\u8BF7\u901A\u8FC7 hello@hedy.org \u5411\u6211\u4EEC\u53D1\u9001\u4E00\u5C01\u7535\u5B50\u90AE\u4EF6\uFF0C\u5176\u4E2D\u5305\u542B\u7EA7\u522B\u548C\u60A8\u7684\u7A0B\u5E8F\u3002\u4E0E\u6B64\u540C\u65F6\uFF0C\u5C1D\u8BD5\u4E00\u4E9B\u4E0D\u540C\u7684\u4E1C\u897F\uFF0C\u518D\u770B\u770B\u8FD9\u4E9B\u4F8B\u5B50\u3002\u8C22\u8C22\uFF01",
          "Transpile_error": "\u6211\u4EEC\u65E0\u6CD5\u8FD0\u884C\u4F60\u7684\u7A0B\u5E8F\u3002",
          "Transpile_success": "\u597D\u6837\u7684\uFF01\n\u4E86\u4E0D\u8D77\uFF01\n\u505A\u7684\u5F88\u597D\uFF01\n\u68D2\u6781\u4E86\uFF01\n\u505A\u7684\u771F\u68D2\uFF01",
          "Transpile_warning": "\u8B66\u544A\uFF01",
          "Unsaved_Changes": "\u4F60\u6709\u4E00\u4E2A\u672A\u4FDD\u5B58\u7684\u7A0B\u5E8F\u3002\u4F60\u60F3\u4E0D\u4FDD\u5B58\u5C31\u79BB\u5F00\u5417\uFF1F",
          "adventures_restored": "\u9ED8\u8BA4\u7684\u5192\u9669\u5DF2\u7ECF\u6062\u590D\uFF01",
          "copy_link_to_share": "\u590D\u5236\u94FE\u63A5\u4EE5\u5206\u4EAB",
          "customization_deleted": "\u5DF2\u6210\u529F\u5220\u9664\u81EA\u5B9A\u4E49\u9879\u3002",
          "dice": "\u{1F3B2}",
          "directly_available": "\u76F4\u63A5\u6253\u5F00",
          "disabled": "\u7981\u7528\u7684",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "\u7EA7\u522B",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        },
        "zh_Hant": {
          "CheckInternet": "Have a look if your Internet connection is working properly.",
          "Connection_error": "We couldn't reach the server.",
          "Empty_output": "This code works but does not print anything. Add a print command to your code or use the turtle to get output.",
          "Errors_found": "You made a mistake! Don't worry, Hedy is trying to find the mistakes",
          "Execute_error": "Something went wrong while running the program.",
          "Other_error": "Oops! Maybe we made a little mistake.",
          "Program_repair": "This could be the correct code, can you fix it?",
          "Program_too_long": "Your program takes too long to run.",
          "ServerError": "You wrote a program we weren't expecting. If you want to help, send us an email with the level and your program at hello@hedy.org. In the meantime, try something a little different and take another look at the examples. Thanks!",
          "Transpile_error": "We can't run your program.",
          "Transpile_success": "Good job!\nAmazing!\nWell done!\nExcellent!\nYou did great!",
          "Transpile_warning": "Warning!",
          "Unsaved_Changes": "You have an unsaved program. Do you want to leave without saving it?",
          "adventures_restored": "The default adventures have been restored!",
          "copy_link_to_share": "Copy link to share",
          "customization_deleted": "Customizations successfully deleted.",
          "dice": "\u{1F3B2}",
          "directly_available": "Directly open",
          "disabled": "Disabled",
          "fortune": "\u{1F52E}, \u2728",
          "haunted": "\u{1F987}, \u{1F47B}, \u{1F383}",
          "level_title": "Level",
          "restaurant": "\u{1F363}, \u{1F355}, \u{1F354}",
          "rock": "\u2702\uFE0F, \u{1F4DC}, \u{1F5FB}",
          "songs": "\u{1F3B5},\u{1F3B6}",
          "teacher_welcome": "Welcome to Hedy! Your are now the proud owner of a teachers account which allows you to create classes and invite students.",
          "turtle": "\u{1F422}",
          "unsaved_class_changes": "There are unsaved changes, are you sure you want to leave this page?"
        }
      };
    }
  });

  // __tmp__/static/js/client-messages.js
  var require_client_messages = __commonJS({
    "__tmp__/static/js/client-messages.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.setClientMessageLanguage = exports.ClientMessages = void 0;
      var message_translations_1 = require_message_translations();
      exports.ClientMessages = Object.assign({}, message_translations_1.TRANSLATIONS["en"]);
      function setClientMessageLanguage(key) {
        var _a2;
        Object.assign(exports.ClientMessages, (_a2 = message_translations_1.TRANSLATIONS[key]) !== null && _a2 !== void 0 ? _a2 : message_translations_1.TRANSLATIONS["en"]);
      }
      exports.setClientMessageLanguage = setClientMessageLanguage;
    }
  });

  // __tmp__/static/js/modal.js
  var require_modal = __commonJS({
    "__tmp__/static/js/modal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.tryCatchPopup = exports.modal = exports.error = exports.success = void 0;
      var Modal = class {
        constructor() {
          $("#modal-confirm-button").on("click", () => this.hide());
          $("#modal-no-button").on("click", () => this.hide());
          $("#modal-cancel-button").on("click", () => this.hide());
          $("#modal-copy-ok-button").on("click", () => this.hide());
          $("#modal-copy-close-button").on("click", () => this.hide());
          $("#modal-repair-button").on("click", () => this.hide());
          $("#modal-preview-button").on("click", () => this.hide());
          $("#modal-alert-button").on("click", () => this.hide_alert());
        }
        show() {
          $("#modal-mask").show();
          $("#modal-content").show();
          window.scrollTo(0, 0);
        }
        hide() {
          $("#modal-mask").hide();
          $("#modal-content").hide();
          $("#modal-prompt").hide();
          $("#modal-confirm").hide();
          $("#modal-copy").hide();
          $("#modal-repair").hide();
          $("#modal-preview").hide();
        }
        hide_alert() {
          $("#modal-alert").fadeOut(500);
        }
        notifySuccess(message, timeoutMs = 3e3) {
          return this.alert(message, timeoutMs);
        }
        notifyError(message, timeoutMs = 5e3) {
          return this.alert(message, timeoutMs, true);
        }
        alert(message, timeoutMs, error) {
          $("#modal_alert_container").toggleClass("bg-red-100 border-red-400 text-red-700", !!error);
          $("#modal_alert_container").toggleClass("bg-green-100 border-green-400 text-green-700", !error);
          $("#modal-alert-button").toggleClass("text-red-500", !!error);
          $("#modal-alert-button").toggleClass("text-green-500", !error);
          $("#modal_alert_text").html(message);
          $("#modal-alert").fadeIn(500);
          if (this._alert_timeout) {
            clearTimeout(this._alert_timeout);
            this._alert_timeout = void 0;
          }
          if (timeoutMs)
            this._alert_timeout = setTimeout(() => this.hide_alert(), timeoutMs);
        }
        copy_alert(message, timeoutMs, title = "") {
          this.hide();
          if (title != "") {
            $("#modal-copy-title").html(title);
            $("#modal-copy-title").removeClass("hidden");
          } else {
            $("#modal-copy-title").html("");
            $("#modal-copy-title").addClass("hidden");
          }
          $("#modal-copy-text").html(message);
          this.show();
          $("#modal-copy").show();
          if (this._timeout) {
            clearTimeout(this._timeout);
            this._timeout = void 0;
          }
          if (timeoutMs)
            this._timeout = setTimeout(() => this.hide(), timeoutMs);
        }
        preview(content, title) {
          this.hide();
          $("#modal-preview-title").html(title);
          const target = $("#modal-preview-content");
          content.attr("id", "modal-preview-content");
          target.replaceWith(content);
          this.show();
          $("#modal-preview").show();
          if (this._timeout) {
            clearTimeout(this._timeout);
            this._timeout = void 0;
          }
        }
        repair(message, timeoutMs, title = "") {
          this.hide();
          if (title != "") {
            $("#modal-repair-title").html(title);
            $("#modal-repair-title").removeClass("hidden");
          } else {
            $("#modal-repair-title").html("");
            $("#modal-repair-title").addClass("hidden");
          }
          $("#modal-repair-text").html(message);
          this.show();
          $("#modal-repair").show();
          if (timeoutMs)
            setTimeout(() => this.hide(), timeoutMs);
          if (this._timeout) {
            clearTimeout(this._timeout);
            this._timeout = void 0;
          }
          if (timeoutMs)
            this._timeout = setTimeout(() => this.hide(), timeoutMs);
        }
        confirmP(message) {
          return new Promise((ok) => this.confirm(message, ok));
        }
        confirm(message, confirmCb, declineCb = function() {
        }) {
          this.hide();
          $("#modal-confirm-text").text(message);
          this.show();
          $("#modal-confirm").show();
          if (this._timeout) {
            clearTimeout(this._timeout);
            this._timeout = void 0;
          }
          $("#modal-yes-button").off("click").on("click", () => {
            this.hide();
            confirmCb();
          });
          $("#modal-no-button").off("click").on("click", () => {
            this.hide();
            declineCb();
          });
        }
        prompt(message, defaultValue, confirmCb) {
          this.hide();
          $("#modal-prompt-text").text(message);
          this.show();
          $("#modal-prompt").show();
          if (defaultValue)
            $("#modal-prompt-input").val(defaultValue);
          if (this._timeout) {
            clearTimeout(this._timeout);
            this._timeout = void 0;
          }
          $("#modal-ok-button").off("click").on("click", () => {
            this.hide();
            const value = $("#modal-prompt-input").val();
            if (typeof value === "string") {
              $("#modal-prompt-input").val("");
              confirmCb(value);
            }
          });
        }
      };
      exports.success = {
        hide: function() {
          $("#okbox").hide();
        },
        showWarning(caption, message) {
          $("#okbox .caption").text(caption);
          $("#okbox .details").text(message);
          $("#okbox").show();
        },
        show(caption) {
          $("#okbox .caption").text(caption);
          $("#okbox").show();
          setTimeout(function() {
            $("#okbox").hide();
          }, 3e3);
        }
      };
      exports.error = {
        hide() {
          $("#errorbox").hide();
          $("#warningbox").hide();
        },
        showWarning(caption, message) {
          this.hide();
          $("#warningbox .caption").text(caption);
          $("#warningbox .details").text(message);
          $("#warningbox").show();
        },
        show(caption, message) {
          $("#errorbox .caption").text(caption);
          $("#errorbox .details").html(message);
          $("#errorbox").show();
        },
        showFadingWarning(caption, message) {
          exports.error.showWarning(caption, message);
          setTimeout(function() {
            $("#warningbox").fadeOut();
          }, 1e4);
        }
      };
      exports.modal = new Modal();
      async function tryCatchPopup(cb2) {
        try {
          return await cb2();
        } catch (e) {
          console.log("Error", e);
          exports.modal.notifyError(e.message);
        }
      }
      exports.tryCatchPopup = tryCatchPopup;
    }
  });

  // node_modules/jszip/dist/jszip.min.js
  var require_jszip_min = __commonJS({
    "node_modules/jszip/dist/jszip.min.js"(exports, module) {
      !function(e) {
        if (typeof exports == "object" && typeof module != "undefined")
          module.exports = e();
        else if (typeof define == "function" && define.amd)
          define([], e);
        else {
          (typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this).JSZip = e();
        }
      }(function() {
        return function s(a, o, h2) {
          function u(r, e2) {
            if (!o[r]) {
              if (!a[r]) {
                var t = typeof __require == "function" && __require;
                if (!e2 && t)
                  return t(r, true);
                if (l)
                  return l(r, true);
                var n = new Error("Cannot find module '" + r + "'");
                throw n.code = "MODULE_NOT_FOUND", n;
              }
              var i = o[r] = { exports: {} };
              a[r][0].call(i.exports, function(e3) {
                var t2 = a[r][1][e3];
                return u(t2 || e3);
              }, i, i.exports, s, a, o, h2);
            }
            return o[r].exports;
          }
          for (var l = typeof __require == "function" && __require, e = 0; e < h2.length; e++)
            u(h2[e]);
          return u;
        }({ 1: [function(e, t, r) {
          "use strict";
          var d2 = e("./utils"), c2 = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          r.encode = function(e2) {
            for (var t2, r2, n, i, s, a, o, h2 = [], u = 0, l = e2.length, f = l, c3 = d2.getTypeOf(e2) !== "string"; u < e2.length; )
              f = l - u, n = c3 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h2.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
            return h2.join("");
          }, r.decode = function(e2) {
            var t2, r2, n, i, s, a, o = 0, h2 = 0, u = "data:";
            if (e2.substr(0, u.length) === u)
              throw new Error("Invalid base64 input, it looks like a data url.");
            var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
            if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
              throw new Error("Invalid base64 input, bad content length.");
            for (l = c2.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
              t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h2++] = t2, s !== 64 && (l[h2++] = r2), a !== 64 && (l[h2++] = n);
            return l;
          };
        }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
          "use strict";
          var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
          function o(e2, t2, r2, n2, i2) {
            this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
          }
          o.prototype = { getContentWorker: function() {
            var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
            return e2.on("end", function() {
              if (this.streamInfo.data_length !== t2.uncompressedSize)
                throw new Error("Bug : uncompressed data size mismatch");
            }), e2;
          }, getCompressedWorker: function() {
            return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
          } }, o.createWorkerFrom = function(e2, t2, r2) {
            return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
          }, t.exports = o;
        }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
          "use strict";
          var n = e("./stream/GenericWorker");
          r.STORE = { magic: "\0\0", compressWorker: function() {
            return new n("STORE compression");
          }, uncompressWorker: function() {
            return new n("STORE decompression");
          } }, r.DEFLATE = e("./flate");
        }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
          "use strict";
          var n = e("./utils");
          var o = function() {
            for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
              e2 = r2;
              for (var n2 = 0; n2 < 8; n2++)
                e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
              t2[r2] = e2;
            }
            return t2;
          }();
          t.exports = function(e2, t2) {
            return e2 !== void 0 && e2.length ? n.getTypeOf(e2) !== "string" ? function(e3, t3, r2, n2) {
              var i = o, s = n2 + r2;
              e3 ^= -1;
              for (var a = n2; a < s; a++)
                e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
              return -1 ^ e3;
            }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n2) {
              var i = o, s = n2 + r2;
              e3 ^= -1;
              for (var a = n2; a < s; a++)
                e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
              return -1 ^ e3;
            }(0 | t2, e2, e2.length, 0) : 0;
          };
        }, { "./utils": 32 }], 5: [function(e, t, r) {
          "use strict";
          r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
        }, {}], 6: [function(e, t, r) {
          "use strict";
          var n = null;
          n = typeof Promise != "undefined" ? Promise : e("lie"), t.exports = { Promise: n };
        }, { lie: 37 }], 7: [function(e, t, r) {
          "use strict";
          var n = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Uint32Array != "undefined", i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
          function h2(e2, t2) {
            a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
          }
          r.magic = "\b\0", s.inherits(h2, a), h2.prototype.processChunk = function(e2) {
            this.meta = e2.meta, this._pako === null && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
          }, h2.prototype.flush = function() {
            a.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], true);
          }, h2.prototype.cleanUp = function() {
            a.prototype.cleanUp.call(this), this._pako = null;
          }, h2.prototype._createPako = function() {
            this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
            var t2 = this;
            this._pako.onData = function(e2) {
              t2.push({ data: e2, meta: t2.meta });
            };
          }, r.compressWorker = function(e2) {
            return new h2("Deflate", e2);
          }, r.uncompressWorker = function() {
            return new h2("Inflate", {});
          };
        }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
          "use strict";
          function A(e2, t2) {
            var r2, n2 = "";
            for (r2 = 0; r2 < t2; r2++)
              n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
            return n2;
          }
          function n(e2, t2, r2, n2, i2, s2) {
            var a, o, h2 = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h2.name)), c2 = I.transformTo("string", O.utf8encode(h2.name)), d2 = h2.comment, p = I.transformTo("string", s2(d2)), m = I.transformTo("string", O.utf8encode(d2)), _ = c2.length !== h2.name.length, g = m.length !== d2.length, b = "", v = "", y2 = "", w = h2.dir, k = h2.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
            t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
            var S = 0;
            t2 && (S |= 8), l || !_ && !g || (S |= 2048);
            var z2 = 0, C = 0;
            w && (z2 |= 16), i2 === "UNIX" ? (C = 798, z2 |= function(e3, t3) {
              var r3 = e3;
              return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
            }(h2.unixPermissions, w)) : (C = 20, z2 |= function(e3) {
              return 63 & (e3 || 0);
            }(h2.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c2, b += "up" + A(v.length, 2) + v), g && (y2 = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y2.length, 2) + y2);
            var E = "";
            return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z2, 4) + A(n2, 4) + f + b + p };
          }
          var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
          function s(e2, t2, r2, n2) {
            i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
          }
          I.inherits(s, i), s.prototype.push = function(e2) {
            var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
            this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
          }, s.prototype.openedSource = function(e2) {
            this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
            var t2 = this.streamFiles && !e2.file.dir;
            if (t2) {
              var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
              this.push({ data: r2.fileRecord, meta: { percent: 0 } });
            } else
              this.accumulate = true;
          }, s.prototype.closedSource = function(e2) {
            this.accumulate = false;
            var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            if (this.dirRecords.push(r2.dirRecord), t2)
              this.push({ data: function(e3) {
                return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
              }(e2), meta: { percent: 100 } });
            else
              for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
                this.push(this.contentBuffer.shift());
            this.currentFile = null;
          }, s.prototype.flush = function() {
            for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++)
              this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
            var r2 = this.bytesWritten - e2, n2 = function(e3, t3, r3, n3, i2) {
              var s2 = I.transformTo("string", i2(n3));
              return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
            }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
            this.push({ data: n2, meta: { percent: 100 } });
          }, s.prototype.prepareNextSource = function() {
            this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
          }, s.prototype.registerPrevious = function(e2) {
            this._sources.push(e2);
            var t2 = this;
            return e2.on("data", function(e3) {
              t2.processChunk(e3);
            }), e2.on("end", function() {
              t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
            }), e2.on("error", function(e3) {
              t2.error(e3);
            }), this;
          }, s.prototype.resume = function() {
            return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
          }, s.prototype.error = function(e2) {
            var t2 = this._sources;
            if (!i.prototype.error.call(this, e2))
              return false;
            for (var r2 = 0; r2 < t2.length; r2++)
              try {
                t2[r2].error(e2);
              } catch (e3) {
              }
            return true;
          }, s.prototype.lock = function() {
            i.prototype.lock.call(this);
            for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++)
              e2[t2].lock();
          }, t.exports = s;
        }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
          "use strict";
          var u = e("../compressions"), n = e("./ZipFileWorker");
          r.generateWorker = function(e2, a, t2) {
            var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h2 = 0;
            try {
              e2.forEach(function(e3, t3) {
                h2++;
                var r2 = function(e4, t4) {
                  var r3 = e4 || t4, n3 = u[r3];
                  if (!n3)
                    throw new Error(r3 + " is not a valid compression method !");
                  return n3;
                }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
                t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
              }), o.entriesCount = h2;
            } catch (e3) {
              o.error(e3);
            }
            return o;
          };
        }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
          "use strict";
          function n() {
            if (!(this instanceof n))
              return new n();
            if (arguments.length)
              throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
            this.files = Object.create(null), this.comment = null, this.root = "", this.clone = function() {
              var e2 = new n();
              for (var t2 in this)
                typeof this[t2] != "function" && (e2[t2] = this[t2]);
              return e2;
            };
          }
          (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
            return new n().loadAsync(e2, t2);
          }, n.external = e("./external"), t.exports = n;
        }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
          "use strict";
          var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
          function f(n2) {
            return new i.Promise(function(e2, t2) {
              var r2 = n2.decompressed.getContentWorker().pipe(new a());
              r2.on("error", function(e3) {
                t2(e3);
              }).on("end", function() {
                r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
              }).resume();
            });
          }
          t.exports = function(e2, o) {
            var h2 = this;
            return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
              var t2 = new s(o);
              return t2.load(e3), t2;
            }).then(function(e3) {
              var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
              if (o.checkCRC32)
                for (var n2 = 0; n2 < r2.length; n2++)
                  t2.push(f(r2[n2]));
              return i.Promise.all(t2);
            }).then(function(e3) {
              for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
                var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
                h2.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h2.file(a2).unsafeOriginalName = s2);
              }
              return t2.zipComment.length && (h2.comment = t2.zipComment), h2;
            });
          };
        }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
          "use strict";
          var n = e("../utils"), i = e("../stream/GenericWorker");
          function s(e2, t2) {
            i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
          }
          n.inherits(s, i), s.prototype._bindStream = function(e2) {
            var t2 = this;
            (this._stream = e2).pause(), e2.on("data", function(e3) {
              t2.push({ data: e3, meta: { percent: 0 } });
            }).on("error", function(e3) {
              t2.isPaused ? this.generatedError = e3 : t2.error(e3);
            }).on("end", function() {
              t2.isPaused ? t2._upstreamEnded = true : t2.end();
            });
          }, s.prototype.pause = function() {
            return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
          }, s.prototype.resume = function() {
            return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
          }, t.exports = s;
        }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
          "use strict";
          var i = e("readable-stream").Readable;
          function n(e2, t2, r2) {
            i.call(this, t2), this._helper = e2;
            var n2 = this;
            e2.on("data", function(e3, t3) {
              n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
            }).on("error", function(e3) {
              n2.emit("error", e3);
            }).on("end", function() {
              n2.push(null);
            });
          }
          e("../utils").inherits(n, i), n.prototype._read = function() {
            this._helper.resume();
          }, t.exports = n;
        }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
          "use strict";
          t.exports = { isNode: typeof Buffer != "undefined", newBufferFrom: function(e2, t2) {
            if (Buffer.from && Buffer.from !== Uint8Array.from)
              return Buffer.from(e2, t2);
            if (typeof e2 == "number")
              throw new Error('The "data" argument must not be a number');
            return new Buffer(e2, t2);
          }, allocBuffer: function(e2) {
            if (Buffer.alloc)
              return Buffer.alloc(e2);
            var t2 = new Buffer(e2);
            return t2.fill(0), t2;
          }, isBuffer: function(e2) {
            return Buffer.isBuffer(e2);
          }, isStream: function(e2) {
            return e2 && typeof e2.on == "function" && typeof e2.pause == "function" && typeof e2.resume == "function";
          } };
        }, {}], 15: [function(e, t, r) {
          "use strict";
          function s(e2, t2, r2) {
            var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
            s2.date = s2.date || new Date(), s2.compression !== null && (s2.compression = s2.compression.toUpperCase()), typeof s2.unixPermissions == "string" && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
            var a2 = i2 === "string" && s2.binary === false && s2.base64 === false;
            r2 && r2.binary !== void 0 || (s2.binary = !a2), (t2 instanceof c2 && t2.uncompressedSize === 0 || s2.dir || !t2 || t2.length === 0) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
            var o2 = null;
            o2 = t2 instanceof c2 || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
            var h3 = new d2(e2, o2, s2);
            this.files[e2] = h3;
          }
          var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c2 = e("./compressedObject"), d2 = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
            e2.slice(-1) === "/" && (e2 = e2.substring(0, e2.length - 1));
            var t2 = e2.lastIndexOf("/");
            return 0 < t2 ? e2.substring(0, t2) : "";
          }, g = function(e2) {
            return e2.slice(-1) !== "/" && (e2 += "/"), e2;
          }, b = function(e2, t2) {
            return t2 = t2 !== void 0 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
          };
          function h2(e2) {
            return Object.prototype.toString.call(e2) === "[object RegExp]";
          }
          var n = { load: function() {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          }, forEach: function(e2) {
            var t2, r2, n2;
            for (t2 in this.files)
              n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
          }, filter: function(r2) {
            var n2 = [];
            return this.forEach(function(e2, t2) {
              r2(e2, t2) && n2.push(t2);
            }), n2;
          }, file: function(e2, t2, r2) {
            if (arguments.length !== 1)
              return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
            if (h2(e2)) {
              var n2 = e2;
              return this.filter(function(e3, t3) {
                return !t3.dir && n2.test(e3);
              });
            }
            var i2 = this.files[this.root + e2];
            return i2 && !i2.dir ? i2 : null;
          }, folder: function(r2) {
            if (!r2)
              return this;
            if (h2(r2))
              return this.filter(function(e3, t3) {
                return t3.dir && r2.test(e3);
              });
            var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
            return n2.root = t2.name, n2;
          }, remove: function(r2) {
            r2 = this.root + r2;
            var e2 = this.files[r2];
            if (e2 || (r2.slice(-1) !== "/" && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
              delete this.files[r2];
            else
              for (var t2 = this.filter(function(e3, t3) {
                return t3.name.slice(0, r2.length) === r2;
              }), n2 = 0; n2 < t2.length; n2++)
                delete this.files[t2[n2].name];
            return this;
          }, generate: function() {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          }, generateInternalStream: function(e2) {
            var t2, r2 = {};
            try {
              if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), r2.type === "binarystring" && (r2.type = "string"), !r2.type)
                throw new Error("No output type specified.");
              u.checkSupport(r2.type), r2.platform !== "darwin" && r2.platform !== "freebsd" && r2.platform !== "linux" && r2.platform !== "sunos" || (r2.platform = "UNIX"), r2.platform === "win32" && (r2.platform = "DOS");
              var n2 = r2.comment || this.comment || "";
              t2 = o.generateWorker(this, r2, n2);
            } catch (e3) {
              (t2 = new l("error")).error(e3);
            }
            return new a(t2, r2.type || "string", r2.mimeType);
          }, generateAsync: function(e2, t2) {
            return this.generateInternalStream(e2).accumulate(t2);
          }, generateNodeStream: function(e2, t2) {
            return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
          } };
          t.exports = n;
        }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
          "use strict";
          t.exports = e("stream");
        }, { stream: void 0 }], 17: [function(e, t, r) {
          "use strict";
          var n = e("./DataReader");
          function i(e2) {
            n.call(this, e2);
            for (var t2 = 0; t2 < this.data.length; t2++)
              e2[t2] = 255 & e2[t2];
          }
          e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
            return this.data[this.zero + e2];
          }, i.prototype.lastIndexOfSignature = function(e2) {
            for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
              if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
                return s - this.zero;
            return -1;
          }, i.prototype.readAndCheckSignature = function(e2) {
            var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
            return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
          }, i.prototype.readData = function(e2) {
            if (this.checkOffset(e2), e2 === 0)
              return [];
            var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
            return this.index += e2, t2;
          }, t.exports = i;
        }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
          "use strict";
          var n = e("../utils");
          function i(e2) {
            this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
          }
          i.prototype = { checkOffset: function(e2) {
            this.checkIndex(this.index + e2);
          }, checkIndex: function(e2) {
            if (this.length < this.zero + e2 || e2 < 0)
              throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
          }, setIndex: function(e2) {
            this.checkIndex(e2), this.index = e2;
          }, skip: function(e2) {
            this.setIndex(this.index + e2);
          }, byteAt: function() {
          }, readInt: function(e2) {
            var t2, r2 = 0;
            for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--)
              r2 = (r2 << 8) + this.byteAt(t2);
            return this.index += e2, r2;
          }, readString: function(e2) {
            return n.transformTo("string", this.readData(e2));
          }, readData: function() {
          }, lastIndexOfSignature: function() {
          }, readAndCheckSignature: function() {
          }, readDate: function() {
            var e2 = this.readInt(4);
            return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
          } }, t.exports = i;
        }, { "../utils": 32 }], 19: [function(e, t, r) {
          "use strict";
          var n = e("./Uint8ArrayReader");
          function i(e2) {
            n.call(this, e2);
          }
          e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
            this.checkOffset(e2);
            var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
            return this.index += e2, t2;
          }, t.exports = i;
        }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
          "use strict";
          var n = e("./DataReader");
          function i(e2) {
            n.call(this, e2);
          }
          e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
            return this.data.charCodeAt(this.zero + e2);
          }, i.prototype.lastIndexOfSignature = function(e2) {
            return this.data.lastIndexOf(e2) - this.zero;
          }, i.prototype.readAndCheckSignature = function(e2) {
            return e2 === this.readData(4);
          }, i.prototype.readData = function(e2) {
            this.checkOffset(e2);
            var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
            return this.index += e2, t2;
          }, t.exports = i;
        }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
          "use strict";
          var n = e("./ArrayReader");
          function i(e2) {
            n.call(this, e2);
          }
          e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
            if (this.checkOffset(e2), e2 === 0)
              return new Uint8Array(0);
            var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
            return this.index += e2, t2;
          }, t.exports = i;
        }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
          "use strict";
          var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h2 = e("./Uint8ArrayReader");
          t.exports = function(e2) {
            var t2 = n.getTypeOf(e2);
            return n.checkSupport(t2), t2 !== "string" || i.uint8array ? t2 === "nodebuffer" ? new o(e2) : i.uint8array ? new h2(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
          };
        }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
          "use strict";
          r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
        }, {}], 24: [function(e, t, r) {
          "use strict";
          var n = e("./GenericWorker"), i = e("../utils");
          function s(e2) {
            n.call(this, "ConvertWorker to " + e2), this.destType = e2;
          }
          i.inherits(s, n), s.prototype.processChunk = function(e2) {
            this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
          }, t.exports = s;
        }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
          "use strict";
          var n = e("./GenericWorker"), i = e("../crc32");
          function s() {
            n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
          }
          e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
            this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
          }, t.exports = s;
        }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
          "use strict";
          var n = e("../utils"), i = e("./GenericWorker");
          function s(e2) {
            i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
          }
          n.inherits(s, i), s.prototype.processChunk = function(e2) {
            if (e2) {
              var t2 = this.streamInfo[this.propName] || 0;
              this.streamInfo[this.propName] = t2 + e2.data.length;
            }
            i.prototype.processChunk.call(this, e2);
          }, t.exports = s;
        }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
          "use strict";
          var n = e("../utils"), i = e("./GenericWorker");
          function s(e2) {
            i.call(this, "DataWorker");
            var t2 = this;
            this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
              t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
            }, function(e3) {
              t2.error(e3);
            });
          }
          n.inherits(s, i), s.prototype.cleanUp = function() {
            i.prototype.cleanUp.call(this), this.data = null;
          }, s.prototype.resume = function() {
            return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
          }, s.prototype._tickAndRepeat = function() {
            this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
          }, s.prototype._tick = function() {
            if (this.isPaused || this.isFinished)
              return false;
            var e2 = null, t2 = Math.min(this.max, this.index + 16384);
            if (this.index >= this.max)
              return this.end();
            switch (this.type) {
              case "string":
                e2 = this.data.substring(this.index, t2);
                break;
              case "uint8array":
                e2 = this.data.subarray(this.index, t2);
                break;
              case "array":
              case "nodebuffer":
                e2 = this.data.slice(this.index, t2);
            }
            return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
          }, t.exports = s;
        }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
          "use strict";
          function n(e2) {
            this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
          }
          n.prototype = { push: function(e2) {
            this.emit("data", e2);
          }, end: function() {
            if (this.isFinished)
              return false;
            this.flush();
            try {
              this.emit("end"), this.cleanUp(), this.isFinished = true;
            } catch (e2) {
              this.emit("error", e2);
            }
            return true;
          }, error: function(e2) {
            return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
          }, on: function(e2, t2) {
            return this._listeners[e2].push(t2), this;
          }, cleanUp: function() {
            this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
          }, emit: function(e2, t2) {
            if (this._listeners[e2])
              for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
                this._listeners[e2][r2].call(this, t2);
          }, pipe: function(e2) {
            return e2.registerPrevious(this);
          }, registerPrevious: function(e2) {
            if (this.isLocked)
              throw new Error("The stream '" + this + "' has already been used.");
            this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
            var t2 = this;
            return e2.on("data", function(e3) {
              t2.processChunk(e3);
            }), e2.on("end", function() {
              t2.end();
            }), e2.on("error", function(e3) {
              t2.error(e3);
            }), this;
          }, pause: function() {
            return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
          }, resume: function() {
            if (!this.isPaused || this.isFinished)
              return false;
            var e2 = this.isPaused = false;
            return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
          }, flush: function() {
          }, processChunk: function(e2) {
            this.push(e2);
          }, withStreamInfo: function(e2, t2) {
            return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
          }, mergeStreamInfo: function() {
            for (var e2 in this.extraStreamInfo)
              Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
          }, lock: function() {
            if (this.isLocked)
              throw new Error("The stream '" + this + "' has already been used.");
            this.isLocked = true, this.previous && this.previous.lock();
          }, toString: function() {
            var e2 = "Worker " + this.name;
            return this.previous ? this.previous + " -> " + e2 : e2;
          } }, t.exports = n;
        }, {}], 29: [function(e, t, r) {
          "use strict";
          var h2 = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
          if (n.nodestream)
            try {
              o = e("../nodejs/NodejsStreamOutputAdapter");
            } catch (e2) {
            }
          function l(e2, o2) {
            return new a.Promise(function(t2, r2) {
              var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
              e2.on("data", function(e3, t3) {
                n2.push(e3), o2 && o2(t3);
              }).on("error", function(e3) {
                n2 = [], r2(e3);
              }).on("end", function() {
                try {
                  var e3 = function(e4, t3, r3) {
                    switch (e4) {
                      case "blob":
                        return h2.newBlob(h2.transformTo("arraybuffer", t3), r3);
                      case "base64":
                        return u.encode(t3);
                      default:
                        return h2.transformTo(e4, t3);
                    }
                  }(s2, function(e4, t3) {
                    var r3, n3 = 0, i3 = null, s3 = 0;
                    for (r3 = 0; r3 < t3.length; r3++)
                      s3 += t3[r3].length;
                    switch (e4) {
                      case "string":
                        return t3.join("");
                      case "array":
                        return Array.prototype.concat.apply([], t3);
                      case "uint8array":
                        for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++)
                          i3.set(t3[r3], n3), n3 += t3[r3].length;
                        return i3;
                      case "nodebuffer":
                        return Buffer.concat(t3);
                      default:
                        throw new Error("concat : unsupported type '" + e4 + "'");
                    }
                  }(i2, n2), a2);
                  t2(e3);
                } catch (e4) {
                  r2(e4);
                }
                n2 = [];
              }).resume();
            });
          }
          function f(e2, t2, r2) {
            var n2 = t2;
            switch (t2) {
              case "blob":
              case "arraybuffer":
                n2 = "uint8array";
                break;
              case "base64":
                n2 = "string";
            }
            try {
              this._internalType = n2, this._outputType = t2, this._mimeType = r2, h2.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
            } catch (e3) {
              this._worker = new s("error"), this._worker.error(e3);
            }
          }
          f.prototype = { accumulate: function(e2) {
            return l(this, e2);
          }, on: function(e2, t2) {
            var r2 = this;
            return e2 === "data" ? this._worker.on(e2, function(e3) {
              t2.call(r2, e3.data, e3.meta);
            }) : this._worker.on(e2, function() {
              h2.delay(t2, arguments, r2);
            }), this;
          }, resume: function() {
            return h2.delay(this._worker.resume, [], this._worker), this;
          }, pause: function() {
            return this._worker.pause(), this;
          }, toNodejsStream: function(e2) {
            if (h2.checkSupport("nodestream"), this._outputType !== "nodebuffer")
              throw new Error(this._outputType + " is not supported by this method");
            return new o(this, { objectMode: this._outputType !== "nodebuffer" }, e2);
          } }, t.exports = f;
        }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
          "use strict";
          if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = typeof ArrayBuffer != "undefined" && typeof Uint8Array != "undefined", r.nodebuffer = typeof Buffer != "undefined", r.uint8array = typeof Uint8Array != "undefined", typeof ArrayBuffer == "undefined")
            r.blob = false;
          else {
            var n = new ArrayBuffer(0);
            try {
              r.blob = new Blob([n], { type: "application/zip" }).size === 0;
            } catch (e2) {
              try {
                var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                i.append(n), r.blob = i.getBlob("application/zip").size === 0;
              } catch (e3) {
                r.blob = false;
              }
            }
          }
          try {
            r.nodestream = !!e("readable-stream").Readable;
          } catch (e2) {
            r.nodestream = false;
          }
        }, { "readable-stream": 16 }], 31: [function(e, t, s) {
          "use strict";
          for (var o = e("./utils"), h2 = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
            u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
          u[254] = u[254] = 1;
          function a() {
            n.call(this, "utf-8 decode"), this.leftOver = null;
          }
          function l() {
            n.call(this, "utf-8 encode");
          }
          s.utf8encode = function(e2) {
            return h2.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
              var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
              for (i2 = 0; i2 < a2; i2++)
                (64512 & (r2 = e3.charCodeAt(i2))) == 55296 && i2 + 1 < a2 && (64512 & (n2 = e3.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
              for (t2 = h2.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
                (64512 & (r2 = e3.charCodeAt(i2))) == 55296 && i2 + 1 < a2 && (64512 & (n2 = e3.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
              return t2;
            }(e2);
          }, s.utf8decode = function(e2) {
            return h2.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
              var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
              for (t2 = r2 = 0; t2 < s2; )
                if ((n2 = e3[t2++]) < 128)
                  a2[r2++] = n2;
                else if (4 < (i2 = u[n2]))
                  a2[r2++] = 65533, t2 += i2 - 1;
                else {
                  for (n2 &= i2 === 2 ? 31 : i2 === 3 ? 15 : 7; 1 < i2 && t2 < s2; )
                    n2 = n2 << 6 | 63 & e3[t2++], i2--;
                  1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
                }
              return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
            }(e2 = o.transformTo(h2.uint8array ? "uint8array" : "array", e2));
          }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
            var t2 = o.transformTo(h2.uint8array ? "uint8array" : "array", e2.data);
            if (this.leftOver && this.leftOver.length) {
              if (h2.uint8array) {
                var r2 = t2;
                (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
              } else
                t2 = this.leftOver.concat(t2);
              this.leftOver = null;
            }
            var n2 = function(e3, t3) {
              var r3;
              for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && (192 & e3[r3]) == 128; )
                r3--;
              return r3 < 0 ? t3 : r3 === 0 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
            }(t2), i2 = t2;
            n2 !== t2.length && (h2.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
          }, a.prototype.flush = function() {
            this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
          }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
            this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
          }, s.Utf8EncodeWorker = l;
        }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
          "use strict";
          var o = e("./support"), h2 = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
          function n(e2) {
            return e2;
          }
          function l(e2, t2) {
            for (var r2 = 0; r2 < e2.length; ++r2)
              t2[r2] = 255 & e2.charCodeAt(r2);
            return t2;
          }
          e("setimmediate"), a.newBlob = function(t2, r2) {
            a.checkSupport("blob");
            try {
              return new Blob([t2], { type: r2 });
            } catch (e2) {
              try {
                var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                return n2.append(t2), n2.getBlob(r2);
              } catch (e3) {
                throw new Error("Bug : can't construct the Blob.");
              }
            }
          };
          var i = { stringifyByChunk: function(e2, t2, r2) {
            var n2 = [], i2 = 0, s2 = e2.length;
            if (s2 <= r2)
              return String.fromCharCode.apply(null, e2);
            for (; i2 < s2; )
              t2 === "array" || t2 === "nodebuffer" ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
            return n2.join("");
          }, stringifyByChar: function(e2) {
            for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
              t2 += String.fromCharCode(e2[r2]);
            return t2;
          }, applyCanBeUsed: { uint8array: function() {
            try {
              return o.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch (e2) {
              return false;
            }
          }(), nodebuffer: function() {
            try {
              return o.nodebuffer && String.fromCharCode.apply(null, r.allocBuffer(1)).length === 1;
            } catch (e2) {
              return false;
            }
          }() } };
          function s(e2) {
            var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
            if (r2 === "uint8array" ? n2 = i.applyCanBeUsed.uint8array : r2 === "nodebuffer" && (n2 = i.applyCanBeUsed.nodebuffer), n2)
              for (; 1 < t2; )
                try {
                  return i.stringifyByChunk(e2, r2, t2);
                } catch (e3) {
                  t2 = Math.floor(t2 / 2);
                }
            return i.stringifyByChar(e2);
          }
          function f(e2, t2) {
            for (var r2 = 0; r2 < e2.length; r2++)
              t2[r2] = e2[r2];
            return t2;
          }
          a.applyFromCharCode = s;
          var c2 = {};
          c2.string = { string: n, array: function(e2) {
            return l(e2, new Array(e2.length));
          }, arraybuffer: function(e2) {
            return c2.string.uint8array(e2).buffer;
          }, uint8array: function(e2) {
            return l(e2, new Uint8Array(e2.length));
          }, nodebuffer: function(e2) {
            return l(e2, r.allocBuffer(e2.length));
          } }, c2.array = { string: s, array: n, arraybuffer: function(e2) {
            return new Uint8Array(e2).buffer;
          }, uint8array: function(e2) {
            return new Uint8Array(e2);
          }, nodebuffer: function(e2) {
            return r.newBufferFrom(e2);
          } }, c2.arraybuffer = { string: function(e2) {
            return s(new Uint8Array(e2));
          }, array: function(e2) {
            return f(new Uint8Array(e2), new Array(e2.byteLength));
          }, arraybuffer: n, uint8array: function(e2) {
            return new Uint8Array(e2);
          }, nodebuffer: function(e2) {
            return r.newBufferFrom(new Uint8Array(e2));
          } }, c2.uint8array = { string: s, array: function(e2) {
            return f(e2, new Array(e2.length));
          }, arraybuffer: function(e2) {
            return e2.buffer;
          }, uint8array: n, nodebuffer: function(e2) {
            return r.newBufferFrom(e2);
          } }, c2.nodebuffer = { string: s, array: function(e2) {
            return f(e2, new Array(e2.length));
          }, arraybuffer: function(e2) {
            return c2.nodebuffer.uint8array(e2).buffer;
          }, uint8array: function(e2) {
            return f(e2, new Uint8Array(e2.length));
          }, nodebuffer: n }, a.transformTo = function(e2, t2) {
            if (t2 = t2 || "", !e2)
              return t2;
            a.checkSupport(e2);
            var r2 = a.getTypeOf(t2);
            return c2[r2][e2](t2);
          }, a.resolve = function(e2) {
            for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
              var i2 = t2[n2];
              i2 === "." || i2 === "" && n2 !== 0 && n2 !== t2.length - 1 || (i2 === ".." ? r2.pop() : r2.push(i2));
            }
            return r2.join("/");
          }, a.getTypeOf = function(e2) {
            return typeof e2 == "string" ? "string" : Object.prototype.toString.call(e2) === "[object Array]" ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
          }, a.checkSupport = function(e2) {
            if (!o[e2.toLowerCase()])
              throw new Error(e2 + " is not supported by this platform");
          }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
            var t2, r2, n2 = "";
            for (r2 = 0; r2 < (e2 || "").length; r2++)
              n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
            return n2;
          }, a.delay = function(e2, t2, r2) {
            setImmediate(function() {
              e2.apply(r2 || null, t2 || []);
            });
          }, a.inherits = function(e2, t2) {
            function r2() {
            }
            r2.prototype = t2.prototype, e2.prototype = new r2();
          }, a.extend = function() {
            var e2, t2, r2 = {};
            for (e2 = 0; e2 < arguments.length; e2++)
              for (t2 in arguments[e2])
                Object.prototype.hasOwnProperty.call(arguments[e2], t2) && r2[t2] === void 0 && (r2[t2] = arguments[e2][t2]);
            return r2;
          }, a.prepareContent = function(r2, e2, n2, i2, s2) {
            return u.Promise.resolve(e2).then(function(n3) {
              return o.blob && (n3 instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3)) !== -1) && typeof FileReader != "undefined" ? new u.Promise(function(t2, r3) {
                var e3 = new FileReader();
                e3.onload = function(e4) {
                  t2(e4.target.result);
                }, e3.onerror = function(e4) {
                  r3(e4.target.error);
                }, e3.readAsArrayBuffer(n3);
              }) : n3;
            }).then(function(e3) {
              var t2 = a.getTypeOf(e3);
              return t2 ? (t2 === "arraybuffer" ? e3 = a.transformTo("uint8array", e3) : t2 === "string" && (s2 ? e3 = h2.decode(e3) : n2 && i2 !== true && (e3 = function(e4) {
                return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
              }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
            });
          };
        }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
          "use strict";
          var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
          function h2(e2) {
            this.files = [], this.loadOptions = e2;
          }
          h2.prototype = { checkSignature: function(e2) {
            if (!this.reader.readAndCheckSignature(e2)) {
              this.reader.index -= 4;
              var t2 = this.reader.readString(4);
              throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
            }
          }, isSignature: function(e2, t2) {
            var r2 = this.reader.index;
            this.reader.setIndex(e2);
            var n2 = this.reader.readString(4) === t2;
            return this.reader.setIndex(r2), n2;
          }, readBlockEndOfCentral: function() {
            this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
            var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
            this.zipComment = this.loadOptions.decodeFileName(r2);
          }, readBlockZip64EndOfCentral: function() {
            this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
            for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
              e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
          }, readBlockZip64EndOfCentralLocator: function() {
            if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
              throw new Error("Multi-volumes zip are not supported");
          }, readLocalFiles: function() {
            var e2, t2;
            for (e2 = 0; e2 < this.files.length; e2++)
              t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
          }, readCentralDir: function() {
            var e2;
            for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
              (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
            if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
              throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
          }, readEndOfCentral: function() {
            var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
            if (e2 < 0)
              throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
            this.reader.setIndex(e2);
            var t2 = e2;
            if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
              if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
              if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
              this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
            }
            var r2 = this.centralDirOffset + this.centralDirSize;
            this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
            var n2 = t2 - r2;
            if (0 < n2)
              this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
            else if (n2 < 0)
              throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
          }, prepareReader: function(e2) {
            this.reader = n(e2);
          }, load: function(e2) {
            this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
          } }, t.exports = h2;
        }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
          "use strict";
          var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h2 = e("./compressions"), u = e("./support");
          function l(e2, t2) {
            this.options = e2, this.loadOptions = t2;
          }
          l.prototype = { isEncrypted: function() {
            return (1 & this.bitFlag) == 1;
          }, useUTF8: function() {
            return (2048 & this.bitFlag) == 2048;
          }, readLocalPart: function(e2) {
            var t2, r2;
            if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), this.compressedSize === -1 || this.uncompressedSize === -1)
              throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
            if ((t2 = function(e3) {
              for (var t3 in h2)
                if (Object.prototype.hasOwnProperty.call(h2, t3) && h2[t3].magic === e3)
                  return h2[t3];
              return null;
            }(this.compressionMethod)) === null)
              throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
            this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
          }, readCentralPart: function(e2) {
            this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
            var t2 = e2.readInt(2);
            if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
              throw new Error("Encrypted zip are not supported");
            e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
          }, processAttributes: function() {
            this.unixPermissions = null, this.dosPermissions = null;
            var e2 = this.versionMadeBy >> 8;
            this.dir = !!(16 & this.externalFileAttributes), e2 == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), e2 == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = true);
          }, parseZIP64ExtraField: function() {
            if (this.extraFields[1]) {
              var e2 = n(this.extraFields[1].value);
              this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
            }
          }, readExtraFields: function(e2) {
            var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
            for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
              t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
            e2.setIndex(i2);
          }, handleUTF8: function() {
            var e2 = u.uint8array ? "uint8array" : "array";
            if (this.useUTF8())
              this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
            else {
              var t2 = this.findExtraFieldUnicodePath();
              if (t2 !== null)
                this.fileNameStr = t2;
              else {
                var r2 = s.transformTo(e2, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(r2);
              }
              var n2 = this.findExtraFieldUnicodeComment();
              if (n2 !== null)
                this.fileCommentStr = n2;
              else {
                var i2 = s.transformTo(e2, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(i2);
              }
            }
          }, findExtraFieldUnicodePath: function() {
            var e2 = this.extraFields[28789];
            if (e2) {
              var t2 = n(e2.value);
              return t2.readInt(1) !== 1 ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
            }
            return null;
          }, findExtraFieldUnicodeComment: function() {
            var e2 = this.extraFields[25461];
            if (e2) {
              var t2 = n(e2.value);
              return t2.readInt(1) !== 1 ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
            }
            return null;
          } }, t.exports = l;
        }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
          "use strict";
          function n(e2, t2, r2) {
            this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
          }
          var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h2 = e("./stream/GenericWorker");
          n.prototype = { internalStream: function(e2) {
            var t2 = null, r2 = "string";
            try {
              if (!e2)
                throw new Error("No output type specified.");
              var n2 = (r2 = e2.toLowerCase()) === "string" || r2 === "text";
              r2 !== "binarystring" && r2 !== "text" || (r2 = "string"), t2 = this._decompressWorker();
              var i2 = !this._dataBinary;
              i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
            } catch (e3) {
              (t2 = new h2("error")).error(e3);
            }
            return new s(t2, r2, "");
          }, async: function(e2, t2) {
            return this.internalStream(e2).accumulate(t2);
          }, nodeStream: function(e2, t2) {
            return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
          }, _compressWorker: function(e2, t2) {
            if (this._data instanceof o && this._data.compression.magic === e2.magic)
              return this._data.getCompressedWorker();
            var r2 = this._decompressWorker();
            return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
          }, _decompressWorker: function() {
            return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h2 ? this._data : new i(this._data);
          } };
          for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          }, f = 0; f < u.length; f++)
            n.prototype[u[f]] = l;
          t.exports = n;
        }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
          (function(t2) {
            "use strict";
            var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
            if (e2) {
              var i = 0, s = new e2(u), a = t2.document.createTextNode("");
              s.observe(a, { characterData: true }), r = function() {
                a.data = i = ++i % 2;
              };
            } else if (t2.setImmediate || t2.MessageChannel === void 0)
              r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
                var e3 = t2.document.createElement("script");
                e3.onreadystatechange = function() {
                  u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
                }, t2.document.documentElement.appendChild(e3);
              } : function() {
                setTimeout(u, 0);
              };
            else {
              var o = new t2.MessageChannel();
              o.port1.onmessage = u, r = function() {
                o.port2.postMessage(0);
              };
            }
            var h2 = [];
            function u() {
              var e3, t3;
              n = true;
              for (var r2 = h2.length; r2; ) {
                for (t3 = h2, h2 = [], e3 = -1; ++e3 < r2; )
                  t3[e3]();
                r2 = h2.length;
              }
              n = false;
            }
            l.exports = function(e3) {
              h2.push(e3) !== 1 || n || r();
            };
          }).call(this, typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
        }, {}], 37: [function(e, t, r) {
          "use strict";
          var i = e("immediate");
          function u() {
          }
          var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
          function o(e2) {
            if (typeof e2 != "function")
              throw new TypeError("resolver must be a function");
            this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d2(this, e2);
          }
          function h2(e2, t2, r2) {
            this.promise = e2, typeof t2 == "function" && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), typeof r2 == "function" && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
          }
          function f(t2, r2, n2) {
            i(function() {
              var e2;
              try {
                e2 = r2(n2);
              } catch (e3) {
                return l.reject(t2, e3);
              }
              e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
            });
          }
          function c2(e2) {
            var t2 = e2 && e2.then;
            if (e2 && (typeof e2 == "object" || typeof e2 == "function") && typeof t2 == "function")
              return function() {
                t2.apply(e2, arguments);
              };
          }
          function d2(t2, e2) {
            var r2 = false;
            function n2(e3) {
              r2 || (r2 = true, l.reject(t2, e3));
            }
            function i2(e3) {
              r2 || (r2 = true, l.resolve(t2, e3));
            }
            var s2 = p(function() {
              e2(i2, n2);
            });
            s2.status === "error" && n2(s2.value);
          }
          function p(e2, t2) {
            var r2 = {};
            try {
              r2.value = e2(t2), r2.status = "success";
            } catch (e3) {
              r2.status = "error", r2.value = e3;
            }
            return r2;
          }
          (t.exports = o).prototype.finally = function(t2) {
            if (typeof t2 != "function")
              return this;
            var r2 = this.constructor;
            return this.then(function(e2) {
              return r2.resolve(t2()).then(function() {
                return e2;
              });
            }, function(e2) {
              return r2.resolve(t2()).then(function() {
                throw e2;
              });
            });
          }, o.prototype.catch = function(e2) {
            return this.then(null, e2);
          }, o.prototype.then = function(e2, t2) {
            if (typeof e2 != "function" && this.state === a || typeof t2 != "function" && this.state === s)
              return this;
            var r2 = new this.constructor(u);
            this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h2(r2, e2, t2));
            return r2;
          }, h2.prototype.callFulfilled = function(e2) {
            l.resolve(this.promise, e2);
          }, h2.prototype.otherCallFulfilled = function(e2) {
            f(this.promise, this.onFulfilled, e2);
          }, h2.prototype.callRejected = function(e2) {
            l.reject(this.promise, e2);
          }, h2.prototype.otherCallRejected = function(e2) {
            f(this.promise, this.onRejected, e2);
          }, l.resolve = function(e2, t2) {
            var r2 = p(c2, t2);
            if (r2.status === "error")
              return l.reject(e2, r2.value);
            var n2 = r2.value;
            if (n2)
              d2(e2, n2);
            else {
              e2.state = a, e2.outcome = t2;
              for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
                e2.queue[i2].callFulfilled(t2);
            }
            return e2;
          }, l.reject = function(e2, t2) {
            e2.state = s, e2.outcome = t2;
            for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; )
              e2.queue[r2].callRejected(t2);
            return e2;
          }, o.resolve = function(e2) {
            if (e2 instanceof this)
              return e2;
            return l.resolve(new this(u), e2);
          }, o.reject = function(e2) {
            var t2 = new this(u);
            return l.reject(t2, e2);
          }, o.all = function(e2) {
            var r2 = this;
            if (Object.prototype.toString.call(e2) !== "[object Array]")
              return this.reject(new TypeError("must be an array"));
            var n2 = e2.length, i2 = false;
            if (!n2)
              return this.resolve([]);
            var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
            for (; ++t2 < n2; )
              h3(e2[t2], t2);
            return o2;
            function h3(e3, t3) {
              r2.resolve(e3).then(function(e4) {
                s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
              }, function(e4) {
                i2 || (i2 = true, l.reject(o2, e4));
              });
            }
          }, o.race = function(e2) {
            var t2 = this;
            if (Object.prototype.toString.call(e2) !== "[object Array]")
              return this.reject(new TypeError("must be an array"));
            var r2 = e2.length, n2 = false;
            if (!r2)
              return this.resolve([]);
            var i2 = -1, s2 = new this(u);
            for (; ++i2 < r2; )
              a2 = e2[i2], t2.resolve(a2).then(function(e3) {
                n2 || (n2 = true, l.resolve(s2, e3));
              }, function(e3) {
                n2 || (n2 = true, l.reject(s2, e3));
              });
            var a2;
            return s2;
          };
        }, { immediate: 36 }], 38: [function(e, t, r) {
          "use strict";
          var n = {};
          (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
        }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
          "use strict";
          var a = e("./zlib/deflate"), o = e("./utils/common"), h2 = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c2 = 0, d2 = 8;
          function p(e2) {
            if (!(this instanceof p))
              return new p(e2);
            this.options = o.assign({ level: f, method: d2, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c2, to: "" }, e2 || {});
            var t2 = this.options;
            t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
            var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
            if (r2 !== l)
              throw new Error(i[r2]);
            if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
              var n2;
              if (n2 = typeof t2.dictionary == "string" ? h2.string2buf(t2.dictionary) : u.call(t2.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
                throw new Error(i[r2]);
              this._dict_set = true;
            }
          }
          function n(e2, t2) {
            var r2 = new p(t2);
            if (r2.push(e2, true), r2.err)
              throw r2.msg || i[r2.err];
            return r2.result;
          }
          p.prototype.push = function(e2, t2) {
            var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
            if (this.ended)
              return false;
            n2 = t2 === ~~t2 ? t2 : t2 === true ? 4 : 0, typeof e2 == "string" ? i2.input = h2.string2buf(e2) : u.call(e2) === "[object ArrayBuffer]" ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
            do {
              if (i2.avail_out === 0 && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), (r2 = a.deflate(i2, n2)) !== 1 && r2 !== l)
                return this.onEnd(r2), !(this.ended = true);
              i2.avail_out !== 0 && (i2.avail_in !== 0 || n2 !== 4 && n2 !== 2) || (this.options.to === "string" ? this.onData(h2.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
            } while ((0 < i2.avail_in || i2.avail_out === 0) && r2 !== 1);
            return n2 === 4 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : n2 !== 2 || (this.onEnd(l), !(i2.avail_out = 0));
          }, p.prototype.onData = function(e2) {
            this.chunks.push(e2);
          }, p.prototype.onEnd = function(e2) {
            e2 === l && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
          }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
            return (t2 = t2 || {}).raw = true, n(e2, t2);
          }, r.gzip = function(e2, t2) {
            return (t2 = t2 || {}).gzip = true, n(e2, t2);
          };
        }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
          "use strict";
          var c2 = e("./zlib/inflate"), d2 = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
          function a(e2) {
            if (!(this instanceof a))
              return new a(e2);
            this.options = d2.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
            var t2 = this.options;
            t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, t2.windowBits === 0 && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && (15 & t2.windowBits) == 0 && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
            var r2 = c2.inflateInit2(this.strm, t2.windowBits);
            if (r2 !== m.Z_OK)
              throw new Error(n[r2]);
            this.header = new s(), c2.inflateGetHeader(this.strm, this.header);
          }
          function o(e2, t2) {
            var r2 = new a(t2);
            if (r2.push(e2, true), r2.err)
              throw r2.msg || n[r2.err];
            return r2.result;
          }
          a.prototype.push = function(e2, t2) {
            var r2, n2, i2, s2, a2, o2, h2 = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
            if (this.ended)
              return false;
            n2 = t2 === ~~t2 ? t2 : t2 === true ? m.Z_FINISH : m.Z_NO_FLUSH, typeof e2 == "string" ? h2.input = p.binstring2buf(e2) : _.call(e2) === "[object ArrayBuffer]" ? h2.input = new Uint8Array(e2) : h2.input = e2, h2.next_in = 0, h2.avail_in = h2.input.length;
            do {
              if (h2.avail_out === 0 && (h2.output = new d2.Buf8(u), h2.next_out = 0, h2.avail_out = u), (r2 = c2.inflate(h2, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = typeof l == "string" ? p.string2buf(l) : _.call(l) === "[object ArrayBuffer]" ? new Uint8Array(l) : l, r2 = c2.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && f === true && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
                return this.onEnd(r2), !(this.ended = true);
              h2.next_out && (h2.avail_out !== 0 && r2 !== m.Z_STREAM_END && (h2.avail_in !== 0 || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || (this.options.to === "string" ? (i2 = p.utf8border(h2.output, h2.next_out), s2 = h2.next_out - i2, a2 = p.buf2string(h2.output, i2), h2.next_out = s2, h2.avail_out = u - s2, s2 && d2.arraySet(h2.output, h2.output, i2, s2, 0), this.onData(a2)) : this.onData(d2.shrinkBuf(h2.output, h2.next_out)))), h2.avail_in === 0 && h2.avail_out === 0 && (f = true);
            } while ((0 < h2.avail_in || h2.avail_out === 0) && r2 !== m.Z_STREAM_END);
            return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c2.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h2.avail_out = 0));
          }, a.prototype.onData = function(e2) {
            this.chunks.push(e2);
          }, a.prototype.onEnd = function(e2) {
            e2 === m.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = d2.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
          }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
            return (t2 = t2 || {}).raw = true, o(e2, t2);
          }, r.ungzip = o;
        }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
          "use strict";
          var n = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Int32Array != "undefined";
          r.assign = function(e2) {
            for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
              var r2 = t2.shift();
              if (r2) {
                if (typeof r2 != "object")
                  throw new TypeError(r2 + "must be non-object");
                for (var n2 in r2)
                  r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
              }
            }
            return e2;
          }, r.shrinkBuf = function(e2, t2) {
            return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
          };
          var i = { arraySet: function(e2, t2, r2, n2, i2) {
            if (t2.subarray && e2.subarray)
              e2.set(t2.subarray(r2, r2 + n2), i2);
            else
              for (var s2 = 0; s2 < n2; s2++)
                e2[i2 + s2] = t2[r2 + s2];
          }, flattenChunks: function(e2) {
            var t2, r2, n2, i2, s2, a;
            for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++)
              n2 += e2[t2].length;
            for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++)
              s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
            return a;
          } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
            for (var s2 = 0; s2 < n2; s2++)
              e2[i2 + s2] = t2[r2 + s2];
          }, flattenChunks: function(e2) {
            return [].concat.apply([], e2);
          } };
          r.setTyped = function(e2) {
            e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
          }, r.setTyped(n);
        }, {}], 42: [function(e, t, r) {
          "use strict";
          var h2 = e("./common"), i = true, s = true;
          try {
            String.fromCharCode.apply(null, [0]);
          } catch (e2) {
            i = false;
          }
          try {
            String.fromCharCode.apply(null, new Uint8Array(1));
          } catch (e2) {
            s = false;
          }
          for (var u = new h2.Buf8(256), n = 0; n < 256; n++)
            u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
          function l(e2, t2) {
            if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i))
              return String.fromCharCode.apply(null, h2.shrinkBuf(e2, t2));
            for (var r2 = "", n2 = 0; n2 < t2; n2++)
              r2 += String.fromCharCode(e2[n2]);
            return r2;
          }
          u[254] = u[254] = 1, r.string2buf = function(e2) {
            var t2, r2, n2, i2, s2, a = e2.length, o = 0;
            for (i2 = 0; i2 < a; i2++)
              (64512 & (r2 = e2.charCodeAt(i2))) == 55296 && i2 + 1 < a && (64512 & (n2 = e2.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t2 = new h2.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
              (64512 & (r2 = e2.charCodeAt(i2))) == 55296 && i2 + 1 < a && (64512 & (n2 = e2.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
            return t2;
          }, r.buf2binstring = function(e2) {
            return l(e2, e2.length);
          }, r.binstring2buf = function(e2) {
            for (var t2 = new h2.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++)
              t2[r2] = e2.charCodeAt(r2);
            return t2;
          }, r.buf2string = function(e2, t2) {
            var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
            for (r2 = n2 = 0; r2 < a; )
              if ((i2 = e2[r2++]) < 128)
                o[n2++] = i2;
              else if (4 < (s2 = u[i2]))
                o[n2++] = 65533, r2 += s2 - 1;
              else {
                for (i2 &= s2 === 2 ? 31 : s2 === 3 ? 15 : 7; 1 < s2 && r2 < a; )
                  i2 = i2 << 6 | 63 & e2[r2++], s2--;
                1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
              }
            return l(o, n2);
          }, r.utf8border = function(e2, t2) {
            var r2;
            for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && (192 & e2[r2]) == 128; )
              r2--;
            return r2 < 0 ? t2 : r2 === 0 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
          };
        }, { "./common": 41 }], 43: [function(e, t, r) {
          "use strict";
          t.exports = function(e2, t2, r2, n) {
            for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; r2 !== 0; ) {
              for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; )
                ;
              i %= 65521, s %= 65521;
            }
            return i | s << 16 | 0;
          };
        }, {}], 44: [function(e, t, r) {
          "use strict";
          t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
        }, {}], 45: [function(e, t, r) {
          "use strict";
          var o = function() {
            for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
              e2 = r2;
              for (var n = 0; n < 8; n++)
                e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
              t2[r2] = e2;
            }
            return t2;
          }();
          t.exports = function(e2, t2, r2, n) {
            var i = o, s = n + r2;
            e2 ^= -1;
            for (var a = n; a < s; a++)
              e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
            return -1 ^ e2;
          };
        }, {}], 46: [function(e, t, r) {
          "use strict";
          var h2, c2 = e("../utils/common"), u = e("./trees"), d2 = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y2 = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z2 = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
          function R(e2, t2) {
            return e2.msg = n[t2], t2;
          }
          function T(e2) {
            return (e2 << 1) - (4 < e2 ? 9 : 0);
          }
          function D2(e2) {
            for (var t2 = e2.length; 0 <= --t2; )
              e2[t2] = 0;
          }
          function F2(e2) {
            var t2 = e2.state, r2 = t2.pending;
            r2 > e2.avail_out && (r2 = e2.avail_out), r2 !== 0 && (c2.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, t2.pending === 0 && (t2.pending_out = 0));
          }
          function N(e2, t2) {
            u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F2(e2.strm);
          }
          function U(e2, t2) {
            e2.pending_buf[e2.pending++] = t2;
          }
          function P(e2, t2) {
            e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
          }
          function L(e2, t2) {
            var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h3 = e2.strstart > e2.w_size - z2 ? e2.strstart - (e2.w_size - z2) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c3 = e2.strstart + S, d3 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
            e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
            do {
              if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d3 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
                s2 += 2, r2++;
                do {
                } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c3);
                if (n2 = S - (c3 - s2), s2 = c3 - S, a2 < n2) {
                  if (e2.match_start = t2, o2 <= (a2 = n2))
                    break;
                  d3 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
                }
              }
            } while ((t2 = f2[t2 & l2]) > h3 && --i2 != 0);
            return a2 <= e2.lookahead ? a2 : e2.lookahead;
          }
          function j2(e2) {
            var t2, r2, n2, i2, s2, a2, o2, h3, u2, l2, f2 = e2.w_size;
            do {
              if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z2)) {
                for (c2.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                  ;
                for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                  ;
                i2 += f2;
              }
              if (e2.strm.avail_in === 0)
                break;
              if (a2 = e2.strm, o2 = e2.window, h3 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = l2 === 0 ? 0 : (a2.avail_in -= l2, c2.arraySet(o2, a2.input, a2.next_in, l2, h3), a2.state.wrap === 1 ? a2.adler = d2(a2.adler, o2, l2, h3) : a2.state.wrap === 2 && (a2.adler = p(a2.adler, o2, l2, h3)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
                for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
                  ;
            } while (e2.lookahead < z2 && e2.strm.avail_in !== 0);
          }
          function Z(e2, t2) {
            for (var r2, n2; ; ) {
              if (e2.lookahead < z2) {
                if (j2(e2), e2.lookahead < z2 && t2 === l)
                  return A;
                if (e2.lookahead === 0)
                  break;
              }
              if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), r2 !== 0 && e2.strstart - r2 <= e2.w_size - z2 && (e2.match_length = L(e2, r2)), e2.match_length >= x)
                if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
                  for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, --e2.match_length != 0; )
                    ;
                  e2.strstart++;
                } else
                  e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
              else
                n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
              if (n2 && (N(e2, false), e2.strm.avail_out === 0))
                return A;
            }
            return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), e2.strm.avail_out === 0 ? O : B) : e2.last_lit && (N(e2, false), e2.strm.avail_out === 0) ? A : I;
          }
          function W2(e2, t2) {
            for (var r2, n2, i2; ; ) {
              if (e2.lookahead < z2) {
                if (j2(e2), e2.lookahead < z2 && t2 === l)
                  return A;
                if (e2.lookahead === 0)
                  break;
              }
              if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, r2 !== 0 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z2 && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (e2.strategy === 1 || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
                for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), --e2.prev_length != 0; )
                  ;
                if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), e2.strm.avail_out === 0))
                  return A;
              } else if (e2.match_available) {
                if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, e2.strm.avail_out === 0)
                  return A;
              } else
                e2.match_available = 1, e2.strstart++, e2.lookahead--;
            }
            return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), e2.strm.avail_out === 0 ? O : B) : e2.last_lit && (N(e2, false), e2.strm.avail_out === 0) ? A : I;
          }
          function M2(e2, t2, r2, n2, i2) {
            this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
          }
          function H2() {
            this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c2.Buf16(2 * w), this.dyn_dtree = new c2.Buf16(2 * (2 * a + 1)), this.bl_tree = new c2.Buf16(2 * (2 * o + 1)), D2(this.dyn_ltree), D2(this.dyn_dtree), D2(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c2.Buf16(k + 1), this.heap = new c2.Buf16(2 * s + 1), D2(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c2.Buf16(2 * s + 1), D2(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
          }
          function G2(e2) {
            var t2;
            return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = t2.wrap === 2 ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);
          }
          function K2(e2) {
            var t2 = G2(e2);
            return t2 === m && function(e3) {
              e3.window_size = 2 * e3.w_size, D2(e3.head), e3.max_lazy_match = h2[e3.level].max_lazy, e3.good_match = h2[e3.level].good_length, e3.nice_match = h2[e3.level].nice_length, e3.max_chain_length = h2[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
            }(e2.state), t2;
          }
          function Y(e2, t2, r2, n2, i2, s2) {
            if (!e2)
              return _;
            var a2 = 1;
            if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y2 < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2)
              return R(e2, _);
            n2 === 8 && (n2 = 9);
            var o2 = new H2();
            return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c2.Buf8(2 * o2.w_size), o2.head = new c2.Buf16(o2.hash_size), o2.prev = new c2.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c2.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K2(e2);
          }
          h2 = [new M2(0, 0, 0, 0, function(e2, t2) {
            var r2 = 65535;
            for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
              if (e2.lookahead <= 1) {
                if (j2(e2), e2.lookahead === 0 && t2 === l)
                  return A;
                if (e2.lookahead === 0)
                  break;
              }
              e2.strstart += e2.lookahead, e2.lookahead = 0;
              var n2 = e2.block_start + r2;
              if ((e2.strstart === 0 || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), e2.strm.avail_out === 0))
                return A;
              if (e2.strstart - e2.block_start >= e2.w_size - z2 && (N(e2, false), e2.strm.avail_out === 0))
                return A;
            }
            return e2.insert = 0, t2 === f ? (N(e2, true), e2.strm.avail_out === 0 ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
          }), new M2(4, 4, 8, 4, Z), new M2(4, 5, 16, 8, Z), new M2(4, 6, 32, 32, Z), new M2(4, 4, 16, 16, W2), new M2(8, 16, 32, 32, W2), new M2(8, 16, 128, 128, W2), new M2(8, 32, 128, 256, W2), new M2(32, 128, 258, 1024, W2), new M2(32, 258, 258, 4096, W2)], r.deflateInit = function(e2, t2) {
            return Y(e2, t2, v, 15, 8, 0);
          }, r.deflateInit2 = Y, r.deflateReset = K2, r.deflateResetKeep = G2, r.deflateSetHeader = function(e2, t2) {
            return e2 && e2.state ? e2.state.wrap !== 2 ? _ : (e2.state.gzhead = t2, m) : _;
          }, r.deflate = function(e2, t2) {
            var r2, n2, i2, s2;
            if (!e2 || !e2.state || 5 < t2 || t2 < 0)
              return e2 ? R(e2, _) : _;
            if (n2 = e2.state, !e2.output || !e2.input && e2.avail_in !== 0 || n2.status === 666 && t2 !== f)
              return R(e2, e2.avail_out === 0 ? -5 : _);
            if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C)
              if (n2.wrap === 2)
                e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, n2.level === 9 ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, n2.level === 9 ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
              else {
                var a2 = v + (n2.w_bits - 8 << 4) << 8;
                a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : n2.level === 6 ? 2 : 3) << 6, n2.strstart !== 0 && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), n2.strstart !== 0 && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
              }
            if (n2.status === 69)
              if (n2.gzhead.extra) {
                for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F2(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
                  U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
                n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
              } else
                n2.status = 73;
            if (n2.status === 73)
              if (n2.gzhead.name) {
                i2 = n2.pending;
                do {
                  if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F2(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                    s2 = 1;
                    break;
                  }
                  s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
                } while (s2 !== 0);
                n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), s2 === 0 && (n2.gzindex = 0, n2.status = 91);
              } else
                n2.status = 91;
            if (n2.status === 91)
              if (n2.gzhead.comment) {
                i2 = n2.pending;
                do {
                  if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F2(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                    s2 = 1;
                    break;
                  }
                  s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
                } while (s2 !== 0);
                n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), s2 === 0 && (n2.status = 103);
              } else
                n2.status = 103;
            if (n2.status === 103 && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F2(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), n2.pending !== 0) {
              if (F2(e2), e2.avail_out === 0)
                return n2.last_flush = -1, m;
            } else if (e2.avail_in === 0 && T(t2) <= T(r2) && t2 !== f)
              return R(e2, -5);
            if (n2.status === 666 && e2.avail_in !== 0)
              return R(e2, -5);
            if (e2.avail_in !== 0 || n2.lookahead !== 0 || t2 !== l && n2.status !== 666) {
              var o2 = n2.strategy === 2 ? function(e3, t3) {
                for (var r3; ; ) {
                  if (e3.lookahead === 0 && (j2(e3), e3.lookahead === 0)) {
                    if (t3 === l)
                      return A;
                    break;
                  }
                  if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), e3.strm.avail_out === 0))
                    return A;
                }
                return e3.insert = 0, t3 === f ? (N(e3, true), e3.strm.avail_out === 0 ? O : B) : e3.last_lit && (N(e3, false), e3.strm.avail_out === 0) ? A : I;
              }(n2, t2) : n2.strategy === 3 ? function(e3, t3) {
                for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                  if (e3.lookahead <= S) {
                    if (j2(e3), e3.lookahead <= S && t3 === l)
                      return A;
                    if (e3.lookahead === 0)
                      break;
                  }
                  if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                    s3 = e3.strstart + S;
                    do {
                    } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                    e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                  }
                  if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), e3.strm.avail_out === 0))
                    return A;
                }
                return e3.insert = 0, t3 === f ? (N(e3, true), e3.strm.avail_out === 0 ? O : B) : e3.last_lit && (N(e3, false), e3.strm.avail_out === 0) ? A : I;
              }(n2, t2) : h2[n2.level].func(n2, t2);
              if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O)
                return e2.avail_out === 0 && (n2.last_flush = -1), m;
              if (o2 === I && (t2 === 1 ? u._tr_align(n2) : t2 !== 5 && (u._tr_stored_block(n2, 0, 0, false), t2 === 3 && (D2(n2.head), n2.lookahead === 0 && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F2(e2), e2.avail_out === 0))
                return n2.last_flush = -1, m;
            }
            return t2 !== f ? m : n2.wrap <= 0 ? 1 : (n2.wrap === 2 ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F2(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), n2.pending !== 0 ? m : 1);
          }, r.deflateEnd = function(e2) {
            var t2;
            return e2 && e2.state ? (t2 = e2.state.status) !== C && t2 !== 69 && t2 !== 73 && t2 !== 91 && t2 !== 103 && t2 !== E && t2 !== 666 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;
          }, r.deflateSetDictionary = function(e2, t2) {
            var r2, n2, i2, s2, a2, o2, h3, u2, l2 = t2.length;
            if (!e2 || !e2.state)
              return _;
            if ((s2 = (r2 = e2.state).wrap) === 2 || s2 === 1 && r2.status !== C || r2.lookahead)
              return _;
            for (s2 === 1 && (e2.adler = d2(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (s2 === 0 && (D2(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c2.Buf8(r2.w_size), c2.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h3 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j2(r2); r2.lookahead >= x; ) {
              for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
                ;
              r2.strstart = n2, r2.lookahead = x - 1, j2(r2);
            }
            return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h3, e2.avail_in = a2, r2.wrap = s2, m;
          }, r.deflateInfo = "pako deflate (from Nodeca project)";
        }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
          "use strict";
          t.exports = function() {
            this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
          };
        }, {}], 48: [function(e, t, r) {
          "use strict";
          t.exports = function(e2, t2) {
            var r2, n, i, s, a, o, h2, u, l, f, c2, d2, p, m, _, g, b, v, y2, w, k, x, S, z2, C;
            r2 = e2.state, n = e2.next_in, z2 = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h2 = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c2 = r2.window, d2 = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
            e:
              do {
                p < 15 && (d2 += z2[n++] << p, p += 8, d2 += z2[n++] << p, p += 8), v = m[d2 & g];
                t:
                  for (; ; ) {
                    if (d2 >>>= y2 = v >>> 24, p -= y2, (y2 = v >>> 16 & 255) === 0)
                      C[s++] = 65535 & v;
                    else {
                      if (!(16 & y2)) {
                        if ((64 & y2) == 0) {
                          v = m[(65535 & v) + (d2 & (1 << y2) - 1)];
                          continue t;
                        }
                        if (32 & y2) {
                          r2.mode = 12;
                          break e;
                        }
                        e2.msg = "invalid literal/length code", r2.mode = 30;
                        break e;
                      }
                      w = 65535 & v, (y2 &= 15) && (p < y2 && (d2 += z2[n++] << p, p += 8), w += d2 & (1 << y2) - 1, d2 >>>= y2, p -= y2), p < 15 && (d2 += z2[n++] << p, p += 8, d2 += z2[n++] << p, p += 8), v = _[d2 & b];
                      r:
                        for (; ; ) {
                          if (d2 >>>= y2 = v >>> 24, p -= y2, !(16 & (y2 = v >>> 16 & 255))) {
                            if ((64 & y2) == 0) {
                              v = _[(65535 & v) + (d2 & (1 << y2) - 1)];
                              continue r;
                            }
                            e2.msg = "invalid distance code", r2.mode = 30;
                            break e;
                          }
                          if (k = 65535 & v, p < (y2 &= 15) && (d2 += z2[n++] << p, (p += 8) < y2 && (d2 += z2[n++] << p, p += 8)), h2 < (k += d2 & (1 << y2) - 1)) {
                            e2.msg = "invalid distance too far back", r2.mode = 30;
                            break e;
                          }
                          if (d2 >>>= y2, p -= y2, (y2 = s - a) < k) {
                            if (l < (y2 = k - y2) && r2.sane) {
                              e2.msg = "invalid distance too far back", r2.mode = 30;
                              break e;
                            }
                            if (S = c2, (x = 0) === f) {
                              if (x += u - y2, y2 < w) {
                                for (w -= y2; C[s++] = c2[x++], --y2; )
                                  ;
                                x = s - k, S = C;
                              }
                            } else if (f < y2) {
                              if (x += u + f - y2, (y2 -= f) < w) {
                                for (w -= y2; C[s++] = c2[x++], --y2; )
                                  ;
                                if (x = 0, f < w) {
                                  for (w -= y2 = f; C[s++] = c2[x++], --y2; )
                                    ;
                                  x = s - k, S = C;
                                }
                              }
                            } else if (x += f - y2, y2 < w) {
                              for (w -= y2; C[s++] = c2[x++], --y2; )
                                ;
                              x = s - k, S = C;
                            }
                            for (; 2 < w; )
                              C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                            w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                          } else {
                            for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                              ;
                            w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                          }
                          break;
                        }
                    }
                    break;
                  }
              } while (n < i && s < o);
            n -= w = p >> 3, d2 &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d2, r2.bits = p;
          };
        }, {}], 49: [function(e, t, r) {
          "use strict";
          var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D2 = 1, F2 = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
          function L(e2) {
            return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
          }
          function s() {
            this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
          }
          function a(e2) {
            var t2;
            return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
          }
          function o(e2) {
            var t2;
            return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
          }
          function h2(e2, t2) {
            var r2, n2;
            return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (n2.window !== null && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
          }
          function u(e2, t2) {
            var r2, n2;
            return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h2(e2, t2)) !== N && (e2.state = null), r2) : U;
          }
          var l, f, c2 = true;
          function j2(e2) {
            if (c2) {
              var t2;
              for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; )
                e2.lens[t2++] = 8;
              for (; t2 < 256; )
                e2.lens[t2++] = 9;
              for (; t2 < 280; )
                e2.lens[t2++] = 7;
              for (; t2 < 288; )
                e2.lens[t2++] = 8;
              for (T(D2, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
                e2.lens[t2++] = 5;
              T(F2, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c2 = false;
            }
            e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
          }
          function Z(e2, t2, r2, n2) {
            var i2, s2 = e2.state;
            return s2.window === null && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
          }
          r.inflateReset = o, r.inflateReset2 = h2, r.inflateResetKeep = a, r.inflateInit = function(e2) {
            return u(e2, 15);
          }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
            var r2, n2, i2, s2, a2, o2, h3, u2, l2, f2, c3, d2, p, m, _, g, b, v, y2, w, k, x, S, z2, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
            if (!e2 || !e2.state || !e2.output || !e2.input && e2.avail_in !== 0)
              return U;
            (r2 = e2.state).mode === 12 && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h3 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c3 = h3, x = N;
            e:
              for (; ; )
                switch (r2.mode) {
                  case P:
                    if (r2.wrap === 0) {
                      r2.mode = 13;
                      break;
                    }
                    for (; l2 < 16; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (2 & r2.wrap && u2 === 35615) {
                      E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                      break;
                    }
                    if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                      e2.msg = "incorrect header check", r2.mode = 30;
                      break;
                    }
                    if ((15 & u2) != 8) {
                      e2.msg = "unknown compression method", r2.mode = 30;
                      break;
                    }
                    if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), r2.wbits === 0)
                      r2.wbits = k;
                    else if (k > r2.wbits) {
                      e2.msg = "invalid window size", r2.mode = 30;
                      break;
                    }
                    r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                    break;
                  case 2:
                    for (; l2 < 16; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (r2.flags = u2, (255 & r2.flags) != 8) {
                      e2.msg = "unknown compression method", r2.mode = 30;
                      break;
                    }
                    if (57344 & r2.flags) {
                      e2.msg = "unknown header flags set", r2.mode = 30;
                      break;
                    }
                    r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
                  case 3:
                    for (; l2 < 32; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
                  case 4:
                    for (; l2 < 16; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
                  case 5:
                    if (1024 & r2.flags) {
                      for (; l2 < 16; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                    } else
                      r2.head && (r2.head.extra = null);
                    r2.mode = 6;
                  case 6:
                    if (1024 & r2.flags && (o2 < (d2 = r2.length) && (d2 = o2), d2 && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d2, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d2, s2)), o2 -= d2, s2 += d2, r2.length -= d2), r2.length))
                      break e;
                    r2.length = 0, r2.mode = 7;
                  case 7:
                    if (2048 & r2.flags) {
                      if (o2 === 0)
                        break e;
                      for (d2 = 0; k = n2[s2 + d2++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d2 < o2; )
                        ;
                      if (512 & r2.flags && (r2.check = B(r2.check, n2, d2, s2)), o2 -= d2, s2 += d2, k)
                        break e;
                    } else
                      r2.head && (r2.head.name = null);
                    r2.length = 0, r2.mode = 8;
                  case 8:
                    if (4096 & r2.flags) {
                      if (o2 === 0)
                        break e;
                      for (d2 = 0; k = n2[s2 + d2++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d2 < o2; )
                        ;
                      if (512 & r2.flags && (r2.check = B(r2.check, n2, d2, s2)), o2 -= d2, s2 += d2, k)
                        break e;
                    } else
                      r2.head && (r2.head.comment = null);
                    r2.mode = 9;
                  case 9:
                    if (512 & r2.flags) {
                      for (; l2 < 16; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      if (u2 !== (65535 & r2.check)) {
                        e2.msg = "header crc mismatch", r2.mode = 30;
                        break;
                      }
                      l2 = u2 = 0;
                    }
                    r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                    break;
                  case 10:
                    for (; l2 < 32; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
                  case 11:
                    if (r2.havedict === 0)
                      return e2.next_out = a2, e2.avail_out = h3, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                    e2.adler = r2.check = 1, r2.mode = 12;
                  case 12:
                    if (t2 === 5 || t2 === 6)
                      break e;
                  case 13:
                    if (r2.last) {
                      u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                      break;
                    }
                    for (; l2 < 3; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                      case 0:
                        r2.mode = 14;
                        break;
                      case 1:
                        if (j2(r2), r2.mode = 20, t2 !== 6)
                          break;
                        u2 >>>= 2, l2 -= 2;
                        break e;
                      case 2:
                        r2.mode = 17;
                        break;
                      case 3:
                        e2.msg = "invalid block type", r2.mode = 30;
                    }
                    u2 >>>= 2, l2 -= 2;
                    break;
                  case 14:
                    for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                      e2.msg = "invalid stored block lengths", r2.mode = 30;
                      break;
                    }
                    if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, t2 === 6)
                      break e;
                  case 15:
                    r2.mode = 16;
                  case 16:
                    if (d2 = r2.length) {
                      if (o2 < d2 && (d2 = o2), h3 < d2 && (d2 = h3), d2 === 0)
                        break e;
                      I.arraySet(i2, n2, s2, d2, a2), o2 -= d2, s2 += d2, h3 -= d2, a2 += d2, r2.length -= d2;
                      break;
                    }
                    r2.mode = 12;
                    break;
                  case 17:
                    for (; l2 < 14; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                      e2.msg = "too many length or distance symbols", r2.mode = 30;
                      break;
                    }
                    r2.have = 0, r2.mode = 18;
                  case 18:
                    for (; r2.have < r2.ncode; ) {
                      for (; l2 < 3; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                    }
                    for (; r2.have < 19; )
                      r2.lens[A[r2.have++]] = 0;
                    if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                      e2.msg = "invalid code lengths set", r2.mode = 30;
                      break;
                    }
                    r2.have = 0, r2.mode = 19;
                  case 19:
                    for (; r2.have < r2.nlen + r2.ndist; ) {
                      for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      if (b < 16)
                        u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                      else {
                        if (b === 16) {
                          for (z2 = _ + 2; l2 < z2; ) {
                            if (o2 === 0)
                              break e;
                            o2--, u2 += n2[s2++] << l2, l2 += 8;
                          }
                          if (u2 >>>= _, l2 -= _, r2.have === 0) {
                            e2.msg = "invalid bit length repeat", r2.mode = 30;
                            break;
                          }
                          k = r2.lens[r2.have - 1], d2 = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                        } else if (b === 17) {
                          for (z2 = _ + 3; l2 < z2; ) {
                            if (o2 === 0)
                              break e;
                            o2--, u2 += n2[s2++] << l2, l2 += 8;
                          }
                          l2 -= _, k = 0, d2 = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                        } else {
                          for (z2 = _ + 7; l2 < z2; ) {
                            if (o2 === 0)
                              break e;
                            o2--, u2 += n2[s2++] << l2, l2 += 8;
                          }
                          l2 -= _, k = 0, d2 = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                        }
                        if (r2.have + d2 > r2.nlen + r2.ndist) {
                          e2.msg = "invalid bit length repeat", r2.mode = 30;
                          break;
                        }
                        for (; d2--; )
                          r2.lens[r2.have++] = k;
                      }
                    }
                    if (r2.mode === 30)
                      break;
                    if (r2.lens[256] === 0) {
                      e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                      break;
                    }
                    if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D2, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                      e2.msg = "invalid literal/lengths set", r2.mode = 30;
                      break;
                    }
                    if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F2, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                      e2.msg = "invalid distances set", r2.mode = 30;
                      break;
                    }
                    if (r2.mode = 20, t2 === 6)
                      break e;
                  case 20:
                    r2.mode = 21;
                  case 21:
                    if (6 <= o2 && 258 <= h3) {
                      e2.next_out = a2, e2.avail_out = h3, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c3), a2 = e2.next_out, i2 = e2.output, h3 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, r2.mode === 12 && (r2.back = -1);
                      break;
                    }
                    for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (g && (240 & g) == 0) {
                      for (v = _, y2 = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y2) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      u2 >>>= v, l2 -= v, r2.back += v;
                    }
                    if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, g === 0) {
                      r2.mode = 26;
                      break;
                    }
                    if (32 & g) {
                      r2.back = -1, r2.mode = 12;
                      break;
                    }
                    if (64 & g) {
                      e2.msg = "invalid literal/length code", r2.mode = 30;
                      break;
                    }
                    r2.extra = 15 & g, r2.mode = 22;
                  case 22:
                    if (r2.extra) {
                      for (z2 = r2.extra; l2 < z2; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                    }
                    r2.was = r2.length, r2.mode = 23;
                  case 23:
                    for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if ((240 & g) == 0) {
                      for (v = _, y2 = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y2) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      u2 >>>= v, l2 -= v, r2.back += v;
                    }
                    if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                      e2.msg = "invalid distance code", r2.mode = 30;
                      break;
                    }
                    r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
                  case 24:
                    if (r2.extra) {
                      for (z2 = r2.extra; l2 < z2; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                    }
                    if (r2.offset > r2.dmax) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break;
                    }
                    r2.mode = 25;
                  case 25:
                    if (h3 === 0)
                      break e;
                    if (d2 = c3 - h3, r2.offset > d2) {
                      if ((d2 = r2.offset - d2) > r2.whave && r2.sane) {
                        e2.msg = "invalid distance too far back", r2.mode = 30;
                        break;
                      }
                      p = d2 > r2.wnext ? (d2 -= r2.wnext, r2.wsize - d2) : r2.wnext - d2, d2 > r2.length && (d2 = r2.length), m = r2.window;
                    } else
                      m = i2, p = a2 - r2.offset, d2 = r2.length;
                    for (h3 < d2 && (d2 = h3), h3 -= d2, r2.length -= d2; i2[a2++] = m[p++], --d2; )
                      ;
                    r2.length === 0 && (r2.mode = 21);
                    break;
                  case 26:
                    if (h3 === 0)
                      break e;
                    i2[a2++] = r2.length, h3--, r2.mode = 21;
                    break;
                  case 27:
                    if (r2.wrap) {
                      for (; l2 < 32; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 |= n2[s2++] << l2, l2 += 8;
                      }
                      if (c3 -= h3, e2.total_out += c3, r2.total += c3, c3 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c3, a2 - c3) : O(r2.check, i2, c3, a2 - c3)), c3 = h3, (r2.flags ? u2 : L(u2)) !== r2.check) {
                        e2.msg = "incorrect data check", r2.mode = 30;
                        break;
                      }
                      l2 = u2 = 0;
                    }
                    r2.mode = 28;
                  case 28:
                    if (r2.wrap && r2.flags) {
                      for (; l2 < 32; ) {
                        if (o2 === 0)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      if (u2 !== (4294967295 & r2.total)) {
                        e2.msg = "incorrect length check", r2.mode = 30;
                        break;
                      }
                      l2 = u2 = 0;
                    }
                    r2.mode = 29;
                  case 29:
                    x = 1;
                    break e;
                  case 30:
                    x = -3;
                    break e;
                  case 31:
                    return -4;
                  case 32:
                  default:
                    return U;
                }
            return e2.next_out = a2, e2.avail_out = h3, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c3 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || t2 !== 4)) && Z(e2, e2.output, e2.next_out, c3 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c3 -= e2.avail_out, e2.total_in += f2, e2.total_out += c3, r2.total += c3, r2.wrap && c3 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c3, e2.next_out - c3) : O(r2.check, i2, c3, e2.next_out - c3)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (r2.mode === 12 ? 128 : 0) + (r2.mode === 20 || r2.mode === 15 ? 256 : 0), (f2 == 0 && c3 === 0 || t2 === 4) && x === N && (x = -5), x);
          }, r.inflateEnd = function(e2) {
            if (!e2 || !e2.state)
              return U;
            var t2 = e2.state;
            return t2.window && (t2.window = null), e2.state = null, N;
          }, r.inflateGetHeader = function(e2, t2) {
            var r2;
            return e2 && e2.state ? (2 & (r2 = e2.state).wrap) == 0 ? U : ((r2.head = t2).done = false, N) : U;
          }, r.inflateSetDictionary = function(e2, t2) {
            var r2, n2 = t2.length;
            return e2 && e2.state ? (r2 = e2.state).wrap !== 0 && r2.mode !== 11 ? U : r2.mode === 11 && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
          }, r.inflateInfo = "pako inflate (from Nodeca project)";
        }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
          "use strict";
          var D2 = e("../utils/common"), F2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
          t.exports = function(e2, t2, r2, n, i, s, a, o) {
            var h2, u, l, f, c2, d2, p, m, _, g = o.bits, b = 0, v = 0, y2 = 0, w = 0, k = 0, x = 0, S = 0, z2 = 0, C = 0, E = 0, A = null, I = 0, O = new D2.Buf16(16), B = new D2.Buf16(16), R = null, T = 0;
            for (b = 0; b <= 15; b++)
              O[b] = 0;
            for (v = 0; v < n; v++)
              O[t2[r2 + v]]++;
            for (k = g, w = 15; 1 <= w && O[w] === 0; w--)
              ;
            if (w < k && (k = w), w === 0)
              return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
            for (y2 = 1; y2 < w && O[y2] === 0; y2++)
              ;
            for (k < y2 && (k = y2), b = z2 = 1; b <= 15; b++)
              if (z2 <<= 1, (z2 -= O[b]) < 0)
                return -1;
            if (0 < z2 && (e2 === 0 || w !== 1))
              return -1;
            for (B[1] = 0, b = 1; b < 15; b++)
              B[b + 1] = B[b] + O[b];
            for (v = 0; v < n; v++)
              t2[r2 + v] !== 0 && (a[B[t2[r2 + v]]++] = v);
            if (d2 = e2 === 0 ? (A = R = a, 19) : e2 === 1 ? (A = F2, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y2, c2 = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, e2 === 1 && 852 < C || e2 === 2 && 592 < C)
              return 1;
            for (; ; ) {
              for (p = b - S, _ = a[v] < d2 ? (m = 0, a[v]) : a[v] > d2 ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h2 = 1 << b - S, y2 = u = 1 << x; i[c2 + (E >> S) + (u -= h2)] = p << 24 | m << 16 | _ | 0, u !== 0; )
                ;
              for (h2 = 1 << b - 1; E & h2; )
                h2 >>= 1;
              if (h2 !== 0 ? (E &= h2 - 1, E += h2) : E = 0, v++, --O[b] == 0) {
                if (b === w)
                  break;
                b = t2[r2 + a[v]];
              }
              if (k < b && (E & f) !== l) {
                for (S === 0 && (S = k), c2 += y2, z2 = 1 << (x = b - S); x + S < w && !((z2 -= O[x + S]) <= 0); )
                  x++, z2 <<= 1;
                if (C += 1 << x, e2 === 1 && 852 < C || e2 === 2 && 592 < C)
                  return 1;
                i[l = E & f] = k << 24 | x << 16 | c2 - s | 0;
              }
            }
            return E !== 0 && (i[c2 + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
          };
        }, { "../utils/common": 41 }], 51: [function(e, t, r) {
          "use strict";
          t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
        }, {}], 52: [function(e, t, r) {
          "use strict";
          var i = e("../utils/common"), o = 0, h2 = 1;
          function n(e2) {
            for (var t2 = e2.length; 0 <= --t2; )
              e2[t2] = 0;
          }
          var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c2 = 19, _ = 2 * l + 1, g = 15, d2 = 16, p = 7, m = 256, b = 16, v = 17, y2 = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z2 = new Array(2 * (l + 2));
          n(z2);
          var C = new Array(2 * f);
          n(C);
          var E = new Array(512);
          n(E);
          var A = new Array(256);
          n(A);
          var I = new Array(a);
          n(I);
          var O, B, R, T = new Array(f);
          function D2(e2, t2, r2, n2, i2) {
            this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
          }
          function F2(e2, t2) {
            this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
          }
          function N(e2) {
            return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
          }
          function U(e2, t2) {
            e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
          }
          function P(e2, t2, r2) {
            e2.bi_valid > d2 - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d2 - e2.bi_valid, e2.bi_valid += r2 - d2) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
          }
          function L(e2, t2, r2) {
            P(e2, r2[2 * t2], r2[2 * t2 + 1]);
          }
          function j2(e2, t2) {
            for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; )
              ;
            return r2 >>> 1;
          }
          function Z(e2, t2, r2) {
            var n2, i2, s2 = new Array(g + 1), a2 = 0;
            for (n2 = 1; n2 <= g; n2++)
              s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
            for (i2 = 0; i2 <= t2; i2++) {
              var o2 = e2[2 * i2 + 1];
              o2 !== 0 && (e2[2 * i2] = j2(s2[o2]++, o2));
            }
          }
          function W2(e2) {
            var t2;
            for (t2 = 0; t2 < l; t2++)
              e2.dyn_ltree[2 * t2] = 0;
            for (t2 = 0; t2 < f; t2++)
              e2.dyn_dtree[2 * t2] = 0;
            for (t2 = 0; t2 < c2; t2++)
              e2.bl_tree[2 * t2] = 0;
            e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
          }
          function M2(e2) {
            8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
          }
          function H2(e2, t2, r2, n2) {
            var i2 = 2 * t2, s2 = 2 * r2;
            return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
          }
          function G2(e2, t2, r2) {
            for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H2(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H2(t2, n2, e2.heap[i2], e2.depth)); )
              e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
            e2.heap[r2] = n2;
          }
          function K2(e2, t2, r2) {
            var n2, i2, s2, a2, o2 = 0;
            if (e2.last_lit !== 0)
              for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, n2 === 0 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), (a2 = w[s2]) !== 0 && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), (a2 = k[s2]) !== 0 && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; )
                ;
            L(e2, m, t2);
          }
          function Y(e2, t2) {
            var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h3 = t2.stat_desc.elems, u2 = -1;
            for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h3; r2++)
              s2[2 * r2] !== 0 ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
            for (; e2.heap_len < 2; )
              s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
            for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
              G2(e2, s2, r2);
            for (i2 = h3; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G2(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G2(e2, s2, 1), 2 <= e2.heap_len; )
              ;
            e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
              var r3, n3, i3, s3, a3, o3, h4 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c3 = t3.stat_desc.extra_bits, d3 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
              for (s3 = 0; s3 <= g; s3++)
                e3.bl_count[s3] = 0;
              for (h4[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
                p2 < (s3 = h4[2 * h4[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h4[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d3 <= n3 && (a3 = c3[n3 - d3]), o3 = h4[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
              if (m2 !== 0) {
                do {
                  for (s3 = p2 - 1; e3.bl_count[s3] === 0; )
                    s3--;
                  e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
                } while (0 < m2);
                for (s3 = p2; s3 !== 0; s3--)
                  for (n3 = e3.bl_count[s3]; n3 !== 0; )
                    u3 < (i3 = e3.heap[--r3]) || (h4[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h4[2 * i3 + 1]) * h4[2 * i3], h4[2 * i3 + 1] = s3), n3--);
              }
            }(e2, t2), Z(s2, u2, e2.bl_count);
          }
          function X2(e2, t2, r2) {
            var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h3 = 7, u2 = 4;
            for (a2 === 0 && (h3 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
              i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h3 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : i2 !== 0 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y2]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h3 = 138, 3) : i2 === a2 ? (h3 = 6, 3) : (h3 = 7, 4));
          }
          function V2(e2, t2, r2) {
            var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h3 = 7, u2 = 4;
            for (a2 === 0 && (h3 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
              if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h3 && i2 === a2)) {
                if (o2 < u2)
                  for (; L(e2, i2, e2.bl_tree), --o2 != 0; )
                    ;
                else
                  i2 !== 0 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y2, e2.bl_tree), P(e2, o2 - 11, 7));
                s2 = i2, u2 = (o2 = 0) === a2 ? (h3 = 138, 3) : i2 === a2 ? (h3 = 6, 3) : (h3 = 7, 4);
              }
          }
          n(T);
          var q2 = false;
          function J2(e2, t2, r2, n2) {
            P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
              M2(e3), n3 && (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
            }(e2, t2, r2, true);
          }
          r._tr_init = function(e2) {
            q2 || (function() {
              var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
              for (n2 = r2 = 0; n2 < a - 1; n2++)
                for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++)
                  A[r2++] = n2;
              for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
                for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++)
                  E[i2++] = n2;
              for (i2 >>= 7; n2 < f; n2++)
                for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++)
                  E[256 + i2++] = n2;
              for (t2 = 0; t2 <= g; t2++)
                s2[t2] = 0;
              for (e3 = 0; e3 <= 143; )
                z2[2 * e3 + 1] = 8, e3++, s2[8]++;
              for (; e3 <= 255; )
                z2[2 * e3 + 1] = 9, e3++, s2[9]++;
              for (; e3 <= 279; )
                z2[2 * e3 + 1] = 7, e3++, s2[7]++;
              for (; e3 <= 287; )
                z2[2 * e3 + 1] = 8, e3++, s2[8]++;
              for (Z(z2, l + 1, s2), e3 = 0; e3 < f; e3++)
                C[2 * e3 + 1] = 5, C[2 * e3] = j2(e3, 5);
              O = new D2(z2, w, u + 1, l, g), B = new D2(C, k, 0, f, g), R = new D2(new Array(0), x, 0, c2, p);
            }(), q2 = true), e2.l_desc = new F2(e2.dyn_ltree, O), e2.d_desc = new F2(e2.dyn_dtree, B), e2.bl_desc = new F2(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W2(e2);
          }, r._tr_stored_block = J2, r._tr_flush_block = function(e2, t2, r2, n2) {
            var i2, s2, a2 = 0;
            0 < e2.level ? (e2.strm.data_type === 2 && (e2.strm.data_type = function(e3) {
              var t3, r3 = 4093624447;
              for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
                if (1 & r3 && e3.dyn_ltree[2 * t3] !== 0)
                  return o;
              if (e3.dyn_ltree[18] !== 0 || e3.dyn_ltree[20] !== 0 || e3.dyn_ltree[26] !== 0)
                return h2;
              for (t3 = 32; t3 < u; t3++)
                if (e3.dyn_ltree[2 * t3] !== 0)
                  return h2;
              return o;
            }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
              var t3;
              for (X2(e3, e3.dyn_ltree, e3.l_desc.max_code), X2(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c2 - 1; 3 <= t3 && e3.bl_tree[2 * S[t3] + 1] === 0; t3--)
                ;
              return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
            }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && t2 !== -1 ? J2(e2, t2, r2, n2) : e2.strategy === 4 || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K2(e2, z2, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
              var i3;
              for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
                P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
              V2(e3, e3.dyn_ltree, t3 - 1), V2(e3, e3.dyn_dtree, r3 - 1);
            }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K2(e2, e2.dyn_ltree, e2.dyn_dtree)), W2(e2), n2 && M2(e2);
          }, r._tr_tally = function(e2, t2, r2) {
            return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, t2 === 0 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
          }, r._tr_align = function(e2) {
            P(e2, 2, 3), L(e2, m, z2), function(e3) {
              e3.bi_valid === 16 ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
            }(e2);
          };
        }, { "../utils/common": 41 }], 53: [function(e, t, r) {
          "use strict";
          t.exports = function() {
            this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
          };
        }, {}], 54: [function(e, t, r) {
          (function(e2) {
            !function(r2, n) {
              "use strict";
              if (!r2.setImmediate) {
                var i, s, t2, a, o = 1, h2 = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
                e3 = e3 && e3.setTimeout ? e3 : r2, i = {}.toString.call(r2.process) === "[object process]" ? function(e4) {
                  process.nextTick(function() {
                    c2(e4);
                  });
                } : function() {
                  if (r2.postMessage && !r2.importScripts) {
                    var e4 = true, t3 = r2.onmessage;
                    return r2.onmessage = function() {
                      e4 = false;
                    }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
                  }
                }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d2, false) : r2.attachEvent("onmessage", d2), function(e4) {
                  r2.postMessage(a + e4, "*");
                }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
                  c2(e4.data);
                }, function(e4) {
                  t2.port2.postMessage(e4);
                }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                  var t3 = l.createElement("script");
                  t3.onreadystatechange = function() {
                    c2(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                  }, s.appendChild(t3);
                }) : function(e4) {
                  setTimeout(c2, 0, e4);
                }, e3.setImmediate = function(e4) {
                  typeof e4 != "function" && (e4 = new Function("" + e4));
                  for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++)
                    t3[r3] = arguments[r3 + 1];
                  var n2 = { callback: e4, args: t3 };
                  return h2[o] = n2, i(o), o++;
                }, e3.clearImmediate = f;
              }
              function f(e4) {
                delete h2[e4];
              }
              function c2(e4) {
                if (u)
                  setTimeout(c2, 0, e4);
                else {
                  var t3 = h2[e4];
                  if (t3) {
                    u = true;
                    try {
                      !function(e5) {
                        var t4 = e5.callback, r3 = e5.args;
                        switch (r3.length) {
                          case 0:
                            t4();
                            break;
                          case 1:
                            t4(r3[0]);
                            break;
                          case 2:
                            t4(r3[0], r3[1]);
                            break;
                          case 3:
                            t4(r3[0], r3[1], r3[2]);
                            break;
                          default:
                            t4.apply(n, r3);
                        }
                      }(t3);
                    } finally {
                      f(e4), u = false;
                    }
                  }
                }
              }
              function d2(e4) {
                e4.source === r2 && typeof e4.data == "string" && e4.data.indexOf(a) === 0 && c2(+e4.data.slice(a.length));
              }
            }(typeof self == "undefined" ? e2 === void 0 ? this : e2 : self);
          }).call(this, typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
        }, {}] }, {}, [10])(10);
      });
    }
  });

  // __tmp__/static/js/event-emitter.js
  var require_event_emitter = __commonJS({
    "__tmp__/static/js/event-emitter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EventEmitter = void 0;
      var EventEmitter = class {
        constructor(events) {
          this.events = Object.fromEntries(Object.keys(events).map((k) => [k, []]));
        }
        on(name, handler) {
          this.events[name].push(handler);
        }
        emit(name, args) {
          let status = "sync";
          let _block;
          const ev = Object.assign(Object.assign({}, args), {
            cancelEvent() {
              status = "canceled";
            },
            deferEvent() {
              status = "deferred";
              return () => {
                if (_block) {
                  _block();
                }
              };
            },
            then(block) {
              if (status === "sync") {
                block();
              } else if (status === "deferred") {
                _block = block;
              }
            }
          });
          for (const handler of this.events[name]) {
            handler(ev);
          }
          return ev;
        }
      };
      exports.EventEmitter = EventEmitter;
    }
  });

  // __tmp__/static/js/tabs.js
  var require_tabs = __commonJS({
    "__tmp__/static/js/tabs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getPreviousAndNext = exports.Tabs = void 0;
      var event_emitter_1 = require_event_emitter();
      var Tabs = class {
        constructor(options = {}) {
          this._currentTab = "";
          this.tabEvents = new event_emitter_1.EventEmitter({
            beforeSwitch: true,
            afterSwitch: true
          });
          $("*[data-tab]").on("click", (e) => {
            const tab = $(e.target);
            const tabName = tab.data("tab");
            e.preventDefault();
            this.switchToTab(tabName);
          });
          let initialTab = options.initialTab;
          if (!initialTab && window.location.hash) {
            const hashFragment = window.location.hash.replace(/^#/, "");
            initialTab = hashFragment;
          }
          if (!initialTab) {
            initialTab = $(".tab:first").attr("data-tab");
          }
          if (initialTab) {
            this.switchToTab(initialTab);
          }
        }
        switchToTab(tabName) {
          const doSwitch = () => {
            const oldTab = this._currentTab;
            this._currentTab = tabName;
            const hashFragment = tabName !== "level" ? tabName : "";
            if (window.history) {
              window.history.replaceState(null, "", "#" + hashFragment);
            }
            const tab = $('*[data-tab="' + tabName + '"]');
            const allTabs = tab.siblings("*[data-tab]");
            const target = $('*[data-tabtarget="' + tabName + '"]');
            const allTargets = target.siblings("*[data-tabtarget]");
            allTabs.removeClass("tab-selected");
            tab.addClass("tab-selected");
            allTargets.addClass("hidden");
            target.removeClass("hidden");
            this.tabEvents.emit("afterSwitch", { oldTab, newTab: tabName });
          };
          if (this._currentTab != "") {
            const event2 = this.tabEvents.emit("beforeSwitch", { oldTab: this._currentTab, newTab: tabName });
            event2.then(doSwitch);
          } else {
            doSwitch();
          }
        }
        get currentTab() {
          return this._currentTab;
        }
        on(key, handler) {
          const ret = this.tabEvents.on(key, handler);
          if (key === "afterSwitch") {
            this.tabEvents.emit("afterSwitch", { oldTab: "", newTab: this._currentTab });
          }
          return ret;
        }
      };
      exports.Tabs = Tabs;
      function getPreviousAndNext2() {
        const selected = document.querySelector(".tab-selected");
        if (!selected)
          return [];
        const i = parseInt(selected.getAttribute("tabindex") || "0");
        const prev = document.querySelector(`.tab[tabindex='${i - 1}']`);
        const next = document.querySelector(`.tab[tabindex='${i + 1}']`);
        return [prev, next];
      }
      exports.getPreviousAndNext = getPreviousAndNext2;
    }
  });

  // __tmp__/static/js/pythonPrefixes.js
  var require_pythonPrefixes = __commonJS({
    "__tmp__/static/js/pythonPrefixes.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.normal_prefix = exports.pygame_prefix = exports.turtle_prefix = void 0;
      exports.turtle_prefix = `# coding=utf8

import random  # noqa F401
import time  # noqa F401
import turtle

t = turtle.Turtle()
t.shape("turtle")
t.hideturtle()
t.penup()
t.left(90)
t.pendown()
t.speed(3)
t.showturtle()
`;
      exports.pygame_prefix = `# coding=utf8

import pygame  # noqa F401
import buttons  # noqa F401

pygame.init()
canvas = pygame.display.set_mode((711, 300))
canvas.fill(pygame.Color(247, 250, 252, 255))

pygame_end = False
button_list = []


def create_button(name):
    if name not in button_list:
        button_list.append(name)
        buttons.add(name)
`;
      exports.normal_prefix = `# coding=utf8

import random  # noqa F401
import time  # noqa F401

try:
    import extensions  # noqa F401
except ModuleNotFoundError:
    # This is done because 'extensions' is not a python module but rather a Skulpt JS extension
    # These functions are defined in skulpt-stdlib-extensions.js
    # When running tests in test_python_prefixes it wil raise ModuleNotFoundError
    pass

global int_saver
global convert_numerals  # needed for recursion to work
int_saver = int


def int(s):
    if isinstance(s, str):
        numerals_dict = {'0': '0', '1': '1', '2': '2', '3': '3', '4': '4', '5': '5', '6': '6', '7': '7', '8': '8',
                         '9': '9', '\u{11066}': '0', '\u{11067}': '1', '\u{11068}': '2', '\u{11069}': '3', '\u{1106A}': '4', '\u{1106B}': '5', '\u{1106C}': '6', '\u{1106D}': '7',
                         '\u{1106E}': '8', '\u{1106F}': '9', '\u0966': '0', '\u0967': '1', '\u0968': '2', '\u0969': '3', '\u096A': '4', '\u096B': '5', '\u096C': '6',
                         '\u096D': '7', '\u096E': '8', '\u096F': '9', '\u0AE6': '0', '\u0AE7': '1', '\u0AE8': '2', '\u0AE9': '3', '\u0AEA': '4', '\u0AEB': '5',
                         '\u0AEC': '6', '\u0AED': '7', '\u0AEE': '8', '\u0AEF': '9', '\u0A66': '0', '\u0A67': '1', '\u0A68': '2', '\u0A69': '3', '\u0A6A': '4',
                         '\u0A6B': '5', '\u0A6C': '6', '\u0A6D': '7', '\u0A6E': '8', '\u0A6F': '9', '\u09E6': '0', '\u09E7': '1', '\u09E8': '2', '\u09E9': '3',
                         '\u09EA': '4', '\u09EB': '5', '\u09EC': '6', '\u09ED': '7', '\u09EE': '8', '\u09EF': '9', '\u0CE6': '0', '\u0CE7': '1', '\u0CE8': '2',
                         '\u0CE9': '3', '\u0CEA': '4', '\u0CEB': '5', '\u0CEC': '6', '\u0CED': '7', '\u0CEE': '8', '\u0CEF': '9', '\u0B66': '0', '\u0B67': '1',
                         '\u0B68': '2', '\u0B69': '3', '\u0B6A': '4', '\u0B6B': '5', '\u0B6C': '6', '\u0B6D': '7', '\u0B6E': '8', '\u0B6F': '9', '\u0D66': '0',
                         '\u0D67': '1', '\u0D68': '2', '\u0D69': '3', '\u0D6A': '4', '\u0D6B': '5', '\u0D6C': '6', '\u0D6D': '7', '\u0D6E': '8', '\u0D6F': '9',
                         '\u0BE6': '0', '\u0BE7': '1', '\u0BE8': '2', '\u0BE9': '3', '\u0BEA': '4', '\u0BEB': '5', '\u0BEC': '6', '\u0BED': '7', '\u0BEE': '8',
                         '\u0BEF': '9', '\u0C66': '0', '\u0C67': '1', '\u0C68': '2', '\u0C69': '3', '\u0C6A': '4', '\u0C6B': '5', '\u0C6C': '6', '\u0C6D': '7',
                         '\u0C6E': '8', '\u0C6F': '9', '\u1040': '0', '\u1041': '1', '\u1042': '2', '\u1043': '3', '\u1044': '4', '\u1045': '5', '\u1046': '6',
                         '\u1047': '7', '\u1048': '8', '\u1049': '9', '\u0F20': '0', '\u0F21': '1', '\u0F22': '2', '\u0F23': '3', '\u0F24': '4', '\u0F25': '5',
                         '\u0F26': '6', '\u0F27': '7', '\u0F28': '8', '\u0F29': '9', '\u1810': '0', '\u1811': '1', '\u1812': '2', '\u1813': '3', '\u1814': '4',
                         '\u1815': '5', '\u1816': '6', '\u1817': '7', '\u1818': '8', '\u1819': '9', '\u17E0': '0', '\u17E1': '1', '\u17E2': '2', '\u17E3': '3',
                         '\u17E4': '4', '\u17E5': '5', '\u17E6': '6', '\u17E7': '7', '\u17E8': '8', '\u17E9': '9', '\u0E50': '0', '\u0E51': '1', '\u0E52': '2',
                         '\u0E53': '3', '\u0E54': '4', '\u0E55': '5', '\u0E56': '6', '\u0E57': '7', '\u0E58': '8', '\u0E59': '9', '\u0ED0': '0', '\u0ED1': '1',
                         '\u0ED2': '2', '\u0ED3': '3', '\u0ED4': '4', '\u0ED5': '5', '\u0ED6': '6', '\u0ED7': '7', '\u0ED8': '8', '\u0ED9': '9', '\uA9D0': '0',
                         '\uA9D1': '1', '\uA9D2': '2', '\uA9D3': '3', '\uA9D4': '4', '\uA9D5': '5', '\uA9D6': '6', '\uA9D7': '7', '\uA9D8': '8', '\uA9D9': '9',
                         '\u0660': '0', '\u0661': '1', '\u0662': '2', '\u0663': '3', '\u0664': '4', '\u0665': '5', '\u0666': '6', '\u0667': '7', '\u0668': '8',
                         '\u0669': '9', '\u06F0': '0', '\u06F1': '1', '\u06F2': '2', '\u06F3': '3', '\u06F4': '4', '\u06F5': '5', '\u06F6': '6', '\u06F7': '7',
                         '\u06F8': '8', '\u06F9': '9', '\u3007': '0', '\u4E00': '1', '\u4E8C': '2', '\u4E09': '3', '\u56DB': '4', '\u4E94': '5', '\u516D': '6',
                         '\u4E03': '7', '\u516B': '8', '\u4E5D': '9', '\u96F6': '0'}
        latin_numerals = ''.join([numerals_dict.get(letter, letter) for letter in s])
        return int_saver(latin_numerals)
    return (int_saver(s))


def convert_numerals(alphabet, number):
    numerals_dict_return = {
        'Latin': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
        'Brahmi': ['\u{11066}', '\u{11067}', '\u{11068}', '\u{11069}', '\u{1106A}', '\u{1106B}', '\u{1106C}', '\u{1106D}', '\u{1106E}', '\u{1106F}'],
        'Devanagari': ['\u0966', '\u0967', '\u0968', '\u0969', '\u096A', '\u096B', '\u096C', '\u096D', '\u096E', '\u096F'],
        'Gujarati': ['\u0AE6', '\u0AE7', '\u0AE8', '\u0AE9', '\u0AEA', '\u0AEB', '\u0AEC', '\u0AED', '\u0AEE', '\u0AEF'],
        'Gurmukhi': ['\u0A66', '\u0A67', '\u0A68', '\u0A69', '\u0A6A', '\u0A6B', '\u0A6C', '\u0A6D', '\u0A6E', '\u0A6F'],
        'Bengali': ['\u09E6', '\u09E7', '\u09E8', '\u09E9', '\u09EA', '\u09EB', '\u09EC', '\u09ED', '\u09EE', '\u09EF'],
        'Kannada': ['\u0CE6', '\u0CE7', '\u0CE8', '\u0CE9', '\u0CEA', '\u0CEB', '\u0CEC', '\u0CED', '\u0CEE', '\u0CEF'],
        'Odia': ['\u0B66', '\u0B67', '\u0B68', '\u0B69', '\u0B6A', '\u0B6B', '\u0B6C', '\u0B6D', '\u0B6E', '\u0B6F'],
        'Malayalam': ['\u0D66', '\u0D67', '\u0D68', '\u0D69', '\u0D6A', '\u0D6B', '\u0D6C', '\u0D6D', '\u0D6E', '\u0D6F'],
        'Tamil': ['\u0BE6', '\u0BE7', '\u0BE8', '\u0BE9', '\u0BEA', '\u0BEB', '\u0BEC', '\u0BED', '\u0BEE', '\u0BEF'],
        'Telugu': ['\u0C66', '\u0C67', '\u0C68', '\u0C69', '\u0C6A', '\u0C6B', '\u0C6C', '\u0C6D', '\u0C6E', '\u0C6F'],
        'Burmese': ['\u1040', '\u1041', '\u1042', '\u1043', '\u1044', '\u1045', '\u1046', '\u1047', '\u1048', '\u1049'],
        'Tibetan': ['\u0F20', '\u0F21', '\u0F22', '\u0F23', '\u0F24', '\u0F25', '\u0F26', '\u0F27', '\u0F28', '\u0F29'],
        'Mongolian': ['\u1810', '\u1811', '\u1812', '\u1813', '\u1814', '\u1815', '\u1816', '\u1817', '\u1818', '\u1819'],
        'Khmer': ['\u17E0', '\u17E1', '\u17E2', '\u17E3', '\u17E4', '\u17E5', '\u17E6', '\u17E7', '\u17E8', '\u17E9'],
        'Thai': ['\u0E50', '\u0E51', '\u0E52', '\u0E53', '\u0E54', '\u0E55', '\u0E56', '\u0E57', '\u0E58', '\u0E59'],
        'Lao': ['\u0ED0', '\u0ED1', '\u0ED2', '\u0ED3', '\u0ED4', '\u0ED5', '\u0ED6', '\u0ED7', '\u0ED8', '\u0ED9'],
        'Javanese': ['\uA9D0', '\uA9D1', '\uA9D2', '\uA9D3', '\uA9D4', '\uA9D5', '\uA9D6', '\uA9D7', '\uA9D8', '\uA9D9'],
        'Arabic': ['\u0660', '\u0661', '\u0662', '\u0663', '\u0664', '\u0665', '\u0666', '\u0667', '\u0668', '\u0669'],
        'Persian': ['\u06F0', '\u06F1', '\u06F2', '\u06F3', '\u06F4', '\u06F5', '\u06F6', '\u06F7', '\u06F8', '\u06F9'],
        'Urdu': ['\u06F0', '\u06F1', '\u06F2', '\u06F3', '\u06F4', '\u06F5', '\u06F6', '\u06F7', '\u06F8', '\u06F9']
    }

    number = str(number)
    T = str

    sign = ''
    if number[0] == '-':
        sign = '-'
        number = number[1:]

    if number.replace('.', '', 1).isnumeric():
        numerals_list = numerals_dict_return[alphabet]
        if '.' in number:
            tokens = number.split('.')
            all_numerals_converted = [numerals_list[int(digit)] for digit in tokens[0]]
            all_numerals_converted.append('.')
            all_numerals_converted.extend(numerals_list[int(digit)] for digit in tokens[1])
            if alphabet == 'Latin':
                T = float
        else:
            all_numerals_converted = [numerals_list[int(digit)] for digit in number]
            if alphabet == 'Latin':
                T = int
        number = ''.join(all_numerals_converted)
    return T(f'{sign}{number}')
`;
    }
  });

  // __tmp__/static/js/types.js
  var require_types = __commonJS({
    "__tmp__/static/js/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isServerSaveInfo = void 0;
      function isServerSaveInfo(x) {
        return !!x && typeof x === "object" && !!x.id;
      }
      exports.isServerSaveInfo = isServerSaveInfo;
    }
  });

  // __tmp__/static/js/tutorials/utils.js
  var require_utils = __commonJS({
    "__tmp__/static/js/tutorials/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.tutorialPopup = exports.relocatePopup = exports.removeBorder = exports.addHighlightBorder = void 0;
      var modal_1 = require_modal();
      function addHighlightBorder(element_id) {
        $("#" + element_id).addClass("border-2 rounded-lg border-red-500");
      }
      exports.addHighlightBorder = addHighlightBorder;
      function removeBorder(element_id) {
        $("#" + element_id).removeClass("border-2 border-red-500");
      }
      exports.removeBorder = removeBorder;
      function relocatePopup(x, y2) {
        $("#tutorial-pop-up").css({ "top": "20%", "left": "50%" });
        if (x && y2) {
          let left = x.toString() + "%";
          let top = y2.toString() + "%";
          $("#tutorial-pop-up").css({ "top": top, "left": left });
        }
      }
      exports.relocatePopup = relocatePopup;
      function tutorialPopup(current_level, step) {
        let route = "/get_tutorial_step/" + current_level + "/";
        $.ajax({
          type: "GET",
          url: route + step.toString(),
          dataType: "json"
        }).done(function(response) {
          $("#tutorial_title").text(response.title);
          $("#tutorial_text").text(response.text);
          $("#tutorial-pop-up").fadeIn(800);
        }).fail(function(response) {
          modal_1.modal.notifyError(response.responseText);
        });
      }
      exports.tutorialPopup = tutorialPopup;
    }
  });

  // __tmp__/static/js/browser-helpers/unsaved-changes.js
  var require_unsaved_changes = __commonJS({
    "__tmp__/static/js/browser-helpers/unsaved-changes.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.clearUnsavedChanges = exports.markUnsavedChanges = exports.hasUnsavedChanges = void 0;
      var client_messages_1 = require_client_messages();
      function unloadHandler(event2) {
        event2.preventDefault();
        return event2.returnValue = client_messages_1.ClientMessages["Unsaved_Changes"];
      }
      var unsavedChanges = false;
      function hasUnsavedChanges() {
        return unsavedChanges;
      }
      exports.hasUnsavedChanges = hasUnsavedChanges;
      function markUnsavedChanges() {
        unsavedChanges = true;
        window.addEventListener("beforeunload", unloadHandler, { capture: true });
      }
      exports.markUnsavedChanges = markUnsavedChanges;
      function clearUnsavedChanges() {
        unsavedChanges = false;
        window.removeEventListener("beforeunload", unloadHandler, { capture: true });
      }
      exports.clearUnsavedChanges = clearUnsavedChanges;
    }
  });

  // __tmp__/static/js/tutorials/intro.js
  var require_intro = __commonJS({
    "__tmp__/static/js/tutorials/intro.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.callNextIntroStep = exports.startIntro = void 0;
      var app_1 = require_app();
      var utils_1 = require_utils();
      var unsaved_changes_1 = require_unsaved_changes();
      var current_step = 0;
      function startIntro() {
        current_step = 1;
        $("#adventures").hide();
        $("#variables_container").hide();
        app_1.theGlobalEditor.contents = "";
        (0, utils_1.tutorialPopup)("intro", current_step);
      }
      exports.startIntro = startIntro;
      function callNextIntroStep() {
        current_step += 1;
        if (current_step == 2) {
          codeEditorStep();
        } else if (current_step == 3) {
          codeOutputStep();
        } else if (current_step == 4) {
          runButtonStep();
        } else if (current_step == 5) {
          tryRunButtonStep();
        } else if (current_step == 6) {
          speakAloudStep();
        } else if (current_step == 7) {
          runSpeakAloudStep();
        } else if (current_step == 8) {
          nextLevelStep();
        } else if (current_step == 9) {
          levelDefaultStep();
        } else if (current_step == 10) {
          adventureTabsStep();
        } else if (current_step == 11) {
          parsonsTabStep();
        } else if (current_step == 12) {
          quizTabStep();
        } else if (current_step == 13) {
          saveShareStep();
        } else if (current_step == 14) {
          cheatsheetStep();
        } else if (current_step == 15) {
          (0, app_1.pushAchievement)("well_begun_is_half_done");
          $("#achievement_pop-up").removeClass("z-10");
          $("#achievement_pop-up").addClass("z-50");
          setTimeout(function() {
            if ($("#achievement_pop-up").is(":visible")) {
              setTimeout(function() {
                endTutorial();
                $("#achievement_pop-up").removeClass("z-50");
                $("#achievement_pop-up").addClass("z-10");
              }, 5e3);
            } else {
              endTutorial();
              $("#achievement_pop-up").removeClass("z-50");
              $("#achievement_pop-up").addClass("z-10");
            }
          }, 500);
        } else {
          location.replace("/hedy");
        }
      }
      exports.callNextIntroStep = callNextIntroStep;
      function codeEditorStep() {
        $("#editor").addClass("z-40");
        (0, utils_1.addHighlightBorder)("editor");
        (0, utils_1.relocatePopup)(65, 30);
        app_1.theGlobalEditor.contents = "print ___";
        (0, utils_1.tutorialPopup)("intro", current_step);
      }
      function codeOutputStep() {
        (0, utils_1.removeBorder)("editor");
        $("#code_output").addClass("z-40");
        (0, utils_1.addHighlightBorder)("code_output");
        (0, app_1.runit)(1, "en", "", "run", function() {
          $("#output").focus();
        });
        (0, utils_1.relocatePopup)(35, 30);
        (0, utils_1.tutorialPopup)("intro", current_step);
      }
      function runButtonStep() {
        (0, utils_1.removeBorder)("code_output");
        $("#code_related_buttons").show();
        $("#runButtonContainer").addClass("z-40");
        (0, utils_1.addHighlightBorder)("runButtonContainer");
        (0, utils_1.relocatePopup)(50, 30);
        (0, utils_1.tutorialPopup)("intro", current_step);
      }
      function tryRunButtonStep() {
        $.ajax({
          type: "GET",
          url: "/get_tutorial_step/intro/code_snippet/",
          dataType: "json"
        }).done(function(response) {
          app_1.theGlobalEditor.contents = response.code;
        }).fail(function() {
          app_1.theGlobalEditor.contents = "print Hello world!\nprint I'm learning Hedy with the tutorial!";
        });
        (0, utils_1.relocatePopup)(50, 70);
        (0, utils_1.tutorialPopup)("intro", current_step);
      }
      function speakAloudStep() {
        (0, utils_1.removeBorder)("runButtonContainer");
        $("#editor").removeClass("z-40");
        $("#code_output").removeClass("z-40");
        $("#runButtonContainer").removeClass("z-40");
        $("#speak_container").addClass("z-40 bg-white relative");
        (0, utils_1.addHighlightBorder)("speak_container");
        (0, utils_1.relocatePopup)(50, 30);
        (0, utils_1.tutorialPopup)("intro", current_step);
      }
      function runSpeakAloudStep() {
        $("#editor").addClass("z-40");
        $("#code_output").addClass("z-40");
        $("#runButtonContainer").addClass("z-40");
        (0, utils_1.relocatePopup)(50, 70);
        (0, utils_1.tutorialPopup)("intro", current_step);
      }
      function nextLevelStep() {
        (0, utils_1.removeBorder)("speak_container");
        $("#editor").removeClass("z-40");
        $("#code_output").removeClass("z-40");
        $("#runButtonContainer").removeClass("z-40");
        $("#speak_container").removeClass("z-40 bg-white relative");
        $("#next_level_button").addClass("z-40");
        $("#next_level_button").removeAttr("onclick");
        (0, utils_1.addHighlightBorder)("next_level_button");
        (0, utils_1.relocatePopup)(50, 30);
        (0, utils_1.tutorialPopup)("intro", current_step);
      }
      function levelDefaultStep() {
        (0, utils_1.removeBorder)("next_level_button");
        $("#next_level_button").removeClass("z-40");
        $("#code_content_container").addClass("z-40");
        $("#adventures").addClass("z-40 bg-gray-100");
        $("#adventures").show();
        (0, unsaved_changes_1.clearUnsavedChanges)();
        (0, utils_1.addHighlightBorder)("adventures");
        (0, utils_1.relocatePopup)(50, 40);
        (0, utils_1.tutorialPopup)("intro", current_step);
      }
      function adventureTabsStep() {
        $("#adventures-buttons").children().each(function() {
          if ($(this).attr("data-tab") == "story") {
            (0, unsaved_changes_1.clearUnsavedChanges)();
            $(this).click();
          }
        });
        (0, utils_1.tutorialPopup)("intro", current_step);
      }
      function parsonsTabStep() {
        $("#adventures-buttons").children().each(function() {
          if ($(this).attr("data-tab") == "parsons") {
            (0, unsaved_changes_1.clearUnsavedChanges)();
            $(this).click();
          }
        });
        (0, utils_1.tutorialPopup)("intro", current_step);
      }
      function quizTabStep() {
        $("#adventures-buttons").children().each(function() {
          if ($(this).attr("data-tab") == "quiz") {
            (0, unsaved_changes_1.clearUnsavedChanges)();
            $(this).click();
          }
        });
        (0, utils_1.tutorialPopup)("intro", current_step);
      }
      function saveShareStep() {
        $("#adventures-buttons").children().each(function() {
          if ($(this).attr("data-tab") == "default") {
            (0, unsaved_changes_1.clearUnsavedChanges)();
            $(this).click();
          }
        });
        (0, utils_1.removeBorder)("adventures");
        $("#code_content_container").removeClass("z-40");
        $("#level-header").addClass("z-40");
        $("#cheatsheet_container").hide();
        (0, utils_1.addHighlightBorder)("level-header");
        $("#save_program_button").removeAttr("onclick");
        $("#share_program_button").removeAttr("onclick");
        (0, utils_1.relocatePopup)(50, 30);
        (0, utils_1.tutorialPopup)("intro", current_step);
      }
      function cheatsheetStep() {
        $("#cheatsheet_container").show();
        $("#code_output").removeClass("z-40");
        $("#adventures").removeClass("z-40");
        $("#cheatsheet_dropdown").addClass("z-40");
        $("#cheatsheet_dropdown").show();
        (0, utils_1.tutorialPopup)("intro", current_step);
      }
      function endTutorial() {
        (0, utils_1.removeBorder)("level-header");
        $("#level-header").removeClass("z-40");
        $("#cheatsheet_dropdown").removeClass("z-40");
        $("#cheatsheet_dropdown").hide();
        (0, utils_1.relocatePopup)(50, 15);
        (0, utils_1.tutorialPopup)("intro", current_step);
      }
    }
  });

  // __tmp__/static/js/tutorials/teacher.js
  var require_teacher = __commonJS({
    "__tmp__/static/js/tutorials/teacher.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.callTeacherNextStep = exports.startTeacher = void 0;
      var app_1 = require_app();
      var utils_1 = require_utils();
      var current_step = 0;
      function startTeacher() {
        current_step = 1;
        (0, utils_1.tutorialPopup)("teacher", current_step);
      }
      exports.startTeacher = startTeacher;
      function callTeacherNextStep() {
        current_step += 1;
        if (current_step == 2) {
          classStep();
        } else if (current_step == 3) {
          customizeClassStep();
        } else if (current_step == 4) {
          adventureStep();
        } else if (current_step == 5) {
          multipleAccountsStep();
        } else if (current_step == 6) {
          documentationStep();
        } else if (current_step == 7) {
          (0, app_1.pushAchievement)("ring_the_bell");
          $("#achievement_pop-up").removeClass("z-10");
          $("#achievement_pop-up").addClass("z-50");
          setTimeout(function() {
            if ($("#achievement_pop-up").is(":visible")) {
              setTimeout(function() {
                teacherEndStep();
                $("#achievement_pop-up").removeClass("z-50");
                $("#achievement_pop-up").addClass("z-10");
              }, 5e3);
            } else {
              teacherEndStep();
              $("#achievement_pop-up").removeClass("z-50");
              $("#achievement_pop-up").addClass("z-10");
            }
          }, 500);
        } else {
          location.replace("/for-teachers");
        }
      }
      exports.callTeacherNextStep = callTeacherNextStep;
      function classStep() {
        $("#auth_main_container").addClass("z-40");
        $("#teacher_classes").addClass("z-40 bg-gray-100");
        (0, utils_1.addHighlightBorder)("teacher_classes");
        (0, utils_1.relocatePopup)(50, 40);
        (0, utils_1.tutorialPopup)("teacher", current_step);
      }
      function customizeClassStep() {
        (0, utils_1.tutorialPopup)("teacher", current_step);
      }
      function adventureStep() {
        $("#teacher_adventures").addClass("z-40 bg-gray-100");
        (0, utils_1.removeBorder)("teacher_classes");
        (0, utils_1.addHighlightBorder)("teacher_adventures");
        (0, utils_1.relocatePopup)(50, 70);
        (0, utils_1.tutorialPopup)("teacher", current_step);
      }
      function multipleAccountsStep() {
        $("#teacher_accounts").addClass("z-40 bg-gray-100");
        (0, utils_1.removeBorder)("teacher_adventures");
        (0, utils_1.addHighlightBorder)("teacher_accounts");
        (0, utils_1.relocatePopup)(50, 20);
        (0, utils_1.tutorialPopup)("teacher", current_step);
      }
      function documentationStep() {
        $("#teacher_documentation").addClass("z-40 bg-gray-100");
        (0, utils_1.removeBorder)("teacher_accounts");
        (0, utils_1.addHighlightBorder)("teacher_documentation");
        (0, utils_1.tutorialPopup)("teacher", current_step);
      }
      function teacherEndStep() {
        (0, utils_1.removeBorder)("teacher_documentation");
        (0, utils_1.tutorialPopup)("teacher", current_step);
      }
    }
  });

  // __tmp__/static/js/tutorials/level1.js
  var require_level1 = __commonJS({
    "__tmp__/static/js/tutorials/level1.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.callNextStepLevel1 = exports.startLevel1 = void 0;
      var app_1 = require_app();
      var utils_1 = require_utils();
      var current_step = 0;
      function startLevel1() {
        current_step = 1;
        (0, utils_1.tutorialPopup)("1", current_step);
      }
      exports.startLevel1 = startLevel1;
      function callNextStepLevel1() {
        current_step += 1;
        if (current_step == 2) {
          app_1.theGlobalEditor.contents = "print Hello world!";
          (0, utils_1.relocatePopup)(50, 70);
          (0, utils_1.tutorialPopup)("1", 2);
        } else if (current_step == 3) {
          location.replace("/hedy");
        }
      }
      exports.callNextStepLevel1 = callNextStepLevel1;
    }
  });

  // __tmp__/static/js/tutorials/tutorial.js
  var require_tutorial = __commonJS({
    "__tmp__/static/js/tutorials/tutorial.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.startTeacherTutorial = exports.startLevelTutorial = exports.startIntroTutorial = exports.initializeTutorial = void 0;
      var intro_1 = require_intro();
      var teacher_1 = require_teacher();
      var level1_1 = require_level1();
      var current_level = "";
      function initializeTutorial() {
        $("#tutorial_next_button").off("click").on("click", () => {
          $("#tutorial-pop-up").hide();
          if (current_level == "intro") {
            return (0, intro_1.callNextIntroStep)();
          } else if (current_level == "teacher") {
            return (0, teacher_1.callTeacherNextStep)();
          }
          return callNextLevelStep(current_level);
        });
      }
      exports.initializeTutorial = initializeTutorial;
      function startIntroTutorial() {
        $("#tutorial-mask").show();
        current_level = "intro";
        (0, intro_1.startIntro)();
      }
      exports.startIntroTutorial = startIntroTutorial;
      function startLevelTutorial(level) {
        $("#tutorial-mask").show();
        current_level = level;
        startLevel(level);
      }
      exports.startLevelTutorial = startLevelTutorial;
      function startTeacherTutorial() {
        $("#tutorial-mask").show();
        current_level = "teacher";
        (0, teacher_1.startTeacher)();
      }
      exports.startTeacherTutorial = startTeacherTutorial;
      function startLevel(current_level2) {
        if (current_level2 == "1") {
          (0, level1_1.startLevel1)();
        }
      }
      function callNextLevelStep(current_level2) {
        if (current_level2 == "1") {
          (0, level1_1.callNextStepLevel1)();
        }
      }
    }
  });

  // __tmp__/static/js/editor.js
  var require_editor = __commonJS({
    "__tmp__/static/js/editor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EditorType = void 0;
      var EditorType;
      (function(EditorType2) {
        EditorType2[EditorType2["MAIN"] = 0] = "MAIN";
        EditorType2[EditorType2["MODAL"] = 1] = "MODAL";
        EditorType2[EditorType2["COMMON_MISTAKES"] = 2] = "COMMON_MISTAKES";
        EditorType2[EditorType2["CHEATSHEET"] = 3] = "CHEATSHEET";
        EditorType2[EditorType2["PARSONS"] = 4] = "PARSONS";
        EditorType2[EditorType2["EXAMPLE"] = 5] = "EXAMPLE";
      })(EditorType || (exports.EditorType = EditorType = {}));
    }
  });

  // node_modules/@codemirror/state/dist/index.cjs
  var require_dist = __commonJS({
    "node_modules/@codemirror/state/dist/index.cjs"(exports) {
      "use strict";
      var Text = class {
        lineAt(pos) {
          if (pos < 0 || pos > this.length)
            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
          return this.lineInner(pos, false, 1, 0);
        }
        line(n) {
          if (n < 1 || n > this.lines)
            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
          return this.lineInner(n, true, 1, 0);
        }
        replace(from, to2, text) {
          [from, to2] = clip(this, from, to2);
          let parts = [];
          this.decompose(0, from, parts, 2);
          if (text.length)
            text.decompose(0, text.length, parts, 1 | 2);
          this.decompose(to2, this.length, parts, 1);
          return TextNode.from(parts, this.length - (to2 - from) + text.length);
        }
        append(other) {
          return this.replace(this.length, this.length, other);
        }
        slice(from, to2 = this.length) {
          [from, to2] = clip(this, from, to2);
          let parts = [];
          this.decompose(from, to2, parts, 0);
          return TextNode.from(parts, to2 - from);
        }
        eq(other) {
          if (other == this)
            return true;
          if (other.length != this.length || other.lines != this.lines)
            return false;
          let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
          let a = new RawTextCursor(this), b = new RawTextCursor(other);
          for (let skip = start, pos = start; ; ) {
            a.next(skip);
            b.next(skip);
            skip = 0;
            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
              return false;
            pos += a.value.length;
            if (a.done || pos >= end)
              return true;
          }
        }
        iter(dir = 1) {
          return new RawTextCursor(this, dir);
        }
        iterRange(from, to2 = this.length) {
          return new PartialTextCursor(this, from, to2);
        }
        iterLines(from, to2) {
          let inner;
          if (from == null) {
            inner = this.iter();
          } else {
            if (to2 == null)
              to2 = this.lines + 1;
            let start = this.line(from).from;
            inner = this.iterRange(start, Math.max(start, to2 == this.lines + 1 ? this.length : to2 <= 1 ? 0 : this.line(to2 - 1).to));
          }
          return new LineCursor(inner);
        }
        toString() {
          return this.sliceString(0);
        }
        toJSON() {
          let lines = [];
          this.flatten(lines);
          return lines;
        }
        constructor() {
        }
        static of(text) {
          if (text.length == 0)
            throw new RangeError("A document must have at least one line");
          if (text.length == 1 && !text[0])
            return Text.empty;
          return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
        }
      };
      var TextLeaf = class extends Text {
        constructor(text, length = textLength(text)) {
          super();
          this.text = text;
          this.length = length;
        }
        get lines() {
          return this.text.length;
        }
        get children() {
          return null;
        }
        lineInner(target, isLine, line, offset) {
          for (let i = 0; ; i++) {
            let string = this.text[i], end = offset + string.length;
            if ((isLine ? line : end) >= target)
              return new Line(offset, end, line, string);
            offset = end + 1;
            line++;
          }
        }
        decompose(from, to2, target, open) {
          let text = from <= 0 && to2 >= this.length ? this : new TextLeaf(sliceText(this.text, from, to2), Math.min(to2, this.length) - Math.max(0, from));
          if (open & 1) {
            let prev = target.pop();
            let joined = appendText(text.text, prev.text.slice(), 0, text.length);
            if (joined.length <= 32) {
              target.push(new TextLeaf(joined, prev.length + text.length));
            } else {
              let mid = joined.length >> 1;
              target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
            }
          } else {
            target.push(text);
          }
        }
        replace(from, to2, text) {
          if (!(text instanceof TextLeaf))
            return super.replace(from, to2, text);
          [from, to2] = clip(this, from, to2);
          let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to2);
          let newLen = this.length + text.length - (to2 - from);
          if (lines.length <= 32)
            return new TextLeaf(lines, newLen);
          return TextNode.from(TextLeaf.split(lines, []), newLen);
        }
        sliceString(from, to2 = this.length, lineSep = "\n") {
          [from, to2] = clip(this, from, to2);
          let result = "";
          for (let pos = 0, i = 0; pos <= to2 && i < this.text.length; i++) {
            let line = this.text[i], end = pos + line.length;
            if (pos > from && i)
              result += lineSep;
            if (from < end && to2 > pos)
              result += line.slice(Math.max(0, from - pos), to2 - pos);
            pos = end + 1;
          }
          return result;
        }
        flatten(target) {
          for (let line of this.text)
            target.push(line);
        }
        scanIdentical() {
          return 0;
        }
        static split(text, target) {
          let part = [], len = -1;
          for (let line of text) {
            part.push(line);
            len += line.length + 1;
            if (part.length == 32) {
              target.push(new TextLeaf(part, len));
              part = [];
              len = -1;
            }
          }
          if (len > -1)
            target.push(new TextLeaf(part, len));
          return target;
        }
      };
      var TextNode = class extends Text {
        constructor(children, length) {
          super();
          this.children = children;
          this.length = length;
          this.lines = 0;
          for (let child of children)
            this.lines += child.lines;
        }
        lineInner(target, isLine, line, offset) {
          for (let i = 0; ; i++) {
            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
            if ((isLine ? endLine : end) >= target)
              return child.lineInner(target, isLine, line, offset);
            offset = end + 1;
            line = endLine + 1;
          }
        }
        decompose(from, to2, target, open) {
          for (let i = 0, pos = 0; pos <= to2 && i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (from <= end && to2 >= pos) {
              let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to2 ? 2 : 0));
              if (pos >= from && end <= to2 && !childOpen)
                target.push(child);
              else
                child.decompose(from - pos, to2 - pos, target, childOpen);
            }
            pos = end + 1;
          }
        }
        replace(from, to2, text) {
          [from, to2] = clip(this, from, to2);
          if (text.lines < this.lines)
            for (let i = 0, pos = 0; i < this.children.length; i++) {
              let child = this.children[i], end = pos + child.length;
              if (from >= pos && to2 <= end) {
                let updated = child.replace(from - pos, to2 - pos, text);
                let totalLines = this.lines - child.lines + updated.lines;
                if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
                  let copy = this.children.slice();
                  copy[i] = updated;
                  return new TextNode(copy, this.length - (to2 - from) + text.length);
                }
                return super.replace(pos, end, updated);
              }
              pos = end + 1;
            }
          return super.replace(from, to2, text);
        }
        sliceString(from, to2 = this.length, lineSep = "\n") {
          [from, to2] = clip(this, from, to2);
          let result = "";
          for (let i = 0, pos = 0; i < this.children.length && pos <= to2; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos > from && i)
              result += lineSep;
            if (from < end && to2 > pos)
              result += child.sliceString(from - pos, to2 - pos, lineSep);
            pos = end + 1;
          }
          return result;
        }
        flatten(target) {
          for (let child of this.children)
            child.flatten(target);
        }
        scanIdentical(other, dir) {
          if (!(other instanceof TextNode))
            return 0;
          let length = 0;
          let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
          for (; ; iA += dir, iB += dir) {
            if (iA == eA || iB == eB)
              return length;
            let chA = this.children[iA], chB = other.children[iB];
            if (chA != chB)
              return length + chA.scanIdentical(chB, dir);
            length += chA.length + 1;
          }
        }
        static from(children, length = children.reduce((l, ch2) => l + ch2.length + 1, -1)) {
          let lines = 0;
          for (let ch2 of children)
            lines += ch2.lines;
          if (lines < 32) {
            let flat = [];
            for (let ch2 of children)
              ch2.flatten(flat);
            return new TextLeaf(flat, length);
          }
          let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
          let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
          function add(child) {
            let last;
            if (child.lines > maxChunk && child instanceof TextNode) {
              for (let node of child.children)
                add(node);
            } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
              flush();
              chunked.push(child);
            } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
              currentLines += child.lines;
              currentLen += child.length + 1;
              currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
            } else {
              if (currentLines + child.lines > chunk)
                flush();
              currentLines += child.lines;
              currentLen += child.length + 1;
              currentChunk.push(child);
            }
          }
          function flush() {
            if (currentLines == 0)
              return;
            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
            currentLen = -1;
            currentLines = currentChunk.length = 0;
          }
          for (let child of children)
            add(child);
          flush();
          return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
        }
      };
      Text.empty = new TextLeaf([""], 0);
      function textLength(text) {
        let length = -1;
        for (let line of text)
          length += line.length + 1;
        return length;
      }
      function appendText(text, target, from = 0, to2 = 1e9) {
        for (let pos = 0, i = 0, first = true; i < text.length && pos <= to2; i++) {
          let line = text[i], end = pos + line.length;
          if (end >= from) {
            if (end > to2)
              line = line.slice(0, to2 - pos);
            if (pos < from)
              line = line.slice(from - pos);
            if (first) {
              target[target.length - 1] += line;
              first = false;
            } else
              target.push(line);
          }
          pos = end + 1;
        }
        return target;
      }
      function sliceText(text, from, to2) {
        return appendText(text, [""], from, to2);
      }
      var RawTextCursor = class {
        constructor(text, dir = 1) {
          this.dir = dir;
          this.done = false;
          this.lineBreak = false;
          this.value = "";
          this.nodes = [text];
          this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
        }
        nextInner(skip, dir) {
          this.done = this.lineBreak = false;
          for (; ; ) {
            let last = this.nodes.length - 1;
            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
            let size = top instanceof TextLeaf ? top.text.length : top.children.length;
            if (offset == (dir > 0 ? size : 0)) {
              if (last == 0) {
                this.done = true;
                this.value = "";
                return this;
              }
              if (dir > 0)
                this.offsets[last - 1]++;
              this.nodes.pop();
              this.offsets.pop();
            } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
              this.offsets[last] += dir;
              if (skip == 0) {
                this.lineBreak = true;
                this.value = "\n";
                return this;
              }
              skip--;
            } else if (top instanceof TextLeaf) {
              let next = top.text[offset + (dir < 0 ? -1 : 0)];
              this.offsets[last] += dir;
              if (next.length > Math.max(0, skip)) {
                this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
                return this;
              }
              skip -= next.length;
            } else {
              let next = top.children[offset + (dir < 0 ? -1 : 0)];
              if (skip > next.length) {
                skip -= next.length;
                this.offsets[last] += dir;
              } else {
                if (dir < 0)
                  this.offsets[last]--;
                this.nodes.push(next);
                this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
              }
            }
          }
        }
        next(skip = 0) {
          if (skip < 0) {
            this.nextInner(-skip, -this.dir);
            skip = this.value.length;
          }
          return this.nextInner(skip, this.dir);
        }
      };
      var PartialTextCursor = class {
        constructor(text, start, end) {
          this.value = "";
          this.done = false;
          this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
          this.pos = start > end ? text.length : 0;
          this.from = Math.min(start, end);
          this.to = Math.max(start, end);
        }
        nextInner(skip, dir) {
          if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
            this.value = "";
            this.done = true;
            return this;
          }
          skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
          let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
          if (skip > limit)
            skip = limit;
          limit -= skip;
          let { value } = this.cursor.next(skip);
          this.pos += (value.length + skip) * dir;
          this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
          this.done = !this.value;
          return this;
        }
        next(skip = 0) {
          if (skip < 0)
            skip = Math.max(skip, this.from - this.pos);
          else if (skip > 0)
            skip = Math.min(skip, this.to - this.pos);
          return this.nextInner(skip, this.cursor.dir);
        }
        get lineBreak() {
          return this.cursor.lineBreak && this.value != "";
        }
      };
      var LineCursor = class {
        constructor(inner) {
          this.inner = inner;
          this.afterBreak = true;
          this.value = "";
          this.done = false;
        }
        next(skip = 0) {
          let { done, lineBreak, value } = this.inner.next(skip);
          if (done && this.afterBreak) {
            this.value = "";
            this.afterBreak = false;
          } else if (done) {
            this.done = true;
            this.value = "";
          } else if (lineBreak) {
            if (this.afterBreak) {
              this.value = "";
            } else {
              this.afterBreak = true;
              this.next();
            }
          } else {
            this.value = value;
            this.afterBreak = false;
          }
          return this;
        }
        get lineBreak() {
          return false;
        }
      };
      if (typeof Symbol != "undefined") {
        Text.prototype[Symbol.iterator] = function() {
          return this.iter();
        };
        RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
          return this;
        };
      }
      var Line = class {
        constructor(from, to2, number, text) {
          this.from = from;
          this.to = to2;
          this.number = number;
          this.text = text;
        }
        get length() {
          return this.to - this.from;
        }
      };
      function clip(text, from, to2) {
        from = Math.max(0, Math.min(text.length, from));
        return [from, Math.max(from, Math.min(text.length, to2))];
      }
      var extend = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
      for (let i = 1; i < extend.length; i++)
        extend[i] += extend[i - 1];
      function isExtendingChar(code) {
        for (let i = 1; i < extend.length; i += 2)
          if (extend[i] > code)
            return extend[i - 1] <= code;
        return false;
      }
      function isRegionalIndicator(code) {
        return code >= 127462 && code <= 127487;
      }
      var ZWJ = 8205;
      function findClusterBreak(str, pos, forward = true, includeExtending = true) {
        return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
      }
      function nextClusterBreak(str, pos, includeExtending) {
        if (pos == str.length)
          return pos;
        if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
          pos--;
        let prev = codePointAt(str, pos);
        pos += codePointSize(prev);
        while (pos < str.length) {
          let next = codePointAt(str, pos);
          if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
            pos += codePointSize(next);
            prev = next;
          } else if (isRegionalIndicator(next)) {
            let countBefore = 0, i = pos - 2;
            while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
              countBefore++;
              i -= 2;
            }
            if (countBefore % 2 == 0)
              break;
            else
              pos += 2;
          } else {
            break;
          }
        }
        return pos;
      }
      function prevClusterBreak(str, pos, includeExtending) {
        while (pos > 0) {
          let found = nextClusterBreak(str, pos - 2, includeExtending);
          if (found < pos)
            return found;
          pos--;
        }
        return 0;
      }
      function surrogateLow(ch2) {
        return ch2 >= 56320 && ch2 < 57344;
      }
      function surrogateHigh(ch2) {
        return ch2 >= 55296 && ch2 < 56320;
      }
      function codePointAt(str, pos) {
        let code0 = str.charCodeAt(pos);
        if (!surrogateHigh(code0) || pos + 1 == str.length)
          return code0;
        let code1 = str.charCodeAt(pos + 1);
        if (!surrogateLow(code1))
          return code0;
        return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
      }
      function fromCodePoint(code) {
        if (code <= 65535)
          return String.fromCharCode(code);
        code -= 65536;
        return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      function codePointSize(code) {
        return code < 65536 ? 1 : 2;
      }
      var DefaultSplit = /\r\n?|\n/;
      exports.MapMode = void 0;
      (function(MapMode) {
        MapMode[MapMode["Simple"] = 0] = "Simple";
        MapMode[MapMode["TrackDel"] = 1] = "TrackDel";
        MapMode[MapMode["TrackBefore"] = 2] = "TrackBefore";
        MapMode[MapMode["TrackAfter"] = 3] = "TrackAfter";
      })(exports.MapMode || (exports.MapMode = {}));
      var ChangeDesc = class {
        constructor(sections) {
          this.sections = sections;
        }
        get length() {
          let result = 0;
          for (let i = 0; i < this.sections.length; i += 2)
            result += this.sections[i];
          return result;
        }
        get newLength() {
          let result = 0;
          for (let i = 0; i < this.sections.length; i += 2) {
            let ins = this.sections[i + 1];
            result += ins < 0 ? this.sections[i] : ins;
          }
          return result;
        }
        get empty() {
          return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
        }
        iterGaps(f) {
          for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
            let len = this.sections[i++], ins = this.sections[i++];
            if (ins < 0) {
              f(posA, posB, len);
              posB += len;
            } else {
              posB += ins;
            }
            posA += len;
          }
        }
        iterChangedRanges(f, individual = false) {
          iterChanges(this, f, individual);
        }
        get invertedDesc() {
          let sections = [];
          for (let i = 0; i < this.sections.length; ) {
            let len = this.sections[i++], ins = this.sections[i++];
            if (ins < 0)
              sections.push(len, ins);
            else
              sections.push(ins, len);
          }
          return new ChangeDesc(sections);
        }
        composeDesc(other) {
          return this.empty ? other : other.empty ? this : composeSets(this, other);
        }
        mapDesc(other, before = false) {
          return other.empty ? this : mapSet(this, other, before);
        }
        mapPos(pos, assoc = -1, mode = exports.MapMode.Simple) {
          let posA = 0, posB = 0;
          for (let i = 0; i < this.sections.length; ) {
            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
            if (ins < 0) {
              if (endA > pos)
                return posB + (pos - posA);
              posB += len;
            } else {
              if (mode != exports.MapMode.Simple && endA >= pos && (mode == exports.MapMode.TrackDel && posA < pos && endA > pos || mode == exports.MapMode.TrackBefore && posA < pos || mode == exports.MapMode.TrackAfter && endA > pos))
                return null;
              if (endA > pos || endA == pos && assoc < 0 && !len)
                return pos == posA || assoc < 0 ? posB : posB + ins;
              posB += ins;
            }
            posA = endA;
          }
          if (pos > posA)
            throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
          return posB;
        }
        touchesRange(from, to2 = from) {
          for (let i = 0, pos = 0; i < this.sections.length && pos <= to2; ) {
            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
            if (ins >= 0 && pos <= to2 && end >= from)
              return pos < from && end > to2 ? "cover" : true;
            pos = end;
          }
          return false;
        }
        toString() {
          let result = "";
          for (let i = 0; i < this.sections.length; ) {
            let len = this.sections[i++], ins = this.sections[i++];
            result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
          }
          return result;
        }
        toJSON() {
          return this.sections;
        }
        static fromJSON(json) {
          if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number"))
            throw new RangeError("Invalid JSON representation of ChangeDesc");
          return new ChangeDesc(json);
        }
        static create(sections) {
          return new ChangeDesc(sections);
        }
      };
      var ChangeSet = class extends ChangeDesc {
        constructor(sections, inserted) {
          super(sections);
          this.inserted = inserted;
        }
        apply(doc) {
          if (this.length != doc.length)
            throw new RangeError("Applying change set to a document with the wrong length");
          iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);
          return doc;
        }
        mapDesc(other, before = false) {
          return mapSet(this, other, before, true);
        }
        invert(doc) {
          let sections = this.sections.slice(), inserted = [];
          for (let i = 0, pos = 0; i < sections.length; i += 2) {
            let len = sections[i], ins = sections[i + 1];
            if (ins >= 0) {
              sections[i] = ins;
              sections[i + 1] = len;
              let index = i >> 1;
              while (inserted.length < index)
                inserted.push(Text.empty);
              inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);
            }
            pos += len;
          }
          return new ChangeSet(sections, inserted);
        }
        compose(other) {
          return this.empty ? other : other.empty ? this : composeSets(this, other, true);
        }
        map(other, before = false) {
          return other.empty ? this : mapSet(this, other, before, true);
        }
        iterChanges(f, individual = false) {
          iterChanges(this, f, individual);
        }
        get desc() {
          return ChangeDesc.create(this.sections);
        }
        filter(ranges) {
          let resultSections = [], resultInserted = [], filteredSections = [];
          let iter = new SectionIter(this);
          done:
            for (let i = 0, pos = 0; ; ) {
              let next = i == ranges.length ? 1e9 : ranges[i++];
              while (pos < next || pos == next && iter.len == 0) {
                if (iter.done)
                  break done;
                let len = Math.min(iter.len, next - pos);
                addSection(filteredSections, len, -1);
                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
                addSection(resultSections, len, ins);
                if (ins > 0)
                  addInsert(resultInserted, resultSections, iter.text);
                iter.forward(len);
                pos += len;
              }
              let end = ranges[i++];
              while (pos < end) {
                if (iter.done)
                  break done;
                let len = Math.min(iter.len, end - pos);
                addSection(resultSections, len, -1);
                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
                iter.forward(len);
                pos += len;
              }
            }
          return {
            changes: new ChangeSet(resultSections, resultInserted),
            filtered: ChangeDesc.create(filteredSections)
          };
        }
        toJSON() {
          let parts = [];
          for (let i = 0; i < this.sections.length; i += 2) {
            let len = this.sections[i], ins = this.sections[i + 1];
            if (ins < 0)
              parts.push(len);
            else if (ins == 0)
              parts.push([len]);
            else
              parts.push([len].concat(this.inserted[i >> 1].toJSON()));
          }
          return parts;
        }
        static of(changes, length, lineSep) {
          let sections = [], inserted = [], pos = 0;
          let total = null;
          function flush(force = false) {
            if (!force && !sections.length)
              return;
            if (pos < length)
              addSection(sections, length - pos, -1);
            let set = new ChangeSet(sections, inserted);
            total = total ? total.compose(set.map(total)) : set;
            sections = [];
            inserted = [];
            pos = 0;
          }
          function process2(spec) {
            if (Array.isArray(spec)) {
              for (let sub of spec)
                process2(sub);
            } else if (spec instanceof ChangeSet) {
              if (spec.length != length)
                throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
              flush();
              total = total ? total.compose(spec.map(total)) : spec;
            } else {
              let { from, to: to2 = from, insert: insert2 } = spec;
              if (from > to2 || from < 0 || to2 > length)
                throw new RangeError(`Invalid change range ${from} to ${to2} (in doc of length ${length})`);
              let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
              let insLen = insText.length;
              if (from == to2 && insLen == 0)
                return;
              if (from < pos)
                flush();
              if (from > pos)
                addSection(sections, from - pos, -1);
              addSection(sections, to2 - from, insLen);
              addInsert(inserted, sections, insText);
              pos = to2;
            }
          }
          process2(changes);
          flush(!total);
          return total;
        }
        static empty(length) {
          return new ChangeSet(length ? [length, -1] : [], []);
        }
        static fromJSON(json) {
          if (!Array.isArray(json))
            throw new RangeError("Invalid JSON representation of ChangeSet");
          let sections = [], inserted = [];
          for (let i = 0; i < json.length; i++) {
            let part = json[i];
            if (typeof part == "number") {
              sections.push(part, -1);
            } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
              throw new RangeError("Invalid JSON representation of ChangeSet");
            } else if (part.length == 1) {
              sections.push(part[0], 0);
            } else {
              while (inserted.length < i)
                inserted.push(Text.empty);
              inserted[i] = Text.of(part.slice(1));
              sections.push(part[0], inserted[i].length);
            }
          }
          return new ChangeSet(sections, inserted);
        }
        static createSet(sections, inserted) {
          return new ChangeSet(sections, inserted);
        }
      };
      function addSection(sections, len, ins, forceJoin = false) {
        if (len == 0 && ins <= 0)
          return;
        let last = sections.length - 2;
        if (last >= 0 && ins <= 0 && ins == sections[last + 1])
          sections[last] += len;
        else if (len == 0 && sections[last] == 0)
          sections[last + 1] += ins;
        else if (forceJoin) {
          sections[last] += len;
          sections[last + 1] += ins;
        } else
          sections.push(len, ins);
      }
      function addInsert(values, sections, value) {
        if (value.length == 0)
          return;
        let index = sections.length - 2 >> 1;
        if (index < values.length) {
          values[values.length - 1] = values[values.length - 1].append(value);
        } else {
          while (values.length < index)
            values.push(Text.empty);
          values.push(value);
        }
      }
      function iterChanges(desc, f, individual) {
        let inserted = desc.inserted;
        for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
          let len = desc.sections[i++], ins = desc.sections[i++];
          if (ins < 0) {
            posA += len;
            posB += len;
          } else {
            let endA = posA, endB = posB, text = Text.empty;
            for (; ; ) {
              endA += len;
              endB += ins;
              if (ins && inserted)
                text = text.append(inserted[i - 2 >> 1]);
              if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
                break;
              len = desc.sections[i++];
              ins = desc.sections[i++];
            }
            f(posA, endA, posB, endB, text);
            posA = endA;
            posB = endB;
          }
        }
      }
      function mapSet(setA, setB, before, mkSet = false) {
        let sections = [], insert2 = mkSet ? [] : null;
        let a = new SectionIter(setA), b = new SectionIter(setB);
        for (let inserted = -1; ; ) {
          if (a.ins == -1 && b.ins == -1) {
            let len = Math.min(a.len, b.len);
            addSection(sections, len, -1);
            a.forward(len);
            b.forward(len);
          } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
            let len = b.len;
            addSection(sections, b.ins, -1);
            while (len) {
              let piece = Math.min(a.len, len);
              if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
                addSection(sections, 0, a.ins);
                if (insert2)
                  addInsert(insert2, sections, a.text);
                inserted = a.i;
              }
              a.forward(piece);
              len -= piece;
            }
            b.next();
          } else if (a.ins >= 0) {
            let len = 0, left = a.len;
            while (left) {
              if (b.ins == -1) {
                let piece = Math.min(left, b.len);
                len += piece;
                left -= piece;
                b.forward(piece);
              } else if (b.ins == 0 && b.len < left) {
                left -= b.len;
                b.next();
              } else {
                break;
              }
            }
            addSection(sections, len, inserted < a.i ? a.ins : 0);
            if (insert2 && inserted < a.i)
              addInsert(insert2, sections, a.text);
            inserted = a.i;
            a.forward(a.len - left);
          } else if (a.done && b.done) {
            return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
          } else {
            throw new Error("Mismatched change set lengths");
          }
        }
      }
      function composeSets(setA, setB, mkSet = false) {
        let sections = [];
        let insert2 = mkSet ? [] : null;
        let a = new SectionIter(setA), b = new SectionIter(setB);
        for (let open = false; ; ) {
          if (a.done && b.done) {
            return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
          } else if (a.ins == 0) {
            addSection(sections, a.len, 0, open);
            a.next();
          } else if (b.len == 0 && !b.done) {
            addSection(sections, 0, b.ins, open);
            if (insert2)
              addInsert(insert2, sections, b.text);
            b.next();
          } else if (a.done || b.done) {
            throw new Error("Mismatched change set lengths");
          } else {
            let len = Math.min(a.len2, b.len), sectionLen = sections.length;
            if (a.ins == -1) {
              let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
              addSection(sections, len, insB, open);
              if (insert2 && insB)
                addInsert(insert2, sections, b.text);
            } else if (b.ins == -1) {
              addSection(sections, a.off ? 0 : a.len, len, open);
              if (insert2)
                addInsert(insert2, sections, a.textBit(len));
            } else {
              addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
              if (insert2 && !b.off)
                addInsert(insert2, sections, b.text);
            }
            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
            a.forward2(len);
            b.forward(len);
          }
        }
      }
      var SectionIter = class {
        constructor(set) {
          this.set = set;
          this.i = 0;
          this.next();
        }
        next() {
          let { sections } = this.set;
          if (this.i < sections.length) {
            this.len = sections[this.i++];
            this.ins = sections[this.i++];
          } else {
            this.len = 0;
            this.ins = -2;
          }
          this.off = 0;
        }
        get done() {
          return this.ins == -2;
        }
        get len2() {
          return this.ins < 0 ? this.len : this.ins;
        }
        get text() {
          let { inserted } = this.set, index = this.i - 2 >> 1;
          return index >= inserted.length ? Text.empty : inserted[index];
        }
        textBit(len) {
          let { inserted } = this.set, index = this.i - 2 >> 1;
          return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
        }
        forward(len) {
          if (len == this.len)
            this.next();
          else {
            this.len -= len;
            this.off += len;
          }
        }
        forward2(len) {
          if (this.ins == -1)
            this.forward(len);
          else if (len == this.ins)
            this.next();
          else {
            this.ins -= len;
            this.off += len;
          }
        }
      };
      var SelectionRange = class {
        constructor(from, to2, flags) {
          this.from = from;
          this.to = to2;
          this.flags = flags;
        }
        get anchor() {
          return this.flags & 32 ? this.to : this.from;
        }
        get head() {
          return this.flags & 32 ? this.from : this.to;
        }
        get empty() {
          return this.from == this.to;
        }
        get assoc() {
          return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
        }
        get bidiLevel() {
          let level = this.flags & 7;
          return level == 7 ? null : level;
        }
        get goalColumn() {
          let value = this.flags >> 6;
          return value == 16777215 ? void 0 : value;
        }
        map(change, assoc = -1) {
          let from, to2;
          if (this.empty) {
            from = to2 = change.mapPos(this.from, assoc);
          } else {
            from = change.mapPos(this.from, 1);
            to2 = change.mapPos(this.to, -1);
          }
          return from == this.from && to2 == this.to ? this : new SelectionRange(from, to2, this.flags);
        }
        extend(from, to2 = from) {
          if (from <= this.anchor && to2 >= this.anchor)
            return EditorSelection.range(from, to2);
          let head = Math.abs(from - this.anchor) > Math.abs(to2 - this.anchor) ? from : to2;
          return EditorSelection.range(this.anchor, head);
        }
        eq(other, includeAssoc = false) {
          return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
        }
        toJSON() {
          return { anchor: this.anchor, head: this.head };
        }
        static fromJSON(json) {
          if (!json || typeof json.anchor != "number" || typeof json.head != "number")
            throw new RangeError("Invalid JSON representation for SelectionRange");
          return EditorSelection.range(json.anchor, json.head);
        }
        static create(from, to2, flags) {
          return new SelectionRange(from, to2, flags);
        }
      };
      var EditorSelection = class {
        constructor(ranges, mainIndex) {
          this.ranges = ranges;
          this.mainIndex = mainIndex;
        }
        map(change, assoc = -1) {
          if (change.empty)
            return this;
          return EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
        }
        eq(other, includeAssoc = false) {
          if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
            return false;
          for (let i = 0; i < this.ranges.length; i++)
            if (!this.ranges[i].eq(other.ranges[i], includeAssoc))
              return false;
          return true;
        }
        get main() {
          return this.ranges[this.mainIndex];
        }
        asSingle() {
          return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
        }
        addRange(range, main = true) {
          return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
        }
        replaceRange(range, which = this.mainIndex) {
          let ranges = this.ranges.slice();
          ranges[which] = range;
          return EditorSelection.create(ranges, this.mainIndex);
        }
        toJSON() {
          return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
        }
        static fromJSON(json) {
          if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
            throw new RangeError("Invalid JSON representation for EditorSelection");
          return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
        }
        static single(anchor, head = anchor) {
          return new EditorSelection([EditorSelection.range(anchor, head)], 0);
        }
        static create(ranges, mainIndex = 0) {
          if (ranges.length == 0)
            throw new RangeError("A selection needs at least one range");
          for (let pos = 0, i = 0; i < ranges.length; i++) {
            let range = ranges[i];
            if (range.empty ? range.from <= pos : range.from < pos)
              return EditorSelection.normalized(ranges.slice(), mainIndex);
            pos = range.to;
          }
          return new EditorSelection(ranges, mainIndex);
        }
        static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
          return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
        }
        static range(anchor, head, goalColumn, bidiLevel) {
          let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
          return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
        }
        static normalized(ranges, mainIndex = 0) {
          let main = ranges[mainIndex];
          ranges.sort((a, b) => a.from - b.from);
          mainIndex = ranges.indexOf(main);
          for (let i = 1; i < ranges.length; i++) {
            let range = ranges[i], prev = ranges[i - 1];
            if (range.empty ? range.from <= prev.to : range.from < prev.to) {
              let from = prev.from, to2 = Math.max(range.to, prev.to);
              if (i <= mainIndex)
                mainIndex--;
              ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to2, from) : EditorSelection.range(from, to2));
            }
          }
          return new EditorSelection(ranges, mainIndex);
        }
      };
      function checkSelection(selection, docLength) {
        for (let range of selection.ranges)
          if (range.to > docLength)
            throw new RangeError("Selection points outside of document");
      }
      var nextID = 0;
      var Facet = class {
        constructor(combine, compareInput, compare2, isStatic, enables) {
          this.combine = combine;
          this.compareInput = compareInput;
          this.compare = compare2;
          this.isStatic = isStatic;
          this.id = nextID++;
          this.default = combine([]);
          this.extensions = typeof enables == "function" ? enables(this) : enables;
        }
        get reader() {
          return this;
        }
        static define(config = {}) {
          return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);
        }
        of(value) {
          return new FacetProvider([], this, 0, value);
        }
        compute(deps, get) {
          if (this.isStatic)
            throw new Error("Can't compute a static facet");
          return new FacetProvider(deps, this, 1, get);
        }
        computeN(deps, get) {
          if (this.isStatic)
            throw new Error("Can't compute a static facet");
          return new FacetProvider(deps, this, 2, get);
        }
        from(field, get) {
          if (!get)
            get = (x) => x;
          return this.compute([field], (state) => get(state.field(field)));
        }
      };
      function sameArray(a, b) {
        return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
      }
      var FacetProvider = class {
        constructor(dependencies, facet, type, value) {
          this.dependencies = dependencies;
          this.facet = facet;
          this.type = type;
          this.value = value;
          this.id = nextID++;
        }
        dynamicSlot(addresses) {
          var _a2;
          let getter = this.value;
          let compare2 = this.facet.compareInput;
          let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2;
          let depDoc = false, depSel = false, depAddrs = [];
          for (let dep of this.dependencies) {
            if (dep == "doc")
              depDoc = true;
            else if (dep == "selection")
              depSel = true;
            else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
              depAddrs.push(addresses[dep.id]);
          }
          return {
            create(state) {
              state.values[idx] = getter(state);
              return 1;
            },
            update(state, tr2) {
              if (depDoc && tr2.docChanged || depSel && (tr2.docChanged || tr2.selection) || ensureAll(state, depAddrs)) {
                let newVal = getter(state);
                if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
                  state.values[idx] = newVal;
                  return 1;
                }
              }
              return 0;
            },
            reconfigure: (state, oldState) => {
              let newVal, oldAddr = oldState.config.address[id];
              if (oldAddr != null) {
                let oldVal = getAddr(oldState, oldAddr);
                if (this.dependencies.every((dep) => {
                  return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
                }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
                  state.values[idx] = oldVal;
                  return 0;
                }
              } else {
                newVal = getter(state);
              }
              state.values[idx] = newVal;
              return 1;
            }
          };
        }
      };
      function compareArray(a, b, compare2) {
        if (a.length != b.length)
          return false;
        for (let i = 0; i < a.length; i++)
          if (!compare2(a[i], b[i]))
            return false;
        return true;
      }
      function ensureAll(state, addrs) {
        let changed = false;
        for (let addr of addrs)
          if (ensureAddr(state, addr) & 1)
            changed = true;
        return changed;
      }
      function dynamicFacetSlot(addresses, facet, providers) {
        let providerAddrs = providers.map((p) => addresses[p.id]);
        let providerTypes = providers.map((p) => p.type);
        let dynamic = providerAddrs.filter((p) => !(p & 1));
        let idx = addresses[facet.id] >> 1;
        function get(state) {
          let values = [];
          for (let i = 0; i < providerAddrs.length; i++) {
            let value = getAddr(state, providerAddrs[i]);
            if (providerTypes[i] == 2)
              for (let val of value)
                values.push(val);
            else
              values.push(value);
          }
          return facet.combine(values);
        }
        return {
          create(state) {
            for (let addr of providerAddrs)
              ensureAddr(state, addr);
            state.values[idx] = get(state);
            return 1;
          },
          update(state, tr2) {
            if (!ensureAll(state, dynamic))
              return 0;
            let value = get(state);
            if (facet.compare(value, state.values[idx]))
              return 0;
            state.values[idx] = value;
            return 1;
          },
          reconfigure(state, oldState) {
            let depChanged = ensureAll(state, providerAddrs);
            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
              state.values[idx] = oldValue;
              return 0;
            }
            let value = get(state);
            if (facet.compare(value, oldValue)) {
              state.values[idx] = oldValue;
              return 0;
            }
            state.values[idx] = value;
            return 1;
          }
        };
      }
      var initField = Facet.define({ static: true });
      var StateField = class {
        constructor(id, createF, updateF, compareF, spec) {
          this.id = id;
          this.createF = createF;
          this.updateF = updateF;
          this.compareF = compareF;
          this.spec = spec;
          this.provides = void 0;
        }
        static define(config) {
          let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
          if (config.provide)
            field.provides = config.provide(field);
          return field;
        }
        create(state) {
          let init = state.facet(initField).find((i) => i.field == this);
          return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
        }
        slot(addresses) {
          let idx = addresses[this.id] >> 1;
          return {
            create: (state) => {
              state.values[idx] = this.create(state);
              return 1;
            },
            update: (state, tr2) => {
              let oldVal = state.values[idx];
              let value = this.updateF(oldVal, tr2);
              if (this.compareF(oldVal, value))
                return 0;
              state.values[idx] = value;
              return 1;
            },
            reconfigure: (state, oldState) => {
              if (oldState.config.address[this.id] != null) {
                state.values[idx] = oldState.field(this);
                return 0;
              }
              state.values[idx] = this.create(state);
              return 1;
            }
          };
        }
        init(create) {
          return [this, initField.of({ field: this, create })];
        }
        get extension() {
          return this;
        }
      };
      var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
      function prec(value) {
        return (ext) => new PrecExtension(ext, value);
      }
      var Prec = {
        highest: prec(Prec_.highest),
        high: prec(Prec_.high),
        default: prec(Prec_.default),
        low: prec(Prec_.low),
        lowest: prec(Prec_.lowest)
      };
      var PrecExtension = class {
        constructor(inner, prec2) {
          this.inner = inner;
          this.prec = prec2;
        }
      };
      var Compartment = class {
        of(ext) {
          return new CompartmentInstance(this, ext);
        }
        reconfigure(content) {
          return Compartment.reconfigure.of({ compartment: this, extension: content });
        }
        get(state) {
          return state.config.compartments.get(this);
        }
      };
      var CompartmentInstance = class {
        constructor(compartment, inner) {
          this.compartment = compartment;
          this.inner = inner;
        }
      };
      var Configuration = class {
        constructor(base, compartments, dynamicSlots, address, staticValues, facets) {
          this.base = base;
          this.compartments = compartments;
          this.dynamicSlots = dynamicSlots;
          this.address = address;
          this.staticValues = staticValues;
          this.facets = facets;
          this.statusTemplate = [];
          while (this.statusTemplate.length < dynamicSlots.length)
            this.statusTemplate.push(0);
        }
        staticFacet(facet) {
          let addr = this.address[facet.id];
          return addr == null ? facet.default : this.staticValues[addr >> 1];
        }
        static resolve(base, compartments, oldState) {
          let fields = [];
          let facets = Object.create(null);
          let newCompartments = new Map();
          for (let ext of flatten(base, compartments, newCompartments)) {
            if (ext instanceof StateField)
              fields.push(ext);
            else
              (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
          }
          let address = Object.create(null);
          let staticValues = [];
          let dynamicSlots = [];
          for (let field of fields) {
            address[field.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a) => field.slot(a));
          }
          let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
          for (let id in facets) {
            let providers = facets[id], facet = providers[0].facet;
            let oldProviders = oldFacets && oldFacets[id] || [];
            if (providers.every((p) => p.type == 0)) {
              address[facet.id] = staticValues.length << 1 | 1;
              if (sameArray(oldProviders, providers)) {
                staticValues.push(oldState.facet(facet));
              } else {
                let value = facet.combine(providers.map((p) => p.value));
                staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
              }
            } else {
              for (let p of providers) {
                if (p.type == 0) {
                  address[p.id] = staticValues.length << 1 | 1;
                  staticValues.push(p.value);
                } else {
                  address[p.id] = dynamicSlots.length << 1;
                  dynamicSlots.push((a) => p.dynamicSlot(a));
                }
              }
              address[facet.id] = dynamicSlots.length << 1;
              dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
            }
          }
          let dynamic = dynamicSlots.map((f) => f(address));
          return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);
        }
      };
      function flatten(extension, compartments, newCompartments) {
        let result = [[], [], [], [], []];
        let seen = new Map();
        function inner(ext, prec2) {
          let known = seen.get(ext);
          if (known != null) {
            if (known <= prec2)
              return;
            let found = result[known].indexOf(ext);
            if (found > -1)
              result[known].splice(found, 1);
            if (ext instanceof CompartmentInstance)
              newCompartments.delete(ext.compartment);
          }
          seen.set(ext, prec2);
          if (Array.isArray(ext)) {
            for (let e of ext)
              inner(e, prec2);
          } else if (ext instanceof CompartmentInstance) {
            if (newCompartments.has(ext.compartment))
              throw new RangeError(`Duplicate use of compartment in extensions`);
            let content = compartments.get(ext.compartment) || ext.inner;
            newCompartments.set(ext.compartment, content);
            inner(content, prec2);
          } else if (ext instanceof PrecExtension) {
            inner(ext.inner, ext.prec);
          } else if (ext instanceof StateField) {
            result[prec2].push(ext);
            if (ext.provides)
              inner(ext.provides, prec2);
          } else if (ext instanceof FacetProvider) {
            result[prec2].push(ext);
            if (ext.facet.extensions)
              inner(ext.facet.extensions, Prec_.default);
          } else {
            let content = ext.extension;
            if (!content)
              throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
            inner(content, prec2);
          }
        }
        inner(extension, Prec_.default);
        return result.reduce((a, b) => a.concat(b));
      }
      function ensureAddr(state, addr) {
        if (addr & 1)
          return 2;
        let idx = addr >> 1;
        let status = state.status[idx];
        if (status == 4)
          throw new Error("Cyclic dependency between fields and/or facets");
        if (status & 2)
          return status;
        state.status[idx] = 4;
        let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
        return state.status[idx] = 2 | changed;
      }
      function getAddr(state, addr) {
        return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
      }
      var languageData = Facet.define();
      var allowMultipleSelections = Facet.define({
        combine: (values) => values.some((v) => v),
        static: true
      });
      var lineSeparator = Facet.define({
        combine: (values) => values.length ? values[0] : void 0,
        static: true
      });
      var changeFilter = Facet.define();
      var transactionFilter = Facet.define();
      var transactionExtender = Facet.define();
      var readOnly = Facet.define({
        combine: (values) => values.length ? values[0] : false
      });
      var Annotation = class {
        constructor(type, value) {
          this.type = type;
          this.value = value;
        }
        static define() {
          return new AnnotationType();
        }
      };
      var AnnotationType = class {
        of(value) {
          return new Annotation(this, value);
        }
      };
      var StateEffectType = class {
        constructor(map) {
          this.map = map;
        }
        of(value) {
          return new StateEffect(this, value);
        }
      };
      var StateEffect = class {
        constructor(type, value) {
          this.type = type;
          this.value = value;
        }
        map(mapping) {
          let mapped = this.type.map(this.value, mapping);
          return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
        }
        is(type) {
          return this.type == type;
        }
        static define(spec = {}) {
          return new StateEffectType(spec.map || ((v) => v));
        }
        static mapEffects(effects, mapping) {
          if (!effects.length)
            return effects;
          let result = [];
          for (let effect of effects) {
            let mapped = effect.map(mapping);
            if (mapped)
              result.push(mapped);
          }
          return result;
        }
      };
      StateEffect.reconfigure = StateEffect.define();
      StateEffect.appendConfig = StateEffect.define();
      var Transaction = class {
        constructor(startState, changes, selection, effects, annotations, scrollIntoView) {
          this.startState = startState;
          this.changes = changes;
          this.selection = selection;
          this.effects = effects;
          this.annotations = annotations;
          this.scrollIntoView = scrollIntoView;
          this._doc = null;
          this._state = null;
          if (selection)
            checkSelection(selection, changes.newLength);
          if (!annotations.some((a) => a.type == Transaction.time))
            this.annotations = annotations.concat(Transaction.time.of(Date.now()));
        }
        static create(startState, changes, selection, effects, annotations, scrollIntoView) {
          return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);
        }
        get newDoc() {
          return this._doc || (this._doc = this.changes.apply(this.startState.doc));
        }
        get newSelection() {
          return this.selection || this.startState.selection.map(this.changes);
        }
        get state() {
          if (!this._state)
            this.startState.applyTransaction(this);
          return this._state;
        }
        annotation(type) {
          for (let ann of this.annotations)
            if (ann.type == type)
              return ann.value;
          return void 0;
        }
        get docChanged() {
          return !this.changes.empty;
        }
        get reconfigured() {
          return this.startState.config != this.state.config;
        }
        isUserEvent(event2) {
          let e = this.annotation(Transaction.userEvent);
          return !!(e && (e == event2 || e.length > event2.length && e.slice(0, event2.length) == event2 && e[event2.length] == "."));
        }
      };
      Transaction.time = Annotation.define();
      Transaction.userEvent = Annotation.define();
      Transaction.addToHistory = Annotation.define();
      Transaction.remote = Annotation.define();
      function joinRanges(a, b) {
        let result = [];
        for (let iA = 0, iB = 0; ; ) {
          let from, to2;
          if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
            from = a[iA++];
            to2 = a[iA++];
          } else if (iB < b.length) {
            from = b[iB++];
            to2 = b[iB++];
          } else
            return result;
          if (!result.length || result[result.length - 1] < from)
            result.push(from, to2);
          else if (result[result.length - 1] < to2)
            result[result.length - 1] = to2;
        }
      }
      function mergeTransaction(a, b, sequential) {
        var _a2;
        let mapForA, mapForB, changes;
        if (sequential) {
          mapForA = b.changes;
          mapForB = ChangeSet.empty(b.changes.length);
          changes = a.changes.compose(b.changes);
        } else {
          mapForA = b.changes.map(a.changes);
          mapForB = a.changes.mapDesc(b.changes, true);
          changes = a.changes.compose(mapForA);
        }
        return {
          changes,
          selection: b.selection ? b.selection.map(mapForB) : (_a2 = a.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
          effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
          annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
          scrollIntoView: a.scrollIntoView || b.scrollIntoView
        };
      }
      function resolveTransactionInner(state, spec, docSize) {
        let sel = spec.selection, annotations = asArray(spec.annotations);
        if (spec.userEvent)
          annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
        return {
          changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
          selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
          effects: asArray(spec.effects),
          annotations,
          scrollIntoView: !!spec.scrollIntoView
        };
      }
      function resolveTransaction(state, specs, filter) {
        let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
        if (specs.length && specs[0].filter === false)
          filter = false;
        for (let i = 1; i < specs.length; i++) {
          if (specs[i].filter === false)
            filter = false;
          let seq = !!specs[i].sequential;
          s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
        }
        let tr2 = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
        return extendTransaction(filter ? filterTransaction(tr2) : tr2);
      }
      function filterTransaction(tr2) {
        let state = tr2.startState;
        let result = true;
        for (let filter of state.facet(changeFilter)) {
          let value = filter(tr2);
          if (value === false) {
            result = false;
            break;
          }
          if (Array.isArray(value))
            result = result === true ? value : joinRanges(result, value);
        }
        if (result !== true) {
          let changes, back;
          if (result === false) {
            back = tr2.changes.invertedDesc;
            changes = ChangeSet.empty(state.doc.length);
          } else {
            let filtered = tr2.changes.filter(result);
            changes = filtered.changes;
            back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
          }
          tr2 = Transaction.create(state, changes, tr2.selection && tr2.selection.map(back), StateEffect.mapEffects(tr2.effects, back), tr2.annotations, tr2.scrollIntoView);
        }
        let filters = state.facet(transactionFilter);
        for (let i = filters.length - 1; i >= 0; i--) {
          let filtered = filters[i](tr2);
          if (filtered instanceof Transaction)
            tr2 = filtered;
          else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
            tr2 = filtered[0];
          else
            tr2 = resolveTransaction(state, asArray(filtered), false);
        }
        return tr2;
      }
      function extendTransaction(tr2) {
        let state = tr2.startState, extenders = state.facet(transactionExtender), spec = tr2;
        for (let i = extenders.length - 1; i >= 0; i--) {
          let extension = extenders[i](tr2);
          if (extension && Object.keys(extension).length)
            spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr2.changes.newLength), true);
        }
        return spec == tr2 ? tr2 : Transaction.create(state, tr2.changes, tr2.selection, spec.effects, spec.annotations, spec.scrollIntoView);
      }
      var none = [];
      function asArray(value) {
        return value == null ? none : Array.isArray(value) ? value : [value];
      }
      exports.CharCategory = void 0;
      (function(CharCategory) {
        CharCategory[CharCategory["Word"] = 0] = "Word";
        CharCategory[CharCategory["Space"] = 1] = "Space";
        CharCategory[CharCategory["Other"] = 2] = "Other";
      })(exports.CharCategory || (exports.CharCategory = {}));
      var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
      var wordChar;
      try {
        wordChar = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
      } catch (_) {
      }
      function hasWordChar(str) {
        if (wordChar)
          return wordChar.test(str);
        for (let i = 0; i < str.length; i++) {
          let ch2 = str[i];
          if (/\w/.test(ch2) || ch2 > "\x80" && (ch2.toUpperCase() != ch2.toLowerCase() || nonASCIISingleCaseWordChar.test(ch2)))
            return true;
        }
        return false;
      }
      function makeCategorizer(wordChars) {
        return (char) => {
          if (!/\S/.test(char))
            return exports.CharCategory.Space;
          if (hasWordChar(char))
            return exports.CharCategory.Word;
          for (let i = 0; i < wordChars.length; i++)
            if (char.indexOf(wordChars[i]) > -1)
              return exports.CharCategory.Word;
          return exports.CharCategory.Other;
        };
      }
      var EditorState = class {
        constructor(config, doc, selection, values, computeSlot, tr2) {
          this.config = config;
          this.doc = doc;
          this.selection = selection;
          this.values = values;
          this.status = config.statusTemplate.slice();
          this.computeSlot = computeSlot;
          if (tr2)
            tr2._state = this;
          for (let i = 0; i < this.config.dynamicSlots.length; i++)
            ensureAddr(this, i << 1);
          this.computeSlot = null;
        }
        field(field, require2 = true) {
          let addr = this.config.address[field.id];
          if (addr == null) {
            if (require2)
              throw new RangeError("Field is not present in this state");
            return void 0;
          }
          ensureAddr(this, addr);
          return getAddr(this, addr);
        }
        update(...specs) {
          return resolveTransaction(this, specs, true);
        }
        applyTransaction(tr2) {
          let conf = this.config, { base, compartments } = conf;
          for (let effect of tr2.effects) {
            if (effect.is(Compartment.reconfigure)) {
              if (conf) {
                compartments = new Map();
                conf.compartments.forEach((val, key) => compartments.set(key, val));
                conf = null;
              }
              compartments.set(effect.value.compartment, effect.value.extension);
            } else if (effect.is(StateEffect.reconfigure)) {
              conf = null;
              base = effect.value;
            } else if (effect.is(StateEffect.appendConfig)) {
              conf = null;
              base = asArray(base).concat(effect.value);
            }
          }
          let startValues;
          if (!conf) {
            conf = Configuration.resolve(base, compartments, this);
            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
            startValues = intermediateState.values;
          } else {
            startValues = tr2.startState.values.slice();
          }
          let selection = tr2.startState.facet(allowMultipleSelections) ? tr2.newSelection : tr2.newSelection.asSingle();
          new EditorState(conf, tr2.newDoc, selection, startValues, (state, slot) => slot.update(state, tr2), tr2);
        }
        replaceSelection(text) {
          if (typeof text == "string")
            text = this.toText(text);
          return this.changeByRange((range) => ({
            changes: { from: range.from, to: range.to, insert: text },
            range: EditorSelection.cursor(range.from + text.length)
          }));
        }
        changeByRange(f) {
          let sel = this.selection;
          let result1 = f(sel.ranges[0]);
          let changes = this.changes(result1.changes), ranges = [result1.range];
          let effects = asArray(result1.effects);
          for (let i = 1; i < sel.ranges.length; i++) {
            let result = f(sel.ranges[i]);
            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
            for (let j2 = 0; j2 < i; j2++)
              ranges[j2] = ranges[j2].map(newMapped);
            let mapBy = changes.mapDesc(newChanges, true);
            ranges.push(result.range.map(mapBy));
            changes = changes.compose(newMapped);
            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
          }
          return {
            changes,
            selection: EditorSelection.create(ranges, sel.mainIndex),
            effects
          };
        }
        changes(spec = []) {
          if (spec instanceof ChangeSet)
            return spec;
          return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
        }
        toText(string) {
          return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
        }
        sliceDoc(from = 0, to2 = this.doc.length) {
          return this.doc.sliceString(from, to2, this.lineBreak);
        }
        facet(facet) {
          let addr = this.config.address[facet.id];
          if (addr == null)
            return facet.default;
          ensureAddr(this, addr);
          return getAddr(this, addr);
        }
        toJSON(fields) {
          let result = {
            doc: this.sliceDoc(),
            selection: this.selection.toJSON()
          };
          if (fields)
            for (let prop in fields) {
              let value = fields[prop];
              if (value instanceof StateField && this.config.address[value.id] != null)
                result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
            }
          return result;
        }
        static fromJSON(json, config = {}, fields) {
          if (!json || typeof json.doc != "string")
            throw new RangeError("Invalid JSON representation for EditorState");
          let fieldInit = [];
          if (fields)
            for (let prop in fields) {
              if (Object.prototype.hasOwnProperty.call(json, prop)) {
                let field = fields[prop], value = json[prop];
                fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
              }
            }
          return EditorState.create({
            doc: json.doc,
            selection: EditorSelection.fromJSON(json.selection),
            extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
          });
        }
        static create(config = {}) {
          let configuration = Configuration.resolve(config.extensions || [], new Map());
          let doc = config.doc instanceof Text ? config.doc : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
          let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);
          checkSelection(selection, doc.length);
          if (!configuration.staticFacet(allowMultipleSelections))
            selection = selection.asSingle();
          return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
        }
        get tabSize() {
          return this.facet(EditorState.tabSize);
        }
        get lineBreak() {
          return this.facet(EditorState.lineSeparator) || "\n";
        }
        get readOnly() {
          return this.facet(readOnly);
        }
        phrase(phrase, ...insert2) {
          for (let map of this.facet(EditorState.phrases))
            if (Object.prototype.hasOwnProperty.call(map, phrase)) {
              phrase = map[phrase];
              break;
            }
          if (insert2.length)
            phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
              if (i == "$")
                return "$";
              let n = +(i || 1);
              return !n || n > insert2.length ? m : insert2[n - 1];
            });
          return phrase;
        }
        languageDataAt(name, pos, side = -1) {
          let values = [];
          for (let provider of this.facet(languageData)) {
            for (let result of provider(this, pos, side)) {
              if (Object.prototype.hasOwnProperty.call(result, name))
                values.push(result[name]);
            }
          }
          return values;
        }
        charCategorizer(at2) {
          return makeCategorizer(this.languageDataAt("wordChars", at2).join(""));
        }
        wordAt(pos) {
          let { text, from, length } = this.doc.lineAt(pos);
          let cat = this.charCategorizer(pos);
          let start = pos - from, end = pos - from;
          while (start > 0) {
            let prev = findClusterBreak(text, start, false);
            if (cat(text.slice(prev, start)) != exports.CharCategory.Word)
              break;
            start = prev;
          }
          while (end < length) {
            let next = findClusterBreak(text, end);
            if (cat(text.slice(end, next)) != exports.CharCategory.Word)
              break;
            end = next;
          }
          return start == end ? null : EditorSelection.range(start + from, end + from);
        }
      };
      EditorState.allowMultipleSelections = allowMultipleSelections;
      EditorState.tabSize = Facet.define({
        combine: (values) => values.length ? values[0] : 4
      });
      EditorState.lineSeparator = lineSeparator;
      EditorState.readOnly = readOnly;
      EditorState.phrases = Facet.define({
        compare(a, b) {
          let kA = Object.keys(a), kB = Object.keys(b);
          return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
        }
      });
      EditorState.languageData = languageData;
      EditorState.changeFilter = changeFilter;
      EditorState.transactionFilter = transactionFilter;
      EditorState.transactionExtender = transactionExtender;
      Compartment.reconfigure = StateEffect.define();
      function combineConfig(configs, defaults, combine = {}) {
        let result = {};
        for (let config of configs)
          for (let key of Object.keys(config)) {
            let value = config[key], current = result[key];
            if (current === void 0)
              result[key] = value;
            else if (current === value || value === void 0)
              ;
            else if (Object.hasOwnProperty.call(combine, key))
              result[key] = combine[key](current, value);
            else
              throw new Error("Config merge conflict for field " + key);
          }
        for (let key in defaults)
          if (result[key] === void 0)
            result[key] = defaults[key];
        return result;
      }
      var RangeValue = class {
        eq(other) {
          return this == other;
        }
        range(from, to2 = from) {
          return Range.create(from, to2, this);
        }
      };
      RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
      RangeValue.prototype.point = false;
      RangeValue.prototype.mapMode = exports.MapMode.TrackDel;
      var Range = class {
        constructor(from, to2, value) {
          this.from = from;
          this.to = to2;
          this.value = value;
        }
        static create(from, to2, value) {
          return new Range(from, to2, value);
        }
      };
      function cmpRange(a, b) {
        return a.from - b.from || a.value.startSide - b.value.startSide;
      }
      var Chunk = class {
        constructor(from, to2, value, maxPoint) {
          this.from = from;
          this.to = to2;
          this.value = value;
          this.maxPoint = maxPoint;
        }
        get length() {
          return this.to[this.to.length - 1];
        }
        findIndex(pos, side, end, startAt = 0) {
          let arr = end ? this.to : this.from;
          for (let lo2 = startAt, hi2 = arr.length; ; ) {
            if (lo2 == hi2)
              return lo2;
            let mid = lo2 + hi2 >> 1;
            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
            if (mid == lo2)
              return diff >= 0 ? lo2 : hi2;
            if (diff >= 0)
              hi2 = mid;
            else
              lo2 = mid + 1;
          }
        }
        between(offset, from, to2, f) {
          for (let i = this.findIndex(from, -1e9, true), e = this.findIndex(to2, 1e9, false, i); i < e; i++)
            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
              return false;
        }
        map(offset, changes) {
          let value = [], from = [], to2 = [], newPos = -1, maxPoint = -1;
          for (let i = 0; i < this.value.length; i++) {
            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
            if (curFrom == curTo) {
              let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
              if (mapped == null)
                continue;
              newFrom = newTo = mapped;
              if (val.startSide != val.endSide) {
                newTo = changes.mapPos(curFrom, val.endSide);
                if (newTo < newFrom)
                  continue;
              }
            } else {
              newFrom = changes.mapPos(curFrom, val.startSide);
              newTo = changes.mapPos(curTo, val.endSide);
              if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
                continue;
            }
            if ((newTo - newFrom || val.endSide - val.startSide) < 0)
              continue;
            if (newPos < 0)
              newPos = newFrom;
            if (val.point)
              maxPoint = Math.max(maxPoint, newTo - newFrom);
            value.push(val);
            from.push(newFrom - newPos);
            to2.push(newTo - newPos);
          }
          return { mapped: value.length ? new Chunk(from, to2, value, maxPoint) : null, pos: newPos };
        }
      };
      var RangeSet = class {
        constructor(chunkPos, chunk, nextLayer, maxPoint) {
          this.chunkPos = chunkPos;
          this.chunk = chunk;
          this.nextLayer = nextLayer;
          this.maxPoint = maxPoint;
        }
        static create(chunkPos, chunk, nextLayer, maxPoint) {
          return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
        }
        get length() {
          let last = this.chunk.length - 1;
          return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
        }
        get size() {
          if (this.isEmpty)
            return 0;
          let size = this.nextLayer.size;
          for (let chunk of this.chunk)
            size += chunk.value.length;
          return size;
        }
        chunkEnd(index) {
          return this.chunkPos[index] + this.chunk[index].length;
        }
        update(updateSpec) {
          let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
          let filter = updateSpec.filter;
          if (add.length == 0 && !filter)
            return this;
          if (sort)
            add = add.slice().sort(cmpRange);
          if (this.isEmpty)
            return add.length ? RangeSet.of(add) : this;
          let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
          let builder = new RangeSetBuilder();
          while (cur.value || i < add.length) {
            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
              let range = add[i++];
              if (!builder.addInner(range.from, range.to, range.value))
                spill.push(range);
            } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
              cur.nextChunk();
            } else {
              if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
                if (!builder.addInner(cur.from, cur.to, cur.value))
                  spill.push(Range.create(cur.from, cur.to, cur.value));
              }
              cur.next();
            }
          }
          return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
        }
        map(changes) {
          if (changes.empty || this.isEmpty)
            return this;
          let chunks = [], chunkPos = [], maxPoint = -1;
          for (let i = 0; i < this.chunk.length; i++) {
            let start = this.chunkPos[i], chunk = this.chunk[i];
            let touch = changes.touchesRange(start, start + chunk.length);
            if (touch === false) {
              maxPoint = Math.max(maxPoint, chunk.maxPoint);
              chunks.push(chunk);
              chunkPos.push(changes.mapPos(start));
            } else if (touch === true) {
              let { mapped, pos } = chunk.map(start, changes);
              if (mapped) {
                maxPoint = Math.max(maxPoint, mapped.maxPoint);
                chunks.push(mapped);
                chunkPos.push(pos);
              }
            }
          }
          let next = this.nextLayer.map(changes);
          return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
        }
        between(from, to2, f) {
          if (this.isEmpty)
            return;
          for (let i = 0; i < this.chunk.length; i++) {
            let start = this.chunkPos[i], chunk = this.chunk[i];
            if (to2 >= start && from <= start + chunk.length && chunk.between(start, from - start, to2 - start, f) === false)
              return;
          }
          this.nextLayer.between(from, to2, f);
        }
        iter(from = 0) {
          return HeapCursor.from([this]).goto(from);
        }
        get isEmpty() {
          return this.nextLayer == this;
        }
        static iter(sets, from = 0) {
          return HeapCursor.from(sets).goto(from);
        }
        static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
          let a = oldSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
          let b = newSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
          let sharedChunks = findSharedChunks(a, b, textDiff);
          let sideA = new SpanCursor(a, sharedChunks, minPointSize);
          let sideB = new SpanCursor(b, sharedChunks, minPointSize);
          textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
          if (textDiff.empty && textDiff.length == 0)
            compare(sideA, 0, sideB, 0, 0, comparator);
        }
        static eq(oldSets, newSets, from = 0, to2) {
          if (to2 == null)
            to2 = 1e9 - 1;
          let a = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
          let b = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
          if (a.length != b.length)
            return false;
          if (!a.length)
            return true;
          let sharedChunks = findSharedChunks(a, b);
          let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
          for (; ; ) {
            if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
              return false;
            if (sideA.to > to2)
              return true;
            sideA.next();
            sideB.next();
          }
        }
        static spans(sets, from, to2, iterator, minPointSize = -1) {
          let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
          let openRanges = cursor.openStart;
          for (; ; ) {
            let curTo = Math.min(cursor.to, to2);
            if (cursor.point) {
              let active = cursor.activeForPoint(cursor.to);
              let openCount = cursor.pointFrom < from ? active.length + 1 : Math.min(active.length, openRanges);
              iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
              openRanges = Math.min(cursor.openEnd(curTo), active.length);
            } else if (curTo > pos) {
              iterator.span(pos, curTo, cursor.active, openRanges);
              openRanges = cursor.openEnd(curTo);
            }
            if (cursor.to > to2)
              return openRanges + (cursor.point && cursor.to > to2 ? 1 : 0);
            pos = cursor.to;
            cursor.next();
          }
        }
        static of(ranges, sort = false) {
          let build = new RangeSetBuilder();
          for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
            build.add(range.from, range.to, range.value);
          return build.finish();
        }
        static join(sets) {
          if (!sets.length)
            return RangeSet.empty;
          let result = sets[sets.length - 1];
          for (let i = sets.length - 2; i >= 0; i--) {
            for (let layer = sets[i]; layer != RangeSet.empty; layer = layer.nextLayer)
              result = new RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));
          }
          return result;
        }
      };
      RangeSet.empty = new RangeSet([], [], null, -1);
      function lazySort(ranges) {
        if (ranges.length > 1)
          for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
            let cur = ranges[i];
            if (cmpRange(prev, cur) > 0)
              return ranges.slice().sort(cmpRange);
            prev = cur;
          }
        return ranges;
      }
      RangeSet.empty.nextLayer = RangeSet.empty;
      var RangeSetBuilder = class {
        finishChunk(newArrays) {
          this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
          this.chunkPos.push(this.chunkStart);
          this.chunkStart = -1;
          this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
          this.maxPoint = -1;
          if (newArrays) {
            this.from = [];
            this.to = [];
            this.value = [];
          }
        }
        constructor() {
          this.chunks = [];
          this.chunkPos = [];
          this.chunkStart = -1;
          this.last = null;
          this.lastFrom = -1e9;
          this.lastTo = -1e9;
          this.from = [];
          this.to = [];
          this.value = [];
          this.maxPoint = -1;
          this.setMaxPoint = -1;
          this.nextLayer = null;
        }
        add(from, to2, value) {
          if (!this.addInner(from, to2, value))
            (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to2, value);
        }
        addInner(from, to2, value) {
          let diff = from - this.lastTo || value.startSide - this.last.endSide;
          if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
            throw new Error("Ranges must be added sorted by `from` position and `startSide`");
          if (diff < 0)
            return false;
          if (this.from.length == 250)
            this.finishChunk(true);
          if (this.chunkStart < 0)
            this.chunkStart = from;
          this.from.push(from - this.chunkStart);
          this.to.push(to2 - this.chunkStart);
          this.last = value;
          this.lastFrom = from;
          this.lastTo = to2;
          this.value.push(value);
          if (value.point)
            this.maxPoint = Math.max(this.maxPoint, to2 - from);
          return true;
        }
        addChunk(from, chunk) {
          if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
            return false;
          if (this.from.length)
            this.finishChunk(true);
          this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
          this.chunks.push(chunk);
          this.chunkPos.push(from);
          let last = chunk.value.length - 1;
          this.last = chunk.value[last];
          this.lastFrom = chunk.from[last] + from;
          this.lastTo = chunk.to[last] + from;
          return true;
        }
        finish() {
          return this.finishInner(RangeSet.empty);
        }
        finishInner(next) {
          if (this.from.length)
            this.finishChunk(false);
          if (this.chunks.length == 0)
            return next;
          let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
          this.from = null;
          return result;
        }
      };
      function findSharedChunks(a, b, textDiff) {
        let inA = new Map();
        for (let set of a)
          for (let i = 0; i < set.chunk.length; i++)
            if (set.chunk[i].maxPoint <= 0)
              inA.set(set.chunk[i], set.chunkPos[i]);
        let shared = new Set();
        for (let set of b)
          for (let i = 0; i < set.chunk.length; i++) {
            let known = inA.get(set.chunk[i]);
            if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
              shared.add(set.chunk[i]);
          }
        return shared;
      }
      var LayerCursor = class {
        constructor(layer, skip, minPoint, rank = 0) {
          this.layer = layer;
          this.skip = skip;
          this.minPoint = minPoint;
          this.rank = rank;
        }
        get startSide() {
          return this.value ? this.value.startSide : 0;
        }
        get endSide() {
          return this.value ? this.value.endSide : 0;
        }
        goto(pos, side = -1e9) {
          this.chunkIndex = this.rangeIndex = 0;
          this.gotoInner(pos, side, false);
          return this;
        }
        gotoInner(pos, side, forward) {
          while (this.chunkIndex < this.layer.chunk.length) {
            let next = this.layer.chunk[this.chunkIndex];
            if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
              break;
            this.chunkIndex++;
            forward = false;
          }
          if (this.chunkIndex < this.layer.chunk.length) {
            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
            if (!forward || this.rangeIndex < rangeIndex)
              this.setRangeIndex(rangeIndex);
          }
          this.next();
        }
        forward(pos, side) {
          if ((this.to - pos || this.endSide - side) < 0)
            this.gotoInner(pos, side, true);
        }
        next() {
          for (; ; ) {
            if (this.chunkIndex == this.layer.chunk.length) {
              this.from = this.to = 1e9;
              this.value = null;
              break;
            } else {
              let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
              let from = chunkPos + chunk.from[this.rangeIndex];
              this.from = from;
              this.to = chunkPos + chunk.to[this.rangeIndex];
              this.value = chunk.value[this.rangeIndex];
              this.setRangeIndex(this.rangeIndex + 1);
              if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
                break;
            }
          }
        }
        setRangeIndex(index) {
          if (index == this.layer.chunk[this.chunkIndex].value.length) {
            this.chunkIndex++;
            if (this.skip) {
              while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
                this.chunkIndex++;
            }
            this.rangeIndex = 0;
          } else {
            this.rangeIndex = index;
          }
        }
        nextChunk() {
          this.chunkIndex++;
          this.rangeIndex = 0;
          this.next();
        }
        compare(other) {
          return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
        }
      };
      var HeapCursor = class {
        constructor(heap) {
          this.heap = heap;
        }
        static from(sets, skip = null, minPoint = -1) {
          let heap = [];
          for (let i = 0; i < sets.length; i++) {
            for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
              if (cur.maxPoint >= minPoint)
                heap.push(new LayerCursor(cur, skip, minPoint, i));
            }
          }
          return heap.length == 1 ? heap[0] : new HeapCursor(heap);
        }
        get startSide() {
          return this.value ? this.value.startSide : 0;
        }
        goto(pos, side = -1e9) {
          for (let cur of this.heap)
            cur.goto(pos, side);
          for (let i = this.heap.length >> 1; i >= 0; i--)
            heapBubble(this.heap, i);
          this.next();
          return this;
        }
        forward(pos, side) {
          for (let cur of this.heap)
            cur.forward(pos, side);
          for (let i = this.heap.length >> 1; i >= 0; i--)
            heapBubble(this.heap, i);
          if ((this.to - pos || this.value.endSide - side) < 0)
            this.next();
        }
        next() {
          if (this.heap.length == 0) {
            this.from = this.to = 1e9;
            this.value = null;
            this.rank = -1;
          } else {
            let top = this.heap[0];
            this.from = top.from;
            this.to = top.to;
            this.value = top.value;
            this.rank = top.rank;
            if (top.value)
              top.next();
            heapBubble(this.heap, 0);
          }
        }
      };
      function heapBubble(heap, index) {
        for (let cur = heap[index]; ; ) {
          let childIndex = (index << 1) + 1;
          if (childIndex >= heap.length)
            break;
          let child = heap[childIndex];
          if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
            child = heap[childIndex + 1];
            childIndex++;
          }
          if (cur.compare(child) < 0)
            break;
          heap[childIndex] = cur;
          heap[index] = child;
          index = childIndex;
        }
      }
      var SpanCursor = class {
        constructor(sets, skip, minPoint) {
          this.minPoint = minPoint;
          this.active = [];
          this.activeTo = [];
          this.activeRank = [];
          this.minActive = -1;
          this.point = null;
          this.pointFrom = 0;
          this.pointRank = 0;
          this.to = -1e9;
          this.endSide = 0;
          this.openStart = -1;
          this.cursor = HeapCursor.from(sets, skip, minPoint);
        }
        goto(pos, side = -1e9) {
          this.cursor.goto(pos, side);
          this.active.length = this.activeTo.length = this.activeRank.length = 0;
          this.minActive = -1;
          this.to = pos;
          this.endSide = side;
          this.openStart = -1;
          this.next();
          return this;
        }
        forward(pos, side) {
          while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
            this.removeActive(this.minActive);
          this.cursor.forward(pos, side);
        }
        removeActive(index) {
          remove(this.active, index);
          remove(this.activeTo, index);
          remove(this.activeRank, index);
          this.minActive = findMinIndex(this.active, this.activeTo);
        }
        addActive(trackOpen) {
          let i = 0, { value, to: to2, rank } = this.cursor;
          while (i < this.activeRank.length && (rank - this.activeRank[i] || to2 - this.activeTo[i]) > 0)
            i++;
          insert(this.active, i, value);
          insert(this.activeTo, i, to2);
          insert(this.activeRank, i, rank);
          if (trackOpen)
            insert(trackOpen, i, this.cursor.from);
          this.minActive = findMinIndex(this.active, this.activeTo);
        }
        next() {
          let from = this.to, wasPoint = this.point;
          this.point = null;
          let trackOpen = this.openStart < 0 ? [] : null;
          for (; ; ) {
            let a = this.minActive;
            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
              if (this.activeTo[a] > from) {
                this.to = this.activeTo[a];
                this.endSide = this.active[a].endSide;
                break;
              }
              this.removeActive(a);
              if (trackOpen)
                remove(trackOpen, a);
            } else if (!this.cursor.value) {
              this.to = this.endSide = 1e9;
              break;
            } else if (this.cursor.from > from) {
              this.to = this.cursor.from;
              this.endSide = this.cursor.startSide;
              break;
            } else {
              let nextVal = this.cursor.value;
              if (!nextVal.point) {
                this.addActive(trackOpen);
                this.cursor.next();
              } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
                this.cursor.next();
              } else {
                this.point = nextVal;
                this.pointFrom = this.cursor.from;
                this.pointRank = this.cursor.rank;
                this.to = this.cursor.to;
                this.endSide = nextVal.endSide;
                this.cursor.next();
                this.forward(this.to, this.endSide);
                break;
              }
            }
          }
          if (trackOpen) {
            this.openStart = 0;
            for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)
              this.openStart++;
          }
        }
        activeForPoint(to2) {
          if (!this.active.length)
            return this.active;
          let active = [];
          for (let i = this.active.length - 1; i >= 0; i--) {
            if (this.activeRank[i] < this.pointRank)
              break;
            if (this.activeTo[i] > to2 || this.activeTo[i] == to2 && this.active[i].endSide >= this.point.endSide)
              active.push(this.active[i]);
          }
          return active.reverse();
        }
        openEnd(to2) {
          let open = 0;
          for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to2; i--)
            open++;
          return open;
        }
      };
      function compare(a, startA, b, startB, length, comparator) {
        a.goto(startA);
        b.goto(startB);
        let endB = startB + length;
        let pos = startB, dPos = startB - startA;
        for (; ; ) {
          let diff = a.to + dPos - b.to || a.endSide - b.endSide;
          let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
          if (a.point || b.point) {
            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))
              comparator.comparePoint(pos, clipEnd, a.point, b.point);
          } else {
            if (clipEnd > pos && !sameValues(a.active, b.active))
              comparator.compareRange(pos, clipEnd, a.active, b.active);
          }
          if (end > endB)
            break;
          pos = end;
          if (diff <= 0)
            a.next();
          if (diff >= 0)
            b.next();
        }
      }
      function sameValues(a, b) {
        if (a.length != b.length)
          return false;
        for (let i = 0; i < a.length; i++)
          if (a[i] != b[i] && !a[i].eq(b[i]))
            return false;
        return true;
      }
      function remove(array, index) {
        for (let i = index, e = array.length - 1; i < e; i++)
          array[i] = array[i + 1];
        array.pop();
      }
      function insert(array, index, value) {
        for (let i = array.length - 1; i >= index; i--)
          array[i + 1] = array[i];
        array[index] = value;
      }
      function findMinIndex(value, array) {
        let found = -1, foundPos = 1e9;
        for (let i = 0; i < array.length; i++)
          if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
            found = i;
            foundPos = array[i];
          }
        return found;
      }
      function countColumn(string, tabSize, to2 = string.length) {
        let n = 0;
        for (let i = 0; i < to2; ) {
          if (string.charCodeAt(i) == 9) {
            n += tabSize - n % tabSize;
            i++;
          } else {
            n++;
            i = findClusterBreak(string, i);
          }
        }
        return n;
      }
      function findColumn(string, col, tabSize, strict) {
        for (let i = 0, n = 0; ; ) {
          if (n >= col)
            return i;
          if (i == string.length)
            break;
          n += string.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
          i = findClusterBreak(string, i);
        }
        return strict === true ? -1 : string.length;
      }
      exports.Annotation = Annotation;
      exports.AnnotationType = AnnotationType;
      exports.ChangeDesc = ChangeDesc;
      exports.ChangeSet = ChangeSet;
      exports.Compartment = Compartment;
      exports.EditorSelection = EditorSelection;
      exports.EditorState = EditorState;
      exports.Facet = Facet;
      exports.Line = Line;
      exports.Prec = Prec;
      exports.Range = Range;
      exports.RangeSet = RangeSet;
      exports.RangeSetBuilder = RangeSetBuilder;
      exports.RangeValue = RangeValue;
      exports.SelectionRange = SelectionRange;
      exports.StateEffect = StateEffect;
      exports.StateEffectType = StateEffectType;
      exports.StateField = StateField;
      exports.Text = Text;
      exports.Transaction = Transaction;
      exports.codePointAt = codePointAt;
      exports.codePointSize = codePointSize;
      exports.combineConfig = combineConfig;
      exports.countColumn = countColumn;
      exports.findClusterBreak = findClusterBreak;
      exports.findColumn = findColumn;
      exports.fromCodePoint = fromCodePoint;
    }
  });

  // node_modules/style-mod/dist/style-mod.cjs
  var require_style_mod = __commonJS({
    "node_modules/style-mod/dist/style-mod.cjs"(exports) {
      var C = "\u037C";
      var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
      var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
      var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
      var StyleModule = exports.StyleModule = function StyleModule2(spec, options) {
        this.rules = [];
        var ref = options || {};
        var finish = ref.finish;
        function splitSelector(selector) {
          return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
        }
        function render(selectors, spec2, target, isKeyframes) {
          var local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
          if (isAt && spec2 == null) {
            return target.push(selectors[0] + ";");
          }
          for (var prop2 in spec2) {
            var value = spec2[prop2];
            if (/&/.test(prop2)) {
              render(prop2.split(/,\s*/).map(function(part) {
                return selectors.map(function(sel) {
                  return part.replace(/&/, sel);
                });
              }).reduce(function(a, b) {
                return a.concat(b);
              }), value, target);
            } else if (value && typeof value == "object") {
              if (!isAt) {
                throw new RangeError("The value of a property (" + prop2 + ") should be a primitive value.");
              }
              render(splitSelector(prop2), value, local, keyframes);
            } else if (value != null) {
              local.push(prop2.replace(/_.*/, "").replace(/[A-Z]/g, function(l) {
                return "-" + l.toLowerCase();
              }) + ": " + value + ";");
            }
          }
          if (local.length || keyframes) {
            target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
          }
        }
        for (var prop in spec) {
          render(splitSelector(prop), spec[prop], this.rules);
        }
      };
      StyleModule.prototype.getRules = function getRules() {
        return this.rules.join("\n");
      };
      StyleModule.newName = function newName() {
        var id = top[COUNT] || 1;
        top[COUNT] = id + 1;
        return C + id.toString(36);
      };
      StyleModule.mount = function mount(root, modules, options) {
        var set = root[SET], nonce = options && options.nonce;
        if (!set) {
          set = new StyleSet(root, nonce);
        } else if (nonce) {
          set.setNonce(nonce);
        }
        set.mount(Array.isArray(modules) ? modules : [modules]);
      };
      var adoptedSet = new Map();
      var StyleSet = function StyleSet2(root, nonce) {
        var doc = root.ownerDocument || root, win = doc.defaultView;
        if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
          var adopted = adoptedSet.get(doc);
          if (adopted) {
            root.adoptedStyleSheets = [adopted.sheet].concat(root.adoptedStyleSheets);
            return root[SET] = adopted;
          }
          this.sheet = new win.CSSStyleSheet();
          root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);
          adoptedSet.set(doc, this);
        } else {
          this.styleTag = doc.createElement("style");
          if (nonce) {
            this.styleTag.setAttribute("nonce", nonce);
          }
          var target = root.head || root;
          target.insertBefore(this.styleTag, target.firstChild);
        }
        this.modules = [];
        root[SET] = this;
      };
      StyleSet.prototype.mount = function mount(modules) {
        var sheet = this.sheet;
        var pos = 0, j2 = 0;
        for (var i = 0; i < modules.length; i++) {
          var mod = modules[i], index = this.modules.indexOf(mod);
          if (index < j2 && index > -1) {
            this.modules.splice(index, 1);
            j2--;
            index = -1;
          }
          if (index == -1) {
            this.modules.splice(j2++, 0, mod);
            if (sheet) {
              for (var k = 0; k < mod.rules.length; k++) {
                sheet.insertRule(mod.rules[k], pos++);
              }
            }
          } else {
            while (j2 < index) {
              pos += this.modules[j2++].rules.length;
            }
            pos += mod.rules.length;
            j2++;
          }
        }
        if (!sheet) {
          var text = "";
          for (var i$1 = 0; i$1 < this.modules.length; i$1++) {
            text += this.modules[i$1].getRules() + "\n";
          }
          this.styleTag.textContent = text;
        }
      };
      StyleSet.prototype.setNonce = function setNonce(nonce) {
        if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce) {
          this.styleTag.setAttribute("nonce", nonce);
        }
      };
    }
  });

  // node_modules/w3c-keyname/index.cjs
  var require_w3c_keyname = __commonJS({
    "node_modules/w3c-keyname/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var base = {
        8: "Backspace",
        9: "Tab",
        10: "Enter",
        12: "NumLock",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        44: "PrintScreen",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Meta",
        92: "Meta",
        106: "*",
        107: "+",
        108: ",",
        109: "-",
        110: ".",
        111: "/",
        144: "NumLock",
        145: "ScrollLock",
        160: "Shift",
        161: "Shift",
        162: "Control",
        163: "Control",
        164: "Alt",
        165: "Alt",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'"
      };
      var shift = {
        48: ")",
        49: "!",
        50: "@",
        51: "#",
        52: "$",
        53: "%",
        54: "^",
        55: "&",
        56: "*",
        57: "(",
        59: ":",
        61: "+",
        173: "_",
        186: ":",
        187: "+",
        188: "<",
        189: "_",
        190: ">",
        191: "?",
        192: "~",
        219: "{",
        220: "|",
        221: "}",
        222: '"'
      };
      var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
      var ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
      for (i = 0; i < 10; i++)
        base[48 + i] = base[96 + i] = String(i);
      var i;
      for (i = 1; i <= 24; i++)
        base[i + 111] = "F" + i;
      var i;
      for (i = 65; i <= 90; i++) {
        base[i] = String.fromCharCode(i + 32);
        shift[i] = String.fromCharCode(i);
      }
      var i;
      for (code in base)
        if (!shift.hasOwnProperty(code))
          shift[code] = base[code];
      var code;
      function keyName(event2) {
        var ignoreKey = mac && event2.metaKey && event2.shiftKey && !event2.ctrlKey && !event2.altKey || ie2 && event2.shiftKey && event2.key && event2.key.length == 1 || event2.key == "Unidentified";
        var name = !ignoreKey && event2.key || (event2.shiftKey ? shift : base)[event2.keyCode] || event2.key || "Unidentified";
        if (name == "Esc")
          name = "Escape";
        if (name == "Del")
          name = "Delete";
        if (name == "Left")
          name = "ArrowLeft";
        if (name == "Up")
          name = "ArrowUp";
        if (name == "Right")
          name = "ArrowRight";
        if (name == "Down")
          name = "ArrowDown";
        return name;
      }
      exports.base = base;
      exports.keyName = keyName;
      exports.shift = shift;
    }
  });

  // node_modules/@codemirror/view/dist/index.cjs
  var require_dist2 = __commonJS({
    "node_modules/@codemirror/view/dist/index.cjs"(exports) {
      "use strict";
      var state = require_dist();
      var styleMod = require_style_mod();
      var w3cKeyname = require_w3c_keyname();
      function getSelection(root) {
        let target;
        if (root.nodeType == 11) {
          target = root.getSelection ? root : root.ownerDocument;
        } else {
          target = root;
        }
        return target.getSelection();
      }
      function contains(dom, node) {
        return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
      }
      function deepActiveElement(doc2) {
        let elt = doc2.activeElement;
        while (elt && elt.shadowRoot)
          elt = elt.shadowRoot.activeElement;
        return elt;
      }
      function hasSelection(dom, selection) {
        if (!selection.anchorNode)
          return false;
        try {
          return contains(dom, selection.anchorNode);
        } catch (_) {
          return false;
        }
      }
      function clientRectsFor(dom) {
        if (dom.nodeType == 3)
          return textRange(dom, 0, dom.nodeValue.length).getClientRects();
        else if (dom.nodeType == 1)
          return dom.getClientRects();
        else
          return [];
      }
      function isEquivalentPosition(node, off, targetNode, targetOff) {
        return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
      }
      function domIndex(node) {
        for (var index = 0; ; index++) {
          node = node.previousSibling;
          if (!node)
            return index;
        }
      }
      function scanFor(node, off, targetNode, targetOff, dir) {
        for (; ; ) {
          if (node == targetNode && off == targetOff)
            return true;
          if (off == (dir < 0 ? 0 : maxOffset(node))) {
            if (node.nodeName == "DIV")
              return false;
            let parent = node.parentNode;
            if (!parent || parent.nodeType != 1)
              return false;
            off = domIndex(node) + (dir < 0 ? 0 : 1);
            node = parent;
          } else if (node.nodeType == 1) {
            node = node.childNodes[off + (dir < 0 ? -1 : 0)];
            if (node.nodeType == 1 && node.contentEditable == "false")
              return false;
            off = dir < 0 ? maxOffset(node) : 0;
          } else {
            return false;
          }
        }
      }
      function maxOffset(node) {
        return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
      }
      function flattenRect(rect, left) {
        let x = left ? rect.left : rect.right;
        return { left: x, right: x, top: rect.top, bottom: rect.bottom };
      }
      function windowRect(win) {
        return {
          left: 0,
          right: win.innerWidth,
          top: 0,
          bottom: win.innerHeight
        };
      }
      function scrollRectIntoView(dom, rect, side, x, y2, xMargin, yMargin, ltr) {
        let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
        for (let cur = dom, stop = false; cur && !stop; ) {
          if (cur.nodeType == 1) {
            let bounding, top = cur == doc2.body;
            let scaleX = 1, scaleY = 1;
            if (top) {
              bounding = windowRect(win);
            } else {
              if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position))
                stop = true;
              if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
                cur = cur.assignedSlot || cur.parentNode;
                continue;
              }
              let rect2 = cur.getBoundingClientRect();
              scaleX = rect2.width / cur.offsetWidth;
              scaleY = rect2.height / cur.offsetHeight;
              bounding = {
                left: rect2.left,
                right: rect2.left + cur.clientWidth * scaleX,
                top: rect2.top,
                bottom: rect2.top + cur.clientHeight * scaleY
              };
            }
            let moveX = 0, moveY = 0;
            if (y2 == "nearest") {
              if (rect.top < bounding.top) {
                moveY = -(bounding.top - rect.top + yMargin);
                if (side > 0 && rect.bottom > bounding.bottom + moveY)
                  moveY = rect.bottom - bounding.bottom + moveY + yMargin;
              } else if (rect.bottom > bounding.bottom) {
                moveY = rect.bottom - bounding.bottom + yMargin;
                if (side < 0 && rect.top - moveY < bounding.top)
                  moveY = -(bounding.top + moveY - rect.top + yMargin);
              }
            } else {
              let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
              let targetTop = y2 == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y2 == "start" || y2 == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
              moveY = targetTop - bounding.top;
            }
            if (x == "nearest") {
              if (rect.left < bounding.left) {
                moveX = -(bounding.left - rect.left + xMargin);
                if (side > 0 && rect.right > bounding.right + moveX)
                  moveX = rect.right - bounding.right + moveX + xMargin;
              } else if (rect.right > bounding.right) {
                moveX = rect.right - bounding.right + xMargin;
                if (side < 0 && rect.left < bounding.left + moveX)
                  moveX = -(bounding.left + moveX - rect.left + xMargin);
              }
            } else {
              let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
              moveX = targetLeft - bounding.left;
            }
            if (moveX || moveY) {
              if (top) {
                win.scrollBy(moveX, moveY);
              } else {
                let movedX = 0, movedY = 0;
                if (moveY) {
                  let start = cur.scrollTop;
                  cur.scrollTop += moveY / scaleY;
                  movedY = (cur.scrollTop - start) * scaleY;
                }
                if (moveX) {
                  let start = cur.scrollLeft;
                  cur.scrollLeft += moveX / scaleX;
                  movedX = (cur.scrollLeft - start) * scaleX;
                }
                rect = {
                  left: rect.left - movedX,
                  top: rect.top - movedY,
                  right: rect.right - movedX,
                  bottom: rect.bottom - movedY
                };
                if (movedX && Math.abs(movedX - moveX) < 1)
                  x = "nearest";
                if (movedY && Math.abs(movedY - moveY) < 1)
                  y2 = "nearest";
              }
            }
            if (top)
              break;
            cur = cur.assignedSlot || cur.parentNode;
          } else if (cur.nodeType == 11) {
            cur = cur.host;
          } else {
            break;
          }
        }
      }
      function scrollableParent(dom) {
        let doc2 = dom.ownerDocument;
        for (let cur = dom.parentNode; cur; ) {
          if (cur == doc2.body) {
            break;
          } else if (cur.nodeType == 1) {
            if (cur.scrollHeight > cur.clientHeight || cur.scrollWidth > cur.clientWidth)
              return cur;
            cur = cur.assignedSlot || cur.parentNode;
          } else if (cur.nodeType == 11) {
            cur = cur.host;
          } else {
            break;
          }
        }
        return null;
      }
      var DOMSelectionState = class {
        constructor() {
          this.anchorNode = null;
          this.anchorOffset = 0;
          this.focusNode = null;
          this.focusOffset = 0;
        }
        eq(domSel) {
          return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
        }
        setRange(range) {
          let { anchorNode, focusNode } = range;
          this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
        }
        set(anchorNode, anchorOffset, focusNode, focusOffset) {
          this.anchorNode = anchorNode;
          this.anchorOffset = anchorOffset;
          this.focusNode = focusNode;
          this.focusOffset = focusOffset;
        }
      };
      var preventScrollSupported = null;
      function focusPreventScroll(dom) {
        if (dom.setActive)
          return dom.setActive();
        if (preventScrollSupported)
          return dom.focus(preventScrollSupported);
        let stack = [];
        for (let cur = dom; cur; cur = cur.parentNode) {
          stack.push(cur, cur.scrollTop, cur.scrollLeft);
          if (cur == cur.ownerDocument)
            break;
        }
        dom.focus(preventScrollSupported == null ? {
          get preventScroll() {
            preventScrollSupported = { preventScroll: true };
            return true;
          }
        } : void 0);
        if (!preventScrollSupported) {
          preventScrollSupported = false;
          for (let i = 0; i < stack.length; ) {
            let elt = stack[i++], top = stack[i++], left = stack[i++];
            if (elt.scrollTop != top)
              elt.scrollTop = top;
            if (elt.scrollLeft != left)
              elt.scrollLeft = left;
          }
        }
      }
      var scratchRange;
      function textRange(node, from, to2 = from) {
        let range = scratchRange || (scratchRange = document.createRange());
        range.setEnd(node, to2);
        range.setStart(node, from);
        return range;
      }
      function dispatchKey(elt, name, code) {
        let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };
        let down = new KeyboardEvent("keydown", options);
        down.synthetic = true;
        elt.dispatchEvent(down);
        let up2 = new KeyboardEvent("keyup", options);
        up2.synthetic = true;
        elt.dispatchEvent(up2);
        return down.defaultPrevented || up2.defaultPrevented;
      }
      function getRoot(node) {
        while (node) {
          if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
            return node;
          node = node.assignedSlot || node.parentNode;
        }
        return null;
      }
      function clearAttributes(node) {
        while (node.attributes.length)
          node.removeAttributeNode(node.attributes[0]);
      }
      function atElementStart(doc2, selection) {
        let node = selection.focusNode, offset = selection.focusOffset;
        if (!node || selection.anchorNode != node || selection.anchorOffset != offset)
          return false;
        offset = Math.min(offset, maxOffset(node));
        for (; ; ) {
          if (offset) {
            if (node.nodeType != 1)
              return false;
            let prev = node.childNodes[offset - 1];
            if (prev.contentEditable == "false")
              offset--;
            else {
              node = prev;
              offset = maxOffset(node);
            }
          } else if (node == doc2) {
            return true;
          } else {
            offset = domIndex(node);
            node = node.parentNode;
          }
        }
      }
      function isScrolledToBottom(elt) {
        return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
      }
      var DOMPos = class {
        constructor(node, offset, precise = true) {
          this.node = node;
          this.offset = offset;
          this.precise = precise;
        }
        static before(dom, precise) {
          return new DOMPos(dom.parentNode, domIndex(dom), precise);
        }
        static after(dom, precise) {
          return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
        }
      };
      var noChildren = [];
      var ContentView = class {
        constructor() {
          this.parent = null;
          this.dom = null;
          this.flags = 2;
        }
        get overrideDOMText() {
          return null;
        }
        get posAtStart() {
          return this.parent ? this.parent.posBefore(this) : 0;
        }
        get posAtEnd() {
          return this.posAtStart + this.length;
        }
        posBefore(view) {
          let pos = this.posAtStart;
          for (let child of this.children) {
            if (child == view)
              return pos;
            pos += child.length + child.breakAfter;
          }
          throw new RangeError("Invalid child in posBefore");
        }
        posAfter(view) {
          return this.posBefore(view) + view.length;
        }
        sync(view, track) {
          if (this.flags & 2) {
            let parent = this.dom;
            let prev = null, next;
            for (let child of this.children) {
              if (child.flags & 7) {
                if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
                  let contentView = ContentView.get(next);
                  if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                    child.reuseDOM(next);
                }
                child.sync(view, track);
                child.flags &= ~7;
              }
              next = prev ? prev.nextSibling : parent.firstChild;
              if (track && !track.written && track.node == parent && next != child.dom)
                track.written = true;
              if (child.dom.parentNode == parent) {
                while (next && next != child.dom)
                  next = rm$1(next);
              } else {
                parent.insertBefore(child.dom, next);
              }
              prev = child.dom;
            }
            next = prev ? prev.nextSibling : parent.firstChild;
            if (next && track && track.node == parent)
              track.written = true;
            while (next)
              next = rm$1(next);
          } else if (this.flags & 1) {
            for (let child of this.children)
              if (child.flags & 7) {
                child.sync(view, track);
                child.flags &= ~7;
              }
          }
        }
        reuseDOM(_dom) {
        }
        localPosFromDOM(node, offset) {
          let after;
          if (node == this.dom) {
            after = this.dom.childNodes[offset];
          } else {
            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
            for (; ; ) {
              let parent = node.parentNode;
              if (parent == this.dom)
                break;
              if (bias == 0 && parent.firstChild != parent.lastChild) {
                if (node == parent.firstChild)
                  bias = -1;
                else
                  bias = 1;
              }
              node = parent;
            }
            if (bias < 0)
              after = node;
            else
              after = node.nextSibling;
          }
          if (after == this.dom.firstChild)
            return 0;
          while (after && !ContentView.get(after))
            after = after.nextSibling;
          if (!after)
            return this.length;
          for (let i = 0, pos = 0; ; i++) {
            let child = this.children[i];
            if (child.dom == after)
              return pos;
            pos += child.length + child.breakAfter;
          }
        }
        domBoundsAround(from, to2, offset = 0) {
          let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
          for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos < from && end > to2)
              return child.domBoundsAround(from, to2, pos);
            if (end >= from && fromI == -1) {
              fromI = i;
              fromStart = pos;
            }
            if (pos > to2 && child.dom.parentNode == this.dom) {
              toI = i;
              toEnd = prevEnd;
              break;
            }
            prevEnd = end;
            pos = end + child.breakAfter;
          }
          return {
            from: fromStart,
            to: toEnd < 0 ? offset + this.length : toEnd,
            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
          };
        }
        markDirty(andParent = false) {
          this.flags |= 2;
          this.markParentsDirty(andParent);
        }
        markParentsDirty(childList) {
          for (let parent = this.parent; parent; parent = parent.parent) {
            if (childList)
              parent.flags |= 2;
            if (parent.flags & 1)
              return;
            parent.flags |= 1;
            childList = false;
          }
        }
        setParent(parent) {
          if (this.parent != parent) {
            this.parent = parent;
            if (this.flags & 7)
              this.markParentsDirty(true);
          }
        }
        setDOM(dom) {
          if (this.dom == dom)
            return;
          if (this.dom)
            this.dom.cmView = null;
          this.dom = dom;
          dom.cmView = this;
        }
        get rootView() {
          for (let v = this; ; ) {
            let parent = v.parent;
            if (!parent)
              return v;
            v = parent;
          }
        }
        replaceChildren(from, to2, children = noChildren) {
          this.markDirty();
          for (let i = from; i < to2; i++) {
            let child = this.children[i];
            if (child.parent == this && children.indexOf(child) < 0)
              child.destroy();
          }
          this.children.splice(from, to2 - from, ...children);
          for (let i = 0; i < children.length; i++)
            children[i].setParent(this);
        }
        ignoreMutation(_rec) {
          return false;
        }
        ignoreEvent(_event) {
          return false;
        }
        childCursor(pos = this.length) {
          return new ChildCursor(this.children, pos, this.children.length);
        }
        childPos(pos, bias = 1) {
          return this.childCursor().findPos(pos, bias);
        }
        toString() {
          let name = this.constructor.name.replace("View", "");
          return name + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
        }
        static get(node) {
          return node.cmView;
        }
        get isEditable() {
          return true;
        }
        get isWidget() {
          return false;
        }
        get isHidden() {
          return false;
        }
        merge(from, to2, source, hasStart, openStart, openEnd) {
          return false;
        }
        become(other) {
          return false;
        }
        canReuseDOM(other) {
          return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
        }
        getSide() {
          return 0;
        }
        destroy() {
          for (let child of this.children)
            child.destroy();
          this.parent = null;
        }
      };
      ContentView.prototype.breakAfter = 0;
      function rm$1(dom) {
        let next = dom.nextSibling;
        dom.parentNode.removeChild(dom);
        return next;
      }
      var ChildCursor = class {
        constructor(children, pos, i) {
          this.children = children;
          this.pos = pos;
          this.i = i;
          this.off = 0;
        }
        findPos(pos, bias = 1) {
          for (; ; ) {
            if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
              this.off = pos - this.pos;
              return this;
            }
            let next = this.children[--this.i];
            this.pos -= next.length + next.breakAfter;
          }
        }
      };
      function replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {
        let { children } = parent;
        let before = children.length ? children[fromI] : null;
        let last = insert.length ? insert[insert.length - 1] : null;
        let breakAtEnd = last ? last.breakAfter : breakAtStart;
        if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 && before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd))
          return;
        if (toI < children.length) {
          let after = children[toI];
          if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {
            if (fromI == toI) {
              after = after.split(toOff);
              toOff = 0;
            }
            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
              insert[insert.length - 1] = after;
            } else {
              if (toOff || after.children.length && !after.children[0].length)
                after.merge(0, toOff, null, false, 0, openEnd);
              insert.push(after);
            }
          } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
            if (last)
              last.breakAfter = 1;
            else
              breakAtStart = 1;
          }
          toI++;
        }
        if (before) {
          before.breakAfter = breakAtStart;
          if (fromOff > 0) {
            if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {
              before.breakAfter = insert.shift().breakAfter;
            } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
              before.merge(fromOff, before.length, null, false, openStart, 0);
            }
            fromI++;
          }
        }
        while (fromI < toI && insert.length) {
          if (children[toI - 1].become(insert[insert.length - 1])) {
            toI--;
            insert.pop();
            openEnd = insert.length ? 0 : openStart;
          } else if (children[fromI].become(insert[0])) {
            fromI++;
            insert.shift();
            openStart = insert.length ? 0 : openEnd;
          } else {
            break;
          }
        }
        if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
          fromI--;
        if (fromI < toI || insert.length)
          parent.replaceChildren(fromI, toI, insert);
      }
      function mergeChildrenInto(parent, from, to2, insert, openStart, openEnd) {
        let cur = parent.childCursor();
        let { i: toI, off: toOff } = cur.findPos(to2, 1);
        let { i: fromI, off: fromOff } = cur.findPos(from, -1);
        let dLen = from - to2;
        for (let view of insert)
          dLen += view.length;
        parent.length += dLen;
        replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);
      }
      var nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
      var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
      var ie_edge = /Edge\/(\d+)/.exec(nav.userAgent);
      var ie_upto10 = /MSIE \d/.test(nav.userAgent);
      var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
      var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
      var gecko = !ie2 && /gecko\/(\d+)/i.test(nav.userAgent);
      var chrome = !ie2 && /Chrome\/(\d+)/.exec(nav.userAgent);
      var webkit = "webkitFontSmoothing" in doc.documentElement.style;
      var safari = !ie2 && /Apple Computer/.test(nav.vendor);
      var ios = safari && (/Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
      var browser = {
        mac: ios || /Mac/.test(nav.platform),
        windows: /Win/.test(nav.platform),
        linux: /Linux|X11/.test(nav.platform),
        ie: ie2,
        ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
        gecko,
        gecko_version: gecko ? +(/Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
        chrome: !!chrome,
        chrome_version: chrome ? +chrome[1] : 0,
        ios,
        android: /Android\b/.test(nav.userAgent),
        webkit,
        safari,
        webkit_version: webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
        tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
      };
      var MaxJoinLen = 256;
      var TextView = class extends ContentView {
        constructor(text) {
          super();
          this.text = text;
        }
        get length() {
          return this.text.length;
        }
        createDOM(textDOM) {
          this.setDOM(textDOM || document.createTextNode(this.text));
        }
        sync(view, track) {
          if (!this.dom)
            this.createDOM();
          if (this.dom.nodeValue != this.text) {
            if (track && track.node == this.dom)
              track.written = true;
            this.dom.nodeValue = this.text;
          }
        }
        reuseDOM(dom) {
          if (dom.nodeType == 3)
            this.createDOM(dom);
        }
        merge(from, to2, source) {
          if (this.flags & 8 || source && (!(source instanceof TextView) || this.length - (to2 - from) + source.length > MaxJoinLen || source.flags & 8))
            return false;
          this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to2);
          this.markDirty();
          return true;
        }
        split(from) {
          let result = new TextView(this.text.slice(from));
          this.text = this.text.slice(0, from);
          this.markDirty();
          result.flags |= this.flags & 8;
          return result;
        }
        localPosFromDOM(node, offset) {
          return node == this.dom ? offset : offset ? this.text.length : 0;
        }
        domAtPos(pos) {
          return new DOMPos(this.dom, pos);
        }
        domBoundsAround(_from, _to, offset) {
          return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
        }
        coordsAt(pos, side) {
          return textCoords(this.dom, pos, side);
        }
      };
      var MarkView = class extends ContentView {
        constructor(mark, children = [], length = 0) {
          super();
          this.mark = mark;
          this.children = children;
          this.length = length;
          for (let ch2 of children)
            ch2.setParent(this);
        }
        setAttrs(dom) {
          clearAttributes(dom);
          if (this.mark.class)
            dom.className = this.mark.class;
          if (this.mark.attrs)
            for (let name in this.mark.attrs)
              dom.setAttribute(name, this.mark.attrs[name]);
          return dom;
        }
        canReuseDOM(other) {
          return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
        }
        reuseDOM(node) {
          if (node.nodeName == this.mark.tagName.toUpperCase()) {
            this.setDOM(node);
            this.flags |= 4 | 2;
          }
        }
        sync(view, track) {
          if (!this.dom)
            this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
          else if (this.flags & 4)
            this.setAttrs(this.dom);
          super.sync(view, track);
        }
        merge(from, to2, source, _hasStart, openStart, openEnd) {
          if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to2 < this.length && openEnd <= 0))
            return false;
          mergeChildrenInto(this, from, to2, source ? source.children : [], openStart - 1, openEnd - 1);
          this.markDirty();
          return true;
        }
        split(from) {
          let result = [], off = 0, detachFrom = -1, i = 0;
          for (let elt of this.children) {
            let end = off + elt.length;
            if (end > from)
              result.push(off < from ? elt.split(from - off) : elt);
            if (detachFrom < 0 && off >= from)
              detachFrom = i;
            off = end;
            i++;
          }
          let length = this.length - from;
          this.length = from;
          if (detachFrom > -1) {
            this.children.length = detachFrom;
            this.markDirty();
          }
          return new MarkView(this.mark, result, length);
        }
        domAtPos(pos) {
          return inlineDOMAtPos(this, pos);
        }
        coordsAt(pos, side) {
          return coordsInChildren(this, pos, side);
        }
      };
      function textCoords(text, pos, side) {
        let length = text.nodeValue.length;
        if (pos > length)
          pos = length;
        let from = pos, to2 = pos, flatten = 0;
        if (pos == 0 && side < 0 || pos == length && side >= 0) {
          if (!(browser.chrome || browser.gecko)) {
            if (pos) {
              from--;
              flatten = 1;
            } else if (to2 < length) {
              to2++;
              flatten = -1;
            }
          }
        } else {
          if (side < 0)
            from--;
          else if (to2 < length)
            to2++;
        }
        let rects = textRange(text, from, to2).getClientRects();
        if (!rects.length)
          return null;
        let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];
        if (browser.safari && !flatten && rect.width == 0)
          rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
        return flatten ? flattenRect(rect, flatten < 0) : rect || null;
      }
      var WidgetView = class extends ContentView {
        static create(widget, length, side) {
          return new WidgetView(widget, length, side);
        }
        constructor(widget, length, side) {
          super();
          this.widget = widget;
          this.length = length;
          this.side = side;
          this.prevWidget = null;
        }
        split(from) {
          let result = WidgetView.create(this.widget, this.length - from, this.side);
          this.length -= from;
          return result;
        }
        sync(view) {
          if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
            if (this.dom && this.prevWidget)
              this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(view));
            this.dom.contentEditable = "false";
          }
        }
        getSide() {
          return this.side;
        }
        merge(from, to2, source, hasStart, openStart, openEnd) {
          if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to2 < this.length && openEnd <= 0))
            return false;
          this.length = from + (source ? source.length : 0) + (this.length - to2);
          return true;
        }
        become(other) {
          if (other instanceof WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
            if (!this.widget.compare(other.widget))
              this.markDirty(true);
            if (this.dom && !this.prevWidget)
              this.prevWidget = this.widget;
            this.widget = other.widget;
            this.length = other.length;
            return true;
          }
          return false;
        }
        ignoreMutation() {
          return true;
        }
        ignoreEvent(event2) {
          return this.widget.ignoreEvent(event2);
        }
        get overrideDOMText() {
          if (this.length == 0)
            return state.Text.empty;
          let top = this;
          while (top.parent)
            top = top.parent;
          let { view } = top, text = view && view.state.doc, start = this.posAtStart;
          return text ? text.slice(start, start + this.length) : state.Text.empty;
        }
        domAtPos(pos) {
          return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
        }
        domBoundsAround() {
          return null;
        }
        coordsAt(pos, side) {
          let custom = this.widget.coordsAt(this.dom, pos, side);
          if (custom)
            return custom;
          let rects = this.dom.getClientRects(), rect = null;
          if (!rects.length)
            return null;
          let fromBack = this.side ? this.side < 0 : pos > 0;
          for (let i = fromBack ? rects.length - 1 : 0; ; i += fromBack ? -1 : 1) {
            rect = rects[i];
            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
              break;
          }
          return flattenRect(rect, !fromBack);
        }
        get isEditable() {
          return false;
        }
        get isWidget() {
          return true;
        }
        get isHidden() {
          return this.widget.isHidden;
        }
        destroy() {
          super.destroy();
          if (this.dom)
            this.widget.destroy(this.dom);
        }
      };
      var WidgetBufferView = class extends ContentView {
        constructor(side) {
          super();
          this.side = side;
        }
        get length() {
          return 0;
        }
        merge() {
          return false;
        }
        become(other) {
          return other instanceof WidgetBufferView && other.side == this.side;
        }
        split() {
          return new WidgetBufferView(this.side);
        }
        sync() {
          if (!this.dom) {
            let dom = document.createElement("img");
            dom.className = "cm-widgetBuffer";
            dom.setAttribute("aria-hidden", "true");
            this.setDOM(dom);
          }
        }
        getSide() {
          return this.side;
        }
        domAtPos(pos) {
          return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
        }
        localPosFromDOM() {
          return 0;
        }
        domBoundsAround() {
          return null;
        }
        coordsAt(pos) {
          return this.dom.getBoundingClientRect();
        }
        get overrideDOMText() {
          return state.Text.empty;
        }
        get isHidden() {
          return true;
        }
      };
      TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
      function inlineDOMAtPos(parent, pos) {
        let dom = parent.dom, { children } = parent, i = 0;
        for (let off = 0; i < children.length; i++) {
          let child = children[i], end = off + child.length;
          if (end == off && child.getSide() <= 0)
            continue;
          if (pos > off && pos < end && child.dom.parentNode == dom)
            return child.domAtPos(pos - off);
          if (pos <= off)
            break;
          off = end;
        }
        for (let j2 = i; j2 > 0; j2--) {
          let prev = children[j2 - 1];
          if (prev.dom.parentNode == dom)
            return prev.domAtPos(prev.length);
        }
        for (let j2 = i; j2 < children.length; j2++) {
          let next = children[j2];
          if (next.dom.parentNode == dom)
            return next.domAtPos(0);
        }
        return new DOMPos(dom, 0);
      }
      function joinInlineInto(parent, view, open) {
        let last, { children } = parent;
        if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
          joinInlineInto(last, view.children[0], open - 1);
        } else {
          children.push(view);
          view.setParent(parent);
        }
        parent.length += view.length;
      }
      function coordsInChildren(view, pos, side) {
        let before = null, beforePos = -1, after = null, afterPos = -1;
        function scan(view2, pos2) {
          for (let i = 0, off = 0; i < view2.children.length && off <= pos2; i++) {
            let child = view2.children[i], end = off + child.length;
            if (end >= pos2) {
              if (child.children.length) {
                scan(child, pos2 - off);
              } else if ((!after || after.isHidden && side > 0) && (end > pos2 || off == end && child.getSide() > 0)) {
                after = child;
                afterPos = pos2 - off;
              } else if (off < pos2 || off == end && child.getSide() < 0 && !child.isHidden) {
                before = child;
                beforePos = pos2 - off;
              }
            }
            off = end;
          }
        }
        scan(view, pos);
        let target = (side < 0 ? before : after) || before || after;
        if (target)
          return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
        return fallbackRect(view);
      }
      function fallbackRect(view) {
        let last = view.dom.lastChild;
        if (!last)
          return view.dom.getBoundingClientRect();
        let rects = clientRectsFor(last);
        return rects[rects.length - 1] || null;
      }
      function combineAttrs(source, target) {
        for (let name in source) {
          if (name == "class" && target.class)
            target.class += " " + source.class;
          else if (name == "style" && target.style)
            target.style += ";" + source.style;
          else
            target[name] = source[name];
        }
        return target;
      }
      var noAttrs = Object.create(null);
      function attrsEq(a, b, ignore) {
        if (a == b)
          return true;
        if (!a)
          a = noAttrs;
        if (!b)
          b = noAttrs;
        let keysA = Object.keys(a), keysB = Object.keys(b);
        if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
          return false;
        for (let key of keysA) {
          if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key]))
            return false;
        }
        return true;
      }
      function updateAttrs(dom, prev, attrs) {
        let changed = false;
        if (prev) {
          for (let name in prev)
            if (!(attrs && name in attrs)) {
              changed = true;
              if (name == "style")
                dom.style.cssText = "";
              else
                dom.removeAttribute(name);
            }
        }
        if (attrs) {
          for (let name in attrs)
            if (!(prev && prev[name] == attrs[name])) {
              changed = true;
              if (name == "style")
                dom.style.cssText = attrs[name];
              else
                dom.setAttribute(name, attrs[name]);
            }
        }
        return changed;
      }
      function getAttrs(dom) {
        let attrs = Object.create(null);
        for (let i = 0; i < dom.attributes.length; i++) {
          let attr = dom.attributes[i];
          attrs[attr.name] = attr.value;
        }
        return attrs;
      }
      var LineView = class extends ContentView {
        constructor() {
          super(...arguments);
          this.children = [];
          this.length = 0;
          this.prevAttrs = void 0;
          this.attrs = null;
          this.breakAfter = 0;
        }
        merge(from, to2, source, hasStart, openStart, openEnd) {
          if (source) {
            if (!(source instanceof LineView))
              return false;
            if (!this.dom)
              source.transferDOM(this);
          }
          if (hasStart)
            this.setDeco(source ? source.attrs : null);
          mergeChildrenInto(this, from, to2, source ? source.children : [], openStart, openEnd);
          return true;
        }
        split(at2) {
          let end = new LineView();
          end.breakAfter = this.breakAfter;
          if (this.length == 0)
            return end;
          let { i, off } = this.childPos(at2);
          if (off) {
            end.append(this.children[i].split(off), 0);
            this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
            i++;
          }
          for (let j2 = i; j2 < this.children.length; j2++)
            end.append(this.children[j2], 0);
          while (i > 0 && this.children[i - 1].length == 0)
            this.children[--i].destroy();
          this.children.length = i;
          this.markDirty();
          this.length = at2;
          return end;
        }
        transferDOM(other) {
          if (!this.dom)
            return;
          this.markDirty();
          other.setDOM(this.dom);
          other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
          this.prevAttrs = void 0;
          this.dom = null;
        }
        setDeco(attrs) {
          if (!attrsEq(this.attrs, attrs)) {
            if (this.dom) {
              this.prevAttrs = this.attrs;
              this.markDirty();
            }
            this.attrs = attrs;
          }
        }
        append(child, openStart) {
          joinInlineInto(this, child, openStart);
        }
        addLineDeco(deco) {
          let attrs = deco.spec.attributes, cls = deco.spec.class;
          if (attrs)
            this.attrs = combineAttrs(attrs, this.attrs || {});
          if (cls)
            this.attrs = combineAttrs({ class: cls }, this.attrs || {});
        }
        domAtPos(pos) {
          return inlineDOMAtPos(this, pos);
        }
        reuseDOM(node) {
          if (node.nodeName == "DIV") {
            this.setDOM(node);
            this.flags |= 4 | 2;
          }
        }
        sync(view, track) {
          var _a2;
          if (!this.dom) {
            this.setDOM(document.createElement("div"));
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : void 0;
          } else if (this.flags & 4) {
            clearAttributes(this.dom);
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : void 0;
          }
          if (this.prevAttrs !== void 0) {
            updateAttrs(this.dom, this.prevAttrs, this.attrs);
            this.dom.classList.add("cm-line");
            this.prevAttrs = void 0;
          }
          super.sync(view, track);
          let last = this.dom.lastChild;
          while (last && ContentView.get(last) instanceof MarkView)
            last = last.lastChild;
          if (!last || !this.length || last.nodeName != "BR" && ((_a2 = ContentView.get(last)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch2) => ch2 instanceof TextView))) {
            let hack = document.createElement("BR");
            hack.cmIgnore = true;
            this.dom.appendChild(hack);
          }
        }
        measureTextSize() {
          if (this.children.length == 0 || this.length > 20)
            return null;
          let totalWidth = 0, textHeight;
          for (let child of this.children) {
            if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
              return null;
            let rects = clientRectsFor(child.dom);
            if (rects.length != 1)
              return null;
            totalWidth += rects[0].width;
            textHeight = rects[0].height;
          }
          return !totalWidth ? null : {
            lineHeight: this.dom.getBoundingClientRect().height,
            charWidth: totalWidth / this.length,
            textHeight
          };
        }
        coordsAt(pos, side) {
          let rect = coordsInChildren(this, pos, side);
          if (!this.children.length && rect && this.parent) {
            let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
            if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
              let dist2 = (height - heightOracle.textHeight) / 2;
              return { top: rect.top + dist2, bottom: rect.bottom - dist2, left: rect.left, right: rect.left };
            }
          }
          return rect;
        }
        become(_other) {
          return false;
        }
        covers() {
          return true;
        }
        static find(docView, pos) {
          for (let i = 0, off = 0; i < docView.children.length; i++) {
            let block = docView.children[i], end = off + block.length;
            if (end >= pos) {
              if (block instanceof LineView)
                return block;
              if (end > pos)
                break;
            }
            off = end + block.breakAfter;
          }
          return null;
        }
      };
      var BlockWidgetView = class extends ContentView {
        constructor(widget, length, deco) {
          super();
          this.widget = widget;
          this.length = length;
          this.deco = deco;
          this.breakAfter = 0;
          this.prevWidget = null;
        }
        merge(from, to2, source, _takeDeco, openStart, openEnd) {
          if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to2 < this.length && openEnd <= 0))
            return false;
          this.length = from + (source ? source.length : 0) + (this.length - to2);
          return true;
        }
        domAtPos(pos) {
          return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
        }
        split(at2) {
          let len = this.length - at2;
          this.length = at2;
          let end = new BlockWidgetView(this.widget, len, this.deco);
          end.breakAfter = this.breakAfter;
          return end;
        }
        get children() {
          return noChildren;
        }
        sync(view) {
          if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
            if (this.dom && this.prevWidget)
              this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(view));
            this.dom.contentEditable = "false";
          }
        }
        get overrideDOMText() {
          return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : state.Text.empty;
        }
        domBoundsAround() {
          return null;
        }
        become(other) {
          if (other instanceof BlockWidgetView && other.widget.constructor == this.widget.constructor) {
            if (!other.widget.compare(this.widget))
              this.markDirty(true);
            if (this.dom && !this.prevWidget)
              this.prevWidget = this.widget;
            this.widget = other.widget;
            this.length = other.length;
            this.deco = other.deco;
            this.breakAfter = other.breakAfter;
            return true;
          }
          return false;
        }
        ignoreMutation() {
          return true;
        }
        ignoreEvent(event2) {
          return this.widget.ignoreEvent(event2);
        }
        get isEditable() {
          return false;
        }
        get isWidget() {
          return true;
        }
        coordsAt(pos, side) {
          return this.widget.coordsAt(this.dom, pos, side);
        }
        destroy() {
          super.destroy();
          if (this.dom)
            this.widget.destroy(this.dom);
        }
        covers(side) {
          let { startSide, endSide } = this.deco;
          return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
        }
      };
      var WidgetType = class {
        eq(widget) {
          return false;
        }
        updateDOM(dom, view) {
          return false;
        }
        compare(other) {
          return this == other || this.constructor == other.constructor && this.eq(other);
        }
        get estimatedHeight() {
          return -1;
        }
        get lineBreaks() {
          return 0;
        }
        ignoreEvent(event2) {
          return true;
        }
        coordsAt(dom, pos, side) {
          return null;
        }
        get isHidden() {
          return false;
        }
        destroy(dom) {
        }
      };
      exports.BlockType = void 0;
      (function(BlockType) {
        BlockType[BlockType["Text"] = 0] = "Text";
        BlockType[BlockType["WidgetBefore"] = 1] = "WidgetBefore";
        BlockType[BlockType["WidgetAfter"] = 2] = "WidgetAfter";
        BlockType[BlockType["WidgetRange"] = 3] = "WidgetRange";
      })(exports.BlockType || (exports.BlockType = {}));
      var Decoration = class extends state.RangeValue {
        constructor(startSide, endSide, widget, spec) {
          super();
          this.startSide = startSide;
          this.endSide = endSide;
          this.widget = widget;
          this.spec = spec;
        }
        get heightRelevant() {
          return false;
        }
        static mark(spec) {
          return new MarkDecoration(spec);
        }
        static widget(spec) {
          let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
          side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
          return new PointDecoration(spec, side, side, block, spec.widget || null, false);
        }
        static replace(spec) {
          let block = !!spec.block, startSide, endSide;
          if (spec.isBlockGap) {
            startSide = -5e8;
            endSide = 4e8;
          } else {
            let { start, end } = getInclusive(spec, block);
            startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
            endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
          }
          return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
        }
        static line(spec) {
          return new LineDecoration(spec);
        }
        static set(of, sort = false) {
          return state.RangeSet.of(of, sort);
        }
        hasHeight() {
          return this.widget ? this.widget.estimatedHeight > -1 : false;
        }
      };
      Decoration.none = state.RangeSet.empty;
      var MarkDecoration = class extends Decoration {
        constructor(spec) {
          let { start, end } = getInclusive(spec);
          super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
          this.tagName = spec.tagName || "span";
          this.class = spec.class || "";
          this.attrs = spec.attributes || null;
        }
        eq(other) {
          var _a2, _b;
          return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && (this.class || ((_a2 = this.attrs) === null || _a2 === void 0 ? void 0 : _a2.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, "class");
        }
        range(from, to2 = from) {
          if (from >= to2)
            throw new RangeError("Mark decorations may not be empty");
          return super.range(from, to2);
        }
      };
      MarkDecoration.prototype.point = false;
      var LineDecoration = class extends Decoration {
        constructor(spec) {
          super(-2e8, -2e8, null, spec);
        }
        eq(other) {
          return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
        }
        range(from, to2 = from) {
          if (to2 != from)
            throw new RangeError("Line decoration ranges must be zero-length");
          return super.range(from, to2);
        }
      };
      LineDecoration.prototype.mapMode = state.MapMode.TrackBefore;
      LineDecoration.prototype.point = true;
      var PointDecoration = class extends Decoration {
        constructor(spec, startSide, endSide, block, widget, isReplace) {
          super(startSide, endSide, widget, spec);
          this.block = block;
          this.isReplace = isReplace;
          this.mapMode = !block ? state.MapMode.TrackDel : startSide <= 0 ? state.MapMode.TrackBefore : state.MapMode.TrackAfter;
        }
        get type() {
          return this.startSide != this.endSide ? exports.BlockType.WidgetRange : this.startSide <= 0 ? exports.BlockType.WidgetBefore : exports.BlockType.WidgetAfter;
        }
        get heightRelevant() {
          return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
        }
        eq(other) {
          return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
        }
        range(from, to2 = from) {
          if (this.isReplace && (from > to2 || from == to2 && this.startSide > 0 && this.endSide <= 0))
            throw new RangeError("Invalid range for replacement decoration");
          if (!this.isReplace && to2 != from)
            throw new RangeError("Widget decorations can only have zero-length ranges");
          return super.range(from, to2);
        }
      };
      PointDecoration.prototype.point = true;
      function getInclusive(spec, block = false) {
        let { inclusiveStart: start, inclusiveEnd: end } = spec;
        if (start == null)
          start = spec.inclusive;
        if (end == null)
          end = spec.inclusive;
        return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
      }
      function widgetsEq(a, b) {
        return a == b || !!(a && b && a.compare(b));
      }
      function addRange(from, to2, ranges, margin = 0) {
        let last = ranges.length - 1;
        if (last >= 0 && ranges[last] + margin >= from)
          ranges[last] = Math.max(ranges[last], to2);
        else
          ranges.push(from, to2);
      }
      var ContentBuilder = class {
        constructor(doc2, pos, end, disallowBlockEffectsFor) {
          this.doc = doc2;
          this.pos = pos;
          this.end = end;
          this.disallowBlockEffectsFor = disallowBlockEffectsFor;
          this.content = [];
          this.curLine = null;
          this.breakAtStart = 0;
          this.pendingBuffer = 0;
          this.bufferMarks = [];
          this.atCursorPos = true;
          this.openStart = -1;
          this.openEnd = -1;
          this.text = "";
          this.textOff = 0;
          this.cursor = doc2.iter();
          this.skip = pos;
        }
        posCovered() {
          if (this.content.length == 0)
            return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
          let last = this.content[this.content.length - 1];
          return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);
        }
        getLine() {
          if (!this.curLine) {
            this.content.push(this.curLine = new LineView());
            this.atCursorPos = true;
          }
          return this.curLine;
        }
        flushBuffer(active = this.bufferMarks) {
          if (this.pendingBuffer) {
            this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
            this.pendingBuffer = 0;
          }
        }
        addBlockWidget(view) {
          this.flushBuffer();
          this.curLine = null;
          this.content.push(view);
        }
        finish(openEnd) {
          if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
            this.flushBuffer();
          else
            this.pendingBuffer = 0;
          if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
            this.getLine();
        }
        buildText(length, active, openStart) {
          while (length > 0) {
            if (this.textOff == this.text.length) {
              let { value, lineBreak, done } = this.cursor.next(this.skip);
              this.skip = 0;
              if (done)
                throw new Error("Ran out of text content when drawing inline views");
              if (lineBreak) {
                if (!this.posCovered())
                  this.getLine();
                if (this.content.length)
                  this.content[this.content.length - 1].breakAfter = 1;
                else
                  this.breakAtStart = 1;
                this.flushBuffer();
                this.curLine = null;
                this.atCursorPos = true;
                length--;
                continue;
              } else {
                this.text = value;
                this.textOff = 0;
              }
            }
            let take = Math.min(this.text.length - this.textOff, length, 512);
            this.flushBuffer(active.slice(active.length - openStart));
            this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
            this.atCursorPos = true;
            this.textOff += take;
            length -= take;
            openStart = 0;
          }
        }
        span(from, to2, active, openStart) {
          this.buildText(to2 - from, active, openStart);
          this.pos = to2;
          if (this.openStart < 0)
            this.openStart = openStart;
        }
        point(from, to2, deco, active, openStart, index) {
          if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
            if (deco.block)
              throw new RangeError("Block decorations may not be specified via plugins");
            if (to2 > this.doc.lineAt(this.pos).to)
              throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
          }
          let len = to2 - from;
          if (deco instanceof PointDecoration) {
            if (deco.block) {
              if (deco.startSide > 0 && !this.posCovered())
                this.getLine();
              this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, deco));
            } else {
              let view = WidgetView.create(deco.widget || new NullWidget("span"), len, len ? 0 : deco.startSide);
              let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to2 || deco.startSide > 0);
              let cursorAfter = !view.isEditable && (from < to2 || openStart > active.length || deco.startSide <= 0);
              let line = this.getLine();
              if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable)
                this.pendingBuffer = 0;
              this.flushBuffer(active);
              if (cursorBefore) {
                line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
                openStart = active.length + Math.max(0, openStart - active.length);
              }
              line.append(wrapMarks(view, active), openStart);
              this.atCursorPos = cursorAfter;
              this.pendingBuffer = !cursorAfter ? 0 : from < to2 || openStart > active.length ? 1 : 2;
              if (this.pendingBuffer)
                this.bufferMarks = active.slice();
            }
          } else if (this.doc.lineAt(this.pos).from == this.pos) {
            this.getLine().addLineDeco(deco);
          }
          if (len) {
            if (this.textOff + len <= this.text.length) {
              this.textOff += len;
            } else {
              this.skip += len - (this.text.length - this.textOff);
              this.text = "";
              this.textOff = 0;
            }
            this.pos = to2;
          }
          if (this.openStart < 0)
            this.openStart = openStart;
        }
        static build(text, from, to2, decorations2, dynamicDecorationMap) {
          let builder = new ContentBuilder(text, from, to2, dynamicDecorationMap);
          builder.openEnd = state.RangeSet.spans(decorations2, from, to2, builder);
          if (builder.openStart < 0)
            builder.openStart = builder.openEnd;
          builder.finish(builder.openEnd);
          return builder;
        }
      };
      function wrapMarks(view, active) {
        for (let mark of active)
          view = new MarkView(mark, [view], view.length);
        return view;
      }
      var NullWidget = class extends WidgetType {
        constructor(tag) {
          super();
          this.tag = tag;
        }
        eq(other) {
          return other.tag == this.tag;
        }
        toDOM() {
          return document.createElement(this.tag);
        }
        updateDOM(elt) {
          return elt.nodeName.toLowerCase() == this.tag;
        }
        get isHidden() {
          return true;
        }
      };
      var clickAddsSelectionRange = state.Facet.define();
      var dragMovesSelection$1 = state.Facet.define();
      var mouseSelectionStyle = state.Facet.define();
      var exceptionSink = state.Facet.define();
      var updateListener = state.Facet.define();
      var inputHandler = state.Facet.define();
      var focusChangeEffect = state.Facet.define();
      var perLineTextDirection = state.Facet.define({
        combine: (values) => values.some((x) => x)
      });
      var nativeSelectionHidden = state.Facet.define({
        combine: (values) => values.some((x) => x)
      });
      var ScrollTarget = class {
        constructor(range, y2 = "nearest", x = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
          this.range = range;
          this.y = y2;
          this.x = x;
          this.yMargin = yMargin;
          this.xMargin = xMargin;
          this.isSnapshot = isSnapshot;
        }
        map(changes) {
          return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
        }
        clip(state$1) {
          return this.range.to <= state$1.doc.length ? this : new ScrollTarget(state.EditorSelection.cursor(state$1.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
        }
      };
      var scrollIntoView = state.StateEffect.define({ map: (t, ch2) => t.map(ch2) });
      function logException(state2, exception, context) {
        let handler = state2.facet(exceptionSink);
        if (handler.length)
          handler[0](exception);
        else if (window.onerror)
          window.onerror(String(exception), context, void 0, void 0, exception);
        else if (context)
          console.error(context + ":", exception);
        else
          console.error(exception);
      }
      var editable = state.Facet.define({ combine: (values) => values.length ? values[0] : true });
      var nextPluginID = 0;
      var viewPlugin = state.Facet.define();
      var ViewPlugin = class {
        constructor(id, create, domEventHandlers, domEventObservers, buildExtensions) {
          this.id = id;
          this.create = create;
          this.domEventHandlers = domEventHandlers;
          this.domEventObservers = domEventObservers;
          this.extension = buildExtensions(this);
        }
        static define(create, spec) {
          const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
          return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, (plugin2) => {
            let ext = [viewPlugin.of(plugin2)];
            if (deco)
              ext.push(decorations.of((view) => {
                let pluginInst = view.plugin(plugin2);
                return pluginInst ? deco(pluginInst) : Decoration.none;
              }));
            if (provide)
              ext.push(provide(plugin2));
            return ext;
          });
        }
        static fromClass(cls, spec) {
          return ViewPlugin.define((view) => new cls(view), spec);
        }
      };
      var PluginInstance = class {
        constructor(spec) {
          this.spec = spec;
          this.mustUpdate = null;
          this.value = null;
        }
        update(view) {
          if (!this.value) {
            if (this.spec) {
              try {
                this.value = this.spec.create(view);
              } catch (e) {
                logException(view.state, e, "CodeMirror plugin crashed");
                this.deactivate();
              }
            }
          } else if (this.mustUpdate) {
            let update = this.mustUpdate;
            this.mustUpdate = null;
            if (this.value.update) {
              try {
                this.value.update(update);
              } catch (e) {
                logException(update.state, e, "CodeMirror plugin crashed");
                if (this.value.destroy)
                  try {
                    this.value.destroy();
                  } catch (_) {
                  }
                this.deactivate();
              }
            }
          }
          return this;
        }
        destroy(view) {
          var _a2;
          if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
            try {
              this.value.destroy();
            } catch (e) {
              logException(view.state, e, "CodeMirror plugin crashed");
            }
          }
        }
        deactivate() {
          this.spec = this.value = null;
        }
      };
      var editorAttributes = state.Facet.define();
      var contentAttributes = state.Facet.define();
      var decorations = state.Facet.define();
      var atomicRanges = state.Facet.define();
      var bidiIsolatedRanges = state.Facet.define();
      function getIsolatedRanges(view, from, to2) {
        let isolates = view.state.facet(bidiIsolatedRanges);
        if (!isolates.length)
          return isolates;
        let sets = isolates.map((i) => i instanceof Function ? i(view) : i);
        let result = [];
        state.RangeSet.spans(sets, from, to2, {
          point() {
          },
          span(from2, to3, active, open) {
            let level = result;
            for (let i = active.length - 1; i >= 0; i--, open--) {
              let iso = active[i].spec.bidiIsolate, update;
              if (iso == null)
                continue;
              if (open > 0 && level.length && (update = level[level.length - 1]).to == from2 && update.direction == iso) {
                update.to = to3;
                level = update.inner;
              } else {
                let add = { from: from2, to: to3, direction: iso, inner: [] };
                level.push(add);
                level = add.inner;
              }
            }
          }
        });
        return result;
      }
      var scrollMargins = state.Facet.define();
      function getScrollMargins(view) {
        let left = 0, right = 0, top = 0, bottom = 0;
        for (let source of view.state.facet(scrollMargins)) {
          let m = source(view);
          if (m) {
            if (m.left != null)
              left = Math.max(left, m.left);
            if (m.right != null)
              right = Math.max(right, m.right);
            if (m.top != null)
              top = Math.max(top, m.top);
            if (m.bottom != null)
              bottom = Math.max(bottom, m.bottom);
          }
        }
        return { left, right, top, bottom };
      }
      var styleModule = state.Facet.define();
      var ChangedRange = class {
        constructor(fromA, toA, fromB, toB) {
          this.fromA = fromA;
          this.toA = toA;
          this.fromB = fromB;
          this.toB = toB;
        }
        join(other) {
          return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
        }
        addToSet(set) {
          let i = set.length, me2 = this;
          for (; i > 0; i--) {
            let range = set[i - 1];
            if (range.fromA > me2.toA)
              continue;
            if (range.toA < me2.fromA)
              break;
            me2 = me2.join(range);
            set.splice(i - 1, 1);
          }
          set.splice(i, 0, me2);
          return set;
        }
        static extendWithRanges(diff, ranges) {
          if (ranges.length == 0)
            return diff;
          let result = [];
          for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
            let next = dI == diff.length ? null : diff[dI], off = posA - posB;
            let end = next ? next.fromB : 1e9;
            while (rI < ranges.length && ranges[rI] < end) {
              let from = ranges[rI], to2 = ranges[rI + 1];
              let fromB = Math.max(posB, from), toB = Math.min(end, to2);
              if (fromB <= toB)
                new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
              if (to2 > end)
                break;
              else
                rI += 2;
            }
            if (!next)
              return result;
            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
            posA = next.toA;
            posB = next.toB;
          }
        }
      };
      var ViewUpdate = class {
        constructor(view, state$1, transactions) {
          this.view = view;
          this.state = state$1;
          this.transactions = transactions;
          this.flags = 0;
          this.startState = view.state;
          this.changes = state.ChangeSet.empty(this.startState.doc.length);
          for (let tr2 of transactions)
            this.changes = this.changes.compose(tr2.changes);
          let changedRanges = [];
          this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
          this.changedRanges = changedRanges;
        }
        static create(view, state2, transactions) {
          return new ViewUpdate(view, state2, transactions);
        }
        get viewportChanged() {
          return (this.flags & 4) > 0;
        }
        get heightChanged() {
          return (this.flags & 2) > 0;
        }
        get geometryChanged() {
          return this.docChanged || (this.flags & (8 | 2)) > 0;
        }
        get focusChanged() {
          return (this.flags & 1) > 0;
        }
        get docChanged() {
          return !this.changes.empty;
        }
        get selectionSet() {
          return this.transactions.some((tr2) => tr2.selection);
        }
        get empty() {
          return this.flags == 0 && this.transactions.length == 0;
        }
      };
      exports.Direction = void 0;
      (function(Direction) {
        Direction[Direction["LTR"] = 0] = "LTR";
        Direction[Direction["RTL"] = 1] = "RTL";
      })(exports.Direction || (exports.Direction = {}));
      var LTR = exports.Direction.LTR;
      var RTL = exports.Direction.RTL;
      function dec(str) {
        let result = [];
        for (let i = 0; i < str.length; i++)
          result.push(1 << +str[i]);
        return result;
      }
      var LowTypes = dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
      var ArabicTypes = dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
      var Brackets = Object.create(null);
      var BracketStack = [];
      for (let p of ["()", "[]", "{}"]) {
        let l = p.charCodeAt(0), r = p.charCodeAt(1);
        Brackets[l] = r;
        Brackets[r] = -l;
      }
      function charType(ch2) {
        return ch2 <= 247 ? LowTypes[ch2] : 1424 <= ch2 && ch2 <= 1524 ? 2 : 1536 <= ch2 && ch2 <= 1785 ? ArabicTypes[ch2 - 1536] : 1774 <= ch2 && ch2 <= 2220 ? 4 : 8192 <= ch2 && ch2 <= 8203 ? 256 : 64336 <= ch2 && ch2 <= 65023 ? 4 : ch2 == 8204 ? 256 : 1;
      }
      var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
      var BidiSpan = class {
        get dir() {
          return this.level % 2 ? RTL : LTR;
        }
        constructor(from, to2, level) {
          this.from = from;
          this.to = to2;
          this.level = level;
        }
        side(end, dir) {
          return this.dir == dir == end ? this.to : this.from;
        }
        static find(order, index, level, assoc) {
          let maybe = -1;
          for (let i = 0; i < order.length; i++) {
            let span = order[i];
            if (span.from <= index && span.to >= index) {
              if (span.level == level)
                return i;
              if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level))
                maybe = i;
            }
          }
          if (maybe < 0)
            throw new RangeError("Index out of range");
          return maybe;
        }
      };
      function isolatesEq(a, b) {
        if (a.length != b.length)
          return false;
        for (let i = 0; i < a.length; i++) {
          let iA = a[i], iB = b[i];
          if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
            return false;
        }
        return true;
      }
      var types = [];
      function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
        for (let iI = 0; iI <= isolates.length; iI++) {
          let from = iI ? isolates[iI - 1].to : rFrom, to2 = iI < isolates.length ? isolates[iI].from : rTo;
          let prevType = iI ? 256 : outerType;
          for (let i = from, prev = prevType, prevStrong = prevType; i < to2; i++) {
            let type = charType(line.charCodeAt(i));
            if (type == 512)
              type = prev;
            else if (type == 8 && prevStrong == 4)
              type = 16;
            types[i] = type == 4 ? 2 : type;
            if (type & 7)
              prevStrong = type;
            prev = type;
          }
          for (let i = from, prev = prevType, prevStrong = prevType; i < to2; i++) {
            let type = types[i];
            if (type == 128) {
              if (i < to2 - 1 && prev == types[i + 1] && prev & 24)
                type = types[i] = prev;
              else
                types[i] = 256;
            } else if (type == 64) {
              let end = i + 1;
              while (end < to2 && types[end] == 64)
                end++;
              let replace = i && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
              for (let j2 = i; j2 < end; j2++)
                types[j2] = replace;
              i = end - 1;
            } else if (type == 8 && prevStrong == 1) {
              types[i] = 1;
            }
            prev = type;
            if (type & 7)
              prevStrong = type;
          }
        }
      }
      function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
        let oppositeType = outerType == 1 ? 2 : 1;
        for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
          let from = iI ? isolates[iI - 1].to : rFrom, to2 = iI < isolates.length ? isolates[iI].from : rTo;
          for (let i = from, ch2, br, type; i < to2; i++) {
            if (br = Brackets[ch2 = line.charCodeAt(i)]) {
              if (br < 0) {
                for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                  if (BracketStack[sJ + 1] == -br) {
                    let flags = BracketStack[sJ + 2];
                    let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
                    if (type2)
                      types[i] = types[BracketStack[sJ]] = type2;
                    sI = sJ;
                    break;
                  }
                }
              } else if (BracketStack.length == 189) {
                break;
              } else {
                BracketStack[sI++] = i;
                BracketStack[sI++] = ch2;
                BracketStack[sI++] = context;
              }
            } else if ((type = types[i]) == 2 || type == 1) {
              let embed = type == outerType;
              context = embed ? 0 : 1;
              for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                let cur = BracketStack[sJ + 2];
                if (cur & 2)
                  break;
                if (embed) {
                  BracketStack[sJ + 2] |= 2;
                } else {
                  if (cur & 4)
                    break;
                  BracketStack[sJ + 2] |= 4;
                }
              }
            }
          }
        }
      }
      function processNeutrals(rFrom, rTo, isolates, outerType) {
        for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
          let from = iI ? isolates[iI - 1].to : rFrom, to2 = iI < isolates.length ? isolates[iI].from : rTo;
          for (let i = from; i < to2; ) {
            let type = types[i];
            if (type == 256) {
              let end = i + 1;
              for (; ; ) {
                if (end == to2) {
                  if (iI == isolates.length)
                    break;
                  end = isolates[iI++].to;
                  to2 = iI < isolates.length ? isolates[iI].from : rTo;
                } else if (types[end] == 256) {
                  end++;
                } else {
                  break;
                }
              }
              let beforeL = prev == 1;
              let afterL = (end < rTo ? types[end] : outerType) == 1;
              let replace = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
              for (let j2 = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j2 > i; ) {
                if (j2 == fromJ) {
                  j2 = isolates[--jI].from;
                  fromJ = jI ? isolates[jI - 1].to : rFrom;
                }
                types[--j2] = replace;
              }
              i = end;
            } else {
              prev = type;
              i++;
            }
          }
        }
      }
      function emitSpans(line, from, to2, level, baseLevel, isolates, order) {
        let ourType = level % 2 ? 2 : 1;
        if (level % 2 == baseLevel % 2) {
          for (let iCh = from, iI = 0; iCh < to2; ) {
            let sameDir = true, isNum = false;
            if (iI == isolates.length || iCh < isolates[iI].from) {
              let next = types[iCh];
              if (next != ourType) {
                sameDir = false;
                isNum = next == 16;
              }
            }
            let recurse = !sameDir && ourType == 1 ? [] : null;
            let localLevel = sameDir ? level : level + 1;
            let iScan = iCh;
            run:
              for (; ; ) {
                if (iI < isolates.length && iScan == isolates[iI].from) {
                  if (isNum)
                    break run;
                  let iso = isolates[iI];
                  if (!sameDir)
                    for (let upto = iso.to, jI = iI + 1; ; ) {
                      if (upto == to2)
                        break run;
                      if (jI < isolates.length && isolates[jI].from == upto)
                        upto = isolates[jI++].to;
                      else if (types[upto] == ourType)
                        break run;
                      else
                        break;
                    }
                  iI++;
                  if (recurse) {
                    recurse.push(iso);
                  } else {
                    if (iso.from > iCh)
                      order.push(new BidiSpan(iCh, iso.from, localLevel));
                    let dirSwap = iso.direction == LTR != !(localLevel % 2);
                    computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                    iCh = iso.to;
                  }
                  iScan = iso.to;
                } else if (iScan == to2 || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
                  break;
                } else {
                  iScan++;
                }
              }
            if (recurse)
              emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
            else if (iCh < iScan)
              order.push(new BidiSpan(iCh, iScan, localLevel));
            iCh = iScan;
          }
        } else {
          for (let iCh = to2, iI = isolates.length; iCh > from; ) {
            let sameDir = true, isNum = false;
            if (!iI || iCh > isolates[iI - 1].to) {
              let next = types[iCh - 1];
              if (next != ourType) {
                sameDir = false;
                isNum = next == 16;
              }
            }
            let recurse = !sameDir && ourType == 1 ? [] : null;
            let localLevel = sameDir ? level : level + 1;
            let iScan = iCh;
            run:
              for (; ; ) {
                if (iI && iScan == isolates[iI - 1].to) {
                  if (isNum)
                    break run;
                  let iso = isolates[--iI];
                  if (!sameDir)
                    for (let upto = iso.from, jI = iI; ; ) {
                      if (upto == from)
                        break run;
                      if (jI && isolates[jI - 1].to == upto)
                        upto = isolates[--jI].from;
                      else if (types[upto - 1] == ourType)
                        break run;
                      else
                        break;
                    }
                  if (recurse) {
                    recurse.push(iso);
                  } else {
                    if (iso.to < iCh)
                      order.push(new BidiSpan(iso.to, iCh, localLevel));
                    let dirSwap = iso.direction == LTR != !(localLevel % 2);
                    computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                    iCh = iso.from;
                  }
                  iScan = iso.from;
                } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
                  break;
                } else {
                  iScan--;
                }
              }
            if (recurse)
              emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
            else if (iScan < iCh)
              order.push(new BidiSpan(iScan, iCh, localLevel));
            iCh = iScan;
          }
        }
      }
      function computeSectionOrder(line, level, baseLevel, isolates, from, to2, order) {
        let outerType = level % 2 ? 2 : 1;
        computeCharTypes(line, from, to2, isolates, outerType);
        processBracketPairs(line, from, to2, isolates, outerType);
        processNeutrals(from, to2, isolates, outerType);
        emitSpans(line, from, to2, level, baseLevel, isolates, order);
      }
      function computeOrder(line, direction, isolates) {
        if (!line)
          return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
        if (direction == LTR && !isolates.length && !BidiRE.test(line))
          return trivialOrder(line.length);
        if (isolates.length)
          while (line.length > types.length)
            types[types.length] = 256;
        let order = [], level = direction == LTR ? 0 : 1;
        computeSectionOrder(line, level, level, isolates, 0, line.length, order);
        return order;
      }
      function trivialOrder(length) {
        return [new BidiSpan(0, length, 0)];
      }
      var movedOver = "";
      function moveVisually(line, order, dir, start, forward) {
        var _a2;
        let startIndex = start.head - line.from, spanI = -1;
        if (startIndex == 0) {
          if (!forward || !line.length)
            return null;
          if (order[0].level != dir) {
            startIndex = order[0].side(false, dir);
            spanI = 0;
          }
        } else if (startIndex == line.length) {
          if (forward)
            return null;
          let last = order[order.length - 1];
          if (last.level != dir) {
            startIndex = last.side(true, dir);
            spanI = order.length - 1;
          }
        }
        if (spanI < 0)
          spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
        let span = order[spanI];
        if (startIndex == span.side(forward, dir)) {
          span = order[spanI += forward ? 1 : -1];
          startIndex = span.side(!forward, dir);
        }
        let indexForward = forward == (span.dir == dir);
        let nextIndex = state.findClusterBreak(line.text, startIndex, indexForward);
        movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
        if (nextIndex != span.side(forward, dir))
          return state.EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
        let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
        if (!nextSpan && span.level != dir)
          return state.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
        if (nextSpan && nextSpan.level < span.level)
          return state.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
        return state.EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
      }
      var DocView = class extends ContentView {
        get length() {
          return this.view.state.doc.length;
        }
        constructor(view) {
          super();
          this.view = view;
          this.decorations = [];
          this.dynamicDecorationMap = [];
          this.domChanged = null;
          this.hasComposition = null;
          this.markedForComposition = new Set();
          this.minWidth = 0;
          this.minWidthFrom = 0;
          this.minWidthTo = 0;
          this.impreciseAnchor = null;
          this.impreciseHead = null;
          this.forceSelection = false;
          this.lastUpdate = Date.now();
          this.setDOM(view.contentDOM);
          this.children = [new LineView()];
          this.children[0].setParent(this);
          this.updateDeco();
          this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
        }
        update(update) {
          var _a2;
          let changedRanges = update.changedRanges;
          if (this.minWidth > 0 && changedRanges.length) {
            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
              this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
            } else {
              this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
              this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
            }
          }
          let readCompositionAt = -1;
          if (this.view.inputState.composing >= 0) {
            if ((_a2 = this.domChanged) === null || _a2 === void 0 ? void 0 : _a2.newSel)
              readCompositionAt = this.domChanged.newSel.head;
            else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
              readCompositionAt = update.state.selection.main.head;
          }
          let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
          this.domChanged = null;
          if (this.hasComposition) {
            this.markedForComposition.clear();
            let { from, to: to2 } = this.hasComposition;
            changedRanges = new ChangedRange(from, to2, update.changes.mapPos(from, -1), update.changes.mapPos(to2, 1)).addToSet(changedRanges.slice());
          }
          this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
          if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines)
            this.forceSelection = true;
          let prevDeco = this.decorations, deco = this.updateDeco();
          let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
          changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
          if (!(this.flags & 7) && changedRanges.length == 0) {
            return false;
          } else {
            this.updateInner(changedRanges, update.startState.doc.length, composition);
            if (update.transactions.length)
              this.lastUpdate = Date.now();
            return true;
          }
        }
        updateInner(changes, oldLength, composition) {
          this.view.viewState.mustMeasureContent = true;
          this.updateChildren(changes, oldLength, composition);
          let { observer } = this.view;
          observer.ignore(() => {
            this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
            this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
            let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
            this.sync(this.view, track);
            this.flags &= ~7;
            if (track && (track.written || observer.selectionRange.focusNode != track.node))
              this.forceSelection = true;
            this.dom.style.height = "";
          });
          this.markedForComposition.forEach((cView) => cView.flags &= ~8);
          let gaps = [];
          if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
            for (let child of this.children)
              if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
                gaps.push(child.dom);
          }
          observer.updateGaps(gaps);
        }
        updateChildren(changes, oldLength, composition) {
          let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
          let cursor = this.childCursor(oldLength);
          for (let i = ranges.length - 1; ; i--) {
            let next = i >= 0 ? ranges[i] : null;
            if (!next)
              break;
            let { fromA, toA, fromB, toB } = next, content, breakAtStart, openStart, openEnd;
            if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
              let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
              let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
              breakAtStart = before.breakAtStart;
              openStart = before.openStart;
              openEnd = after.openEnd;
              let compLine = this.compositionView(composition);
              if (after.breakAtStart) {
                compLine.breakAfter = 1;
              } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
                compLine.breakAfter = after.content[0].breakAfter;
                after.content.shift();
              }
              if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
                before.content.pop();
              }
              content = before.content.concat(compLine).concat(after.content);
            } else {
              ({ content, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
            }
            let { i: toI, off: toOff } = cursor.findPos(toA, 1);
            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
            replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);
          }
          if (composition)
            this.fixCompositionDOM(composition);
        }
        compositionView(composition) {
          let cur = new TextView(composition.text.nodeValue);
          cur.flags |= 8;
          for (let { deco } of composition.marks)
            cur = new MarkView(deco, [cur], cur.length);
          let line = new LineView();
          line.append(cur, 0);
          return line;
        }
        fixCompositionDOM(composition) {
          let fix = (dom, cView2) => {
            cView2.flags |= 8 | (cView2.children.some((c2) => c2.flags & 7) ? 1 : 0);
            this.markedForComposition.add(cView2);
            let prev = ContentView.get(dom);
            if (prev && prev != cView2)
              prev.dom = null;
            cView2.setDOM(dom);
          };
          let pos = this.childPos(composition.range.fromB, 1);
          let cView = this.children[pos.i];
          fix(composition.line, cView);
          for (let i = composition.marks.length - 1; i >= -1; i--) {
            pos = cView.childPos(pos.off, 1);
            cView = cView.children[pos.i];
            fix(i >= 0 ? composition.marks[i].node : composition.text, cView);
          }
        }
        updateSelection(mustRead = false, fromPointer = false) {
          if (mustRead || !this.view.observer.selectionRange.focusNode)
            this.view.observer.readSelectionRange();
          let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
          let selectionNotFocus = !focused && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
          if (!(focused || fromPointer || selectionNotFocus))
            return;
          let force = this.forceSelection;
          this.forceSelection = false;
          let main = this.view.state.selection.main;
          let anchor = this.moveToLine(this.domAtPos(main.anchor));
          let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
          if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
            let dummy = document.createTextNode("");
            this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
            anchor = head = new DOMPos(dummy, 0);
            force = true;
          }
          let domSel = this.view.observer.selectionRange;
          if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
            this.view.observer.ignore(() => {
              if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
                this.dom.blur();
                this.dom.focus({ preventScroll: true });
              }
              let rawSel = getSelection(this.view.root);
              if (!rawSel)
                ;
              else if (main.empty) {
                if (browser.gecko) {
                  let nextTo = nextToUneditable(anchor.node, anchor.offset);
                  if (nextTo && nextTo != (1 | 2)) {
                    let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
                    if (text)
                      anchor = new DOMPos(text.node, text.offset);
                  }
                }
                rawSel.collapse(anchor.node, anchor.offset);
                if (main.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
                  rawSel.caretBidiLevel = main.bidiLevel;
              } else if (rawSel.extend) {
                rawSel.collapse(anchor.node, anchor.offset);
                try {
                  rawSel.extend(head.node, head.offset);
                } catch (_) {
                }
              } else {
                let range = document.createRange();
                if (main.anchor > main.head)
                  [anchor, head] = [head, anchor];
                range.setEnd(head.node, head.offset);
                range.setStart(anchor.node, anchor.offset);
                rawSel.removeAllRanges();
                rawSel.addRange(range);
              }
              if (selectionNotFocus && this.view.root.activeElement == this.dom) {
                this.dom.blur();
                if (activeElt)
                  activeElt.focus();
              }
            });
            this.view.observer.setSelectionRange(anchor, head);
          }
          this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
          this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
        }
        enforceCursorAssoc() {
          if (this.hasComposition)
            return;
          let { view } = this, cursor = view.state.selection.main;
          let sel = getSelection(view.root);
          let { anchorNode, anchorOffset } = view.observer.selectionRange;
          if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
            return;
          let line = LineView.find(this, cursor.head);
          if (!line)
            return;
          let lineStart = line.posAtStart;
          if (cursor.head == lineStart || cursor.head == lineStart + line.length)
            return;
          let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
          if (!before || !after || before.bottom > after.top)
            return;
          let dom = this.domAtPos(cursor.head + cursor.assoc);
          sel.collapse(dom.node, dom.offset);
          sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
          view.observer.readSelectionRange();
          let newRange = view.observer.selectionRange;
          if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
            sel.collapse(anchorNode, anchorOffset);
        }
        moveToLine(pos) {
          let dom = this.dom, newPos;
          if (pos.node != dom)
            return pos;
          for (let i = pos.offset; !newPos && i < dom.childNodes.length; i++) {
            let view = ContentView.get(dom.childNodes[i]);
            if (view instanceof LineView)
              newPos = view.domAtPos(0);
          }
          for (let i = pos.offset - 1; !newPos && i >= 0; i--) {
            let view = ContentView.get(dom.childNodes[i]);
            if (view instanceof LineView)
              newPos = view.domAtPos(view.length);
          }
          return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
        }
        nearest(dom) {
          for (let cur = dom; cur; ) {
            let domView = ContentView.get(cur);
            if (domView && domView.rootView == this)
              return domView;
            cur = cur.parentNode;
          }
          return null;
        }
        posFromDOM(node, offset) {
          let view = this.nearest(node);
          if (!view)
            throw new RangeError("Trying to find position for a DOM position outside of the document");
          return view.localPosFromDOM(node, offset) + view.posAtStart;
        }
        domAtPos(pos) {
          let { i, off } = this.childCursor().findPos(pos, -1);
          for (; i < this.children.length - 1; ) {
            let child = this.children[i];
            if (off < child.length || child instanceof LineView)
              break;
            i++;
            off = 0;
          }
          return this.children[i].domAtPos(off);
        }
        coordsAt(pos, side) {
          let best = null, bestPos = 0;
          for (let off = this.length, i = this.children.length - 1; i >= 0; i--) {
            let child = this.children[i], end = off - child.breakAfter, start = end - child.length;
            if (end < pos)
              break;
            if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
              best = child;
              bestPos = start;
            }
            off = start;
          }
          return best ? best.coordsAt(pos - bestPos, side) : null;
        }
        coordsForChar(pos) {
          let { i, off } = this.childPos(pos, 1), child = this.children[i];
          if (!(child instanceof LineView))
            return null;
          while (child.children.length) {
            let { i: i2, off: childOff } = child.childPos(off, 1);
            for (; ; i2++) {
              if (i2 == child.children.length)
                return null;
              if ((child = child.children[i2]).length)
                break;
            }
            off = childOff;
          }
          if (!(child instanceof TextView))
            return null;
          let end = state.findClusterBreak(child.text, off);
          if (end == off)
            return null;
          let rects = textRange(child.dom, off, end).getClientRects();
          for (let i2 = 0; i2 < rects.length; i2++) {
            let rect = rects[i2];
            if (i2 == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
              return rect;
          }
          return null;
        }
        measureVisibleLineHeights(viewport) {
          let result = [], { from, to: to2 } = viewport;
          let contentWidth = this.view.contentDOM.clientWidth;
          let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
          let widest = -1, ltr = this.view.textDirection == exports.Direction.LTR;
          for (let pos = 0, i = 0; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (end > to2)
              break;
            if (pos >= from) {
              let childRect = child.dom.getBoundingClientRect();
              result.push(childRect.height);
              if (isWider) {
                let last = child.dom.lastChild;
                let rects = last ? clientRectsFor(last) : [];
                if (rects.length) {
                  let rect = rects[rects.length - 1];
                  let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
                  if (width > widest) {
                    widest = width;
                    this.minWidth = contentWidth;
                    this.minWidthFrom = pos;
                    this.minWidthTo = end;
                  }
                }
              }
            }
            pos = end + child.breakAfter;
          }
          return result;
        }
        textDirectionAt(pos) {
          let { i } = this.childPos(pos, 1);
          return getComputedStyle(this.children[i].dom).direction == "rtl" ? exports.Direction.RTL : exports.Direction.LTR;
        }
        measureTextSize() {
          for (let child of this.children) {
            if (child instanceof LineView) {
              let measure = child.measureTextSize();
              if (measure)
                return measure;
            }
          }
          let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
          dummy.className = "cm-line";
          dummy.style.width = "99999px";
          dummy.style.position = "absolute";
          dummy.textContent = "abc def ghi jkl mno pqr stu";
          this.view.observer.ignore(() => {
            this.dom.appendChild(dummy);
            let rect = clientRectsFor(dummy.firstChild)[0];
            lineHeight = dummy.getBoundingClientRect().height;
            charWidth = rect ? rect.width / 27 : 7;
            textHeight = rect ? rect.height : lineHeight;
            dummy.remove();
          });
          return { lineHeight, charWidth, textHeight };
        }
        childCursor(pos = this.length) {
          let i = this.children.length;
          if (i)
            pos -= this.children[--i].length;
          return new ChildCursor(this.children, pos, i);
        }
        computeBlockGapDeco() {
          let deco = [], vs2 = this.view.viewState;
          for (let pos = 0, i = 0; ; i++) {
            let next = i == vs2.viewports.length ? null : vs2.viewports[i];
            let end = next ? next.from - 1 : this.length;
            if (end > pos) {
              let height = (vs2.lineBlockAt(end).bottom - vs2.lineBlockAt(pos).top) / this.view.scaleY;
              deco.push(Decoration.replace({
                widget: new BlockGapWidget(height),
                block: true,
                inclusive: true,
                isBlockGap: true
              }).range(pos, end));
            }
            if (!next)
              break;
            pos = next.to + 1;
          }
          return Decoration.set(deco);
        }
        updateDeco() {
          let allDeco = this.view.state.facet(decorations).map((d2, i) => {
            let dynamic = this.dynamicDecorationMap[i] = typeof d2 == "function";
            return dynamic ? d2(this.view) : d2;
          });
          for (let i = allDeco.length; i < allDeco.length + 3; i++)
            this.dynamicDecorationMap[i] = false;
          return this.decorations = [
            ...allDeco,
            this.computeBlockGapDeco(),
            this.view.viewState.lineGapDeco
          ];
        }
        scrollIntoView(target) {
          if (target.isSnapshot) {
            let ref = this.view.viewState.lineBlockAt(target.range.head);
            this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
            this.view.scrollDOM.scrollLeft = target.xMargin;
            return;
          }
          let { range } = target;
          let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
          if (!rect)
            return;
          if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
            rect = {
              left: Math.min(rect.left, other.left),
              top: Math.min(rect.top, other.top),
              right: Math.max(rect.right, other.right),
              bottom: Math.max(rect.bottom, other.bottom)
            };
          let margins = getScrollMargins(this.view);
          let targetRect = {
            left: rect.left - margins.left,
            top: rect.top - margins.top,
            right: rect.right + margins.right,
            bottom: rect.bottom + margins.bottom
          };
          let { offsetWidth, offsetHeight } = this.view.scrollDOM;
          scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == exports.Direction.LTR);
        }
      };
      function betweenUneditable(pos) {
        return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
      }
      var BlockGapWidget = class extends WidgetType {
        constructor(height) {
          super();
          this.height = height;
        }
        toDOM() {
          let elt = document.createElement("div");
          this.updateDOM(elt);
          return elt;
        }
        eq(other) {
          return other.height == this.height;
        }
        updateDOM(elt) {
          elt.style.height = this.height + "px";
          return true;
        }
        get estimatedHeight() {
          return this.height;
        }
      };
      function findCompositionNode(view, headPos) {
        let sel = view.observer.selectionRange;
        let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
        if (!textNode)
          return null;
        let from = headPos - textNode.offset;
        return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };
      }
      function findCompositionRange(view, changes, headPos) {
        let found = findCompositionNode(view, headPos);
        if (!found)
          return null;
        let { node: textNode, from, to: to2 } = found, text = textNode.nodeValue;
        if (/[\n\r]/.test(text))
          return null;
        if (view.state.doc.sliceString(found.from, found.to) != text)
          return null;
        let inv = changes.invertedDesc;
        let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to2), from, to2);
        let marks = [];
        for (let parent = textNode.parentNode; ; parent = parent.parentNode) {
          let parentView = ContentView.get(parent);
          if (parentView instanceof MarkView)
            marks.push({ node: parent, deco: parentView.mark });
          else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
            return { range, text: textNode, marks, line: parent };
          else if (parent != view.contentDOM)
            marks.push({ node: parent, deco: new MarkDecoration({
              inclusive: true,
              attributes: getAttrs(parent),
              tagName: parent.tagName.toLowerCase()
            }) });
          else
            return null;
        }
      }
      function nearbyTextNode(startNode, startOffset, side) {
        if (side <= 0)
          for (let node = startNode, offset = startOffset; ; ) {
            if (node.nodeType == 3)
              return { node, offset };
            if (node.nodeType == 1 && offset > 0) {
              node = node.childNodes[offset - 1];
              offset = maxOffset(node);
            } else {
              break;
            }
          }
        if (side >= 0)
          for (let node = startNode, offset = startOffset; ; ) {
            if (node.nodeType == 3)
              return { node, offset };
            if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
              node = node.childNodes[offset];
              offset = 0;
            } else {
              break;
            }
          }
        return null;
      }
      function nextToUneditable(node, offset) {
        if (node.nodeType != 1)
          return 0;
        return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
      }
      var DecorationComparator$1 = class DecorationComparator {
        constructor() {
          this.changes = [];
        }
        compareRange(from, to2) {
          addRange(from, to2, this.changes);
        }
        comparePoint(from, to2) {
          addRange(from, to2, this.changes);
        }
      };
      function findChangedDeco(a, b, diff) {
        let comp = new DecorationComparator$1();
        state.RangeSet.compare(a, b, diff, comp);
        return comp.changes;
      }
      function inUneditable(node, inside2) {
        for (let cur = node; cur && cur != inside2; cur = cur.assignedSlot || cur.parentNode) {
          if (cur.nodeType == 1 && cur.contentEditable == "false") {
            return true;
          }
        }
        return false;
      }
      function touchesComposition(changes, composition) {
        let touched = false;
        if (composition)
          changes.iterChangedRanges((from, to2) => {
            if (from < composition.to && to2 > composition.from)
              touched = true;
          });
        return touched;
      }
      function groupAt(state$1, pos, bias = 1) {
        let categorize = state$1.charCategorizer(pos);
        let line = state$1.doc.lineAt(pos), linePos = pos - line.from;
        if (line.length == 0)
          return state.EditorSelection.cursor(pos);
        if (linePos == 0)
          bias = 1;
        else if (linePos == line.length)
          bias = -1;
        let from = linePos, to2 = linePos;
        if (bias < 0)
          from = state.findClusterBreak(line.text, linePos, false);
        else
          to2 = state.findClusterBreak(line.text, linePos);
        let cat = categorize(line.text.slice(from, to2));
        while (from > 0) {
          let prev = state.findClusterBreak(line.text, from, false);
          if (categorize(line.text.slice(prev, from)) != cat)
            break;
          from = prev;
        }
        while (to2 < line.length) {
          let next = state.findClusterBreak(line.text, to2);
          if (categorize(line.text.slice(to2, next)) != cat)
            break;
          to2 = next;
        }
        return state.EditorSelection.range(from + line.from, to2 + line.from);
      }
      function getdx(x, rect) {
        return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
      }
      function getdy(y2, rect) {
        return rect.top > y2 ? rect.top - y2 : Math.max(0, y2 - rect.bottom);
      }
      function yOverlap(a, b) {
        return a.top < b.bottom - 1 && a.bottom > b.top + 1;
      }
      function upTop(rect, top) {
        return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
      }
      function upBot(rect, bottom) {
        return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
      }
      function domPosAtCoords(parent, x, y2) {
        let closest, closestRect, closestX, closestY, closestOverlap = false;
        let above, below, aboveRect, belowRect;
        for (let child = parent.firstChild; child; child = child.nextSibling) {
          let rects = clientRectsFor(child);
          for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            if (closestRect && yOverlap(closestRect, rect))
              rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
            let dx = getdx(x, rect), dy = getdy(y2, rect);
            if (dx == 0 && dy == 0)
              return child.nodeType == 3 ? domPosInText(child, x, y2) : domPosAtCoords(child, x, y2);
            if (!closest || closestY > dy || closestY == dy && closestX > dx) {
              closest = child;
              closestRect = rect;
              closestX = dx;
              closestY = dy;
              let side = dy ? y2 < rect.top ? -1 : 1 : dx ? x < rect.left ? -1 : 1 : 0;
              closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);
            }
            if (dx == 0) {
              if (y2 > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
                above = child;
                aboveRect = rect;
              } else if (y2 < rect.top && (!belowRect || belowRect.top > rect.top)) {
                below = child;
                belowRect = rect;
              }
            } else if (aboveRect && yOverlap(aboveRect, rect)) {
              aboveRect = upBot(aboveRect, rect.bottom);
            } else if (belowRect && yOverlap(belowRect, rect)) {
              belowRect = upTop(belowRect, rect.top);
            }
          }
        }
        if (aboveRect && aboveRect.bottom >= y2) {
          closest = above;
          closestRect = aboveRect;
        } else if (belowRect && belowRect.top <= y2) {
          closest = below;
          closestRect = belowRect;
        }
        if (!closest)
          return { node: parent, offset: 0 };
        let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
        if (closest.nodeType == 3)
          return domPosInText(closest, clipX, y2);
        if (closestOverlap && closest.contentEditable != "false")
          return domPosAtCoords(closest, clipX, y2);
        let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
        return { node: parent, offset };
      }
      function domPosInText(node, x, y2) {
        let len = node.nodeValue.length;
        let closestOffset = -1, closestDY = 1e9, generalSide = 0;
        for (let i = 0; i < len; i++) {
          let rects = textRange(node, i, i + 1).getClientRects();
          for (let j2 = 0; j2 < rects.length; j2++) {
            let rect = rects[j2];
            if (rect.top == rect.bottom)
              continue;
            if (!generalSide)
              generalSide = x - rect.left;
            let dy = (rect.top > y2 ? rect.top - y2 : y2 - rect.bottom) - 1;
            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
              let right = x >= (rect.left + rect.right) / 2, after = right;
              if (browser.chrome || browser.gecko) {
                let rectBefore = textRange(node, i).getBoundingClientRect();
                if (rectBefore.left == rect.right)
                  after = !right;
              }
              if (dy <= 0)
                return { node, offset: i + (after ? 1 : 0) };
              closestOffset = i + (after ? 1 : 0);
              closestDY = dy;
            }
          }
        }
        return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
      }
      function posAtCoords(view, coords, precise, bias = -1) {
        var _a2, _b;
        let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;
        let block, { docHeight } = view.viewState;
        let { x, y: y2 } = coords, yOffset = y2 - docTop;
        if (yOffset < 0)
          return 0;
        if (yOffset > docHeight)
          return view.state.doc.length;
        for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
          block = view.elementAtHeight(yOffset);
          if (block.type == exports.BlockType.Text)
            break;
          for (; ; ) {
            yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
            if (yOffset >= 0 && yOffset <= docHeight)
              break;
            if (bounced)
              return precise ? null : 0;
            bounced = true;
            bias = -bias;
          }
        }
        y2 = docTop + yOffset;
        let lineStart = block.from;
        if (lineStart < view.viewport.from)
          return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y2);
        if (lineStart > view.viewport.to)
          return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content, block, x, y2);
        let doc2 = view.dom.ownerDocument;
        let root = view.root.elementFromPoint ? view.root : doc2;
        let element = root.elementFromPoint(x, y2);
        if (element && !view.contentDOM.contains(element))
          element = null;
        if (!element) {
          x = Math.max(content.left + 1, Math.min(content.right - 1, x));
          element = root.elementFromPoint(x, y2);
          if (element && !view.contentDOM.contains(element))
            element = null;
        }
        let node, offset = -1;
        if (element && ((_a2 = view.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
          if (doc2.caretPositionFromPoint) {
            let pos = doc2.caretPositionFromPoint(x, y2);
            if (pos)
              ({ offsetNode: node, offset } = pos);
          } else if (doc2.caretRangeFromPoint) {
            let range = doc2.caretRangeFromPoint(x, y2);
            if (range) {
              ({ startContainer: node, startOffset: offset } = range);
              if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
                node = void 0;
            }
          }
        }
        if (!node || !view.docView.dom.contains(node)) {
          let line = LineView.find(view.docView, lineStart);
          if (!line)
            return yOffset > block.top + block.height / 2 ? block.to : block.from;
          ({ node, offset } = domPosAtCoords(line.dom, x, y2));
        }
        let nearest = view.docView.nearest(node);
        if (!nearest)
          return null;
        if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
          let rect = nearest.dom.getBoundingClientRect();
          return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
        } else {
          return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
        }
      }
      function posAtCoordsImprecise(view, contentRect, block, x, y2) {
        let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
        if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
          let textHeight = view.viewState.heightOracle.textHeight;
          let line = Math.floor((y2 - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
          into += line * view.viewState.heightOracle.lineLength;
        }
        let content = view.state.sliceDoc(block.from, block.to);
        return block.from + state.findColumn(content, into, view.state.tabSize);
      }
      function isSuspiciousSafariCaretResult(node, offset, x) {
        let len;
        if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
          return false;
        for (let next = node.nextSibling; next; next = next.nextSibling)
          if (next.nodeType != 1 || next.nodeName != "BR")
            return false;
        return textRange(node, len - 1, len).getBoundingClientRect().left > x;
      }
      function isSuspiciousChromeCaretResult(node, offset, x) {
        if (offset != 0)
          return false;
        for (let cur = node; ; ) {
          let parent = cur.parentNode;
          if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
            return false;
          if (parent.classList.contains("cm-line"))
            break;
          cur = parent;
        }
        let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
        return x - rect.left > 5;
      }
      function blockAt(view, pos) {
        let line = view.lineBlockAt(pos);
        if (Array.isArray(line.type))
          for (let l of line.type) {
            if (l.to > pos || l.to == pos && (l.to == line.to || l.type == exports.BlockType.Text))
              return l;
          }
        return line;
      }
      function moveToLineBoundary(view, start, forward, includeWrap) {
        let line = blockAt(view, start.head);
        let coords = !includeWrap || line.type != exports.BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
        if (coords) {
          let editorRect = view.dom.getBoundingClientRect();
          let direction = view.textDirectionAt(line.from);
          let pos = view.posAtCoords({
            x: forward == (direction == exports.Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
            y: (coords.top + coords.bottom) / 2
          });
          if (pos != null)
            return state.EditorSelection.cursor(pos, forward ? -1 : 1);
        }
        return state.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
      }
      function moveByChar(view, start, forward, by) {
        let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
        let direction = view.textDirectionAt(line.from);
        for (let cur = start, check = null; ; ) {
          let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;
          if (!next) {
            if (line.number == (forward ? view.state.doc.lines : 1))
              return cur;
            char = "\n";
            line = view.state.doc.line(line.number + (forward ? 1 : -1));
            spans = view.bidiSpans(line);
            next = state.EditorSelection.cursor(forward ? line.from : line.to);
          }
          if (!check) {
            if (!by)
              return next;
            check = by(char);
          } else if (!check(char)) {
            return cur;
          }
          cur = next;
        }
      }
      function byGroup(view, pos, start) {
        let categorize = view.state.charCategorizer(pos);
        let cat = categorize(start);
        return (next) => {
          let nextCat = categorize(next);
          if (cat == state.CharCategory.Space)
            cat = nextCat;
          return cat == nextCat;
        };
      }
      function moveVertically(view, start, forward, distance) {
        let startPos = start.head, dir = forward ? 1 : -1;
        if (startPos == (forward ? view.state.doc.length : 0))
          return state.EditorSelection.cursor(startPos, start.assoc);
        let goal = start.goalColumn, startY;
        let rect = view.contentDOM.getBoundingClientRect();
        let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
        if (startCoords) {
          if (goal == null)
            goal = startCoords.left - rect.left;
          startY = dir < 0 ? startCoords.top : startCoords.bottom;
        } else {
          let line = view.viewState.lineBlockAt(startPos);
          if (goal == null)
            goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
          startY = (dir < 0 ? line.top : line.bottom) + docTop;
        }
        let resolvedGoal = rect.left + goal;
        let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
        for (let extra = 0; ; extra += 10) {
          let curY = startY + (dist2 + extra) * dir;
          let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
          if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
            let charRect = view.docView.coordsForChar(pos);
            let assoc = !charRect || curY < charRect.top ? -1 : 1;
            return state.EditorSelection.cursor(pos, assoc, void 0, goal);
          }
        }
      }
      function skipAtomicRanges(atoms, pos, bias) {
        for (; ; ) {
          let moved = 0;
          for (let set of atoms) {
            set.between(pos - 1, pos + 1, (from, to2, value) => {
              if (pos > from && pos < to2) {
                let side = moved || bias || (pos - from < to2 - pos ? -1 : 1);
                pos = side < 0 ? from : to2;
                moved = side;
              }
            });
          }
          if (!moved)
            return pos;
        }
      }
      function skipAtoms(view, oldPos, pos) {
        let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f) => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
        return newPos == pos.from ? pos : state.EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
      }
      var InputState = class {
        setSelectionOrigin(origin) {
          this.lastSelectionOrigin = origin;
          this.lastSelectionTime = Date.now();
        }
        constructor(view) {
          this.view = view;
          this.lastKeyCode = 0;
          this.lastKeyTime = 0;
          this.lastTouchTime = 0;
          this.lastFocusTime = 0;
          this.lastScrollTop = 0;
          this.lastScrollLeft = 0;
          this.pendingIOSKey = void 0;
          this.lastSelectionOrigin = null;
          this.lastSelectionTime = 0;
          this.lastEscPress = 0;
          this.lastContextMenu = 0;
          this.scrollHandlers = [];
          this.handlers = Object.create(null);
          this.composing = -1;
          this.compositionFirstChange = null;
          this.compositionEndedAt = 0;
          this.compositionPendingKey = false;
          this.compositionPendingChange = false;
          this.mouseSelection = null;
          this.draggedContent = null;
          this.handleEvent = this.handleEvent.bind(this);
          this.notifiedFocused = view.hasFocus;
          if (browser.safari)
            view.contentDOM.addEventListener("input", () => null);
          if (browser.gecko)
            firefoxCopyCutHack(view.contentDOM.ownerDocument);
        }
        handleEvent(event2) {
          if (!eventBelongsToEditor(this.view, event2) || this.ignoreDuringComposition(event2))
            return;
          if (event2.type == "keydown" && this.keydown(event2))
            return;
          this.runHandlers(event2.type, event2);
        }
        runHandlers(type, event2) {
          let handlers2 = this.handlers[type];
          if (handlers2) {
            for (let observer of handlers2.observers)
              observer(this.view, event2);
            for (let handler of handlers2.handlers) {
              if (event2.defaultPrevented)
                break;
              if (handler(this.view, event2)) {
                event2.preventDefault();
                break;
              }
            }
          }
        }
        ensureHandlers(plugins) {
          let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
          for (let type in handlers2)
            if (type != "scroll") {
              let passive = !handlers2[type].handlers.length;
              let exists = prev[type];
              if (exists && passive != !exists.handlers.length) {
                dom.removeEventListener(type, this.handleEvent);
                exists = null;
              }
              if (!exists)
                dom.addEventListener(type, this.handleEvent, { passive });
            }
          for (let type in prev)
            if (type != "scroll" && !handlers2[type])
              dom.removeEventListener(type, this.handleEvent);
          this.handlers = handlers2;
        }
        keydown(event2) {
          this.lastKeyCode = event2.keyCode;
          this.lastKeyTime = Date.now();
          if (event2.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
            return true;
          if (event2.keyCode != 27 && modifierCodes.indexOf(event2.keyCode) < 0)
            this.view.inputState.lastEscPress = 0;
          if (browser.android && browser.chrome && !event2.synthetic && (event2.keyCode == 13 || event2.keyCode == 8)) {
            this.view.observer.delayAndroidKey(event2.key, event2.keyCode);
            return true;
          }
          let pending;
          if (browser.ios && !event2.synthetic && !event2.altKey && !event2.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event2.keyCode)) && !event2.ctrlKey || EmacsyPendingKeys.indexOf(event2.key) > -1 && event2.ctrlKey && !event2.shiftKey)) {
            this.pendingIOSKey = pending || event2;
            setTimeout(() => this.flushIOSKey(), 250);
            return true;
          }
          if (event2.keyCode != 229)
            this.view.observer.forceFlush();
          return false;
        }
        flushIOSKey() {
          let key = this.pendingIOSKey;
          if (!key)
            return false;
          this.pendingIOSKey = void 0;
          return dispatchKey(this.view.contentDOM, key.key, key.keyCode);
        }
        ignoreDuringComposition(event2) {
          if (!/^key/.test(event2.type))
            return false;
          if (this.composing > 0)
            return true;
          if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
            this.compositionPendingKey = false;
            return true;
          }
          return false;
        }
        startMouseSelection(mouseSelection) {
          if (this.mouseSelection)
            this.mouseSelection.destroy();
          this.mouseSelection = mouseSelection;
        }
        update(update) {
          if (this.mouseSelection)
            this.mouseSelection.update(update);
          if (this.draggedContent && update.docChanged)
            this.draggedContent = this.draggedContent.map(update.changes);
          if (update.transactions.length)
            this.lastKeyCode = this.lastSelectionTime = 0;
        }
        destroy() {
          if (this.mouseSelection)
            this.mouseSelection.destroy();
        }
      };
      function bindHandler(plugin2, handler) {
        return (view, event2) => {
          try {
            return handler.call(plugin2, event2, view);
          } catch (e) {
            logException(view.state, e);
          }
        };
      }
      function computeHandlers(plugins) {
        let result = Object.create(null);
        function record(type) {
          return result[type] || (result[type] = { observers: [], handlers: [] });
        }
        for (let plugin2 of plugins) {
          let spec = plugin2.spec;
          if (spec && spec.domEventHandlers)
            for (let type in spec.domEventHandlers) {
              let f = spec.domEventHandlers[type];
              if (f)
                record(type).handlers.push(bindHandler(plugin2.value, f));
            }
          if (spec && spec.domEventObservers)
            for (let type in spec.domEventObservers) {
              let f = spec.domEventObservers[type];
              if (f)
                record(type).observers.push(bindHandler(plugin2.value, f));
            }
        }
        for (let type in handlers)
          record(type).handlers.push(handlers[type]);
        for (let type in observers)
          record(type).observers.push(observers[type]);
        return result;
      }
      var PendingKeys = [
        { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
        { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
        { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
        { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
      ];
      var EmacsyPendingKeys = "dthko";
      var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
      var dragScrollMargin = 6;
      function dragScrollSpeed(dist2) {
        return Math.max(0, dist2) * 0.7 + 8;
      }
      function dist(a, b) {
        return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
      }
      var MouseSelection = class {
        constructor(view, startEvent, style, mustSelect) {
          this.view = view;
          this.startEvent = startEvent;
          this.style = style;
          this.mustSelect = mustSelect;
          this.scrollSpeed = { x: 0, y: 0 };
          this.scrolling = -1;
          this.lastEvent = startEvent;
          this.scrollParent = scrollableParent(view.contentDOM);
          this.atoms = view.state.facet(atomicRanges).map((f) => f(view));
          let doc2 = view.contentDOM.ownerDocument;
          doc2.addEventListener("mousemove", this.move = this.move.bind(this));
          doc2.addEventListener("mouseup", this.up = this.up.bind(this));
          this.extend = startEvent.shiftKey;
          this.multiple = view.state.facet(state.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
          this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
        }
        start(event2) {
          if (this.dragging === false)
            this.select(event2);
        }
        move(event2) {
          var _a2;
          if (event2.buttons == 0)
            return this.destroy();
          if (this.dragging || this.dragging == null && dist(this.startEvent, event2) < 10)
            return;
          this.select(this.lastEvent = event2);
          let sx = 0, sy = 0;
          let rect = ((_a2 = this.scrollParent) === null || _a2 === void 0 ? void 0 : _a2.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight };
          let margins = getScrollMargins(this.view);
          if (event2.clientX - margins.left <= rect.left + dragScrollMargin)
            sx = -dragScrollSpeed(rect.left - event2.clientX);
          else if (event2.clientX + margins.right >= rect.right - dragScrollMargin)
            sx = dragScrollSpeed(event2.clientX - rect.right);
          if (event2.clientY - margins.top <= rect.top + dragScrollMargin)
            sy = -dragScrollSpeed(rect.top - event2.clientY);
          else if (event2.clientY + margins.bottom >= rect.bottom - dragScrollMargin)
            sy = dragScrollSpeed(event2.clientY - rect.bottom);
          this.setScrollSpeed(sx, sy);
        }
        up(event2) {
          if (this.dragging == null)
            this.select(this.lastEvent);
          if (!this.dragging)
            event2.preventDefault();
          this.destroy();
        }
        destroy() {
          this.setScrollSpeed(0, 0);
          let doc2 = this.view.contentDOM.ownerDocument;
          doc2.removeEventListener("mousemove", this.move);
          doc2.removeEventListener("mouseup", this.up);
          this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
        }
        setScrollSpeed(sx, sy) {
          this.scrollSpeed = { x: sx, y: sy };
          if (sx || sy) {
            if (this.scrolling < 0)
              this.scrolling = setInterval(() => this.scroll(), 50);
          } else if (this.scrolling > -1) {
            clearInterval(this.scrolling);
            this.scrolling = -1;
          }
        }
        scroll() {
          if (this.scrollParent) {
            this.scrollParent.scrollLeft += this.scrollSpeed.x;
            this.scrollParent.scrollTop += this.scrollSpeed.y;
          } else {
            this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);
          }
          if (this.dragging === false)
            this.select(this.lastEvent);
        }
        skipAtoms(sel) {
          let ranges = null;
          for (let i = 0; i < sel.ranges.length; i++) {
            let range = sel.ranges[i], updated = null;
            if (range.empty) {
              let pos = skipAtomicRanges(this.atoms, range.from, 0);
              if (pos != range.from)
                updated = state.EditorSelection.cursor(pos, -1);
            } else {
              let from = skipAtomicRanges(this.atoms, range.from, -1);
              let to2 = skipAtomicRanges(this.atoms, range.to, 1);
              if (from != range.from || to2 != range.to)
                updated = state.EditorSelection.range(range.from == range.anchor ? from : to2, range.from == range.head ? from : to2);
            }
            if (updated) {
              if (!ranges)
                ranges = sel.ranges.slice();
              ranges[i] = updated;
            }
          }
          return ranges ? state.EditorSelection.create(ranges, sel.mainIndex) : sel;
        }
        select(event2) {
          let { view } = this, selection = this.skipAtoms(this.style.get(event2, this.extend, this.multiple));
          if (this.mustSelect || !selection.eq(view.state.selection) || selection.main.assoc != view.state.selection.main.assoc && this.dragging === false)
            this.view.dispatch({
              selection,
              userEvent: "select.pointer"
            });
          this.mustSelect = false;
        }
        update(update) {
          if (this.style.update(update))
            setTimeout(() => this.select(this.lastEvent), 20);
        }
      };
      function addsSelectionRange(view, event2) {
        let facet = view.state.facet(clickAddsSelectionRange);
        return facet.length ? facet[0](event2) : browser.mac ? event2.metaKey : event2.ctrlKey;
      }
      function dragMovesSelection(view, event2) {
        let facet = view.state.facet(dragMovesSelection$1);
        return facet.length ? facet[0](event2) : browser.mac ? !event2.altKey : !event2.ctrlKey;
      }
      function isInPrimarySelection(view, event2) {
        let { main } = view.state.selection;
        if (main.empty)
          return false;
        let sel = getSelection(view.root);
        if (!sel || sel.rangeCount == 0)
          return true;
        let rects = sel.getRangeAt(0).getClientRects();
        for (let i = 0; i < rects.length; i++) {
          let rect = rects[i];
          if (rect.left <= event2.clientX && rect.right >= event2.clientX && rect.top <= event2.clientY && rect.bottom >= event2.clientY)
            return true;
        }
        return false;
      }
      function eventBelongsToEditor(view, event2) {
        if (!event2.bubbles)
          return true;
        if (event2.defaultPrevented)
          return false;
        for (let node = event2.target, cView; node != view.contentDOM; node = node.parentNode)
          if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event2))
            return false;
        return true;
      }
      var handlers = Object.create(null);
      var observers = Object.create(null);
      var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
      function capturePaste(view) {
        let parent = view.dom.parentNode;
        if (!parent)
          return;
        let target = parent.appendChild(document.createElement("textarea"));
        target.style.cssText = "position: fixed; left: -10000px; top: 10px";
        target.focus();
        setTimeout(() => {
          view.focus();
          target.remove();
          doPaste(view, target.value);
        }, 50);
      }
      function doPaste(view, input) {
        let { state: state$1 } = view, changes, i = 1, text = state$1.toText(input);
        let byLine = text.lines == state$1.selection.ranges.length;
        let linewise = lastLinewiseCopy != null && state$1.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text.toString();
        if (linewise) {
          let lastLine = -1;
          changes = state$1.changeByRange((range) => {
            let line = state$1.doc.lineAt(range.from);
            if (line.from == lastLine)
              return { range };
            lastLine = line.from;
            let insert = state$1.toText((byLine ? text.line(i++).text : input) + state$1.lineBreak);
            return {
              changes: { from: line.from, insert },
              range: state.EditorSelection.cursor(range.from + insert.length)
            };
          });
        } else if (byLine) {
          changes = state$1.changeByRange((range) => {
            let line = text.line(i++);
            return {
              changes: { from: range.from, to: range.to, insert: line.text },
              range: state.EditorSelection.cursor(range.from + line.length)
            };
          });
        } else {
          changes = state$1.replaceSelection(text);
        }
        view.dispatch(changes, {
          userEvent: "input.paste",
          scrollIntoView: true
        });
      }
      observers.scroll = (view) => {
        view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
        view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
      };
      handlers.keydown = (view, event2) => {
        view.inputState.setSelectionOrigin("select");
        if (event2.keyCode == 27)
          view.inputState.lastEscPress = Date.now();
        return false;
      };
      observers.touchstart = (view, e) => {
        view.inputState.lastTouchTime = Date.now();
        view.inputState.setSelectionOrigin("select.pointer");
      };
      observers.touchmove = (view) => {
        view.inputState.setSelectionOrigin("select.pointer");
      };
      handlers.mousedown = (view, event2) => {
        view.observer.flush();
        if (view.inputState.lastTouchTime > Date.now() - 2e3)
          return false;
        let style = null;
        for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
          style = makeStyle(view, event2);
          if (style)
            break;
        }
        if (!style && event2.button == 0)
          style = basicMouseSelection(view, event2);
        if (style) {
          let mustFocus = !view.hasFocus;
          view.inputState.startMouseSelection(new MouseSelection(view, event2, style, mustFocus));
          if (mustFocus)
            view.observer.ignore(() => focusPreventScroll(view.contentDOM));
          let mouseSel = view.inputState.mouseSelection;
          if (mouseSel) {
            mouseSel.start(event2);
            return mouseSel.dragging === false;
          }
        }
        return false;
      };
      function rangeForClick(view, pos, bias, type) {
        if (type == 1) {
          return state.EditorSelection.cursor(pos, bias);
        } else if (type == 2) {
          return groupAt(view.state, pos, bias);
        } else {
          let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
          let from = visual ? visual.posAtStart : line.from, to2 = visual ? visual.posAtEnd : line.to;
          if (to2 < view.state.doc.length && to2 == line.to)
            to2++;
          return state.EditorSelection.range(from, to2);
        }
      }
      var insideY = (y2, rect) => y2 >= rect.top && y2 <= rect.bottom;
      var inside = (x, y2, rect) => insideY(y2, rect) && x >= rect.left && x <= rect.right;
      function findPositionSide(view, pos, x, y2) {
        let line = LineView.find(view.docView, pos);
        if (!line)
          return 1;
        let off = pos - line.posAtStart;
        if (off == 0)
          return 1;
        if (off == line.length)
          return -1;
        let before = line.coordsAt(off, -1);
        if (before && inside(x, y2, before))
          return -1;
        let after = line.coordsAt(off, 1);
        if (after && inside(x, y2, after))
          return 1;
        return before && insideY(y2, before) ? -1 : 1;
      }
      function queryPos(view, event2) {
        let pos = view.posAtCoords({ x: event2.clientX, y: event2.clientY }, false);
        return { pos, bias: findPositionSide(view, pos, event2.clientX, event2.clientY) };
      }
      var BadMouseDetail = browser.ie && browser.ie_version <= 11;
      var lastMouseDown = null;
      var lastMouseDownCount = 0;
      var lastMouseDownTime = 0;
      function getClickType(event2) {
        if (!BadMouseDetail)
          return event2.detail;
        let last = lastMouseDown, lastTime = lastMouseDownTime;
        lastMouseDown = event2;
        lastMouseDownTime = Date.now();
        return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event2.clientX) < 2 && Math.abs(last.clientY - event2.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
      }
      function basicMouseSelection(view, event2) {
        let start = queryPos(view, event2), type = getClickType(event2);
        let startSel = view.state.selection;
        return {
          update(update) {
            if (update.docChanged) {
              start.pos = update.changes.mapPos(start.pos);
              startSel = startSel.map(update.changes);
            }
          },
          get(event3, extend, multiple) {
            let cur = queryPos(view, event3), removed;
            let range = rangeForClick(view, cur.pos, cur.bias, type);
            if (start.pos != cur.pos && !extend) {
              let startRange = rangeForClick(view, start.pos, start.bias, type);
              let from = Math.min(startRange.from, range.from), to2 = Math.max(startRange.to, range.to);
              range = from < range.from ? state.EditorSelection.range(from, to2) : state.EditorSelection.range(to2, from);
            }
            if (extend)
              return startSel.replaceRange(startSel.main.extend(range.from, range.to));
            else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos)))
              return removed;
            else if (multiple)
              return startSel.addRange(range);
            else
              return state.EditorSelection.create([range]);
          }
        };
      }
      function removeRangeAround(sel, pos) {
        for (let i = 0; i < sel.ranges.length; i++) {
          let { from, to: to2 } = sel.ranges[i];
          if (from <= pos && to2 >= pos)
            return state.EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
        }
        return null;
      }
      handlers.dragstart = (view, event2) => {
        let { selection: { main: range } } = view.state;
        if (event2.target.draggable) {
          let cView = view.docView.nearest(event2.target);
          if (cView && cView.isWidget) {
            let from = cView.posAtStart, to2 = from + cView.length;
            if (from >= range.to || to2 <= range.from)
              range = state.EditorSelection.range(from, to2);
          }
        }
        let { inputState } = view;
        if (inputState.mouseSelection)
          inputState.mouseSelection.dragging = true;
        inputState.draggedContent = range;
        if (event2.dataTransfer) {
          event2.dataTransfer.setData("Text", view.state.sliceDoc(range.from, range.to));
          event2.dataTransfer.effectAllowed = "copyMove";
        }
        return false;
      };
      handlers.dragend = (view) => {
        view.inputState.draggedContent = null;
        return false;
      };
      function dropText(view, event2, text, direct) {
        if (!text)
          return;
        let dropPos = view.posAtCoords({ x: event2.clientX, y: event2.clientY }, false);
        let { draggedContent } = view.inputState;
        let del = direct && draggedContent && dragMovesSelection(view, event2) ? { from: draggedContent.from, to: draggedContent.to } : null;
        let ins = { from: dropPos, insert: text };
        let changes = view.state.changes(del ? [del, ins] : ins);
        view.focus();
        view.dispatch({
          changes,
          selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
          userEvent: del ? "move.drop" : "input.drop"
        });
        view.inputState.draggedContent = null;
      }
      handlers.drop = (view, event2) => {
        if (!event2.dataTransfer)
          return false;
        if (view.state.readOnly)
          return true;
        let files = event2.dataTransfer.files;
        if (files && files.length) {
          let text = Array(files.length), read = 0;
          let finishFile = () => {
            if (++read == files.length)
              dropText(view, event2, text.filter((s) => s != null).join(view.state.lineBreak), false);
          };
          for (let i = 0; i < files.length; i++) {
            let reader = new FileReader();
            reader.onerror = finishFile;
            reader.onload = () => {
              if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
                text[i] = reader.result;
              finishFile();
            };
            reader.readAsText(files[i]);
          }
          return true;
        } else {
          let text = event2.dataTransfer.getData("Text");
          if (text) {
            dropText(view, event2, text, true);
            return true;
          }
        }
        return false;
      };
      handlers.paste = (view, event2) => {
        if (view.state.readOnly)
          return true;
        view.observer.flush();
        let data = brokenClipboardAPI ? null : event2.clipboardData;
        if (data) {
          doPaste(view, data.getData("text/plain") || data.getData("text/uri-text"));
          return true;
        } else {
          capturePaste(view);
          return false;
        }
      };
      function captureCopy(view, text) {
        let parent = view.dom.parentNode;
        if (!parent)
          return;
        let target = parent.appendChild(document.createElement("textarea"));
        target.style.cssText = "position: fixed; left: -10000px; top: 10px";
        target.value = text;
        target.focus();
        target.selectionEnd = text.length;
        target.selectionStart = 0;
        setTimeout(() => {
          target.remove();
          view.focus();
        }, 50);
      }
      function copiedRange(state2) {
        let content = [], ranges = [], linewise = false;
        for (let range of state2.selection.ranges)
          if (!range.empty) {
            content.push(state2.sliceDoc(range.from, range.to));
            ranges.push(range);
          }
        if (!content.length) {
          let upto = -1;
          for (let { from } of state2.selection.ranges) {
            let line = state2.doc.lineAt(from);
            if (line.number > upto) {
              content.push(line.text);
              ranges.push({ from: line.from, to: Math.min(state2.doc.length, line.to + 1) });
            }
            upto = line.number;
          }
          linewise = true;
        }
        return { text: content.join(state2.lineBreak), ranges, linewise };
      }
      var lastLinewiseCopy = null;
      handlers.copy = handlers.cut = (view, event2) => {
        let { text, ranges, linewise } = copiedRange(view.state);
        if (!text && !linewise)
          return false;
        lastLinewiseCopy = linewise ? text : null;
        if (event2.type == "cut" && !view.state.readOnly)
          view.dispatch({
            changes: ranges,
            scrollIntoView: true,
            userEvent: "delete.cut"
          });
        let data = brokenClipboardAPI ? null : event2.clipboardData;
        if (data) {
          data.clearData();
          data.setData("text/plain", text);
          return true;
        } else {
          captureCopy(view, text);
          return false;
        }
      };
      var isFocusChange = state.Annotation.define();
      function focusChangeTransaction(state2, focus) {
        let effects = [];
        for (let getEffect of state2.facet(focusChangeEffect)) {
          let effect = getEffect(state2, focus);
          if (effect)
            effects.push(effect);
        }
        return effects ? state2.update({ effects, annotations: isFocusChange.of(true) }) : null;
      }
      function updateForFocusChange(view) {
        setTimeout(() => {
          let focus = view.hasFocus;
          if (focus != view.inputState.notifiedFocused) {
            let tr2 = focusChangeTransaction(view.state, focus);
            if (tr2)
              view.dispatch(tr2);
            else
              view.update([]);
          }
        }, 10);
      }
      observers.focus = (view) => {
        view.inputState.lastFocusTime = Date.now();
        if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
          view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
          view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
        }
        updateForFocusChange(view);
      };
      observers.blur = (view) => {
        view.observer.clearSelectionRange();
        updateForFocusChange(view);
      };
      observers.compositionstart = observers.compositionupdate = (view) => {
        if (view.inputState.compositionFirstChange == null)
          view.inputState.compositionFirstChange = true;
        if (view.inputState.composing < 0) {
          view.inputState.composing = 0;
        }
      };
      observers.compositionend = (view) => {
        view.inputState.composing = -1;
        view.inputState.compositionEndedAt = Date.now();
        view.inputState.compositionPendingKey = true;
        view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
        view.inputState.compositionFirstChange = null;
        if (browser.chrome && browser.android) {
          view.observer.flushSoon();
        } else if (view.inputState.compositionPendingChange) {
          Promise.resolve().then(() => view.observer.flush());
        } else {
          setTimeout(() => {
            if (view.inputState.composing < 0 && view.docView.hasComposition)
              view.update([]);
          }, 50);
        }
      };
      observers.contextmenu = (view) => {
        view.inputState.lastContextMenu = Date.now();
      };
      handlers.beforeinput = (view, event2) => {
        var _a2;
        let pending;
        if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event2.inputType))) {
          view.observer.delayAndroidKey(pending.key, pending.keyCode);
          if (pending.key == "Backspace" || pending.key == "Delete") {
            let startViewHeight = ((_a2 = window.visualViewport) === null || _a2 === void 0 ? void 0 : _a2.height) || 0;
            setTimeout(() => {
              var _a3;
              if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
                view.contentDOM.blur();
                view.focus();
              }
            }, 100);
          }
        }
        return false;
      };
      var appliedFirefoxHack = new Set();
      function firefoxCopyCutHack(doc2) {
        if (!appliedFirefoxHack.has(doc2)) {
          appliedFirefoxHack.add(doc2);
          doc2.addEventListener("copy", () => {
          });
          doc2.addEventListener("cut", () => {
          });
        }
      }
      var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
      var HeightOracle = class {
        constructor(lineWrapping) {
          this.lineWrapping = lineWrapping;
          this.doc = state.Text.empty;
          this.heightSamples = {};
          this.lineHeight = 14;
          this.charWidth = 7;
          this.textHeight = 14;
          this.lineLength = 30;
          this.heightChanged = false;
        }
        heightForGap(from, to2) {
          let lines = this.doc.lineAt(to2).number - this.doc.lineAt(from).number + 1;
          if (this.lineWrapping)
            lines += Math.max(0, Math.ceil((to2 - from - lines * this.lineLength * 0.5) / this.lineLength));
          return this.lineHeight * lines;
        }
        heightForLine(length) {
          if (!this.lineWrapping)
            return this.lineHeight;
          let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
          return lines * this.lineHeight;
        }
        setDoc(doc2) {
          this.doc = doc2;
          return this;
        }
        mustRefreshForWrapping(whiteSpace) {
          return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
        }
        mustRefreshForHeights(lineHeights) {
          let newHeight = false;
          for (let i = 0; i < lineHeights.length; i++) {
            let h2 = lineHeights[i];
            if (h2 < 0) {
              i++;
            } else if (!this.heightSamples[Math.floor(h2 * 10)]) {
              newHeight = true;
              this.heightSamples[Math.floor(h2 * 10)] = true;
            }
          }
          return newHeight;
        }
        refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
          let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
          let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
          this.lineWrapping = lineWrapping;
          this.lineHeight = lineHeight;
          this.charWidth = charWidth;
          this.textHeight = textHeight;
          this.lineLength = lineLength;
          if (changed) {
            this.heightSamples = {};
            for (let i = 0; i < knownHeights.length; i++) {
              let h2 = knownHeights[i];
              if (h2 < 0)
                i++;
              else
                this.heightSamples[Math.floor(h2 * 10)] = true;
            }
          }
          return changed;
        }
      };
      var MeasuredHeights = class {
        constructor(from, heights) {
          this.from = from;
          this.heights = heights;
          this.index = 0;
        }
        get more() {
          return this.index < this.heights.length;
        }
      };
      var BlockInfo = class {
        constructor(from, length, top, height, _content) {
          this.from = from;
          this.length = length;
          this.top = top;
          this.height = height;
          this._content = _content;
        }
        get type() {
          return typeof this._content == "number" ? exports.BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
        }
        get to() {
          return this.from + this.length;
        }
        get bottom() {
          return this.top + this.height;
        }
        get widget() {
          return this._content instanceof PointDecoration ? this._content.widget : null;
        }
        get widgetLineBreaks() {
          return typeof this._content == "number" ? this._content : 0;
        }
        join(other) {
          let content = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
          return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);
        }
      };
      var QueryType;
      (function(QueryType2) {
        QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
        QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
        QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
      })(QueryType || (QueryType = {}));
      var Epsilon = 1e-3;
      var HeightMap = class {
        constructor(length, height, flags = 2) {
          this.length = length;
          this.height = height;
          this.flags = flags;
        }
        get outdated() {
          return (this.flags & 2) > 0;
        }
        set outdated(value) {
          this.flags = (value ? 2 : 0) | this.flags & ~2;
        }
        setHeight(oracle, height) {
          if (this.height != height) {
            if (Math.abs(this.height - height) > Epsilon)
              oracle.heightChanged = true;
            this.height = height;
          }
        }
        replace(_from, _to, nodes) {
          return HeightMap.of(nodes);
        }
        decomposeLeft(_to, result) {
          result.push(this);
        }
        decomposeRight(_from, result) {
          result.push(this);
        }
        applyChanges(decorations2, oldDoc, oracle, changes) {
          let me2 = this, doc2 = oracle.doc;
          for (let i = changes.length - 1; i >= 0; i--) {
            let { fromA, toA, fromB, toB } = changes[i];
            let start = me2.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
            let end = start.to >= toA ? start : me2.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
            toB += end.to - toA;
            toA = end.to;
            while (i > 0 && start.from <= changes[i - 1].toA) {
              fromA = changes[i - 1].fromA;
              fromB = changes[i - 1].fromB;
              i--;
              if (fromA < start.from)
                start = me2.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
            }
            fromB += start.from - fromA;
            fromA = start.from;
            let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
            me2 = me2.replace(fromA, toA, nodes);
          }
          return me2.updateHeight(oracle, 0);
        }
        static empty() {
          return new HeightMapText(0, 0);
        }
        static of(nodes) {
          if (nodes.length == 1)
            return nodes[0];
          let i = 0, j2 = nodes.length, before = 0, after = 0;
          for (; ; ) {
            if (i == j2) {
              if (before > after * 2) {
                let split = nodes[i - 1];
                if (split.break)
                  nodes.splice(--i, 1, split.left, null, split.right);
                else
                  nodes.splice(--i, 1, split.left, split.right);
                j2 += 1 + split.break;
                before -= split.size;
              } else if (after > before * 2) {
                let split = nodes[j2];
                if (split.break)
                  nodes.splice(j2, 1, split.left, null, split.right);
                else
                  nodes.splice(j2, 1, split.left, split.right);
                j2 += 2 + split.break;
                after -= split.size;
              } else {
                break;
              }
            } else if (before < after) {
              let next = nodes[i++];
              if (next)
                before += next.size;
            } else {
              let next = nodes[--j2];
              if (next)
                after += next.size;
            }
          }
          let brk = 0;
          if (nodes[i - 1] == null) {
            brk = 1;
            i--;
          } else if (nodes[i] == null) {
            brk = 1;
            j2++;
          }
          return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j2)));
        }
      };
      HeightMap.prototype.size = 1;
      var HeightMapBlock = class extends HeightMap {
        constructor(length, height, deco) {
          super(length, height);
          this.deco = deco;
        }
        blockAt(_height, _oracle, top, offset) {
          return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);
        }
        lineAt(_value, _type, oracle, top, offset) {
          return this.blockAt(0, oracle, top, offset);
        }
        forEachLine(from, to2, oracle, top, offset, f) {
          if (from <= offset + this.length && to2 >= offset)
            f(this.blockAt(0, oracle, top, offset));
        }
        updateHeight(oracle, offset = 0, _force = false, measured) {
          if (measured && measured.from <= offset && measured.more)
            this.setHeight(oracle, measured.heights[measured.index++]);
          this.outdated = false;
          return this;
        }
        toString() {
          return `block(${this.length})`;
        }
      };
      var HeightMapText = class extends HeightMapBlock {
        constructor(length, height) {
          super(length, height, null);
          this.collapsed = 0;
          this.widgetHeight = 0;
          this.breaks = 0;
        }
        blockAt(_height, _oracle, top, offset) {
          return new BlockInfo(offset, this.length, top, this.height, this.breaks);
        }
        replace(_from, _to, nodes) {
          let node = nodes[0];
          if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
            if (node instanceof HeightMapGap)
              node = new HeightMapText(node.length, this.height);
            else
              node.height = this.height;
            if (!this.outdated)
              node.outdated = false;
            return node;
          } else {
            return HeightMap.of(nodes);
          }
        }
        updateHeight(oracle, offset = 0, force = false, measured) {
          if (measured && measured.from <= offset && measured.more)
            this.setHeight(oracle, measured.heights[measured.index++]);
          else if (force || this.outdated)
            this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
          this.outdated = false;
          return this;
        }
        toString() {
          return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
        }
      };
      var HeightMapGap = class extends HeightMap {
        constructor(length) {
          super(length, 0);
        }
        heightMetrics(oracle, offset) {
          let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
          let lines = lastLine - firstLine + 1;
          let perLine, perChar = 0;
          if (oracle.lineWrapping) {
            let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
            perLine = totalPerLine / lines;
            if (this.length > lines + 1)
              perChar = (this.height - totalPerLine) / (this.length - lines - 1);
          } else {
            perLine = this.height / lines;
          }
          return { firstLine, lastLine, perLine, perChar };
        }
        blockAt(height, oracle, top, offset) {
          let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
          if (oracle.lineWrapping) {
            let guess = offset + Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length);
            let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
            let lineTop = Math.max(top, height - lineHeight / 2);
            return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
          } else {
            let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));
            let { from, length } = oracle.doc.line(firstLine + line);
            return new BlockInfo(from, length, top + perLine * line, perLine, 0);
          }
        }
        lineAt(value, type, oracle, top, offset) {
          if (type == QueryType.ByHeight)
            return this.blockAt(value, oracle, top, offset);
          if (type == QueryType.ByPosNoHeight) {
            let { from, to: to2 } = oracle.doc.lineAt(value);
            return new BlockInfo(from, to2 - from, 0, 0, 0);
          }
          let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
          let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
          let linesAbove = line.number - firstLine;
          let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
          return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);
        }
        forEachLine(from, to2, oracle, top, offset, f) {
          from = Math.max(from, offset);
          to2 = Math.min(to2, offset + this.length);
          let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
          for (let pos = from, lineTop = top; pos <= to2; ) {
            let line = oracle.doc.lineAt(pos);
            if (pos == from) {
              let linesAbove = line.number - firstLine;
              lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
            }
            let lineHeight = perLine + perChar * line.length;
            f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
            lineTop += lineHeight;
            pos = line.to + 1;
          }
        }
        replace(from, to2, nodes) {
          let after = this.length - to2;
          if (after > 0) {
            let last = nodes[nodes.length - 1];
            if (last instanceof HeightMapGap)
              nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
            else
              nodes.push(null, new HeightMapGap(after - 1));
          }
          if (from > 0) {
            let first = nodes[0];
            if (first instanceof HeightMapGap)
              nodes[0] = new HeightMapGap(from + first.length);
            else
              nodes.unshift(new HeightMapGap(from - 1), null);
          }
          return HeightMap.of(nodes);
        }
        decomposeLeft(to2, result) {
          result.push(new HeightMapGap(to2 - 1), null);
        }
        decomposeRight(from, result) {
          result.push(null, new HeightMapGap(this.length - from - 1));
        }
        updateHeight(oracle, offset = 0, force = false, measured) {
          let end = offset + this.length;
          if (measured && measured.from <= offset + this.length && measured.more) {
            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
            if (measured.from > offset)
              nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
            while (pos <= end && measured.more) {
              let len = oracle.doc.lineAt(pos).length;
              if (nodes.length)
                nodes.push(null);
              let height = measured.heights[measured.index++];
              if (singleHeight == -1)
                singleHeight = height;
              else if (Math.abs(height - singleHeight) >= Epsilon)
                singleHeight = -2;
              let line = new HeightMapText(len, height);
              line.outdated = false;
              nodes.push(line);
              pos += len + 1;
            }
            if (pos <= end)
              nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
            let result = HeightMap.of(nodes);
            if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
              oracle.heightChanged = true;
            return result;
          } else if (force || this.outdated) {
            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
            this.outdated = false;
          }
          return this;
        }
        toString() {
          return `gap(${this.length})`;
        }
      };
      var HeightMapBranch = class extends HeightMap {
        constructor(left, brk, right) {
          super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
          this.left = left;
          this.right = right;
          this.size = left.size + right.size;
        }
        get break() {
          return this.flags & 1;
        }
        blockAt(height, oracle, top, offset) {
          let mid = top + this.left.height;
          return height < mid ? this.left.blockAt(height, oracle, top, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
        }
        lineAt(value, type, oracle, top, offset) {
          let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
          let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
          let base = left ? this.left.lineAt(value, type, oracle, top, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
          if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))
            return base;
          let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
          if (left)
            return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
          else
            return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);
        }
        forEachLine(from, to2, oracle, top, offset, f) {
          let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
          if (this.break) {
            if (from < rightOffset)
              this.left.forEachLine(from, to2, oracle, top, offset, f);
            if (to2 >= rightOffset)
              this.right.forEachLine(from, to2, oracle, rightTop, rightOffset, f);
          } else {
            let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);
            if (from < mid.from)
              this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);
            if (mid.to >= from && mid.from <= to2)
              f(mid);
            if (to2 > mid.to)
              this.right.forEachLine(mid.to + 1, to2, oracle, rightTop, rightOffset, f);
          }
        }
        replace(from, to2, nodes) {
          let rightStart = this.left.length + this.break;
          if (to2 < rightStart)
            return this.balanced(this.left.replace(from, to2, nodes), this.right);
          if (from > this.left.length)
            return this.balanced(this.left, this.right.replace(from - rightStart, to2 - rightStart, nodes));
          let result = [];
          if (from > 0)
            this.decomposeLeft(from, result);
          let left = result.length;
          for (let node of nodes)
            result.push(node);
          if (from > 0)
            mergeGaps(result, left - 1);
          if (to2 < this.length) {
            let right = result.length;
            this.decomposeRight(to2, result);
            mergeGaps(result, right);
          }
          return HeightMap.of(result);
        }
        decomposeLeft(to2, result) {
          let left = this.left.length;
          if (to2 <= left)
            return this.left.decomposeLeft(to2, result);
          result.push(this.left);
          if (this.break) {
            left++;
            if (to2 >= left)
              result.push(null);
          }
          if (to2 > left)
            this.right.decomposeLeft(to2 - left, result);
        }
        decomposeRight(from, result) {
          let left = this.left.length, right = left + this.break;
          if (from >= right)
            return this.right.decomposeRight(from - right, result);
          if (from < left)
            this.left.decomposeRight(from, result);
          if (this.break && from < right)
            result.push(null);
          result.push(this.right);
        }
        balanced(left, right) {
          if (left.size > 2 * right.size || right.size > 2 * left.size)
            return HeightMap.of(this.break ? [left, null, right] : [left, right]);
          this.left = left;
          this.right = right;
          this.height = left.height + right.height;
          this.outdated = left.outdated || right.outdated;
          this.size = left.size + right.size;
          this.length = left.length + this.break + right.length;
          return this;
        }
        updateHeight(oracle, offset = 0, force = false, measured) {
          let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
          if (measured && measured.from <= offset + left.length && measured.more)
            rebalance = left = left.updateHeight(oracle, offset, force, measured);
          else
            left.updateHeight(oracle, offset, force);
          if (measured && measured.from <= rightStart + right.length && measured.more)
            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
          else
            right.updateHeight(oracle, rightStart, force);
          if (rebalance)
            return this.balanced(left, right);
          this.height = this.left.height + this.right.height;
          this.outdated = false;
          return this;
        }
        toString() {
          return this.left + (this.break ? " " : "-") + this.right;
        }
      };
      function mergeGaps(nodes, around) {
        let before, after;
        if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
          nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
      }
      var relevantWidgetHeight = 5;
      var NodeBuilder = class {
        constructor(pos, oracle) {
          this.pos = pos;
          this.oracle = oracle;
          this.nodes = [];
          this.lineStart = -1;
          this.lineEnd = -1;
          this.covering = null;
          this.writtenTo = pos;
        }
        get isCovered() {
          return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
        }
        span(_from, to2) {
          if (this.lineStart > -1) {
            let end = Math.min(to2, this.lineEnd), last = this.nodes[this.nodes.length - 1];
            if (last instanceof HeightMapText)
              last.length += end - this.pos;
            else if (end > this.pos || !this.isCovered)
              this.nodes.push(new HeightMapText(end - this.pos, -1));
            this.writtenTo = end;
            if (to2 > end) {
              this.nodes.push(null);
              this.writtenTo++;
              this.lineStart = -1;
            }
          }
          this.pos = to2;
        }
        point(from, to2, deco) {
          if (from < to2 || deco.heightRelevant) {
            let height = deco.widget ? deco.widget.estimatedHeight : 0;
            let breaks = deco.widget ? deco.widget.lineBreaks : 0;
            if (height < 0)
              height = this.oracle.lineHeight;
            let len = to2 - from;
            if (deco.block) {
              this.addBlock(new HeightMapBlock(len, height, deco));
            } else if (len || breaks || height >= relevantWidgetHeight) {
              this.addLineDeco(height, breaks, len);
            }
          } else if (to2 > from) {
            this.span(from, to2);
          }
          if (this.lineEnd > -1 && this.lineEnd < this.pos)
            this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
        }
        enterLine() {
          if (this.lineStart > -1)
            return;
          let { from, to: to2 } = this.oracle.doc.lineAt(this.pos);
          this.lineStart = from;
          this.lineEnd = to2;
          if (this.writtenTo < from) {
            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
              this.nodes.push(this.blankContent(this.writtenTo, from - 1));
            this.nodes.push(null);
          }
          if (this.pos > from)
            this.nodes.push(new HeightMapText(this.pos - from, -1));
          this.writtenTo = this.pos;
        }
        blankContent(from, to2) {
          let gap = new HeightMapGap(to2 - from);
          if (this.oracle.doc.lineAt(from).to == to2)
            gap.flags |= 4;
          return gap;
        }
        ensureLine() {
          this.enterLine();
          let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
          if (last instanceof HeightMapText)
            return last;
          let line = new HeightMapText(0, -1);
          this.nodes.push(line);
          return line;
        }
        addBlock(block) {
          this.enterLine();
          let deco = block.deco;
          if (deco && deco.startSide > 0 && !this.isCovered)
            this.ensureLine();
          this.nodes.push(block);
          this.writtenTo = this.pos = this.pos + block.length;
          if (deco && deco.endSide > 0)
            this.covering = block;
        }
        addLineDeco(height, breaks, length) {
          let line = this.ensureLine();
          line.length += length;
          line.collapsed += length;
          line.widgetHeight = Math.max(line.widgetHeight, height);
          line.breaks += breaks;
          this.writtenTo = this.pos = this.pos + length;
        }
        finish(from) {
          let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
          if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
            this.nodes.push(new HeightMapText(0, -1));
          else if (this.writtenTo < this.pos || last == null)
            this.nodes.push(this.blankContent(this.writtenTo, this.pos));
          let pos = from;
          for (let node of this.nodes) {
            if (node instanceof HeightMapText)
              node.updateHeight(this.oracle, pos);
            pos += node ? node.length : 1;
          }
          return this.nodes;
        }
        static build(oracle, decorations2, from, to2) {
          let builder = new NodeBuilder(from, oracle);
          state.RangeSet.spans(decorations2, from, to2, builder, 0);
          return builder.finish(from);
        }
      };
      function heightRelevantDecoChanges(a, b, diff) {
        let comp = new DecorationComparator();
        state.RangeSet.compare(a, b, diff, comp, 0);
        return comp.changes;
      }
      var DecorationComparator = class {
        constructor() {
          this.changes = [];
        }
        compareRange() {
        }
        comparePoint(from, to2, a, b) {
          if (from < to2 || a && a.heightRelevant || b && b.heightRelevant)
            addRange(from, to2, this.changes, 5);
        }
      };
      function visiblePixelRange(dom, paddingTop) {
        let rect = dom.getBoundingClientRect();
        let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
        let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
        let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
        for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
          if (parent.nodeType == 1) {
            let elt = parent;
            let style = window.getComputedStyle(elt);
            if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
              let parentRect = elt.getBoundingClientRect();
              left = Math.max(left, parentRect.left);
              right = Math.min(right, parentRect.right);
              top = Math.max(top, parentRect.top);
              bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);
            }
            parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
          } else if (parent.nodeType == 11) {
            parent = parent.host;
          } else {
            break;
          }
        }
        return {
          left: left - rect.left,
          right: Math.max(left, right) - rect.left,
          top: top - (rect.top + paddingTop),
          bottom: Math.max(top, bottom) - (rect.top + paddingTop)
        };
      }
      function fullPixelRange(dom, paddingTop) {
        let rect = dom.getBoundingClientRect();
        return {
          left: 0,
          right: rect.right - rect.left,
          top: paddingTop,
          bottom: rect.bottom - (rect.top + paddingTop)
        };
      }
      var LineGap = class {
        constructor(from, to2, size) {
          this.from = from;
          this.to = to2;
          this.size = size;
        }
        static same(a, b) {
          if (a.length != b.length)
            return false;
          for (let i = 0; i < a.length; i++) {
            let gA = a[i], gB = b[i];
            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
              return false;
          }
          return true;
        }
        draw(viewState, wrapping) {
          return Decoration.replace({
            widget: new LineGapWidget(this.size * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
          }).range(this.from, this.to);
        }
      };
      var LineGapWidget = class extends WidgetType {
        constructor(size, vertical) {
          super();
          this.size = size;
          this.vertical = vertical;
        }
        eq(other) {
          return other.size == this.size && other.vertical == this.vertical;
        }
        toDOM() {
          let elt = document.createElement("div");
          if (this.vertical) {
            elt.style.height = this.size + "px";
          } else {
            elt.style.width = this.size + "px";
            elt.style.height = "2px";
            elt.style.display = "inline-block";
          }
          return elt;
        }
        get estimatedHeight() {
          return this.vertical ? this.size : -1;
        }
      };
      var ViewState = class {
        constructor(state$1) {
          this.state = state$1;
          this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
          this.inView = true;
          this.paddingTop = 0;
          this.paddingBottom = 0;
          this.contentDOMWidth = 0;
          this.contentDOMHeight = 0;
          this.editorHeight = 0;
          this.editorWidth = 0;
          this.scrollTop = 0;
          this.scrolledToBottom = true;
          this.scaleX = 1;
          this.scaleY = 1;
          this.scrollAnchorPos = 0;
          this.scrollAnchorHeight = -1;
          this.scaler = IdScaler;
          this.scrollTarget = null;
          this.printing = false;
          this.mustMeasureContent = true;
          this.defaultTextDirection = exports.Direction.LTR;
          this.visibleRanges = [];
          this.mustEnforceCursorAssoc = false;
          let guessWrapping = state$1.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
          this.heightOracle = new HeightOracle(guessWrapping);
          this.stateDeco = state$1.facet(decorations).filter((d2) => typeof d2 != "function");
          this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, state.Text.empty, this.heightOracle.setDoc(state$1.doc), [new ChangedRange(0, 0, 0, state$1.doc.length)]);
          this.viewport = this.getViewport(0, null);
          this.updateViewportLines();
          this.updateForViewport();
          this.lineGaps = this.ensureLineGaps([]);
          this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
          this.computeVisibleRanges();
        }
        updateForViewport() {
          let viewports = [this.viewport], { main } = this.state.selection;
          for (let i = 0; i <= 1; i++) {
            let pos = i ? main.head : main.anchor;
            if (!viewports.some(({ from, to: to2 }) => pos >= from && pos <= to2)) {
              let { from, to: to2 } = this.lineBlockAt(pos);
              viewports.push(new Viewport(from, to2));
            }
          }
          this.viewports = viewports.sort((a, b) => a.from - b.from);
          this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
        }
        updateViewportLines() {
          this.viewportLines = [];
          this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
            this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
          });
        }
        update(update, scrollTarget = null) {
          this.state = update.state;
          let prevDeco = this.stateDeco;
          this.stateDeco = this.state.facet(decorations).filter((d2) => typeof d2 != "function");
          let contentChanges = update.changedRanges;
          let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : state.ChangeSet.empty(this.state.doc.length)));
          let prevHeight = this.heightMap.height;
          let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
          this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
          if (this.heightMap.height != prevHeight)
            update.flags |= 2;
          if (scrollAnchor) {
            this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
            this.scrollAnchorHeight = scrollAnchor.top;
          } else {
            this.scrollAnchorPos = -1;
            this.scrollAnchorHeight = this.heightMap.height;
          }
          let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
          if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
            viewport = this.getViewport(0, scrollTarget);
          let updateLines = !update.changes.empty || update.flags & 2 || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
          this.viewport = viewport;
          this.updateForViewport();
          if (updateLines)
            this.updateViewportLines();
          if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
            this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
          update.flags |= this.computeVisibleRanges();
          if (scrollTarget)
            this.scrollTarget = scrollTarget;
          if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
            this.mustEnforceCursorAssoc = true;
        }
        measure(view) {
          let dom = view.contentDOM, style = window.getComputedStyle(dom);
          let oracle = this.heightOracle;
          let whiteSpace = style.whiteSpace;
          this.defaultTextDirection = style.direction == "rtl" ? exports.Direction.RTL : exports.Direction.LTR;
          let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
          let domRect = dom.getBoundingClientRect();
          let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
          this.contentDOMHeight = domRect.height;
          this.mustMeasureContent = false;
          let result = 0, bias = 0;
          if (domRect.width && domRect.height) {
            let scaleX = domRect.width / dom.offsetWidth;
            let scaleY = domRect.height / dom.offsetHeight;
            if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(domRect.width - dom.offsetWidth) < 1)
              scaleX = 1;
            if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(domRect.height - dom.offsetHeight) < 1)
              scaleY = 1;
            if (this.scaleX != scaleX || this.scaleY != scaleY) {
              this.scaleX = scaleX;
              this.scaleY = scaleY;
              result |= 8;
              refresh = measureContent = true;
            }
          }
          let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
          let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
          if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
            this.paddingTop = paddingTop;
            this.paddingBottom = paddingBottom;
            result |= 8 | 2;
          }
          if (this.editorWidth != view.scrollDOM.clientWidth) {
            if (oracle.lineWrapping)
              measureContent = true;
            this.editorWidth = view.scrollDOM.clientWidth;
            result |= 8;
          }
          let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
          if (this.scrollTop != scrollTop) {
            this.scrollAnchorHeight = -1;
            this.scrollTop = scrollTop;
          }
          this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
          let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
          let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
          this.pixelViewport = pixelViewport;
          let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
          if (inView != this.inView) {
            this.inView = inView;
            if (inView)
              measureContent = true;
          }
          if (!this.inView && !this.scrollTarget)
            return 0;
          let contentWidth = domRect.width;
          if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
            this.contentDOMWidth = domRect.width;
            this.editorHeight = view.scrollDOM.clientHeight;
            result |= 8;
          }
          if (measureContent) {
            let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
            if (oracle.mustRefreshForHeights(lineHeights))
              refresh = true;
            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
              let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
              refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
              if (refresh) {
                view.docView.minWidth = 0;
                result |= 8;
              }
            }
            if (dTop > 0 && dBottom > 0)
              bias = Math.max(dTop, dBottom);
            else if (dTop < 0 && dBottom < 0)
              bias = Math.min(dTop, dBottom);
            oracle.heightChanged = false;
            for (let vp of this.viewports) {
              let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
              this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, state.Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
            }
            if (oracle.heightChanged)
              result |= 2;
          }
          let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
          if (viewportChange)
            this.viewport = this.getViewport(bias, this.scrollTarget);
          this.updateForViewport();
          if (result & 2 || viewportChange)
            this.updateViewportLines();
          if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
            this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
          result |= this.computeVisibleRanges();
          if (this.mustEnforceCursorAssoc) {
            this.mustEnforceCursorAssoc = false;
            view.docView.enforceCursorAssoc();
          }
          return result;
        }
        get visibleTop() {
          return this.scaler.fromDOM(this.pixelViewport.top);
        }
        get visibleBottom() {
          return this.scaler.fromDOM(this.pixelViewport.bottom);
        }
        getViewport(bias, scrollTarget) {
          let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
          let map = this.heightMap, oracle = this.heightOracle;
          let { visibleTop, visibleBottom } = this;
          let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
          if (scrollTarget) {
            let { head } = scrollTarget.range;
            if (head < viewport.from || head > viewport.to) {
              let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
              let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
              if (scrollTarget.y == "center")
                topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
              else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
                topPos = block.top;
              else
                topPos = block.bottom - viewHeight;
              viewport = new Viewport(map.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
            }
          }
          return viewport;
        }
        mapViewport(viewport, changes) {
          let from = changes.mapPos(viewport.from, -1), to2 = changes.mapPos(viewport.to, 1);
          return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to2, QueryType.ByPos, this.heightOracle, 0, 0).to);
        }
        viewportIsAppropriate({ from, to: to2 }, bias = 0) {
          if (!this.inView)
            return true;
          let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
          let { bottom } = this.heightMap.lineAt(to2, QueryType.ByPos, this.heightOracle, 0, 0);
          let { visibleTop, visibleBottom } = this;
          return (from == 0 || top <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to2 == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
        }
        mapLineGaps(gaps, changes) {
          if (!gaps.length || changes.empty)
            return gaps;
          let mapped = [];
          for (let gap of gaps)
            if (!changes.touchesRange(gap.from, gap.to))
              mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
          return mapped;
        }
        ensureLineGaps(current, mayMeasure) {
          let wrapping = this.heightOracle.lineWrapping;
          let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
          if (this.defaultTextDirection != exports.Direction.LTR && !wrapping)
            return [];
          let gaps = [];
          let addGap = (from, to2, line, structure) => {
            if (to2 - from < halfMargin)
              return;
            let sel = this.state.selection.main, avoid = [sel.from];
            if (!sel.empty)
              avoid.push(sel.to);
            for (let pos of avoid) {
              if (pos > from && pos < to2) {
                addGap(from, pos - 10, line, structure);
                addGap(pos + 10, to2, line, structure);
                return;
              }
            }
            let gap = find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to2) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
            if (!gap) {
              if (to2 < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to2 && r.to >= to2)) {
                let lineStart = mayMeasure.moveToLineBoundary(state.EditorSelection.cursor(to2), false, true).head;
                if (lineStart > from)
                  to2 = lineStart;
              }
              gap = new LineGap(from, to2, this.gapSize(line, from, to2, structure));
            }
            gaps.push(gap);
          };
          for (let line of this.viewportLines) {
            if (line.length < doubleMargin)
              continue;
            let structure = lineStructure(line.from, line.to, this.stateDeco);
            if (structure.total < doubleMargin)
              continue;
            let target = this.scrollTarget ? this.scrollTarget.range.head : null;
            let viewFrom, viewTo;
            if (wrapping) {
              let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
              let top, bot;
              if (target != null) {
                let targetFrac = findFraction(structure, target);
                let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
                top = targetFrac - spaceFrac;
                bot = targetFrac + spaceFrac;
              } else {
                top = (this.visibleTop - line.top - marginHeight) / line.height;
                bot = (this.visibleBottom - line.top + marginHeight) / line.height;
              }
              viewFrom = findPosition(structure, top);
              viewTo = findPosition(structure, bot);
            } else {
              let totalWidth = structure.total * this.heightOracle.charWidth;
              let marginWidth = margin * this.heightOracle.charWidth;
              let left, right;
              if (target != null) {
                let targetFrac = findFraction(structure, target);
                let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
                left = targetFrac - spaceFrac;
                right = targetFrac + spaceFrac;
              } else {
                left = (this.pixelViewport.left - marginWidth) / totalWidth;
                right = (this.pixelViewport.right + marginWidth) / totalWidth;
              }
              viewFrom = findPosition(structure, left);
              viewTo = findPosition(structure, right);
            }
            if (viewFrom > line.from)
              addGap(line.from, viewFrom, line, structure);
            if (viewTo < line.to)
              addGap(viewTo, line.to, line, structure);
          }
          return gaps;
        }
        gapSize(line, from, to2, structure) {
          let fraction = findFraction(structure, to2) - findFraction(structure, from);
          if (this.heightOracle.lineWrapping) {
            return line.height * fraction;
          } else {
            return structure.total * this.heightOracle.charWidth * fraction;
          }
        }
        updateLineGaps(gaps) {
          if (!LineGap.same(gaps, this.lineGaps)) {
            this.lineGaps = gaps;
            this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
          }
        }
        computeVisibleRanges() {
          let deco = this.stateDeco;
          if (this.lineGaps.length)
            deco = deco.concat(this.lineGapDeco);
          let ranges = [];
          state.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
            span(from, to2) {
              ranges.push({ from, to: to2 });
            },
            point() {
            }
          }, 20);
          let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
          this.visibleRanges = ranges;
          return changed ? 4 : 0;
        }
        lineBlockAt(pos) {
          return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
        }
        lineBlockAtHeight(height) {
          return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
        }
        scrollAnchorAt(scrollTop) {
          let block = this.lineBlockAtHeight(scrollTop + 8);
          return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
        }
        elementAtHeight(height) {
          return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
        }
        get docHeight() {
          return this.scaler.toDOM(this.heightMap.height);
        }
        get contentHeight() {
          return this.docHeight + this.paddingTop + this.paddingBottom;
        }
      };
      var Viewport = class {
        constructor(from, to2) {
          this.from = from;
          this.to = to2;
        }
      };
      function lineStructure(from, to2, stateDeco) {
        let ranges = [], pos = from, total = 0;
        state.RangeSet.spans(stateDeco, from, to2, {
          span() {
          },
          point(from2, to3) {
            if (from2 > pos) {
              ranges.push({ from: pos, to: from2 });
              total += from2 - pos;
            }
            pos = to3;
          }
        }, 20);
        if (pos < to2) {
          ranges.push({ from: pos, to: to2 });
          total += to2 - pos;
        }
        return { total, ranges };
      }
      function findPosition({ total, ranges }, ratio) {
        if (ratio <= 0)
          return ranges[0].from;
        if (ratio >= 1)
          return ranges[ranges.length - 1].to;
        let dist2 = Math.floor(total * ratio);
        for (let i = 0; ; i++) {
          let { from, to: to2 } = ranges[i], size = to2 - from;
          if (dist2 <= size)
            return from + dist2;
          dist2 -= size;
        }
      }
      function findFraction(structure, pos) {
        let counted = 0;
        for (let { from, to: to2 } of structure.ranges) {
          if (pos <= to2) {
            counted += pos - from;
            break;
          }
          counted += to2 - from;
        }
        return counted / structure.total;
      }
      function find(array, f) {
        for (let val of array)
          if (f(val))
            return val;
        return void 0;
      }
      var IdScaler = {
        toDOM(n) {
          return n;
        },
        fromDOM(n) {
          return n;
        },
        scale: 1
      };
      var BigScaler = class {
        constructor(oracle, heightMap, viewports) {
          let vpHeight = 0, base = 0, domBase = 0;
          this.viewports = viewports.map(({ from, to: to2 }) => {
            let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
            let bottom = heightMap.lineAt(to2, QueryType.ByPos, oracle, 0, 0).bottom;
            vpHeight += bottom - top;
            return { from, to: to2, top, bottom, domTop: 0, domBottom: 0 };
          });
          this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
          for (let obj of this.viewports) {
            obj.domTop = domBase + (obj.top - base) * this.scale;
            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
            base = obj.bottom;
          }
        }
        toDOM(n) {
          for (let i = 0, base = 0, domBase = 0; ; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.top)
              return domBase + (n - base) * this.scale;
            if (n <= vp.bottom)
              return vp.domTop + (n - vp.top);
            base = vp.bottom;
            domBase = vp.domBottom;
          }
        }
        fromDOM(n) {
          for (let i = 0, base = 0, domBase = 0; ; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.domTop)
              return base + (n - domBase) / this.scale;
            if (n <= vp.domBottom)
              return vp.top + (n - vp.domTop);
            base = vp.bottom;
            domBase = vp.domBottom;
          }
        }
      };
      function scaleBlock(block, scaler) {
        if (scaler.scale == 1)
          return block;
        let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
        return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b) => scaleBlock(b, scaler)) : block._content);
      }
      var theme = state.Facet.define({ combine: (strs) => strs.join(" ") });
      var darkTheme = state.Facet.define({ combine: (values) => values.indexOf(true) > -1 });
      var baseThemeID = styleMod.StyleModule.newName();
      var baseLightID = styleMod.StyleModule.newName();
      var baseDarkID = styleMod.StyleModule.newName();
      var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
      function buildTheme(main, spec, scopes) {
        return new styleMod.StyleModule(spec, {
          finish(sel) {
            return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
              if (m == "&")
                return main;
              if (!scopes || !scopes[m])
                throw new RangeError(`Unsupported selector: ${m}`);
              return scopes[m];
            }) : main + " " + sel;
          }
        });
      }
      var baseTheme$1 = buildTheme("." + baseThemeID, {
        "&": {
          position: "relative !important",
          boxSizing: "border-box",
          "&.cm-focused": {
            outline: "1px dotted #212121"
          },
          display: "flex !important",
          flexDirection: "column"
        },
        ".cm-scroller": {
          display: "flex !important",
          alignItems: "flex-start !important",
          fontFamily: "monospace",
          lineHeight: 1.4,
          height: "100%",
          overflowX: "auto",
          position: "relative",
          zIndex: 0
        },
        ".cm-content": {
          margin: 0,
          flexGrow: 2,
          flexShrink: 0,
          display: "block",
          whiteSpace: "pre",
          wordWrap: "normal",
          boxSizing: "border-box",
          minHeight: "100%",
          padding: "4px 0",
          outline: "none",
          "&[contenteditable=true]": {
            WebkitUserModify: "read-write-plaintext-only"
          }
        },
        ".cm-lineWrapping": {
          whiteSpace_fallback: "pre-wrap",
          whiteSpace: "break-spaces",
          wordBreak: "break-word",
          overflowWrap: "anywhere",
          flexShrink: 1
        },
        "&light .cm-content": { caretColor: "black" },
        "&dark .cm-content": { caretColor: "white" },
        ".cm-line": {
          display: "block",
          padding: "0 2px 0 6px"
        },
        ".cm-layer": {
          position: "absolute",
          left: 0,
          top: 0,
          contain: "size style",
          "& > *": {
            position: "absolute"
          }
        },
        "&light .cm-selectionBackground": {
          background: "#d9d9d9"
        },
        "&dark .cm-selectionBackground": {
          background: "#222"
        },
        "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
          background: "#d7d4f0"
        },
        "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
          background: "#233"
        },
        ".cm-cursorLayer": {
          pointerEvents: "none"
        },
        "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
          animation: "steps(1) cm-blink 1.2s infinite"
        },
        "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
        "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
        ".cm-cursor, .cm-dropCursor": {
          borderLeft: "1.2px solid black",
          marginLeft: "-0.6px",
          pointerEvents: "none"
        },
        ".cm-cursor": {
          display: "none"
        },
        "&dark .cm-cursor": {
          borderLeftColor: "#444"
        },
        ".cm-dropCursor": {
          position: "absolute"
        },
        "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
          display: "block"
        },
        ".cm-announced": {
          position: "fixed",
          top: "-10000px"
        },
        "@media print": {
          ".cm-announced": { display: "none" }
        },
        "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
        "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
        "&light .cm-specialChar": { color: "red" },
        "&dark .cm-specialChar": { color: "#f78" },
        ".cm-gutters": {
          flexShrink: 0,
          display: "flex",
          height: "100%",
          boxSizing: "border-box",
          insetInlineStart: 0,
          zIndex: 200
        },
        "&light .cm-gutters": {
          backgroundColor: "#f5f5f5",
          color: "#6c6c6c",
          borderRight: "1px solid #ddd"
        },
        "&dark .cm-gutters": {
          backgroundColor: "#333338",
          color: "#ccc"
        },
        ".cm-gutter": {
          display: "flex !important",
          flexDirection: "column",
          flexShrink: 0,
          boxSizing: "border-box",
          minHeight: "100%",
          overflow: "hidden"
        },
        ".cm-gutterElement": {
          boxSizing: "border-box"
        },
        ".cm-lineNumbers .cm-gutterElement": {
          padding: "0 3px 0 5px",
          minWidth: "20px",
          textAlign: "right",
          whiteSpace: "nowrap"
        },
        "&light .cm-activeLineGutter": {
          backgroundColor: "#e2f2ff"
        },
        "&dark .cm-activeLineGutter": {
          backgroundColor: "#222227"
        },
        ".cm-panels": {
          boxSizing: "border-box",
          position: "sticky",
          left: 0,
          right: 0
        },
        "&light .cm-panels": {
          backgroundColor: "#f5f5f5",
          color: "black"
        },
        "&light .cm-panels-top": {
          borderBottom: "1px solid #ddd"
        },
        "&light .cm-panels-bottom": {
          borderTop: "1px solid #ddd"
        },
        "&dark .cm-panels": {
          backgroundColor: "#333338",
          color: "white"
        },
        ".cm-tab": {
          display: "inline-block",
          overflow: "hidden",
          verticalAlign: "bottom"
        },
        ".cm-widgetBuffer": {
          verticalAlign: "text-top",
          height: "1em",
          width: 0,
          display: "inline"
        },
        ".cm-placeholder": {
          color: "#888",
          display: "inline-block",
          verticalAlign: "top"
        },
        ".cm-highlightSpace:before": {
          content: "attr(data-display)",
          position: "absolute",
          pointerEvents: "none",
          color: "#888"
        },
        ".cm-highlightTab": {
          backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
          backgroundSize: "auto 100%",
          backgroundPosition: "right 90%",
          backgroundRepeat: "no-repeat"
        },
        ".cm-trailingSpace": {
          backgroundColor: "#ff332255"
        },
        ".cm-button": {
          verticalAlign: "middle",
          color: "inherit",
          fontSize: "70%",
          padding: ".2em 1em",
          borderRadius: "1px"
        },
        "&light .cm-button": {
          backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
          border: "1px solid #888",
          "&:active": {
            backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
          }
        },
        "&dark .cm-button": {
          backgroundImage: "linear-gradient(#393939, #111)",
          border: "1px solid #888",
          "&:active": {
            backgroundImage: "linear-gradient(#111, #333)"
          }
        },
        ".cm-textfield": {
          verticalAlign: "middle",
          color: "inherit",
          fontSize: "70%",
          border: "1px solid silver",
          padding: ".2em .5em"
        },
        "&light .cm-textfield": {
          backgroundColor: "white"
        },
        "&dark .cm-textfield": {
          border: "1px solid #555",
          backgroundColor: "inherit"
        }
      }, lightDarkIDs);
      var LineBreakPlaceholder = "\uFFFF";
      var DOMReader = class {
        constructor(points, state$1) {
          this.points = points;
          this.text = "";
          this.lineSeparator = state$1.facet(state.EditorState.lineSeparator);
        }
        append(text) {
          this.text += text;
        }
        lineBreak() {
          this.text += LineBreakPlaceholder;
        }
        readRange(start, end) {
          if (!start)
            return this;
          let parent = start.parentNode;
          for (let cur = start; ; ) {
            this.findPointBefore(parent, cur);
            let oldLen = this.text.length;
            this.readNode(cur);
            let next = cur.nextSibling;
            if (next == end)
              break;
            let view = ContentView.get(cur), nextView = ContentView.get(next);
            if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore) && this.text.length > oldLen)
              this.lineBreak();
            cur = next;
          }
          this.findPointBefore(parent, end);
          return this;
        }
        readTextNode(node) {
          let text = node.nodeValue;
          for (let point of this.points)
            if (point.node == node)
              point.pos = this.text.length + Math.min(point.offset, text.length);
          for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
            let nextBreak = -1, breakSize = 1, m;
            if (this.lineSeparator) {
              nextBreak = text.indexOf(this.lineSeparator, off);
              breakSize = this.lineSeparator.length;
            } else if (m = re.exec(text)) {
              nextBreak = m.index;
              breakSize = m[0].length;
            }
            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
            if (nextBreak < 0)
              break;
            this.lineBreak();
            if (breakSize > 1) {
              for (let point of this.points)
                if (point.node == node && point.pos > this.text.length)
                  point.pos -= breakSize - 1;
            }
            off = nextBreak + breakSize;
          }
        }
        readNode(node) {
          if (node.cmIgnore)
            return;
          let view = ContentView.get(node);
          let fromView = view && view.overrideDOMText;
          if (fromView != null) {
            this.findPointInside(node, fromView.length);
            for (let i = fromView.iter(); !i.next().done; ) {
              if (i.lineBreak)
                this.lineBreak();
              else
                this.append(i.value);
            }
          } else if (node.nodeType == 3) {
            this.readTextNode(node);
          } else if (node.nodeName == "BR") {
            if (node.nextSibling)
              this.lineBreak();
          } else if (node.nodeType == 1) {
            this.readRange(node.firstChild, null);
          }
        }
        findPointBefore(node, next) {
          for (let point of this.points)
            if (point.node == node && node.childNodes[point.offset] == next)
              point.pos = this.text.length;
        }
        findPointInside(node, length) {
          for (let point of this.points)
            if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
              point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
        }
      };
      function isAtEnd(parent, node, offset) {
        for (; ; ) {
          if (!node || offset < maxOffset(node))
            return false;
          if (node == parent)
            return true;
          offset = domIndex(node) + 1;
          node = node.parentNode;
        }
      }
      function isBlockElement(node) {
        return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
      }
      var DOMPoint = class {
        constructor(node, offset) {
          this.node = node;
          this.offset = offset;
          this.pos = -1;
        }
      };
      var DOMChange = class {
        constructor(view, start, end, typeOver) {
          this.typeOver = typeOver;
          this.bounds = null;
          this.text = "";
          let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
          if (view.state.readOnly && start > -1) {
            this.newSel = null;
          } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
            let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
            let reader = new DOMReader(selPoints, view.state);
            reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
            this.text = reader.text;
            this.newSel = selectionFromPoints(selPoints, this.bounds.from);
          } else {
            let domSel = view.observer.selectionRange;
            let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
            let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
            this.newSel = state.EditorSelection.single(anchor, head);
          }
        }
      };
      function applyDOMChange(view, domChange) {
        let change;
        let { newSel } = domChange, sel = view.state.selection.main;
        let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
        if (domChange.bounds) {
          let { from, to: to2 } = domChange.bounds;
          let preferredPos = sel.from, preferredSide = null;
          if (lastKey === 8 || browser.android && domChange.text.length < to2 - from) {
            preferredPos = sel.to;
            preferredSide = "end";
          }
          let diff = findDiff(view.state.doc.sliceString(from, to2, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
          if (diff) {
            if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
              diff.toB--;
            change = {
              from: from + diff.from,
              to: from + diff.toA,
              insert: state.Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
            };
          }
        } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
          newSel = null;
        }
        if (!change && !newSel)
          return false;
        if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
          change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
        } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
          change = {
            from: sel.from,
            to: sel.to,
            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
          };
        } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
          if (newSel && change.insert.length == 2)
            newSel = state.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
          change = { from: sel.from, to: sel.to, insert: state.Text.of([" "]) };
        } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
          if (newSel)
            newSel = state.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
          change = { from: sel.from, to: sel.to, insert: state.Text.of([" "]) };
        }
        if (change) {
          if (browser.ios && view.inputState.flushIOSKey())
            return true;
          if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
            return true;
          let text = change.insert.toString();
          if (view.inputState.composing >= 0)
            view.inputState.composing++;
          let defaultTr;
          let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
          if (!view.state.facet(inputHandler).some((h2) => h2(view, change.from, change.to, text, defaultInsert)))
            view.dispatch(defaultInsert());
          return true;
        } else if (newSel && !newSel.main.eq(sel)) {
          let scrollIntoView2 = false, userEvent = "select";
          if (view.inputState.lastSelectionTime > Date.now() - 50) {
            if (view.inputState.lastSelectionOrigin == "select")
              scrollIntoView2 = true;
            userEvent = view.inputState.lastSelectionOrigin;
          }
          view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView2, userEvent });
          return true;
        } else {
          return false;
        }
      }
      function applyDefaultInsert(view, change, newSel) {
        let tr2, startState = view.state, sel = startState.selection.main;
        if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
          let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
          let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
          tr2 = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
        } else {
          let changes = startState.changes(change);
          let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
          if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
            let replaced = view.state.sliceDoc(change.from, change.to);
            let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
            if (composition) {
              let dLen = change.insert.length - (change.to - change.from);
              compositionRange = { from: composition.from, to: composition.to - dLen };
            } else {
              compositionRange = view.state.doc.lineAt(sel.head);
            }
            let offset = sel.to - change.to, size = sel.to - sel.from;
            tr2 = startState.changeByRange((range) => {
              if (range.from == sel.from && range.to == sel.to)
                return { changes, range: mainSel || range.map(changes) };
              let to2 = range.to - offset, from = to2 - replaced.length;
              if (range.to - range.from != size || view.state.sliceDoc(from, to2) != replaced || range.to >= compositionRange.from && range.from <= compositionRange.to)
                return { range };
              let rangeChanges = startState.changes({ from, to: to2, insert: change.insert }), selOff = range.to - sel.to;
              return {
                changes: rangeChanges,
                range: !mainSel ? range.map(rangeChanges) : state.EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
              };
            });
          } else {
            tr2 = {
              changes,
              selection: mainSel && startState.selection.replaceRange(mainSel)
            };
          }
        }
        let userEvent = "input.type";
        if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
          view.inputState.compositionPendingChange = false;
          userEvent += ".compose";
          if (view.inputState.compositionFirstChange) {
            userEvent += ".start";
            view.inputState.compositionFirstChange = false;
          }
        }
        return startState.update(tr2, { userEvent, scrollIntoView: true });
      }
      function findDiff(a, b, preferredPos, preferredSide) {
        let minLen = Math.min(a.length, b.length);
        let from = 0;
        while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
          from++;
        if (from == minLen && a.length == b.length)
          return null;
        let toA = a.length, toB = b.length;
        while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
          toA--;
          toB--;
        }
        if (preferredSide == "end") {
          let adjust = Math.max(0, from - Math.min(toA, toB));
          preferredPos -= toA + adjust - from;
        }
        if (toA < from && a.length < b.length) {
          let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
          from -= move;
          toB = from + (toB - toA);
          toA = from;
        } else if (toB < from) {
          let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
          from -= move;
          toA = from + (toA - toB);
          toB = from;
        }
        return { from, toA, toB };
      }
      function selectionPoints(view) {
        let result = [];
        if (view.root.activeElement != view.contentDOM)
          return result;
        let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
        if (anchorNode) {
          result.push(new DOMPoint(anchorNode, anchorOffset));
          if (focusNode != anchorNode || focusOffset != anchorOffset)
            result.push(new DOMPoint(focusNode, focusOffset));
        }
        return result;
      }
      function selectionFromPoints(points, base) {
        if (points.length == 0)
          return null;
        let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
        return anchor > -1 && head > -1 ? state.EditorSelection.single(anchor + base, head + base) : null;
      }
      var observeOptions = {
        childList: true,
        characterData: true,
        subtree: true,
        attributes: true,
        characterDataOldValue: true
      };
      var useCharData = browser.ie && browser.ie_version <= 11;
      var DOMObserver = class {
        constructor(view) {
          this.view = view;
          this.active = false;
          this.selectionRange = new DOMSelectionState();
          this.selectionChanged = false;
          this.delayedFlush = -1;
          this.resizeTimeout = -1;
          this.queue = [];
          this.delayedAndroidKey = null;
          this.flushingAndroidKey = -1;
          this.lastChange = 0;
          this.scrollTargets = [];
          this.intersection = null;
          this.resizeScroll = null;
          this.intersecting = false;
          this.gapIntersection = null;
          this.gaps = [];
          this.parentCheck = -1;
          this.dom = view.contentDOM;
          this.observer = new MutationObserver((mutations) => {
            for (let mut of mutations)
              this.queue.push(mut);
            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
              this.flushSoon();
            else
              this.flush();
          });
          if (useCharData)
            this.onCharData = (event2) => {
              this.queue.push({
                target: event2.target,
                type: "characterData",
                oldValue: event2.prevValue
              });
              this.flushSoon();
            };
          this.onSelectionChange = this.onSelectionChange.bind(this);
          this.onResize = this.onResize.bind(this);
          this.onPrint = this.onPrint.bind(this);
          this.onScroll = this.onScroll.bind(this);
          if (typeof ResizeObserver == "function") {
            this.resizeScroll = new ResizeObserver(() => {
              var _a2;
              if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
                this.onResize();
            });
            this.resizeScroll.observe(view.scrollDOM);
          }
          this.addWindowListeners(this.win = view.win);
          this.start();
          if (typeof IntersectionObserver == "function") {
            this.intersection = new IntersectionObserver((entries) => {
              if (this.parentCheck < 0)
                this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
              if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
                this.intersecting = !this.intersecting;
                if (this.intersecting != this.view.inView)
                  this.onScrollChanged(document.createEvent("Event"));
              }
            }, { threshold: [0, 1e-3] });
            this.intersection.observe(this.dom);
            this.gapIntersection = new IntersectionObserver((entries) => {
              if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
                this.onScrollChanged(document.createEvent("Event"));
            }, {});
          }
          this.listenForScroll();
          this.readSelectionRange();
        }
        onScrollChanged(e) {
          this.view.inputState.runHandlers("scroll", e);
          if (this.intersecting)
            this.view.measure();
        }
        onScroll(e) {
          if (this.intersecting)
            this.flush(false);
          this.onScrollChanged(e);
        }
        onResize() {
          if (this.resizeTimeout < 0)
            this.resizeTimeout = setTimeout(() => {
              this.resizeTimeout = -1;
              this.view.requestMeasure();
            }, 50);
        }
        onPrint() {
          this.view.viewState.printing = true;
          this.view.measure();
          setTimeout(() => {
            this.view.viewState.printing = false;
            this.view.requestMeasure();
          }, 500);
        }
        updateGaps(gaps) {
          if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
            this.gapIntersection.disconnect();
            for (let gap of gaps)
              this.gapIntersection.observe(gap);
            this.gaps = gaps;
          }
        }
        onSelectionChange(event2) {
          let wasChanged = this.selectionChanged;
          if (!this.readSelectionRange() || this.delayedAndroidKey)
            return;
          let { view } = this, sel = this.selectionRange;
          if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
            return;
          let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
          if (context && context.ignoreEvent(event2)) {
            if (!wasChanged)
              this.selectionChanged = false;
            return;
          }
          if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
            this.flushSoon();
          else
            this.flush(false);
        }
        readSelectionRange() {
          let { view } = this;
          let range = browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);
          if (!range || this.selectionRange.eq(range))
            return false;
          let local = hasSelection(this.dom, range);
          if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
            this.view.inputState.lastFocusTime = 0;
            view.docView.updateSelection();
            return false;
          }
          this.selectionRange.setRange(range);
          if (local)
            this.selectionChanged = true;
          return true;
        }
        setSelectionRange(anchor, head) {
          this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
          this.selectionChanged = false;
        }
        clearSelectionRange() {
          this.selectionRange.set(null, 0, null, 0);
        }
        listenForScroll() {
          this.parentCheck = -1;
          let i = 0, changed = null;
          for (let dom = this.dom; dom; ) {
            if (dom.nodeType == 1) {
              if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
                i++;
              else if (!changed)
                changed = this.scrollTargets.slice(0, i);
              if (changed)
                changed.push(dom);
              dom = dom.assignedSlot || dom.parentNode;
            } else if (dom.nodeType == 11) {
              dom = dom.host;
            } else {
              break;
            }
          }
          if (i < this.scrollTargets.length && !changed)
            changed = this.scrollTargets.slice(0, i);
          if (changed) {
            for (let dom of this.scrollTargets)
              dom.removeEventListener("scroll", this.onScroll);
            for (let dom of this.scrollTargets = changed)
              dom.addEventListener("scroll", this.onScroll);
          }
        }
        ignore(f) {
          if (!this.active)
            return f();
          try {
            this.stop();
            return f();
          } finally {
            this.start();
            this.clear();
          }
        }
        start() {
          if (this.active)
            return;
          this.observer.observe(this.dom, observeOptions);
          if (useCharData)
            this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
          this.active = true;
        }
        stop() {
          if (!this.active)
            return;
          this.active = false;
          this.observer.disconnect();
          if (useCharData)
            this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
        }
        clear() {
          this.processRecords();
          this.queue.length = 0;
          this.selectionChanged = false;
        }
        delayAndroidKey(key, keyCode) {
          var _a2;
          if (!this.delayedAndroidKey) {
            let flush = () => {
              let key2 = this.delayedAndroidKey;
              if (key2) {
                this.clearDelayedAndroidKey();
                this.view.inputState.lastKeyCode = key2.keyCode;
                this.view.inputState.lastKeyTime = Date.now();
                let flushed = this.flush();
                if (!flushed && key2.force)
                  dispatchKey(this.dom, key2.key, key2.keyCode);
              }
            };
            this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
          }
          if (!this.delayedAndroidKey || key == "Enter")
            this.delayedAndroidKey = {
              key,
              keyCode,
              force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
            };
        }
        clearDelayedAndroidKey() {
          this.win.cancelAnimationFrame(this.flushingAndroidKey);
          this.delayedAndroidKey = null;
          this.flushingAndroidKey = -1;
        }
        flushSoon() {
          if (this.delayedFlush < 0)
            this.delayedFlush = this.view.win.requestAnimationFrame(() => {
              this.delayedFlush = -1;
              this.flush();
            });
        }
        forceFlush() {
          if (this.delayedFlush >= 0) {
            this.view.win.cancelAnimationFrame(this.delayedFlush);
            this.delayedFlush = -1;
          }
          this.flush();
        }
        pendingRecords() {
          for (let mut of this.observer.takeRecords())
            this.queue.push(mut);
          return this.queue;
        }
        processRecords() {
          let records = this.pendingRecords();
          if (records.length)
            this.queue = [];
          let from = -1, to2 = -1, typeOver = false;
          for (let record of records) {
            let range = this.readMutation(record);
            if (!range)
              continue;
            if (range.typeOver)
              typeOver = true;
            if (from == -1) {
              ({ from, to: to2 } = range);
            } else {
              from = Math.min(range.from, from);
              to2 = Math.max(range.to, to2);
            }
          }
          return { from, to: to2, typeOver };
        }
        readChange() {
          let { from, to: to2, typeOver } = this.processRecords();
          let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
          if (from < 0 && !newSel)
            return null;
          if (from > -1)
            this.lastChange = Date.now();
          this.view.inputState.lastFocusTime = 0;
          this.selectionChanged = false;
          let change = new DOMChange(this.view, from, to2, typeOver);
          this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
          return change;
        }
        flush(readSelection = true) {
          if (this.delayedFlush >= 0 || this.delayedAndroidKey)
            return false;
          if (readSelection)
            this.readSelectionRange();
          let domChange = this.readChange();
          if (!domChange) {
            this.view.requestMeasure();
            return false;
          }
          let startState = this.view.state;
          let handled = applyDOMChange(this.view, domChange);
          if (this.view.state == startState)
            this.view.update([]);
          return handled;
        }
        readMutation(rec) {
          let cView = this.view.docView.nearest(rec.target);
          if (!cView || cView.ignoreMutation(rec))
            return null;
          cView.markDirty(rec.type == "attributes");
          if (rec.type == "attributes")
            cView.flags |= 4;
          if (rec.type == "childList") {
            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
            return {
              from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
              to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
              typeOver: false
            };
          } else if (rec.type == "characterData") {
            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
          } else {
            return null;
          }
        }
        setWindow(win) {
          if (win != this.win) {
            this.removeWindowListeners(this.win);
            this.win = win;
            this.addWindowListeners(this.win);
          }
        }
        addWindowListeners(win) {
          win.addEventListener("resize", this.onResize);
          win.addEventListener("beforeprint", this.onPrint);
          win.addEventListener("scroll", this.onScroll);
          win.document.addEventListener("selectionchange", this.onSelectionChange);
        }
        removeWindowListeners(win) {
          win.removeEventListener("scroll", this.onScroll);
          win.removeEventListener("resize", this.onResize);
          win.removeEventListener("beforeprint", this.onPrint);
          win.document.removeEventListener("selectionchange", this.onSelectionChange);
        }
        destroy() {
          var _a2, _b, _c2;
          this.stop();
          (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
          (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
          (_c2 = this.resizeScroll) === null || _c2 === void 0 ? void 0 : _c2.disconnect();
          for (let dom of this.scrollTargets)
            dom.removeEventListener("scroll", this.onScroll);
          this.removeWindowListeners(this.win);
          clearTimeout(this.parentCheck);
          clearTimeout(this.resizeTimeout);
          this.win.cancelAnimationFrame(this.delayedFlush);
          this.win.cancelAnimationFrame(this.flushingAndroidKey);
        }
      };
      function findChild(cView, dom, dir) {
        while (dom) {
          let curView = ContentView.get(dom);
          if (curView && curView.parent == cView)
            return curView;
          let parent = dom.parentNode;
          dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
        }
        return null;
      }
      function safariSelectionRangeHack(view) {
        let found = null;
        function read(event2) {
          event2.preventDefault();
          event2.stopImmediatePropagation();
          found = event2.getTargetRanges()[0];
        }
        view.contentDOM.addEventListener("beforeinput", read, true);
        view.dom.ownerDocument.execCommand("indent");
        view.contentDOM.removeEventListener("beforeinput", read, true);
        if (!found)
          return null;
        let anchorNode = found.startContainer, anchorOffset = found.startOffset;
        let focusNode = found.endContainer, focusOffset = found.endOffset;
        let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
        if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
          [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
        return { anchorNode, anchorOffset, focusNode, focusOffset };
      }
      var EditorView = class {
        get state() {
          return this.viewState.state;
        }
        get viewport() {
          return this.viewState.viewport;
        }
        get visibleRanges() {
          return this.viewState.visibleRanges;
        }
        get inView() {
          return this.viewState.inView;
        }
        get composing() {
          return this.inputState.composing > 0;
        }
        get compositionStarted() {
          return this.inputState.composing >= 0;
        }
        get root() {
          return this._root;
        }
        get win() {
          return this.dom.ownerDocument.defaultView || window;
        }
        constructor(config = {}) {
          this.plugins = [];
          this.pluginMap = new Map();
          this.editorAttrs = {};
          this.contentAttrs = {};
          this.bidiCache = [];
          this.destroyed = false;
          this.updateState = 2;
          this.measureScheduled = -1;
          this.measureRequests = [];
          this.contentDOM = document.createElement("div");
          this.scrollDOM = document.createElement("div");
          this.scrollDOM.tabIndex = -1;
          this.scrollDOM.className = "cm-scroller";
          this.scrollDOM.appendChild(this.contentDOM);
          this.announceDOM = document.createElement("div");
          this.announceDOM.className = "cm-announced";
          this.announceDOM.setAttribute("aria-live", "polite");
          this.dom = document.createElement("div");
          this.dom.appendChild(this.announceDOM);
          this.dom.appendChild(this.scrollDOM);
          let { dispatch } = config;
          this.dispatchTransactions = config.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr2) => dispatch(tr2, this))) || ((trs) => this.update(trs));
          this.dispatch = this.dispatch.bind(this);
          this._root = config.root || getRoot(config.parent) || document;
          this.viewState = new ViewState(config.state || state.EditorState.create(config));
          if (config.scrollTo && config.scrollTo.is(scrollIntoView))
            this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);
          this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
          for (let plugin2 of this.plugins)
            plugin2.update(this);
          this.observer = new DOMObserver(this);
          this.inputState = new InputState(this);
          this.inputState.ensureHandlers(this.plugins);
          this.docView = new DocView(this);
          this.mountStyles();
          this.updateAttrs();
          this.updateState = 0;
          this.requestMeasure();
          if (config.parent)
            config.parent.appendChild(this.dom);
        }
        dispatch(...input) {
          let trs = input.length == 1 && input[0] instanceof state.Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];
          this.dispatchTransactions(trs, this);
        }
        update(transactions) {
          if (this.updateState != 0)
            throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
          let redrawn = false, attrsChanged = false, update;
          let state$1 = this.state;
          for (let tr2 of transactions) {
            if (tr2.startState != state$1)
              throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
            state$1 = tr2.state;
          }
          if (this.destroyed) {
            this.viewState.state = state$1;
            return;
          }
          let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
          if (transactions.some((tr2) => tr2.annotation(isFocusChange))) {
            this.inputState.notifiedFocused = focus;
            focusFlag = 1;
          } else if (focus != this.inputState.notifiedFocused) {
            this.inputState.notifiedFocused = focus;
            dispatchFocus = focusChangeTransaction(state$1, focus);
            if (!dispatchFocus)
              focusFlag = 1;
          }
          let pendingKey = this.observer.delayedAndroidKey, domChange = null;
          if (pendingKey) {
            this.observer.clearDelayedAndroidKey();
            domChange = this.observer.readChange();
            if (domChange && !this.state.doc.eq(state$1.doc) || !this.state.selection.eq(state$1.selection))
              domChange = null;
          } else {
            this.observer.clear();
          }
          if (state$1.facet(state.EditorState.phrases) != this.state.facet(state.EditorState.phrases))
            return this.setState(state$1);
          update = ViewUpdate.create(this, state$1, transactions);
          update.flags |= focusFlag;
          let scrollTarget = this.viewState.scrollTarget;
          try {
            this.updateState = 2;
            for (let tr2 of transactions) {
              if (scrollTarget)
                scrollTarget = scrollTarget.map(tr2.changes);
              if (tr2.scrollIntoView) {
                let { main } = tr2.state.selection;
                scrollTarget = new ScrollTarget(main.empty ? main : state.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
              }
              for (let e of tr2.effects)
                if (e.is(scrollIntoView))
                  scrollTarget = e.value.clip(this.state);
            }
            this.viewState.update(update, scrollTarget);
            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
            if (!update.empty) {
              this.updatePlugins(update);
              this.inputState.update(update);
            }
            redrawn = this.docView.update(update);
            if (this.state.facet(styleModule) != this.styleModules)
              this.mountStyles();
            attrsChanged = this.updateAttrs();
            this.showAnnouncements(transactions);
            this.docView.updateSelection(redrawn, transactions.some((tr2) => tr2.isUserEvent("select.pointer")));
          } finally {
            this.updateState = 0;
          }
          if (update.startState.facet(theme) != update.state.facet(theme))
            this.viewState.mustMeasureContent = true;
          if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
            this.requestMeasure();
          if (!update.empty)
            for (let listener of this.state.facet(updateListener)) {
              try {
                listener(update);
              } catch (e) {
                logException(this.state, e, "update listener");
              }
            }
          if (dispatchFocus || domChange)
            Promise.resolve().then(() => {
              if (dispatchFocus && this.state == dispatchFocus.startState)
                this.dispatch(dispatchFocus);
              if (domChange) {
                if (!applyDOMChange(this, domChange) && pendingKey.force)
                  dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
              }
            });
        }
        setState(newState) {
          if (this.updateState != 0)
            throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
          if (this.destroyed) {
            this.viewState.state = newState;
            return;
          }
          this.updateState = 2;
          let hadFocus = this.hasFocus;
          try {
            for (let plugin2 of this.plugins)
              plugin2.destroy(this);
            this.viewState = new ViewState(newState);
            this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
            this.pluginMap.clear();
            for (let plugin2 of this.plugins)
              plugin2.update(this);
            this.docView.destroy();
            this.docView = new DocView(this);
            this.inputState.ensureHandlers(this.plugins);
            this.mountStyles();
            this.updateAttrs();
            this.bidiCache = [];
          } finally {
            this.updateState = 0;
          }
          if (hadFocus)
            this.focus();
          this.requestMeasure();
        }
        updatePlugins(update) {
          let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
          if (prevSpecs != specs) {
            let newPlugins = [];
            for (let spec of specs) {
              let found = prevSpecs.indexOf(spec);
              if (found < 0) {
                newPlugins.push(new PluginInstance(spec));
              } else {
                let plugin2 = this.plugins[found];
                plugin2.mustUpdate = update;
                newPlugins.push(plugin2);
              }
            }
            for (let plugin2 of this.plugins)
              if (plugin2.mustUpdate != update)
                plugin2.destroy(this);
            this.plugins = newPlugins;
            this.pluginMap.clear();
          } else {
            for (let p of this.plugins)
              p.mustUpdate = update;
          }
          for (let i = 0; i < this.plugins.length; i++)
            this.plugins[i].update(this);
          if (prevSpecs != specs)
            this.inputState.ensureHandlers(this.plugins);
        }
        measure(flush = true) {
          if (this.destroyed)
            return;
          if (this.measureScheduled > -1)
            this.win.cancelAnimationFrame(this.measureScheduled);
          if (this.observer.delayedAndroidKey) {
            this.measureScheduled = -1;
            this.requestMeasure();
            return;
          }
          this.measureScheduled = 0;
          if (flush)
            this.observer.forceFlush();
          let updated = null;
          let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
          let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
          if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
            scrollAnchorHeight = -1;
          this.viewState.scrollAnchorHeight = -1;
          try {
            for (let i = 0; ; i++) {
              if (scrollAnchorHeight < 0) {
                if (isScrolledToBottom(sDOM)) {
                  scrollAnchorPos = -1;
                  scrollAnchorHeight = this.viewState.heightMap.height;
                } else {
                  let block = this.viewState.scrollAnchorAt(scrollTop);
                  scrollAnchorPos = block.from;
                  scrollAnchorHeight = block.top;
                }
              }
              this.updateState = 1;
              let changed = this.viewState.measure(this);
              if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
                break;
              if (i > 5) {
                console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
                break;
              }
              let measuring = [];
              if (!(changed & 4))
                [this.measureRequests, measuring] = [measuring, this.measureRequests];
              let measured = measuring.map((m) => {
                try {
                  return m.read(this);
                } catch (e) {
                  logException(this.state, e);
                  return BadMeasure;
                }
              });
              let update = ViewUpdate.create(this, this.state, []), redrawn = false;
              update.flags |= changed;
              if (!updated)
                updated = update;
              else
                updated.flags |= changed;
              this.updateState = 2;
              if (!update.empty) {
                this.updatePlugins(update);
                this.inputState.update(update);
                this.updateAttrs();
                redrawn = this.docView.update(update);
              }
              for (let i2 = 0; i2 < measuring.length; i2++)
                if (measured[i2] != BadMeasure) {
                  try {
                    let m = measuring[i2];
                    if (m.write)
                      m.write(measured[i2], this);
                  } catch (e) {
                    logException(this.state, e);
                  }
                }
              if (redrawn)
                this.docView.updateSelection(true);
              if (!update.viewportChanged && this.measureRequests.length == 0) {
                if (this.viewState.editorHeight) {
                  if (this.viewState.scrollTarget) {
                    this.docView.scrollIntoView(this.viewState.scrollTarget);
                    this.viewState.scrollTarget = null;
                    continue;
                  } else {
                    let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
                    let diff = newAnchorHeight - scrollAnchorHeight;
                    if (diff > 1 || diff < -1) {
                      scrollTop = scrollTop + diff;
                      sDOM.scrollTop = scrollTop / this.scaleY;
                      scrollAnchorHeight = -1;
                      continue;
                    }
                  }
                }
                break;
              }
            }
          } finally {
            this.updateState = 0;
            this.measureScheduled = -1;
          }
          if (updated && !updated.empty)
            for (let listener of this.state.facet(updateListener))
              listener(updated);
        }
        get themeClasses() {
          return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
        }
        updateAttrs() {
          let editorAttrs = attrsFromFacet(this, editorAttributes, {
            class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
          });
          let contentAttrs = {
            spellcheck: "false",
            autocorrect: "off",
            autocapitalize: "off",
            translate: "no",
            contenteditable: !this.state.facet(editable) ? "false" : "true",
            class: "cm-content",
            style: `${browser.tabSize}: ${this.state.tabSize}`,
            role: "textbox",
            "aria-multiline": "true"
          };
          if (this.state.readOnly)
            contentAttrs["aria-readonly"] = "true";
          attrsFromFacet(this, contentAttributes, contentAttrs);
          let changed = this.observer.ignore(() => {
            let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
            let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
            return changedContent || changedEditor;
          });
          this.editorAttrs = editorAttrs;
          this.contentAttrs = contentAttrs;
          return changed;
        }
        showAnnouncements(trs) {
          let first = true;
          for (let tr2 of trs)
            for (let effect of tr2.effects)
              if (effect.is(EditorView.announce)) {
                if (first)
                  this.announceDOM.textContent = "";
                first = false;
                let div = this.announceDOM.appendChild(document.createElement("div"));
                div.textContent = effect.value;
              }
        }
        mountStyles() {
          this.styleModules = this.state.facet(styleModule);
          let nonce = this.state.facet(EditorView.cspNonce);
          styleMod.StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : void 0);
        }
        readMeasured() {
          if (this.updateState == 2)
            throw new Error("Reading the editor layout isn't allowed during an update");
          if (this.updateState == 0 && this.measureScheduled > -1)
            this.measure(false);
        }
        requestMeasure(request) {
          if (this.measureScheduled < 0)
            this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
          if (request) {
            if (this.measureRequests.indexOf(request) > -1)
              return;
            if (request.key != null)
              for (let i = 0; i < this.measureRequests.length; i++) {
                if (this.measureRequests[i].key === request.key) {
                  this.measureRequests[i] = request;
                  return;
                }
              }
            this.measureRequests.push(request);
          }
        }
        plugin(plugin2) {
          let known = this.pluginMap.get(plugin2);
          if (known === void 0 || known && known.spec != plugin2)
            this.pluginMap.set(plugin2, known = this.plugins.find((p) => p.spec == plugin2) || null);
          return known && known.update(this).value;
        }
        get documentTop() {
          return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
        }
        get documentPadding() {
          return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
        }
        get scaleX() {
          return this.viewState.scaleX;
        }
        get scaleY() {
          return this.viewState.scaleY;
        }
        elementAtHeight(height) {
          this.readMeasured();
          return this.viewState.elementAtHeight(height);
        }
        lineBlockAtHeight(height) {
          this.readMeasured();
          return this.viewState.lineBlockAtHeight(height);
        }
        get viewportLineBlocks() {
          return this.viewState.viewportLines;
        }
        lineBlockAt(pos) {
          return this.viewState.lineBlockAt(pos);
        }
        get contentHeight() {
          return this.viewState.contentHeight;
        }
        moveByChar(start, forward, by) {
          return skipAtoms(this, start, moveByChar(this, start, forward, by));
        }
        moveByGroup(start, forward) {
          return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
        }
        moveToLineBoundary(start, forward, includeWrap = true) {
          return moveToLineBoundary(this, start, forward, includeWrap);
        }
        moveVertically(start, forward, distance) {
          return skipAtoms(this, start, moveVertically(this, start, forward, distance));
        }
        domAtPos(pos) {
          return this.docView.domAtPos(pos);
        }
        posAtDOM(node, offset = 0) {
          return this.docView.posFromDOM(node, offset);
        }
        posAtCoords(coords, precise = true) {
          this.readMeasured();
          return posAtCoords(this, coords, precise);
        }
        coordsAtPos(pos, side = 1) {
          this.readMeasured();
          let rect = this.docView.coordsAt(pos, side);
          if (!rect || rect.left == rect.right)
            return rect;
          let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
          let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
          return flattenRect(rect, span.dir == exports.Direction.LTR == side > 0);
        }
        coordsForChar(pos) {
          this.readMeasured();
          return this.docView.coordsForChar(pos);
        }
        get defaultCharacterWidth() {
          return this.viewState.heightOracle.charWidth;
        }
        get defaultLineHeight() {
          return this.viewState.heightOracle.lineHeight;
        }
        get textDirection() {
          return this.viewState.defaultTextDirection;
        }
        textDirectionAt(pos) {
          let perLine = this.state.facet(perLineTextDirection);
          if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
            return this.textDirection;
          this.readMeasured();
          return this.docView.textDirectionAt(pos);
        }
        get lineWrapping() {
          return this.viewState.heightOracle.lineWrapping;
        }
        bidiSpans(line) {
          if (line.length > MaxBidiLine)
            return trivialOrder(line.length);
          let dir = this.textDirectionAt(line.from), isolates;
          for (let entry of this.bidiCache) {
            if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line.from, line.to))))
              return entry.order;
          }
          if (!isolates)
            isolates = getIsolatedRanges(this, line.from, line.to);
          let order = computeOrder(line.text, dir, isolates);
          this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
          return order;
        }
        get hasFocus() {
          var _a2;
          return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
        }
        focus() {
          this.observer.ignore(() => {
            focusPreventScroll(this.contentDOM);
            this.docView.updateSelection();
          });
        }
        setRoot(root) {
          if (this._root != root) {
            this._root = root;
            this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
            this.mountStyles();
          }
        }
        destroy() {
          for (let plugin2 of this.plugins)
            plugin2.destroy(this);
          this.plugins = [];
          this.inputState.destroy();
          this.docView.destroy();
          this.dom.remove();
          this.observer.destroy();
          if (this.measureScheduled > -1)
            this.win.cancelAnimationFrame(this.measureScheduled);
          this.destroyed = true;
        }
        static scrollIntoView(pos, options = {}) {
          return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? state.EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
        }
        scrollSnapshot() {
          let { scrollTop, scrollLeft } = this.scrollDOM;
          let ref = this.viewState.scrollAnchorAt(scrollTop);
          return scrollIntoView.of(new ScrollTarget(state.EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
        }
        static domEventHandlers(handlers2) {
          return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
        }
        static domEventObservers(observers2) {
          return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
        }
        static theme(spec, options) {
          let prefix = styleMod.StyleModule.newName();
          let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
          if (options && options.dark)
            result.push(darkTheme.of(true));
          return result;
        }
        static baseTheme(spec) {
          return state.Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
        }
        static findFromDOM(dom) {
          var _a2;
          let content = dom.querySelector(".cm-content");
          let cView = content && ContentView.get(content) || ContentView.get(dom);
          return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
        }
      };
      EditorView.styleModule = styleModule;
      EditorView.inputHandler = inputHandler;
      EditorView.focusChangeEffect = focusChangeEffect;
      EditorView.perLineTextDirection = perLineTextDirection;
      EditorView.exceptionSink = exceptionSink;
      EditorView.updateListener = updateListener;
      EditorView.editable = editable;
      EditorView.mouseSelectionStyle = mouseSelectionStyle;
      EditorView.dragMovesSelection = dragMovesSelection$1;
      EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
      EditorView.decorations = decorations;
      EditorView.atomicRanges = atomicRanges;
      EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
      EditorView.scrollMargins = scrollMargins;
      EditorView.darkTheme = darkTheme;
      EditorView.cspNonce = state.Facet.define({ combine: (values) => values.length ? values[0] : "" });
      EditorView.contentAttributes = contentAttributes;
      EditorView.editorAttributes = editorAttributes;
      EditorView.lineWrapping = EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
      EditorView.announce = state.StateEffect.define();
      var MaxBidiLine = 4096;
      var BadMeasure = {};
      var CachedOrder = class {
        constructor(from, to2, dir, isolates, fresh, order) {
          this.from = from;
          this.to = to2;
          this.dir = dir;
          this.isolates = isolates;
          this.fresh = fresh;
          this.order = order;
        }
        static update(cache, changes) {
          if (changes.empty && !cache.some((c2) => c2.fresh))
            return cache;
          let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : exports.Direction.LTR;
          for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
            let entry = cache[i];
            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
              result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
          }
          return result;
        }
      };
      function attrsFromFacet(view, facet, base) {
        for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
          let source = sources[i], value = typeof source == "function" ? source(view) : source;
          if (value)
            combineAttrs(value, base);
        }
        return base;
      }
      var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
      function normalizeKeyName(name, platform) {
        const parts = name.split(/-(?!$)/);
        let result = parts[parts.length - 1];
        if (result == "Space")
          result = " ";
        let alt, ctrl, shift, meta;
        for (let i = 0; i < parts.length - 1; ++i) {
          const mod = parts[i];
          if (/^(cmd|meta|m)$/i.test(mod))
            meta = true;
          else if (/^a(lt)?$/i.test(mod))
            alt = true;
          else if (/^(c|ctrl|control)$/i.test(mod))
            ctrl = true;
          else if (/^s(hift)?$/i.test(mod))
            shift = true;
          else if (/^mod$/i.test(mod)) {
            if (platform == "mac")
              meta = true;
            else
              ctrl = true;
          } else
            throw new Error("Unrecognized modifier name: " + mod);
        }
        if (alt)
          result = "Alt-" + result;
        if (ctrl)
          result = "Ctrl-" + result;
        if (meta)
          result = "Meta-" + result;
        if (shift)
          result = "Shift-" + result;
        return result;
      }
      function modifiers(name, event2, shift) {
        if (event2.altKey)
          name = "Alt-" + name;
        if (event2.ctrlKey)
          name = "Ctrl-" + name;
        if (event2.metaKey)
          name = "Meta-" + name;
        if (shift !== false && event2.shiftKey)
          name = "Shift-" + name;
        return name;
      }
      var handleKeyEvents = state.Prec.default(EditorView.domEventHandlers({
        keydown(event2, view) {
          return runHandlers(getKeymap(view.state), event2, view, "editor");
        }
      }));
      var keymap = state.Facet.define({ enables: handleKeyEvents });
      var Keymaps = new WeakMap();
      function getKeymap(state2) {
        let bindings = state2.facet(keymap);
        let map = Keymaps.get(bindings);
        if (!map)
          Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
        return map;
      }
      function runScopeHandlers(view, event2, scope) {
        return runHandlers(getKeymap(view.state), event2, view, scope);
      }
      var storedPrefix = null;
      var PrefixTimeout = 4e3;
      function buildKeymap(bindings, platform = currentPlatform) {
        let bound = Object.create(null);
        let isPrefix = Object.create(null);
        let checkPrefix = (name, is) => {
          let current = isPrefix[name];
          if (current == null)
            isPrefix[name] = is;
          else if (current != is)
            throw new Error("Key binding " + name + " is used both as a regular binding and as a multi-stroke prefix");
        };
        let add = (scope, key, command, preventDefault, stopPropagation) => {
          var _a2, _b;
          let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
          let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
          for (let i = 1; i < parts.length; i++) {
            let prefix = parts.slice(0, i).join(" ");
            checkPrefix(prefix, true);
            if (!scopeObj[prefix])
              scopeObj[prefix] = {
                preventDefault: true,
                stopPropagation: false,
                run: [(view) => {
                  let ourObj = storedPrefix = { view, prefix, scope };
                  setTimeout(() => {
                    if (storedPrefix == ourObj)
                      storedPrefix = null;
                  }, PrefixTimeout);
                  return true;
                }]
              };
          }
          let full = parts.join(" ");
          checkPrefix(full, false);
          let binding = scopeObj[full] || (scopeObj[full] = {
            preventDefault: false,
            stopPropagation: false,
            run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
          });
          if (command)
            binding.run.push(command);
          if (preventDefault)
            binding.preventDefault = true;
          if (stopPropagation)
            binding.stopPropagation = true;
        };
        for (let b of bindings) {
          let scopes = b.scope ? b.scope.split(" ") : ["editor"];
          if (b.any)
            for (let scope of scopes) {
              let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
              if (!scopeObj._any)
                scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
              for (let key in scopeObj)
                scopeObj[key].run.push(b.any);
            }
          let name = b[platform] || b.key;
          if (!name)
            continue;
          for (let scope of scopes) {
            add(scope, name, b.run, b.preventDefault, b.stopPropagation);
            if (b.shift)
              add(scope, "Shift-" + name, b.shift, b.preventDefault, b.stopPropagation);
          }
        }
        return bound;
      }
      function runHandlers(map, event2, view, scope) {
        let name = w3cKeyname.keyName(event2);
        let charCode = state.codePointAt(name, 0), isChar = state.codePointSize(charCode) == name.length && name != " ";
        let prefix = "", handled = false, prevented = false, stopPropagation = false;
        if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
          prefix = storedPrefix.prefix + " ";
          if (modifierCodes.indexOf(event2.keyCode) < 0) {
            prevented = true;
            storedPrefix = null;
          }
        }
        let ran = new Set();
        let runFor = (binding) => {
          if (binding) {
            for (let cmd of binding.run)
              if (!ran.has(cmd)) {
                ran.add(cmd);
                if (cmd(view, event2)) {
                  if (binding.stopPropagation)
                    stopPropagation = true;
                  return true;
                }
              }
            if (binding.preventDefault) {
              if (binding.stopPropagation)
                stopPropagation = true;
              prevented = true;
            }
          }
          return false;
        };
        let scopeObj = map[scope], baseName, shiftName;
        if (scopeObj) {
          if (runFor(scopeObj[prefix + modifiers(name, event2, !isChar)])) {
            handled = true;
          } else if (isChar && (event2.altKey || event2.metaKey || event2.ctrlKey) && !(browser.windows && event2.ctrlKey && event2.altKey) && (baseName = w3cKeyname.base[event2.keyCode]) && baseName != name) {
            if (runFor(scopeObj[prefix + modifiers(baseName, event2, true)])) {
              handled = true;
            } else if (event2.shiftKey && (shiftName = w3cKeyname.shift[event2.keyCode]) != name && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event2, false)])) {
              handled = true;
            }
          } else if (isChar && event2.shiftKey && runFor(scopeObj[prefix + modifiers(name, event2, true)])) {
            handled = true;
          }
          if (!handled && runFor(scopeObj._any))
            handled = true;
        }
        if (prevented)
          handled = true;
        if (handled && stopPropagation)
          event2.stopPropagation();
        return handled;
      }
      var RectangleMarker = class {
        constructor(className, left, top, width, height) {
          this.className = className;
          this.left = left;
          this.top = top;
          this.width = width;
          this.height = height;
        }
        draw() {
          let elt = document.createElement("div");
          elt.className = this.className;
          this.adjust(elt);
          return elt;
        }
        update(elt, prev) {
          if (prev.className != this.className)
            return false;
          this.adjust(elt);
          return true;
        }
        adjust(elt) {
          elt.style.left = this.left + "px";
          elt.style.top = this.top + "px";
          if (this.width != null)
            elt.style.width = this.width + "px";
          elt.style.height = this.height + "px";
        }
        eq(p) {
          return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
        }
        static forRange(view, className, range) {
          if (range.empty) {
            let pos = view.coordsAtPos(range.head, range.assoc || 1);
            if (!pos)
              return [];
            let base = getBase(view);
            return [new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)];
          } else {
            return rectanglesForRange(view, className, range);
          }
        }
      };
      function getBase(view) {
        let rect = view.scrollDOM.getBoundingClientRect();
        let left = view.textDirection == exports.Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
        return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
      }
      function wrappedLine(view, pos, inside2) {
        let range = state.EditorSelection.cursor(pos);
        return {
          from: Math.max(inside2.from, view.moveToLineBoundary(range, false, true).from),
          to: Math.min(inside2.to, view.moveToLineBoundary(range, true, true).from),
          type: exports.BlockType.Text
        };
      }
      function rectanglesForRange(view, className, range) {
        if (range.to <= view.viewport.from || range.from >= view.viewport.to)
          return [];
        let from = Math.max(range.from, view.viewport.from), to2 = Math.min(range.to, view.viewport.to);
        let ltr = view.textDirection == exports.Direction.LTR;
        let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);
        let lineElt = content.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
        let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
        let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
        let startBlock = blockAt(view, from), endBlock = blockAt(view, to2);
        let visualStart = startBlock.type == exports.BlockType.Text ? startBlock : null;
        let visualEnd = endBlock.type == exports.BlockType.Text ? endBlock : null;
        if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
          visualStart = wrappedLine(view, from, visualStart);
        if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
          visualEnd = wrappedLine(view, to2, visualEnd);
        if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
          return pieces(drawForLine(range.from, range.to, visualStart));
        } else {
          let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
          let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
          let between = [];
          if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top.bottom + view.defaultLineHeight / 2 < bottom.top)
            between.push(piece(leftSide, top.bottom, rightSide, bottom.top));
          else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == exports.BlockType.Text)
            top.bottom = bottom.top = (top.bottom + bottom.top) / 2;
          return pieces(top).concat(between).concat(pieces(bottom));
        }
        function piece(left, top, right, bottom) {
          return new RectangleMarker(className, left - base.left, top - base.top - 0.01, right - left, bottom - top + 0.01);
        }
        function pieces({ top, bottom, horizontal }) {
          let pieces2 = [];
          for (let i = 0; i < horizontal.length; i += 2)
            pieces2.push(piece(horizontal[i], top, horizontal[i + 1], bottom));
          return pieces2;
        }
        function drawForLine(from2, to3, line) {
          let top = 1e9, bottom = -1e9, horizontal = [];
          function addSpan(from3, fromOpen, to4, toOpen, dir) {
            let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
            let toCoords = view.coordsAtPos(to4, to4 == line.from ? 2 : -2);
            if (!fromCoords || !toCoords)
              return;
            top = Math.min(fromCoords.top, toCoords.top, top);
            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
            if (dir == exports.Direction.LTR)
              horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
            else
              horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
          }
          let start = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to3 !== null && to3 !== void 0 ? to3 : line.to;
          for (let r of view.visibleRanges)
            if (r.to > start && r.from < end) {
              for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {
                let docLine = view.state.doc.lineAt(pos);
                for (let span of view.bidiSpans(docLine)) {
                  let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
                  if (spanFrom >= endPos)
                    break;
                  if (spanTo > pos)
                    addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to3 == null && spanTo >= end, span.dir);
                }
                pos = docLine.to + 1;
                if (pos >= endPos)
                  break;
              }
            }
          if (horizontal.length == 0)
            addSpan(start, from2 == null, end, to3 == null, view.textDirection);
          return { top, bottom, horizontal };
        }
        function drawForWidget(block, top) {
          let y2 = contentRect.top + (top ? block.top : block.bottom);
          return { top: y2, bottom: y2, horizontal: [] };
        }
      }
      function sameMarker(a, b) {
        return a.constructor == b.constructor && a.eq(b);
      }
      var LayerView = class {
        constructor(view, layer2) {
          this.view = view;
          this.layer = layer2;
          this.drawn = [];
          this.scaleX = 1;
          this.scaleY = 1;
          this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
          this.dom = view.scrollDOM.appendChild(document.createElement("div"));
          this.dom.classList.add("cm-layer");
          if (layer2.above)
            this.dom.classList.add("cm-layer-above");
          if (layer2.class)
            this.dom.classList.add(layer2.class);
          this.scale();
          this.dom.setAttribute("aria-hidden", "true");
          this.setOrder(view.state);
          view.requestMeasure(this.measureReq);
          if (layer2.mount)
            layer2.mount(this.dom, view);
        }
        update(update) {
          if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
            this.setOrder(update.state);
          if (this.layer.update(update, this.dom) || update.geometryChanged) {
            this.scale();
            update.view.requestMeasure(this.measureReq);
          }
        }
        setOrder(state2) {
          let pos = 0, order = state2.facet(layerOrder);
          while (pos < order.length && order[pos] != this.layer)
            pos++;
          this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
        }
        measure() {
          return this.layer.markers(this.view);
        }
        scale() {
          let { scaleX, scaleY } = this.view;
          if (scaleX != this.scaleX || scaleY != this.scaleY) {
            this.scaleX = scaleX;
            this.scaleY = scaleY;
            this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
          }
        }
        draw(markers) {
          if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
            let old = this.dom.firstChild, oldI = 0;
            for (let marker of markers) {
              if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
                old = old.nextSibling;
                oldI++;
              } else {
                this.dom.insertBefore(marker.draw(), old);
              }
            }
            while (old) {
              let next = old.nextSibling;
              old.remove();
              old = next;
            }
            this.drawn = markers;
          }
        }
        destroy() {
          if (this.layer.destroy)
            this.layer.destroy(this.dom, this.view);
          this.dom.remove();
        }
      };
      var layerOrder = state.Facet.define();
      function layer(config) {
        return [
          ViewPlugin.define((v) => new LayerView(v, config)),
          layerOrder.of(config)
        ];
      }
      var CanHidePrimary = !browser.ios;
      var selectionConfig = state.Facet.define({
        combine(configs) {
          return state.combineConfig(configs, {
            cursorBlinkRate: 1200,
            drawRangeCursor: true
          }, {
            cursorBlinkRate: (a, b) => Math.min(a, b),
            drawRangeCursor: (a, b) => a || b
          });
        }
      });
      function drawSelection(config = {}) {
        return [
          selectionConfig.of(config),
          cursorLayer,
          selectionLayer,
          hideNativeSelection,
          nativeSelectionHidden.of(true)
        ];
      }
      function getDrawSelectionConfig(state2) {
        return state2.facet(selectionConfig);
      }
      function configChanged(update) {
        return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
      }
      var cursorLayer = layer({
        above: true,
        markers(view) {
          let { state: state$1 } = view, conf = state$1.facet(selectionConfig);
          let cursors = [];
          for (let r of state$1.selection.ranges) {
            let prim = r == state$1.selection.main;
            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
              let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
              let cursor = r.empty ? r : state.EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
              for (let piece of RectangleMarker.forRange(view, className, cursor))
                cursors.push(piece);
            }
          }
          return cursors;
        },
        update(update, dom) {
          if (update.transactions.some((tr2) => tr2.selection))
            dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
          let confChange = configChanged(update);
          if (confChange)
            setBlinkRate(update.state, dom);
          return update.docChanged || update.selectionSet || confChange;
        },
        mount(dom, view) {
          setBlinkRate(view.state, dom);
        },
        class: "cm-cursorLayer"
      });
      function setBlinkRate(state2, dom) {
        dom.style.animationDuration = state2.facet(selectionConfig).cursorBlinkRate + "ms";
      }
      var selectionLayer = layer({
        above: false,
        markers(view) {
          return view.state.selection.ranges.map((r) => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r)).reduce((a, b) => a.concat(b));
        },
        update(update, dom) {
          return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
        },
        class: "cm-selectionLayer"
      });
      var themeSpec = {
        ".cm-line": {
          "& ::selection": { backgroundColor: "transparent !important" },
          "&::selection": { backgroundColor: "transparent !important" }
        }
      };
      if (CanHidePrimary) {
        themeSpec[".cm-line"].caretColor = "transparent !important";
        themeSpec[".cm-content"] = { caretColor: "transparent !important" };
      }
      var hideNativeSelection = state.Prec.highest(EditorView.theme(themeSpec));
      var setDropCursorPos = state.StateEffect.define({
        map(pos, mapping) {
          return pos == null ? null : mapping.mapPos(pos);
        }
      });
      var dropCursorPos = state.StateField.define({
        create() {
          return null;
        },
        update(pos, tr2) {
          if (pos != null)
            pos = tr2.changes.mapPos(pos);
          return tr2.effects.reduce((pos2, e) => e.is(setDropCursorPos) ? e.value : pos2, pos);
        }
      });
      var drawDropCursor = ViewPlugin.fromClass(class {
        constructor(view) {
          this.view = view;
          this.cursor = null;
          this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
        }
        update(update) {
          var _a2;
          let cursorPos = update.state.field(dropCursorPos);
          if (cursorPos == null) {
            if (this.cursor != null) {
              (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
              this.cursor = null;
            }
          } else {
            if (!this.cursor) {
              this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
              this.cursor.className = "cm-dropCursor";
            }
            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
              this.view.requestMeasure(this.measureReq);
          }
        }
        readPos() {
          let { view } = this;
          let pos = view.state.field(dropCursorPos);
          let rect = pos != null && view.coordsAtPos(pos);
          if (!rect)
            return null;
          let outer = view.scrollDOM.getBoundingClientRect();
          return {
            left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
            top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
            height: rect.bottom - rect.top
          };
        }
        drawCursor(pos) {
          if (this.cursor) {
            let { scaleX, scaleY } = this.view;
            if (pos) {
              this.cursor.style.left = pos.left / scaleX + "px";
              this.cursor.style.top = pos.top / scaleY + "px";
              this.cursor.style.height = pos.height / scaleY + "px";
            } else {
              this.cursor.style.left = "-100000px";
            }
          }
        }
        destroy() {
          if (this.cursor)
            this.cursor.remove();
        }
        setDropPos(pos) {
          if (this.view.state.field(dropCursorPos) != pos)
            this.view.dispatch({ effects: setDropCursorPos.of(pos) });
        }
      }, {
        eventObservers: {
          dragover(event2) {
            this.setDropPos(this.view.posAtCoords({ x: event2.clientX, y: event2.clientY }));
          },
          dragleave(event2) {
            if (event2.target == this.view.contentDOM || !this.view.contentDOM.contains(event2.relatedTarget))
              this.setDropPos(null);
          },
          dragend() {
            this.setDropPos(null);
          },
          drop() {
            this.setDropPos(null);
          }
        }
      });
      function dropCursor() {
        return [dropCursorPos, drawDropCursor];
      }
      function iterMatches(doc2, re, from, to2, f) {
        re.lastIndex = 0;
        for (let cursor = doc2.iterRange(from, to2), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
          if (!cursor.lineBreak)
            while (m = re.exec(cursor.value))
              f(pos + m.index, m);
        }
      }
      function matchRanges(view, maxLength) {
        let visible = view.visibleRanges;
        if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
          return visible;
        let result = [];
        for (let { from, to: to2 } of visible) {
          from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
          to2 = Math.min(view.state.doc.lineAt(to2).to, to2 + maxLength);
          if (result.length && result[result.length - 1].to >= from)
            result[result.length - 1].to = to2;
          else
            result.push({ from, to: to2 });
        }
        return result;
      }
      var MatchDecorator = class {
        constructor(config) {
          const { regexp, decoration, decorate, boundary, maxLength = 1e3 } = config;
          if (!regexp.global)
            throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
          this.regexp = regexp;
          if (decorate) {
            this.addMatch = (match, view, from, add) => decorate(add, from, from + match[0].length, match, view);
          } else if (typeof decoration == "function") {
            this.addMatch = (match, view, from, add) => {
              let deco = decoration(match, view, from);
              if (deco)
                add(from, from + match[0].length, deco);
            };
          } else if (decoration) {
            this.addMatch = (match, _view, from, add) => add(from, from + match[0].length, decoration);
          } else {
            throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
          }
          this.boundary = boundary;
          this.maxLength = maxLength;
        }
        createDeco(view) {
          let build = new state.RangeSetBuilder(), add = build.add.bind(build);
          for (let { from, to: to2 } of matchRanges(view, this.maxLength))
            iterMatches(view.state.doc, this.regexp, from, to2, (from2, m) => this.addMatch(m, view, from2, add));
          return build.finish();
        }
        updateDeco(update, deco) {
          let changeFrom = 1e9, changeTo = -1;
          if (update.docChanged)
            update.changes.iterChanges((_f, _t2, from, to2) => {
              if (to2 > update.view.viewport.from && from < update.view.viewport.to) {
                changeFrom = Math.min(from, changeFrom);
                changeTo = Math.max(to2, changeTo);
              }
            });
          if (update.viewportChanged || changeTo - changeFrom > 1e3)
            return this.createDeco(update.view);
          if (changeTo > -1)
            return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
          return deco;
        }
        updateRange(view, deco, updateFrom, updateTo) {
          for (let r of view.visibleRanges) {
            let from = Math.max(r.from, updateFrom), to2 = Math.min(r.to, updateTo);
            if (to2 > from) {
              let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to2 ? view.state.doc.lineAt(to2) : fromLine;
              let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
              if (this.boundary) {
                for (; from > fromLine.from; from--)
                  if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                    start = from;
                    break;
                  }
                for (; to2 < toLine.to; to2++)
                  if (this.boundary.test(toLine.text[to2 - toLine.from])) {
                    end = to2;
                    break;
                  }
              }
              let ranges = [], m;
              let add = (from2, to3, deco2) => ranges.push(deco2.range(from2, to3));
              if (fromLine == toLine) {
                this.regexp.lastIndex = start - fromLine.from;
                while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
                  this.addMatch(m, view, m.index + fromLine.from, add);
              } else {
                iterMatches(view.state.doc, this.regexp, start, end, (from2, m2) => this.addMatch(m2, view, from2, add));
              }
              deco = deco.update({ filterFrom: start, filterTo: end, filter: (from2, to3) => from2 < start || to3 > end, add: ranges });
            }
          }
          return deco;
        }
      };
      var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
      var Specials = new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
      var Names = {
        0: "null",
        7: "bell",
        8: "backspace",
        10: "newline",
        11: "vertical tab",
        13: "carriage return",
        27: "escape",
        8203: "zero width space",
        8204: "zero width non-joiner",
        8205: "zero width joiner",
        8206: "left-to-right mark",
        8207: "right-to-left mark",
        8232: "line separator",
        8237: "left-to-right override",
        8238: "right-to-left override",
        8294: "left-to-right isolate",
        8295: "right-to-left isolate",
        8297: "pop directional isolate",
        8233: "paragraph separator",
        65279: "zero width no-break space",
        65532: "object replacement"
      };
      var _supportsTabSize = null;
      function supportsTabSize() {
        var _a2;
        if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
          let styles = document.body.style;
          _supportsTabSize = ((_a2 = styles.tabSize) !== null && _a2 !== void 0 ? _a2 : styles.MozTabSize) != null;
        }
        return _supportsTabSize || false;
      }
      var specialCharConfig = state.Facet.define({
        combine(configs) {
          let config = state.combineConfig(configs, {
            render: null,
            specialChars: Specials,
            addSpecialChars: null
          });
          if (config.replaceTabs = !supportsTabSize())
            config.specialChars = new RegExp("	|" + config.specialChars.source, UnicodeRegexpSupport);
          if (config.addSpecialChars)
            config.specialChars = new RegExp(config.specialChars.source + "|" + config.addSpecialChars.source, UnicodeRegexpSupport);
          return config;
        }
      });
      function highlightSpecialChars(config = {}) {
        return [specialCharConfig.of(config), specialCharPlugin()];
      }
      var _plugin = null;
      function specialCharPlugin() {
        return _plugin || (_plugin = ViewPlugin.fromClass(class {
          constructor(view) {
            this.view = view;
            this.decorations = Decoration.none;
            this.decorationCache = Object.create(null);
            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
            this.decorations = this.decorator.createDeco(view);
          }
          makeDecorator(conf) {
            return new MatchDecorator({
              regexp: conf.specialChars,
              decoration: (m, view, pos) => {
                let { doc: doc2 } = view.state;
                let code = state.codePointAt(m[0], 0);
                if (code == 9) {
                  let line = doc2.lineAt(pos);
                  let size = view.state.tabSize, col = state.countColumn(line.text, size, pos - line.from);
                  return Decoration.replace({
                    widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)
                  });
                }
                return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
              },
              boundary: conf.replaceTabs ? void 0 : /[^]/
            });
          }
          update(update) {
            let conf = update.state.facet(specialCharConfig);
            if (update.startState.facet(specialCharConfig) != conf) {
              this.decorator = this.makeDecorator(conf);
              this.decorations = this.decorator.createDeco(update.view);
            } else {
              this.decorations = this.decorator.updateDeco(update, this.decorations);
            }
          }
        }, {
          decorations: (v) => v.decorations
        }));
      }
      var DefaultPlaceholder = "\u2022";
      function placeholder$1(code) {
        if (code >= 32)
          return DefaultPlaceholder;
        if (code == 10)
          return "\u2424";
        return String.fromCharCode(9216 + code);
      }
      var SpecialCharWidget = class extends WidgetType {
        constructor(options, code) {
          super();
          this.options = options;
          this.code = code;
        }
        eq(other) {
          return other.code == this.code;
        }
        toDOM(view) {
          let ph2 = placeholder$1(this.code);
          let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
          let custom = this.options.render && this.options.render(this.code, desc, ph2);
          if (custom)
            return custom;
          let span = document.createElement("span");
          span.textContent = ph2;
          span.title = desc;
          span.setAttribute("aria-label", desc);
          span.className = "cm-specialChar";
          return span;
        }
        ignoreEvent() {
          return false;
        }
      };
      var TabWidget = class extends WidgetType {
        constructor(width) {
          super();
          this.width = width;
        }
        eq(other) {
          return other.width == this.width;
        }
        toDOM() {
          let span = document.createElement("span");
          span.textContent = "	";
          span.className = "cm-tab";
          span.style.width = this.width + "px";
          return span;
        }
        ignoreEvent() {
          return false;
        }
      };
      var plugin = ViewPlugin.fromClass(class {
        constructor() {
          this.height = 1e3;
          this.attrs = { style: "padding-bottom: 1000px" };
        }
        update(update) {
          let { view } = update;
          let height = view.viewState.editorHeight * view.scaleY - view.defaultLineHeight - view.documentPadding.top - 0.5;
          if (height >= 0 && height != this.height) {
            this.height = height;
            this.attrs = { style: `padding-bottom: ${height}px` };
          }
        }
      });
      function scrollPastEnd() {
        return [plugin, contentAttributes.of((view) => {
          var _a2;
          return ((_a2 = view.plugin(plugin)) === null || _a2 === void 0 ? void 0 : _a2.attrs) || null;
        })];
      }
      function highlightActiveLine() {
        return activeLineHighlighter;
      }
      var lineDeco = Decoration.line({ class: "cm-activeLine" });
      var activeLineHighlighter = ViewPlugin.fromClass(class {
        constructor(view) {
          this.decorations = this.getDeco(view);
        }
        update(update) {
          if (update.docChanged || update.selectionSet)
            this.decorations = this.getDeco(update.view);
        }
        getDeco(view) {
          let lastLineStart = -1, deco = [];
          for (let r of view.state.selection.ranges) {
            let line = view.lineBlockAt(r.head);
            if (line.from > lastLineStart) {
              deco.push(lineDeco.range(line.from));
              lastLineStart = line.from;
            }
          }
          return Decoration.set(deco);
        }
      }, {
        decorations: (v) => v.decorations
      });
      var Placeholder = class extends WidgetType {
        constructor(content) {
          super();
          this.content = content;
        }
        toDOM() {
          let wrap = document.createElement("span");
          wrap.className = "cm-placeholder";
          wrap.style.pointerEvents = "none";
          wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content);
          if (typeof this.content == "string")
            wrap.setAttribute("aria-label", "placeholder " + this.content);
          else
            wrap.setAttribute("aria-hidden", "true");
          return wrap;
        }
        coordsAt(dom) {
          let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];
          if (!rects.length)
            return null;
          let style = window.getComputedStyle(dom.parentNode);
          let rect = flattenRect(rects[0], style.direction != "rtl");
          let lineHeight = parseInt(style.lineHeight);
          if (rect.bottom - rect.top > lineHeight * 1.5)
            return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.top + lineHeight };
          return rect;
        }
        ignoreEvent() {
          return false;
        }
      };
      function placeholder(content) {
        return ViewPlugin.fromClass(class {
          constructor(view) {
            this.view = view;
            this.placeholder = content ? Decoration.set([Decoration.widget({ widget: new Placeholder(content), side: 1 }).range(0)]) : Decoration.none;
          }
          get decorations() {
            return this.view.state.doc.length ? Decoration.none : this.placeholder;
          }
        }, { decorations: (v) => v.decorations });
      }
      var MaxOff = 2e3;
      function rectangleFor(state$1, a, b) {
        let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
        let ranges = [];
        if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
          let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
          for (let i = startLine; i <= endLine; i++) {
            let line = state$1.doc.line(i);
            if (line.length <= endOff)
              ranges.push(state.EditorSelection.range(line.from + startOff, line.to + endOff));
          }
        } else {
          let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
          for (let i = startLine; i <= endLine; i++) {
            let line = state$1.doc.line(i);
            let start = state.findColumn(line.text, startCol, state$1.tabSize, true);
            if (start < 0) {
              ranges.push(state.EditorSelection.cursor(line.to));
            } else {
              let end = state.findColumn(line.text, endCol, state$1.tabSize);
              ranges.push(state.EditorSelection.range(line.from + start, line.from + end));
            }
          }
        }
        return ranges;
      }
      function absoluteColumn(view, x) {
        let ref = view.coordsAtPos(view.viewport.from);
        return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
      }
      function getPos(view, event2) {
        let offset = view.posAtCoords({ x: event2.clientX, y: event2.clientY }, false);
        let line = view.state.doc.lineAt(offset), off = offset - line.from;
        let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event2.clientX) : state.countColumn(line.text, view.state.tabSize, offset - line.from);
        return { line: line.number, col, off };
      }
      function rectangleSelectionStyle(view, event2) {
        let start = getPos(view, event2), startSel = view.state.selection;
        if (!start)
          return null;
        return {
          update(update) {
            if (update.docChanged) {
              let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
              let newLine = update.state.doc.lineAt(newStart);
              start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
              startSel = startSel.map(update.changes);
            }
          },
          get(event3, _extend, multiple) {
            let cur = getPos(view, event3);
            if (!cur)
              return startSel;
            let ranges = rectangleFor(view.state, start, cur);
            if (!ranges.length)
              return startSel;
            if (multiple)
              return state.EditorSelection.create(ranges.concat(startSel.ranges));
            else
              return state.EditorSelection.create(ranges);
          }
        };
      }
      function rectangularSelection(options) {
        let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e) => e.altKey && e.button == 0);
        return EditorView.mouseSelectionStyle.of((view, event2) => filter(event2) ? rectangleSelectionStyle(view, event2) : null);
      }
      var keys = {
        Alt: [18, (e) => !!e.altKey],
        Control: [17, (e) => !!e.ctrlKey],
        Shift: [16, (e) => !!e.shiftKey],
        Meta: [91, (e) => !!e.metaKey]
      };
      var showCrosshair = { style: "cursor: crosshair" };
      function crosshairCursor(options = {}) {
        let [code, getter] = keys[options.key || "Alt"];
        let plugin2 = ViewPlugin.fromClass(class {
          constructor(view) {
            this.view = view;
            this.isDown = false;
          }
          set(isDown) {
            if (this.isDown != isDown) {
              this.isDown = isDown;
              this.view.update([]);
            }
          }
        }, {
          eventObservers: {
            keydown(e) {
              this.set(e.keyCode == code || getter(e));
            },
            keyup(e) {
              if (e.keyCode == code || !getter(e))
                this.set(false);
            },
            mousemove(e) {
              this.set(getter(e));
            }
          }
        });
        return [
          plugin2,
          EditorView.contentAttributes.of((view) => {
            var _a2;
            return ((_a2 = view.plugin(plugin2)) === null || _a2 === void 0 ? void 0 : _a2.isDown) ? showCrosshair : null;
          })
        ];
      }
      var Outside = "-10000px";
      var TooltipViewManager = class {
        constructor(view, facet, createTooltipView) {
          this.facet = facet;
          this.createTooltipView = createTooltipView;
          this.input = view.state.facet(facet);
          this.tooltips = this.input.filter((t) => t);
          this.tooltipViews = this.tooltips.map(createTooltipView);
        }
        update(update, above) {
          var _a2;
          let input = update.state.facet(this.facet);
          let tooltips2 = input.filter((x) => x);
          if (input === this.input) {
            for (let t of this.tooltipViews)
              if (t.update)
                t.update(update);
            return false;
          }
          let tooltipViews = [], newAbove = above ? [] : null;
          for (let i = 0; i < tooltips2.length; i++) {
            let tip = tooltips2[i], known = -1;
            if (!tip)
              continue;
            for (let i2 = 0; i2 < this.tooltips.length; i2++) {
              let other = this.tooltips[i2];
              if (other && other.create == tip.create)
                known = i2;
            }
            if (known < 0) {
              tooltipViews[i] = this.createTooltipView(tip);
              if (newAbove)
                newAbove[i] = !!tip.above;
            } else {
              let tooltipView = tooltipViews[i] = this.tooltipViews[known];
              if (newAbove)
                newAbove[i] = above[known];
              if (tooltipView.update)
                tooltipView.update(update);
            }
          }
          for (let t of this.tooltipViews)
            if (tooltipViews.indexOf(t) < 0) {
              t.dom.remove();
              (_a2 = t.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t);
            }
          if (above) {
            newAbove.forEach((val, i) => above[i] = val);
            above.length = newAbove.length;
          }
          this.input = input;
          this.tooltips = tooltips2;
          this.tooltipViews = tooltipViews;
          return true;
        }
      };
      function tooltips(config = {}) {
        return tooltipConfig.of(config);
      }
      function windowSpace(view) {
        let { win } = view;
        return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth };
      }
      var tooltipConfig = state.Facet.define({
        combine: (values) => {
          var _a2, _b, _c2;
          return {
            position: browser.ios ? "absolute" : ((_a2 = values.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
            parent: ((_b = values.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
            tooltipSpace: ((_c2 = values.find((conf) => conf.tooltipSpace)) === null || _c2 === void 0 ? void 0 : _c2.tooltipSpace) || windowSpace
          };
        }
      });
      var knownHeight = new WeakMap();
      var tooltipPlugin = ViewPlugin.fromClass(class {
        constructor(view) {
          this.view = view;
          this.above = [];
          this.inView = true;
          this.madeAbsolute = false;
          this.lastTransaction = 0;
          this.measureTimeout = -1;
          let config = view.state.facet(tooltipConfig);
          this.position = config.position;
          this.parent = config.parent;
          this.classes = view.themeClasses;
          this.createContainer();
          this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
          this.manager = new TooltipViewManager(view, showTooltip, (t) => this.createTooltip(t));
          this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
            if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
              this.measureSoon();
          }, { threshold: [1] }) : null;
          this.observeIntersection();
          view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
          this.maybeMeasure();
        }
        createContainer() {
          if (this.parent) {
            this.container = document.createElement("div");
            this.container.style.position = "relative";
            this.container.className = this.view.themeClasses;
            this.parent.appendChild(this.container);
          } else {
            this.container = this.view.dom;
          }
        }
        observeIntersection() {
          if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            for (let tooltip of this.manager.tooltipViews)
              this.intersectionObserver.observe(tooltip.dom);
          }
        }
        measureSoon() {
          if (this.measureTimeout < 0)
            this.measureTimeout = setTimeout(() => {
              this.measureTimeout = -1;
              this.maybeMeasure();
            }, 50);
        }
        update(update) {
          if (update.transactions.length)
            this.lastTransaction = Date.now();
          let updated = this.manager.update(update, this.above);
          if (updated)
            this.observeIntersection();
          let shouldMeasure = updated || update.geometryChanged;
          let newConfig = update.state.facet(tooltipConfig);
          if (newConfig.position != this.position && !this.madeAbsolute) {
            this.position = newConfig.position;
            for (let t of this.manager.tooltipViews)
              t.dom.style.position = this.position;
            shouldMeasure = true;
          }
          if (newConfig.parent != this.parent) {
            if (this.parent)
              this.container.remove();
            this.parent = newConfig.parent;
            this.createContainer();
            for (let t of this.manager.tooltipViews)
              this.container.appendChild(t.dom);
            shouldMeasure = true;
          } else if (this.parent && this.view.themeClasses != this.classes) {
            this.classes = this.container.className = this.view.themeClasses;
          }
          if (shouldMeasure)
            this.maybeMeasure();
        }
        createTooltip(tooltip) {
          let tooltipView = tooltip.create(this.view);
          tooltipView.dom.classList.add("cm-tooltip");
          if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
            let arrow = document.createElement("div");
            arrow.className = "cm-tooltip-arrow";
            tooltipView.dom.appendChild(arrow);
          }
          tooltipView.dom.style.position = this.position;
          tooltipView.dom.style.top = Outside;
          tooltipView.dom.style.left = "0px";
          this.container.appendChild(tooltipView.dom);
          if (tooltipView.mount)
            tooltipView.mount(this.view);
          return tooltipView;
        }
        destroy() {
          var _a2, _b;
          this.view.win.removeEventListener("resize", this.measureSoon);
          for (let tooltipView of this.manager.tooltipViews) {
            tooltipView.dom.remove();
            (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
          }
          if (this.parent)
            this.container.remove();
          (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
          clearTimeout(this.measureTimeout);
        }
        readMeasure() {
          let editor = this.view.dom.getBoundingClientRect();
          let scaleX = 1, scaleY = 1, makeAbsolute = false;
          if (this.position == "fixed" && this.manager.tooltipViews.length) {
            let { dom } = this.manager.tooltipViews[0];
            if (browser.gecko) {
              makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
            } else {
              if (this.view.scaleX != 1 || this.view.scaleY != 1) {
                makeAbsolute = true;
              } else if (dom.style.top == Outside && dom.style.left == "0px") {
                let rect = dom.getBoundingClientRect();
                makeAbsolute = Math.abs(rect.top + 1e4) > 1 || Math.abs(rect.left) > 1;
              }
            }
          }
          if (makeAbsolute || this.position == "absolute") {
            if (this.parent) {
              let rect = this.parent.getBoundingClientRect();
              if (rect.width && rect.height) {
                scaleX = rect.width / this.parent.offsetWidth;
                scaleY = rect.height / this.parent.offsetHeight;
              }
            } else {
              ({ scaleX, scaleY } = this.view.viewState);
            }
          }
          return {
            editor,
            parent: this.parent ? this.container.getBoundingClientRect() : editor,
            pos: this.manager.tooltips.map((t, i) => {
              let tv2 = this.manager.tooltipViews[i];
              return tv2.getCoords ? tv2.getCoords(t.pos) : this.view.coordsAtPos(t.pos);
            }),
            size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
            scaleX,
            scaleY,
            makeAbsolute
          };
        }
        writeMeasure(measured) {
          var _a2;
          if (measured.makeAbsolute) {
            this.madeAbsolute = true;
            this.position = "absolute";
            for (let t of this.manager.tooltipViews)
              t.dom.style.position = "absolute";
          }
          let { editor, space, scaleX, scaleY } = measured;
          let others = [];
          for (let i = 0; i < this.manager.tooltips.length; i++) {
            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;
            let pos = measured.pos[i], size = measured.size[i];
            if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - 0.1 || pos.left > Math.min(editor.right, space.right) + 0.1) {
              dom.style.top = Outside;
              continue;
            }
            let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
            let arrowHeight = arrow ? 7 : 0;
            let width = size.right - size.left, height = (_a2 = knownHeight.get(tView)) !== null && _a2 !== void 0 ? _a2 : size.bottom - size.top;
            let offset = tView.offset || noOffset, ltr = this.view.textDirection == exports.Direction.LTR;
            let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow ? 14 : 0) - offset.x);
            let above = this.above[i];
            if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space.top : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top)
              above = this.above[i] = !above;
            let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
            if (spaceVert < height && tView.resize !== false) {
              if (spaceVert < this.view.defaultLineHeight) {
                dom.style.top = Outside;
                continue;
              }
              knownHeight.set(tView, height);
              dom.style.height = (height = spaceVert) / scaleY + "px";
            } else if (dom.style.height) {
              dom.style.height = "";
            }
            let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
            let right = left + width;
            if (tView.overlap !== true) {
              for (let r of others)
                if (r.left < right && r.right > left && r.top < top + height && r.bottom > top)
                  top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
            }
            if (this.position == "absolute") {
              dom.style.top = (top - measured.parent.top) / scaleY + "px";
              dom.style.left = (left - measured.parent.left) / scaleX + "px";
            } else {
              dom.style.top = top / scaleY + "px";
              dom.style.left = left / scaleX + "px";
            }
            if (arrow) {
              let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7);
              arrow.style.left = arrowLeft / scaleX + "px";
            }
            if (tView.overlap !== true)
              others.push({ left, top, right, bottom: top + height });
            dom.classList.toggle("cm-tooltip-above", above);
            dom.classList.toggle("cm-tooltip-below", !above);
            if (tView.positioned)
              tView.positioned(measured.space);
          }
        }
        maybeMeasure() {
          if (this.manager.tooltips.length) {
            if (this.view.inView)
              this.view.requestMeasure(this.measureReq);
            if (this.inView != this.view.inView) {
              this.inView = this.view.inView;
              if (!this.inView)
                for (let tv2 of this.manager.tooltipViews)
                  tv2.dom.style.top = Outside;
            }
          }
        }
      }, {
        eventObservers: {
          scroll() {
            this.maybeMeasure();
          }
        }
      });
      var baseTheme = EditorView.baseTheme({
        ".cm-tooltip": {
          zIndex: 100,
          boxSizing: "border-box"
        },
        "&light .cm-tooltip": {
          border: "1px solid #bbb",
          backgroundColor: "#f5f5f5"
        },
        "&light .cm-tooltip-section:not(:first-child)": {
          borderTop: "1px solid #bbb"
        },
        "&dark .cm-tooltip": {
          backgroundColor: "#333338",
          color: "white"
        },
        ".cm-tooltip-arrow": {
          height: `${7}px`,
          width: `${7 * 2}px`,
          position: "absolute",
          zIndex: -1,
          overflow: "hidden",
          "&:before, &:after": {
            content: "''",
            position: "absolute",
            width: 0,
            height: 0,
            borderLeft: `${7}px solid transparent`,
            borderRight: `${7}px solid transparent`
          },
          ".cm-tooltip-above &": {
            bottom: `-${7}px`,
            "&:before": {
              borderTop: `${7}px solid #bbb`
            },
            "&:after": {
              borderTop: `${7}px solid #f5f5f5`,
              bottom: "1px"
            }
          },
          ".cm-tooltip-below &": {
            top: `-${7}px`,
            "&:before": {
              borderBottom: `${7}px solid #bbb`
            },
            "&:after": {
              borderBottom: `${7}px solid #f5f5f5`,
              top: "1px"
            }
          }
        },
        "&dark .cm-tooltip .cm-tooltip-arrow": {
          "&:before": {
            borderTopColor: "#333338",
            borderBottomColor: "#333338"
          },
          "&:after": {
            borderTopColor: "transparent",
            borderBottomColor: "transparent"
          }
        }
      });
      var noOffset = { x: 0, y: 0 };
      var showTooltip = state.Facet.define({
        enables: [tooltipPlugin, baseTheme]
      });
      var showHoverTooltip = state.Facet.define();
      var HoverTooltipHost = class {
        static create(view) {
          return new HoverTooltipHost(view);
        }
        constructor(view) {
          this.view = view;
          this.mounted = false;
          this.dom = document.createElement("div");
          this.dom.classList.add("cm-tooltip-hover");
          this.manager = new TooltipViewManager(view, showHoverTooltip, (t) => this.createHostedView(t));
        }
        createHostedView(tooltip) {
          let hostedView = tooltip.create(this.view);
          hostedView.dom.classList.add("cm-tooltip-section");
          this.dom.appendChild(hostedView.dom);
          if (this.mounted && hostedView.mount)
            hostedView.mount(this.view);
          return hostedView;
        }
        mount(view) {
          for (let hostedView of this.manager.tooltipViews) {
            if (hostedView.mount)
              hostedView.mount(view);
          }
          this.mounted = true;
        }
        positioned(space) {
          for (let hostedView of this.manager.tooltipViews) {
            if (hostedView.positioned)
              hostedView.positioned(space);
          }
        }
        update(update) {
          this.manager.update(update);
        }
        destroy() {
          var _a2;
          for (let t of this.manager.tooltipViews)
            (_a2 = t.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t);
        }
        passProp(name) {
          let value = void 0;
          for (let view of this.manager.tooltipViews) {
            let given = view[name];
            if (given !== void 0) {
              if (value === void 0)
                value = given;
              else if (value !== given)
                return void 0;
            }
          }
          return value;
        }
        get offset() {
          return this.passProp("offset");
        }
        get getCoords() {
          return this.passProp("getCoords");
        }
        get overlap() {
          return this.passProp("overlap");
        }
        get resize() {
          return this.passProp("resize");
        }
      };
      var showHoverTooltipHost = showTooltip.compute([showHoverTooltip], (state2) => {
        let tooltips2 = state2.facet(showHoverTooltip).filter((t) => t);
        if (tooltips2.length === 0)
          return null;
        return {
          pos: Math.min(...tooltips2.map((t) => t.pos)),
          end: Math.max(...tooltips2.map((t) => {
            var _a2;
            return (_a2 = t.end) !== null && _a2 !== void 0 ? _a2 : t.pos;
          })),
          create: HoverTooltipHost.create,
          above: tooltips2[0].above,
          arrow: tooltips2.some((t) => t.arrow)
        };
      });
      var HoverPlugin = class {
        constructor(view, source, field, setHover, hoverTime) {
          this.view = view;
          this.source = source;
          this.field = field;
          this.setHover = setHover;
          this.hoverTime = hoverTime;
          this.hoverTimeout = -1;
          this.restartTimeout = -1;
          this.pending = null;
          this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
          this.checkHover = this.checkHover.bind(this);
          view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
          view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
        }
        update() {
          if (this.pending) {
            this.pending = null;
            clearTimeout(this.restartTimeout);
            this.restartTimeout = setTimeout(() => this.startHover(), 20);
          }
        }
        get active() {
          return this.view.state.field(this.field);
        }
        checkHover() {
          this.hoverTimeout = -1;
          if (this.active)
            return;
          let hovered = Date.now() - this.lastMove.time;
          if (hovered < this.hoverTime)
            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
          else
            this.startHover();
        }
        startHover() {
          clearTimeout(this.restartTimeout);
          let { view, lastMove } = this;
          let desc = view.docView.nearest(lastMove.target);
          if (!desc)
            return;
          let pos, side = 1;
          if (desc instanceof WidgetView) {
            pos = desc.posAtStart;
          } else {
            pos = view.posAtCoords(lastMove);
            if (pos == null)
              return;
            let posCoords = view.coordsAtPos(pos);
            if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth)
              return;
            let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s) => s.from <= pos && s.to >= pos);
            let rtl = bidi && bidi.dir == exports.Direction.RTL ? -1 : 1;
            side = lastMove.x < posCoords.left ? -rtl : rtl;
          }
          let open = this.source(view, pos, side);
          if (open === null || open === void 0 ? void 0 : open.then) {
            let pending = this.pending = { pos };
            open.then((result) => {
              if (this.pending == pending) {
                this.pending = null;
                if (result)
                  view.dispatch({ effects: this.setHover.of(result) });
              }
            }, (e) => logException(view.state, e, "hover tooltip"));
          } else if (open) {
            view.dispatch({ effects: this.setHover.of(open) });
          }
        }
        get tooltip() {
          let plugin2 = this.view.plugin(tooltipPlugin);
          let index = plugin2 ? plugin2.manager.tooltips.findIndex((t) => t.create == HoverTooltipHost.create) : -1;
          return index > -1 ? plugin2.manager.tooltipViews[index] : null;
        }
        mousemove(event2) {
          var _a2;
          this.lastMove = { x: event2.clientX, y: event2.clientY, target: event2.target, time: Date.now() };
          if (this.hoverTimeout < 0)
            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
          let { active, tooltip } = this;
          if (active && tooltip && !isInTooltip(tooltip.dom, event2) || this.pending) {
            let { pos } = active || this.pending, end = (_a2 = active === null || active === void 0 ? void 0 : active.end) !== null && _a2 !== void 0 ? _a2 : pos;
            if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event2.clientX, event2.clientY)) {
              this.view.dispatch({ effects: this.setHover.of(null) });
              this.pending = null;
            }
          }
        }
        mouseleave(event2) {
          clearTimeout(this.hoverTimeout);
          this.hoverTimeout = -1;
          let { active } = this;
          if (active) {
            let { tooltip } = this;
            let inTooltip = tooltip && tooltip.dom.contains(event2.relatedTarget);
            if (!inTooltip)
              this.view.dispatch({ effects: this.setHover.of(null) });
            else
              this.watchTooltipLeave(tooltip.dom);
          }
        }
        watchTooltipLeave(tooltip) {
          let watch = (event2) => {
            tooltip.removeEventListener("mouseleave", watch);
            if (this.active && !this.view.dom.contains(event2.relatedTarget))
              this.view.dispatch({ effects: this.setHover.of(null) });
          };
          tooltip.addEventListener("mouseleave", watch);
        }
        destroy() {
          clearTimeout(this.hoverTimeout);
          this.view.dom.removeEventListener("mouseleave", this.mouseleave);
          this.view.dom.removeEventListener("mousemove", this.mousemove);
        }
      };
      var tooltipMargin = 4;
      function isInTooltip(tooltip, event2) {
        let rect = tooltip.getBoundingClientRect();
        return event2.clientX >= rect.left - tooltipMargin && event2.clientX <= rect.right + tooltipMargin && event2.clientY >= rect.top - tooltipMargin && event2.clientY <= rect.bottom + tooltipMargin;
      }
      function isOverRange(view, from, to2, x, y2, margin) {
        let rect = view.scrollDOM.getBoundingClientRect();
        let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
        if (rect.left > x || rect.right < x || rect.top > y2 || Math.min(rect.bottom, docBottom) < y2)
          return false;
        let pos = view.posAtCoords({ x, y: y2 }, false);
        return pos >= from && pos <= to2;
      }
      function hoverTooltip(source, options = {}) {
        let setHover = state.StateEffect.define();
        let hoverState = state.StateField.define({
          create() {
            return null;
          },
          update(value, tr2) {
            if (value && (options.hideOnChange && (tr2.docChanged || tr2.selection) || options.hideOn && options.hideOn(tr2, value)))
              return null;
            if (value && tr2.docChanged) {
              let newPos = tr2.changes.mapPos(value.pos, -1, state.MapMode.TrackDel);
              if (newPos == null)
                return null;
              let copy = Object.assign(Object.create(null), value);
              copy.pos = newPos;
              if (value.end != null)
                copy.end = tr2.changes.mapPos(value.end);
              value = copy;
            }
            for (let effect of tr2.effects) {
              if (effect.is(setHover))
                value = effect.value;
              if (effect.is(closeHoverTooltipEffect))
                value = null;
            }
            return value;
          },
          provide: (f) => showHoverTooltip.from(f)
        });
        return [
          hoverState,
          ViewPlugin.define((view) => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300)),
          showHoverTooltipHost
        ];
      }
      function getTooltip(view, tooltip) {
        let plugin2 = view.plugin(tooltipPlugin);
        if (!plugin2)
          return null;
        let found = plugin2.manager.tooltips.indexOf(tooltip);
        return found < 0 ? null : plugin2.manager.tooltipViews[found];
      }
      function hasHoverTooltips(state2) {
        return state2.facet(showHoverTooltip).some((x) => x);
      }
      var closeHoverTooltipEffect = state.StateEffect.define();
      var closeHoverTooltips = closeHoverTooltipEffect.of(null);
      function repositionTooltips(view) {
        let plugin2 = view.plugin(tooltipPlugin);
        if (plugin2)
          plugin2.maybeMeasure();
      }
      var panelConfig = state.Facet.define({
        combine(configs) {
          let topContainer, bottomContainer;
          for (let c2 of configs) {
            topContainer = topContainer || c2.topContainer;
            bottomContainer = bottomContainer || c2.bottomContainer;
          }
          return { topContainer, bottomContainer };
        }
      });
      function panels(config) {
        return config ? [panelConfig.of(config)] : [];
      }
      function getPanel(view, panel) {
        let plugin2 = view.plugin(panelPlugin);
        let index = plugin2 ? plugin2.specs.indexOf(panel) : -1;
        return index > -1 ? plugin2.panels[index] : null;
      }
      var panelPlugin = ViewPlugin.fromClass(class {
        constructor(view) {
          this.input = view.state.facet(showPanel);
          this.specs = this.input.filter((s) => s);
          this.panels = this.specs.map((spec) => spec(view));
          let conf = view.state.facet(panelConfig);
          this.top = new PanelGroup(view, true, conf.topContainer);
          this.bottom = new PanelGroup(view, false, conf.bottomContainer);
          this.top.sync(this.panels.filter((p) => p.top));
          this.bottom.sync(this.panels.filter((p) => !p.top));
          for (let p of this.panels) {
            p.dom.classList.add("cm-panel");
            if (p.mount)
              p.mount();
          }
        }
        update(update) {
          let conf = update.state.facet(panelConfig);
          if (this.top.container != conf.topContainer) {
            this.top.sync([]);
            this.top = new PanelGroup(update.view, true, conf.topContainer);
          }
          if (this.bottom.container != conf.bottomContainer) {
            this.bottom.sync([]);
            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
          }
          this.top.syncClasses();
          this.bottom.syncClasses();
          let input = update.state.facet(showPanel);
          if (input != this.input) {
            let specs = input.filter((x) => x);
            let panels2 = [], top = [], bottom = [], mount = [];
            for (let spec of specs) {
              let known = this.specs.indexOf(spec), panel;
              if (known < 0) {
                panel = spec(update.view);
                mount.push(panel);
              } else {
                panel = this.panels[known];
                if (panel.update)
                  panel.update(update);
              }
              panels2.push(panel);
              (panel.top ? top : bottom).push(panel);
            }
            this.specs = specs;
            this.panels = panels2;
            this.top.sync(top);
            this.bottom.sync(bottom);
            for (let p of mount) {
              p.dom.classList.add("cm-panel");
              if (p.mount)
                p.mount();
            }
          } else {
            for (let p of this.panels)
              if (p.update)
                p.update(update);
          }
        }
        destroy() {
          this.top.sync([]);
          this.bottom.sync([]);
        }
      }, {
        provide: (plugin2) => EditorView.scrollMargins.of((view) => {
          let value = view.plugin(plugin2);
          return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
        })
      });
      var PanelGroup = class {
        constructor(view, top, container) {
          this.view = view;
          this.top = top;
          this.container = container;
          this.dom = void 0;
          this.classes = "";
          this.panels = [];
          this.syncClasses();
        }
        sync(panels2) {
          for (let p of this.panels)
            if (p.destroy && panels2.indexOf(p) < 0)
              p.destroy();
          this.panels = panels2;
          this.syncDOM();
        }
        syncDOM() {
          if (this.panels.length == 0) {
            if (this.dom) {
              this.dom.remove();
              this.dom = void 0;
            }
            return;
          }
          if (!this.dom) {
            this.dom = document.createElement("div");
            this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
            this.dom.style[this.top ? "top" : "bottom"] = "0";
            let parent = this.container || this.view.dom;
            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
          }
          let curDOM = this.dom.firstChild;
          for (let panel of this.panels) {
            if (panel.dom.parentNode == this.dom) {
              while (curDOM != panel.dom)
                curDOM = rm(curDOM);
              curDOM = curDOM.nextSibling;
            } else {
              this.dom.insertBefore(panel.dom, curDOM);
            }
          }
          while (curDOM)
            curDOM = rm(curDOM);
        }
        scrollMargin() {
          return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
        }
        syncClasses() {
          if (!this.container || this.classes == this.view.themeClasses)
            return;
          for (let cls of this.classes.split(" "))
            if (cls)
              this.container.classList.remove(cls);
          for (let cls of (this.classes = this.view.themeClasses).split(" "))
            if (cls)
              this.container.classList.add(cls);
        }
      };
      function rm(node) {
        let next = node.nextSibling;
        node.remove();
        return next;
      }
      var showPanel = state.Facet.define({
        enables: panelPlugin
      });
      var GutterMarker = class extends state.RangeValue {
        compare(other) {
          return this == other || this.constructor == other.constructor && this.eq(other);
        }
        eq(other) {
          return false;
        }
        destroy(dom) {
        }
      };
      GutterMarker.prototype.elementClass = "";
      GutterMarker.prototype.toDOM = void 0;
      GutterMarker.prototype.mapMode = state.MapMode.TrackBefore;
      GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
      GutterMarker.prototype.point = true;
      var gutterLineClass = state.Facet.define();
      var defaults = {
        class: "",
        renderEmptyElements: false,
        elementStyle: "",
        markers: () => state.RangeSet.empty,
        lineMarker: () => null,
        widgetMarker: () => null,
        lineMarkerChange: null,
        initialSpacer: null,
        updateSpacer: null,
        domEventHandlers: {}
      };
      var activeGutters = state.Facet.define();
      function gutter(config) {
        return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];
      }
      var unfixGutters = state.Facet.define({
        combine: (values) => values.some((x) => x)
      });
      function gutters(config) {
        let result = [
          gutterView
        ];
        if (config && config.fixed === false)
          result.push(unfixGutters.of(true));
        return result;
      }
      var gutterView = ViewPlugin.fromClass(class {
        constructor(view) {
          this.view = view;
          this.prevViewport = view.viewport;
          this.dom = document.createElement("div");
          this.dom.className = "cm-gutters";
          this.dom.setAttribute("aria-hidden", "true");
          this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
          this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
          for (let gutter2 of this.gutters)
            this.dom.appendChild(gutter2.dom);
          this.fixed = !view.state.facet(unfixGutters);
          if (this.fixed) {
            this.dom.style.position = "sticky";
          }
          this.syncGutters(false);
          view.scrollDOM.insertBefore(this.dom, view.contentDOM);
        }
        update(update) {
          if (this.updateGutters(update)) {
            let vpA = this.prevViewport, vpB = update.view.viewport;
            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
          }
          if (update.geometryChanged)
            this.dom.style.minHeight = this.view.contentHeight + "px";
          if (this.view.state.facet(unfixGutters) != !this.fixed) {
            this.fixed = !this.fixed;
            this.dom.style.position = this.fixed ? "sticky" : "";
          }
          this.prevViewport = update.view.viewport;
        }
        syncGutters(detach) {
          let after = this.dom.nextSibling;
          if (detach)
            this.dom.remove();
          let lineClasses = state.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
          let classSet = [];
          let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
          for (let line of this.view.viewportLineBlocks) {
            if (classSet.length)
              classSet = [];
            if (Array.isArray(line.type)) {
              let first = true;
              for (let b of line.type) {
                if (b.type == exports.BlockType.Text && first) {
                  advanceCursor(lineClasses, classSet, b.from);
                  for (let cx of contexts)
                    cx.line(this.view, b, classSet);
                  first = false;
                } else if (b.widget) {
                  for (let cx of contexts)
                    cx.widget(this.view, b);
                }
              }
            } else if (line.type == exports.BlockType.Text) {
              advanceCursor(lineClasses, classSet, line.from);
              for (let cx of contexts)
                cx.line(this.view, line, classSet);
            } else if (line.widget) {
              for (let cx of contexts)
                cx.widget(this.view, line);
            }
          }
          for (let cx of contexts)
            cx.finish();
          if (detach)
            this.view.scrollDOM.insertBefore(this.dom, after);
        }
        updateGutters(update) {
          let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);
          let change = update.docChanged || update.heightChanged || update.viewportChanged || !state.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
          if (prev == cur) {
            for (let gutter2 of this.gutters)
              if (gutter2.update(update))
                change = true;
          } else {
            change = true;
            let gutters2 = [];
            for (let conf of cur) {
              let known = prev.indexOf(conf);
              if (known < 0) {
                gutters2.push(new SingleGutterView(this.view, conf));
              } else {
                this.gutters[known].update(update);
                gutters2.push(this.gutters[known]);
              }
            }
            for (let g of this.gutters) {
              g.dom.remove();
              if (gutters2.indexOf(g) < 0)
                g.destroy();
            }
            for (let g of gutters2)
              this.dom.appendChild(g.dom);
            this.gutters = gutters2;
          }
          return change;
        }
        destroy() {
          for (let view of this.gutters)
            view.destroy();
          this.dom.remove();
        }
      }, {
        provide: (plugin2) => EditorView.scrollMargins.of((view) => {
          let value = view.plugin(plugin2);
          if (!value || value.gutters.length == 0 || !value.fixed)
            return null;
          return view.textDirection == exports.Direction.LTR ? { left: value.dom.offsetWidth * view.scaleX } : { right: value.dom.offsetWidth * view.scaleX };
        })
      });
      function asArray(val) {
        return Array.isArray(val) ? val : [val];
      }
      function advanceCursor(cursor, collect, pos) {
        while (cursor.value && cursor.from <= pos) {
          if (cursor.from == pos)
            collect.push(cursor.value);
          cursor.next();
        }
      }
      var UpdateContext = class {
        constructor(gutter2, viewport, height) {
          this.gutter = gutter2;
          this.height = height;
          this.i = 0;
          this.cursor = state.RangeSet.iter(gutter2.markers, viewport.from);
        }
        addElement(view, block, markers) {
          let { gutter: gutter2 } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
          if (this.i == gutter2.elements.length) {
            let newElt = new GutterElement(view, height, above, markers);
            gutter2.elements.push(newElt);
            gutter2.dom.appendChild(newElt.dom);
          } else {
            gutter2.elements[this.i].update(view, height, above, markers);
          }
          this.height = block.bottom;
          this.i++;
        }
        line(view, line, extraMarkers) {
          let localMarkers = [];
          advanceCursor(this.cursor, localMarkers, line.from);
          if (extraMarkers.length)
            localMarkers = localMarkers.concat(extraMarkers);
          let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
          if (forLine)
            localMarkers.unshift(forLine);
          let gutter2 = this.gutter;
          if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
            return;
          this.addElement(view, line, localMarkers);
        }
        widget(view, block) {
          let marker = this.gutter.config.widgetMarker(view, block.widget, block);
          if (marker)
            this.addElement(view, block, [marker]);
        }
        finish() {
          let gutter2 = this.gutter;
          while (gutter2.elements.length > this.i) {
            let last = gutter2.elements.pop();
            gutter2.dom.removeChild(last.dom);
            last.destroy();
          }
        }
      };
      var SingleGutterView = class {
        constructor(view, config) {
          this.view = view;
          this.config = config;
          this.elements = [];
          this.spacer = null;
          this.dom = document.createElement("div");
          this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
          for (let prop in config.domEventHandlers) {
            this.dom.addEventListener(prop, (event2) => {
              let target = event2.target, y2;
              if (target != this.dom && this.dom.contains(target)) {
                while (target.parentNode != this.dom)
                  target = target.parentNode;
                let rect = target.getBoundingClientRect();
                y2 = (rect.top + rect.bottom) / 2;
              } else {
                y2 = event2.clientY;
              }
              let line = view.lineBlockAtHeight(y2 - view.documentTop);
              if (config.domEventHandlers[prop](view, line, event2))
                event2.preventDefault();
            });
          }
          this.markers = asArray(config.markers(view));
          if (config.initialSpacer) {
            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
            this.dom.appendChild(this.spacer.dom);
            this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
          }
        }
        update(update) {
          let prevMarkers = this.markers;
          this.markers = asArray(this.config.markers(update.view));
          if (this.spacer && this.config.updateSpacer) {
            let updated = this.config.updateSpacer(this.spacer.markers[0], update);
            if (updated != this.spacer.markers[0])
              this.spacer.update(update.view, 0, 0, [updated]);
          }
          let vp = update.view.viewport;
          return !state.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
        }
        destroy() {
          for (let elt of this.elements)
            elt.destroy();
        }
      };
      var GutterElement = class {
        constructor(view, height, above, markers) {
          this.height = -1;
          this.above = 0;
          this.markers = [];
          this.dom = document.createElement("div");
          this.dom.className = "cm-gutterElement";
          this.update(view, height, above, markers);
        }
        update(view, height, above, markers) {
          if (this.height != height) {
            this.height = height;
            this.dom.style.height = height + "px";
          }
          if (this.above != above)
            this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
          if (!sameMarkers(this.markers, markers))
            this.setMarkers(view, markers);
        }
        setMarkers(view, markers) {
          let cls = "cm-gutterElement", domPos = this.dom.firstChild;
          for (let iNew = 0, iOld = 0; ; ) {
            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
            if (marker) {
              let c2 = marker.elementClass;
              if (c2)
                cls += " " + c2;
              for (let i = iOld; i < this.markers.length; i++)
                if (this.markers[i].compare(marker)) {
                  skipTo = i;
                  matched = true;
                  break;
                }
            } else {
              skipTo = this.markers.length;
            }
            while (iOld < skipTo) {
              let next = this.markers[iOld++];
              if (next.toDOM) {
                next.destroy(domPos);
                let after = domPos.nextSibling;
                domPos.remove();
                domPos = after;
              }
            }
            if (!marker)
              break;
            if (marker.toDOM) {
              if (matched)
                domPos = domPos.nextSibling;
              else
                this.dom.insertBefore(marker.toDOM(view), domPos);
            }
            if (matched)
              iOld++;
          }
          this.dom.className = cls;
          this.markers = markers;
        }
        destroy() {
          this.setMarkers(null, []);
        }
      };
      function sameMarkers(a, b) {
        if (a.length != b.length)
          return false;
        for (let i = 0; i < a.length; i++)
          if (!a[i].compare(b[i]))
            return false;
        return true;
      }
      var lineNumberMarkers = state.Facet.define();
      var lineNumberConfig = state.Facet.define({
        combine(values) {
          return state.combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
            domEventHandlers(a, b) {
              let result = Object.assign({}, a);
              for (let event2 in b) {
                let exists = result[event2], add = b[event2];
                result[event2] = exists ? (view, line, event3) => exists(view, line, event3) || add(view, line, event3) : add;
              }
              return result;
            }
          });
        }
      });
      var NumberMarker = class extends GutterMarker {
        constructor(number) {
          super();
          this.number = number;
        }
        eq(other) {
          return this.number == other.number;
        }
        toDOM() {
          return document.createTextNode(this.number);
        }
      };
      function formatNumber(view, number) {
        return view.state.facet(lineNumberConfig).formatNumber(number, view.state);
      }
      var lineNumberGutter = activeGutters.compute([lineNumberConfig], (state2) => ({
        class: "cm-lineNumbers",
        renderEmptyElements: false,
        markers(view) {
          return view.state.facet(lineNumberMarkers);
        },
        lineMarker(view, line, others) {
          if (others.some((m) => m.toDOM))
            return null;
          return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
        },
        widgetMarker: () => null,
        lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
        initialSpacer(view) {
          return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
        },
        updateSpacer(spacer, update) {
          let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
          return max == spacer.number ? spacer : new NumberMarker(max);
        },
        domEventHandlers: state2.facet(lineNumberConfig).domEventHandlers
      }));
      function lineNumbers(config = {}) {
        return [
          lineNumberConfig.of(config),
          gutters(),
          lineNumberGutter
        ];
      }
      function maxLineNumber(lines) {
        let last = 9;
        while (last < lines)
          last = last * 10 + 9;
        return last;
      }
      var activeLineGutterMarker = new class extends GutterMarker {
        constructor() {
          super(...arguments);
          this.elementClass = "cm-activeLineGutter";
        }
      }();
      var activeLineGutterHighlighter = gutterLineClass.compute(["selection"], (state$1) => {
        let marks = [], last = -1;
        for (let range of state$1.selection.ranges) {
          let linePos = state$1.doc.lineAt(range.head).from;
          if (linePos > last) {
            last = linePos;
            marks.push(activeLineGutterMarker.range(linePos));
          }
        }
        return state.RangeSet.of(marks);
      });
      function highlightActiveLineGutter() {
        return activeLineGutterHighlighter;
      }
      var WhitespaceDeco = new Map();
      function getWhitespaceDeco(space) {
        let deco = WhitespaceDeco.get(space);
        if (!deco)
          WhitespaceDeco.set(space, deco = Decoration.mark({
            attributes: space === "	" ? {
              class: "cm-highlightTab"
            } : {
              class: "cm-highlightSpace",
              "data-display": space.replace(/ /g, "\xB7")
            }
          }));
        return deco;
      }
      function matcher(decorator) {
        return ViewPlugin.define((view) => ({
          decorations: decorator.createDeco(view),
          update(u) {
            this.decorations = decorator.updateDeco(u, this.decorations);
          }
        }), {
          decorations: (v) => v.decorations
        });
      }
      var whitespaceHighlighter = matcher(new MatchDecorator({
        regexp: /\t| +/g,
        decoration: (match) => getWhitespaceDeco(match[0]),
        boundary: /\S/
      }));
      function highlightWhitespace() {
        return whitespaceHighlighter;
      }
      var trailingHighlighter = matcher(new MatchDecorator({
        regexp: /\s+$/g,
        decoration: Decoration.mark({ class: "cm-trailingSpace" }),
        boundary: /\S/
      }));
      function highlightTrailingWhitespace() {
        return trailingHighlighter;
      }
      var __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType, ChangedRange, computeOrder, moveVisually };
      exports.BidiSpan = BidiSpan;
      exports.BlockInfo = BlockInfo;
      exports.Decoration = Decoration;
      exports.EditorView = EditorView;
      exports.GutterMarker = GutterMarker;
      exports.MatchDecorator = MatchDecorator;
      exports.RectangleMarker = RectangleMarker;
      exports.ViewPlugin = ViewPlugin;
      exports.ViewUpdate = ViewUpdate;
      exports.WidgetType = WidgetType;
      exports.__test = __test;
      exports.closeHoverTooltips = closeHoverTooltips;
      exports.crosshairCursor = crosshairCursor;
      exports.drawSelection = drawSelection;
      exports.dropCursor = dropCursor;
      exports.getDrawSelectionConfig = getDrawSelectionConfig;
      exports.getPanel = getPanel;
      exports.getTooltip = getTooltip;
      exports.gutter = gutter;
      exports.gutterLineClass = gutterLineClass;
      exports.gutters = gutters;
      exports.hasHoverTooltips = hasHoverTooltips;
      exports.highlightActiveLine = highlightActiveLine;
      exports.highlightActiveLineGutter = highlightActiveLineGutter;
      exports.highlightSpecialChars = highlightSpecialChars;
      exports.highlightTrailingWhitespace = highlightTrailingWhitespace;
      exports.highlightWhitespace = highlightWhitespace;
      exports.hoverTooltip = hoverTooltip;
      exports.keymap = keymap;
      exports.layer = layer;
      exports.lineNumberMarkers = lineNumberMarkers;
      exports.lineNumbers = lineNumbers;
      exports.logException = logException;
      exports.panels = panels;
      exports.placeholder = placeholder;
      exports.rectangularSelection = rectangularSelection;
      exports.repositionTooltips = repositionTooltips;
      exports.runScopeHandlers = runScopeHandlers;
      exports.scrollPastEnd = scrollPastEnd;
      exports.showPanel = showPanel;
      exports.showTooltip = showTooltip;
      exports.tooltips = tooltips;
    }
  });

  // node_modules/@lezer/common/dist/index.cjs
  var require_dist3 = __commonJS({
    "node_modules/@lezer/common/dist/index.cjs"(exports) {
      "use strict";
      var DefaultBufferLength = 1024;
      var nextPropID = 0;
      var Range = class {
        constructor(from, to2) {
          this.from = from;
          this.to = to2;
        }
      };
      var NodeProp = class {
        constructor(config = {}) {
          this.id = nextPropID++;
          this.perNode = !!config.perNode;
          this.deserialize = config.deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
          });
        }
        add(match) {
          if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
          if (typeof match != "function")
            match = NodeType.match(match);
          return (type) => {
            let result = match(type);
            return result === void 0 ? null : [this, result];
          };
        }
      };
      NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
      NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
      NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
      NodeProp.contextHash = new NodeProp({ perNode: true });
      NodeProp.lookAhead = new NodeProp({ perNode: true });
      NodeProp.mounted = new NodeProp({ perNode: true });
      var MountedTree = class {
        constructor(tree, overlay, parser) {
          this.tree = tree;
          this.overlay = overlay;
          this.parser = parser;
        }
      };
      var noProps = Object.create(null);
      var NodeType = class {
        constructor(name, props, id, flags = 0) {
          this.name = name;
          this.props = props;
          this.id = id;
          this.flags = flags;
        }
        static define(spec) {
          let props = spec.props && spec.props.length ? Object.create(null) : noProps;
          let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
          let type = new NodeType(spec.name || "", props, spec.id, flags);
          if (spec.props)
            for (let src of spec.props) {
              if (!Array.isArray(src))
                src = src(type);
              if (src) {
                if (src[0].perNode)
                  throw new RangeError("Can't store a per-node prop on a node type");
                props[src[0].id] = src[1];
              }
            }
          return type;
        }
        prop(prop) {
          return this.props[prop.id];
        }
        get isTop() {
          return (this.flags & 1) > 0;
        }
        get isSkipped() {
          return (this.flags & 2) > 0;
        }
        get isError() {
          return (this.flags & 4) > 0;
        }
        get isAnonymous() {
          return (this.flags & 8) > 0;
        }
        is(name) {
          if (typeof name == "string") {
            if (this.name == name)
              return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
          }
          return this.id == name;
        }
        static match(map) {
          let direct = Object.create(null);
          for (let prop in map)
            for (let name of prop.split(" "))
              direct[name] = map[prop];
          return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
              let found = direct[i < 0 ? node.name : groups[i]];
              if (found)
                return found;
            }
          };
        }
      };
      NodeType.none = new NodeType("", Object.create(null), 0, 8);
      var NodeSet = class {
        constructor(types) {
          this.types = types;
          for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
              throw new RangeError("Node type ids should correspond to array positions when creating a node set");
        }
        extend(...props) {
          let newTypes = [];
          for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
              let add = source(type);
              if (add) {
                if (!newProps)
                  newProps = Object.assign({}, type.props);
                newProps[add[0].id] = add[1];
              }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
          }
          return new NodeSet(newTypes);
        }
      };
      var CachedNode = new WeakMap();
      var CachedInnerNode = new WeakMap();
      exports.IterMode = void 0;
      (function(IterMode) {
        IterMode[IterMode["ExcludeBuffers"] = 1] = "ExcludeBuffers";
        IterMode[IterMode["IncludeAnonymous"] = 2] = "IncludeAnonymous";
        IterMode[IterMode["IgnoreMounts"] = 4] = "IgnoreMounts";
        IterMode[IterMode["IgnoreOverlays"] = 8] = "IgnoreOverlays";
      })(exports.IterMode || (exports.IterMode = {}));
      var Tree = class {
        constructor(type, children, positions, length, props) {
          this.type = type;
          this.children = children;
          this.positions = positions;
          this.length = length;
          this.props = null;
          if (props && props.length) {
            this.props = Object.create(null);
            for (let [prop, value] of props)
              this.props[typeof prop == "number" ? prop : prop.id] = value;
          }
        }
        toString() {
          let mounted = this.prop(NodeProp.mounted);
          if (mounted && !mounted.overlay)
            return mounted.tree.toString();
          let children = "";
          for (let ch2 of this.children) {
            let str = ch2.toString();
            if (str) {
              if (children)
                children += ",";
              children += str;
            }
          }
          return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
        }
        cursor(mode = 0) {
          return new TreeCursor(this.topNode, mode);
        }
        cursorAt(pos, side = 0, mode = 0) {
          let scope = CachedNode.get(this) || this.topNode;
          let cursor = new TreeCursor(scope);
          cursor.moveTo(pos, side);
          CachedNode.set(this, cursor._tree);
          return cursor;
        }
        get topNode() {
          return new TreeNode(this, 0, 0, null);
        }
        resolve(pos, side = 0) {
          let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
          CachedNode.set(this, node);
          return node;
        }
        resolveInner(pos, side = 0) {
          let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
          CachedInnerNode.set(this, node);
          return node;
        }
        iterate(spec) {
          let { enter, leave, from = 0, to: to2 = this.length } = spec;
          let mode = spec.mode || 0, anon = (mode & exports.IterMode.IncludeAnonymous) > 0;
          for (let c2 = this.cursor(mode | exports.IterMode.IncludeAnonymous); ; ) {
            let entered = false;
            if (c2.from <= to2 && c2.to >= from && (!anon && c2.type.isAnonymous || enter(c2) !== false)) {
              if (c2.firstChild())
                continue;
              entered = true;
            }
            for (; ; ) {
              if (entered && leave && (anon || !c2.type.isAnonymous))
                leave(c2);
              if (c2.nextSibling())
                break;
              if (!c2.parent())
                return;
              entered = true;
            }
          }
        }
        prop(prop) {
          return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
        }
        get propValues() {
          let result = [];
          if (this.props)
            for (let id in this.props)
              result.push([+id, this.props[id]]);
          return result;
        }
        balance(config = {}) {
          return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
        }
        static build(data) {
          return buildTree(data);
        }
      };
      Tree.empty = new Tree(NodeType.none, [], [], 0);
      var FlatBufferCursor = class {
        constructor(buffer, index) {
          this.buffer = buffer;
          this.index = index;
        }
        get id() {
          return this.buffer[this.index - 4];
        }
        get start() {
          return this.buffer[this.index - 3];
        }
        get end() {
          return this.buffer[this.index - 2];
        }
        get size() {
          return this.buffer[this.index - 1];
        }
        get pos() {
          return this.index;
        }
        next() {
          this.index -= 4;
        }
        fork() {
          return new FlatBufferCursor(this.buffer, this.index);
        }
      };
      var TreeBuffer = class {
        constructor(buffer, length, set) {
          this.buffer = buffer;
          this.length = length;
          this.set = set;
        }
        get type() {
          return NodeType.none;
        }
        toString() {
          let result = [];
          for (let index = 0; index < this.buffer.length; ) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
          }
          return result.join(",");
        }
        childString(index) {
          let id = this.buffer[index], endIndex = this.buffer[index + 3];
          let type = this.set.types[id], result = type.name;
          if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
          index += 4;
          if (endIndex == index)
            return result;
          let children = [];
          while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
          }
          return result + "(" + children.join(",") + ")";
        }
        findChild(startIndex, endIndex, dir, pos, side) {
          let { buffer } = this, pick = -1;
          for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
              pick = i;
              if (dir > 0)
                break;
            }
          }
          return pick;
        }
        slice(startI, endI, from) {
          let b = this.buffer;
          let copy = new Uint16Array(endI - startI), len = 0;
          for (let i = startI, j2 = 0; i < endI; ) {
            copy[j2++] = b[i++];
            copy[j2++] = b[i++] - from;
            let to2 = copy[j2++] = b[i++] - from;
            copy[j2++] = b[i++] - startI;
            len = Math.max(len, to2);
          }
          return new TreeBuffer(copy, len, this.set);
        }
      };
      function checkSide(side, pos, from, to2) {
        switch (side) {
          case -2:
            return from < pos;
          case -1:
            return to2 >= pos && from < pos;
          case 0:
            return from < pos && to2 > pos;
          case 1:
            return from <= pos && to2 > pos;
          case 2:
            return to2 > pos;
          case 4:
            return true;
        }
      }
      function enterUnfinishedNodesBefore(node, pos) {
        let scan = node.childBefore(pos);
        while (scan) {
          let last = scan.lastChild;
          if (!last || last.to != scan.to)
            break;
          if (last.type.isError && last.from == last.to) {
            node = scan;
            scan = last.prevSibling;
          } else {
            scan = last;
          }
        }
        return node;
      }
      function resolveNode(node, pos, side, overlays) {
        var _a2;
        while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
          let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
          if (!parent)
            return node;
          node = parent;
        }
        let mode = overlays ? 0 : exports.IterMode.IgnoreOverlays;
        if (overlays)
          for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
            if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
              node = parent;
          }
        for (; ; ) {
          let inner = node.enter(pos, side, mode);
          if (!inner)
            return node;
          node = inner;
        }
      }
      var TreeNode = class {
        constructor(_tree, from, index, _parent) {
          this._tree = _tree;
          this.from = from;
          this.index = index;
          this._parent = _parent;
        }
        get type() {
          return this._tree.type;
        }
        get name() {
          return this._tree.type.name;
        }
        get to() {
          return this.from + this._tree.length;
        }
        nextChild(i, dir, pos, side, mode = 0) {
          for (let parent = this; ; ) {
            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
              let next = children[i], start = positions[i] + parent.from;
              if (!checkSide(side, pos, start, start + next.length))
                continue;
              if (next instanceof TreeBuffer) {
                if (mode & exports.IterMode.ExcludeBuffers)
                  continue;
                let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                if (index > -1)
                  return new BufferNode(new BufferContext(parent, next, i, start), null, index);
              } else if (mode & exports.IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
                let mounted;
                if (!(mode & exports.IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
                  return new TreeNode(mounted.tree, start, i, parent);
                let inner = new TreeNode(next, start, i, parent);
                return mode & exports.IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
              }
            }
            if (mode & exports.IterMode.IncludeAnonymous || !parent.type.isAnonymous)
              return null;
            if (parent.index >= 0)
              i = parent.index + dir;
            else
              i = dir < 0 ? -1 : parent._parent._tree.children.length;
            parent = parent._parent;
            if (!parent)
              return null;
          }
        }
        get firstChild() {
          return this.nextChild(0, 1, 0, 4);
        }
        get lastChild() {
          return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
        }
        childAfter(pos) {
          return this.nextChild(0, 1, pos, 2);
        }
        childBefore(pos) {
          return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
        }
        enter(pos, side, mode = 0) {
          let mounted;
          if (!(mode & exports.IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
            let rPos = pos - this.from;
            for (let { from, to: to2 } of mounted.overlay) {
              if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to2 >= rPos : to2 > rPos))
                return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
            }
          }
          return this.nextChild(0, 1, pos, side, mode);
        }
        nextSignificantParent() {
          let val = this;
          while (val.type.isAnonymous && val._parent)
            val = val._parent;
          return val;
        }
        get parent() {
          return this._parent ? this._parent.nextSignificantParent() : null;
        }
        get nextSibling() {
          return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
        }
        get prevSibling() {
          return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
        }
        cursor(mode = 0) {
          return new TreeCursor(this, mode);
        }
        get tree() {
          return this._tree;
        }
        toTree() {
          return this._tree;
        }
        resolve(pos, side = 0) {
          return resolveNode(this, pos, side, false);
        }
        resolveInner(pos, side = 0) {
          return resolveNode(this, pos, side, true);
        }
        enterUnfinishedNodesBefore(pos) {
          return enterUnfinishedNodesBefore(this, pos);
        }
        getChild(type, before = null, after = null) {
          let r = getChildren(this, type, before, after);
          return r.length ? r[0] : null;
        }
        getChildren(type, before = null, after = null) {
          return getChildren(this, type, before, after);
        }
        toString() {
          return this._tree.toString();
        }
        get node() {
          return this;
        }
        matchContext(context) {
          return matchNodeContext(this, context);
        }
      };
      function getChildren(node, type, before, after) {
        let cur = node.cursor(), result = [];
        if (!cur.firstChild())
          return result;
        if (before != null) {
          while (!cur.type.is(before))
            if (!cur.nextSibling())
              return result;
        }
        for (; ; ) {
          if (after != null && cur.type.is(after))
            return result;
          if (cur.type.is(type))
            result.push(cur.node);
          if (!cur.nextSibling())
            return after == null ? result : [];
        }
      }
      function matchNodeContext(node, context, i = context.length - 1) {
        for (let p = node.parent; i >= 0; p = p.parent) {
          if (!p)
            return false;
          if (!p.type.isAnonymous) {
            if (context[i] && context[i] != p.name)
              return false;
            i--;
          }
        }
        return true;
      }
      var BufferContext = class {
        constructor(parent, buffer, index, start) {
          this.parent = parent;
          this.buffer = buffer;
          this.index = index;
          this.start = start;
        }
      };
      var BufferNode = class {
        get name() {
          return this.type.name;
        }
        get from() {
          return this.context.start + this.context.buffer.buffer[this.index + 1];
        }
        get to() {
          return this.context.start + this.context.buffer.buffer[this.index + 2];
        }
        constructor(context, _parent, index) {
          this.context = context;
          this._parent = _parent;
          this.index = index;
          this.type = context.buffer.set.types[context.buffer.buffer[index]];
        }
        child(dir, pos, side) {
          let { buffer } = this.context;
          let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
          return index < 0 ? null : new BufferNode(this.context, this, index);
        }
        get firstChild() {
          return this.child(1, 0, 4);
        }
        get lastChild() {
          return this.child(-1, 0, 4);
        }
        childAfter(pos) {
          return this.child(1, pos, 2);
        }
        childBefore(pos) {
          return this.child(-1, pos, -2);
        }
        enter(pos, side, mode = 0) {
          if (mode & exports.IterMode.ExcludeBuffers)
            return null;
          let { buffer } = this.context;
          let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
          return index < 0 ? null : new BufferNode(this.context, this, index);
        }
        get parent() {
          return this._parent || this.context.parent.nextSignificantParent();
        }
        externalSibling(dir) {
          return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
        }
        get nextSibling() {
          let { buffer } = this.context;
          let after = buffer.buffer[this.index + 3];
          if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
          return this.externalSibling(1);
        }
        get prevSibling() {
          let { buffer } = this.context;
          let parentStart = this._parent ? this._parent.index + 4 : 0;
          if (this.index == parentStart)
            return this.externalSibling(-1);
          return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
        }
        cursor(mode = 0) {
          return new TreeCursor(this, mode);
        }
        get tree() {
          return null;
        }
        toTree() {
          let children = [], positions = [];
          let { buffer } = this.context;
          let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
          if (endI > startI) {
            let from = buffer.buffer[this.index + 1];
            children.push(buffer.slice(startI, endI, from));
            positions.push(0);
          }
          return new Tree(this.type, children, positions, this.to - this.from);
        }
        resolve(pos, side = 0) {
          return resolveNode(this, pos, side, false);
        }
        resolveInner(pos, side = 0) {
          return resolveNode(this, pos, side, true);
        }
        enterUnfinishedNodesBefore(pos) {
          return enterUnfinishedNodesBefore(this, pos);
        }
        toString() {
          return this.context.buffer.childString(this.index);
        }
        getChild(type, before = null, after = null) {
          let r = getChildren(this, type, before, after);
          return r.length ? r[0] : null;
        }
        getChildren(type, before = null, after = null) {
          return getChildren(this, type, before, after);
        }
        get node() {
          return this;
        }
        matchContext(context) {
          return matchNodeContext(this, context);
        }
      };
      var TreeCursor = class {
        get name() {
          return this.type.name;
        }
        constructor(node, mode = 0) {
          this.mode = mode;
          this.buffer = null;
          this.stack = [];
          this.index = 0;
          this.bufferNode = null;
          if (node instanceof TreeNode) {
            this.yieldNode(node);
          } else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
              this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
          }
        }
        yieldNode(node) {
          if (!node)
            return false;
          this._tree = node;
          this.type = node.type;
          this.from = node.from;
          this.to = node.to;
          return true;
        }
        yieldBuf(index, type) {
          this.index = index;
          let { start, buffer } = this.buffer;
          this.type = type || buffer.set.types[buffer.buffer[index]];
          this.from = start + buffer.buffer[index + 1];
          this.to = start + buffer.buffer[index + 2];
          return true;
        }
        yield(node) {
          if (!node)
            return false;
          if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
          }
          this.buffer = node.context;
          return this.yieldBuf(node.index, node.type);
        }
        toString() {
          return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
        }
        enterChild(dir, pos, side) {
          if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
          let { buffer } = this.buffer;
          let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
          if (index < 0)
            return false;
          this.stack.push(this.index);
          return this.yieldBuf(index);
        }
        firstChild() {
          return this.enterChild(1, 0, 4);
        }
        lastChild() {
          return this.enterChild(-1, 0, 4);
        }
        childAfter(pos) {
          return this.enterChild(1, pos, 2);
        }
        childBefore(pos) {
          return this.enterChild(-1, pos, -2);
        }
        enter(pos, side, mode = this.mode) {
          if (!this.buffer)
            return this.yield(this._tree.enter(pos, side, mode));
          return mode & exports.IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
        }
        parent() {
          if (!this.buffer)
            return this.yieldNode(this.mode & exports.IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
          if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
          let parent = this.mode & exports.IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
          this.buffer = null;
          return this.yieldNode(parent);
        }
        sibling(dir) {
          if (!this.buffer)
            return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
          let { buffer } = this.buffer, d2 = this.stack.length - 1;
          if (dir < 0) {
            let parentStart = d2 < 0 ? 0 : this.stack[d2] + 4;
            if (this.index != parentStart)
              return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
          } else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d2 < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d2] + 3]))
              return this.yieldBuf(after);
          }
          return d2 < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
        }
        nextSibling() {
          return this.sibling(1);
        }
        prevSibling() {
          return this.sibling(-1);
        }
        atLastNode(dir) {
          let index, parent, { buffer } = this;
          if (buffer) {
            if (dir > 0) {
              if (this.index < buffer.buffer.buffer.length)
                return false;
            } else {
              for (let i = 0; i < this.index; i++)
                if (buffer.buffer.buffer[i + 3] < this.index)
                  return false;
            }
            ({ index, parent } = buffer);
          } else {
            ({ index, _parent: parent } = this._tree);
          }
          for (; parent; { index, _parent: parent } = parent) {
            if (index > -1)
              for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
                let child = parent._tree.children[i];
                if (this.mode & exports.IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
                  return false;
              }
          }
          return true;
        }
        move(dir, enter) {
          if (enter && this.enterChild(dir, 0, 4))
            return true;
          for (; ; ) {
            if (this.sibling(dir))
              return true;
            if (this.atLastNode(dir) || !this.parent())
              return false;
          }
        }
        next(enter = true) {
          return this.move(1, enter);
        }
        prev(enter = true) {
          return this.move(-1, enter);
        }
        moveTo(pos, side = 0) {
          while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
              break;
          while (this.enterChild(1, pos, side)) {
          }
          return this;
        }
        get node() {
          if (!this.buffer)
            return this._tree;
          let cache = this.bufferNode, result = null, depth = 0;
          if (cache && cache.context == this.buffer) {
            scan:
              for (let index = this.index, d2 = this.stack.length; d2 >= 0; ) {
                for (let c2 = cache; c2; c2 = c2._parent)
                  if (c2.index == index) {
                    if (index == this.index)
                      return c2;
                    result = c2;
                    depth = d2 + 1;
                    break scan;
                  }
                index = this.stack[--d2];
              }
          }
          for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
          return this.bufferNode = new BufferNode(this.buffer, result, this.index);
        }
        get tree() {
          return this.buffer ? null : this._tree._tree;
        }
        iterate(enter, leave) {
          for (let depth = 0; ; ) {
            let mustLeave = false;
            if (this.type.isAnonymous || enter(this) !== false) {
              if (this.firstChild()) {
                depth++;
                continue;
              }
              if (!this.type.isAnonymous)
                mustLeave = true;
            }
            for (; ; ) {
              if (mustLeave && leave)
                leave(this);
              mustLeave = this.type.isAnonymous;
              if (this.nextSibling())
                break;
              if (!depth)
                return;
              this.parent();
              depth--;
              mustLeave = true;
            }
          }
        }
        matchContext(context) {
          if (!this.buffer)
            return matchNodeContext(this.node, context);
          let { buffer } = this.buffer, { types } = buffer.set;
          for (let i = context.length - 1, d2 = this.stack.length - 1; i >= 0; d2--) {
            if (d2 < 0)
              return matchNodeContext(this.node, context, i);
            let type = types[buffer.buffer[this.stack[d2]]];
            if (!type.isAnonymous) {
              if (context[i] && context[i] != type.name)
                return false;
              i--;
            }
          }
          return true;
        }
      };
      function hasChild(tree) {
        return tree.children.some((ch2) => ch2 instanceof TreeBuffer || !ch2.type.isAnonymous || hasChild(ch2));
      }
      function buildTree(data) {
        var _a2;
        let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
        let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
        let types = nodeSet.types;
        let contextHash = 0, lookAhead = 0;
        function takeNode(parentStart, minPos, children2, positions2, inRepeat) {
          let { id, start, end, size } = cursor;
          let lookAheadAtStart = lookAhead;
          while (size < 0) {
            cursor.next();
            if (size == -1) {
              let node2 = reused[id];
              children2.push(node2);
              positions2.push(start - parentStart);
              return;
            } else if (size == -3) {
              contextHash = id;
              return;
            } else if (size == -4) {
              lookAhead = id;
              return;
            } else {
              throw new RangeError(`Unrecognized record size: ${size}`);
            }
          }
          let type = types[id], node, buffer2;
          let startPos = start - parentStart;
          if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
            let data2 = new Uint16Array(buffer2.size - buffer2.skip);
            let endPos = cursor.pos - buffer2.size, index = data2.length;
            while (cursor.pos > endPos)
              index = copyToBuffer(buffer2.start, data2, index);
            node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
            startPos = buffer2.start - parentStart;
          } else {
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            let lastGroup = 0, lastEnd = end;
            while (cursor.pos > endPos) {
              if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                if (cursor.end <= lastEnd - maxBufferLength) {
                  makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
                  lastGroup = localChildren.length;
                  lastEnd = cursor.end;
                }
                cursor.next();
              } else {
                takeNode(start, endPos, localChildren, localPositions, localInRepeat);
              }
            }
            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
              makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && lastGroup > 0) {
              let make = makeBalanced(type);
              node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
            } else {
              node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
            }
          }
          children2.push(node);
          positions2.push(startPos);
        }
        function makeBalanced(type) {
          return (children2, positions2, length2) => {
            let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
            if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
              if (!lastI && last.type == type && last.length == length2)
                return last;
              if (lookAheadProp = last.prop(NodeProp.lookAhead))
                lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
            }
            return makeTree(type, children2, positions2, length2, lookAhead2);
          };
        }
        function makeRepeatLeaf(children2, positions2, base, i, from, to2, type, lookAhead2) {
          let localChildren = [], localPositions = [];
          while (children2.length > i) {
            localChildren.push(children2.pop());
            localPositions.push(positions2.pop() + base - from);
          }
          children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to2 - from, lookAhead2 - to2));
          positions2.push(from - base);
        }
        function makeTree(type, children2, positions2, length2, lookAhead2 = 0, props) {
          if (contextHash) {
            let pair = [NodeProp.contextHash, contextHash];
            props = props ? [pair].concat(props) : [pair];
          }
          if (lookAhead2 > 25) {
            let pair = [NodeProp.lookAhead, lookAhead2];
            props = props ? [pair].concat(props) : [pair];
          }
          return new Tree(type, children2, positions2, length2, props);
        }
        function findBufferSize(maxSize, inRepeat) {
          let fork = cursor.fork();
          let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
          let result = { size: 0, start: 0, skip: 0 };
          scan:
            for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
              let nodeSize2 = fork.size;
              if (fork.id == inRepeat && nodeSize2 >= 0) {
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
              }
              let startPos = fork.pos - nodeSize2;
              if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
                break;
              let localSkipped = fork.id >= minRepeatType ? 4 : 0;
              let nodeStart = fork.start;
              fork.next();
              while (fork.pos > startPos) {
                if (fork.size < 0) {
                  if (fork.size == -3)
                    localSkipped += 4;
                  else
                    break scan;
                } else if (fork.id >= minRepeatType) {
                  localSkipped += 4;
                }
                fork.next();
              }
              start = nodeStart;
              size += nodeSize2;
              skip += localSkipped;
            }
          if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
          }
          return result.size > 4 ? result : void 0;
        }
        function copyToBuffer(bufferStart, buffer2, index) {
          let { id, start, end, size } = cursor;
          cursor.next();
          if (size >= 0 && id < minRepeatType) {
            let startIndex = index;
            if (size > 4) {
              let endPos = cursor.pos - (size - 4);
              while (cursor.pos > endPos)
                index = copyToBuffer(bufferStart, buffer2, index);
            }
            buffer2[--index] = startIndex;
            buffer2[--index] = end - bufferStart;
            buffer2[--index] = start - bufferStart;
            buffer2[--index] = id;
          } else if (size == -3) {
            contextHash = id;
          } else if (size == -4) {
            lookAhead = id;
          }
          return index;
        }
        let children = [], positions = [];
        while (cursor.pos > 0)
          takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
        let length = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
        return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
      }
      var nodeSizeCache = new WeakMap();
      function nodeSize(balanceType, node) {
        if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
          return 1;
        let size = nodeSizeCache.get(node);
        if (size == null) {
          size = 1;
          for (let child of node.children) {
            if (child.type != balanceType || !(child instanceof Tree)) {
              size = 1;
              break;
            }
            size += nodeSize(balanceType, child);
          }
          nodeSizeCache.set(node, size);
        }
        return size;
      }
      function balanceRange(balanceType, children, positions, from, to2, start, length, mkTop, mkTree) {
        let total = 0;
        for (let i = from; i < to2; i++)
          total += nodeSize(balanceType, children[i]);
        let maxChild = Math.ceil(total * 1.5 / 8);
        let localChildren = [], localPositions = [];
        function divide(children2, positions2, from2, to3, offset) {
          for (let i = from2; i < to3; ) {
            let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
            i++;
            for (; i < to3; i++) {
              let nextSize = nodeSize(balanceType, children2[i]);
              if (groupSize + nextSize >= maxChild)
                break;
              groupSize += nextSize;
            }
            if (i == groupFrom + 1) {
              if (groupSize > maxChild) {
                let only = children2[groupFrom];
                divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
                continue;
              }
              localChildren.push(children2[groupFrom]);
            } else {
              let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
              localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
            }
            localPositions.push(groupStart + offset - start);
          }
        }
        divide(children, positions, from, to2, 0);
        return (mkTop || mkTree)(localChildren, localPositions, length);
      }
      var NodeWeakMap = class {
        constructor() {
          this.map = new WeakMap();
        }
        setBuffer(buffer, index, value) {
          let inner = this.map.get(buffer);
          if (!inner)
            this.map.set(buffer, inner = new Map());
          inner.set(index, value);
        }
        getBuffer(buffer, index) {
          let inner = this.map.get(buffer);
          return inner && inner.get(index);
        }
        set(node, value) {
          if (node instanceof BufferNode)
            this.setBuffer(node.context.buffer, node.index, value);
          else if (node instanceof TreeNode)
            this.map.set(node.tree, value);
        }
        get(node) {
          return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : void 0;
        }
        cursorSet(cursor, value) {
          if (cursor.buffer)
            this.setBuffer(cursor.buffer.buffer, cursor.index, value);
          else
            this.map.set(cursor.tree, value);
        }
        cursorGet(cursor) {
          return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
        }
      };
      var TreeFragment = class {
        constructor(from, to2, tree, offset, openStart = false, openEnd = false) {
          this.from = from;
          this.to = to2;
          this.tree = tree;
          this.offset = offset;
          this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
        }
        get openStart() {
          return (this.open & 1) > 0;
        }
        get openEnd() {
          return (this.open & 2) > 0;
        }
        static addTree(tree, fragments = [], partial = false) {
          let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
          for (let f of fragments)
            if (f.to > tree.length)
              result.push(f);
          return result;
        }
        static applyChanges(fragments, changes, minGap = 128) {
          if (!changes.length)
            return fragments;
          let result = [];
          let fI = 1, nextF = fragments.length ? fragments[0] : null;
          for (let cI = 0, pos = 0, off = 0; ; cI++) {
            let nextC = cI < changes.length ? changes[cI] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
              while (nextF && nextF.from < nextPos) {
                let cut = nextF;
                if (pos >= cut.from || nextPos <= cut.to || off) {
                  let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                  cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                }
                if (cut)
                  result.push(cut);
                if (nextF.to > nextPos)
                  break;
                nextF = fI < fragments.length ? fragments[fI++] : null;
              }
            if (!nextC)
              break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
          }
          return result;
        }
      };
      var Parser = class {
        startParse(input, fragments, ranges) {
          if (typeof input == "string")
            input = new StringInput(input);
          ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map((r) => new Range(r.from, r.to)) : [new Range(0, 0)];
          return this.createParse(input, fragments || [], ranges);
        }
        parse(input, fragments, ranges) {
          let parse = this.startParse(input, fragments, ranges);
          for (; ; ) {
            let done = parse.advance();
            if (done)
              return done;
          }
        }
      };
      var StringInput = class {
        constructor(string) {
          this.string = string;
        }
        get length() {
          return this.string.length;
        }
        chunk(from) {
          return this.string.slice(from);
        }
        get lineChunks() {
          return false;
        }
        read(from, to2) {
          return this.string.slice(from, to2);
        }
      };
      function parseMixed(nest) {
        return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
      }
      var InnerParse = class {
        constructor(parser, parse, overlay, target, ranges) {
          this.parser = parser;
          this.parse = parse;
          this.overlay = overlay;
          this.target = target;
          this.ranges = ranges;
          if (!ranges.length || ranges.some((r) => r.from >= r.to))
            throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(ranges));
        }
      };
      var ActiveOverlay = class {
        constructor(parser, predicate, mounts, index, start, target, prev) {
          this.parser = parser;
          this.predicate = predicate;
          this.mounts = mounts;
          this.index = index;
          this.start = start;
          this.target = target;
          this.prev = prev;
          this.depth = 0;
          this.ranges = [];
        }
      };
      var stoppedInner = new NodeProp({ perNode: true });
      var MixedParse = class {
        constructor(base, nest, input, fragments, ranges) {
          this.nest = nest;
          this.input = input;
          this.fragments = fragments;
          this.ranges = ranges;
          this.inner = [];
          this.innerDone = 0;
          this.baseTree = null;
          this.stoppedAt = null;
          this.baseParse = base;
        }
        advance() {
          if (this.baseParse) {
            let done2 = this.baseParse.advance();
            if (!done2)
              return null;
            this.baseParse = null;
            this.baseTree = done2;
            this.startInner();
            if (this.stoppedAt != null)
              for (let inner2 of this.inner)
                inner2.parse.stopAt(this.stoppedAt);
          }
          if (this.innerDone == this.inner.length) {
            let result = this.baseTree;
            if (this.stoppedAt != null)
              result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
            return result;
          }
          let inner = this.inner[this.innerDone], done = inner.parse.advance();
          if (done) {
            this.innerDone++;
            let props = Object.assign(Object.create(null), inner.target.props);
            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
            inner.target.props = props;
          }
          return null;
        }
        get parsedPos() {
          if (this.baseParse)
            return 0;
          let pos = this.input.length;
          for (let i = this.innerDone; i < this.inner.length; i++) {
            if (this.inner[i].ranges[0].from < pos)
              pos = Math.min(pos, this.inner[i].parse.parsedPos);
          }
          return pos;
        }
        stopAt(pos) {
          this.stoppedAt = pos;
          if (this.baseParse)
            this.baseParse.stopAt(pos);
          else
            for (let i = this.innerDone; i < this.inner.length; i++)
              this.inner[i].parse.stopAt(pos);
        }
        startInner() {
          let fragmentCursor = new FragmentCursor(this.fragments);
          let overlay = null;
          let covered = null;
          let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), exports.IterMode.IncludeAnonymous | exports.IterMode.IgnoreMounts);
          scan:
            for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt; ) {
              let enter = true, range;
              if (fragmentCursor.hasNode(cursor)) {
                if (overlay) {
                  let match = overlay.mounts.find((m) => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
                  if (match)
                    for (let r of match.mount.overlay) {
                      let from = r.from + match.pos, to2 = r.to + match.pos;
                      if (from >= cursor.from && to2 <= cursor.to && !overlay.ranges.some((r2) => r2.from < to2 && r2.to > from))
                        overlay.ranges.push({ from, to: to2 });
                    }
                }
                enter = false;
              } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
                enter = isCovered != 2;
              } else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {
                if (!cursor.tree)
                  materialize(cursor);
                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
                if (typeof nest.overlay == "function") {
                  overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
                } else {
                  let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);
                  if (ranges.length)
                    this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map((r) => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));
                  if (!nest.overlay)
                    enter = false;
                  else if (ranges.length)
                    covered = { ranges, depth: 0, prev: covered };
                }
              } else if (overlay && (range = overlay.predicate(cursor))) {
                if (range === true)
                  range = new Range(cursor.from, cursor.to);
                if (range.from < range.to)
                  overlay.ranges.push(range);
              }
              if (enter && cursor.firstChild()) {
                if (overlay)
                  overlay.depth++;
                if (covered)
                  covered.depth++;
              } else {
                for (; ; ) {
                  if (cursor.nextSibling())
                    break;
                  if (!cursor.parent())
                    break scan;
                  if (overlay && !--overlay.depth) {
                    let ranges = punchRanges(this.ranges, overlay.ranges);
                    if (ranges.length)
                      this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r) => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));
                    overlay = overlay.prev;
                  }
                  if (covered && !--covered.depth)
                    covered = covered.prev;
                }
              }
            }
        }
      };
      function checkCover(covered, from, to2) {
        for (let range of covered) {
          if (range.from >= to2)
            break;
          if (range.to > from)
            return range.from <= from && range.to >= to2 ? 2 : 1;
        }
        return 0;
      }
      function sliceBuf(buf, startI, endI, nodes, positions, off) {
        if (startI < endI) {
          let from = buf.buffer[startI + 1];
          nodes.push(buf.slice(startI, endI, from));
          positions.push(from - off);
        }
      }
      function materialize(cursor) {
        let { node } = cursor, depth = 0;
        do {
          cursor.parent();
          depth++;
        } while (!cursor.tree);
        let i = 0, base = cursor.tree, off = 0;
        for (; ; i++) {
          off = base.positions[i] + cursor.from;
          if (off <= node.from && off + base.children[i].length >= node.to)
            break;
        }
        let buf = base.children[i], b = buf.buffer;
        function split(startI, endI, type, innerOffset, length) {
          let i2 = startI;
          while (b[i2 + 2] + off <= node.from)
            i2 = b[i2 + 3];
          let children = [], positions = [];
          sliceBuf(buf, startI, i2, children, positions, innerOffset);
          let from = b[i2 + 1], to2 = b[i2 + 2];
          let isTarget = from + off == node.from && to2 + off == node.to && b[i2] == node.type.id;
          children.push(isTarget ? node.toTree() : split(i2 + 4, b[i2 + 3], buf.set.types[b[i2]], from, to2 - from));
          positions.push(from - innerOffset);
          sliceBuf(buf, b[i2 + 3], endI, children, positions, innerOffset);
          return new Tree(type, children, positions, length);
        }
        base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);
        for (let d2 = 0; d2 <= depth; d2++)
          cursor.childAfter(node.from);
      }
      var StructureCursor = class {
        constructor(root, offset) {
          this.offset = offset;
          this.done = false;
          this.cursor = root.cursor(exports.IterMode.IncludeAnonymous | exports.IterMode.IgnoreMounts);
        }
        moveTo(pos) {
          let { cursor } = this, p = pos - this.offset;
          while (!this.done && cursor.from < p) {
            if (cursor.to >= pos && cursor.enter(p, 1, exports.IterMode.IgnoreOverlays | exports.IterMode.ExcludeBuffers))
              ;
            else if (!cursor.next(false))
              this.done = true;
          }
        }
        hasNode(cursor) {
          this.moveTo(cursor.from);
          if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
            for (let tree = this.cursor.tree; ; ) {
              if (tree == cursor.tree)
                return true;
              if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
                tree = tree.children[0];
              else
                break;
            }
          }
          return false;
        }
      };
      var FragmentCursor = class {
        constructor(fragments) {
          var _a2;
          this.fragments = fragments;
          this.curTo = 0;
          this.fragI = 0;
          if (fragments.length) {
            let first = this.curFrag = fragments[0];
            this.curTo = (_a2 = first.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : first.to;
            this.inner = new StructureCursor(first.tree, -first.offset);
          } else {
            this.curFrag = this.inner = null;
          }
        }
        hasNode(node) {
          while (this.curFrag && node.from >= this.curTo)
            this.nextFrag();
          return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
        }
        nextFrag() {
          var _a2;
          this.fragI++;
          if (this.fragI == this.fragments.length) {
            this.curFrag = this.inner = null;
          } else {
            let frag = this.curFrag = this.fragments[this.fragI];
            this.curTo = (_a2 = frag.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : frag.to;
            this.inner = new StructureCursor(frag.tree, -frag.offset);
          }
        }
        findMounts(pos, parser) {
          var _a2;
          let result = [];
          if (this.inner) {
            this.inner.cursor.moveTo(pos, 1);
            for (let pos2 = this.inner.cursor.node; pos2; pos2 = pos2.parent) {
              let mount = (_a2 = pos2.tree) === null || _a2 === void 0 ? void 0 : _a2.prop(NodeProp.mounted);
              if (mount && mount.parser == parser) {
                for (let i = this.fragI; i < this.fragments.length; i++) {
                  let frag = this.fragments[i];
                  if (frag.from >= pos2.to)
                    break;
                  if (frag.tree == this.curFrag.tree)
                    result.push({
                      frag,
                      pos: pos2.from - frag.offset,
                      mount
                    });
                }
              }
            }
          }
          return result;
        }
      };
      function punchRanges(outer, ranges) {
        let copy = null, current = ranges;
        for (let i = 1, j2 = 0; i < outer.length; i++) {
          let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
          for (; j2 < current.length; j2++) {
            let r = current[j2];
            if (r.from >= gapTo)
              break;
            if (r.to <= gapFrom)
              continue;
            if (!copy)
              current = copy = ranges.slice();
            if (r.from < gapFrom) {
              copy[j2] = new Range(r.from, gapFrom);
              if (r.to > gapTo)
                copy.splice(j2 + 1, 0, new Range(gapTo, r.to));
            } else if (r.to > gapTo) {
              copy[j2--] = new Range(gapTo, r.to);
            } else {
              copy.splice(j2--, 1);
            }
          }
        }
        return current;
      }
      function findCoverChanges(a, b, from, to2) {
        let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
        let result = [];
        for (; ; ) {
          let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
          let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
          if (inA != inB) {
            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to2);
            if (start < end)
              result.push(new Range(start, end));
          }
          pos = Math.min(nextA, nextB);
          if (pos == 1e9)
            break;
          if (nextA == pos) {
            if (!inA)
              inA = true;
            else {
              inA = false;
              iA++;
            }
          }
          if (nextB == pos) {
            if (!inB)
              inB = true;
            else {
              inB = false;
              iB++;
            }
          }
        }
        return result;
      }
      function enterFragments(mounts, ranges) {
        let result = [];
        for (let { pos, mount, frag } of mounts) {
          let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
          let from = Math.max(frag.from, startPos), to2 = Math.min(frag.to, endPos);
          if (mount.overlay) {
            let overlay = mount.overlay.map((r) => new Range(r.from + pos, r.to + pos));
            let changes = findCoverChanges(ranges, overlay, from, to2);
            for (let i = 0, pos2 = from; ; i++) {
              let last = i == changes.length, end = last ? to2 : changes[i].from;
              if (end > pos2)
                result.push(new TreeFragment(pos2, end, mount.tree, -startPos, frag.from >= pos2 || frag.openStart, frag.to <= end || frag.openEnd));
              if (last)
                break;
              pos2 = changes[i].to;
            }
          } else {
            result.push(new TreeFragment(from, to2, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));
          }
        }
        return result;
      }
      exports.DefaultBufferLength = DefaultBufferLength;
      exports.MountedTree = MountedTree;
      exports.NodeProp = NodeProp;
      exports.NodeSet = NodeSet;
      exports.NodeType = NodeType;
      exports.NodeWeakMap = NodeWeakMap;
      exports.Parser = Parser;
      exports.Tree = Tree;
      exports.TreeBuffer = TreeBuffer;
      exports.TreeCursor = TreeCursor;
      exports.TreeFragment = TreeFragment;
      exports.parseMixed = parseMixed;
    }
  });

  // node_modules/@lezer/highlight/dist/index.cjs
  var require_dist4 = __commonJS({
    "node_modules/@lezer/highlight/dist/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var common = require_dist3();
      var nextTagID = 0;
      var Tag = class {
        constructor(set, base, modified) {
          this.set = set;
          this.base = base;
          this.modified = modified;
          this.id = nextTagID++;
        }
        static define(parent) {
          if (parent === null || parent === void 0 ? void 0 : parent.base)
            throw new Error("Can not derive from a modified tag");
          let tag = new Tag([], null, []);
          tag.set.push(tag);
          if (parent)
            for (let t2 of parent.set)
              tag.set.push(t2);
          return tag;
        }
        static defineModifier() {
          let mod = new Modifier();
          return (tag) => {
            if (tag.modified.indexOf(mod) > -1)
              return tag;
            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
          };
        }
      };
      var nextModifierID = 0;
      var Modifier = class {
        constructor() {
          this.instances = [];
          this.id = nextModifierID++;
        }
        static get(base, mods) {
          if (!mods.length)
            return base;
          let exists = mods[0].instances.find((t2) => t2.base == base && sameArray(mods, t2.modified));
          if (exists)
            return exists;
          let set = [], tag = new Tag(set, base, mods);
          for (let m of mods)
            m.instances.push(tag);
          let configs = powerSet(mods);
          for (let parent of base.set)
            if (!parent.modified.length)
              for (let config of configs)
                set.push(Modifier.get(parent, config));
          return tag;
        }
      };
      function sameArray(a, b) {
        return a.length == b.length && a.every((x, i) => x == b[i]);
      }
      function powerSet(array) {
        let sets = [[]];
        for (let i = 0; i < array.length; i++) {
          for (let j2 = 0, e = sets.length; j2 < e; j2++) {
            sets.push(sets[j2].concat(array[i]));
          }
        }
        return sets.sort((a, b) => b.length - a.length);
      }
      function styleTags(spec) {
        let byName = Object.create(null);
        for (let prop in spec) {
          let tags2 = spec[prop];
          if (!Array.isArray(tags2))
            tags2 = [tags2];
          for (let part of prop.split(" "))
            if (part) {
              let pieces = [], mode = 2, rest = part;
              for (let pos = 0; ; ) {
                if (rest == "..." && pos > 0 && pos + 3 == part.length) {
                  mode = 1;
                  break;
                }
                let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
                if (!m)
                  throw new RangeError("Invalid path: " + part);
                pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
                pos += m[0].length;
                if (pos == part.length)
                  break;
                let next = part[pos++];
                if (pos == part.length && next == "!") {
                  mode = 0;
                  break;
                }
                if (next != "/")
                  throw new RangeError("Invalid path: " + part);
                rest = part.slice(pos);
              }
              let last = pieces.length - 1, inner = pieces[last];
              if (!inner)
                throw new RangeError("Invalid path: " + part);
              let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
              byName[inner] = rule.sort(byName[inner]);
            }
        }
        return ruleNodeProp.add(byName);
      }
      var ruleNodeProp = new common.NodeProp();
      var Rule = class {
        constructor(tags2, mode, context, next) {
          this.tags = tags2;
          this.mode = mode;
          this.context = context;
          this.next = next;
        }
        get opaque() {
          return this.mode == 0;
        }
        get inherit() {
          return this.mode == 1;
        }
        sort(other) {
          if (!other || other.depth < this.depth) {
            this.next = other;
            return this;
          }
          other.next = this.sort(other.next);
          return other;
        }
        get depth() {
          return this.context ? this.context.length : 0;
        }
      };
      Rule.empty = new Rule([], 2, null);
      function tagHighlighter(tags2, options) {
        let map = Object.create(null);
        for (let style of tags2) {
          if (!Array.isArray(style.tag))
            map[style.tag.id] = style.class;
          else
            for (let tag of style.tag)
              map[tag.id] = style.class;
        }
        let { scope, all = null } = options || {};
        return {
          style: (tags3) => {
            let cls = all;
            for (let tag of tags3) {
              for (let sub of tag.set) {
                let tagClass = map[sub.id];
                if (tagClass) {
                  cls = cls ? cls + " " + tagClass : tagClass;
                  break;
                }
              }
            }
            return cls;
          },
          scope
        };
      }
      function highlightTags(highlighters, tags2) {
        let result = null;
        for (let highlighter of highlighters) {
          let value = highlighter.style(tags2);
          if (value)
            result = result ? result + " " + value : value;
        }
        return result;
      }
      function highlightTree(tree, highlighter, putStyle, from = 0, to2 = tree.length) {
        let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
        builder.highlightRange(tree.cursor(), from, to2, "", builder.highlighters);
        builder.flush(to2);
      }
      var HighlightBuilder = class {
        constructor(at2, highlighters, span) {
          this.at = at2;
          this.highlighters = highlighters;
          this.span = span;
          this.class = "";
        }
        startSpan(at2, cls) {
          if (cls != this.class) {
            this.flush(at2);
            if (at2 > this.at)
              this.at = at2;
            this.class = cls;
          }
        }
        flush(to2) {
          if (to2 > this.at && this.class)
            this.span(this.at, to2, this.class);
        }
        highlightRange(cursor, from, to2, inheritedClass, highlighters) {
          let { type, from: start, to: end } = cursor;
          if (start >= to2 || end <= from)
            return;
          if (type.isTop)
            highlighters = this.highlighters.filter((h2) => !h2.scope || h2.scope(type));
          let cls = inheritedClass;
          let rule = getStyleTags(cursor) || Rule.empty;
          let tagCls = highlightTags(highlighters, rule.tags);
          if (tagCls) {
            if (cls)
              cls += " ";
            cls += tagCls;
            if (rule.mode == 1)
              inheritedClass += (inheritedClass ? " " : "") + tagCls;
          }
          this.startSpan(Math.max(from, start), cls);
          if (rule.opaque)
            return;
          let mounted = cursor.tree && cursor.tree.prop(common.NodeProp.mounted);
          if (mounted && mounted.overlay) {
            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
            let innerHighlighters = this.highlighters.filter((h2) => !h2.scope || h2.scope(mounted.tree.type));
            let hasChild = cursor.firstChild();
            for (let i = 0, pos = start; ; i++) {
              let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
              let nextPos = next ? next.from + start : end;
              let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to2, nextPos);
              if (rangeFrom < rangeTo && hasChild) {
                while (cursor.from < rangeTo) {
                  this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
                  this.startSpan(Math.min(rangeTo, cursor.to), cls);
                  if (cursor.to >= nextPos || !cursor.nextSibling())
                    break;
                }
              }
              if (!next || nextPos > to2)
                break;
              pos = next.to + start;
              if (pos > from) {
                this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to2, pos), "", innerHighlighters);
                this.startSpan(Math.min(to2, pos), cls);
              }
            }
            if (hasChild)
              cursor.parent();
          } else if (cursor.firstChild()) {
            if (mounted)
              inheritedClass = "";
            do {
              if (cursor.to <= from)
                continue;
              if (cursor.from >= to2)
                break;
              this.highlightRange(cursor, from, to2, inheritedClass, highlighters);
              this.startSpan(Math.min(to2, cursor.to), cls);
            } while (cursor.nextSibling());
            cursor.parent();
          }
        }
      };
      function getStyleTags(node) {
        let rule = node.type.prop(ruleNodeProp);
        while (rule && rule.context && !node.matchContext(rule.context))
          rule = rule.next;
        return rule || null;
      }
      var t = Tag.define;
      var comment = t();
      var name = t();
      var typeName = t(name);
      var propertyName = t(name);
      var literal = t();
      var string = t(literal);
      var number = t(literal);
      var content = t();
      var heading = t(content);
      var keyword = t();
      var operator = t();
      var punctuation = t();
      var bracket = t(punctuation);
      var meta = t();
      var tags = {
        comment,
        lineComment: t(comment),
        blockComment: t(comment),
        docComment: t(comment),
        name,
        variableName: t(name),
        typeName,
        tagName: t(typeName),
        propertyName,
        attributeName: t(propertyName),
        className: t(name),
        labelName: t(name),
        namespace: t(name),
        macroName: t(name),
        literal,
        string,
        docString: t(string),
        character: t(string),
        attributeValue: t(string),
        number,
        integer: t(number),
        float: t(number),
        bool: t(literal),
        regexp: t(literal),
        escape: t(literal),
        color: t(literal),
        url: t(literal),
        keyword,
        self: t(keyword),
        null: t(keyword),
        atom: t(keyword),
        unit: t(keyword),
        modifier: t(keyword),
        operatorKeyword: t(keyword),
        controlKeyword: t(keyword),
        definitionKeyword: t(keyword),
        moduleKeyword: t(keyword),
        operator,
        derefOperator: t(operator),
        arithmeticOperator: t(operator),
        logicOperator: t(operator),
        bitwiseOperator: t(operator),
        compareOperator: t(operator),
        updateOperator: t(operator),
        definitionOperator: t(operator),
        typeOperator: t(operator),
        controlOperator: t(operator),
        punctuation,
        separator: t(punctuation),
        bracket,
        angleBracket: t(bracket),
        squareBracket: t(bracket),
        paren: t(bracket),
        brace: t(bracket),
        content,
        heading,
        heading1: t(heading),
        heading2: t(heading),
        heading3: t(heading),
        heading4: t(heading),
        heading5: t(heading),
        heading6: t(heading),
        contentSeparator: t(content),
        list: t(content),
        quote: t(content),
        emphasis: t(content),
        strong: t(content),
        link: t(content),
        monospace: t(content),
        strikethrough: t(content),
        inserted: t(),
        deleted: t(),
        changed: t(),
        invalid: t(),
        meta,
        documentMeta: t(meta),
        annotation: t(meta),
        processingInstruction: t(meta),
        definition: Tag.defineModifier(),
        constant: Tag.defineModifier(),
        function: Tag.defineModifier(),
        standard: Tag.defineModifier(),
        local: Tag.defineModifier(),
        special: Tag.defineModifier()
      };
      var classHighlighter = tagHighlighter([
        { tag: tags.link, class: "tok-link" },
        { tag: tags.heading, class: "tok-heading" },
        { tag: tags.emphasis, class: "tok-emphasis" },
        { tag: tags.strong, class: "tok-strong" },
        { tag: tags.keyword, class: "tok-keyword" },
        { tag: tags.atom, class: "tok-atom" },
        { tag: tags.bool, class: "tok-bool" },
        { tag: tags.url, class: "tok-url" },
        { tag: tags.labelName, class: "tok-labelName" },
        { tag: tags.inserted, class: "tok-inserted" },
        { tag: tags.deleted, class: "tok-deleted" },
        { tag: tags.literal, class: "tok-literal" },
        { tag: tags.string, class: "tok-string" },
        { tag: tags.number, class: "tok-number" },
        { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
        { tag: tags.variableName, class: "tok-variableName" },
        { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
        { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
        { tag: tags.special(tags.variableName), class: "tok-variableName2" },
        { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
        { tag: tags.typeName, class: "tok-typeName" },
        { tag: tags.namespace, class: "tok-namespace" },
        { tag: tags.className, class: "tok-className" },
        { tag: tags.macroName, class: "tok-macroName" },
        { tag: tags.propertyName, class: "tok-propertyName" },
        { tag: tags.operator, class: "tok-operator" },
        { tag: tags.comment, class: "tok-comment" },
        { tag: tags.meta, class: "tok-meta" },
        { tag: tags.invalid, class: "tok-invalid" },
        { tag: tags.punctuation, class: "tok-punctuation" }
      ]);
      exports.Tag = Tag;
      exports.classHighlighter = classHighlighter;
      exports.getStyleTags = getStyleTags;
      exports.highlightTree = highlightTree;
      exports.styleTags = styleTags;
      exports.tagHighlighter = tagHighlighter;
      exports.tags = tags;
    }
  });

  // node_modules/@codemirror/language/dist/index.cjs
  var require_dist5 = __commonJS({
    "node_modules/@codemirror/language/dist/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var common = require_dist3();
      var state = require_dist();
      var view = require_dist2();
      var highlight = require_dist4();
      var styleMod = require_style_mod();
      var _a2;
      var languageDataProp = new common.NodeProp();
      function defineLanguageFacet(baseData) {
        return state.Facet.define({
          combine: baseData ? (values) => values.concat(baseData) : void 0
        });
      }
      var sublanguageProp = new common.NodeProp();
      var Language = class {
        constructor(data, parser, extraExtensions = [], name = "") {
          this.data = data;
          this.name = name;
          if (!state.EditorState.prototype.hasOwnProperty("tree"))
            Object.defineProperty(state.EditorState.prototype, "tree", { get() {
              return syntaxTree(this);
            } });
          this.parser = parser;
          this.extension = [
            language.of(this),
            state.EditorState.languageData.of((state2, pos, side) => {
              let top = topNodeAt(state2, pos, side), data2 = top.type.prop(languageDataProp);
              if (!data2)
                return [];
              let base = state2.facet(data2), sub = top.type.prop(sublanguageProp);
              if (sub) {
                let innerNode = top.resolve(pos - top.from, side);
                for (let sublang of sub)
                  if (sublang.test(innerNode, state2)) {
                    let data3 = state2.facet(sublang.facet);
                    return sublang.type == "replace" ? data3 : data3.concat(base);
                  }
              }
              return base;
            })
          ].concat(extraExtensions);
        }
        isActiveAt(state2, pos, side = -1) {
          return topNodeAt(state2, pos, side).type.prop(languageDataProp) == this.data;
        }
        findRegions(state2) {
          let lang = state2.facet(language);
          if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
            return [{ from: 0, to: state2.doc.length }];
          if (!lang || !lang.allowsNesting)
            return [];
          let result = [];
          let explore = (tree, from) => {
            if (tree.prop(languageDataProp) == this.data) {
              result.push({ from, to: from + tree.length });
              return;
            }
            let mount = tree.prop(common.NodeProp.mounted);
            if (mount) {
              if (mount.tree.prop(languageDataProp) == this.data) {
                if (mount.overlay)
                  for (let r of mount.overlay)
                    result.push({ from: r.from + from, to: r.to + from });
                else
                  result.push({ from, to: from + tree.length });
                return;
              } else if (mount.overlay) {
                let size = result.length;
                explore(mount.tree, mount.overlay[0].from + from);
                if (result.length > size)
                  return;
              }
            }
            for (let i = 0; i < tree.children.length; i++) {
              let ch2 = tree.children[i];
              if (ch2 instanceof common.Tree)
                explore(ch2, tree.positions[i] + from);
            }
          };
          explore(syntaxTree(state2), 0);
          return result;
        }
        get allowsNesting() {
          return true;
        }
      };
      Language.setState = state.StateEffect.define();
      function topNodeAt(state2, pos, side) {
        let topLang = state2.facet(language), tree = syntaxTree(state2).topNode;
        if (!topLang || topLang.allowsNesting) {
          for (let node = tree; node; node = node.enter(pos, side, common.IterMode.ExcludeBuffers))
            if (node.type.isTop)
              tree = node;
        }
        return tree;
      }
      var LRLanguage = class extends Language {
        constructor(data, parser, name) {
          super(data, parser, [], name);
          this.parser = parser;
        }
        static define(spec) {
          let data = defineLanguageFacet(spec.languageData);
          return new LRLanguage(data, spec.parser.configure({
            props: [languageDataProp.add((type) => type.isTop ? data : void 0)]
          }), spec.name);
        }
        configure(options, name) {
          return new LRLanguage(this.data, this.parser.configure(options), name || this.name);
        }
        get allowsNesting() {
          return this.parser.hasWrappers();
        }
      };
      function syntaxTree(state2) {
        let field = state2.field(Language.state, false);
        return field ? field.tree : common.Tree.empty;
      }
      function ensureSyntaxTree(state2, upto, timeout = 50) {
        var _a3;
        let parse = (_a3 = state2.field(Language.state, false)) === null || _a3 === void 0 ? void 0 : _a3.context;
        if (!parse)
          return null;
        let oldVieport = parse.viewport;
        parse.updateViewport({ from: 0, to: upto });
        let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;
        parse.updateViewport(oldVieport);
        return result;
      }
      function syntaxTreeAvailable(state2, upto = state2.doc.length) {
        var _a3;
        return ((_a3 = state2.field(Language.state, false)) === null || _a3 === void 0 ? void 0 : _a3.context.isDone(upto)) || false;
      }
      function forceParsing(view2, upto = view2.viewport.to, timeout = 100) {
        let success = ensureSyntaxTree(view2.state, upto, timeout);
        if (success != syntaxTree(view2.state))
          view2.dispatch({});
        return !!success;
      }
      function syntaxParserRunning(view2) {
        var _a3;
        return ((_a3 = view2.plugin(parseWorker)) === null || _a3 === void 0 ? void 0 : _a3.isWorking()) || false;
      }
      var DocInput = class {
        constructor(doc) {
          this.doc = doc;
          this.cursorPos = 0;
          this.string = "";
          this.cursor = doc.iter();
        }
        get length() {
          return this.doc.length;
        }
        syncTo(pos) {
          this.string = this.cursor.next(pos - this.cursorPos).value;
          this.cursorPos = pos + this.string.length;
          return this.cursorPos - this.string.length;
        }
        chunk(pos) {
          this.syncTo(pos);
          return this.string;
        }
        get lineChunks() {
          return true;
        }
        read(from, to2) {
          let stringStart = this.cursorPos - this.string.length;
          if (from < stringStart || to2 >= this.cursorPos)
            return this.doc.sliceString(from, to2);
          else
            return this.string.slice(from - stringStart, to2 - stringStart);
        }
      };
      var currentContext = null;
      var ParseContext = class {
        constructor(parser, state2, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
          this.parser = parser;
          this.state = state2;
          this.fragments = fragments;
          this.tree = tree;
          this.treeLen = treeLen;
          this.viewport = viewport;
          this.skipped = skipped;
          this.scheduleOn = scheduleOn;
          this.parse = null;
          this.tempSkipped = [];
        }
        static create(parser, state2, viewport) {
          return new ParseContext(parser, state2, [], common.Tree.empty, 0, viewport, [], null);
        }
        startParse() {
          return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
        }
        work(until, upto) {
          if (upto != null && upto >= this.state.doc.length)
            upto = void 0;
          if (this.tree != common.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
            this.takeTree();
            return true;
          }
          return this.withContext(() => {
            var _a3;
            if (typeof until == "number") {
              let endTime = Date.now() + until;
              until = () => Date.now() > endTime;
            }
            if (!this.parse)
              this.parse = this.startParse();
            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
              this.parse.stopAt(upto);
            for (; ; ) {
              let done = this.parse.advance();
              if (done) {
                this.fragments = this.withoutTempSkipped(common.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
                this.treeLen = (_a3 = this.parse.stoppedAt) !== null && _a3 !== void 0 ? _a3 : this.state.doc.length;
                this.tree = done;
                this.parse = null;
                if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
                  this.parse = this.startParse();
                else
                  return true;
              }
              if (until())
                return false;
            }
          });
        }
        takeTree() {
          let pos, tree;
          if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
              this.parse.stopAt(pos);
            this.withContext(() => {
              while (!(tree = this.parse.advance())) {
              }
            });
            this.treeLen = pos;
            this.tree = tree;
            this.fragments = this.withoutTempSkipped(common.TreeFragment.addTree(this.tree, this.fragments, true));
            this.parse = null;
          }
        }
        withContext(f) {
          let prev = currentContext;
          currentContext = this;
          try {
            return f();
          } finally {
            currentContext = prev;
          }
        }
        withoutTempSkipped(fragments) {
          for (let r; r = this.tempSkipped.pop(); )
            fragments = cutFragments(fragments, r.from, r.to);
          return fragments;
        }
        changes(changes, newState) {
          let { fragments, tree, treeLen, viewport, skipped } = this;
          this.takeTree();
          if (!changes.empty) {
            let ranges = [];
            changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
            fragments = common.TreeFragment.applyChanges(fragments, ranges);
            tree = common.Tree.empty;
            treeLen = 0;
            viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
            if (this.skipped.length) {
              skipped = [];
              for (let r of this.skipped) {
                let from = changes.mapPos(r.from, 1), to2 = changes.mapPos(r.to, -1);
                if (from < to2)
                  skipped.push({ from, to: to2 });
              }
            }
          }
          return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
        }
        updateViewport(viewport) {
          if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
            return false;
          this.viewport = viewport;
          let startLen = this.skipped.length;
          for (let i = 0; i < this.skipped.length; i++) {
            let { from, to: to2 } = this.skipped[i];
            if (from < viewport.to && to2 > viewport.from) {
              this.fragments = cutFragments(this.fragments, from, to2);
              this.skipped.splice(i--, 1);
            }
          }
          if (this.skipped.length >= startLen)
            return false;
          this.reset();
          return true;
        }
        reset() {
          if (this.parse) {
            this.takeTree();
            this.parse = null;
          }
        }
        skipUntilInView(from, to2) {
          this.skipped.push({ from, to: to2 });
        }
        static getSkippingParser(until) {
          return new class extends common.Parser {
            createParse(input, fragments, ranges) {
              let from = ranges[0].from, to2 = ranges[ranges.length - 1].to;
              let parser = {
                parsedPos: from,
                advance() {
                  let cx = currentContext;
                  if (cx) {
                    for (let r of ranges)
                      cx.tempSkipped.push(r);
                    if (until)
                      cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
                  }
                  this.parsedPos = to2;
                  return new common.Tree(common.NodeType.none, [], [], to2 - from);
                },
                stoppedAt: null,
                stopAt() {
                }
              };
              return parser;
            }
          }();
        }
        isDone(upto) {
          upto = Math.min(upto, this.state.doc.length);
          let frags = this.fragments;
          return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
        }
        static get() {
          return currentContext;
        }
      };
      function cutFragments(fragments, from, to2) {
        return common.TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to2, fromB: from, toB: to2 }]);
      }
      var LanguageState = class {
        constructor(context) {
          this.context = context;
          this.tree = context.tree;
        }
        apply(tr2) {
          if (!tr2.docChanged && this.tree == this.context.tree)
            return this;
          let newCx = this.context.changes(tr2.changes, tr2.state);
          let upto = this.context.treeLen == tr2.startState.doc.length ? void 0 : Math.max(tr2.changes.mapPos(this.context.treeLen), newCx.viewport.to);
          if (!newCx.work(20, upto))
            newCx.takeTree();
          return new LanguageState(newCx);
        }
        static init(state2) {
          let vpTo = Math.min(3e3, state2.doc.length);
          let parseState = ParseContext.create(state2.facet(language).parser, state2, { from: 0, to: vpTo });
          if (!parseState.work(20, vpTo))
            parseState.takeTree();
          return new LanguageState(parseState);
        }
      };
      Language.state = state.StateField.define({
        create: LanguageState.init,
        update(value, tr2) {
          for (let e of tr2.effects)
            if (e.is(Language.setState))
              return e.value;
          if (tr2.startState.facet(language) != tr2.state.facet(language))
            return LanguageState.init(tr2.state);
          return value.apply(tr2);
        }
      });
      var requestIdle = (callback) => {
        let timeout = setTimeout(() => callback(), 500);
        return () => clearTimeout(timeout);
      };
      if (typeof requestIdleCallback != "undefined")
        requestIdle = (callback) => {
          let idle = -1, timeout = setTimeout(() => {
            idle = requestIdleCallback(callback, { timeout: 500 - 100 });
          }, 100);
          return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
        };
      var isInputPending = typeof navigator != "undefined" && ((_a2 = navigator.scheduling) === null || _a2 === void 0 ? void 0 : _a2.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
      var parseWorker = view.ViewPlugin.fromClass(class ParseWorker {
        constructor(view2) {
          this.view = view2;
          this.working = null;
          this.workScheduled = 0;
          this.chunkEnd = -1;
          this.chunkBudget = -1;
          this.work = this.work.bind(this);
          this.scheduleWork();
        }
        update(update) {
          let cx = this.view.state.field(Language.state).context;
          if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
            this.scheduleWork();
          if (update.docChanged) {
            if (this.view.hasFocus)
              this.chunkBudget += 50;
            this.scheduleWork();
          }
          this.checkAsyncSchedule(cx);
        }
        scheduleWork() {
          if (this.working)
            return;
          let { state: state2 } = this.view, field = state2.field(Language.state);
          if (field.tree != field.context.tree || !field.context.isDone(state2.doc.length))
            this.working = requestIdle(this.work);
        }
        work(deadline) {
          this.working = null;
          let now = Date.now();
          if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
            this.chunkEnd = now + 3e4;
            this.chunkBudget = 3e3;
          }
          if (this.chunkBudget <= 0)
            return;
          let { state: state2, viewport: { to: vpTo } } = this.view, field = state2.field(Language.state);
          if (field.tree == field.context.tree && field.context.isDone(vpTo + 1e5))
            return;
          let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
          let viewportFirst = field.context.treeLen < vpTo && state2.doc.length > vpTo + 1e3;
          let done = field.context.work(() => {
            return isInputPending && isInputPending() || Date.now() > endTime;
          }, vpTo + (viewportFirst ? 0 : 1e5));
          this.chunkBudget -= Date.now() - now;
          if (done || this.chunkBudget <= 0) {
            field.context.takeTree();
            this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
          }
          if (this.chunkBudget > 0 && !(done && !viewportFirst))
            this.scheduleWork();
          this.checkAsyncSchedule(field.context);
        }
        checkAsyncSchedule(cx) {
          if (cx.scheduleOn) {
            this.workScheduled++;
            cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => view.logException(this.view.state, err)).then(() => this.workScheduled--);
            cx.scheduleOn = null;
          }
        }
        destroy() {
          if (this.working)
            this.working();
        }
        isWorking() {
          return !!(this.working || this.workScheduled > 0);
        }
      }, {
        eventHandlers: { focus() {
          this.scheduleWork();
        } }
      });
      var language = state.Facet.define({
        combine(languages) {
          return languages.length ? languages[0] : null;
        },
        enables: (language2) => [
          Language.state,
          parseWorker,
          view.EditorView.contentAttributes.compute([language2], (state2) => {
            let lang = state2.facet(language2);
            return lang && lang.name ? { "data-language": lang.name } : {};
          })
        ]
      });
      var LanguageSupport = class {
        constructor(language2, support = []) {
          this.language = language2;
          this.support = support;
          this.extension = [language2, support];
        }
      };
      var LanguageDescription = class {
        constructor(name, alias, extensions, filename, loadFunc, support = void 0) {
          this.name = name;
          this.alias = alias;
          this.extensions = extensions;
          this.filename = filename;
          this.loadFunc = loadFunc;
          this.support = support;
          this.loading = null;
        }
        load() {
          return this.loading || (this.loading = this.loadFunc().then((support) => this.support = support, (err) => {
            this.loading = null;
            throw err;
          }));
        }
        static of(spec) {
          let { load, support } = spec;
          if (!load) {
            if (!support)
              throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
            load = () => Promise.resolve(support);
          }
          return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map((s) => s.toLowerCase()), spec.extensions || [], spec.filename, load, support);
        }
        static matchFilename(descs, filename) {
          for (let d2 of descs)
            if (d2.filename && d2.filename.test(filename))
              return d2;
          let ext = /\.([^.]+)$/.exec(filename);
          if (ext) {
            for (let d2 of descs)
              if (d2.extensions.indexOf(ext[1]) > -1)
                return d2;
          }
          return null;
        }
        static matchLanguageName(descs, name, fuzzy = true) {
          name = name.toLowerCase();
          for (let d2 of descs)
            if (d2.alias.some((a) => a == name))
              return d2;
          if (fuzzy)
            for (let d2 of descs)
              for (let a of d2.alias) {
                let found = name.indexOf(a);
                if (found > -1 && (a.length > 2 || !/\w/.test(name[found - 1]) && !/\w/.test(name[found + a.length])))
                  return d2;
              }
          return null;
        }
      };
      var indentService = state.Facet.define();
      var indentUnit = state.Facet.define({
        combine: (values) => {
          if (!values.length)
            return "  ";
          let unit = values[0];
          if (!unit || /\S/.test(unit) || Array.from(unit).some((e) => e != unit[0]))
            throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
          return unit;
        }
      });
      function getIndentUnit(state2) {
        let unit = state2.facet(indentUnit);
        return unit.charCodeAt(0) == 9 ? state2.tabSize * unit.length : unit.length;
      }
      function indentString(state2, cols) {
        let result = "", ts2 = state2.tabSize, ch2 = state2.facet(indentUnit)[0];
        if (ch2 == "	") {
          while (cols >= ts2) {
            result += "	";
            cols -= ts2;
          }
          ch2 = " ";
        }
        for (let i = 0; i < cols; i++)
          result += ch2;
        return result;
      }
      function getIndentation(context, pos) {
        if (context instanceof state.EditorState)
          context = new IndentContext(context);
        for (let service of context.state.facet(indentService)) {
          let result = service(context, pos);
          if (result !== void 0)
            return result;
        }
        let tree = syntaxTree(context.state);
        return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
      }
      function indentRange(state2, from, to2) {
        let updated = Object.create(null);
        let context = new IndentContext(state2, { overrideIndentation: (start) => {
          var _a3;
          return (_a3 = updated[start]) !== null && _a3 !== void 0 ? _a3 : -1;
        } });
        let changes = [];
        for (let pos = from; pos <= to2; ) {
          let line = state2.doc.lineAt(pos);
          pos = line.to + 1;
          let indent = getIndentation(context, line.from);
          if (indent == null)
            continue;
          if (!/\S/.test(line.text))
            indent = 0;
          let cur = /^\s*/.exec(line.text)[0];
          let norm = indentString(state2, indent);
          if (cur != norm) {
            updated[line.from] = indent;
            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
          }
        }
        return state2.changes(changes);
      }
      var IndentContext = class {
        constructor(state2, options = {}) {
          this.state = state2;
          this.options = options;
          this.unit = getIndentUnit(state2);
        }
        lineAt(pos, bias = 1) {
          let line = this.state.doc.lineAt(pos);
          let { simulateBreak, simulateDoubleBreak } = this.options;
          if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
            if (simulateDoubleBreak && simulateBreak == pos)
              return { text: "", from: pos };
            else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
              return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
            else
              return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
          }
          return line;
        }
        textAfterPos(pos, bias = 1) {
          if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
            return "";
          let { text, from } = this.lineAt(pos, bias);
          return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
        }
        column(pos, bias = 1) {
          let { text, from } = this.lineAt(pos, bias);
          let result = this.countColumn(text, pos - from);
          let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
          if (override > -1)
            result += override - this.countColumn(text, text.search(/\S|$/));
          return result;
        }
        countColumn(line, pos = line.length) {
          return state.countColumn(line, this.state.tabSize, pos);
        }
        lineIndent(pos, bias = 1) {
          let { text, from } = this.lineAt(pos, bias);
          let override = this.options.overrideIndentation;
          if (override) {
            let overriden = override(from);
            if (overriden > -1)
              return overriden;
          }
          return this.countColumn(text, text.search(/\S|$/));
        }
        get simulatedBreak() {
          return this.options.simulateBreak || null;
        }
      };
      var indentNodeProp = new common.NodeProp();
      function syntaxIndentation(cx, ast, pos) {
        return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
      }
      function ignoreClosed(cx) {
        return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
      }
      function indentStrategy(tree) {
        let strategy = tree.type.prop(indentNodeProp);
        if (strategy)
          return strategy;
        let first = tree.firstChild, close;
        if (first && (close = first.type.prop(common.NodeProp.closedBy))) {
          let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
          return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
        }
        return tree.parent == null ? topIndent : null;
      }
      function indentFrom(node, pos, base) {
        for (; node; node = node.parent) {
          let strategy = indentStrategy(node);
          if (strategy)
            return strategy(TreeIndentContext.create(base, pos, node));
        }
        return null;
      }
      function topIndent() {
        return 0;
      }
      var TreeIndentContext = class extends IndentContext {
        constructor(base, pos, node) {
          super(base.state, base.options);
          this.base = base;
          this.pos = pos;
          this.node = node;
        }
        static create(base, pos, node) {
          return new TreeIndentContext(base, pos, node);
        }
        get textAfter() {
          return this.textAfterPos(this.pos);
        }
        get baseIndent() {
          return this.baseIndentFor(this.node);
        }
        baseIndentFor(node) {
          let line = this.state.doc.lineAt(node.from);
          for (; ; ) {
            let atBreak = node.resolve(line.from);
            while (atBreak.parent && atBreak.parent.from == atBreak.from)
              atBreak = atBreak.parent;
            if (isParent(atBreak, node))
              break;
            line = this.state.doc.lineAt(atBreak.from);
          }
          return this.lineIndent(line.from);
        }
        continue() {
          let parent = this.node.parent;
          return parent ? indentFrom(parent, this.pos, this.base) : 0;
        }
      };
      function isParent(parent, of) {
        for (let cur = of; cur; cur = cur.parent)
          if (parent == cur)
            return true;
        return false;
      }
      function bracketedAligned(context) {
        let tree = context.node;
        let openToken = tree.childAfter(tree.from), last = tree.lastChild;
        if (!openToken)
          return null;
        let sim = context.options.simulateBreak;
        let openLine = context.state.doc.lineAt(openToken.from);
        let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
        for (let pos = openToken.to; ; ) {
          let next = tree.childAfter(pos);
          if (!next || next == last)
            return null;
          if (!next.type.isSkipped)
            return next.from < lineEnd ? openToken : null;
          pos = next.to;
        }
      }
      function delimitedIndent({ closing, align = true, units = 1 }) {
        return (context) => delimitedStrategy(context, align, units, closing);
      }
      function delimitedStrategy(context, align, units, closing, closedAt) {
        let after = context.textAfter, space = after.match(/^\s*/)[0].length;
        let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
        let aligned = align ? bracketedAligned(context) : null;
        if (aligned)
          return closed ? context.column(aligned.from) : context.column(aligned.to);
        return context.baseIndent + (closed ? 0 : context.unit * units);
      }
      var flatIndent = (context) => context.baseIndent;
      function continuedIndent({ except, units = 1 } = {}) {
        return (context) => {
          let matchExcept = except && except.test(context.textAfter);
          return context.baseIndent + (matchExcept ? 0 : units * context.unit);
        };
      }
      var DontIndentBeyond = 200;
      function indentOnInput() {
        return state.EditorState.transactionFilter.of((tr2) => {
          if (!tr2.docChanged || !tr2.isUserEvent("input.type") && !tr2.isUserEvent("input.complete"))
            return tr2;
          let rules = tr2.startState.languageDataAt("indentOnInput", tr2.startState.selection.main.head);
          if (!rules.length)
            return tr2;
          let doc = tr2.newDoc, { head } = tr2.newSelection.main, line = doc.lineAt(head);
          if (head > line.from + DontIndentBeyond)
            return tr2;
          let lineStart = doc.sliceString(line.from, head);
          if (!rules.some((r) => r.test(lineStart)))
            return tr2;
          let { state: state2 } = tr2, last = -1, changes = [];
          for (let { head: head2 } of state2.selection.ranges) {
            let line2 = state2.doc.lineAt(head2);
            if (line2.from == last)
              continue;
            last = line2.from;
            let indent = getIndentation(state2, line2.from);
            if (indent == null)
              continue;
            let cur = /^\s*/.exec(line2.text)[0];
            let norm = indentString(state2, indent);
            if (cur != norm)
              changes.push({ from: line2.from, to: line2.from + cur.length, insert: norm });
          }
          return changes.length ? [tr2, { changes, sequential: true }] : tr2;
        });
      }
      var foldService = state.Facet.define();
      var foldNodeProp = new common.NodeProp();
      function foldInside(node) {
        let first = node.firstChild, last = node.lastChild;
        return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;
      }
      function syntaxFolding(state2, start, end) {
        let tree = syntaxTree(state2);
        if (tree.length < end)
          return null;
        let inner = tree.resolveInner(end, 1);
        let found = null;
        for (let cur = inner; cur; cur = cur.parent) {
          if (cur.to <= end || cur.from > end)
            continue;
          if (found && cur.from < start)
            break;
          let prop = cur.type.prop(foldNodeProp);
          if (prop && (cur.to < tree.length - 50 || tree.length == state2.doc.length || !isUnfinished(cur))) {
            let value = prop(cur, state2);
            if (value && value.from <= end && value.from >= start && value.to > end)
              found = value;
          }
        }
        return found;
      }
      function isUnfinished(node) {
        let ch2 = node.lastChild;
        return ch2 && ch2.to == node.to && ch2.type.isError;
      }
      function foldable(state2, lineStart, lineEnd) {
        for (let service of state2.facet(foldService)) {
          let result = service(state2, lineStart, lineEnd);
          if (result)
            return result;
        }
        return syntaxFolding(state2, lineStart, lineEnd);
      }
      function mapRange(range, mapping) {
        let from = mapping.mapPos(range.from, 1), to2 = mapping.mapPos(range.to, -1);
        return from >= to2 ? void 0 : { from, to: to2 };
      }
      var foldEffect = state.StateEffect.define({ map: mapRange });
      var unfoldEffect = state.StateEffect.define({ map: mapRange });
      function selectedLines(view2) {
        let lines = [];
        for (let { head } of view2.state.selection.ranges) {
          if (lines.some((l) => l.from <= head && l.to >= head))
            continue;
          lines.push(view2.lineBlockAt(head));
        }
        return lines;
      }
      var foldState = state.StateField.define({
        create() {
          return view.Decoration.none;
        },
        update(folded, tr2) {
          folded = folded.map(tr2.changes);
          for (let e of tr2.effects) {
            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {
              let { preparePlaceholder } = tr2.state.facet(foldConfig);
              let widget = !preparePlaceholder ? foldWidget : view.Decoration.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr2.state, e.value)) });
              folded = folded.update({ add: [widget.range(e.value.from, e.value.to)] });
            } else if (e.is(unfoldEffect)) {
              folded = folded.update({
                filter: (from, to2) => e.value.from != from || e.value.to != to2,
                filterFrom: e.value.from,
                filterTo: e.value.to
              });
            }
          }
          if (tr2.selection) {
            let onSelection = false, { head } = tr2.selection.main;
            folded.between(head, head, (a, b) => {
              if (a < head && b > head)
                onSelection = true;
            });
            if (onSelection)
              folded = folded.update({
                filterFrom: head,
                filterTo: head,
                filter: (a, b) => b <= head || a >= head
              });
          }
          return folded;
        },
        provide: (f) => view.EditorView.decorations.from(f),
        toJSON(folded, state2) {
          let ranges = [];
          folded.between(0, state2.doc.length, (from, to2) => {
            ranges.push(from, to2);
          });
          return ranges;
        },
        fromJSON(value) {
          if (!Array.isArray(value) || value.length % 2)
            throw new RangeError("Invalid JSON for fold state");
          let ranges = [];
          for (let i = 0; i < value.length; ) {
            let from = value[i++], to2 = value[i++];
            if (typeof from != "number" || typeof to2 != "number")
              throw new RangeError("Invalid JSON for fold state");
            ranges.push(foldWidget.range(from, to2));
          }
          return view.Decoration.set(ranges, true);
        }
      });
      function foldedRanges(state$1) {
        return state$1.field(foldState, false) || state.RangeSet.empty;
      }
      function findFold(state2, from, to2) {
        var _a3;
        let found = null;
        (_a3 = state2.field(foldState, false)) === null || _a3 === void 0 ? void 0 : _a3.between(from, to2, (from2, to3) => {
          if (!found || found.from > from2)
            found = { from: from2, to: to3 };
        });
        return found;
      }
      function foldExists(folded, from, to2) {
        let found = false;
        folded.between(from, from, (a, b) => {
          if (a == from && b == to2)
            found = true;
        });
        return found;
      }
      function maybeEnable(state$1, other) {
        return state$1.field(foldState, false) ? other : other.concat(state.StateEffect.appendConfig.of(codeFolding()));
      }
      var foldCode = (view2) => {
        for (let line of selectedLines(view2)) {
          let range = foldable(view2.state, line.from, line.to);
          if (range) {
            view2.dispatch({ effects: maybeEnable(view2.state, [foldEffect.of(range), announceFold(view2, range)]) });
            return true;
          }
        }
        return false;
      };
      var unfoldCode = (view2) => {
        if (!view2.state.field(foldState, false))
          return false;
        let effects = [];
        for (let line of selectedLines(view2)) {
          let folded = findFold(view2.state, line.from, line.to);
          if (folded)
            effects.push(unfoldEffect.of(folded), announceFold(view2, folded, false));
        }
        if (effects.length)
          view2.dispatch({ effects });
        return effects.length > 0;
      };
      function announceFold(view$1, range, fold = true) {
        let lineFrom = view$1.state.doc.lineAt(range.from).number, lineTo = view$1.state.doc.lineAt(range.to).number;
        return view.EditorView.announce.of(`${view$1.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view$1.state.phrase("to")} ${lineTo}.`);
      }
      var foldAll = (view2) => {
        let { state: state2 } = view2, effects = [];
        for (let pos = 0; pos < state2.doc.length; ) {
          let line = view2.lineBlockAt(pos), range = foldable(state2, line.from, line.to);
          if (range)
            effects.push(foldEffect.of(range));
          pos = (range ? view2.lineBlockAt(range.to) : line).to + 1;
        }
        if (effects.length)
          view2.dispatch({ effects: maybeEnable(view2.state, effects) });
        return !!effects.length;
      };
      var unfoldAll = (view2) => {
        let field = view2.state.field(foldState, false);
        if (!field || !field.size)
          return false;
        let effects = [];
        field.between(0, view2.state.doc.length, (from, to2) => {
          effects.push(unfoldEffect.of({ from, to: to2 }));
        });
        view2.dispatch({ effects });
        return true;
      };
      function foldableContainer(view2, lineBlock) {
        for (let line = lineBlock; ; ) {
          let foldableRegion = foldable(view2.state, line.from, line.to);
          if (foldableRegion && foldableRegion.to > lineBlock.from)
            return foldableRegion;
          if (!line.from)
            return null;
          line = view2.lineBlockAt(line.from - 1);
        }
      }
      var toggleFold = (view2) => {
        let effects = [];
        for (let line of selectedLines(view2)) {
          let folded = findFold(view2.state, line.from, line.to);
          if (folded) {
            effects.push(unfoldEffect.of(folded), announceFold(view2, folded, false));
          } else {
            let foldRange = foldableContainer(view2, line);
            if (foldRange)
              effects.push(foldEffect.of(foldRange), announceFold(view2, foldRange));
          }
        }
        if (effects.length > 0)
          view2.dispatch({ effects: maybeEnable(view2.state, effects) });
        return !!effects.length;
      };
      var foldKeymap = [
        { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
        { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
        { key: "Ctrl-Alt-[", run: foldAll },
        { key: "Ctrl-Alt-]", run: unfoldAll }
      ];
      var defaultConfig = {
        placeholderDOM: null,
        preparePlaceholder: null,
        placeholderText: "\u2026"
      };
      var foldConfig = state.Facet.define({
        combine(values) {
          return state.combineConfig(values, defaultConfig);
        }
      });
      function codeFolding(config) {
        let result = [foldState, baseTheme$1];
        if (config)
          result.push(foldConfig.of(config));
        return result;
      }
      function widgetToDOM(view2, prepared) {
        let { state: state2 } = view2, conf = state2.facet(foldConfig);
        let onclick = (event2) => {
          let line = view2.lineBlockAt(view2.posAtDOM(event2.target));
          let folded = findFold(view2.state, line.from, line.to);
          if (folded)
            view2.dispatch({ effects: unfoldEffect.of(folded) });
          event2.preventDefault();
        };
        if (conf.placeholderDOM)
          return conf.placeholderDOM(view2, onclick, prepared);
        let element = document.createElement("span");
        element.textContent = conf.placeholderText;
        element.setAttribute("aria-label", state2.phrase("folded code"));
        element.title = state2.phrase("unfold");
        element.className = "cm-foldPlaceholder";
        element.onclick = onclick;
        return element;
      }
      var foldWidget = view.Decoration.replace({ widget: new class extends view.WidgetType {
        toDOM(view2) {
          return widgetToDOM(view2, null);
        }
      }() });
      var PreparedFoldWidget = class extends view.WidgetType {
        constructor(value) {
          super();
          this.value = value;
        }
        eq(other) {
          return this.value == other.value;
        }
        toDOM(view2) {
          return widgetToDOM(view2, this.value);
        }
      };
      var foldGutterDefaults = {
        openText: "\u2304",
        closedText: "\u203A",
        markerDOM: null,
        domEventHandlers: {},
        foldingChanged: () => false
      };
      var FoldMarker = class extends view.GutterMarker {
        constructor(config, open) {
          super();
          this.config = config;
          this.open = open;
        }
        eq(other) {
          return this.config == other.config && this.open == other.open;
        }
        toDOM(view2) {
          if (this.config.markerDOM)
            return this.config.markerDOM(this.open);
          let span = document.createElement("span");
          span.textContent = this.open ? this.config.openText : this.config.closedText;
          span.title = view2.state.phrase(this.open ? "Fold line" : "Unfold line");
          return span;
        }
      };
      function foldGutter(config = {}) {
        let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);
        let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
        let markers = view.ViewPlugin.fromClass(class {
          constructor(view2) {
            this.from = view2.viewport.from;
            this.markers = this.buildMarkers(view2);
          }
          update(update) {
            if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update))
              this.markers = this.buildMarkers(update.view);
          }
          buildMarkers(view2) {
            let builder = new state.RangeSetBuilder();
            for (let line of view2.viewportLineBlocks) {
              let mark = findFold(view2.state, line.from, line.to) ? canUnfold : foldable(view2.state, line.from, line.to) ? canFold : null;
              if (mark)
                builder.add(line.from, line.from, mark);
            }
            return builder.finish();
          }
        });
        let { domEventHandlers } = fullConfig;
        return [
          markers,
          view.gutter({
            class: "cm-foldGutter",
            markers(view2) {
              var _a3;
              return ((_a3 = view2.plugin(markers)) === null || _a3 === void 0 ? void 0 : _a3.markers) || state.RangeSet.empty;
            },
            initialSpacer() {
              return new FoldMarker(fullConfig, false);
            },
            domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view2, line, event2) => {
              if (domEventHandlers.click && domEventHandlers.click(view2, line, event2))
                return true;
              let folded = findFold(view2.state, line.from, line.to);
              if (folded) {
                view2.dispatch({ effects: unfoldEffect.of(folded) });
                return true;
              }
              let range = foldable(view2.state, line.from, line.to);
              if (range) {
                view2.dispatch({ effects: foldEffect.of(range) });
                return true;
              }
              return false;
            } })
          }),
          codeFolding()
        ];
      }
      var baseTheme$1 = view.EditorView.baseTheme({
        ".cm-foldPlaceholder": {
          backgroundColor: "#eee",
          border: "1px solid #ddd",
          color: "#888",
          borderRadius: ".2em",
          margin: "0 1px",
          padding: "0 1px",
          cursor: "pointer"
        },
        ".cm-foldGutter span": {
          padding: "0 1px",
          cursor: "pointer"
        }
      });
      var HighlightStyle = class {
        constructor(specs, options) {
          this.specs = specs;
          let modSpec;
          function def(spec) {
            let cls = styleMod.StyleModule.newName();
            (modSpec || (modSpec = Object.create(null)))["." + cls] = spec;
            return cls;
          }
          const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
          const scopeOpt = options.scope;
          this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
          this.style = highlight.tagHighlighter(specs.map((style) => ({
            tag: style.tag,
            class: style.class || def(Object.assign({}, style, { tag: null }))
          })), {
            all
          }).style;
          this.module = modSpec ? new styleMod.StyleModule(modSpec) : null;
          this.themeType = options.themeType;
        }
        static define(specs, options) {
          return new HighlightStyle(specs, options || {});
        }
      };
      var highlighterFacet = state.Facet.define();
      var fallbackHighlighter = state.Facet.define({
        combine(values) {
          return values.length ? [values[0]] : null;
        }
      });
      function getHighlighters(state2) {
        let main = state2.facet(highlighterFacet);
        return main.length ? main : state2.facet(fallbackHighlighter);
      }
      function syntaxHighlighting(highlighter, options) {
        let ext = [treeHighlighter], themeType;
        if (highlighter instanceof HighlightStyle) {
          if (highlighter.module)
            ext.push(view.EditorView.styleModule.of(highlighter.module));
          themeType = highlighter.themeType;
        }
        if (options === null || options === void 0 ? void 0 : options.fallback)
          ext.push(fallbackHighlighter.of(highlighter));
        else if (themeType)
          ext.push(highlighterFacet.computeN([view.EditorView.darkTheme], (state2) => {
            return state2.facet(view.EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
          }));
        else
          ext.push(highlighterFacet.of(highlighter));
        return ext;
      }
      function highlightingFor(state2, tags, scope) {
        let highlighters = getHighlighters(state2);
        let result = null;
        if (highlighters)
          for (let highlighter of highlighters) {
            if (!highlighter.scope || scope && highlighter.scope(scope)) {
              let cls = highlighter.style(tags);
              if (cls)
                result = result ? result + " " + cls : cls;
            }
          }
        return result;
      }
      var TreeHighlighter = class {
        constructor(view2) {
          this.markCache = Object.create(null);
          this.tree = syntaxTree(view2.state);
          this.decorations = this.buildDeco(view2, getHighlighters(view2.state));
        }
        update(update) {
          let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
          let styleChange = highlighters != getHighlighters(update.startState);
          if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
            this.decorations = this.decorations.map(update.changes);
          } else if (tree != this.tree || update.viewportChanged || styleChange) {
            this.tree = tree;
            this.decorations = this.buildDeco(update.view, highlighters);
          }
        }
        buildDeco(view$1, highlighters) {
          if (!highlighters || !this.tree.length)
            return view.Decoration.none;
          let builder = new state.RangeSetBuilder();
          for (let { from, to: to2 } of view$1.visibleRanges) {
            highlight.highlightTree(this.tree, highlighters, (from2, to3, style) => {
              builder.add(from2, to3, this.markCache[style] || (this.markCache[style] = view.Decoration.mark({ class: style })));
            }, from, to2);
          }
          return builder.finish();
        }
      };
      var treeHighlighter = state.Prec.high(view.ViewPlugin.fromClass(TreeHighlighter, {
        decorations: (v) => v.decorations
      }));
      var defaultHighlightStyle = HighlightStyle.define([
        {
          tag: highlight.tags.meta,
          color: "#404740"
        },
        {
          tag: highlight.tags.link,
          textDecoration: "underline"
        },
        {
          tag: highlight.tags.heading,
          textDecoration: "underline",
          fontWeight: "bold"
        },
        {
          tag: highlight.tags.emphasis,
          fontStyle: "italic"
        },
        {
          tag: highlight.tags.strong,
          fontWeight: "bold"
        },
        {
          tag: highlight.tags.strikethrough,
          textDecoration: "line-through"
        },
        {
          tag: highlight.tags.keyword,
          color: "#708"
        },
        {
          tag: [highlight.tags.atom, highlight.tags.bool, highlight.tags.url, highlight.tags.contentSeparator, highlight.tags.labelName],
          color: "#219"
        },
        {
          tag: [highlight.tags.literal, highlight.tags.inserted],
          color: "#164"
        },
        {
          tag: [highlight.tags.string, highlight.tags.deleted],
          color: "#a11"
        },
        {
          tag: [highlight.tags.regexp, highlight.tags.escape, highlight.tags.special(highlight.tags.string)],
          color: "#e40"
        },
        {
          tag: highlight.tags.definition(highlight.tags.variableName),
          color: "#00f"
        },
        {
          tag: highlight.tags.local(highlight.tags.variableName),
          color: "#30a"
        },
        {
          tag: [highlight.tags.typeName, highlight.tags.namespace],
          color: "#085"
        },
        {
          tag: highlight.tags.className,
          color: "#167"
        },
        {
          tag: [highlight.tags.special(highlight.tags.variableName), highlight.tags.macroName],
          color: "#256"
        },
        {
          tag: highlight.tags.definition(highlight.tags.propertyName),
          color: "#00c"
        },
        {
          tag: highlight.tags.comment,
          color: "#940"
        },
        {
          tag: highlight.tags.invalid,
          color: "#f00"
        }
      ]);
      var baseTheme = view.EditorView.baseTheme({
        "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
        "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
      });
      var DefaultScanDist = 1e4;
      var DefaultBrackets = "()[]{}";
      var bracketMatchingConfig = state.Facet.define({
        combine(configs) {
          return state.combineConfig(configs, {
            afterCursor: true,
            brackets: DefaultBrackets,
            maxScanDistance: DefaultScanDist,
            renderMatch: defaultRenderMatch
          });
        }
      });
      var matchingMark = view.Decoration.mark({ class: "cm-matchingBracket" });
      var nonmatchingMark = view.Decoration.mark({ class: "cm-nonmatchingBracket" });
      function defaultRenderMatch(match) {
        let decorations = [];
        let mark = match.matched ? matchingMark : nonmatchingMark;
        decorations.push(mark.range(match.start.from, match.start.to));
        if (match.end)
          decorations.push(mark.range(match.end.from, match.end.to));
        return decorations;
      }
      var bracketMatchingState = state.StateField.define({
        create() {
          return view.Decoration.none;
        },
        update(deco, tr2) {
          if (!tr2.docChanged && !tr2.selection)
            return deco;
          let decorations = [];
          let config = tr2.state.facet(bracketMatchingConfig);
          for (let range of tr2.state.selection.ranges) {
            if (!range.empty)
              continue;
            let match = matchBrackets(tr2.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr2.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr2.state, range.head, 1, config) || range.head < tr2.state.doc.length && matchBrackets(tr2.state, range.head + 1, -1, config));
            if (match)
              decorations = decorations.concat(config.renderMatch(match, tr2.state));
          }
          return view.Decoration.set(decorations, true);
        },
        provide: (f) => view.EditorView.decorations.from(f)
      });
      var bracketMatchingUnique = [
        bracketMatchingState,
        baseTheme
      ];
      function bracketMatching(config = {}) {
        return [bracketMatchingConfig.of(config), bracketMatchingUnique];
      }
      var bracketMatchingHandle = new common.NodeProp();
      function matchingNodes(node, dir, brackets) {
        let byProp = node.prop(dir < 0 ? common.NodeProp.openedBy : common.NodeProp.closedBy);
        if (byProp)
          return byProp;
        if (node.name.length == 1) {
          let index = brackets.indexOf(node.name);
          if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
            return [brackets[index + dir]];
        }
        return null;
      }
      function findHandle(node) {
        let hasHandle = node.type.prop(bracketMatchingHandle);
        return hasHandle ? hasHandle(node.node) : node;
      }
      function matchBrackets(state2, pos, dir, config = {}) {
        let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;
        let tree = syntaxTree(state2), node = tree.resolveInner(pos, dir);
        for (let cur = node; cur; cur = cur.parent) {
          let matches = matchingNodes(cur.type, dir, brackets);
          if (matches && cur.from < cur.to) {
            let handle = findHandle(cur);
            if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
              return matchMarkedBrackets(state2, pos, dir, cur, handle, matches, brackets);
          }
        }
        return matchPlainBrackets(state2, pos, dir, tree, node.type, maxScanDistance, brackets);
      }
      function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
        let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
        let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
        if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
          do {
            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
              if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
                let endHandle = findHandle(cursor);
                return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0, matched: true };
              } else if (matchingNodes(cursor.type, dir, brackets)) {
                depth++;
              } else if (matchingNodes(cursor.type, -dir, brackets)) {
                if (depth == 0) {
                  let endHandle = findHandle(cursor);
                  return {
                    start: firstToken,
                    end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : void 0,
                    matched: false
                  };
                }
                depth--;
              }
            }
          } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
        return { start: firstToken, matched: false };
      }
      function matchPlainBrackets(state2, pos, dir, tree, tokenType, maxScanDistance, brackets) {
        let startCh = dir < 0 ? state2.sliceDoc(pos - 1, pos) : state2.sliceDoc(pos, pos + 1);
        let bracket = brackets.indexOf(startCh);
        if (bracket < 0 || bracket % 2 == 0 != dir > 0)
          return null;
        let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
        let iter = state2.doc.iterRange(pos, dir > 0 ? state2.doc.length : 0), depth = 0;
        for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
          let text = iter.value;
          if (dir < 0)
            distance += text.length;
          let basePos = pos + distance * dir;
          for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
            let found = brackets.indexOf(text[pos2]);
            if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
              continue;
            if (found % 2 == 0 == dir > 0) {
              depth++;
            } else if (depth == 1) {
              return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket >> 1 };
            } else {
              depth--;
            }
          }
          if (dir > 0)
            distance += text.length;
        }
        return iter.done ? { start: startToken, matched: false } : null;
      }
      function countCol(string, end, tabSize, startIndex = 0, startValue = 0) {
        if (end == null) {
          end = string.search(/[^\s\u00a0]/);
          if (end == -1)
            end = string.length;
        }
        let n = startValue;
        for (let i = startIndex; i < end; i++) {
          if (string.charCodeAt(i) == 9)
            n += tabSize - n % tabSize;
          else
            n++;
        }
        return n;
      }
      var StringStream = class {
        constructor(string, tabSize, indentUnit2, overrideIndent) {
          this.string = string;
          this.tabSize = tabSize;
          this.indentUnit = indentUnit2;
          this.overrideIndent = overrideIndent;
          this.pos = 0;
          this.start = 0;
          this.lastColumnPos = 0;
          this.lastColumnValue = 0;
        }
        eol() {
          return this.pos >= this.string.length;
        }
        sol() {
          return this.pos == 0;
        }
        peek() {
          return this.string.charAt(this.pos) || void 0;
        }
        next() {
          if (this.pos < this.string.length)
            return this.string.charAt(this.pos++);
        }
        eat(match) {
          let ch2 = this.string.charAt(this.pos);
          let ok;
          if (typeof match == "string")
            ok = ch2 == match;
          else
            ok = ch2 && (match instanceof RegExp ? match.test(ch2) : match(ch2));
          if (ok) {
            ++this.pos;
            return ch2;
          }
        }
        eatWhile(match) {
          let start = this.pos;
          while (this.eat(match)) {
          }
          return this.pos > start;
        }
        eatSpace() {
          let start = this.pos;
          while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
            ++this.pos;
          return this.pos > start;
        }
        skipToEnd() {
          this.pos = this.string.length;
        }
        skipTo(ch2) {
          let found = this.string.indexOf(ch2, this.pos);
          if (found > -1) {
            this.pos = found;
            return true;
          }
        }
        backUp(n) {
          this.pos -= n;
        }
        column() {
          if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
          }
          return this.lastColumnValue;
        }
        indentation() {
          var _a3;
          return (_a3 = this.overrideIndent) !== null && _a3 !== void 0 ? _a3 : countCol(this.string, null, this.tabSize);
        }
        match(pattern, consume, caseInsensitive) {
          if (typeof pattern == "string") {
            let cased = (str) => caseInsensitive ? str.toLowerCase() : str;
            let substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
              if (consume !== false)
                this.pos += pattern.length;
              return true;
            } else
              return null;
          } else {
            let match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0)
              return null;
            if (match && consume !== false)
              this.pos += match[0].length;
            return match;
          }
        }
        current() {
          return this.string.slice(this.start, this.pos);
        }
      };
      function fullParser(spec) {
        return {
          name: spec.name || "",
          token: spec.token,
          blankLine: spec.blankLine || (() => {
          }),
          startState: spec.startState || (() => true),
          copyState: spec.copyState || defaultCopyState,
          indent: spec.indent || (() => null),
          languageData: spec.languageData || {},
          tokenTable: spec.tokenTable || noTokens
        };
      }
      function defaultCopyState(state2) {
        if (typeof state2 != "object")
          return state2;
        let newState = {};
        for (let prop in state2) {
          let val = state2[prop];
          newState[prop] = val instanceof Array ? val.slice() : val;
        }
        return newState;
      }
      var IndentedFrom = new WeakMap();
      var StreamLanguage = class extends Language {
        constructor(parser) {
          let data = defineLanguageFacet(parser.languageData);
          let p = fullParser(parser), self2;
          let impl = new class extends common.Parser {
            createParse(input, fragments, ranges) {
              return new Parse(self2, input, fragments, ranges);
            }
          }();
          super(data, impl, [indentService.of((cx, pos) => this.getIndent(cx, pos))], parser.name);
          this.topNode = docID(data);
          self2 = this;
          this.streamParser = p;
          this.stateAfter = new common.NodeProp({ perNode: true });
          this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;
        }
        static define(spec) {
          return new StreamLanguage(spec);
        }
        getIndent(cx, pos) {
          let tree = syntaxTree(cx.state), at2 = tree.resolve(pos);
          while (at2 && at2.type != this.topNode)
            at2 = at2.parent;
          if (!at2)
            return null;
          let from = void 0;
          let { overrideIndentation } = cx.options;
          if (overrideIndentation) {
            from = IndentedFrom.get(cx.state);
            if (from != null && from < pos - 1e4)
              from = void 0;
          }
          let start = findState(this, tree, 0, at2.from, from !== null && from !== void 0 ? from : pos), statePos, state2;
          if (start) {
            state2 = start.state;
            statePos = start.pos + 1;
          } else {
            state2 = this.streamParser.startState(cx.unit);
            statePos = 0;
          }
          if (pos - statePos > 1e4)
            return null;
          while (statePos < pos) {
            let line2 = cx.state.doc.lineAt(statePos), end = Math.min(pos, line2.to);
            if (line2.length) {
              let indentation = overrideIndentation ? overrideIndentation(line2.from) : -1;
              let stream = new StringStream(line2.text, cx.state.tabSize, cx.unit, indentation < 0 ? void 0 : indentation);
              while (stream.pos < end - line2.from)
                readToken(this.streamParser.token, stream, state2);
            } else {
              this.streamParser.blankLine(state2, cx.unit);
            }
            if (end == pos)
              break;
            statePos = line2.to + 1;
          }
          let line = cx.lineAt(pos);
          if (overrideIndentation && from == null)
            IndentedFrom.set(cx.state, line.from);
          return this.streamParser.indent(state2, /^\s*(.*)/.exec(line.text)[1], cx);
        }
        get allowsNesting() {
          return false;
        }
      };
      function findState(lang, tree, off, startPos, before) {
        let state2 = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);
        if (state2)
          return { state: lang.streamParser.copyState(state2), pos: off + tree.length };
        for (let i = tree.children.length - 1; i >= 0; i--) {
          let child = tree.children[i], pos = off + tree.positions[i];
          let found = child instanceof common.Tree && pos < before && findState(lang, child, pos, startPos, before);
          if (found)
            return found;
        }
        return null;
      }
      function cutTree(lang, tree, from, to2, inside) {
        if (inside && from <= 0 && to2 >= tree.length)
          return tree;
        if (!inside && tree.type == lang.topNode)
          inside = true;
        for (let i = tree.children.length - 1; i >= 0; i--) {
          let pos = tree.positions[i], child = tree.children[i], inner;
          if (pos < to2 && child instanceof common.Tree) {
            if (!(inner = cutTree(lang, child, from - pos, to2 - pos, inside)))
              break;
            return !inside ? inner : new common.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);
          }
        }
        return null;
      }
      function findStartInFragments(lang, fragments, startPos, editorState) {
        for (let f of fragments) {
          let from = f.from + (f.openStart ? 25 : 0), to2 = f.to - (f.openEnd ? 25 : 0);
          let found = from <= startPos && to2 > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to2), tree;
          if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))
            return { state: found.state, tree };
        }
        return { state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4), tree: common.Tree.empty };
      }
      var Parse = class {
        constructor(lang, input, fragments, ranges) {
          this.lang = lang;
          this.input = input;
          this.fragments = fragments;
          this.ranges = ranges;
          this.stoppedAt = null;
          this.chunks = [];
          this.chunkPos = [];
          this.chunk = [];
          this.chunkReused = void 0;
          this.rangeIndex = 0;
          this.to = ranges[ranges.length - 1].to;
          let context = ParseContext.get(), from = ranges[0].from;
          let { state: state2, tree } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);
          this.state = state2;
          this.parsedPos = this.chunkStart = from + tree.length;
          for (let i = 0; i < tree.children.length; i++) {
            this.chunks.push(tree.children[i]);
            this.chunkPos.push(tree.positions[i]);
          }
          if (context && this.parsedPos < context.viewport.from - 1e5) {
            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));
            context.skipUntilInView(this.parsedPos, context.viewport.from);
            this.parsedPos = context.viewport.from;
          }
          this.moveRangeIndex();
        }
        advance() {
          let context = ParseContext.get();
          let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);
          let end = Math.min(parseEnd, this.chunkStart + 2048);
          if (context)
            end = Math.min(end, context.viewport.to);
          while (this.parsedPos < end)
            this.parseLine(context);
          if (this.chunkStart < this.parsedPos)
            this.finishChunk();
          if (this.parsedPos >= parseEnd)
            return this.finish();
          if (context && this.parsedPos >= context.viewport.to) {
            context.skipUntilInView(this.parsedPos, parseEnd);
            return this.finish();
          }
          return null;
        }
        stopAt(pos) {
          this.stoppedAt = pos;
        }
        lineAfter(pos) {
          let chunk = this.input.chunk(pos);
          if (!this.input.lineChunks) {
            let eol = chunk.indexOf("\n");
            if (eol > -1)
              chunk = chunk.slice(0, eol);
          } else if (chunk == "\n") {
            chunk = "";
          }
          return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);
        }
        nextLine() {
          let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;
          for (let index = this.rangeIndex; ; ) {
            let rangeEnd = this.ranges[index].to;
            if (rangeEnd >= end)
              break;
            line = line.slice(0, rangeEnd - (end - line.length));
            index++;
            if (index == this.ranges.length)
              break;
            let rangeStart = this.ranges[index].from;
            let after = this.lineAfter(rangeStart);
            line += after;
            end = rangeStart + after.length;
          }
          return { line, end };
        }
        skipGapsTo(pos, offset, side) {
          for (; ; ) {
            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;
            if (side > 0 ? end > offPos : end >= offPos)
              break;
            let start = this.ranges[++this.rangeIndex].from;
            offset += start - end;
          }
          return offset;
        }
        moveRangeIndex() {
          while (this.ranges[this.rangeIndex].to < this.parsedPos)
            this.rangeIndex++;
        }
        emitToken(id, from, to2, size, offset) {
          if (this.ranges.length > 1) {
            offset = this.skipGapsTo(from, offset, 1);
            from += offset;
            let len0 = this.chunk.length;
            offset = this.skipGapsTo(to2, offset, -1);
            to2 += offset;
            size += this.chunk.length - len0;
          }
          this.chunk.push(id, from, to2, size);
          return offset;
        }
        parseLine(context) {
          let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;
          let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);
          if (stream.eol()) {
            streamParser.blankLine(this.state, stream.indentUnit);
          } else {
            while (!stream.eol()) {
              let token = readToken(streamParser.token, stream, this.state);
              if (token)
                offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);
              if (stream.start > 1e4)
                break;
            }
          }
          this.parsedPos = end;
          this.moveRangeIndex();
          if (this.parsedPos < this.to)
            this.parsedPos++;
        }
        finishChunk() {
          let tree = common.Tree.build({
            buffer: this.chunk,
            start: this.chunkStart,
            length: this.parsedPos - this.chunkStart,
            nodeSet,
            topID: 0,
            maxBufferLength: 2048,
            reused: this.chunkReused
          });
          tree = new common.Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);
          this.chunks.push(tree);
          this.chunkPos.push(this.chunkStart - this.ranges[0].from);
          this.chunk = [];
          this.chunkReused = void 0;
          this.chunkStart = this.parsedPos;
        }
        finish() {
          return new common.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
        }
      };
      function readToken(token, stream, state2) {
        stream.start = stream.pos;
        for (let i = 0; i < 10; i++) {
          let result = token(stream, state2);
          if (stream.pos > stream.start)
            return result;
        }
        throw new Error("Stream parser failed to advance stream.");
      }
      var noTokens = Object.create(null);
      var typeArray = [common.NodeType.none];
      var nodeSet = new common.NodeSet(typeArray);
      var warned = [];
      var defaultTable = Object.create(null);
      for (let [legacyName, name] of [
        ["variable", "variableName"],
        ["variable-2", "variableName.special"],
        ["string-2", "string.special"],
        ["def", "variableName.definition"],
        ["tag", "tagName"],
        ["attribute", "attributeName"],
        ["type", "typeName"],
        ["builtin", "variableName.standard"],
        ["qualifier", "modifier"],
        ["error", "invalid"],
        ["header", "heading"],
        ["property", "propertyName"]
      ])
        defaultTable[legacyName] = createTokenType(noTokens, name);
      var TokenTable = class {
        constructor(extra) {
          this.extra = extra;
          this.table = Object.assign(Object.create(null), defaultTable);
        }
        resolve(tag) {
          return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));
        }
      };
      var defaultTokenTable = new TokenTable(noTokens);
      function warnForPart(part, msg) {
        if (warned.indexOf(part) > -1)
          return;
        warned.push(part);
        console.warn(msg);
      }
      function createTokenType(extra, tagStr) {
        let tag = null;
        for (let part of tagStr.split(".")) {
          let value = extra[part] || highlight.tags[part];
          if (!value) {
            warnForPart(part, `Unknown highlighting tag ${part}`);
          } else if (typeof value == "function") {
            if (!tag)
              warnForPart(part, `Modifier ${part} used at start of tag`);
            else
              tag = value(tag);
          } else {
            if (tag)
              warnForPart(part, `Tag ${part} used as modifier`);
            else
              tag = value;
          }
        }
        if (!tag)
          return 0;
        let name = tagStr.replace(/ /g, "_"), type = common.NodeType.define({
          id: typeArray.length,
          name,
          props: [highlight.styleTags({ [name]: tag })]
        });
        typeArray.push(type);
        return type.id;
      }
      function docID(data) {
        let type = common.NodeType.define({ id: typeArray.length, name: "Document", props: [languageDataProp.add(() => data)], top: true });
        typeArray.push(type);
        return type;
      }
      exports.DocInput = DocInput;
      exports.HighlightStyle = HighlightStyle;
      exports.IndentContext = IndentContext;
      exports.LRLanguage = LRLanguage;
      exports.Language = Language;
      exports.LanguageDescription = LanguageDescription;
      exports.LanguageSupport = LanguageSupport;
      exports.ParseContext = ParseContext;
      exports.StreamLanguage = StreamLanguage;
      exports.StringStream = StringStream;
      exports.TreeIndentContext = TreeIndentContext;
      exports.bracketMatching = bracketMatching;
      exports.bracketMatchingHandle = bracketMatchingHandle;
      exports.codeFolding = codeFolding;
      exports.continuedIndent = continuedIndent;
      exports.defaultHighlightStyle = defaultHighlightStyle;
      exports.defineLanguageFacet = defineLanguageFacet;
      exports.delimitedIndent = delimitedIndent;
      exports.ensureSyntaxTree = ensureSyntaxTree;
      exports.flatIndent = flatIndent;
      exports.foldAll = foldAll;
      exports.foldCode = foldCode;
      exports.foldEffect = foldEffect;
      exports.foldGutter = foldGutter;
      exports.foldInside = foldInside;
      exports.foldKeymap = foldKeymap;
      exports.foldNodeProp = foldNodeProp;
      exports.foldService = foldService;
      exports.foldState = foldState;
      exports.foldable = foldable;
      exports.foldedRanges = foldedRanges;
      exports.forceParsing = forceParsing;
      exports.getIndentUnit = getIndentUnit;
      exports.getIndentation = getIndentation;
      exports.highlightingFor = highlightingFor;
      exports.indentNodeProp = indentNodeProp;
      exports.indentOnInput = indentOnInput;
      exports.indentRange = indentRange;
      exports.indentService = indentService;
      exports.indentString = indentString;
      exports.indentUnit = indentUnit;
      exports.language = language;
      exports.languageDataProp = languageDataProp;
      exports.matchBrackets = matchBrackets;
      exports.sublanguageProp = sublanguageProp;
      exports.syntaxHighlighting = syntaxHighlighting;
      exports.syntaxParserRunning = syntaxParserRunning;
      exports.syntaxTree = syntaxTree;
      exports.syntaxTreeAvailable = syntaxTreeAvailable;
      exports.toggleFold = toggleFold;
      exports.unfoldAll = unfoldAll;
      exports.unfoldCode = unfoldCode;
      exports.unfoldEffect = unfoldEffect;
    }
  });

  // node_modules/@codemirror/commands/dist/index.cjs
  var require_dist6 = __commonJS({
    "node_modules/@codemirror/commands/dist/index.cjs"(exports) {
      "use strict";
      var state = require_dist();
      var view = require_dist2();
      var language = require_dist5();
      var common = require_dist3();
      var toggleComment = (target) => {
        let { state: state2 } = target, line = state2.doc.lineAt(state2.selection.main.from), config = getConfig(target.state, line.from);
        return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
      };
      function command(f, option) {
        return ({ state: state2, dispatch }) => {
          if (state2.readOnly)
            return false;
          let tr2 = f(option, state2);
          if (!tr2)
            return false;
          dispatch(state2.update(tr2));
          return true;
        };
      }
      var toggleLineComment = command(changeLineComment, 0);
      var lineComment = command(changeLineComment, 1);
      var lineUncomment = command(changeLineComment, 2);
      var toggleBlockComment = command(changeBlockComment, 0);
      var blockComment = command(changeBlockComment, 1);
      var blockUncomment = command(changeBlockComment, 2);
      var toggleBlockCommentByLine = command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0);
      function getConfig(state2, pos) {
        let data = state2.languageDataAt("commentTokens", pos);
        return data.length ? data[0] : {};
      }
      var SearchMargin = 50;
      function findBlockComment(state2, { open, close }, from, to2) {
        let textBefore = state2.sliceDoc(from - SearchMargin, from);
        let textAfter = state2.sliceDoc(to2, to2 + SearchMargin);
        let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
        let beforeOff = textBefore.length - spaceBefore;
        if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
          return {
            open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
            close: { pos: to2 + spaceAfter, margin: spaceAfter && 1 }
          };
        }
        let startText, endText;
        if (to2 - from <= 2 * SearchMargin) {
          startText = endText = state2.sliceDoc(from, to2);
        } else {
          startText = state2.sliceDoc(from, from + SearchMargin);
          endText = state2.sliceDoc(to2 - SearchMargin, to2);
        }
        let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
        let endOff = endText.length - endSpace - close.length;
        if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
          return {
            open: {
              pos: from + startSpace + open.length,
              margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
            },
            close: {
              pos: to2 - endSpace - close.length,
              margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
            }
          };
        }
        return null;
      }
      function selectedLineRanges(state2) {
        let ranges = [];
        for (let r of state2.selection.ranges) {
          let fromLine = state2.doc.lineAt(r.from);
          let toLine = r.to <= fromLine.to ? fromLine : state2.doc.lineAt(r.to);
          let last = ranges.length - 1;
          if (last >= 0 && ranges[last].to > fromLine.from)
            ranges[last].to = toLine.to;
          else
            ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
        }
        return ranges;
      }
      function changeBlockComment(option, state2, ranges = state2.selection.ranges) {
        let tokens = ranges.map((r) => getConfig(state2, r.from).block);
        if (!tokens.every((c2) => c2))
          return null;
        let comments = ranges.map((r, i) => findBlockComment(state2, tokens[i], r.from, r.to));
        if (option != 2 && !comments.every((c2) => c2)) {
          return { changes: state2.changes(ranges.map((range, i) => {
            if (comments[i])
              return [];
            return [{ from: range.from, insert: tokens[i].open + " " }, { from: range.to, insert: " " + tokens[i].close }];
          })) };
        } else if (option != 1 && comments.some((c2) => c2)) {
          let changes = [];
          for (let i = 0, comment; i < comments.length; i++)
            if (comment = comments[i]) {
              let token = tokens[i], { open, close } = comment;
              changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
            }
          return { changes };
        }
        return null;
      }
      function changeLineComment(option, state2, ranges = state2.selection.ranges) {
        let lines = [];
        let prevLine = -1;
        for (let { from, to: to2 } of ranges) {
          let startI = lines.length, minIndent = 1e9;
          let token = getConfig(state2, from).line;
          if (!token)
            continue;
          for (let pos = from; pos <= to2; ) {
            let line = state2.doc.lineAt(pos);
            if (line.from > prevLine && (from == to2 || to2 > line.from)) {
              prevLine = line.from;
              let indent = /^\s*/.exec(line.text)[0].length;
              let empty = indent == line.length;
              let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;
              if (indent < line.text.length && indent < minIndent)
                minIndent = indent;
              lines.push({ line, comment, token, indent, empty, single: false });
            }
            pos = line.to + 1;
          }
          if (minIndent < 1e9) {
            for (let i = startI; i < lines.length; i++)
              if (lines[i].indent < lines[i].line.text.length)
                lines[i].indent = minIndent;
          }
          if (lines.length == startI + 1)
            lines[startI].single = true;
        }
        if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
          let changes = [];
          for (let { line, token, indent, empty, single } of lines)
            if (single || !empty)
              changes.push({ from: line.from + indent, insert: token + " " });
          let changeSet = state2.changes(changes);
          return { changes: changeSet, selection: state2.selection.map(changeSet, 1) };
        } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
          let changes = [];
          for (let { line, comment, token } of lines)
            if (comment >= 0) {
              let from = line.from + comment, to2 = from + token.length;
              if (line.text[to2 - line.from] == " ")
                to2++;
              changes.push({ from, to: to2 });
            }
          return { changes };
        }
        return null;
      }
      var fromHistory = state.Annotation.define();
      var isolateHistory = state.Annotation.define();
      var invertedEffects = state.Facet.define();
      var historyConfig = state.Facet.define({
        combine(configs) {
          return state.combineConfig(configs, {
            minDepth: 100,
            newGroupDelay: 500,
            joinToEvent: (_t2, isAdjacent2) => isAdjacent2
          }, {
            minDepth: Math.max,
            newGroupDelay: Math.min,
            joinToEvent: (a, b) => (tr2, adj) => a(tr2, adj) || b(tr2, adj)
          });
        }
      });
      function changeEnd(changes) {
        let end = 0;
        changes.iterChangedRanges((_, to2) => end = to2);
        return end;
      }
      var historyField_ = state.StateField.define({
        create() {
          return HistoryState.empty;
        },
        update(state$1, tr2) {
          let config = tr2.state.facet(historyConfig);
          let fromHist = tr2.annotation(fromHistory);
          if (fromHist) {
            let selection = tr2.docChanged ? state.EditorSelection.single(changeEnd(tr2.changes)) : void 0;
            let item = HistEvent.fromTransaction(tr2, selection), from = fromHist.side;
            let other = from == 0 ? state$1.undone : state$1.done;
            if (item)
              other = updateBranch(other, other.length, config.minDepth, item);
            else
              other = addSelection(other, tr2.startState.selection);
            return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
          }
          let isolate = tr2.annotation(isolateHistory);
          if (isolate == "full" || isolate == "before")
            state$1 = state$1.isolate();
          if (tr2.annotation(state.Transaction.addToHistory) === false)
            return !tr2.changes.empty ? state$1.addMapping(tr2.changes.desc) : state$1;
          let event2 = HistEvent.fromTransaction(tr2);
          let time = tr2.annotation(state.Transaction.time), userEvent = tr2.annotation(state.Transaction.userEvent);
          if (event2)
            state$1 = state$1.addChanges(event2, time, userEvent, config, tr2);
          else if (tr2.selection)
            state$1 = state$1.addSelection(tr2.startState.selection, time, userEvent, config.newGroupDelay);
          if (isolate == "full" || isolate == "after")
            state$1 = state$1.isolate();
          return state$1;
        },
        toJSON(value) {
          return { done: value.done.map((e) => e.toJSON()), undone: value.undone.map((e) => e.toJSON()) };
        },
        fromJSON(json) {
          return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
        }
      });
      function history(config = {}) {
        return [
          historyField_,
          historyConfig.of(config),
          view.EditorView.domEventHandlers({
            beforeinput(e, view2) {
              let command2 = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
              if (!command2)
                return false;
              e.preventDefault();
              return command2(view2);
            }
          })
        ];
      }
      var historyField = historyField_;
      function cmd(side, selection) {
        return function({ state: state2, dispatch }) {
          if (!selection && state2.readOnly)
            return false;
          let historyState = state2.field(historyField_, false);
          if (!historyState)
            return false;
          let tr2 = historyState.pop(side, state2, selection);
          if (!tr2)
            return false;
          dispatch(tr2);
          return true;
        };
      }
      var undo = cmd(0, false);
      var redo = cmd(1, false);
      var undoSelection = cmd(0, true);
      var redoSelection = cmd(1, true);
      function depth(side) {
        return function(state2) {
          let histState = state2.field(historyField_, false);
          if (!histState)
            return 0;
          let branch = side == 0 ? histState.done : histState.undone;
          return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
        };
      }
      var undoDepth = depth(0);
      var redoDepth = depth(1);
      var HistEvent = class {
        constructor(changes, effects, mapped, startSelection, selectionsAfter) {
          this.changes = changes;
          this.effects = effects;
          this.mapped = mapped;
          this.startSelection = startSelection;
          this.selectionsAfter = selectionsAfter;
        }
        setSelAfter(after) {
          return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
        }
        toJSON() {
          var _a2, _b, _c2;
          return {
            changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
            startSelection: (_c2 = this.startSelection) === null || _c2 === void 0 ? void 0 : _c2.toJSON(),
            selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
          };
        }
        static fromJSON(json) {
          return new HistEvent(json.changes && state.ChangeSet.fromJSON(json.changes), [], json.mapped && state.ChangeDesc.fromJSON(json.mapped), json.startSelection && state.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(state.EditorSelection.fromJSON));
        }
        static fromTransaction(tr2, selection) {
          let effects = none;
          for (let invert of tr2.startState.facet(invertedEffects)) {
            let result = invert(tr2);
            if (result.length)
              effects = effects.concat(result);
          }
          if (!effects.length && tr2.changes.empty)
            return null;
          return new HistEvent(tr2.changes.invert(tr2.startState.doc), effects, void 0, selection || tr2.startState.selection, none);
        }
        static selection(selections) {
          return new HistEvent(void 0, none, void 0, void 0, selections);
        }
      };
      function updateBranch(branch, to2, maxLen, newEvent) {
        let start = to2 + 1 > maxLen + 20 ? to2 - maxLen - 1 : 0;
        let newBranch = branch.slice(start, to2);
        newBranch.push(newEvent);
        return newBranch;
      }
      function isAdjacent(a, b) {
        let ranges = [], isAdjacent2 = false;
        a.iterChangedRanges((f, t) => ranges.push(f, t));
        b.iterChangedRanges((_f, _t2, f, t) => {
          for (let i = 0; i < ranges.length; ) {
            let from = ranges[i++], to2 = ranges[i++];
            if (t >= from && f <= to2)
              isAdjacent2 = true;
          }
        });
        return isAdjacent2;
      }
      function eqSelectionShape(a, b) {
        return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
      }
      function conc(a, b) {
        return !a.length ? b : !b.length ? a : a.concat(b);
      }
      var none = [];
      var MaxSelectionsPerEvent = 200;
      function addSelection(branch, selection) {
        if (!branch.length) {
          return [HistEvent.selection([selection])];
        } else {
          let lastEvent = branch[branch.length - 1];
          let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
          if (sels.length && sels[sels.length - 1].eq(selection))
            return branch;
          sels.push(selection);
          return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
        }
      }
      function popSelection(branch) {
        let last = branch[branch.length - 1];
        let newBranch = branch.slice();
        newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
        return newBranch;
      }
      function addMappingToBranch(branch, mapping) {
        if (!branch.length)
          return branch;
        let length = branch.length, selections = none;
        while (length) {
          let event2 = mapEvent(branch[length - 1], mapping, selections);
          if (event2.changes && !event2.changes.empty || event2.effects.length) {
            let result = branch.slice(0, length);
            result[length - 1] = event2;
            return result;
          } else {
            mapping = event2.mapped;
            length--;
            selections = event2.selectionsAfter;
          }
        }
        return selections.length ? [HistEvent.selection(selections)] : none;
      }
      function mapEvent(event2, mapping, extraSelections) {
        let selections = conc(event2.selectionsAfter.length ? event2.selectionsAfter.map((s) => s.map(mapping)) : none, extraSelections);
        if (!event2.changes)
          return HistEvent.selection(selections);
        let mappedChanges = event2.changes.map(mapping), before = mapping.mapDesc(event2.changes, true);
        let fullMapping = event2.mapped ? event2.mapped.composeDesc(before) : before;
        return new HistEvent(mappedChanges, state.StateEffect.mapEffects(event2.effects, mapping), fullMapping, event2.startSelection.map(before), selections);
      }
      var joinableUserEvent = /^(input\.type|delete)($|\.)/;
      var HistoryState = class {
        constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
          this.done = done;
          this.undone = undone;
          this.prevTime = prevTime;
          this.prevUserEvent = prevUserEvent;
        }
        isolate() {
          return this.prevTime ? new HistoryState(this.done, this.undone) : this;
        }
        addChanges(event2, time, userEvent, config, tr2) {
          let done = this.done, lastEvent = done[done.length - 1];
          if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event2.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr2, isAdjacent(lastEvent.changes, event2.changes)) || userEvent == "input.type.compose")) {
            done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event2.changes.compose(lastEvent.changes), conc(event2.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));
          } else {
            done = updateBranch(done, done.length, config.minDepth, event2);
          }
          return new HistoryState(done, none, time, userEvent);
        }
        addSelection(selection, time, userEvent, newGroupDelay) {
          let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;
          if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection))
            return this;
          return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
        }
        addMapping(mapping) {
          return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
        }
        pop(side, state2, selection) {
          let branch = side == 0 ? this.done : this.undone;
          if (branch.length == 0)
            return null;
          let event2 = branch[branch.length - 1];
          if (selection && event2.selectionsAfter.length) {
            return state2.update({
              selection: event2.selectionsAfter[event2.selectionsAfter.length - 1],
              annotations: fromHistory.of({ side, rest: popSelection(branch) }),
              userEvent: side == 0 ? "select.undo" : "select.redo",
              scrollIntoView: true
            });
          } else if (!event2.changes) {
            return null;
          } else {
            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);
            if (event2.mapped)
              rest = addMappingToBranch(rest, event2.mapped);
            return state2.update({
              changes: event2.changes,
              selection: event2.startSelection,
              effects: event2.effects,
              annotations: fromHistory.of({ side, rest }),
              filter: false,
              userEvent: side == 0 ? "undo" : "redo",
              scrollIntoView: true
            });
          }
        }
      };
      HistoryState.empty = new HistoryState(none, none);
      var historyKeymap = [
        { key: "Mod-z", run: undo, preventDefault: true },
        { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
        { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
        { key: "Mod-u", run: undoSelection, preventDefault: true },
        { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
      ];
      function updateSel(sel, by) {
        return state.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
      }
      function setSel(state2, selection) {
        return state2.update({ selection, scrollIntoView: true, userEvent: "select" });
      }
      function moveSel({ state: state2, dispatch }, how) {
        let selection = updateSel(state2.selection, how);
        if (selection.eq(state2.selection))
          return false;
        dispatch(setSel(state2, selection));
        return true;
      }
      function rangeEnd(range, forward) {
        return state.EditorSelection.cursor(forward ? range.to : range.from);
      }
      function cursorByChar(view2, forward) {
        return moveSel(view2, (range) => range.empty ? view2.moveByChar(range, forward) : rangeEnd(range, forward));
      }
      function ltrAtCursor(view$1) {
        return view$1.textDirectionAt(view$1.state.selection.main.head) == view.Direction.LTR;
      }
      var cursorCharLeft = (view2) => cursorByChar(view2, !ltrAtCursor(view2));
      var cursorCharRight = (view2) => cursorByChar(view2, ltrAtCursor(view2));
      var cursorCharForward = (view2) => cursorByChar(view2, true);
      var cursorCharBackward = (view2) => cursorByChar(view2, false);
      function cursorByGroup(view2, forward) {
        return moveSel(view2, (range) => range.empty ? view2.moveByGroup(range, forward) : rangeEnd(range, forward));
      }
      var cursorGroupLeft = (view2) => cursorByGroup(view2, !ltrAtCursor(view2));
      var cursorGroupRight = (view2) => cursorByGroup(view2, ltrAtCursor(view2));
      var cursorGroupForward = (view2) => cursorByGroup(view2, true);
      var cursorGroupBackward = (view2) => cursorByGroup(view2, false);
      var segmenter = typeof Intl != "undefined" && Intl.Segmenter ? new Intl.Segmenter(void 0, { granularity: "word" }) : null;
      function moveBySubword(view2, range, forward) {
        let categorize = view2.state.charCategorizer(range.from);
        let cat = state.CharCategory.Space, pos = range.from, steps = 0;
        let done = false, sawUpper = false, sawLower = false;
        let step = (next) => {
          if (done)
            return false;
          pos += forward ? next.length : -next.length;
          let nextCat = categorize(next), ahead;
          if (nextCat == state.CharCategory.Word && next.charCodeAt(0) < 128 && /[\W_]/.test(next))
            nextCat = -1;
          if (cat == state.CharCategory.Space)
            cat = nextCat;
          if (cat != nextCat)
            return false;
          if (cat == state.CharCategory.Word) {
            if (next.toLowerCase() == next) {
              if (!forward && sawUpper)
                return false;
              sawLower = true;
            } else if (sawLower) {
              if (forward)
                return false;
              done = true;
            } else {
              if (sawUpper && forward && categorize(ahead = view2.state.sliceDoc(pos, pos + 1)) == state.CharCategory.Word && ahead.toLowerCase() == ahead)
                return false;
              sawUpper = true;
            }
          }
          steps++;
          return true;
        };
        let end = view2.moveByChar(range, forward, (start) => {
          step(start);
          return step;
        });
        if (segmenter && cat == state.CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {
          let from = Math.min(range.head, end.head), to2 = Math.max(range.head, end.head);
          let skipped = view2.state.sliceDoc(from, to2);
          if (skipped.length > 1 && /[\u4E00-\uffff]/.test(skipped)) {
            let segments = Array.from(segmenter.segment(skipped));
            if (segments.length > 1) {
              if (forward)
                return state.EditorSelection.cursor(range.head + segments[1].index, -1);
              return state.EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);
            }
          }
        }
        return end;
      }
      function cursorBySubword(view2, forward) {
        return moveSel(view2, (range) => range.empty ? moveBySubword(view2, range, forward) : rangeEnd(range, forward));
      }
      var cursorSubwordForward = (view2) => cursorBySubword(view2, true);
      var cursorSubwordBackward = (view2) => cursorBySubword(view2, false);
      function interestingNode(state2, node, bracketProp) {
        if (node.type.prop(bracketProp))
          return true;
        let len = node.to - node.from;
        return len && (len > 2 || /[^\s,.;:]/.test(state2.sliceDoc(node.from, node.to))) || node.firstChild;
      }
      function moveBySyntax(state$1, start, forward) {
        let pos = language.syntaxTree(state$1).resolveInner(start.head);
        let bracketProp = forward ? common.NodeProp.closedBy : common.NodeProp.openedBy;
        for (let at2 = start.head; ; ) {
          let next = forward ? pos.childAfter(at2) : pos.childBefore(at2);
          if (!next)
            break;
          if (interestingNode(state$1, next, bracketProp))
            pos = next;
          else
            at2 = forward ? next.to : next.from;
        }
        let bracket = pos.type.prop(bracketProp), match, newPos;
        if (bracket && (match = forward ? language.matchBrackets(state$1, pos.from, 1) : language.matchBrackets(state$1, pos.to, -1)) && match.matched)
          newPos = forward ? match.end.to : match.end.from;
        else
          newPos = forward ? pos.to : pos.from;
        return state.EditorSelection.cursor(newPos, forward ? -1 : 1);
      }
      var cursorSyntaxLeft = (view2) => moveSel(view2, (range) => moveBySyntax(view2.state, range, !ltrAtCursor(view2)));
      var cursorSyntaxRight = (view2) => moveSel(view2, (range) => moveBySyntax(view2.state, range, ltrAtCursor(view2)));
      function cursorByLine(view2, forward) {
        return moveSel(view2, (range) => {
          if (!range.empty)
            return rangeEnd(range, forward);
          let moved = view2.moveVertically(range, forward);
          return moved.head != range.head ? moved : view2.moveToLineBoundary(range, forward);
        });
      }
      var cursorLineUp = (view2) => cursorByLine(view2, false);
      var cursorLineDown = (view2) => cursorByLine(view2, true);
      function pageInfo(view$1) {
        let selfScroll = view$1.scrollDOM.clientHeight < view$1.scrollDOM.scrollHeight - 2;
        let marginTop = 0, marginBottom = 0, height;
        if (selfScroll) {
          for (let source of view$1.state.facet(view.EditorView.scrollMargins)) {
            let margins = source(view$1);
            if (margins === null || margins === void 0 ? void 0 : margins.top)
              marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
            if (margins === null || margins === void 0 ? void 0 : margins.bottom)
              marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
          }
          height = view$1.scrollDOM.clientHeight - marginTop - marginBottom;
        } else {
          height = (view$1.dom.ownerDocument.defaultView || window).innerHeight;
        }
        return {
          marginTop,
          marginBottom,
          selfScroll,
          height: Math.max(view$1.defaultLineHeight, height - 5)
        };
      }
      function cursorByPage(view$1, forward) {
        let page = pageInfo(view$1);
        let { state: state2 } = view$1, selection = updateSel(state2.selection, (range) => {
          return range.empty ? view$1.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
        });
        if (selection.eq(state2.selection))
          return false;
        let effect;
        if (page.selfScroll) {
          let startPos = view$1.coordsAtPos(state2.selection.main.head);
          let scrollRect = view$1.scrollDOM.getBoundingClientRect();
          let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
          if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
            effect = view.EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollTop });
        }
        view$1.dispatch(setSel(state2, selection), { effects: effect });
        return true;
      }
      var cursorPageUp = (view2) => cursorByPage(view2, false);
      var cursorPageDown = (view2) => cursorByPage(view2, true);
      function moveByLineBoundary(view2, start, forward) {
        let line = view2.lineBlockAt(start.head), moved = view2.moveToLineBoundary(start, forward);
        if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
          moved = view2.moveToLineBoundary(start, forward, false);
        if (!forward && moved.head == line.from && line.length) {
          let space = /^\s*/.exec(view2.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
          if (space && start.head != line.from + space)
            moved = state.EditorSelection.cursor(line.from + space);
        }
        return moved;
      }
      var cursorLineBoundaryForward = (view2) => moveSel(view2, (range) => moveByLineBoundary(view2, range, true));
      var cursorLineBoundaryBackward = (view2) => moveSel(view2, (range) => moveByLineBoundary(view2, range, false));
      var cursorLineBoundaryLeft = (view2) => moveSel(view2, (range) => moveByLineBoundary(view2, range, !ltrAtCursor(view2)));
      var cursorLineBoundaryRight = (view2) => moveSel(view2, (range) => moveByLineBoundary(view2, range, ltrAtCursor(view2)));
      var cursorLineStart = (view2) => moveSel(view2, (range) => state.EditorSelection.cursor(view2.lineBlockAt(range.head).from, 1));
      var cursorLineEnd = (view2) => moveSel(view2, (range) => state.EditorSelection.cursor(view2.lineBlockAt(range.head).to, -1));
      function toMatchingBracket(state$1, dispatch, extend) {
        let found = false, selection = updateSel(state$1.selection, (range) => {
          let matching = language.matchBrackets(state$1, range.head, -1) || language.matchBrackets(state$1, range.head, 1) || range.head > 0 && language.matchBrackets(state$1, range.head - 1, 1) || range.head < state$1.doc.length && language.matchBrackets(state$1, range.head + 1, -1);
          if (!matching || !matching.end)
            return range;
          found = true;
          let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
          return extend ? state.EditorSelection.range(range.anchor, head) : state.EditorSelection.cursor(head);
        });
        if (!found)
          return false;
        dispatch(setSel(state$1, selection));
        return true;
      }
      var cursorMatchingBracket = ({ state: state2, dispatch }) => toMatchingBracket(state2, dispatch, false);
      var selectMatchingBracket = ({ state: state2, dispatch }) => toMatchingBracket(state2, dispatch, true);
      function extendSel(view2, how) {
        let selection = updateSel(view2.state.selection, (range) => {
          let head = how(range);
          return state.EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
        });
        if (selection.eq(view2.state.selection))
          return false;
        view2.dispatch(setSel(view2.state, selection));
        return true;
      }
      function selectByChar(view2, forward) {
        return extendSel(view2, (range) => view2.moveByChar(range, forward));
      }
      var selectCharLeft = (view2) => selectByChar(view2, !ltrAtCursor(view2));
      var selectCharRight = (view2) => selectByChar(view2, ltrAtCursor(view2));
      var selectCharForward = (view2) => selectByChar(view2, true);
      var selectCharBackward = (view2) => selectByChar(view2, false);
      function selectByGroup(view2, forward) {
        return extendSel(view2, (range) => view2.moveByGroup(range, forward));
      }
      var selectGroupLeft = (view2) => selectByGroup(view2, !ltrAtCursor(view2));
      var selectGroupRight = (view2) => selectByGroup(view2, ltrAtCursor(view2));
      var selectGroupForward = (view2) => selectByGroup(view2, true);
      var selectGroupBackward = (view2) => selectByGroup(view2, false);
      function selectBySubword(view2, forward) {
        return extendSel(view2, (range) => moveBySubword(view2, range, forward));
      }
      var selectSubwordForward = (view2) => selectBySubword(view2, true);
      var selectSubwordBackward = (view2) => selectBySubword(view2, false);
      var selectSyntaxLeft = (view2) => extendSel(view2, (range) => moveBySyntax(view2.state, range, !ltrAtCursor(view2)));
      var selectSyntaxRight = (view2) => extendSel(view2, (range) => moveBySyntax(view2.state, range, ltrAtCursor(view2)));
      function selectByLine(view2, forward) {
        return extendSel(view2, (range) => view2.moveVertically(range, forward));
      }
      var selectLineUp = (view2) => selectByLine(view2, false);
      var selectLineDown = (view2) => selectByLine(view2, true);
      function selectByPage(view2, forward) {
        return extendSel(view2, (range) => view2.moveVertically(range, forward, pageInfo(view2).height));
      }
      var selectPageUp = (view2) => selectByPage(view2, false);
      var selectPageDown = (view2) => selectByPage(view2, true);
      var selectLineBoundaryForward = (view2) => extendSel(view2, (range) => moveByLineBoundary(view2, range, true));
      var selectLineBoundaryBackward = (view2) => extendSel(view2, (range) => moveByLineBoundary(view2, range, false));
      var selectLineBoundaryLeft = (view2) => extendSel(view2, (range) => moveByLineBoundary(view2, range, !ltrAtCursor(view2)));
      var selectLineBoundaryRight = (view2) => extendSel(view2, (range) => moveByLineBoundary(view2, range, ltrAtCursor(view2)));
      var selectLineStart = (view2) => extendSel(view2, (range) => state.EditorSelection.cursor(view2.lineBlockAt(range.head).from));
      var selectLineEnd = (view2) => extendSel(view2, (range) => state.EditorSelection.cursor(view2.lineBlockAt(range.head).to));
      var cursorDocStart = ({ state: state2, dispatch }) => {
        dispatch(setSel(state2, { anchor: 0 }));
        return true;
      };
      var cursorDocEnd = ({ state: state2, dispatch }) => {
        dispatch(setSel(state2, { anchor: state2.doc.length }));
        return true;
      };
      var selectDocStart = ({ state: state2, dispatch }) => {
        dispatch(setSel(state2, { anchor: state2.selection.main.anchor, head: 0 }));
        return true;
      };
      var selectDocEnd = ({ state: state2, dispatch }) => {
        dispatch(setSel(state2, { anchor: state2.selection.main.anchor, head: state2.doc.length }));
        return true;
      };
      var selectAll = ({ state: state2, dispatch }) => {
        dispatch(state2.update({ selection: { anchor: 0, head: state2.doc.length }, userEvent: "select" }));
        return true;
      };
      var selectLine = ({ state: state$1, dispatch }) => {
        let ranges = selectedLineBlocks(state$1).map(({ from, to: to2 }) => state.EditorSelection.range(from, Math.min(to2 + 1, state$1.doc.length)));
        dispatch(state$1.update({ selection: state.EditorSelection.create(ranges), userEvent: "select" }));
        return true;
      };
      var selectParentSyntax = ({ state: state$1, dispatch }) => {
        let selection = updateSel(state$1.selection, (range) => {
          var _a2;
          let context = language.syntaxTree(state$1).resolveInner(range.head, 1);
          while (!(context.from < range.from && context.to >= range.to || context.to > range.to && context.from <= range.from || !((_a2 = context.parent) === null || _a2 === void 0 ? void 0 : _a2.parent)))
            context = context.parent;
          return state.EditorSelection.range(context.to, context.from);
        });
        dispatch(setSel(state$1, selection));
        return true;
      };
      var simplifySelection = ({ state: state$1, dispatch }) => {
        let cur = state$1.selection, selection = null;
        if (cur.ranges.length > 1)
          selection = state.EditorSelection.create([cur.main]);
        else if (!cur.main.empty)
          selection = state.EditorSelection.create([state.EditorSelection.cursor(cur.main.head)]);
        if (!selection)
          return false;
        dispatch(setSel(state$1, selection));
        return true;
      };
      function deleteBy(target, by) {
        if (target.state.readOnly)
          return false;
        let event2 = "delete.selection", { state: state$1 } = target;
        let changes = state$1.changeByRange((range) => {
          let { from, to: to2 } = range;
          if (from == to2) {
            let towards = by(from);
            if (towards < from) {
              event2 = "delete.backward";
              towards = skipAtomic(target, towards, false);
            } else if (towards > from) {
              event2 = "delete.forward";
              towards = skipAtomic(target, towards, true);
            }
            from = Math.min(from, towards);
            to2 = Math.max(to2, towards);
          } else {
            from = skipAtomic(target, from, false);
            to2 = skipAtomic(target, to2, true);
          }
          return from == to2 ? { range } : { changes: { from, to: to2 }, range: state.EditorSelection.cursor(from) };
        });
        if (changes.changes.empty)
          return false;
        target.dispatch(state$1.update(changes, {
          scrollIntoView: true,
          userEvent: event2,
          effects: event2 == "delete.selection" ? view.EditorView.announce.of(state$1.phrase("Selection deleted")) : void 0
        }));
        return true;
      }
      function skipAtomic(target, pos, forward) {
        if (target instanceof view.EditorView)
          for (let ranges of target.state.facet(view.EditorView.atomicRanges).map((f) => f(target)))
            ranges.between(pos, pos, (from, to2) => {
              if (from < pos && to2 > pos)
                pos = forward ? to2 : from;
            });
        return pos;
      }
      var deleteByChar = (target, forward) => deleteBy(target, (pos) => {
        let { state: state$1 } = target, line = state$1.doc.lineAt(pos), before, targetPos;
        if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
          if (before[before.length - 1] == "	")
            return pos - 1;
          let col = state.countColumn(before, state$1.tabSize), drop = col % language.getIndentUnit(state$1) || language.getIndentUnit(state$1);
          for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
            pos--;
          targetPos = pos;
        } else {
          targetPos = state.findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
          if (targetPos == pos && line.number != (forward ? state$1.doc.lines : 1))
            targetPos += forward ? 1 : -1;
        }
        return targetPos;
      });
      var deleteCharBackward = (view2) => deleteByChar(view2, false);
      var deleteCharForward = (view2) => deleteByChar(view2, true);
      var deleteByGroup = (target, forward) => deleteBy(target, (start) => {
        let pos = start, { state: state$1 } = target, line = state$1.doc.lineAt(pos);
        let categorize = state$1.charCategorizer(pos);
        for (let cat = null; ; ) {
          if (pos == (forward ? line.to : line.from)) {
            if (pos == start && line.number != (forward ? state$1.doc.lines : 1))
              pos += forward ? 1 : -1;
            break;
          }
          let next = state.findClusterBreak(line.text, pos - line.from, forward) + line.from;
          let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
          let nextCat = categorize(nextChar);
          if (cat != null && nextCat != cat)
            break;
          if (nextChar != " " || pos != start)
            cat = nextCat;
          pos = next;
        }
        return pos;
      });
      var deleteGroupBackward = (target) => deleteByGroup(target, false);
      var deleteGroupForward = (target) => deleteByGroup(target, true);
      var deleteToLineEnd = (view2) => deleteBy(view2, (pos) => {
        let lineEnd = view2.lineBlockAt(pos).to;
        return pos < lineEnd ? lineEnd : Math.min(view2.state.doc.length, pos + 1);
      });
      var deleteToLineStart = (view2) => deleteBy(view2, (pos) => {
        let lineStart = view2.lineBlockAt(pos).from;
        return pos > lineStart ? lineStart : Math.max(0, pos - 1);
      });
      var deleteTrailingWhitespace = ({ state: state2, dispatch }) => {
        if (state2.readOnly)
          return false;
        let changes = [];
        for (let pos = 0, prev = "", iter = state2.doc.iter(); ; ) {
          iter.next();
          if (iter.lineBreak || iter.done) {
            let trailing = prev.search(/\s+$/);
            if (trailing > -1)
              changes.push({ from: pos - (prev.length - trailing), to: pos });
            if (iter.done)
              break;
            prev = "";
          } else {
            prev = iter.value;
          }
          pos += iter.value.length;
        }
        if (!changes.length)
          return false;
        dispatch(state2.update({ changes, userEvent: "delete" }));
        return true;
      };
      var splitLine = ({ state: state$1, dispatch }) => {
        if (state$1.readOnly)
          return false;
        let changes = state$1.changeByRange((range) => {
          return {
            changes: { from: range.from, to: range.to, insert: state.Text.of(["", ""]) },
            range: state.EditorSelection.cursor(range.from)
          };
        });
        dispatch(state$1.update(changes, { scrollIntoView: true, userEvent: "input" }));
        return true;
      };
      var transposeChars = ({ state: state$1, dispatch }) => {
        if (state$1.readOnly)
          return false;
        let changes = state$1.changeByRange((range) => {
          if (!range.empty || range.from == 0 || range.from == state$1.doc.length)
            return { range };
          let pos = range.from, line = state$1.doc.lineAt(pos);
          let from = pos == line.from ? pos - 1 : state.findClusterBreak(line.text, pos - line.from, false) + line.from;
          let to2 = pos == line.to ? pos + 1 : state.findClusterBreak(line.text, pos - line.from, true) + line.from;
          return {
            changes: { from, to: to2, insert: state$1.doc.slice(pos, to2).append(state$1.doc.slice(from, pos)) },
            range: state.EditorSelection.cursor(to2)
          };
        });
        if (changes.changes.empty)
          return false;
        dispatch(state$1.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
        return true;
      };
      function selectedLineBlocks(state2) {
        let blocks = [], upto = -1;
        for (let range of state2.selection.ranges) {
          let startLine = state2.doc.lineAt(range.from), endLine = state2.doc.lineAt(range.to);
          if (!range.empty && range.to == endLine.from)
            endLine = state2.doc.lineAt(range.to - 1);
          if (upto >= startLine.number) {
            let prev = blocks[blocks.length - 1];
            prev.to = endLine.to;
            prev.ranges.push(range);
          } else {
            blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
          }
          upto = endLine.number + 1;
        }
        return blocks;
      }
      function moveLine(state$1, dispatch, forward) {
        if (state$1.readOnly)
          return false;
        let changes = [], ranges = [];
        for (let block of selectedLineBlocks(state$1)) {
          if (forward ? block.to == state$1.doc.length : block.from == 0)
            continue;
          let nextLine = state$1.doc.lineAt(forward ? block.to + 1 : block.from - 1);
          let size = nextLine.length + 1;
          if (forward) {
            changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state$1.lineBreak });
            for (let r of block.ranges)
              ranges.push(state.EditorSelection.range(Math.min(state$1.doc.length, r.anchor + size), Math.min(state$1.doc.length, r.head + size)));
          } else {
            changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state$1.lineBreak + nextLine.text });
            for (let r of block.ranges)
              ranges.push(state.EditorSelection.range(r.anchor - size, r.head - size));
          }
        }
        if (!changes.length)
          return false;
        dispatch(state$1.update({
          changes,
          scrollIntoView: true,
          selection: state.EditorSelection.create(ranges, state$1.selection.mainIndex),
          userEvent: "move.line"
        }));
        return true;
      }
      var moveLineUp = ({ state: state2, dispatch }) => moveLine(state2, dispatch, false);
      var moveLineDown = ({ state: state2, dispatch }) => moveLine(state2, dispatch, true);
      function copyLine(state2, dispatch, forward) {
        if (state2.readOnly)
          return false;
        let changes = [];
        for (let block of selectedLineBlocks(state2)) {
          if (forward)
            changes.push({ from: block.from, insert: state2.doc.slice(block.from, block.to) + state2.lineBreak });
          else
            changes.push({ from: block.to, insert: state2.lineBreak + state2.doc.slice(block.from, block.to) });
        }
        dispatch(state2.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
        return true;
      }
      var copyLineUp = ({ state: state2, dispatch }) => copyLine(state2, dispatch, false);
      var copyLineDown = ({ state: state2, dispatch }) => copyLine(state2, dispatch, true);
      var deleteLine = (view2) => {
        if (view2.state.readOnly)
          return false;
        let { state: state2 } = view2, changes = state2.changes(selectedLineBlocks(state2).map(({ from, to: to2 }) => {
          if (from > 0)
            from--;
          else if (to2 < state2.doc.length)
            to2++;
          return { from, to: to2 };
        }));
        let selection = updateSel(state2.selection, (range) => view2.moveVertically(range, true)).map(changes);
        view2.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
        return true;
      };
      var insertNewline = ({ state: state2, dispatch }) => {
        dispatch(state2.update(state2.replaceSelection(state2.lineBreak), { scrollIntoView: true, userEvent: "input" }));
        return true;
      };
      function isBetweenBrackets(state2, pos) {
        if (/\(\)|\[\]|\{\}/.test(state2.sliceDoc(pos - 1, pos + 1)))
          return { from: pos, to: pos };
        let context = language.syntaxTree(state2).resolveInner(pos);
        let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
        if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(common.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state2.doc.lineAt(before.to).from == state2.doc.lineAt(after.from).from && !/\S/.test(state2.sliceDoc(before.to, after.from)))
          return { from: before.to, to: after.from };
        return null;
      }
      var insertNewlineAndIndent = newlineAndIndent(false);
      var insertBlankLine = newlineAndIndent(true);
      function newlineAndIndent(atEof) {
        return ({ state: state$1, dispatch }) => {
          if (state$1.readOnly)
            return false;
          let changes = state$1.changeByRange((range) => {
            let { from, to: to2 } = range, line = state$1.doc.lineAt(from);
            let explode = !atEof && from == to2 && isBetweenBrackets(state$1, from);
            if (atEof)
              from = to2 = (to2 <= line.to ? line : state$1.doc.lineAt(to2)).to;
            let cx = new language.IndentContext(state$1, { simulateBreak: from, simulateDoubleBreak: !!explode });
            let indent = language.getIndentation(cx, from);
            if (indent == null)
              indent = state.countColumn(/^\s*/.exec(state$1.doc.lineAt(from).text)[0], state$1.tabSize);
            while (to2 < line.to && /\s/.test(line.text[to2 - line.from]))
              to2++;
            if (explode)
              ({ from, to: to2 } = explode);
            else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
              from = line.from;
            let insert = ["", language.indentString(state$1, indent)];
            if (explode)
              insert.push(language.indentString(state$1, cx.lineIndent(line.from, -1)));
            return {
              changes: { from, to: to2, insert: state.Text.of(insert) },
              range: state.EditorSelection.cursor(from + 1 + insert[1].length)
            };
          });
          dispatch(state$1.update(changes, { scrollIntoView: true, userEvent: "input" }));
          return true;
        };
      }
      function changeBySelectedLine(state$1, f) {
        let atLine = -1;
        return state$1.changeByRange((range) => {
          let changes = [];
          for (let pos = range.from; pos <= range.to; ) {
            let line = state$1.doc.lineAt(pos);
            if (line.number > atLine && (range.empty || range.to > line.from)) {
              f(line, changes, range);
              atLine = line.number;
            }
            pos = line.to + 1;
          }
          let changeSet = state$1.changes(changes);
          return {
            changes,
            range: state.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
          };
        });
      }
      var indentSelection = ({ state: state2, dispatch }) => {
        if (state2.readOnly)
          return false;
        let updated = Object.create(null);
        let context = new language.IndentContext(state2, { overrideIndentation: (start) => {
          let found = updated[start];
          return found == null ? -1 : found;
        } });
        let changes = changeBySelectedLine(state2, (line, changes2, range) => {
          let indent = language.getIndentation(context, line.from);
          if (indent == null)
            return;
          if (!/\S/.test(line.text))
            indent = 0;
          let cur = /^\s*/.exec(line.text)[0];
          let norm = language.indentString(state2, indent);
          if (cur != norm || range.from < line.from + cur.length) {
            updated[line.from] = indent;
            changes2.push({ from: line.from, to: line.from + cur.length, insert: norm });
          }
        });
        if (!changes.changes.empty)
          dispatch(state2.update(changes, { userEvent: "indent" }));
        return true;
      };
      var indentMore = ({ state: state2, dispatch }) => {
        if (state2.readOnly)
          return false;
        dispatch(state2.update(changeBySelectedLine(state2, (line, changes) => {
          changes.push({ from: line.from, insert: state2.facet(language.indentUnit) });
        }), { userEvent: "input.indent" }));
        return true;
      };
      var indentLess = ({ state: state$1, dispatch }) => {
        if (state$1.readOnly)
          return false;
        dispatch(state$1.update(changeBySelectedLine(state$1, (line, changes) => {
          let space = /^\s*/.exec(line.text)[0];
          if (!space)
            return;
          let col = state.countColumn(space, state$1.tabSize), keep = 0;
          let insert = language.indentString(state$1, Math.max(0, col - language.getIndentUnit(state$1)));
          while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))
            keep++;
          changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });
        }), { userEvent: "delete.dedent" }));
        return true;
      };
      var insertTab = ({ state: state2, dispatch }) => {
        if (state2.selection.ranges.some((r) => !r.empty))
          return indentMore({ state: state2, dispatch });
        dispatch(state2.update(state2.replaceSelection("	"), { scrollIntoView: true, userEvent: "input" }));
        return true;
      };
      var emacsStyleKeymap = [
        { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
        { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
        { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
        { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
        { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
        { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
        { key: "Ctrl-d", run: deleteCharForward },
        { key: "Ctrl-h", run: deleteCharBackward },
        { key: "Ctrl-k", run: deleteToLineEnd },
        { key: "Ctrl-Alt-h", run: deleteGroupBackward },
        { key: "Ctrl-o", run: splitLine },
        { key: "Ctrl-t", run: transposeChars },
        { key: "Ctrl-v", run: cursorPageDown }
      ];
      var standardKeymap = [
        { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
        { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
        { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
        { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
        { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
        { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
        { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
        { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
        { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
        { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
        { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
        { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
        { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
        { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
        { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
        { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
        { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
        { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
        { key: "Enter", run: insertNewlineAndIndent },
        { key: "Mod-a", run: selectAll },
        { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
        { key: "Delete", run: deleteCharForward },
        { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
        { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
        { mac: "Mod-Backspace", run: deleteToLineStart },
        { mac: "Mod-Delete", run: deleteToLineEnd }
      ].concat(emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
      var defaultKeymap = [
        { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
        { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
        { key: "Alt-ArrowUp", run: moveLineUp },
        { key: "Shift-Alt-ArrowUp", run: copyLineUp },
        { key: "Alt-ArrowDown", run: moveLineDown },
        { key: "Shift-Alt-ArrowDown", run: copyLineDown },
        { key: "Escape", run: simplifySelection },
        { key: "Mod-Enter", run: insertBlankLine },
        { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
        { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
        { key: "Mod-[", run: indentLess },
        { key: "Mod-]", run: indentMore },
        { key: "Mod-Alt-\\", run: indentSelection },
        { key: "Shift-Mod-k", run: deleteLine },
        { key: "Shift-Mod-\\", run: cursorMatchingBracket },
        { key: "Mod-/", run: toggleComment },
        { key: "Alt-A", run: toggleBlockComment }
      ].concat(standardKeymap);
      var indentWithTab = { key: "Tab", run: indentMore, shift: indentLess };
      exports.blockComment = blockComment;
      exports.blockUncomment = blockUncomment;
      exports.copyLineDown = copyLineDown;
      exports.copyLineUp = copyLineUp;
      exports.cursorCharBackward = cursorCharBackward;
      exports.cursorCharForward = cursorCharForward;
      exports.cursorCharLeft = cursorCharLeft;
      exports.cursorCharRight = cursorCharRight;
      exports.cursorDocEnd = cursorDocEnd;
      exports.cursorDocStart = cursorDocStart;
      exports.cursorGroupBackward = cursorGroupBackward;
      exports.cursorGroupForward = cursorGroupForward;
      exports.cursorGroupLeft = cursorGroupLeft;
      exports.cursorGroupRight = cursorGroupRight;
      exports.cursorLineBoundaryBackward = cursorLineBoundaryBackward;
      exports.cursorLineBoundaryForward = cursorLineBoundaryForward;
      exports.cursorLineBoundaryLeft = cursorLineBoundaryLeft;
      exports.cursorLineBoundaryRight = cursorLineBoundaryRight;
      exports.cursorLineDown = cursorLineDown;
      exports.cursorLineEnd = cursorLineEnd;
      exports.cursorLineStart = cursorLineStart;
      exports.cursorLineUp = cursorLineUp;
      exports.cursorMatchingBracket = cursorMatchingBracket;
      exports.cursorPageDown = cursorPageDown;
      exports.cursorPageUp = cursorPageUp;
      exports.cursorSubwordBackward = cursorSubwordBackward;
      exports.cursorSubwordForward = cursorSubwordForward;
      exports.cursorSyntaxLeft = cursorSyntaxLeft;
      exports.cursorSyntaxRight = cursorSyntaxRight;
      exports.defaultKeymap = defaultKeymap;
      exports.deleteCharBackward = deleteCharBackward;
      exports.deleteCharForward = deleteCharForward;
      exports.deleteGroupBackward = deleteGroupBackward;
      exports.deleteGroupForward = deleteGroupForward;
      exports.deleteLine = deleteLine;
      exports.deleteToLineEnd = deleteToLineEnd;
      exports.deleteToLineStart = deleteToLineStart;
      exports.deleteTrailingWhitespace = deleteTrailingWhitespace;
      exports.emacsStyleKeymap = emacsStyleKeymap;
      exports.history = history;
      exports.historyField = historyField;
      exports.historyKeymap = historyKeymap;
      exports.indentLess = indentLess;
      exports.indentMore = indentMore;
      exports.indentSelection = indentSelection;
      exports.indentWithTab = indentWithTab;
      exports.insertBlankLine = insertBlankLine;
      exports.insertNewline = insertNewline;
      exports.insertNewlineAndIndent = insertNewlineAndIndent;
      exports.insertTab = insertTab;
      exports.invertedEffects = invertedEffects;
      exports.isolateHistory = isolateHistory;
      exports.lineComment = lineComment;
      exports.lineUncomment = lineUncomment;
      exports.moveLineDown = moveLineDown;
      exports.moveLineUp = moveLineUp;
      exports.redo = redo;
      exports.redoDepth = redoDepth;
      exports.redoSelection = redoSelection;
      exports.selectAll = selectAll;
      exports.selectCharBackward = selectCharBackward;
      exports.selectCharForward = selectCharForward;
      exports.selectCharLeft = selectCharLeft;
      exports.selectCharRight = selectCharRight;
      exports.selectDocEnd = selectDocEnd;
      exports.selectDocStart = selectDocStart;
      exports.selectGroupBackward = selectGroupBackward;
      exports.selectGroupForward = selectGroupForward;
      exports.selectGroupLeft = selectGroupLeft;
      exports.selectGroupRight = selectGroupRight;
      exports.selectLine = selectLine;
      exports.selectLineBoundaryBackward = selectLineBoundaryBackward;
      exports.selectLineBoundaryForward = selectLineBoundaryForward;
      exports.selectLineBoundaryLeft = selectLineBoundaryLeft;
      exports.selectLineBoundaryRight = selectLineBoundaryRight;
      exports.selectLineDown = selectLineDown;
      exports.selectLineEnd = selectLineEnd;
      exports.selectLineStart = selectLineStart;
      exports.selectLineUp = selectLineUp;
      exports.selectMatchingBracket = selectMatchingBracket;
      exports.selectPageDown = selectPageDown;
      exports.selectPageUp = selectPageUp;
      exports.selectParentSyntax = selectParentSyntax;
      exports.selectSubwordBackward = selectSubwordBackward;
      exports.selectSubwordForward = selectSubwordForward;
      exports.selectSyntaxLeft = selectSyntaxLeft;
      exports.selectSyntaxRight = selectSyntaxRight;
      exports.simplifySelection = simplifySelection;
      exports.splitLine = splitLine;
      exports.standardKeymap = standardKeymap;
      exports.toggleBlockComment = toggleBlockComment;
      exports.toggleBlockCommentByLine = toggleBlockCommentByLine;
      exports.toggleComment = toggleComment;
      exports.toggleLineComment = toggleLineComment;
      exports.transposeChars = transposeChars;
      exports.undo = undo;
      exports.undoDepth = undoDepth;
      exports.undoSelection = undoSelection;
    }
  });

  // node_modules/crelt/dist/index.cjs
  var require_dist7 = __commonJS({
    "node_modules/crelt/dist/index.cjs"(exports, module) {
      "use strict";
      function crelt() {
        var elt = arguments[0];
        if (typeof elt == "string")
          elt = document.createElement(elt);
        var i = 1, next = arguments[1];
        if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
          for (var name in next)
            if (Object.prototype.hasOwnProperty.call(next, name)) {
              var value = next[name];
              if (typeof value == "string")
                elt.setAttribute(name, value);
              else if (value != null)
                elt[name] = value;
            }
          i++;
        }
        for (; i < arguments.length; i++)
          add(elt, arguments[i]);
        return elt;
      }
      function add(elt, child) {
        if (typeof child == "string") {
          elt.appendChild(document.createTextNode(child));
        } else if (child == null)
          ;
        else if (child.nodeType != null) {
          elt.appendChild(child);
        } else if (Array.isArray(child)) {
          for (var i = 0; i < child.length; i++)
            add(elt, child[i]);
        } else {
          throw new RangeError("Unsupported child node: " + child);
        }
      }
      module.exports = crelt;
    }
  });

  // node_modules/@codemirror/search/dist/index.cjs
  var require_dist8 = __commonJS({
    "node_modules/@codemirror/search/dist/index.cjs"(exports) {
      "use strict";
      var view = require_dist2();
      var state = require_dist();
      var elt = require_dist7();
      var basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
      var SearchCursor = class {
        constructor(text, query, from = 0, to2 = text.length, normalize, test) {
          this.test = test;
          this.value = { from: 0, to: 0 };
          this.done = false;
          this.matches = [];
          this.buffer = "";
          this.bufferPos = 0;
          this.iter = text.iterRange(from, to2);
          this.bufferStart = from;
          this.normalize = normalize ? (x) => normalize(basicNormalize(x)) : basicNormalize;
          this.query = this.normalize(query);
        }
        peek() {
          if (this.bufferPos == this.buffer.length) {
            this.bufferStart += this.buffer.length;
            this.iter.next();
            if (this.iter.done)
              return -1;
            this.bufferPos = 0;
            this.buffer = this.iter.value;
          }
          return state.codePointAt(this.buffer, this.bufferPos);
        }
        next() {
          while (this.matches.length)
            this.matches.pop();
          return this.nextOverlapping();
        }
        nextOverlapping() {
          for (; ; ) {
            let next = this.peek();
            if (next < 0) {
              this.done = true;
              return this;
            }
            let str = state.fromCodePoint(next), start = this.bufferStart + this.bufferPos;
            this.bufferPos += state.codePointSize(next);
            let norm = this.normalize(str);
            for (let i = 0, pos = start; ; i++) {
              let code = norm.charCodeAt(i);
              let match = this.match(code, pos);
              if (i == norm.length - 1) {
                if (match) {
                  this.value = match;
                  return this;
                }
                break;
              }
              if (pos == start && i < str.length && str.charCodeAt(i) == code)
                pos++;
            }
          }
        }
        match(code, pos) {
          let match = null;
          for (let i = 0; i < this.matches.length; i += 2) {
            let index = this.matches[i], keep = false;
            if (this.query.charCodeAt(index) == code) {
              if (index == this.query.length - 1) {
                match = { from: this.matches[i + 1], to: pos + 1 };
              } else {
                this.matches[i]++;
                keep = true;
              }
            }
            if (!keep) {
              this.matches.splice(i, 2);
              i -= 2;
            }
          }
          if (this.query.charCodeAt(0) == code) {
            if (this.query.length == 1)
              match = { from: pos, to: pos + 1 };
            else
              this.matches.push(1, pos);
          }
          if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferPos))
            match = null;
          return match;
        }
      };
      if (typeof Symbol != "undefined")
        SearchCursor.prototype[Symbol.iterator] = function() {
          return this;
        };
      var empty = { from: -1, to: -1, match: /.*/.exec("") };
      var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
      var RegExpCursor = class {
        constructor(text, query, options, from = 0, to2 = text.length) {
          this.text = text;
          this.to = to2;
          this.curLine = "";
          this.done = false;
          this.value = empty;
          if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
            return new MultilineRegExpCursor(text, query, options, from, to2);
          this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
          this.test = options === null || options === void 0 ? void 0 : options.test;
          this.iter = text.iter();
          let startLine = text.lineAt(from);
          this.curLineStart = startLine.from;
          this.matchPos = toCharEnd(text, from);
          this.getLine(this.curLineStart);
        }
        getLine(skip) {
          this.iter.next(skip);
          if (this.iter.lineBreak) {
            this.curLine = "";
          } else {
            this.curLine = this.iter.value;
            if (this.curLineStart + this.curLine.length > this.to)
              this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
            this.iter.next();
          }
        }
        nextLine() {
          this.curLineStart = this.curLineStart + this.curLine.length + 1;
          if (this.curLineStart > this.to)
            this.curLine = "";
          else
            this.getLine(0);
        }
        next() {
          for (let off = this.matchPos - this.curLineStart; ; ) {
            this.re.lastIndex = off;
            let match = this.matchPos <= this.to && this.re.exec(this.curLine);
            if (match) {
              let from = this.curLineStart + match.index, to2 = from + match[0].length;
              this.matchPos = toCharEnd(this.text, to2 + (from == to2 ? 1 : 0));
              if (from == this.curLineStart + this.curLine.length)
                this.nextLine();
              if ((from < to2 || from > this.value.to) && (!this.test || this.test(from, to2, match))) {
                this.value = { from, to: to2, match };
                return this;
              }
              off = this.matchPos - this.curLineStart;
            } else if (this.curLineStart + this.curLine.length < this.to) {
              this.nextLine();
              off = 0;
            } else {
              this.done = true;
              return this;
            }
          }
        }
      };
      var flattened = new WeakMap();
      var FlattenedDoc = class {
        constructor(from, text) {
          this.from = from;
          this.text = text;
        }
        get to() {
          return this.from + this.text.length;
        }
        static get(doc, from, to2) {
          let cached = flattened.get(doc);
          if (!cached || cached.from >= to2 || cached.to <= from) {
            let flat = new FlattenedDoc(from, doc.sliceString(from, to2));
            flattened.set(doc, flat);
            return flat;
          }
          if (cached.from == from && cached.to == to2)
            return cached;
          let { text, from: cachedFrom } = cached;
          if (cachedFrom > from) {
            text = doc.sliceString(from, cachedFrom) + text;
            cachedFrom = from;
          }
          if (cached.to < to2)
            text += doc.sliceString(cached.to, to2);
          flattened.set(doc, new FlattenedDoc(cachedFrom, text));
          return new FlattenedDoc(from, text.slice(from - cachedFrom, to2 - cachedFrom));
        }
      };
      var MultilineRegExpCursor = class {
        constructor(text, query, options, from, to2) {
          this.text = text;
          this.to = to2;
          this.done = false;
          this.value = empty;
          this.matchPos = toCharEnd(text, from);
          this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
          this.test = options === null || options === void 0 ? void 0 : options.test;
          this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5e3));
        }
        chunkEnd(pos) {
          return pos >= this.to ? this.to : this.text.lineAt(pos).to;
        }
        next() {
          for (; ; ) {
            let off = this.re.lastIndex = this.matchPos - this.flat.from;
            let match = this.re.exec(this.flat.text);
            if (match && !match[0] && match.index == off) {
              this.re.lastIndex = off + 1;
              match = this.re.exec(this.flat.text);
            }
            if (match) {
              let from = this.flat.from + match.index, to2 = from + match[0].length;
              if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to2, match))) {
                this.value = { from, to: to2, match };
                this.matchPos = toCharEnd(this.text, to2 + (from == to2 ? 1 : 0));
                return this;
              }
            }
            if (this.flat.to == this.to) {
              this.done = true;
              return this;
            }
            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
          }
        }
      };
      if (typeof Symbol != "undefined") {
        RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
          return this;
        };
      }
      function validRegExp(source) {
        try {
          new RegExp(source, baseFlags);
          return true;
        } catch (_a2) {
          return false;
        }
      }
      function toCharEnd(text, pos) {
        if (pos >= text.length)
          return pos;
        let line = text.lineAt(pos), next;
        while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
          pos++;
        return pos;
      }
      function createLineDialog(view$1) {
        let input = elt("input", { class: "cm-textfield", name: "line" });
        let dom = elt("form", {
          class: "cm-gotoLine",
          onkeydown: (event2) => {
            if (event2.keyCode == 27) {
              event2.preventDefault();
              view$1.dispatch({ effects: dialogEffect.of(false) });
              view$1.focus();
            } else if (event2.keyCode == 13) {
              event2.preventDefault();
              go2();
            }
          },
          onsubmit: (event2) => {
            event2.preventDefault();
            go2();
          }
        }, elt("label", view$1.state.phrase("Go to line"), ": ", input), " ", elt("button", { class: "cm-button", type: "submit" }, view$1.state.phrase("go")));
        function go2() {
          let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
          if (!match)
            return;
          let { state: state$1 } = view$1, startLine = state$1.doc.lineAt(state$1.selection.main.head);
          let [, sign, ln2, cl2, percent] = match;
          let col = cl2 ? +cl2.slice(1) : 0;
          let line = ln2 ? +ln2 : startLine.number;
          if (ln2 && percent) {
            let pc2 = line / 100;
            if (sign)
              pc2 = pc2 * (sign == "-" ? -1 : 1) + startLine.number / state$1.doc.lines;
            line = Math.round(state$1.doc.lines * pc2);
          } else if (ln2 && sign) {
            line = line * (sign == "-" ? -1 : 1) + startLine.number;
          }
          let docLine = state$1.doc.line(Math.max(1, Math.min(state$1.doc.lines, line)));
          let selection = state.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
          view$1.dispatch({
            effects: [dialogEffect.of(false), view.EditorView.scrollIntoView(selection.from, { y: "center" })],
            selection
          });
          view$1.focus();
        }
        return { dom };
      }
      var dialogEffect = state.StateEffect.define();
      var dialogField = state.StateField.define({
        create() {
          return true;
        },
        update(value, tr2) {
          for (let e of tr2.effects)
            if (e.is(dialogEffect))
              value = e.value;
          return value;
        },
        provide: (f) => view.showPanel.from(f, (val) => val ? createLineDialog : null)
      });
      var gotoLine = (view$1) => {
        let panel = view.getPanel(view$1, createLineDialog);
        if (!panel) {
          let effects = [dialogEffect.of(true)];
          if (view$1.state.field(dialogField, false) == null)
            effects.push(state.StateEffect.appendConfig.of([dialogField, baseTheme$1]));
          view$1.dispatch({ effects });
          panel = view.getPanel(view$1, createLineDialog);
        }
        if (panel)
          panel.dom.querySelector("input").focus();
        return true;
      };
      var baseTheme$1 = view.EditorView.baseTheme({
        ".cm-panel.cm-gotoLine": {
          padding: "2px 6px 4px",
          "& label": { fontSize: "80%" }
        }
      });
      var defaultHighlightOptions = {
        highlightWordAroundCursor: false,
        minSelectionLength: 1,
        maxMatches: 100,
        wholeWords: false
      };
      var highlightConfig = state.Facet.define({
        combine(options) {
          return state.combineConfig(options, defaultHighlightOptions, {
            highlightWordAroundCursor: (a, b) => a || b,
            minSelectionLength: Math.min,
            maxMatches: Math.min
          });
        }
      });
      function highlightSelectionMatches(options) {
        let ext = [defaultTheme, matchHighlighter];
        if (options)
          ext.push(highlightConfig.of(options));
        return ext;
      }
      var matchDeco = view.Decoration.mark({ class: "cm-selectionMatch" });
      var mainMatchDeco = view.Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
      function insideWordBoundaries(check, state$1, from, to2) {
        return (from == 0 || check(state$1.sliceDoc(from - 1, from)) != state.CharCategory.Word) && (to2 == state$1.doc.length || check(state$1.sliceDoc(to2, to2 + 1)) != state.CharCategory.Word);
      }
      function insideWord(check, state$1, from, to2) {
        return check(state$1.sliceDoc(from, from + 1)) == state.CharCategory.Word && check(state$1.sliceDoc(to2 - 1, to2)) == state.CharCategory.Word;
      }
      var matchHighlighter = view.ViewPlugin.fromClass(class {
        constructor(view2) {
          this.decorations = this.getDeco(view2);
        }
        update(update) {
          if (update.selectionSet || update.docChanged || update.viewportChanged)
            this.decorations = this.getDeco(update.view);
        }
        getDeco(view$1) {
          let conf = view$1.state.facet(highlightConfig);
          let { state: state2 } = view$1, sel = state2.selection;
          if (sel.ranges.length > 1)
            return view.Decoration.none;
          let range = sel.main, query, check = null;
          if (range.empty) {
            if (!conf.highlightWordAroundCursor)
              return view.Decoration.none;
            let word = state2.wordAt(range.head);
            if (!word)
              return view.Decoration.none;
            check = state2.charCategorizer(range.head);
            query = state2.sliceDoc(word.from, word.to);
          } else {
            let len = range.to - range.from;
            if (len < conf.minSelectionLength || len > 200)
              return view.Decoration.none;
            if (conf.wholeWords) {
              query = state2.sliceDoc(range.from, range.to);
              check = state2.charCategorizer(range.head);
              if (!(insideWordBoundaries(check, state2, range.from, range.to) && insideWord(check, state2, range.from, range.to)))
                return view.Decoration.none;
            } else {
              query = state2.sliceDoc(range.from, range.to).trim();
              if (!query)
                return view.Decoration.none;
            }
          }
          let deco = [];
          for (let part of view$1.visibleRanges) {
            let cursor = new SearchCursor(state2.doc, query, part.from, part.to);
            while (!cursor.next().done) {
              let { from, to: to2 } = cursor.value;
              if (!check || insideWordBoundaries(check, state2, from, to2)) {
                if (range.empty && from <= range.from && to2 >= range.to)
                  deco.push(mainMatchDeco.range(from, to2));
                else if (from >= range.to || to2 <= range.from)
                  deco.push(matchDeco.range(from, to2));
                if (deco.length > conf.maxMatches)
                  return view.Decoration.none;
              }
            }
          }
          return view.Decoration.set(deco);
        }
      }, {
        decorations: (v) => v.decorations
      });
      var defaultTheme = view.EditorView.baseTheme({
        ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
        ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
      });
      var selectWord = ({ state: state$1, dispatch }) => {
        let { selection } = state$1;
        let newSel = state.EditorSelection.create(selection.ranges.map((range) => state$1.wordAt(range.head) || state.EditorSelection.cursor(range.head)), selection.mainIndex);
        if (newSel.eq(selection))
          return false;
        dispatch(state$1.update({ selection: newSel }));
        return true;
      };
      function findNextOccurrence(state2, query) {
        let { main, ranges } = state2.selection;
        let word = state2.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
        for (let cycled = false, cursor = new SearchCursor(state2.doc, query, ranges[ranges.length - 1].to); ; ) {
          cursor.next();
          if (cursor.done) {
            if (cycled)
              return null;
            cursor = new SearchCursor(state2.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
            cycled = true;
          } else {
            if (cycled && ranges.some((r) => r.from == cursor.value.from))
              continue;
            if (fullWord) {
              let word2 = state2.wordAt(cursor.value.from);
              if (!word2 || word2.from != cursor.value.from || word2.to != cursor.value.to)
                continue;
            }
            return cursor.value;
          }
        }
      }
      var selectNextOccurrence = ({ state: state$1, dispatch }) => {
        let { ranges } = state$1.selection;
        if (ranges.some((sel) => sel.from === sel.to))
          return selectWord({ state: state$1, dispatch });
        let searchedText = state$1.sliceDoc(ranges[0].from, ranges[0].to);
        if (state$1.selection.ranges.some((r) => state$1.sliceDoc(r.from, r.to) != searchedText))
          return false;
        let range = findNextOccurrence(state$1, searchedText);
        if (!range)
          return false;
        dispatch(state$1.update({
          selection: state$1.selection.addRange(state.EditorSelection.range(range.from, range.to), false),
          effects: view.EditorView.scrollIntoView(range.to)
        }));
        return true;
      };
      var searchConfigFacet = state.Facet.define({
        combine(configs) {
          return state.combineConfig(configs, {
            top: false,
            caseSensitive: false,
            literal: false,
            regexp: false,
            wholeWord: false,
            createPanel: (view2) => new SearchPanel(view2),
            scrollToMatch: (range) => view.EditorView.scrollIntoView(range)
          });
        }
      });
      function search(config) {
        return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;
      }
      var SearchQuery = class {
        constructor(config) {
          this.search = config.search;
          this.caseSensitive = !!config.caseSensitive;
          this.literal = !!config.literal;
          this.regexp = !!config.regexp;
          this.replace = config.replace || "";
          this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
          this.unquoted = this.unquote(this.search);
          this.wholeWord = !!config.wholeWord;
        }
        unquote(text) {
          return this.literal ? text : text.replace(/\\([nrt\\])/g, (_, ch2) => ch2 == "n" ? "\n" : ch2 == "r" ? "\r" : ch2 == "t" ? "	" : "\\");
        }
        eq(other) {
          return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
        }
        create() {
          return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
        }
        getCursor(state$1, from = 0, to2) {
          let st2 = state$1.doc ? state$1 : state.EditorState.create({ doc: state$1 });
          if (to2 == null)
            to2 = st2.doc.length;
          return this.regexp ? regexpCursor(this, st2, from, to2) : stringCursor(this, st2, from, to2);
        }
      };
      var QueryType = class {
        constructor(spec) {
          this.spec = spec;
        }
      };
      function stringCursor(spec, state2, from, to2) {
        return new SearchCursor(state2.doc, spec.unquoted, from, to2, spec.caseSensitive ? void 0 : (x) => x.toLowerCase(), spec.wholeWord ? stringWordTest(state2.doc, state2.charCategorizer(state2.selection.main.head)) : void 0);
      }
      function stringWordTest(doc, categorizer) {
        return (from, to2, buf, bufPos) => {
          if (bufPos > from || bufPos + buf.length < to2) {
            bufPos = Math.max(0, from - 2);
            buf = doc.sliceString(bufPos, Math.min(doc.length, to2 + 2));
          }
          return (categorizer(charBefore(buf, from - bufPos)) != state.CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != state.CharCategory.Word) && (categorizer(charAfter(buf, to2 - bufPos)) != state.CharCategory.Word || categorizer(charBefore(buf, to2 - bufPos)) != state.CharCategory.Word);
        };
      }
      var StringQuery = class extends QueryType {
        constructor(spec) {
          super(spec);
        }
        nextMatch(state2, curFrom, curTo) {
          let cursor = stringCursor(this.spec, state2, curTo, state2.doc.length).nextOverlapping();
          if (cursor.done)
            cursor = stringCursor(this.spec, state2, 0, curFrom).nextOverlapping();
          return cursor.done ? null : cursor.value;
        }
        prevMatchInRange(state2, from, to2) {
          for (let pos = to2; ; ) {
            let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
            let cursor = stringCursor(this.spec, state2, start, pos), range = null;
            while (!cursor.nextOverlapping().done)
              range = cursor.value;
            if (range)
              return range;
            if (start == from)
              return null;
            pos -= 1e4;
          }
        }
        prevMatch(state2, curFrom, curTo) {
          return this.prevMatchInRange(state2, 0, curFrom) || this.prevMatchInRange(state2, curTo, state2.doc.length);
        }
        getReplacement(_result) {
          return this.spec.unquote(this.spec.replace);
        }
        matchAll(state2, limit) {
          let cursor = stringCursor(this.spec, state2, 0, state2.doc.length), ranges = [];
          while (!cursor.next().done) {
            if (ranges.length >= limit)
              return null;
            ranges.push(cursor.value);
          }
          return ranges;
        }
        highlight(state2, from, to2, add) {
          let cursor = stringCursor(this.spec, state2, Math.max(0, from - this.spec.unquoted.length), Math.min(to2 + this.spec.unquoted.length, state2.doc.length));
          while (!cursor.next().done)
            add(cursor.value.from, cursor.value.to);
        }
      };
      function regexpCursor(spec, state2, from, to2) {
        return new RegExpCursor(state2.doc, spec.search, {
          ignoreCase: !spec.caseSensitive,
          test: spec.wholeWord ? regexpWordTest(state2.charCategorizer(state2.selection.main.head)) : void 0
        }, from, to2);
      }
      function charBefore(str, index) {
        return str.slice(state.findClusterBreak(str, index, false), index);
      }
      function charAfter(str, index) {
        return str.slice(index, state.findClusterBreak(str, index));
      }
      function regexpWordTest(categorizer) {
        return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != state.CharCategory.Word || categorizer(charAfter(match.input, match.index)) != state.CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != state.CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != state.CharCategory.Word);
      }
      var RegExpQuery = class extends QueryType {
        nextMatch(state2, curFrom, curTo) {
          let cursor = regexpCursor(this.spec, state2, curTo, state2.doc.length).next();
          if (cursor.done)
            cursor = regexpCursor(this.spec, state2, 0, curFrom).next();
          return cursor.done ? null : cursor.value;
        }
        prevMatchInRange(state2, from, to2) {
          for (let size = 1; ; size++) {
            let start = Math.max(from, to2 - size * 1e4);
            let cursor = regexpCursor(this.spec, state2, start, to2), range = null;
            while (!cursor.next().done)
              range = cursor.value;
            if (range && (start == from || range.from > start + 10))
              return range;
            if (start == from)
              return null;
          }
        }
        prevMatch(state2, curFrom, curTo) {
          return this.prevMatchInRange(state2, 0, curFrom) || this.prevMatchInRange(state2, curTo, state2.doc.length);
        }
        getReplacement(result) {
          return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (m, i) => i == "$" ? "$" : i == "&" ? result.match[0] : i != "0" && +i < result.match.length ? result.match[i] : m));
        }
        matchAll(state2, limit) {
          let cursor = regexpCursor(this.spec, state2, 0, state2.doc.length), ranges = [];
          while (!cursor.next().done) {
            if (ranges.length >= limit)
              return null;
            ranges.push(cursor.value);
          }
          return ranges;
        }
        highlight(state2, from, to2, add) {
          let cursor = regexpCursor(this.spec, state2, Math.max(0, from - 250), Math.min(to2 + 250, state2.doc.length));
          while (!cursor.next().done)
            add(cursor.value.from, cursor.value.to);
        }
      };
      var setSearchQuery = state.StateEffect.define();
      var togglePanel = state.StateEffect.define();
      var searchState = state.StateField.define({
        create(state2) {
          return new SearchState(defaultQuery(state2).create(), null);
        },
        update(value, tr2) {
          for (let effect of tr2.effects) {
            if (effect.is(setSearchQuery))
              value = new SearchState(effect.value.create(), value.panel);
            else if (effect.is(togglePanel))
              value = new SearchState(value.query, effect.value ? createSearchPanel : null);
          }
          return value;
        },
        provide: (f) => view.showPanel.from(f, (val) => val.panel)
      });
      function getSearchQuery(state2) {
        let curState = state2.field(searchState, false);
        return curState ? curState.query.spec : defaultQuery(state2);
      }
      function searchPanelOpen(state2) {
        var _a2;
        return ((_a2 = state2.field(searchState, false)) === null || _a2 === void 0 ? void 0 : _a2.panel) != null;
      }
      var SearchState = class {
        constructor(query, panel) {
          this.query = query;
          this.panel = panel;
        }
      };
      var matchMark = view.Decoration.mark({ class: "cm-searchMatch" });
      var selectedMatchMark = view.Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
      var searchHighlighter = view.ViewPlugin.fromClass(class {
        constructor(view2) {
          this.view = view2;
          this.decorations = this.highlight(view2.state.field(searchState));
        }
        update(update) {
          let state2 = update.state.field(searchState);
          if (state2 != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
            this.decorations = this.highlight(state2);
        }
        highlight({ query, panel }) {
          if (!panel || !query.spec.valid)
            return view.Decoration.none;
          let { view: view$1 } = this;
          let builder = new state.RangeSetBuilder();
          for (let i = 0, ranges = view$1.visibleRanges, l = ranges.length; i < l; i++) {
            let { from, to: to2 } = ranges[i];
            while (i < l - 1 && to2 > ranges[i + 1].from - 2 * 250)
              to2 = ranges[++i].to;
            query.highlight(view$1.state, from, to2, (from2, to3) => {
              let selected = view$1.state.selection.ranges.some((r) => r.from == from2 && r.to == to3);
              builder.add(from2, to3, selected ? selectedMatchMark : matchMark);
            });
          }
          return builder.finish();
        }
      }, {
        decorations: (v) => v.decorations
      });
      function searchCommand(f) {
        return (view2) => {
          let state2 = view2.state.field(searchState, false);
          return state2 && state2.query.spec.valid ? f(view2, state2) : openSearchPanel(view2);
        };
      }
      var findNext = searchCommand((view2, { query }) => {
        let { to: to2 } = view2.state.selection.main;
        let next = query.nextMatch(view2.state, to2, to2);
        if (!next)
          return false;
        let selection = state.EditorSelection.single(next.from, next.to);
        let config = view2.state.facet(searchConfigFacet);
        view2.dispatch({
          selection,
          effects: [announceMatch(view2, next), config.scrollToMatch(selection.main, view2)],
          userEvent: "select.search"
        });
        selectSearchInput(view2);
        return true;
      });
      var findPrevious = searchCommand((view2, { query }) => {
        let { state: state$1 } = view2, { from } = state$1.selection.main;
        let prev = query.prevMatch(state$1, from, from);
        if (!prev)
          return false;
        let selection = state.EditorSelection.single(prev.from, prev.to);
        let config = view2.state.facet(searchConfigFacet);
        view2.dispatch({
          selection,
          effects: [announceMatch(view2, prev), config.scrollToMatch(selection.main, view2)],
          userEvent: "select.search"
        });
        selectSearchInput(view2);
        return true;
      });
      var selectMatches = searchCommand((view2, { query }) => {
        let ranges = query.matchAll(view2.state, 1e3);
        if (!ranges || !ranges.length)
          return false;
        view2.dispatch({
          selection: state.EditorSelection.create(ranges.map((r) => state.EditorSelection.range(r.from, r.to))),
          userEvent: "select.search.matches"
        });
        return true;
      });
      var selectSelectionMatches = ({ state: state$1, dispatch }) => {
        let sel = state$1.selection;
        if (sel.ranges.length > 1 || sel.main.empty)
          return false;
        let { from, to: to2 } = sel.main;
        let ranges = [], main = 0;
        for (let cur = new SearchCursor(state$1.doc, state$1.sliceDoc(from, to2)); !cur.next().done; ) {
          if (ranges.length > 1e3)
            return false;
          if (cur.value.from == from)
            main = ranges.length;
          ranges.push(state.EditorSelection.range(cur.value.from, cur.value.to));
        }
        dispatch(state$1.update({
          selection: state.EditorSelection.create(ranges, main),
          userEvent: "select.search.matches"
        }));
        return true;
      };
      var replaceNext = searchCommand((view$1, { query }) => {
        let { state: state$1 } = view$1, { from, to: to2 } = state$1.selection.main;
        if (state$1.readOnly)
          return false;
        let next = query.nextMatch(state$1, from, from);
        if (!next)
          return false;
        let changes = [], selection, replacement;
        let effects = [];
        if (next.from == from && next.to == to2) {
          replacement = state$1.toText(query.getReplacement(next));
          changes.push({ from: next.from, to: next.to, insert: replacement });
          next = query.nextMatch(state$1, next.from, next.to);
          effects.push(view.EditorView.announce.of(state$1.phrase("replaced match on line $", state$1.doc.lineAt(from).number) + "."));
        }
        if (next) {
          let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
          selection = state.EditorSelection.single(next.from - off, next.to - off);
          effects.push(announceMatch(view$1, next));
          effects.push(state$1.facet(searchConfigFacet).scrollToMatch(selection.main, view$1));
        }
        view$1.dispatch({
          changes,
          selection,
          effects,
          userEvent: "input.replace"
        });
        return true;
      });
      var replaceAll = searchCommand((view$1, { query }) => {
        if (view$1.state.readOnly)
          return false;
        let changes = query.matchAll(view$1.state, 1e9).map((match) => {
          let { from, to: to2 } = match;
          return { from, to: to2, insert: query.getReplacement(match) };
        });
        if (!changes.length)
          return false;
        let announceText = view$1.state.phrase("replaced $ matches", changes.length) + ".";
        view$1.dispatch({
          changes,
          effects: view.EditorView.announce.of(announceText),
          userEvent: "input.replace.all"
        });
        return true;
      });
      function createSearchPanel(view2) {
        return view2.state.facet(searchConfigFacet).createPanel(view2);
      }
      function defaultQuery(state2, fallback) {
        var _a2, _b, _c2, _d2, _e2;
        let sel = state2.selection.main;
        let selText = sel.empty || sel.to > sel.from + 100 ? "" : state2.sliceDoc(sel.from, sel.to);
        if (fallback && !selText)
          return fallback;
        let config = state2.facet(searchConfigFacet);
        return new SearchQuery({
          search: ((_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a2 !== void 0 ? _a2 : config.literal) ? selText : selText.replace(/\n/g, "\\n"),
          caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,
          literal: (_c2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c2 !== void 0 ? _c2 : config.literal,
          regexp: (_d2 = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d2 !== void 0 ? _d2 : config.regexp,
          wholeWord: (_e2 = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e2 !== void 0 ? _e2 : config.wholeWord
        });
      }
      function getSearchInput(view$1) {
        let panel = view.getPanel(view$1, createSearchPanel);
        return panel && panel.dom.querySelector("[main-field]");
      }
      function selectSearchInput(view2) {
        let input = getSearchInput(view2);
        if (input && input == view2.root.activeElement)
          input.select();
      }
      var openSearchPanel = (view2) => {
        let state$1 = view2.state.field(searchState, false);
        if (state$1 && state$1.panel) {
          let searchInput = getSearchInput(view2);
          if (searchInput && searchInput != view2.root.activeElement) {
            let query = defaultQuery(view2.state, state$1.query.spec);
            if (query.valid)
              view2.dispatch({ effects: setSearchQuery.of(query) });
            searchInput.focus();
            searchInput.select();
          }
        } else {
          view2.dispatch({ effects: [
            togglePanel.of(true),
            state$1 ? setSearchQuery.of(defaultQuery(view2.state, state$1.query.spec)) : state.StateEffect.appendConfig.of(searchExtensions)
          ] });
        }
        return true;
      };
      var closeSearchPanel = (view$1) => {
        let state2 = view$1.state.field(searchState, false);
        if (!state2 || !state2.panel)
          return false;
        let panel = view.getPanel(view$1, createSearchPanel);
        if (panel && panel.dom.contains(view$1.root.activeElement))
          view$1.focus();
        view$1.dispatch({ effects: togglePanel.of(false) });
        return true;
      };
      var searchKeymap = [
        { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
        { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
        { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
        { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
        { key: "Mod-Shift-l", run: selectSelectionMatches },
        { key: "Alt-g", run: gotoLine },
        { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
      ];
      var SearchPanel = class {
        constructor(view2) {
          this.view = view2;
          let query = this.query = view2.state.field(searchState).query.spec;
          this.commit = this.commit.bind(this);
          this.searchField = elt("input", {
            value: query.search,
            placeholder: phrase(view2, "Find"),
            "aria-label": phrase(view2, "Find"),
            class: "cm-textfield",
            name: "search",
            form: "",
            "main-field": "true",
            onchange: this.commit,
            onkeyup: this.commit
          });
          this.replaceField = elt("input", {
            value: query.replace,
            placeholder: phrase(view2, "Replace"),
            "aria-label": phrase(view2, "Replace"),
            class: "cm-textfield",
            name: "replace",
            form: "",
            onchange: this.commit,
            onkeyup: this.commit
          });
          this.caseField = elt("input", {
            type: "checkbox",
            name: "case",
            form: "",
            checked: query.caseSensitive,
            onchange: this.commit
          });
          this.reField = elt("input", {
            type: "checkbox",
            name: "re",
            form: "",
            checked: query.regexp,
            onchange: this.commit
          });
          this.wordField = elt("input", {
            type: "checkbox",
            name: "word",
            form: "",
            checked: query.wholeWord,
            onchange: this.commit
          });
          function button(name, onclick, content) {
            return elt("button", { class: "cm-button", name, onclick, type: "button" }, content);
          }
          this.dom = elt("div", { onkeydown: (e) => this.keydown(e), class: "cm-search" }, [
            this.searchField,
            button("next", () => findNext(view2), [phrase(view2, "next")]),
            button("prev", () => findPrevious(view2), [phrase(view2, "previous")]),
            button("select", () => selectMatches(view2), [phrase(view2, "all")]),
            elt("label", null, [this.caseField, phrase(view2, "match case")]),
            elt("label", null, [this.reField, phrase(view2, "regexp")]),
            elt("label", null, [this.wordField, phrase(view2, "by word")]),
            ...view2.state.readOnly ? [] : [
              elt("br"),
              this.replaceField,
              button("replace", () => replaceNext(view2), [phrase(view2, "replace")]),
              button("replaceAll", () => replaceAll(view2), [phrase(view2, "replace all")])
            ],
            elt("button", {
              name: "close",
              onclick: () => closeSearchPanel(view2),
              "aria-label": phrase(view2, "close"),
              type: "button"
            }, ["\xD7"])
          ]);
        }
        commit() {
          let query = new SearchQuery({
            search: this.searchField.value,
            caseSensitive: this.caseField.checked,
            regexp: this.reField.checked,
            wholeWord: this.wordField.checked,
            replace: this.replaceField.value
          });
          if (!query.eq(this.query)) {
            this.query = query;
            this.view.dispatch({ effects: setSearchQuery.of(query) });
          }
        }
        keydown(e) {
          if (view.runScopeHandlers(this.view, e, "search-panel")) {
            e.preventDefault();
          } else if (e.keyCode == 13 && e.target == this.searchField) {
            e.preventDefault();
            (e.shiftKey ? findPrevious : findNext)(this.view);
          } else if (e.keyCode == 13 && e.target == this.replaceField) {
            e.preventDefault();
            replaceNext(this.view);
          }
        }
        update(update) {
          for (let tr2 of update.transactions)
            for (let effect of tr2.effects) {
              if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
                this.setQuery(effect.value);
            }
        }
        setQuery(query) {
          this.query = query;
          this.searchField.value = query.search;
          this.replaceField.value = query.replace;
          this.caseField.checked = query.caseSensitive;
          this.reField.checked = query.regexp;
          this.wordField.checked = query.wholeWord;
        }
        mount() {
          this.searchField.select();
        }
        get pos() {
          return 80;
        }
        get top() {
          return this.view.state.facet(searchConfigFacet).top;
        }
      };
      function phrase(view2, phrase2) {
        return view2.state.phrase(phrase2);
      }
      var AnnounceMargin = 30;
      var Break = /[\s\.,:;?!]/;
      function announceMatch(view$1, { from, to: to2 }) {
        let line = view$1.state.doc.lineAt(from), lineEnd = view$1.state.doc.lineAt(to2).to;
        let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to2 + AnnounceMargin);
        let text = view$1.state.sliceDoc(start, end);
        if (start != line.from) {
          for (let i = 0; i < AnnounceMargin; i++)
            if (!Break.test(text[i + 1]) && Break.test(text[i])) {
              text = text.slice(i);
              break;
            }
        }
        if (end != lineEnd) {
          for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
            if (!Break.test(text[i - 1]) && Break.test(text[i])) {
              text = text.slice(0, i);
              break;
            }
        }
        return view.EditorView.announce.of(`${view$1.state.phrase("current match")}. ${text} ${view$1.state.phrase("on line")} ${line.number}.`);
      }
      var baseTheme = view.EditorView.baseTheme({
        ".cm-panel.cm-search": {
          padding: "2px 6px 4px",
          position: "relative",
          "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "4px",
            backgroundColor: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
          },
          "& input, & button, & label": {
            margin: ".2em .6em .2em 0"
          },
          "& input[type=checkbox]": {
            marginRight: ".2em"
          },
          "& label": {
            fontSize: "80%",
            whiteSpace: "pre"
          }
        },
        "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
        "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
        "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
        "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
      });
      var searchExtensions = [
        searchState,
        state.Prec.low(searchHighlighter),
        baseTheme
      ];
      exports.RegExpCursor = RegExpCursor;
      exports.SearchCursor = SearchCursor;
      exports.SearchQuery = SearchQuery;
      exports.closeSearchPanel = closeSearchPanel;
      exports.findNext = findNext;
      exports.findPrevious = findPrevious;
      exports.getSearchQuery = getSearchQuery;
      exports.gotoLine = gotoLine;
      exports.highlightSelectionMatches = highlightSelectionMatches;
      exports.openSearchPanel = openSearchPanel;
      exports.replaceAll = replaceAll;
      exports.replaceNext = replaceNext;
      exports.search = search;
      exports.searchKeymap = searchKeymap;
      exports.searchPanelOpen = searchPanelOpen;
      exports.selectMatches = selectMatches;
      exports.selectNextOccurrence = selectNextOccurrence;
      exports.selectSelectionMatches = selectSelectionMatches;
      exports.setSearchQuery = setSearchQuery;
    }
  });

  // __tmp__/static/js/cm-decorations.js
  var require_cm_decorations = __commonJS({
    "__tmp__/static/js/cm-decorations.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.basicIndent = exports.placeholders = exports.breakpointGutter = exports.decorationsTheme = exports.breakpointGutterState = exports.incorrectLineField = exports.debugLineField = exports.errorLineField = exports.removeIncorrectLineEffect = exports.addIncorrectLineEffect = exports.removeDebugLine = exports.addDebugWords = exports.addDebugLine = exports.removeErrorMarkers = exports.addErrorWord = exports.addErrorLine = void 0;
      var view_1 = require_dist2();
      var state_1 = require_dist();
      exports.addErrorLine = state_1.StateEffect.define();
      exports.addErrorWord = state_1.StateEffect.define();
      exports.removeErrorMarkers = state_1.StateEffect.define();
      exports.addDebugLine = state_1.StateEffect.define();
      exports.addDebugWords = state_1.StateEffect.define({
        map: (val, mapping) => ({ from: mapping.mapPos(val.from), to: mapping.mapPos(val.to) })
      });
      exports.removeDebugLine = state_1.StateEffect.define();
      var breakpointGutterEffect = state_1.StateEffect.define({
        map: (val, mapping) => ({ pos: mapping.mapPos(val.pos), on: val.on })
      });
      var deactivateLineEffect = state_1.StateEffect.define({
        map: (val, mapping) => ({ pos: mapping.mapPos(val.pos), on: val.on })
      });
      exports.addIncorrectLineEffect = state_1.StateEffect.define({
        map: (val, maping) => ({ from: maping.mapPos(val.from), to: maping.mapPos(val.to) })
      });
      exports.removeIncorrectLineEffect = state_1.StateEffect.define();
      exports.errorLineField = state_1.StateField.define({
        create() {
          return view_1.Decoration.none;
        },
        update(errors, transaction) {
          errors = errors.map(transaction.changes);
          for (let e of transaction.effects) {
            if (e.is(exports.addErrorLine)) {
              const line = transaction.state.doc.line(e.value.row);
              errors = errors.update({
                add: [errorHighlightLine.range(line.from, line.from)]
              });
            } else if (e.is(exports.addErrorWord)) {
              const line = transaction.state.doc.line(e.value.row);
              const length = line.text.slice(e.value.col - 1).split(/(\s+)/)[0].length;
              if (length > 0) {
                errors = errors.update({
                  add: [errorHighlightMark.range(line.from + e.value.col - 1, line.from + e.value.col - 1 + length)]
                });
              } else {
                errors = errors.update({
                  add: [errorHighlightLine.range(line.from, line.from)]
                });
              }
            } else if (e.is(exports.removeErrorMarkers)) {
              return view_1.Decoration.none;
            }
          }
          return errors;
        },
        provide: (f) => view_1.EditorView.decorations.from(f)
      });
      exports.debugLineField = state_1.StateField.define({
        create() {
          return view_1.Decoration.none;
        },
        update(errors, tr2) {
          errors = errors.map(tr2.changes);
          for (let e of tr2.effects) {
            if (e.is(exports.addDebugLine)) {
              const line = tr2.state.doc.line(e.value.row);
              errors = errors.update({
                add: [debugLine.range(line.from, line.from)]
              });
            } else if (e.is(exports.addDebugWords)) {
              errors = errors.update({
                add: [debugWord.range(e.value.from, e.value.to)]
              });
            } else if (e.is(exports.removeDebugLine)) {
              return view_1.Decoration.none;
            }
          }
          return errors;
        },
        provide: (f) => view_1.EditorView.decorations.from(f)
      });
      exports.incorrectLineField = state_1.StateField.define({
        create() {
          return view_1.Decoration.none;
        },
        update(errors, tr2) {
          errors = errors.map(tr2.changes);
          for (let e of tr2.effects) {
            if (e.is(exports.addIncorrectLineEffect)) {
              errors = errors.update({
                add: [incorrectCodeMark.range(e.value.from, e.value.to)]
              });
            } else if (e.is(exports.removeIncorrectLineEffect)) {
              return view_1.Decoration.none;
            }
          }
          return errors;
        },
        provide: (f) => view_1.EditorView.decorations.from(f)
      });
      exports.breakpointGutterState = state_1.StateField.define({
        create() {
          return state_1.RangeSet.empty;
        },
        update(set, transaction) {
          set = set.map(transaction.changes);
          for (let e of transaction.effects) {
            if (e.is(breakpointGutterEffect)) {
              if (e.value.on)
                set = set.update({ add: [deactivateGutterMarker.range(e.value.pos)] });
              else
                set = set.update({ filter: (from) => from != e.value.pos });
            }
          }
          return set;
        }
      });
      var deactivateLineState = state_1.StateField.define({
        create() {
          return view_1.Decoration.none;
        },
        update(set, transaction) {
          set = set.map(transaction.changes);
          for (let e of transaction.effects) {
            if (e.is(deactivateLineEffect)) {
              if (e.value.on) {
                set = set.update({
                  add: [deactivateLineMarker.range(e.value.pos, e.value.pos)]
                });
              } else {
                set = set.update({
                  filter: (from) => from != e.value.pos
                });
              }
            }
          }
          return set;
        },
        provide: (f) => view_1.EditorView.decorations.from(f)
      });
      var errorHighlightLine = view_1.Decoration.line({ class: "cm-error-editor" });
      var errorHighlightMark = view_1.Decoration.mark({ class: "cm-error-editor" });
      var debugLine = view_1.Decoration.line({ class: "cm-debugger-current-line" });
      var debugWord = view_1.Decoration.mark({ class: "cm-debugger-current-line" });
      var incorrectCodeMark = view_1.Decoration.mark({ class: "cm-incorrect-hedy-code" });
      var deactivateLineMarker = view_1.Decoration.line({ class: "cm-disabled-line" });
      exports.decorationsTheme = view_1.EditorView.theme({
        ".cm-error-editor": {
          outline: "2px solid #F56565",
          backgroundColor: "rgba(66, 153, 225, 0.7)",
          color: "white"
        },
        ".cm-debugger-current-line": {
          backgroundColor: "#2D6099"
        },
        ".cm-incorrect-hedy-code": {
          textDecoration: "red wavy underline"
        }
      });
      var deactivateGutterMarker = new class extends view_1.GutterMarker {
        toDOM() {
          return document.createTextNode("\u{1F634}");
        }
      }();
      function toggleLine(view, pos) {
        let breakpoints = view.state.field(exports.breakpointGutterState);
        let isDeactivated = false;
        breakpoints.between(pos, pos, () => {
          isDeactivated = true;
        });
        view.dispatch({
          effects: [
            breakpointGutterEffect.of({ pos, on: !isDeactivated }),
            deactivateLineEffect.of({ pos, on: !isDeactivated })
          ]
        });
      }
      exports.breakpointGutter = [
        exports.breakpointGutterState,
        deactivateLineState,
        (0, view_1.gutter)({
          class: "cm-breakpoint-gutter",
          markers: (v) => v.state.field(exports.breakpointGutterState),
          initialSpacer: () => deactivateGutterMarker,
          domEventHandlers: {
            mousedown(view, line) {
              toggleLine(view, line.from);
              return true;
            }
          }
        }),
        view_1.EditorView.baseTheme({
          ".cm-breakpoint-gutter .cm-gutterElement": {
            paddingLeft: "5px",
            cursor: "default"
          },
          ".cm-disabled-line": {
            textDecoration: "line-through"
          }
        })
      ];
      var view_2 = require_dist2();
      var PlacheholderWidget = class extends view_2.WidgetType {
        constructor(space, placeholder) {
          super();
          this.space = space;
          this.placeholder = placeholder;
        }
        toDOM() {
          let wrap = document.createElement("span");
          wrap.setAttribute("aria-hidden", "true");
          wrap.style.setProperty("background", "#F92672");
          wrap.style.setProperty("color", "white");
          wrap.innerHTML = "_";
          return wrap;
        }
        ignoreEvent() {
          return false;
        }
      };
      var placeholderMatcher = new view_1.MatchDecorator({
        regexp: /(?<![^ ])(_)(?= |$)/g,
        decoration: (match) => view_1.Decoration.replace({
          widget: new PlacheholderWidget(match[1], match[2])
        })
      });
      exports.placeholders = view_1.ViewPlugin.fromClass(class {
        constructor(view) {
          this.placeholders = placeholderMatcher.createDeco(view);
        }
        update(update) {
          this.placeholders = placeholderMatcher.updateDeco(update, this.placeholders);
        }
      }, {
        decorations: (instance) => instance.placeholders,
        provide: (plugin) => view_1.EditorView.atomicRanges.of((view) => {
          var _a2;
          return ((_a2 = view.plugin(plugin)) === null || _a2 === void 0 ? void 0 : _a2.placeholders) || view_1.Decoration.none;
        })
      });
      function basicIndent(context, pos) {
        const nextIndentationSize = context.lineIndent(pos, -1);
        let prevIndentationSize;
        try {
          prevIndentationSize = context.lineIndent(pos + 1, -1);
        } catch (error) {
          prevIndentationSize = 0;
        }
        const indentBy = Math.max(prevIndentationSize, nextIndentationSize);
        return indentBy;
      }
      exports.basicIndent = basicIndent;
    }
  });

  // node_modules/@lezer/lr/dist/index.cjs
  var require_dist9 = __commonJS({
    "node_modules/@lezer/lr/dist/index.cjs"(exports) {
      "use strict";
      var common = require_dist3();
      var Stack = class {
        constructor(p, stack, state, reducePos, pos, score, buffer, bufferBase, curContext, lookAhead = 0, parent) {
          this.p = p;
          this.stack = stack;
          this.state = state;
          this.reducePos = reducePos;
          this.pos = pos;
          this.score = score;
          this.buffer = buffer;
          this.bufferBase = bufferBase;
          this.curContext = curContext;
          this.lookAhead = lookAhead;
          this.parent = parent;
        }
        toString() {
          return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
        }
        static start(p, state, pos = 0) {
          let cx = p.parser.context;
          return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
        }
        get context() {
          return this.curContext ? this.curContext.context : null;
        }
        pushState(state, start) {
          this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
          this.state = state;
        }
        reduce(action) {
          var _a2;
          let depth = action >> 19, type = action & 65535;
          let { parser } = this.p;
          let dPrec = parser.dynamicPrecedence(type);
          if (dPrec)
            this.score += dPrec;
          if (depth == 0) {
            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
            if (type < parser.minRepeatTerm)
              this.storeNode(type, this.reducePos, this.reducePos, 4, true);
            this.reduceContext(type, this.reducePos);
            return;
          }
          let base = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
          let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;
          if (size >= 2e3 && !((_a2 = this.p.parser.nodeSet.types[type]) === null || _a2 === void 0 ? void 0 : _a2.isAnonymous)) {
            if (start == this.p.lastBigReductionStart) {
              this.p.bigReductionCount++;
              this.p.lastBigReductionSize = size;
            } else if (this.p.lastBigReductionSize < size) {
              this.p.bigReductionCount = 1;
              this.p.lastBigReductionStart = start;
              this.p.lastBigReductionSize = size;
            }
          }
          let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
          if (type < parser.minRepeatTerm || action & 131072) {
            let pos = parser.stateFlag(this.state, 1) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
          }
          if (action & 262144) {
            this.state = this.stack[base];
          } else {
            let baseStateID = this.stack[base - 3];
            this.state = parser.getGoto(baseStateID, type, true);
          }
          while (this.stack.length > base)
            this.stack.pop();
          this.reduceContext(type, start);
        }
        storeNode(term, start, end, size = 4, isReduce = false) {
          if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
            let cur = this, top = this.buffer.length;
            if (top == 0 && cur.parent) {
              top = cur.bufferBase - cur.parent.bufferBase;
              cur = cur.parent;
            }
            if (top > 0 && cur.buffer[top - 4] == 0 && cur.buffer[top - 1] > -1) {
              if (start == end)
                return;
              if (cur.buffer[top - 2] >= start) {
                cur.buffer[top - 2] = end;
                return;
              }
            }
          }
          if (!isReduce || this.pos == end) {
            this.buffer.push(term, start, end, size);
          } else {
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != 0)
              while (index > 0 && this.buffer[index - 2] > end) {
                this.buffer[index] = this.buffer[index - 4];
                this.buffer[index + 1] = this.buffer[index - 3];
                this.buffer[index + 2] = this.buffer[index - 2];
                this.buffer[index + 3] = this.buffer[index - 1];
                index -= 4;
                if (size > 4)
                  size -= 4;
              }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
          }
        }
        shift(action, type, start, end) {
          if (action & 131072) {
            this.pushState(action & 65535, this.pos);
          } else if ((action & 262144) == 0) {
            let nextState = action, { parser } = this.p;
            if (end > this.pos || type <= parser.maxNode) {
              this.pos = end;
              if (!parser.stateFlag(nextState, 1))
                this.reducePos = end;
            }
            this.pushState(nextState, start);
            this.shiftContext(type, start);
            if (type <= parser.maxNode)
              this.buffer.push(type, start, end, 4);
          } else {
            this.pos = end;
            this.shiftContext(type, start);
            if (type <= this.p.parser.maxNode)
              this.buffer.push(type, start, end, 4);
          }
        }
        apply(action, next, nextStart, nextEnd) {
          if (action & 65536)
            this.reduce(action);
          else
            this.shift(action, next, nextStart, nextEnd);
        }
        useNode(value, next) {
          let index = this.p.reused.length - 1;
          if (index < 0 || this.p.reused[index] != value) {
            this.p.reused.push(value);
            index++;
          }
          let start = this.pos;
          this.reducePos = this.pos = start + value.length;
          this.pushState(next, start);
          this.buffer.push(index, start, this.reducePos, -1);
          if (this.curContext)
            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
        }
        split() {
          let parent = this;
          let off = parent.buffer.length;
          while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
            off -= 4;
          let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
          while (parent && base == parent.bufferBase)
            parent = parent.parent;
          return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
        }
        recoverByDelete(next, nextEnd) {
          let isNode = next <= this.p.parser.maxNode;
          if (isNode)
            this.storeNode(next, this.pos, nextEnd, 4);
          this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
          this.pos = this.reducePos = nextEnd;
          this.score -= 190;
        }
        canShift(term) {
          for (let sim = new SimulatedStack(this); ; ) {
            let action = this.p.parser.stateSlot(sim.state, 4) || this.p.parser.hasAction(sim.state, term);
            if (action == 0)
              return false;
            if ((action & 65536) == 0)
              return true;
            sim.reduce(action);
          }
        }
        recoverByInsert(next) {
          if (this.stack.length >= 300)
            return [];
          let nextStates = this.p.parser.nextStates(this.state);
          if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
            let best = [];
            for (let i = 0, s; i < nextStates.length; i += 2) {
              if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
                best.push(nextStates[i], s);
            }
            if (this.stack.length < 120)
              for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
                let s = nextStates[i + 1];
                if (!best.some((v, i2) => i2 & 1 && v == s))
                  best.push(nextStates[i], s);
              }
            nextStates = best;
          }
          let result = [];
          for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
            let s = nextStates[i + 1];
            if (s == this.state)
              continue;
            let stack = this.split();
            stack.pushState(s, this.pos);
            stack.storeNode(0, stack.pos, stack.pos, 4, true);
            stack.shiftContext(nextStates[i], this.pos);
            stack.reducePos = this.pos;
            stack.score -= 200;
            result.push(stack);
          }
          return result;
        }
        forceReduce() {
          let { parser } = this.p;
          let reduce = parser.stateSlot(this.state, 5);
          if ((reduce & 65536) == 0)
            return false;
          if (!parser.validAction(this.state, reduce)) {
            let depth = reduce >> 19, term = reduce & 65535;
            let target = this.stack.length - depth * 3;
            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {
              let backup = this.findForcedReduction();
              if (backup == null)
                return false;
              reduce = backup;
            }
            this.storeNode(0, this.pos, this.pos, 4, true);
            this.score -= 100;
          }
          this.reducePos = this.pos;
          this.reduce(reduce);
          return true;
        }
        findForcedReduction() {
          let { parser } = this.p, seen = [];
          let explore = (state, depth) => {
            if (seen.includes(state))
              return;
            seen.push(state);
            return parser.allActions(state, (action) => {
              if (action & (262144 | 131072))
                ;
              else if (action & 65536) {
                let rDepth = (action >> 19) - depth;
                if (rDepth > 1) {
                  let term = action & 65535, target = this.stack.length - rDepth * 3;
                  if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0)
                    return rDepth << 19 | 65536 | term;
                }
              } else {
                let found = explore(action, depth + 1);
                if (found != null)
                  return found;
              }
            });
          };
          return explore(this.state, 0);
        }
        forceAll() {
          while (!this.p.parser.stateFlag(this.state, 2)) {
            if (!this.forceReduce()) {
              this.storeNode(0, this.pos, this.pos, 4, true);
              break;
            }
          }
          return this;
        }
        get deadEnd() {
          if (this.stack.length != 3)
            return false;
          let { parser } = this.p;
          return parser.data[parser.stateSlot(this.state, 1)] == 65535 && !parser.stateSlot(this.state, 4);
        }
        restart() {
          this.storeNode(0, this.pos, this.pos, 4, true);
          this.state = this.stack[0];
          this.stack.length = 0;
        }
        sameState(other) {
          if (this.state != other.state || this.stack.length != other.stack.length)
            return false;
          for (let i = 0; i < this.stack.length; i += 3)
            if (this.stack[i] != other.stack[i])
              return false;
          return true;
        }
        get parser() {
          return this.p.parser;
        }
        dialectEnabled(dialectID) {
          return this.p.parser.dialect.flags[dialectID];
        }
        shiftContext(term, start) {
          if (this.curContext)
            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
        }
        reduceContext(term, start) {
          if (this.curContext)
            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
        }
        emitContext() {
          let last = this.buffer.length - 1;
          if (last < 0 || this.buffer[last] != -3)
            this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
        }
        emitLookAhead() {
          let last = this.buffer.length - 1;
          if (last < 0 || this.buffer[last] != -4)
            this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
        }
        updateContext(context) {
          if (context != this.curContext.context) {
            let newCx = new StackContext(this.curContext.tracker, context);
            if (newCx.hash != this.curContext.hash)
              this.emitContext();
            this.curContext = newCx;
          }
        }
        setLookAhead(lookAhead) {
          if (lookAhead > this.lookAhead) {
            this.emitLookAhead();
            this.lookAhead = lookAhead;
          }
        }
        close() {
          if (this.curContext && this.curContext.tracker.strict)
            this.emitContext();
          if (this.lookAhead > 0)
            this.emitLookAhead();
        }
      };
      var StackContext = class {
        constructor(tracker, context) {
          this.tracker = tracker;
          this.context = context;
          this.hash = tracker.strict ? tracker.hash(context) : 0;
        }
      };
      var SimulatedStack = class {
        constructor(start) {
          this.start = start;
          this.state = start.state;
          this.stack = start.stack;
          this.base = this.stack.length;
        }
        reduce(action) {
          let term = action & 65535, depth = action >> 19;
          if (depth == 0) {
            if (this.stack == this.start.stack)
              this.stack = this.stack.slice();
            this.stack.push(this.state, 0, 0);
            this.base += 3;
          } else {
            this.base -= (depth - 1) * 3;
          }
          let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
          this.state = goto;
        }
      };
      var StackBufferCursor = class {
        constructor(stack, pos, index) {
          this.stack = stack;
          this.pos = pos;
          this.index = index;
          this.buffer = stack.buffer;
          if (this.index == 0)
            this.maybeNext();
        }
        static create(stack, pos = stack.bufferBase + stack.buffer.length) {
          return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
        }
        maybeNext() {
          let next = this.stack.parent;
          if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
          }
        }
        get id() {
          return this.buffer[this.index - 4];
        }
        get start() {
          return this.buffer[this.index - 3];
        }
        get end() {
          return this.buffer[this.index - 2];
        }
        get size() {
          return this.buffer[this.index - 1];
        }
        next() {
          this.index -= 4;
          this.pos -= 4;
          if (this.index == 0)
            this.maybeNext();
        }
        fork() {
          return new StackBufferCursor(this.stack, this.pos, this.index);
        }
      };
      function decodeArray(input, Type = Uint16Array) {
        if (typeof input != "string")
          return input;
        let array = null;
        for (let pos = 0, out = 0; pos < input.length; ) {
          let value = 0;
          for (; ; ) {
            let next = input.charCodeAt(pos++), stop = false;
            if (next == 126) {
              value = 65535;
              break;
            }
            if (next >= 92)
              next--;
            if (next >= 34)
              next--;
            let digit = next - 32;
            if (digit >= 46) {
              digit -= 46;
              stop = true;
            }
            value += digit;
            if (stop)
              break;
            value *= 46;
          }
          if (array)
            array[out++] = value;
          else
            array = new Type(value);
        }
        return array;
      }
      var CachedToken = class {
        constructor() {
          this.start = -1;
          this.value = -1;
          this.end = -1;
          this.extended = -1;
          this.lookAhead = 0;
          this.mask = 0;
          this.context = 0;
        }
      };
      var nullToken = new CachedToken();
      var InputStream = class {
        constructor(input, ranges) {
          this.input = input;
          this.ranges = ranges;
          this.chunk = "";
          this.chunkOff = 0;
          this.chunk2 = "";
          this.chunk2Pos = 0;
          this.next = -1;
          this.token = nullToken;
          this.rangeIndex = 0;
          this.pos = this.chunkPos = ranges[0].from;
          this.range = ranges[0];
          this.end = ranges[ranges.length - 1].to;
          this.readNext();
        }
        resolveOffset(offset, assoc) {
          let range = this.range, index = this.rangeIndex;
          let pos = this.pos + offset;
          while (pos < range.from) {
            if (!index)
              return null;
            let next = this.ranges[--index];
            pos -= range.from - next.to;
            range = next;
          }
          while (assoc < 0 ? pos > range.to : pos >= range.to) {
            if (index == this.ranges.length - 1)
              return null;
            let next = this.ranges[++index];
            pos += next.from - range.to;
            range = next;
          }
          return pos;
        }
        clipPos(pos) {
          if (pos >= this.range.from && pos < this.range.to)
            return pos;
          for (let range of this.ranges)
            if (range.to > pos)
              return Math.max(pos, range.from);
          return this.end;
        }
        peek(offset) {
          let idx = this.chunkOff + offset, pos, result;
          if (idx >= 0 && idx < this.chunk.length) {
            pos = this.pos + offset;
            result = this.chunk.charCodeAt(idx);
          } else {
            let resolved = this.resolveOffset(offset, 1);
            if (resolved == null)
              return -1;
            pos = resolved;
            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
              result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
            } else {
              let i = this.rangeIndex, range = this.range;
              while (range.to <= pos)
                range = this.ranges[++i];
              this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
              if (pos + this.chunk2.length > range.to)
                this.chunk2 = this.chunk2.slice(0, range.to - pos);
              result = this.chunk2.charCodeAt(0);
            }
          }
          if (pos >= this.token.lookAhead)
            this.token.lookAhead = pos + 1;
          return result;
        }
        acceptToken(token, endOffset = 0) {
          let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
          if (end == null || end < this.token.start)
            throw new RangeError("Token end out of bounds");
          this.token.value = token;
          this.token.end = end;
        }
        getChunk() {
          if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
            let { chunk, chunkPos } = this;
            this.chunk = this.chunk2;
            this.chunkPos = this.chunk2Pos;
            this.chunk2 = chunk;
            this.chunk2Pos = chunkPos;
            this.chunkOff = this.pos - this.chunkPos;
          } else {
            this.chunk2 = this.chunk;
            this.chunk2Pos = this.chunkPos;
            let nextChunk = this.input.chunk(this.pos);
            let end = this.pos + nextChunk.length;
            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
            this.chunkPos = this.pos;
            this.chunkOff = 0;
          }
        }
        readNext() {
          if (this.chunkOff >= this.chunk.length) {
            this.getChunk();
            if (this.chunkOff == this.chunk.length)
              return this.next = -1;
          }
          return this.next = this.chunk.charCodeAt(this.chunkOff);
        }
        advance(n = 1) {
          this.chunkOff += n;
          while (this.pos + n >= this.range.to) {
            if (this.rangeIndex == this.ranges.length - 1)
              return this.setDone();
            n -= this.range.to - this.pos;
            this.range = this.ranges[++this.rangeIndex];
            this.pos = this.range.from;
          }
          this.pos += n;
          if (this.pos >= this.token.lookAhead)
            this.token.lookAhead = this.pos + 1;
          return this.readNext();
        }
        setDone() {
          this.pos = this.chunkPos = this.end;
          this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
          this.chunk = "";
          return this.next = -1;
        }
        reset(pos, token) {
          if (token) {
            this.token = token;
            token.start = pos;
            token.lookAhead = pos + 1;
            token.value = token.extended = -1;
          } else {
            this.token = nullToken;
          }
          if (this.pos != pos) {
            this.pos = pos;
            if (pos == this.end) {
              this.setDone();
              return this;
            }
            while (pos < this.range.from)
              this.range = this.ranges[--this.rangeIndex];
            while (pos >= this.range.to)
              this.range = this.ranges[++this.rangeIndex];
            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
              this.chunkOff = pos - this.chunkPos;
            } else {
              this.chunk = "";
              this.chunkOff = 0;
            }
            this.readNext();
          }
          return this;
        }
        read(from, to2) {
          if (from >= this.chunkPos && to2 <= this.chunkPos + this.chunk.length)
            return this.chunk.slice(from - this.chunkPos, to2 - this.chunkPos);
          if (from >= this.chunk2Pos && to2 <= this.chunk2Pos + this.chunk2.length)
            return this.chunk2.slice(from - this.chunk2Pos, to2 - this.chunk2Pos);
          if (from >= this.range.from && to2 <= this.range.to)
            return this.input.read(from, to2);
          let result = "";
          for (let r of this.ranges) {
            if (r.from >= to2)
              break;
            if (r.to > from)
              result += this.input.read(Math.max(r.from, from), Math.min(r.to, to2));
          }
          return result;
        }
      };
      var TokenGroup = class {
        constructor(data, id2) {
          this.data = data;
          this.id = id2;
        }
        token(input, stack) {
          let { parser } = stack.p;
          readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);
        }
      };
      TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
      var LocalTokenGroup = class {
        constructor(data, precTable, elseToken) {
          this.precTable = precTable;
          this.elseToken = elseToken;
          this.data = typeof data == "string" ? decodeArray(data) : data;
        }
        token(input, stack) {
          let start = input.pos, skipped = 0;
          for (; ; ) {
            let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);
            readToken(this.data, input, stack, 0, this.data, this.precTable);
            if (input.token.value > -1)
              break;
            if (this.elseToken == null)
              return;
            if (!atEof)
              skipped++;
            if (nextPos == null)
              break;
            input.reset(nextPos, input.token);
          }
          if (skipped) {
            input.reset(start, input.token);
            input.acceptToken(this.elseToken, skipped);
          }
        }
      };
      LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
      var ExternalTokenizer = class {
        constructor(token, options = {}) {
          this.token = token;
          this.contextual = !!options.contextual;
          this.fallback = !!options.fallback;
          this.extend = !!options.extend;
        }
      };
      function readToken(data, input, stack, group, precTable, precOffset) {
        let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
        scan:
          for (; ; ) {
            if ((groupMask & data[state]) == 0)
              break;
            let accEnd = data[state + 1];
            for (let i = state + 3; i < accEnd; i += 2)
              if ((data[i + 1] & groupMask) > 0) {
                let term = data[i];
                if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
                  input.acceptToken(term);
                  break;
                }
              }
            let next = input.next, low = 0, high = data[state + 2];
            if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 && data[accEnd + high * 3 - 3] == 65535) {
              state = data[accEnd + high * 3 - 1];
              continue scan;
            }
            for (; low < high; ) {
              let mid = low + high >> 1;
              let index = accEnd + mid + (mid << 1);
              let from = data[index], to2 = data[index + 1] || 65536;
              if (next < from)
                high = mid;
              else if (next >= to2)
                low = mid + 1;
              else {
                state = data[index + 2];
                input.advance();
                continue scan;
              }
            }
            break;
          }
      }
      function findOffset(data, start, term) {
        for (let i = start, next; (next = data[i]) != 65535; i++)
          if (next == term)
            return i - start;
        return -1;
      }
      function overrides(token, prev, tableData, tableOffset) {
        let iPrev = findOffset(tableData, tableOffset, prev);
        return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
      }
      var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
      var stackIDs = null;
      function cutAt(tree, pos, side) {
        let cursor = tree.cursor(common.IterMode.IncludeAnonymous);
        cursor.moveTo(pos);
        for (; ; ) {
          if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
            for (; ; ) {
              if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
                return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25));
              if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                break;
              if (!cursor.parent())
                return side < 0 ? 0 : tree.length;
            }
        }
      }
      var FragmentCursor = class {
        constructor(fragments, nodeSet) {
          this.fragments = fragments;
          this.nodeSet = nodeSet;
          this.i = 0;
          this.fragment = null;
          this.safeFrom = -1;
          this.safeTo = -1;
          this.trees = [];
          this.start = [];
          this.index = [];
          this.nextFragment();
        }
        nextFragment() {
          let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
          if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while (this.trees.length) {
              this.trees.pop();
              this.start.pop();
              this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
          } else {
            this.nextStart = 1e9;
          }
        }
        nodeAt(pos) {
          if (pos < this.nextStart)
            return null;
          while (this.fragment && this.safeTo <= pos)
            this.nextFragment();
          if (!this.fragment)
            return null;
          for (; ; ) {
            let last = this.trees.length - 1;
            if (last < 0) {
              this.nextFragment();
              return null;
            }
            let top = this.trees[last], index = this.index[last];
            if (index == top.children.length) {
              this.trees.pop();
              this.start.pop();
              this.index.pop();
              continue;
            }
            let next = top.children[index];
            let start = this.start[last] + top.positions[index];
            if (start > pos) {
              this.nextStart = start;
              return null;
            }
            if (next instanceof common.Tree) {
              if (start == pos) {
                if (start < this.safeFrom)
                  return null;
                let end = start + next.length;
                if (end <= this.safeTo) {
                  let lookAhead = next.prop(common.NodeProp.lookAhead);
                  if (!lookAhead || end + lookAhead < this.fragment.to)
                    return next;
                }
              }
              this.index[last]++;
              if (start + next.length >= Math.max(this.safeFrom, pos)) {
                this.trees.push(next);
                this.start.push(start);
                this.index.push(0);
              }
            } else {
              this.index[last]++;
              this.nextStart = start + next.length;
            }
          }
        }
      };
      var TokenCache = class {
        constructor(parser, stream) {
          this.stream = stream;
          this.tokens = [];
          this.mainToken = null;
          this.actions = [];
          this.tokens = parser.tokenizers.map((_) => new CachedToken());
        }
        getActions(stack) {
          let actionIndex = 0;
          let main = null;
          let { parser } = stack.p, { tokenizers } = parser;
          let mask = parser.stateSlot(stack.state, 3);
          let context = stack.curContext ? stack.curContext.hash : 0;
          let lookAhead = 0;
          for (let i = 0; i < tokenizers.length; i++) {
            if ((1 << i & mask) == 0)
              continue;
            let tokenizer = tokenizers[i], token = this.tokens[i];
            if (main && !tokenizer.fallback)
              continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
              this.updateCachedToken(token, tokenizer, stack);
              token.mask = mask;
              token.context = context;
            }
            if (token.lookAhead > token.end + 25)
              lookAhead = Math.max(token.lookAhead, lookAhead);
            if (token.value != 0) {
              let startIndex = actionIndex;
              if (token.extended > -1)
                actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
              actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
              if (!tokenizer.extend) {
                main = token;
                if (actionIndex > startIndex)
                  break;
              }
            }
          }
          while (this.actions.length > actionIndex)
            this.actions.pop();
          if (lookAhead)
            stack.setLookAhead(lookAhead);
          if (!main && stack.pos == this.stream.end) {
            main = new CachedToken();
            main.value = stack.p.parser.eofTerm;
            main.start = main.end = stack.pos;
            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
          }
          this.mainToken = main;
          return this.actions;
        }
        getMainToken(stack) {
          if (this.mainToken)
            return this.mainToken;
          let main = new CachedToken(), { pos, p } = stack;
          main.start = pos;
          main.end = Math.min(pos + 1, p.stream.end);
          main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
          return main;
        }
        updateCachedToken(token, tokenizer, stack) {
          let start = this.stream.clipPos(stack.pos);
          tokenizer.token(this.stream.reset(start, token), stack);
          if (token.value > -1) {
            let { parser } = stack.p;
            for (let i = 0; i < parser.specialized.length; i++)
              if (parser.specialized[i] == token.value) {
                let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);
                if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                  if ((result & 1) == 0)
                    token.value = result >> 1;
                  else
                    token.extended = result >> 1;
                  break;
                }
              }
          } else {
            token.value = 0;
            token.end = this.stream.clipPos(start + 1);
          }
        }
        putAction(action, token, end, index) {
          for (let i = 0; i < index; i += 3)
            if (this.actions[i] == action)
              return index;
          this.actions[index++] = action;
          this.actions[index++] = token;
          this.actions[index++] = end;
          return index;
        }
        addActions(stack, token, end, index) {
          let { state } = stack, { parser } = stack.p, { data } = parser;
          for (let set = 0; set < 2; set++) {
            for (let i = parser.stateSlot(state, set ? 2 : 1); ; i += 3) {
              if (data[i] == 65535) {
                if (data[i + 1] == 1) {
                  i = pair(data, i + 2);
                } else {
                  if (index == 0 && data[i + 1] == 2)
                    index = this.putAction(pair(data, i + 2), token, end, index);
                  break;
                }
              }
              if (data[i] == token)
                index = this.putAction(pair(data, i + 1), token, end, index);
            }
          }
          return index;
        }
      };
      var Parse = class {
        constructor(parser, input, fragments, ranges) {
          this.parser = parser;
          this.input = input;
          this.ranges = ranges;
          this.recovering = 0;
          this.nextStackID = 9812;
          this.minStackPos = 0;
          this.reused = [];
          this.stoppedAt = null;
          this.lastBigReductionStart = -1;
          this.lastBigReductionSize = 0;
          this.bigReductionCount = 0;
          this.stream = new InputStream(input, ranges);
          this.tokens = new TokenCache(parser, this.stream);
          this.topTerm = parser.top[1];
          let { from } = ranges[0];
          this.stacks = [Stack.start(this, parser.top[0], from)];
          this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4 ? new FragmentCursor(fragments, parser.nodeSet) : null;
        }
        get parsedPos() {
          return this.minStackPos;
        }
        advance() {
          let stacks = this.stacks, pos = this.minStackPos;
          let newStacks = this.stacks = [];
          let stopped, stoppedTokens;
          if (this.bigReductionCount > 300 && stacks.length == 1) {
            let [s] = stacks;
            while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) {
            }
            this.bigReductionCount = this.lastBigReductionSize = 0;
          }
          for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i];
            for (; ; ) {
              this.tokens.mainToken = null;
              if (stack.pos > pos) {
                newStacks.push(stack);
              } else if (this.advanceStack(stack, newStacks, stacks)) {
                continue;
              } else {
                if (!stopped) {
                  stopped = [];
                  stoppedTokens = [];
                }
                stopped.push(stack);
                let tok = this.tokens.getMainToken(stack);
                stoppedTokens.push(tok.value, tok.end);
              }
              break;
            }
          }
          if (!newStacks.length) {
            let finished = stopped && findFinished(stopped);
            if (finished) {
              if (verbose)
                console.log("Finish with " + this.stackID(finished));
              return this.stackToTree(finished);
            }
            if (this.parser.strict) {
              if (verbose && stopped)
                console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
              throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering)
              this.recovering = 5;
          }
          if (this.recovering && stopped) {
            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished) {
              if (verbose)
                console.log("Force-finish " + this.stackID(finished));
              return this.stackToTree(finished.forceAll());
            }
          }
          if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
            if (newStacks.length > maxRemaining) {
              newStacks.sort((a, b) => b.score - a.score);
              while (newStacks.length > maxRemaining)
                newStacks.pop();
            }
            if (newStacks.some((s) => s.reducePos > pos))
              this.recovering--;
          } else if (newStacks.length > 1) {
            outer:
              for (let i = 0; i < newStacks.length - 1; i++) {
                let stack = newStacks[i];
                for (let j2 = i + 1; j2 < newStacks.length; j2++) {
                  let other = newStacks[j2];
                  if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
                    if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                      newStacks.splice(j2--, 1);
                    } else {
                      newStacks.splice(i--, 1);
                      continue outer;
                    }
                  }
                }
              }
            if (newStacks.length > 12)
              newStacks.splice(12, newStacks.length - 12);
          }
          this.minStackPos = newStacks[0].pos;
          for (let i = 1; i < newStacks.length; i++)
            if (newStacks[i].pos < this.minStackPos)
              this.minStackPos = newStacks[i].pos;
          return null;
        }
        stopAt(pos) {
          if (this.stoppedAt != null && this.stoppedAt < pos)
            throw new RangeError("Can't move stoppedAt forward");
          this.stoppedAt = pos;
        }
        advanceStack(stack, stacks, split) {
          let start = stack.pos, { parser } = this;
          let base = verbose ? this.stackID(stack) + " -> " : "";
          if (this.stoppedAt != null && start > this.stoppedAt)
            return stack.forceReduce() ? stack : null;
          if (this.fragments) {
            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
            for (let cached = this.fragments.nodeAt(start); cached; ) {
              let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
              if (match > -1 && cached.length && (!strictCx || (cached.prop(common.NodeProp.contextHash) || 0) == cxHash)) {
                stack.useNode(cached, match);
                if (verbose)
                  console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                return true;
              }
              if (!(cached instanceof common.Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                break;
              let inner = cached.children[0];
              if (inner instanceof common.Tree && cached.positions[0] == 0)
                cached = inner;
              else
                break;
            }
          }
          let defaultReduce = parser.stateSlot(stack.state, 4);
          if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose)
              console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535)})`);
            return true;
          }
          if (stack.stack.length >= 9e3) {
            while (stack.stack.length > 6e3 && stack.forceReduce()) {
            }
          }
          let actions = this.tokens.getActions(stack);
          for (let i = 0; i < actions.length; ) {
            let action = actions[i++], term = actions[i++], end = actions[i++];
            let last = i == actions.length || !split;
            let localStack = last ? stack : stack.split();
            let main = this.tokens.mainToken;
            localStack.apply(action, term, main ? main.start : localStack.pos, end);
            if (verbose)
              console.log(base + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser.getName(action & 65535)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last)
              return true;
            else if (localStack.pos > start)
              stacks.push(localStack);
            else
              split.push(localStack);
          }
          return false;
        }
        advanceFully(stack, newStacks) {
          let pos = stack.pos;
          for (; ; ) {
            if (!this.advanceStack(stack, null, null))
              return false;
            if (stack.pos > pos) {
              pushStackDedup(stack, newStacks);
              return true;
            }
          }
        }
        runRecovery(stacks, tokens, newStacks) {
          let finished = null, restarted = false;
          for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
              if (restarted)
                continue;
              restarted = true;
              stack.restart();
              if (verbose)
                console.log(base + this.stackID(stack) + " (restarted)");
              let done = this.advanceFully(stack, newStacks);
              if (done)
                continue;
            }
            let force = stack.split(), forceBase = base;
            for (let j2 = 0; force.forceReduce() && j2 < 10; j2++) {
              if (verbose)
                console.log(forceBase + this.stackID(force) + " (via force-reduce)");
              let done = this.advanceFully(force, newStacks);
              if (done)
                break;
              if (verbose)
                forceBase = this.stackID(force) + " -> ";
            }
            for (let insert of stack.recoverByInsert(token)) {
              if (verbose)
                console.log(base + this.stackID(insert) + " (via recover-insert)");
              this.advanceFully(insert, newStacks);
            }
            if (this.stream.end > stack.pos) {
              if (tokenEnd == stack.pos) {
                tokenEnd++;
                token = 0;
              }
              stack.recoverByDelete(token, tokenEnd);
              if (verbose)
                console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
              pushStackDedup(stack, newStacks);
            } else if (!finished || finished.score < stack.score) {
              finished = stack;
            }
          }
          return finished;
        }
        stackToTree(stack) {
          stack.close();
          return common.Tree.build({
            buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.ranges[0].from,
            length: stack.pos - this.ranges[0].from,
            minRepeatType: this.parser.minRepeatTerm
          });
        }
        stackID(stack) {
          let id2 = (stackIDs || (stackIDs = new WeakMap())).get(stack);
          if (!id2)
            stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
          return id2 + stack;
        }
      };
      function pushStackDedup(stack, newStacks) {
        for (let i = 0; i < newStacks.length; i++) {
          let other = newStacks[i];
          if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i].score < stack.score)
              newStacks[i] = stack;
            return;
          }
        }
        newStacks.push(stack);
      }
      var Dialect = class {
        constructor(source, flags, disabled) {
          this.source = source;
          this.flags = flags;
          this.disabled = disabled;
        }
        allows(term) {
          return !this.disabled || this.disabled[term] == 0;
        }
      };
      var id = (x) => x;
      var ContextTracker = class {
        constructor(spec) {
          this.start = spec.start;
          this.shift = spec.shift || id;
          this.reduce = spec.reduce || id;
          this.reuse = spec.reuse || id;
          this.hash = spec.hash || (() => 0);
          this.strict = spec.strict !== false;
        }
      };
      var LRParser = class extends common.Parser {
        constructor(spec) {
          super();
          this.wrappers = [];
          if (spec.version != 14)
            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
          let nodeNames = spec.nodeNames.split(" ");
          this.minRepeatTerm = nodeNames.length;
          for (let i = 0; i < spec.repeatNodeCount; i++)
            nodeNames.push("");
          let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
          let nodeProps = [];
          for (let i = 0; i < nodeNames.length; i++)
            nodeProps.push([]);
          function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
          }
          if (spec.nodeProps)
            for (let propSpec of spec.nodeProps) {
              let prop = propSpec[0];
              if (typeof prop == "string")
                prop = common.NodeProp[prop];
              for (let i = 1; i < propSpec.length; ) {
                let next = propSpec[i++];
                if (next >= 0) {
                  setProp(next, prop, propSpec[i++]);
                } else {
                  let value = propSpec[i + -next];
                  for (let j2 = -next; j2 > 0; j2--)
                    setProp(propSpec[i++], prop, value);
                  i++;
                }
              }
            }
          this.nodeSet = new common.NodeSet(nodeNames.map((name, i) => common.NodeType.define({
            name: i >= this.minRepeatTerm ? void 0 : name,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
          })));
          if (spec.propSources)
            this.nodeSet = this.nodeSet.extend(...spec.propSources);
          this.strict = false;
          this.bufferLength = common.DefaultBufferLength;
          let tokenArray = decodeArray(spec.tokenData);
          this.context = spec.context;
          this.specializerSpecs = spec.specialized || [];
          this.specialized = new Uint16Array(this.specializerSpecs.length);
          for (let i = 0; i < this.specializerSpecs.length; i++)
            this.specialized[i] = this.specializerSpecs[i].term;
          this.specializers = this.specializerSpecs.map(getSpecializer);
          this.states = decodeArray(spec.states, Uint32Array);
          this.data = decodeArray(spec.stateData);
          this.goto = decodeArray(spec.goto);
          this.maxTerm = spec.maxTerm;
          this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
          this.topRules = spec.topRules;
          this.dialects = spec.dialects || {};
          this.dynamicPrecedences = spec.dynamicPrecedences || null;
          this.tokenPrecTable = spec.tokenPrec;
          this.termNames = spec.termNames || null;
          this.maxNode = this.nodeSet.types.length - 1;
          this.dialect = this.parseDialect();
          this.top = this.topRules[Object.keys(this.topRules)[0]];
        }
        createParse(input, fragments, ranges) {
          let parse = new Parse(this, input, fragments, ranges);
          for (let w of this.wrappers)
            parse = w(parse, input, fragments, ranges);
          return parse;
        }
        getGoto(state, term, loose = false) {
          let table = this.goto;
          if (term >= table[0])
            return -1;
          for (let pos = table[term + 1]; ; ) {
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose)
              return target;
            for (let end = pos + (groupTag >> 1); pos < end; pos++)
              if (table[pos] == state)
                return target;
            if (last)
              return -1;
          }
        }
        hasAction(state, terminal) {
          let data = this.data;
          for (let set = 0; set < 2; set++) {
            for (let i = this.stateSlot(state, set ? 2 : 1), next; ; i += 3) {
              if ((next = data[i]) == 65535) {
                if (data[i + 1] == 1)
                  next = data[i = pair(data, i + 2)];
                else if (data[i + 1] == 2)
                  return pair(data, i + 2);
                else
                  break;
              }
              if (next == terminal || next == 0)
                return pair(data, i + 1);
            }
          }
          return 0;
        }
        stateSlot(state, slot) {
          return this.states[state * 6 + slot];
        }
        stateFlag(state, flag) {
          return (this.stateSlot(state, 0) & flag) > 0;
        }
        validAction(state, action) {
          return !!this.allActions(state, (a) => a == action ? true : null);
        }
        allActions(state, action) {
          let deflt = this.stateSlot(state, 4);
          let result = deflt ? action(deflt) : void 0;
          for (let i = this.stateSlot(state, 1); result == null; i += 3) {
            if (this.data[i] == 65535) {
              if (this.data[i + 1] == 1)
                i = pair(this.data, i + 2);
              else
                break;
            }
            result = action(pair(this.data, i + 1));
          }
          return result;
        }
        nextStates(state) {
          let result = [];
          for (let i = this.stateSlot(state, 1); ; i += 3) {
            if (this.data[i] == 65535) {
              if (this.data[i + 1] == 1)
                i = pair(this.data, i + 2);
              else
                break;
            }
            if ((this.data[i + 2] & 65536 >> 16) == 0) {
              let value = this.data[i + 1];
              if (!result.some((v, i2) => i2 & 1 && v == value))
                result.push(this.data[i], value);
            }
          }
          return result;
        }
        configure(config) {
          let copy = Object.assign(Object.create(LRParser.prototype), this);
          if (config.props)
            copy.nodeSet = this.nodeSet.extend(...config.props);
          if (config.top) {
            let info = this.topRules[config.top];
            if (!info)
              throw new RangeError(`Invalid top rule name ${config.top}`);
            copy.top = info;
          }
          if (config.tokenizers)
            copy.tokenizers = this.tokenizers.map((t) => {
              let found = config.tokenizers.find((r) => r.from == t);
              return found ? found.to : t;
            });
          if (config.specializers) {
            copy.specializers = this.specializers.slice();
            copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
              let found = config.specializers.find((r) => r.from == s.external);
              if (!found)
                return s;
              let spec = Object.assign(Object.assign({}, s), { external: found.to });
              copy.specializers[i] = getSpecializer(spec);
              return spec;
            });
          }
          if (config.contextTracker)
            copy.context = config.contextTracker;
          if (config.dialect)
            copy.dialect = this.parseDialect(config.dialect);
          if (config.strict != null)
            copy.strict = config.strict;
          if (config.wrap)
            copy.wrappers = copy.wrappers.concat(config.wrap);
          if (config.bufferLength != null)
            copy.bufferLength = config.bufferLength;
          return copy;
        }
        hasWrappers() {
          return this.wrappers.length > 0;
        }
        getName(term) {
          return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
        }
        get eofTerm() {
          return this.maxNode + 1;
        }
        get topNode() {
          return this.nodeSet.types[this.top[1]];
        }
        dynamicPrecedence(term) {
          let prec = this.dynamicPrecedences;
          return prec == null ? 0 : prec[term] || 0;
        }
        parseDialect(dialect) {
          let values = Object.keys(this.dialects), flags = values.map(() => false);
          if (dialect)
            for (let part of dialect.split(" ")) {
              let id2 = values.indexOf(part);
              if (id2 >= 0)
                flags[id2] = true;
            }
          let disabled = null;
          for (let i = 0; i < values.length; i++)
            if (!flags[i]) {
              for (let j2 = this.dialects[values[i]], id2; (id2 = this.data[j2++]) != 65535; )
                (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
            }
          return new Dialect(dialect, flags, disabled);
        }
        static deserialize(spec) {
          return new LRParser(spec);
        }
      };
      function pair(data, off) {
        return data[off] | data[off + 1] << 16;
      }
      function findFinished(stacks) {
        let best = null;
        for (let stack of stacks) {
          let stopped = stack.p.stoppedAt;
          if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score))
            best = stack;
        }
        return best;
      }
      function getSpecializer(spec) {
        if (spec.external) {
          let mask = spec.extend ? 1 : 0;
          return (value, stack) => spec.external(value, stack) << 1 | mask;
        }
        return spec.get;
      }
      exports.ContextTracker = ContextTracker;
      exports.ExternalTokenizer = ExternalTokenizer;
      exports.InputStream = InputStream;
      exports.LRParser = LRParser;
      exports.LocalTokenGroup = LocalTokenGroup;
      exports.Stack = Stack;
    }
  });

  // __tmp__/static/js/lezer-parsers/level1-parser.terms.js
  var require_level1_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level1-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorInvalid = exports.Turtle = exports.Echo = exports.Ask = exports.Text = exports.Print = exports.Command = exports.Program = exports.Comment = exports.color = exports.ask = exports.echo = exports.turn = exports.forward = exports.print = void 0;
      exports.print = 1, exports.forward = 2, exports.turn = 3, exports.echo = 4, exports.ask = 5, exports.color = 6, exports.Comment = 7, exports.Program = 8, exports.Command = 9, exports.Print = 10, exports.Text = 11, exports.Ask = 12, exports.Echo = 13, exports.Turtle = 14, exports.ErrorInvalid = 18;
    }
  });

  // __tmp__/static/js/lezer-parsers/level2-parser.terms.js
  var require_level2_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level2-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorInvalid = exports.Sleep = exports.Turtle = exports.Print = exports.Ask = exports.Text = exports.Assign = exports.Command = exports.Program = exports.Comment = exports.is = exports.sleep = exports.color = exports.turn = exports.forward = exports.print = exports.ask = void 0;
      exports.ask = 1, exports.print = 2, exports.forward = 3, exports.turn = 4, exports.color = 5, exports.sleep = 6, exports.is = 7, exports.Comment = 8, exports.Program = 9, exports.Command = 10, exports.Assign = 11, exports.Text = 12, exports.Ask = 13, exports.Print = 14, exports.Turtle = 15, exports.Sleep = 19, exports.ErrorInvalid = 20;
    }
  });

  // __tmp__/static/js/lezer-parsers/level3-parser.terms.js
  var require_level3_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level3-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorInvalid = exports.Remove = exports.Add = exports.Sleep = exports.Turtle = exports.Print = exports.Ask = exports.Comma = exports.AssignList = exports.ListAccess = exports.Text = exports.Assign = exports.Command = exports.Program = exports.Comment = exports.toList = exports.remove = exports.from = exports.add = exports.is = exports.sleep = exports.color = exports.turn = exports.forward = exports.print = exports.random = exports.at = exports.ask = void 0;
      exports.ask = 1, exports.at = 2, exports.random = 3, exports.print = 4, exports.forward = 5, exports.turn = 6, exports.color = 7, exports.sleep = 8, exports.is = 9, exports.add = 10, exports.from = 11, exports.remove = 12, exports.toList = 13, exports.Comment = 14, exports.Program = 15, exports.Command = 16, exports.Assign = 17, exports.Text = 18, exports.ListAccess = 19, exports.AssignList = 20, exports.Comma = 21, exports.Ask = 22, exports.Print = 23, exports.Turtle = 24, exports.Sleep = 28, exports.Add = 29, exports.Remove = 30, exports.ErrorInvalid = 31;
    }
  });

  // __tmp__/static/js/lezer-parsers/level4-parser.terms.js
  var require_level4_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level4-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorInvalid = exports.Remove = exports.Add = exports.Sleep = exports.Turtle = exports.Print = exports.Clear = exports.String = exports.Ask = exports.Comma = exports.AssignList = exports.ListAccess = exports.Text = exports.Assign = exports.Command = exports.Program = exports.Comment = exports.clear = exports.toList = exports.remove = exports.from = exports.add = exports.is = exports.sleep = exports.color = exports.turn = exports.forward = exports.print = exports.random = exports.at = exports.ask = void 0;
      exports.ask = 1, exports.at = 2, exports.random = 3, exports.print = 4, exports.forward = 5, exports.turn = 6, exports.color = 7, exports.sleep = 8, exports.is = 9, exports.add = 10, exports.from = 11, exports.remove = 12, exports.toList = 13, exports.clear = 14, exports.Comment = 15, exports.Program = 16, exports.Command = 17, exports.Assign = 18, exports.Text = 19, exports.ListAccess = 20, exports.AssignList = 21, exports.Comma = 22, exports.Ask = 23, exports.String = 24, exports.Clear = 25, exports.Print = 26, exports.Turtle = 27, exports.Sleep = 31, exports.Add = 32, exports.Remove = 33, exports.ErrorInvalid = 34;
    }
  });

  // __tmp__/static/js/lezer-parsers/level5-parser.terms.js
  var require_level5_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level5-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Else = exports.ErrorInvalid = exports.IfLessCommand = exports.Condition = exports.If = exports.Remove = exports.Add = exports.Sleep = exports.Turtle = exports.Print = exports.Clear = exports.String = exports.Ask = exports.Comma = exports.AssignList = exports.ListAccess = exports.Text = exports.Assign = exports.Command = exports.Program = exports.Comment = exports.not_in = exports.ins = exports.clear = exports.toList = exports.remove = exports.from = exports.add = exports.is = exports.sleep = exports.color = exports.turn = exports.forward = exports.print = exports.pressed = exports.elses = exports.ifs = exports.random = exports.at = exports.ask = void 0;
      exports.ask = 1, exports.at = 2, exports.random = 3, exports.ifs = 4, exports.elses = 5, exports.pressed = 6, exports.print = 7, exports.forward = 8, exports.turn = 9, exports.color = 10, exports.sleep = 11, exports.is = 12, exports.add = 13, exports.from = 14, exports.remove = 15, exports.toList = 16, exports.clear = 17, exports.ins = 18, exports.not_in = 19, exports.Comment = 20, exports.Program = 21, exports.Command = 22, exports.Assign = 23, exports.Text = 24, exports.ListAccess = 25, exports.AssignList = 26, exports.Comma = 27, exports.Ask = 28, exports.String = 29, exports.Clear = 30, exports.Print = 31, exports.Turtle = 32, exports.Sleep = 36, exports.Add = 37, exports.Remove = 38, exports.If = 39, exports.Condition = 40, exports.IfLessCommand = 44, exports.ErrorInvalid = 45, exports.Else = 46;
    }
  });

  // __tmp__/static/js/lezer-parsers/level6-parser.terms.js
  var require_level6_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level6-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Else = exports.ErrorInvalid = exports.IfLessCommand = exports.Condition = exports.If = exports.Remove = exports.Add = exports.Sleep = exports.Turtle = exports.Print = exports.Clear = exports.String = exports.Ask = exports.Comma = exports.AssignList = exports.ListAccess = exports.Int = exports.Expression = exports.Text = exports.Assign = exports.Command = exports.Program = exports.Comment = exports.not_in = exports.ins = exports.clear = exports.toList = exports.remove = exports.from = exports.add = exports.is = exports.sleep = exports.color = exports.turn = exports.forward = exports.print = exports.pressed = exports.elses = exports.ifs = exports.random = exports.at = exports.ask = void 0;
      exports.ask = 1, exports.at = 2, exports.random = 3, exports.ifs = 4, exports.elses = 5, exports.pressed = 6, exports.print = 7, exports.forward = 8, exports.turn = 9, exports.color = 10, exports.sleep = 11, exports.is = 12, exports.add = 13, exports.from = 14, exports.remove = 15, exports.toList = 16, exports.clear = 17, exports.ins = 18, exports.not_in = 19, exports.Comment = 20, exports.Program = 21, exports.Command = 22, exports.Assign = 23, exports.Text = 24, exports.Expression = 26, exports.Int = 27, exports.ListAccess = 30, exports.AssignList = 31, exports.Comma = 32, exports.Ask = 33, exports.String = 34, exports.Clear = 35, exports.Print = 36, exports.Turtle = 37, exports.Sleep = 41, exports.Add = 42, exports.Remove = 43, exports.If = 44, exports.Condition = 45, exports.IfLessCommand = 49, exports.ErrorInvalid = 50, exports.Else = 51;
    }
  });

  // __tmp__/static/js/lezer-parsers/level7-parser.terms.js
  var require_level7_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level7-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Else = exports.ErrorInvalid = exports.Repeat = exports.IfLessCommand = exports.Condition = exports.If = exports.Remove = exports.Add = exports.Sleep = exports.Turtle = exports.Print = exports.Clear = exports.String = exports.Ask = exports.Comma = exports.AssignList = exports.ListAccess = exports.Int = exports.Expression = exports.Text = exports.Assign = exports.Command = exports.Program = exports.Comment = exports.times = exports.repeat = exports.not_in = exports.ins = exports.clear = exports.toList = exports.remove = exports.from = exports.add = exports.is = exports.sleep = exports.color = exports.turn = exports.forward = exports.print = exports.elses = exports.pressed = exports.ifs = exports.random = exports.at = exports.ask = void 0;
      exports.ask = 1, exports.at = 2, exports.random = 3, exports.ifs = 4, exports.pressed = 5, exports.elses = 6, exports.print = 7, exports.forward = 8, exports.turn = 9, exports.color = 10, exports.sleep = 11, exports.is = 12, exports.add = 13, exports.from = 14, exports.remove = 15, exports.toList = 16, exports.clear = 17, exports.ins = 18, exports.not_in = 19, exports.repeat = 20, exports.times = 21, exports.Comment = 22, exports.Program = 23, exports.Command = 24, exports.Assign = 25, exports.Text = 26, exports.Expression = 28, exports.Int = 29, exports.ListAccess = 32, exports.AssignList = 33, exports.Comma = 34, exports.Ask = 35, exports.String = 36, exports.Clear = 37, exports.Print = 38, exports.Turtle = 39, exports.Sleep = 43, exports.Add = 44, exports.Remove = 45, exports.If = 46, exports.Condition = 47, exports.IfLessCommand = 51, exports.Repeat = 52, exports.ErrorInvalid = 53, exports.Else = 54;
    }
  });

  // __tmp__/static/js/lezer-parsers/level8-parser.terms.js
  var require_level8_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level8-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorInvalid = exports.Repeat = exports.Else = exports.Condition = exports.If = exports.Remove = exports.Add = exports.Sleep = exports.Turtle = exports.Print = exports.Clear = exports.String = exports.Ask = exports.Comma = exports.AssignList = exports.ListAccess = exports.Int = exports.Expression = exports.Text = exports.Assign = exports.Command = exports.Program = exports.Comment = exports.times = exports.repeat = exports.not_in = exports.ins = exports.clear = exports.toList = exports.remove = exports.from = exports.add = exports.is = exports.sleep = exports.color = exports.turn = exports.forward = exports.print = exports.elses = exports.pressed = exports.ifs = exports.random = exports.at = exports.ask = void 0;
      exports.ask = 1, exports.at = 2, exports.random = 3, exports.ifs = 4, exports.pressed = 5, exports.elses = 6, exports.print = 7, exports.forward = 8, exports.turn = 9, exports.color = 10, exports.sleep = 11, exports.is = 12, exports.add = 13, exports.from = 14, exports.remove = 15, exports.toList = 16, exports.clear = 17, exports.ins = 18, exports.not_in = 19, exports.repeat = 20, exports.times = 21, exports.Comment = 22, exports.Program = 23, exports.Command = 24, exports.Assign = 25, exports.Text = 26, exports.Expression = 28, exports.Int = 29, exports.ListAccess = 32, exports.AssignList = 33, exports.Comma = 34, exports.Ask = 35, exports.String = 36, exports.Clear = 37, exports.Print = 38, exports.Turtle = 39, exports.Sleep = 43, exports.Add = 44, exports.Remove = 45, exports.If = 46, exports.Condition = 47, exports.Else = 51, exports.Repeat = 52, exports.ErrorInvalid = 53;
    }
  });

  // __tmp__/static/js/lezer-parsers/level10-parser.terms.js
  var require_level10_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level10-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorInvalid = exports.For = exports.Repeat = exports.Else = exports.Condition = exports.If = exports.Remove = exports.Add = exports.Sleep = exports.Turtle = exports.Print = exports.Clear = exports.String = exports.Ask = exports.Comma = exports.AssignList = exports.ListAccess = exports.Int = exports.Expression = exports.Text = exports.Assign = exports.Command = exports.Program = exports.Comment = exports.fors = exports.times = exports.repeat = exports.not_in = exports.ins = exports.clear = exports.toList = exports.remove = exports.from = exports.add = exports.is = exports.sleep = exports.color = exports.turn = exports.forward = exports.print = exports.elses = exports.pressed = exports.ifs = exports.random = exports.at = exports.ask = void 0;
      exports.ask = 1, exports.at = 2, exports.random = 3, exports.ifs = 4, exports.pressed = 5, exports.elses = 6, exports.print = 7, exports.forward = 8, exports.turn = 9, exports.color = 10, exports.sleep = 11, exports.is = 12, exports.add = 13, exports.from = 14, exports.remove = 15, exports.toList = 16, exports.clear = 17, exports.ins = 18, exports.not_in = 19, exports.repeat = 20, exports.times = 21, exports.fors = 22, exports.Comment = 23, exports.Program = 24, exports.Command = 25, exports.Assign = 26, exports.Text = 27, exports.Expression = 29, exports.Int = 30, exports.ListAccess = 33, exports.AssignList = 34, exports.Comma = 35, exports.Ask = 36, exports.String = 37, exports.Clear = 38, exports.Print = 39, exports.Turtle = 40, exports.Sleep = 44, exports.Add = 45, exports.Remove = 46, exports.If = 47, exports.Condition = 48, exports.Else = 52, exports.Repeat = 53, exports.For = 54, exports.ErrorInvalid = 55;
    }
  });

  // __tmp__/static/js/lezer-parsers/level11-parser.terms.js
  var require_level11_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level11-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorInvalid = exports.For = exports.Repeat = exports.Else = exports.Condition = exports.If = exports.Remove = exports.Add = exports.Sleep = exports.Turtle = exports.Print = exports.Clear = exports.String = exports.Ask = exports.Comma = exports.AssignList = exports.ListAccess = exports.Int = exports.Expression = exports.Text = exports.Assign = exports.Command = exports.Program = exports.Comment = exports.range = exports.to = exports.fors = exports.times = exports.repeat = exports.not_in = exports.ins = exports.clear = exports.toList = exports.remove = exports.from = exports.add = exports.is = exports.sleep = exports.color = exports.turn = exports.forward = exports.print = exports.elses = exports.pressed = exports.ifs = exports.random = exports.at = exports.ask = void 0;
      exports.ask = 1, exports.at = 2, exports.random = 3, exports.ifs = 4, exports.pressed = 5, exports.elses = 6, exports.print = 7, exports.forward = 8, exports.turn = 9, exports.color = 10, exports.sleep = 11, exports.is = 12, exports.add = 13, exports.from = 14, exports.remove = 15, exports.toList = 16, exports.clear = 17, exports.ins = 18, exports.not_in = 19, exports.repeat = 20, exports.times = 21, exports.fors = 22, exports.to = 23, exports.range = 24, exports.Comment = 25, exports.Program = 26, exports.Command = 27, exports.Assign = 28, exports.Text = 29, exports.Expression = 31, exports.Int = 32, exports.ListAccess = 35, exports.AssignList = 36, exports.Comma = 37, exports.Ask = 38, exports.String = 39, exports.Clear = 40, exports.Print = 41, exports.Turtle = 42, exports.Sleep = 46, exports.Add = 47, exports.Remove = 48, exports.If = 49, exports.Condition = 50, exports.Else = 54, exports.Repeat = 55, exports.For = 56, exports.ErrorInvalid = 57;
    }
  });

  // __tmp__/static/js/lezer-parsers/level12-parser.terms.js
  var require_level12_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level12-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Condition = exports.If = exports.Remove = exports.Add = exports.Sleep = exports.Turtle = exports.Arguments = exports.Call = exports.Print = exports.Clear = exports.Ask = exports.Comma = exports.AssignList = exports.String = exports.Expression = exports.Number = exports.ListAccess = exports.Text = exports.Assign = exports.Command = exports.Program = exports.Comment = exports._with = exports.returns = exports.define = exports.call = exports.range = exports.to = exports.fors = exports.times = exports.repeat = exports.not_in = exports.ins = exports.clear = exports.toList = exports.remove = exports.from = exports.add = exports.is = exports.sleep = exports.color = exports.turn = exports.forward = exports.print = exports.elses = exports.pressed = exports.ifs = exports.random = exports.at = exports.ask = void 0;
      exports.ErrorInvalid = exports.Return = exports.Define = exports.For = exports.Repeat = exports.Else = void 0;
      exports.ask = 1, exports.at = 2, exports.random = 3, exports.ifs = 4, exports.pressed = 5, exports.elses = 6, exports.print = 7, exports.forward = 8, exports.turn = 9, exports.color = 10, exports.sleep = 11, exports.is = 12, exports.add = 13, exports.from = 14, exports.remove = 15, exports.toList = 16, exports.clear = 17, exports.ins = 18, exports.not_in = 19, exports.repeat = 20, exports.times = 21, exports.fors = 22, exports.to = 23, exports.range = 24, exports.call = 25, exports.define = 26, exports.returns = 27, exports._with = 28, exports.Comment = 29, exports.Program = 30, exports.Command = 31, exports.Assign = 32, exports.Text = 33, exports.ListAccess = 34, exports.Number = 35, exports.Expression = 37, exports.String = 38, exports.AssignList = 41, exports.Comma = 42, exports.Ask = 43, exports.Clear = 44, exports.Print = 45, exports.Call = 46, exports.Arguments = 47, exports.Turtle = 48, exports.Sleep = 52, exports.Add = 53, exports.Remove = 54, exports.If = 55, exports.Condition = 56, exports.Else = 60, exports.Repeat = 61, exports.For = 62, exports.Define = 63, exports.Return = 64, exports.ErrorInvalid = 65;
    }
  });

  // __tmp__/static/js/lezer-parsers/level13-parser.terms.js
  var require_level13_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level13-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Remove = exports.Add = exports.Sleep = exports.Turtle = exports.Arguments = exports.Call = exports.Print = exports.Clear = exports.Ask = exports.Comma = exports.AssignList = exports.String = exports.Expression = exports.Number = exports.ListAccess = exports.Text = exports.Assign = exports.Command = exports.Program = exports.Comment = exports._with = exports.returns = exports.define = exports.call = exports.range = exports.to = exports.fors = exports.times = exports.repeat = exports.not_in = exports.ins = exports.clear = exports.toList = exports.remove = exports.from = exports.add = exports.is = exports.sleep = exports.color = exports.turn = exports.forward = exports.print = exports.or = exports.and = exports.elses = exports.pressed = exports.ifs = exports.random = exports.at = exports.ask = void 0;
      exports.ErrorInvalid = exports.Return = exports.Define = exports.For = exports.Repeat = exports.Else = exports.Condition = exports.If = void 0;
      exports.ask = 1, exports.at = 2, exports.random = 3, exports.ifs = 4, exports.pressed = 5, exports.elses = 6, exports.and = 7, exports.or = 8, exports.print = 9, exports.forward = 10, exports.turn = 11, exports.color = 12, exports.sleep = 13, exports.is = 14, exports.add = 15, exports.from = 16, exports.remove = 17, exports.toList = 18, exports.clear = 19, exports.ins = 20, exports.not_in = 21, exports.repeat = 22, exports.times = 23, exports.fors = 24, exports.to = 25, exports.range = 26, exports.call = 27, exports.define = 28, exports.returns = 29, exports._with = 30, exports.Comment = 31, exports.Program = 32, exports.Command = 33, exports.Assign = 34, exports.Text = 35, exports.ListAccess = 36, exports.Number = 37, exports.Expression = 39, exports.String = 40, exports.AssignList = 43, exports.Comma = 44, exports.Ask = 45, exports.Clear = 46, exports.Print = 47, exports.Call = 48, exports.Arguments = 49, exports.Turtle = 50, exports.Sleep = 54, exports.Add = 55, exports.Remove = 56, exports.If = 57, exports.Condition = 58, exports.Else = 62, exports.Repeat = 63, exports.For = 64, exports.Define = 65, exports.Return = 66, exports.ErrorInvalid = 67;
    }
  });

  // __tmp__/static/js/lezer-parsers/level14-parser.terms.js
  var require_level14_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level14-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Remove = exports.Add = exports.Sleep = exports.Turtle = exports.Arguments = exports.Call = exports.Print = exports.Clear = exports.Ask = exports.Comma = exports.AssignList = exports.String = exports.Expression = exports.Number = exports.ListAccess = exports.Text = exports.Assign = exports.Command = exports.Program = exports.Comment = exports._with = exports.returns = exports.define = exports.call = exports.range = exports.to = exports.fors = exports.times = exports.repeat = exports.not_in = exports.ins = exports.clear = exports.toList = exports.remove = exports.from = exports.add = exports.sleep = exports.color = exports.turn = exports.forward = exports.print = exports.is = exports.or = exports.and = exports.elses = exports.pressed = exports.ifs = exports.random = exports.at = exports.ask = void 0;
      exports.ErrorInvalid = exports.Return = exports.Define = exports.For = exports.Repeat = exports.Else = exports.Condition = exports.If = void 0;
      exports.ask = 1, exports.at = 2, exports.random = 3, exports.ifs = 4, exports.pressed = 5, exports.elses = 6, exports.and = 7, exports.or = 8, exports.is = 9, exports.print = 10, exports.forward = 11, exports.turn = 12, exports.color = 13, exports.sleep = 14, exports.add = 15, exports.from = 16, exports.remove = 17, exports.toList = 18, exports.clear = 19, exports.ins = 20, exports.not_in = 21, exports.repeat = 22, exports.times = 23, exports.fors = 24, exports.to = 25, exports.range = 26, exports.call = 27, exports.define = 28, exports.returns = 29, exports._with = 30, exports.Comment = 31, exports.Program = 32, exports.Command = 33, exports.Assign = 34, exports.Text = 35, exports.ListAccess = 36, exports.Number = 37, exports.Expression = 39, exports.String = 40, exports.AssignList = 43, exports.Comma = 44, exports.Ask = 45, exports.Clear = 46, exports.Print = 47, exports.Call = 48, exports.Arguments = 49, exports.Turtle = 50, exports.Sleep = 54, exports.Add = 55, exports.Remove = 56, exports.If = 57, exports.Condition = 58, exports.Else = 68, exports.Repeat = 69, exports.For = 70, exports.Define = 71, exports.Return = 72, exports.ErrorInvalid = 73;
    }
  });

  // __tmp__/static/js/lezer-parsers/level15-parser.terms.js
  var require_level15_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level15-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Add = exports.Sleep = exports.Turtle = exports.Arguments = exports.Call = exports.Print = exports.Clear = exports.Ask = exports.Comma = exports.AssignList = exports.String = exports.Expression = exports.Number = exports.ListAccess = exports.Text = exports.Assign = exports.Command = exports.Program = exports.Comment = exports._with = exports.returns = exports.define = exports.call = exports.range = exports.to = exports.fors = exports.times = exports.repeat = exports.not_in = exports.ins = exports.clear = exports.toList = exports.remove = exports.from = exports.add = exports.sleep = exports.color = exports.turn = exports.forward = exports.print = exports._while = exports.is = exports.or = exports.and = exports.elses = exports.pressed = exports.ifs = exports.random = exports.at = exports.ask = void 0;
      exports.ErrorInvalid = exports.While = exports.Return = exports.Define = exports.For = exports.Repeat = exports.Else = exports.Condition = exports.If = exports.Remove = void 0;
      exports.ask = 1, exports.at = 2, exports.random = 3, exports.ifs = 4, exports.pressed = 5, exports.elses = 6, exports.and = 7, exports.or = 8, exports.is = 9, exports._while = 10, exports.print = 11, exports.forward = 12, exports.turn = 13, exports.color = 14, exports.sleep = 15, exports.add = 16, exports.from = 17, exports.remove = 18, exports.toList = 19, exports.clear = 20, exports.ins = 21, exports.not_in = 22, exports.repeat = 23, exports.times = 24, exports.fors = 25, exports.to = 26, exports.range = 27, exports.call = 28, exports.define = 29, exports.returns = 30, exports._with = 31, exports.Comment = 32, exports.Program = 33, exports.Command = 34, exports.Assign = 35, exports.Text = 36, exports.ListAccess = 37, exports.Number = 38, exports.Expression = 40, exports.String = 41, exports.AssignList = 44, exports.Comma = 45, exports.Ask = 46, exports.Clear = 47, exports.Print = 48, exports.Call = 49, exports.Arguments = 50, exports.Turtle = 51, exports.Sleep = 55, exports.Add = 56, exports.Remove = 57, exports.If = 58, exports.Condition = 59, exports.Else = 69, exports.Repeat = 70, exports.For = 71, exports.Define = 72, exports.Return = 73, exports.While = 74, exports.ErrorInvalid = 75;
    }
  });

  // __tmp__/static/js/lezer-parsers/level16-parser.terms.js
  var require_level16_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level16-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Remove = exports.Add = exports.Sleep = exports.Turtle = exports.Arguments = exports.Call = exports.Print = exports.Clear = exports.Ask = exports.Comma = exports.AssignList = exports.String = exports.Expression = exports.Number = exports.ListAccess = exports.Text = exports.Assign = exports.Command = exports.Program = exports.Comment = exports._with = exports.returns = exports.define = exports.call = exports.range = exports.to = exports.fors = exports.times = exports.repeat = exports.not_in = exports.ins = exports.clear = exports.toList = exports.remove = exports.from = exports.add = exports.sleep = exports.color = exports.turn = exports.forward = exports.print = exports._while = exports.is = exports.or = exports.and = exports.elses = exports.pressed = exports.ifs = exports.random = exports.ask = void 0;
      exports.ErrorInvalid = exports.While = exports.Return = exports.Define = exports.For = exports.Repeat = exports.Else = exports.Condition = exports.If = void 0;
      exports.ask = 1, exports.random = 2, exports.ifs = 3, exports.pressed = 4, exports.elses = 5, exports.and = 6, exports.or = 7, exports.is = 8, exports._while = 9, exports.print = 10, exports.forward = 11, exports.turn = 12, exports.color = 13, exports.sleep = 14, exports.add = 15, exports.from = 16, exports.remove = 17, exports.toList = 18, exports.clear = 19, exports.ins = 20, exports.not_in = 21, exports.repeat = 22, exports.times = 23, exports.fors = 24, exports.to = 25, exports.range = 26, exports.call = 27, exports.define = 28, exports.returns = 29, exports._with = 30, exports.Comment = 31, exports.Program = 32, exports.Command = 33, exports.Assign = 34, exports.Text = 35, exports.ListAccess = 36, exports.Number = 38, exports.Expression = 41, exports.String = 42, exports.AssignList = 45, exports.Comma = 46, exports.Ask = 47, exports.Clear = 48, exports.Print = 49, exports.Call = 50, exports.Arguments = 51, exports.Turtle = 52, exports.Sleep = 56, exports.Add = 57, exports.Remove = 58, exports.If = 59, exports.Condition = 60, exports.Else = 70, exports.Repeat = 71, exports.For = 72, exports.Define = 73, exports.Return = 74, exports.While = 75, exports.ErrorInvalid = 76;
    }
  });

  // __tmp__/static/js/lezer-parsers/level17-parser.terms.js
  var require_level17_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level17-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Add = exports.Sleep = exports.Turtle = exports.Arguments = exports.Call = exports.Print = exports.Clear = exports.Ask = exports.Comma = exports.AssignList = exports.String = exports.Expression = exports.Number = exports.ListAccess = exports.Text = exports.Assign = exports.Command = exports.Program = exports.Comment = exports._with = exports.returns = exports.define = exports.call = exports.range = exports.to = exports.fors = exports.times = exports.repeat = exports.not_in = exports.ins = exports.clear = exports.toList = exports.remove = exports.from = exports.add = exports.sleep = exports.color = exports.turn = exports.forward = exports.print = exports.elif = exports._while = exports.is = exports.or = exports.and = exports.elses = exports.pressed = exports.ifs = exports.random = exports.ask = void 0;
      exports.ErrorInvalid = exports.Elif = exports.While = exports.Return = exports.Define = exports.For = exports.Repeat = exports.Else = exports.Condition = exports.If = exports.Remove = void 0;
      exports.ask = 1, exports.random = 2, exports.ifs = 3, exports.pressed = 4, exports.elses = 5, exports.and = 6, exports.or = 7, exports.is = 8, exports._while = 9, exports.elif = 10, exports.print = 11, exports.forward = 12, exports.turn = 13, exports.color = 14, exports.sleep = 15, exports.add = 16, exports.from = 17, exports.remove = 18, exports.toList = 19, exports.clear = 20, exports.ins = 21, exports.not_in = 22, exports.repeat = 23, exports.times = 24, exports.fors = 25, exports.to = 26, exports.range = 27, exports.call = 28, exports.define = 29, exports.returns = 30, exports._with = 31, exports.Comment = 32, exports.Program = 33, exports.Command = 34, exports.Assign = 35, exports.Text = 36, exports.ListAccess = 37, exports.Number = 39, exports.Expression = 42, exports.String = 43, exports.AssignList = 46, exports.Comma = 47, exports.Ask = 48, exports.Clear = 49, exports.Print = 50, exports.Call = 51, exports.Arguments = 52, exports.Turtle = 53, exports.Sleep = 57, exports.Add = 58, exports.Remove = 59, exports.If = 60, exports.Condition = 61, exports.Else = 72, exports.Repeat = 73, exports.For = 74, exports.Define = 75, exports.Return = 76, exports.While = 77, exports.Elif = 78, exports.ErrorInvalid = 79;
    }
  });

  // __tmp__/static/js/lezer-parsers/level18-parser.terms.js
  var require_level18_parser_terms = __commonJS({
    "__tmp__/static/js/lezer-parsers/level18-parser.terms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Condition = exports.If = exports.Remove = exports.Add = exports.Sleep = exports.Turtle = exports.Print = exports.Clear = exports.Call = exports.Arguments = exports.Input = exports.Comma = exports.AssignList = exports.String = exports.Expression = exports.Number = exports.ListAccess = exports.Text = exports.Assign = exports.Command = exports.Program = exports.Comment = exports.elif = exports.toList = exports.fors = exports.returns = exports.def = exports.whiles = exports.range = exports.times = exports.repeat = exports.ins = exports.notIn = exports.pressed = exports.or = exports.and = exports.elses = exports.ifs = exports.clear = exports.from = exports.remove = exports.add = exports.color = exports.turn = exports.forward = exports.random = exports.sleep = exports.input = exports.is = exports.print = void 0;
      exports.ErrorInvalid = exports.Elif = exports.While = exports.Return = exports.Define = exports.For = exports.Repeat = exports.Else = void 0;
      exports.print = 1, exports.is = 2, exports.input = 3, exports.sleep = 4, exports.random = 5, exports.forward = 6, exports.turn = 7, exports.color = 8, exports.add = 9, exports.remove = 10, exports.from = 11, exports.clear = 12, exports.ifs = 13, exports.elses = 14, exports.and = 15, exports.or = 16, exports.pressed = 17, exports.notIn = 18, exports.ins = 19, exports.repeat = 20, exports.times = 21, exports.range = 22, exports.whiles = 23, exports.def = 24, exports.returns = 25, exports.fors = 26, exports.toList = 27, exports.elif = 28, exports.Comment = 29, exports.Program = 30, exports.Command = 31, exports.Assign = 32, exports.Text = 33, exports.ListAccess = 34, exports.Number = 36, exports.Expression = 39, exports.String = 40, exports.AssignList = 43, exports.Comma = 44, exports.Input = 45, exports.Arguments = 47, exports.Call = 48, exports.Clear = 50, exports.Print = 51, exports.Turtle = 52, exports.Sleep = 56, exports.Add = 57, exports.Remove = 58, exports.If = 59, exports.Condition = 60, exports.Else = 70, exports.Repeat = 71, exports.For = 72, exports.Define = 73, exports.Return = 74, exports.While = 75, exports.Elif = 76, exports.ErrorInvalid = 77;
    }
  });

  // __tmp__/static/js/lezer-parsers/tokens.js
  var require_tokens = __commonJS({
    "__tmp__/static/js/lezer-parsers/tokens.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.extendKeyword = exports.specializeKeyword = exports.initializeTranslation = void 0;
      var level1_parser_terms_1 = require_level1_parser_terms();
      var level2_parser_terms_1 = require_level2_parser_terms();
      var level3_parser_terms_1 = require_level3_parser_terms();
      var level4_parser_terms_1 = require_level4_parser_terms();
      var level5_parser_terms_1 = require_level5_parser_terms();
      var level6_parser_terms_1 = require_level6_parser_terms();
      var level7_parser_terms_1 = require_level7_parser_terms();
      var level8_parser_terms_1 = require_level8_parser_terms();
      var level10_parser_terms_1 = require_level10_parser_terms();
      var level11_parser_terms_1 = require_level11_parser_terms();
      var level12_parser_terms_1 = require_level12_parser_terms();
      var level13_parser_terms_1 = require_level13_parser_terms();
      var level14_parser_terms_1 = require_level14_parser_terms();
      var level15_parser_terms_1 = require_level15_parser_terms();
      var level16_parser_terms_1 = require_level16_parser_terms();
      var level17_parser_terms_1 = require_level17_parser_terms();
      var level18_parser_terms_1 = require_level18_parser_terms();
      var highlighting_trad_json_1 = __importDefault(require_highlighting_trad());
      var TRADUCTION;
      var level;
      var keywordToToken = {
        1: {
          extend: {
            "ask": level1_parser_terms_1.ask,
            "print": level1_parser_terms_1.print,
            "echo": level1_parser_terms_1.echo,
            "forward": level1_parser_terms_1.forward,
            "turn": level1_parser_terms_1.turn,
            "color": level1_parser_terms_1.color
          },
          specialize: {}
        },
        2: {
          extend: {
            "print": level2_parser_terms_1.print,
            "forward": level2_parser_terms_1.forward,
            "turn": level2_parser_terms_1.turn,
            "color": level2_parser_terms_1.color,
            "sleep": level2_parser_terms_1.sleep,
            "is": level2_parser_terms_1.is
          },
          specialize: {
            "ask": level2_parser_terms_1.ask
          }
        },
        3: {
          extend: {
            "print": level3_parser_terms_1.print,
            "forward": level3_parser_terms_1.forward,
            "turn": level3_parser_terms_1.turn,
            "color": level3_parser_terms_1.color,
            "sleep": level3_parser_terms_1.sleep,
            "is": level3_parser_terms_1.is,
            "add": level3_parser_terms_1.add,
            "remove": level3_parser_terms_1.remove,
            "from": level3_parser_terms_1.from,
            "to_list": level3_parser_terms_1.toList
          },
          specialize: {
            "ask": level3_parser_terms_1.ask,
            "at": level3_parser_terms_1.at,
            "random": level3_parser_terms_1.random
          }
        },
        4: {
          extend: {
            "print": level4_parser_terms_1.print,
            "forward": level4_parser_terms_1.forward,
            "turn": level4_parser_terms_1.turn,
            "color": level4_parser_terms_1.color,
            "sleep": level4_parser_terms_1.sleep,
            "is": level4_parser_terms_1.is,
            "add": level4_parser_terms_1.add,
            "remove": level4_parser_terms_1.remove,
            "from": level4_parser_terms_1.from,
            "to_list": level4_parser_terms_1.toList,
            "clear": level4_parser_terms_1.clear
          },
          specialize: {
            "ask": level4_parser_terms_1.ask,
            "at": level4_parser_terms_1.at,
            "random": level4_parser_terms_1.random
          }
        },
        5: {
          extend: {
            "print": level5_parser_terms_1.print,
            "forward": level5_parser_terms_1.forward,
            "turn": level5_parser_terms_1.turn,
            "color": level5_parser_terms_1.color,
            "sleep": level5_parser_terms_1.sleep,
            "is": level5_parser_terms_1.is,
            "add": level5_parser_terms_1.add,
            "remove": level5_parser_terms_1.remove,
            "from": level5_parser_terms_1.from,
            "to_list": level5_parser_terms_1.toList,
            "clear": level5_parser_terms_1.clear,
            "not_in": level5_parser_terms_1.not_in,
            "in": level5_parser_terms_1.ins
          },
          specialize: {
            "if": level5_parser_terms_1.ifs,
            "pressed": level5_parser_terms_1.pressed,
            "ask": level5_parser_terms_1.ask,
            "at": level5_parser_terms_1.at,
            "random": level5_parser_terms_1.random,
            "else": level5_parser_terms_1.elses
          }
        },
        6: {
          extend: {
            "print": level6_parser_terms_1.print,
            "forward": level6_parser_terms_1.forward,
            "turn": level6_parser_terms_1.turn,
            "color": level6_parser_terms_1.color,
            "sleep": level6_parser_terms_1.sleep,
            "is": level6_parser_terms_1.is,
            "add": level6_parser_terms_1.add,
            "remove": level6_parser_terms_1.remove,
            "from": level6_parser_terms_1.from,
            "to_list": level6_parser_terms_1.toList,
            "clear": level6_parser_terms_1.clear,
            "not_in": level6_parser_terms_1.not_in,
            "in": level6_parser_terms_1.ins
          },
          specialize: {
            "if": level6_parser_terms_1.ifs,
            "pressed": level6_parser_terms_1.pressed,
            "ask": level6_parser_terms_1.ask,
            "at": level6_parser_terms_1.at,
            "random": level6_parser_terms_1.random,
            "else": level6_parser_terms_1.elses
          }
        },
        7: {
          extend: {
            "print": level7_parser_terms_1.print,
            "forward": level7_parser_terms_1.forward,
            "turn": level7_parser_terms_1.turn,
            "color": level7_parser_terms_1.color,
            "sleep": level7_parser_terms_1.sleep,
            "is": level7_parser_terms_1.is,
            "add": level7_parser_terms_1.add,
            "remove": level7_parser_terms_1.remove,
            "from": level7_parser_terms_1.from,
            "to_list": level7_parser_terms_1.toList,
            "clear": level7_parser_terms_1.clear,
            "not_in": level7_parser_terms_1.not_in,
            "in": level7_parser_terms_1.ins,
            "repeat": level7_parser_terms_1.repeat,
            "times": level7_parser_terms_1.times
          },
          specialize: {
            "if": level7_parser_terms_1.ifs,
            "pressed": level7_parser_terms_1.pressed,
            "ask": level7_parser_terms_1.ask,
            "at": level7_parser_terms_1.at,
            "random": level7_parser_terms_1.random,
            "else": level7_parser_terms_1.elses
          }
        },
        8: {
          extend: {
            "print": level8_parser_terms_1.print,
            "forward": level8_parser_terms_1.forward,
            "turn": level8_parser_terms_1.turn,
            "color": level8_parser_terms_1.color,
            "sleep": level8_parser_terms_1.sleep,
            "is": level8_parser_terms_1.is,
            "add": level8_parser_terms_1.add,
            "remove": level8_parser_terms_1.remove,
            "from": level8_parser_terms_1.from,
            "to_list": level8_parser_terms_1.toList,
            "clear": level8_parser_terms_1.clear,
            "not_in": level8_parser_terms_1.not_in,
            "in": level8_parser_terms_1.ins,
            "repeat": level8_parser_terms_1.repeat,
            "times": level8_parser_terms_1.times
          },
          specialize: {
            "if": level8_parser_terms_1.ifs,
            "pressed": level8_parser_terms_1.pressed,
            "ask": level8_parser_terms_1.ask,
            "at": level8_parser_terms_1.at,
            "random": level8_parser_terms_1.random,
            "else": level8_parser_terms_1.elses
          }
        },
        9: {
          extend: {
            "print": level8_parser_terms_1.print,
            "forward": level8_parser_terms_1.forward,
            "turn": level8_parser_terms_1.turn,
            "color": level8_parser_terms_1.color,
            "sleep": level8_parser_terms_1.sleep,
            "is": level8_parser_terms_1.is,
            "add": level8_parser_terms_1.add,
            "remove": level8_parser_terms_1.remove,
            "from": level8_parser_terms_1.from,
            "to_list": level8_parser_terms_1.toList,
            "clear": level8_parser_terms_1.clear,
            "not_in": level8_parser_terms_1.not_in,
            "in": level8_parser_terms_1.ins,
            "repeat": level8_parser_terms_1.repeat,
            "times": level8_parser_terms_1.times
          },
          specialize: {
            "if": level8_parser_terms_1.ifs,
            "pressed": level8_parser_terms_1.pressed,
            "ask": level8_parser_terms_1.ask,
            "at": level8_parser_terms_1.at,
            "random": level8_parser_terms_1.random,
            "else": level8_parser_terms_1.elses
          }
        },
        10: {
          extend: {
            "print": level10_parser_terms_1.print,
            "forward": level10_parser_terms_1.forward,
            "turn": level10_parser_terms_1.turn,
            "color": level10_parser_terms_1.color,
            "sleep": level10_parser_terms_1.sleep,
            "is": level10_parser_terms_1.is,
            "add": level10_parser_terms_1.add,
            "remove": level10_parser_terms_1.remove,
            "from": level10_parser_terms_1.from,
            "to_list": level10_parser_terms_1.toList,
            "clear": level10_parser_terms_1.clear,
            "not_in": level10_parser_terms_1.not_in,
            "in": level10_parser_terms_1.ins,
            "repeat": level10_parser_terms_1.repeat,
            "times": level10_parser_terms_1.times,
            "for": level10_parser_terms_1.fors
          },
          specialize: {
            "if": level10_parser_terms_1.ifs,
            "pressed": level10_parser_terms_1.pressed,
            "ask": level10_parser_terms_1.ask,
            "at": level10_parser_terms_1.at,
            "random": level10_parser_terms_1.random,
            "else": level10_parser_terms_1.elses
          }
        },
        11: {
          extend: {
            "print": level11_parser_terms_1.print,
            "forward": level11_parser_terms_1.forward,
            "turn": level11_parser_terms_1.turn,
            "color": level11_parser_terms_1.color,
            "sleep": level11_parser_terms_1.sleep,
            "is": level11_parser_terms_1.is,
            "add": level11_parser_terms_1.add,
            "remove": level11_parser_terms_1.remove,
            "from": level11_parser_terms_1.from,
            "to_list": level11_parser_terms_1.toList,
            "clear": level11_parser_terms_1.clear,
            "not_in": level11_parser_terms_1.not_in,
            "in": level11_parser_terms_1.ins,
            "repeat": level11_parser_terms_1.repeat,
            "times": level11_parser_terms_1.times,
            "for": level11_parser_terms_1.fors,
            "to": level11_parser_terms_1.to,
            "range": level11_parser_terms_1.range
          },
          specialize: {
            "if": level11_parser_terms_1.ifs,
            "pressed": level11_parser_terms_1.pressed,
            "ask": level11_parser_terms_1.ask,
            "at": level11_parser_terms_1.at,
            "random": level11_parser_terms_1.random,
            "else": level11_parser_terms_1.elses
          }
        },
        12: {
          extend: {
            "print": level12_parser_terms_1.print,
            "forward": level12_parser_terms_1.forward,
            "turn": level12_parser_terms_1.turn,
            "color": level12_parser_terms_1.color,
            "sleep": level12_parser_terms_1.sleep,
            "is": level12_parser_terms_1.is,
            "add": level12_parser_terms_1.add,
            "remove": level12_parser_terms_1.remove,
            "from": level12_parser_terms_1.from,
            "to_list": level12_parser_terms_1.toList,
            "clear": level12_parser_terms_1.clear,
            "not_in": level12_parser_terms_1.not_in,
            "in": level12_parser_terms_1.ins,
            "repeat": level12_parser_terms_1.repeat,
            "times": level12_parser_terms_1.times,
            "for": level12_parser_terms_1.fors,
            "to": level12_parser_terms_1.to,
            "range": level12_parser_terms_1.range,
            "return": level12_parser_terms_1.returns,
            "call": level12_parser_terms_1.call,
            "define": level12_parser_terms_1.define,
            "with": level12_parser_terms_1._with
          },
          specialize: {
            "if": level12_parser_terms_1.ifs,
            "pressed": level12_parser_terms_1.pressed,
            "ask": level12_parser_terms_1.ask,
            "at": level12_parser_terms_1.at,
            "random": level12_parser_terms_1.random,
            "else": level12_parser_terms_1.elses
          }
        },
        13: {
          extend: {
            "print": level13_parser_terms_1.print,
            "forward": level13_parser_terms_1.forward,
            "turn": level13_parser_terms_1.turn,
            "color": level13_parser_terms_1.color,
            "sleep": level13_parser_terms_1.sleep,
            "is": level13_parser_terms_1.is,
            "add": level13_parser_terms_1.add,
            "remove": level13_parser_terms_1.remove,
            "from": level13_parser_terms_1.from,
            "to_list": level13_parser_terms_1.toList,
            "clear": level13_parser_terms_1.clear,
            "not_in": level13_parser_terms_1.not_in,
            "in": level13_parser_terms_1.ins,
            "repeat": level13_parser_terms_1.repeat,
            "times": level13_parser_terms_1.times,
            "for": level13_parser_terms_1.fors,
            "to": level13_parser_terms_1.to,
            "range": level13_parser_terms_1.range,
            "return": level13_parser_terms_1.returns,
            "call": level13_parser_terms_1.call,
            "define": level13_parser_terms_1.define,
            "with": level13_parser_terms_1._with
          },
          specialize: {
            "if": level13_parser_terms_1.ifs,
            "pressed": level13_parser_terms_1.pressed,
            "ask": level13_parser_terms_1.ask,
            "at": level13_parser_terms_1.at,
            "random": level13_parser_terms_1.random,
            "else": level13_parser_terms_1.elses,
            "and": level13_parser_terms_1.and,
            "or": level13_parser_terms_1.or
          }
        },
        14: {
          extend: {
            "print": level14_parser_terms_1.print,
            "forward": level14_parser_terms_1.forward,
            "turn": level14_parser_terms_1.turn,
            "color": level14_parser_terms_1.color,
            "sleep": level14_parser_terms_1.sleep,
            "add": level14_parser_terms_1.add,
            "remove": level14_parser_terms_1.remove,
            "from": level14_parser_terms_1.from,
            "to_list": level14_parser_terms_1.toList,
            "clear": level14_parser_terms_1.clear,
            "not_in": level14_parser_terms_1.not_in,
            "repeat": level14_parser_terms_1.repeat,
            "times": level14_parser_terms_1.times,
            "for": level14_parser_terms_1.fors,
            "to": level14_parser_terms_1.to,
            "range": level14_parser_terms_1.range,
            "return": level14_parser_terms_1.returns,
            "call": level14_parser_terms_1.call,
            "define": level14_parser_terms_1.define,
            "with": level14_parser_terms_1._with
          },
          specialize: {
            "if": level14_parser_terms_1.ifs,
            "pressed": level14_parser_terms_1.pressed,
            "ask": level14_parser_terms_1.ask,
            "at": level14_parser_terms_1.at,
            "random": level14_parser_terms_1.random,
            "else": level14_parser_terms_1.elses,
            "and": level14_parser_terms_1.and,
            "or": level14_parser_terms_1.or,
            "in": level14_parser_terms_1.ins,
            "is": level14_parser_terms_1.is
          }
        },
        15: {
          extend: {
            "print": level15_parser_terms_1.print,
            "forward": level15_parser_terms_1.forward,
            "turn": level15_parser_terms_1.turn,
            "color": level15_parser_terms_1.color,
            "sleep": level15_parser_terms_1.sleep,
            "is": level15_parser_terms_1.is,
            "add": level15_parser_terms_1.add,
            "remove": level15_parser_terms_1.remove,
            "from": level15_parser_terms_1.from,
            "to_list": level15_parser_terms_1.toList,
            "clear": level15_parser_terms_1.clear,
            "not_in": level15_parser_terms_1.not_in,
            "repeat": level15_parser_terms_1.repeat,
            "times": level15_parser_terms_1.times,
            "for": level15_parser_terms_1.fors,
            "to": level15_parser_terms_1.to,
            "range": level15_parser_terms_1.range,
            "return": level15_parser_terms_1.returns,
            "call": level15_parser_terms_1.call,
            "define": level15_parser_terms_1.define,
            "with": level15_parser_terms_1._with
          },
          specialize: {
            "if": level15_parser_terms_1.ifs,
            "pressed": level15_parser_terms_1.pressed,
            "ask": level15_parser_terms_1.ask,
            "at": level15_parser_terms_1.at,
            "random": level15_parser_terms_1.random,
            "else": level15_parser_terms_1.elses,
            "and": level15_parser_terms_1.and,
            "or": level15_parser_terms_1.or,
            "in": level15_parser_terms_1.ins,
            "is": level15_parser_terms_1.is,
            "while": level15_parser_terms_1._while
          }
        },
        16: {
          extend: {
            "print": level16_parser_terms_1.print,
            "forward": level16_parser_terms_1.forward,
            "turn": level16_parser_terms_1.turn,
            "color": level16_parser_terms_1.color,
            "sleep": level16_parser_terms_1.sleep,
            "is": level16_parser_terms_1.is,
            "add": level16_parser_terms_1.add,
            "remove": level16_parser_terms_1.remove,
            "from": level16_parser_terms_1.from,
            "to_list": level16_parser_terms_1.toList,
            "clear": level16_parser_terms_1.clear,
            "not_in": level16_parser_terms_1.not_in,
            "repeat": level16_parser_terms_1.repeat,
            "times": level16_parser_terms_1.times,
            "for": level16_parser_terms_1.fors,
            "to": level16_parser_terms_1.to,
            "range": level16_parser_terms_1.range,
            "return": level16_parser_terms_1.returns,
            "call": level16_parser_terms_1.call,
            "define": level16_parser_terms_1.define,
            "with": level16_parser_terms_1._with
          },
          specialize: {
            "if": level16_parser_terms_1.ifs,
            "pressed": level16_parser_terms_1.pressed,
            "ask": level16_parser_terms_1.ask,
            "random": level16_parser_terms_1.random,
            "else": level16_parser_terms_1.elses,
            "and": level16_parser_terms_1.and,
            "or": level16_parser_terms_1.or,
            "in": level16_parser_terms_1.ins,
            "is": level16_parser_terms_1.is,
            "while": level16_parser_terms_1._while
          }
        },
        17: {
          extend: {
            "print": level17_parser_terms_1.print,
            "forward": level17_parser_terms_1.forward,
            "turn": level17_parser_terms_1.turn,
            "color": level17_parser_terms_1.color,
            "sleep": level17_parser_terms_1.sleep,
            "is": level17_parser_terms_1.is,
            "add": level17_parser_terms_1.add,
            "remove": level17_parser_terms_1.remove,
            "from": level17_parser_terms_1.from,
            "to_list": level17_parser_terms_1.toList,
            "clear": level17_parser_terms_1.clear,
            "not_in": level17_parser_terms_1.not_in,
            "repeat": level17_parser_terms_1.repeat,
            "times": level17_parser_terms_1.times,
            "for": level17_parser_terms_1.fors,
            "to": level17_parser_terms_1.to,
            "range": level17_parser_terms_1.range,
            "return": level17_parser_terms_1.returns,
            "call": level17_parser_terms_1.call,
            "define": level17_parser_terms_1.define,
            "with": level17_parser_terms_1._with
          },
          specialize: {
            "if": level17_parser_terms_1.ifs,
            "pressed": level17_parser_terms_1.pressed,
            "ask": level17_parser_terms_1.ask,
            "random": level17_parser_terms_1.random,
            "else": level17_parser_terms_1.elses,
            "and": level17_parser_terms_1.and,
            "or": level17_parser_terms_1.or,
            "in": level17_parser_terms_1.ins,
            "is": level17_parser_terms_1.is,
            "while": level17_parser_terms_1._while,
            "elif": level17_parser_terms_1.elif
          }
        },
        18: {
          specialize: {
            "add": level18_parser_terms_1.add,
            "and": level18_parser_terms_1.and,
            "clear": level18_parser_terms_1.clear,
            "color": level18_parser_terms_1.color,
            "def": level18_parser_terms_1.def,
            "print": level18_parser_terms_1.print,
            "is": level18_parser_terms_1.is,
            "input": level18_parser_terms_1.input,
            "sleep": level18_parser_terms_1.sleep,
            "random": level18_parser_terms_1.random,
            "forward": level18_parser_terms_1.forward,
            "turn": level18_parser_terms_1.turn,
            "to_list": level18_parser_terms_1.toList,
            "remove": level18_parser_terms_1.remove,
            "from": level18_parser_terms_1.from,
            "if": level18_parser_terms_1.ifs,
            "else": level18_parser_terms_1.elses,
            "or": level18_parser_terms_1.or,
            "pressed": level18_parser_terms_1.pressed,
            "not_in": level18_parser_terms_1.notIn,
            "in": level18_parser_terms_1.ins,
            "repeat": level18_parser_terms_1.repeat,
            "times": level18_parser_terms_1.times,
            "range": level18_parser_terms_1.range,
            "while": level18_parser_terms_1.whiles,
            "return": level18_parser_terms_1.returns,
            "for": level18_parser_terms_1.fors,
            "elif": level18_parser_terms_1.elif
          },
          extend: {}
        }
      };
      var specializeTranslations;
      var extendTranslations;
      function initializeTranslation(options) {
        const TRADUCTIONS = convert(highlighting_trad_json_1.default);
        level = options.level;
        let lang = options.keywordLanguage;
        if (!TRADUCTIONS.has(lang)) {
          lang = "en";
        }
        TRADUCTION = TRADUCTIONS.get(lang);
        specializeTranslations = new Map();
        extendTranslations = new Map();
        for (const [key, value] of TRADUCTION) {
          if (key in keywordToToken[level].specialize) {
            specializeTranslations.set(key, value);
          } else if (key in keywordToToken[level].extend) {
            extendTranslations.set(key, value);
          }
        }
      }
      exports.initializeTranslation = initializeTranslation;
      function specializeKeyword(name, stack) {
        for (const [key, value] of specializeTranslations) {
          const regexString = value.replace(" ", "|");
          if (new RegExp(`^(${regexString})$`, "gu").test(name)) {
            if (stack.canShift(keywordToToken[level].specialize[key])) {
              return keywordToToken[level].specialize[key];
            }
          }
        }
        return -1;
      }
      exports.specializeKeyword = specializeKeyword;
      function extendKeyword(name, stack) {
        for (const [key, value] of extendTranslations) {
          const regexString = value.replace(" ", "|");
          if (new RegExp(`^(${regexString})$`, "gu").test(name)) {
            if (stack.canShift(keywordToToken[level].extend[key])) {
              return keywordToToken[level].extend[key];
            }
          }
        }
        return -1;
      }
      exports.extendKeyword = extendKeyword;
      function convert(o) {
        if (typeof o === "object") {
          let tmp = new Map(Object.entries(o));
          let ret = new Map();
          tmp.forEach((value, key) => {
            ret.set(key, convert(value));
          });
          return ret;
        } else {
          return o;
        }
      }
    }
  });

  // __tmp__/static/js/lezer-parsers/level1-parser.js
  var require_level1_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level1-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "%vQYQPOOOOQO'#Co'#CoQYQPOOOOQO'#Cq'#CqOtQPO'#CfOOQO'#Cr'#CrO|QPO'#CnOOQO'#Cs'#CsO!XQPO'#ChOOQO'#Ct'#CtO!aQPO'#CiOOQO'#Cu'#CuO!oQPO'#CkOOQO'#Cv'#CvO!wQPO'#ClOOQO'#Cw'#CwO#PQPO'#CmOOQO'#Cj'#CjOOQO'#Ce'#CeQoQPO'#CpQ#XQPOOOOQO-E6m-E6mOOQO-E6o-E6oO#pQPO,59QOOQO-E6p-E6pO#{QPO,59SOOQO-E6q-E6qO$WQPO,59TOOQO-E6r-E6rOOQO-E6s-E6sOOQO,59V,59VOOQO-E6t-E6tOOQO,59W,59WOOQO-E6u-E6uOOQO,59X,59XO$cQPO,59[OOQO-E6n-E6n",
        stateData: "%Q~OVOSnOS~OPROQZOR]OSXOTVOU_OZTOoPO~OPROZTO~OZTOlbXobX~OTVOZTO~OSXOZTOl]Xo]X~OQZOZnO~OR]OZpO~OU_OZrO~OPROQZOR]OSXOTVOU_OZTO~OZTOlYaoYa~OZTOl[ao[a~OZTOl]ao]a~OoPOPdaQdaRdaSdaTdaUdaZdalda~O",
        goto: "#ulPPPPPPPPPmrPrrrwwwr|!W!_!g!{#T#]#e#mVcOQdVbOQdVaOQdQQOSeQsRscSdOQRtdUSOQdRfSUUOQdQgSWhUgikQiWRkYUWOQdRjWUYOQdRlYU[OQdRm[U^OQdRo^U`OQdRq`",
        nodeNames: "\u26A0 print forward turn echo ask color Comment Program Command Print Text Ask Echo Turtle Forward Turn Color ErrorInvalid",
        maxTerm: 31,
        nodeProps: [
          ["group", 14, "turtle"]
        ],
        skippedNodes: [0, 7],
        repeatNodeCount: 9,
        tokenData: "#O~RXOYnYZ!]Zpnpq!bqsnst!gt;'Sn;'S;=`!V<%lOn~sUZ~OYnZpnqsnt;'Sn;'S;=`!V<%lOn~!YP;=`<%ln~!bOo~~!gOn~~!lSV~OY!gZ;'S!g;'S;=`!x<%lO!g~!{P;=`<%l!g",
        tokenizers: [0],
        topRules: { "Program": [0, 8] },
        dynamicPrecedences: { "18": -10 },
        specialized: [{ term: 11, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 0
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level2-parser.js
  var require_level2_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level2-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "&fQYQPOOOOQO'#Cq'#CqQYQPOOOqQPO'#CtO!PQPO'#CpOOQO'#Cv'#CvO![QPO'#CjOOQO'#Cw'#CwO!dQPO'#ClOOQO'#Cx'#CxO!lQPO'#CmOOQO'#Cy'#CyO!tQPO'#CnOOQO'#Ck'#CkOOQO'#Cz'#CzO!|QPO'#CoOOQO'#Cf'#CfQlQPO'#CrQ#[QPOOOOQO-E6o-E6oOOQO'#Cs'#CsO#pQPO,59ROOQO'#Ct'#CtOOQO-E6r-E6rO#{QPO,59UOOQO-E6t-E6tOOQO-E6u-E6uOOQO,59W,59WOOQO-E6v-E6vOOQO,59X,59XOOQO-E6w-E6wOOQO,59Y,59YO$WQPO,59ZOOQO-E6x-E6xO$cQPO,59^OOQO-E6p-E6pOOQO-E6q-E6qO$}QPO1G.mOOQO'#Cu'#CuO%YQPO1G.oO%bQPO7+$ZOOQO-E6s-E6s",
        stateData: "%m~OWOSqOS~OQTORVOSXOTZOU^O[ROrPO~OVdO[hXohXrhX~O[fOodXrdX~OQTO[fO~ORVO[kO~OSXO[mO~OTZO[oO~OU^O[fOocXrcX~OQTORVOSXOTZOU^O[RO~OPvOVdO[fO~O[fOo^ar^a~O[fOocarca~OrPOQfaRfaSfaTfaUfa[faofa~O[fOoZirZi~OPvO[fO~O[fOo]qr]q~O",
        goto: "$QoPPPPPPPPPPpuPuuuzzzuu!P!Z!b!h#Q#W#`#h#p#xVaOQbV`OQbV]OQbQQOScQrRraSbOQRsbQeRRteUSOQbYgShpuxQhUQp_QueRxwQweRywUUOQbRiUUWOQbRjWUYOQbRlYU[OQbRn[U_OQbRq_",
        nodeNames: "\u26A0 ask print forward turn color sleep is Comment Program Command Assign Text Ask Print Turtle Forward Turn Color Sleep ErrorInvalid",
        maxTerm: 34,
        nodeProps: [
          ["group", 15, "turtle"]
        ],
        skippedNodes: [0, 8],
        repeatNodeCount: 10,
        tokenData: "#O~RXOYnYZ!]Zpnpq!bqsnst!gt;'Sn;'S;=`!V<%lOn~sU[~OYnZpnqsnt;'Sn;'S;=`!V<%lOn~!YP;=`<%ln~!bOr~~!gOq~~!lSW~OY!gZ;'S!g;'S;=`!x<%lO!g~!{P;=`<%l!g",
        tokenizers: [0],
        topRules: { "Program": [0, 9] },
        dynamicPrecedences: { "20": -10 },
        specialized: [{ term: 12, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }, { term: 12, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 0
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level3-parser.js
  var require_level3_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level3-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "+WQYQPOOOOQO'#C|'#C|QYQPOOOwQPO'#DPO!VQPO'#C{OOQO'#DU'#DUO!bQPO'#CsOOQO'#DW'#DWO!jQPO'#CuOOQO'#DX'#DXO!rQPO'#CvOOQO'#DY'#DYO!zQPO'#CwOOQO'#Ct'#CtOOQO'#DZ'#DZO#SQPO'#CxOOQO'#D['#D[O#bQPO'#CyOOQO'#D^'#D^O#jQPO'#CzOOQO'#Cl'#ClQrQPO'#C}Q#rQPOOOOQO-E6z-E6zOOQO'#DO'#DOO$^QPO,59XOOQO'#DP'#DPOOQO-E6}-E6}O$iQPO'#DVOOQO-E7S-E7SOOQO'#DV'#DVO$wQPO,59_O%SQPO,59aOOQO-E7U-E7UOOQO,59a,59aO%_QPO,59bOOQO-E7V-E7VOOQO,59b,59bO%jQPO,59cOOQO-E7W-E7WOOQO,59c,59cO%uQPO,59dOOQO-E7X-E7XOOQO,59d,59dOOQO-E7Y-E7YO&QQPO,59eOOQO-E7[-E7[O&VQPO,59fO&[QPO,59iOOQO-E6{-E6{OOQO-E6|-E6|O&|QPO'#DPO'_QPO1G.sOOQO1G.s1G.sOOQO'#DT'#DTO'mQPO1G.xOOQO'#DQ'#DQO'uQPO,59ZOOQO-E7T-E7TOOQO'#D]'#D]O(QQPO1G/POOQO'#D_'#D_O(YQPO1G/QO'pQPO'#DSO(bQPO7+$bO(mQPO7+$dOOQO-E7R-E7ROOQO-E7O-E7OOOQO'#DR'#DRO(xQPO1G.uOOQO1G.u1G.uOOQO-E7Z-E7ZOOQO7+$k7+$kOOQO-E7]-E7]OOQO7+$l7+$lO)WQPO,59nOOQO-E7Q-E7QOOQO-E7P-E7P",
        stateData: ")f~O^OS!UOS~OSTOTVOUXOVZOW^OY`O[bObRO!VPO~OXhObsX!SsX!VsX~ObjO!SoX!VoX~OSTOblO~OTVObpO~OUXObsO~OVZObvO~OW^ObyO!SlX!VlX~OY`Ob}O~O[bOb!PO~OSTOTVOUXOVZOW^OY`O[bObRO~OP!WOXhOb!TO~OQ!YObyX!SyX!VyX~OblO!Sga!Vga~OQ!YO!Sia!Via~OQ!YO!Sja!Vja~OQ!YO!Ska!Vka~OQ!YO!Sla!Vla~O]!]O~OZ!_O~O!VPOSqaTqaUqaVqaWqaYqa[qabqa!Sqa~OQ!YObsXesX!SsX!VsX~ObjOe!aO!Sai!Vai~OP!WObjO~OQ!YOR!fOb!hO~O]!]Ob!jO~OZ!_Ob!lO~Oe!aO!Sdq!Vdq~ObjO!Sfq!Vfq~OR!fObci!Sci!Vci~ObjOeva!Sva!Vva~O",
        goto: "&P!SPPPPPPPPPPPPPPPP!T!YP!_!YP!Y!Y!Y!r!r!r!Y!Y!Y!Y!w#R#Y#`#t$P$V$]$c$k$q$y%R%Z%c%k%q%yVeOQfVdOQfSnUoQrWQuYQx[Q{_R!ViV]OQfQQOSgQ!QR!QeSfOQR!RfQiRR!SiUSOQfWkS!U!c!mQ!UiQ!c!XR!m!a[!Zlpsvy!TR!e!ZQ!g!ZR!o!gQ!b!UR!n!bQ!XiR!d!XUUOQfRmUQoUR![oUWOQfRqWUYOQfRtYU[OQfRw[U_OQfRz_UaOQfR|aQ!^}R!i!^UcOQfR!OcQ!`!PR!k!`",
        nodeNames: "\u26A0 ask at random print forward turn color sleep is add from remove toList Comment Program Command Assign Text ListAccess AssignList Comma Ask Print Turtle Forward Turn Color Sleep Add Remove ErrorInvalid",
        maxTerm: 53,
        nodeProps: [
          ["group", 24, "turtle"]
        ],
        skippedNodes: [0, 14],
        repeatNodeCount: 18,
        tokenData: "$P~RbOY!ZYZ#XZp!Zpq#^qs!Zst#ct|!Z|}#z}#Q!Z#RBn!ZBnBo#zBo&FV!Z&FV&FW#z&FW;'S!Z;'S;=`#R<%l?Hb!Z?Hb?Hc#z?HcO!Z~!`Zb~OY!ZZp!Zqs!Zt|!Z}#Q!Z#RBn!ZBo&FV!Z&FW;'S!Z;'S;=`#R<%l?Hb!Z?HcO!Z~#UP;=`<%l!Z~#^O!V~~#cO!U~~#hS^~OY#cZ;'S#c;'S;=`#t<%lO#c~#wP;=`<%l#c~$POe~",
        tokenizers: [0],
        topRules: { "Program": [0, 15] },
        dynamicPrecedences: { "31": -10 },
        specialized: [{ term: 18, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }, { term: 18, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 0
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level4-parser.js
  var require_level4_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level4-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "-[QYQPOOOOQO'#DP'#DPQYQPOOOzQPO'#DSO!YQPO'#DOOOQO'#D['#D[O!eQPO'#CuOOQO'#D]'#D]O!pQPO'#CvOOQO'#D^'#D^O#OQPO'#CxOOQO'#D_'#D_O#WQPO'#CyOOQO'#D`'#D`O#`QPO'#CzOOQO'#Cw'#CwOOQO'#Da'#DaO#hQPO'#C{OOQO'#Db'#DbO#vQPO'#C|OOQO'#Dd'#DdO$OQPO'#C}OOQO'#Cm'#CmQuQPO'#DQQ$WQPOOOOQO-E6}-E6}OOQO'#DR'#DRO$uQPO,59YOOQO'#DS'#DSOOQO-E7Q-E7QOOQO-E7Y-E7YO%QQPO'#DXO%fOSO'#DjO%nOQO'#DnOOQO'#Ct'#CtOOQO'#DX'#DXO%vQPO,59bOOQO-E7Z-E7ZO&XQPO,59dOOQO-E7[-E7[OOQO,59d,59dO&dQPO,59eOOQO-E7]-E7]OOQO,59e,59eO&oQPO,59fOOQO-E7^-E7^OOQO,59f,59fO&zQPO,59gOOQO-E7_-E7_OOQO,59g,59gOOQO-E7`-E7`O'VQPO,59hOOQO-E7b-E7bO'[QPO,59iO'aQPO,59lOOQO-E7O-E7OOOQO-E7P-E7PO(UQPO'#DSO(gQPO1G.tOOQO1G.t1G.tOOQO'#DW'#DWO(uQPO1G.yOOQO'#DT'#DTO)TQPO,59[OOOO'#DY'#DYO)`OSO,5:UOOQO,5:U,5:UOOOO'#DZ'#DZO)hOQO,5:YOOQO,5:Y,5:YOOQO-E7V-E7VOOQO'#Dc'#DcO)pQPO1G/SOOQO'#De'#DeO)xQPO1G/TO*QQPO'#DVO*VQPO7+$cOOQO-E7U-E7UO*bQPO7+$eOOQO-E7R-E7ROOQO'#DU'#DUO*sQPO1G.vOOQO1G.v1G.vOOOO-E7W-E7WOOQO1G/p1G/pOOOO-E7X-E7XOOQO1G/t1G/tOOQO-E7a-E7aOOQO7+$n7+$nOOQO-E7c-E7cOOQO7+$o7+$oO+XQPO,59qOOQO-E7T-E7TOOQO-E7S-E7S",
        stateData: "+g~O_OS![OS~OSVOTXOUZOV]OW`OYbO[dO^TOcRO!]PO~OXjOcvX!YvX!]vX~OclO!YrX!]rX~O^TO!YiX!]iX~OSVOcoO!_pO!cqO~OTXOcvO~OUZOcyO~OV]Oc|O~OW`Oc!PO!YoX!]oX~OYbOc!TO~O[dOc!VO~OSVOTXOUZOV]OW`OYbO[dO^TOcRO~OP!^OXjOc!ZO~OQ!`Oc{X!Y{X!]{X!_{X!c{X~O!`!bO!a!dO~O!d!eO!e!gO~OcoO!_pO!cqO!Yja!]ja~OQ!`O!Yla!]la~OQ!`O!Yma!]ma~OQ!`O!Yna!]na~OQ!`O!Yoa!]oa~O]!iO~OZ!kO~O!]POStaTtaUtaVtaWtaYta[ta^tacta!Yta~OQ!`OcvXfvX!YvX!]vX~OclOf!mO!Ybi!]bi~OP!^OcoO!_pO!cqO~OQ!`OR!rOc!tO~O!`!bO!a!vO~O!d!eO!e!xO~O]!iOc!zO~OZ!kOc!|O~OclO~Of!mO!Yeq!]eq~OcoO!_pO!cqO!Ygq!]gq~OR!rOcdi!Ydi!]di!_di!cdi~OclOfya!Yya!]ya~O",
        goto: "'S!cPPPPPPPPPPPPPPPPP!d!iP!n!iP!i#T!i!i!i#Z#Z#Z!i!i!i!i#`#j#q#w$X$d$j$p$v%Q%W%^%f%n%v&O&W&`&h&n&vPPPP&|PPP&|VgOQhVfOQhWsWt!_!pQxYQ{[Q!O^Q!RaR!]kXsWt!_!pV_OQhQQOSiQ!WR!WgShOQR!XhQkRR!YkUSOQhUmS![!}Q![kR!}!m[!aovy|!P!ZR!q!aQ!s!aR#P!sQ!n![R#O!nQ!_kR!o!_QtWS!ht!pR!p!_Q!cpR!u!cQ!fqR!w!fUUOQhRnUUWOQhRuWUYOQhRwYU[OQhRz[U^OQhR}^UaOQhR!QaUcOQhR!ScQ!j!TR!y!jUeOQhR!UeQ!l!VR!{!lXrWt!_!p",
        nodeNames: "\u26A0 ask at random print forward turn color sleep is add from remove toList clear Comment Program Command Assign Text ListAccess AssignList Comma Ask String Clear Print Turtle Forward Turn Color Sleep Add Remove ErrorInvalid",
        maxTerm: 67,
        nodeProps: [
          ["group", 27, "turtle"]
        ],
        skippedNodes: [0, 15],
        repeatNodeCount: 21,
        tokenData: "$g~ReOY!dYZ#eZp!dpq#jqr!drs#ost#ttw!dwx$]x|!d|}$b}#Q!d#RBn!dBnBo$bBo&FV!d&FV&FW$b&FW;'S!d;'S;=`#_<%l?Hb!d?Hb?Hc$b?HcO!d~!i[c~OY!dZp!dqr!dtw!dx|!d}#Q!d#RBn!dBo&FV!d&FW;'S!d;'S;=`#_<%l?Hb!d?HcO!d~#bP;=`<%l!d~#jO!]~~#oO![~~#tO!_~~#yS_~OY#tZ;'S#t;'S;=`$V<%lO#t~$YP;=`<%l#t~$bO!c~~$gOf~",
        tokenizers: [2, new lr_1.LocalTokenGroup("_~RQYZXwxX~^O!e~~", 14, 66), new lr_1.LocalTokenGroup("_~RQYZXrsX~^O!a~~", 14, 62)],
        topRules: { "Program": [0, 16] },
        dynamicPrecedences: { "34": -10 },
        specialized: [{ term: 19, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }, { term: 19, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 0
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level5-parser.js
  var require_level5_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level5-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "1^QYQPOOOOQO'#D]'#D]QYQPOOO!QQPO'#D`O!cQPO'#DZOOQO'#Dh'#DhO!qQPO'#CzOOQO'#Di'#DiO#PQPO'#C{OOQO'#Dj'#DjO#_QPO'#C}OOQO'#Dk'#DkO#gQPO'#DOOOQO'#Dl'#DlO#oQPO'#DPOOQO'#C|'#C|OOQO'#Dm'#DmO#wQPO'#DQOOQO'#Dn'#DnO$YQPO'#DROOQO'#Dp'#DpO$bQPO'#DSOOQO'#Dr'#DrO$jQPO'#DTOOQO'#Dv'#DvO%dQPO'#D[OOQO'#Cr'#CrQ{QPO'#D^Q%kQPOOOOQO-E7Z-E7ZOOQO'#D_'#D_O%rQPO,59_OOQO'#D`'#D`OOQO-E7^-E7^OOQO-E7f-E7fO%}QPO'#DeO&fOSO'#D{O&nOQO'#EPOOQO'#Cy'#CyOOQO'#De'#DeO&vQPO,59gOOQO-E7g-E7gO'[QPO,59iOOQO-E7h-E7hOOQO,59i,59iO'jQPO,59jOOQO-E7i-E7iOOQO,59j,59jO'xQPO,59kOOQO-E7j-E7jOOQO,59k,59kO(WQPO,59lOOQO-E7k-E7kOOQO,59l,59lOOQO-E7l-E7lO(fQPO,59mOOQO-E7n-E7nO(kQPO,59nOOQO-E7p-E7pO(pQPO'#DVOOQO'#DU'#DUO`QPO,59oO`QPO,59vOOQO'#DY'#DYOOQO-E7t-E7tOOQO,59v,59vO({QPO,59xOOQO-E7[-E7[OOQO-E7]-E7]O)vQPO'#D`O*[QPO1G.yOOQO1G.y1G.yOOQO'#Dd'#DdO*mQPO1G/OOOQO'#Da'#DaO*{QPO,59aOOOO'#Df'#DfO+WOSO,5:gOOQO,5:g,5:gOOOO'#Dg'#DgO+`OQO,5:kOOQO,5:k,5:kOOQO-E7c-E7cOOQO'#Do'#DoO+hQPO1G/XOOQO'#Dq'#DqO+pQPO1G/YO+xQPO,59qOOQO'#Dt'#DtO,ZQPO,59rOOQO'#Du'#DuO,cQPO,59sO`QPO1G/ZO,kQPO1G/ZOOQO1G/b1G/bO,vQPO'#DcO,{QPO7+$hOOQO-E7b-E7bO-ZQPO7+$jOOQO-E7_-E7_OOQO'#Db'#DbO-oQPO1G.{OOQO1G.{1G.{OOOO-E7d-E7dOOQO1G0R1G0ROOOO-E7e-E7eOOQO1G0V1G0VOOQO-E7m-E7mOOQO7+$s7+$sOOQO-E7o-E7oOOQO7+$t7+$tOOQO'#Ds'#DsO.WQPO1G/]OOQO1G/]1G/]OOQO-E7r-E7rOOQO1G/^1G/^OOQO-E7s-E7sOOQO1G/_1G/_O.{QPO7+$uOOQO7+$u7+$uO/WQPO,59}OOQO-E7a-E7aOOQO-E7`-E7`OOQO-E7q-E7qOOQO<<Ha<<Ha",
        stateData: "/i~OdOS!mOS~OSfOThOVVOWXOXZOY]OZ`O]bO_dOaTOhRO!nPO~O[nOh!SX!k!SX!n!SXT!SX~OhpO!k}X!n}XT}X~OaTO!knX!nnXTnX~OVVOhsO!ptO!tuO~OWXOhzO~OXZOh}O~OY]Oh!QO~OZ`Oh!TO!ktX!ntXTtX~O]bOh!XO~O_dOh!ZO~OSfOh!]O~OThOVVOWXOXZOY]OZ`O]bO_dOaTOhRO~O!nPO~P$rOSfO~P$rOP!jO[nOh!gO~OQ!lOh!XX!k!XX!n!XX!p!XX!t!XXT!XX~O!q!nO!r!pO~O!u!qO!v!sO~OhsO!ptO!tuO!koa!noaToa~OQ!lO!kqa!nqaTqa~OQ!lO!kra!nraTra~OQ!lO!ksa!nsaTsa~OQ!lO!kta!ntaTta~O`!uO~O^!wO~O[nOb!zOc!|O~O!nPOS!QaT!QaV!QaW!QaX!QaY!QaZ!Qa]!Qa_!Qaa!Qah!Qa!k!Qa~OQ!lOh!SXk!SX!k!SX!n!SXT!SX~OhpOk#RO!kgi!ngiTgi~OP!jOhsO!ptO!tuO~OQ!lOR#WOh#YO~O!q!nO!r#[O~O!u!qO!v#^O~O`!uOh#`O~O^!wOh#bO~OU#cO[nOh#eO!ptO!tuO~Ob!zOh#gO~Oc!|Oh#iO~OThO!kwi!nwi~OhpO~Ok#RO!kjq!njqTjq~OhsO!ptO!tuO!klq!nlqTlq~OR#WOhii!kii!nii!pii!tiiTii~OU#cOVyiWyiXyiYyiZyi]yi_yiayihyi!nyi~OThO!kwq!nwq~OhpOk!Va!k!Va!n!VaT!Va~O",
        goto: "*_!tPPPPPPPPPPPPPPPPPPPPPP!u!zP#V!zP!z#l!z!z!z#u#u#u!z!z!z$O$T$W$W$W$Z!z$g$r%U%]%g%{&W&^&d&j&t&z'Q'^'j'v(S(`(l(x)O)[)b)j)p)v)|PPPP*WPPP*WVkOQlUjOQlX!ai!_!`#OWwWx!k#UQ|YQ!P[Q!S^Q!VaR!ioWwWx!k#UR#e!y__OQil!_!`#OVjOQlR!_gR!^gQ!ciQ#P!_Q#Q!`R#j#OUjOQlQ#k#PR#p#jQQOWmQ!`!d#OQ!`iQ!dkR#O!_SlOQR!elQoRS!fo!yR!y!]^SOQil!_!`#OUqS!h#lQ!hoR#l#R[!msz}!Q!T!gR#V!mQ#X!mR#n#XQ#S!hR#m#SQ!koR#T!kQxWS!tx#UR#U!kQ!otR#Z!oQ!ruR#]!r^UOQil!_!`#ORrU^WOQil!_!`#ORyW^YOQil!_!`#OR{Y^[OQil!_!`#OR!O[^^OQil!_!`#OR!R^^aOQil!_!`#OR!Ua^cOQil!_!`#OR!WcQ!v!XR#_!v^eOQil!_!`#OR!YeQ!x!ZR#a!xUgOQlR![gQ#d!yR#o#dQ!{!]R#f!{Q!}!]R#h!}YiOQl#P#jR!biZvWx!k!y#U",
        nodeNames: "\u26A0 ask at random if else pressed print forward turn color sleep is add from remove toList clear in not_in Comment Program Command Assign Text ListAccess AssignList Comma Ask String Clear Print Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck IfLessCommand ErrorInvalid Else",
        maxTerm: 84,
        nodeProps: [
          ["group", 32, "turtle"]
        ],
        skippedNodes: [0, 20],
        repeatNodeCount: 26,
        tokenData: "$g~ReOY!dYZ#eZp!dpq#jqr!drs#ost#ttw!dwx$]x|!d|}$b}#Q!d#RBn!dBnBo$bBo&FV!d&FV&FW$b&FW;'S!d;'S;=`#_<%l?Hb!d?Hb?Hc$b?HcO!d~!i[h~OY!dZp!dqr!dtw!dx|!d}#Q!d#RBn!dBo&FV!d&FW;'S!d;'S;=`#_<%l?Hb!d?HcO!d~#bP;=`<%l!d~#jO!n~~#oO!m~~#tO!p~~#ySd~OY#tZ;'S#t;'S;=`$V<%lO#t~$YP;=`<%l#t~$bO!t~~$gOk~",
        tokenizers: [2, new lr_1.LocalTokenGroup("_~RQYZXwxX~^O!v~~", 14, 83), new lr_1.LocalTokenGroup("_~RQYZXrsX~^O!r~~", 14, 79)],
        topRules: { "Program": [0, 21] },
        dynamicPrecedences: { "45": -10 },
        specialized: [{ term: 24, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }, { term: 24, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 0
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level6-parser.js
  var require_level6_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level6-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "3UQYQPOOOOQO'#Db'#DbQYQPOOO!QQPO'#DhO!fQPO'#D`OOQO'#Dn'#DnO!tQPO'#DPO#SQPO'#DQOOQO'#Do'#DoO#bQPO'#DSOOQO'#Dp'#DpO#mQPO'#DTOOQO'#Dq'#DqO#xQPO'#DUOOQO'#DR'#DROOQO'#Dr'#DrO$TQPO'#DVOOQO'#Ds'#DsO$iQPO'#DWOOQO'#Du'#DuO$qQPO'#DXOOQO'#Dw'#DwO$yQPO'#DYOOQO'#D{'#D{O%sQPO'#DaOOQO'#Cr'#CrQ{QPO'#DcQ%zQPOOOOQO-E7`-E7`OOQO'#Dd'#DdO&RQPO,59_OOQO'#Cu'#CuO&aQPO,59_OOQO'#Dh'#DhOOQO-E7f-E7fOOQO-E7l-E7lO&lQPO'#DkOOQO'#Cv'#CvO(RQPO'#CvO(]OSO'#EWO(eOQO'#E[OOQO'#DO'#DOOOQO'#Dk'#DkO(mQPO,59lO)UQPO,59nOOQO-E7m-E7mOOQO,59n,59nO)mQPO,59oOOQO-E7n-E7nOOQO,59o,59oO*UQPO,59pOOQO-E7o-E7oOOQO,59p,59pO*mQPO,59qOOQO-E7p-E7pOOQO,59q,59qOOQO-E7q-E7qO+UQPO,59rOOQO-E7s-E7sO+ZQPO,59sOOQO-E7u-E7uO+`QPO'#D[OOQO'#DZ'#DZO`QPO,59tO`QPO,59{OOQO'#D_'#D_OOQO-E7y-E7yOOQO,59{,59{O+kQPO,59}OOQO-E7a-E7aOOQO-E7b-E7bO,fQPO'#DeO-TQPO1G/RO-[QPO'#CvOOQO'#De'#DeO-fQPO1G.yO-wQPO1G/ROOQO'#Dj'#DjO.PQPO1G/TOOQO'#Cx'#CxOOQO'#Cy'#CyO.bQPO,5:mO.bQPO,5:mOOQO'#Df'#DfO.jQPO,59fOOOO'#Dl'#DlO.xOSO,5:rOOQO,5:r,5:rOOOO'#Dm'#DmO/QOQO,5:vOOQO,5:v,5:vOOQO-E7i-E7iOOQO'#Dt'#DtO/YQPO1G/^OOQO'#Dv'#DvO/bQPO1G/_O/jQPO,59vOOQO'#Dy'#DyO0OQPO,59wOOQO'#Dz'#DzO0WQPO,59xO`QPO1G/`O0`QPO1G/`OOQO1G/g1G/gO0kQPO'#DiO0sQPO7+$mOOQO-E7c-E7cOOQO-E7h-E7hO1RQPO7+$oOOQO1G0X1G0XO1jQPO1G0XOOQO-E7d-E7dOOQO'#Dg'#DgO2wQPO1G/QOOQO1G/Q1G/QOOOO-E7j-E7jOOQO1G0^1G0^OOOO-E7k-E7kOOQO1G0b1G0bOOQO-E7r-E7rOOQO7+$x7+$xOOQO-E7t-E7tOOQO7+$y7+$yO4TQPO1G/bOOQO'#Dx'#DxO4eQPO1G/bOOQO1G/b1G/bOOQO-E7w-E7wOOQO1G/c1G/cOOQO-E7x-E7xOOQO1G/d1G/dO4lQPO7+$zOOQO7+$z7+$zO4wQPO,5:TOOQO,5:T,5:TOOQO-E7g-E7gOOQO-E7e-E7eOOQO-E7v-E7vOOQO<<Hf<<Hf",
        stateData: "5]~OdOS!rOS~OSeOTgOVVOWWOXYOY[OZ_O]aO_cOaTOhRO!sPO~O[mO!toOh![X!p![X!s![XT![X~OhqO!p!SX!s!SXT!SX~OaTO!psX!ssXTsX~OhvOkuO!{wO#PxO~OWWOhvOkuO~OXYOhvOkuO~OY[OhvOkuO~OZ_OhvOkuO!pyX!syXTyX~O]aOh!ZO~O_cOh!]O~OSeOh!_O~OTgOVVOWWOXYOY[OZ_O]aO_cOaTOhRO~O!sPO~P%ROSeO~P%ROP!oO[mOh!kOk!jO~OP!oOh!kOk!jO~O!v!qO!w!qO!x!rO!y!rOh!_Xk!_X!p!_X!s!_X!{!_X#P!_XT!_X~OQ!uOhjXkjX!pjX!sjX!vjX!wjX!xjX!yjXTjX~O!{jX#PjX~P'aO!|!wO!}!yO~O#Q!zO#R!|O~OhvOkuO!{wO#PxO!pta!staTta~O!v!qO!w!qO!x!rO!y!rO!pva!svaTva~O!v!qO!w!qO!x!rO!y!rO!pwa!swaTwa~O!v!qO!w!qO!x!rO!y!rO!pxa!sxaTxa~O!v!qO!w!qO!x!rO!y!rO!pya!syaTya~O`#OO~O^#QO~O[mOb#TOc#VO~O!sPOS!VaT!VaV!VaW!VaX!VaY!VaZ!Va]!Va_!Vaa!Vah!Va!p!Va~O!v!qO!w!qO!x!rO!y!rOh!XXk!XX!p!XX!s!XXT!XX~Op#[O~P'dOh![Xp![X~P'aOhvOkuO!pgi!sgiTgi~OhqOp#[O~OP!oOhvOkuO!{wO#PxO~OhuOkuO~OQ!uOR#dOh#fOk#fO~O!|!wO!}#hO~O#Q!zO#R#jO~O`#OOh#lO~O^#QOh#nO~OU#pO[mOhuOkuO!{wO#PxO~Ob#TOh#tO~Oc#VOh#vO~OTgO!p|i!s|i~OhqOk#zO~Op#[O!poq!soqToq~OhvOkuO!{wO#PxO!pqq!sqqTqq~O!v!qO!w!qO!x!rO!y!rOh!uik!ui!p!ui!s!ui!{!ui#P!uiV!uiW!uiX!uiY!uiZ!ui]!ui_!uia!uiT!ui~OR#dOhnikni!pni!sni!{ni#PniTni~OV!OiW!OiX!OiY!OiZ!Oi]!Oi_!Oia!Oih!Oi!s!Oi~O!v!qO!w!qO!x!rO!y!rO~P3cOU#pO~P3cOTgO!p|q!s|q~OhqOp!]a!p!]a!s!]aT!]a~Okh~",
        goto: ",P#PPPPPPPPPPPPPPPPPPPPPPP#Q#VP#b#eP$V$a$k#VP#V%S#V#V#V%]%]%]#V#V#V%f%k%n%n%n%q#V%}&Y&l&s&}'U']'c'x(P(W(b(h(n(z)W)d)p)|*Y*`*l*r*z+Q+W+^PPPPP+hPPPP+xPPP+xVjOQkUiOQkX!ch!a!b#XRpRWtV{!p#`Q|XQ!PZQ!S]Q!V`U!inp!mQ#a!sQ#b!tR#o#Sa!st|!P!S!V!i#b#oa!tt|!P!S!V!i#b#oWzV{!p#`Q!OXQ!RZQ!U]Q!X`V!lnp!mWzV{!p#`R#r#S_^OQhk!a!b#XViOQkR!afR!`fQ!ehQ#Y!aQ#Z!bR#w#XUiOQkQ#x#YR$O#wQQOWlQ!b!f#XQ!bhQ!fjR#X!aSkOQR!gkQnRS!hn#SR#S!_S!mnpR#^!mS!vv!kR#c!vQ#e!vR#|#e^SOQhk!a!b#XUrS!n#yS!nnpR#y#[S#]!j!nR#{#]S!pnpR#_!pQ{VS!}{#`R#`!pQ!xwR#g!xQ!{xR#i!{^UOQhk!a!b#XRsU^XOQhk!a!b#XR}X^ZOQhk!a!b#XR!QZ^]OQhk!a!b#XR!T]^`OQhk!a!b#XR!W`^bOQhk!a!b#XR!YbQ#P!ZR#k#P^dOQhk!a!b#XR![dQ#R!]R#m#RUfOQkR!^fQ#q#SR#}#qQ#U!_R#s#UQ#W!_R#u#WYhOQk#Y#wR!dhmuVXZ]`np{!m!p!s!t#S#`ZyV{!p#S#`",
        nodeNames: "\u26A0 ask at random if else pressed print forward turn color sleep is add from remove toList clear in not_in Comment Program Command Assign Text Op Expression Int Op Op ListAccess AssignList Comma Ask String Clear Print Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck IfLessCommand ErrorInvalid Else",
        maxTerm: 95,
        nodeProps: [
          ["group", 37, "turtle"]
        ],
        skippedNodes: [0, 20],
        repeatNodeCount: 26,
        tokenData: "*x~R!^OY$}YZ&UZp$}pq&Zqr$}rs&`st&etw$}wx&|xz$}z{'R{|'W|}']}!O'b!O!P$}!P!Q'g!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!_!`*s!`#Q$}#RBn$}BnBo']BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FV&FW']&FW;'S$};'S;=`&O<%l?Hb$}?Hb?Hc']?HcO$}~%S^h~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!_$}!`#Q$}#RBn$}Bo&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~&RP;=`<%l$}~&ZO!s~~&`O!r~~&eO!{~~&jSd~OY&eZ;'S&e;'S;=`&v<%lO&e~&yP;=`<%l&e~'RO#P~~'WO!v~~']O!x~~'bOp~~'gO!y~~'lO!w~~'s!Ok~h~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!`#Q$}#RBn$}BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~*xO!t~",
        tokenizers: [2, new lr_1.LocalTokenGroup("_~RQYZXwxX~^O#R~~", 14, 94), new lr_1.LocalTokenGroup("_~RQYZXrsX~^O!}~~", 14, 90)],
        topRules: { "Program": [0, 21] },
        dynamicPrecedences: { "50": -10 },
        specialized: [{ term: 24, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }, { term: 24, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 930
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level7-parser.js
  var require_level7_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level7-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "4WQYQPOOOOQO'#De'#DeQYQPOOO!TQPO'#DkO!iQPO'#DcOOQO'#Dq'#DqO!wQPO'#DRO#VQPO'#DSOOQO'#Dr'#DrO#eQPO'#DUOOQO'#Ds'#DsO#pQPO'#DVOOQO'#Dt'#DtO#{QPO'#DWOOQO'#DT'#DTOOQO'#Du'#DuO$WQPO'#DXOOQO'#Dv'#DvO$lQPO'#DYOOQO'#Dx'#DxO$tQPO'#DZOOQO'#Dz'#DzO$|QPO'#D[OOQO'#EO'#EOO%UQPO'#DbOOQO'#EQ'#EQO&UQPO'#DdOOQO'#Ct'#CtQ!OQPO'#DfQ&]QPOOOOQO-E7c-E7cOOQO'#Dg'#DgO&dQPO,59aOOQO'#Cw'#CwO&rQPO,59aOOQO'#Dk'#DkOOQO-E7i-E7iOOQO-E7o-E7oO&}QPO'#DnOOQO'#Cx'#CxO(dQPO'#CxO(nOSO'#E]O(vOQO'#EaOOQO'#DQ'#DQOOQO'#Dn'#DnO)OQPO,59nO)gQPO,59pOOQO-E7p-E7pOOQO,59p,59pO*OQPO,59qOOQO-E7q-E7qOOQO,59q,59qO*gQPO,59rOOQO-E7r-E7rOOQO,59r,59rO+OQPO,59sOOQO-E7s-E7sOOQO,59s,59sOOQO-E7t-E7tO+gQPO,59tOOQO-E7v-E7vO+lQPO,59uOOQO-E7x-E7xO+qQPO'#D^OOQO'#D]'#D]O`QPO,59vOOQO-E7|-E7|O+|QPO,59|O`QPO,5:OOOQO'#Da'#DaOOQO-E8O-E8OOOQO,5:O,5:OO,RQPO,5:QOOQO-E7d-E7dOOQO-E7e-E7eO-PQPO'#DhO-nQPO1G/TO-uQPO'#CxOOQO'#Dh'#DhO.PQPO1G.{O.bQPO1G/TOOQO'#Dm'#DmO.jQPO1G/VOOQO'#Cz'#CzOOQO'#C{'#C{O.{QPO,5:rO.{QPO,5:rOOQO'#Di'#DiO/TQPO,59hOOOO'#Do'#DoO/cOSO,5:wOOQO,5:w,5:wOOOO'#Dp'#DpO/kOQO,5:{OOQO,5:{,5:{OOQO-E7l-E7lOOQO'#Dw'#DwO/sQPO1G/`OOQO'#Dy'#DyO/{QPO1G/aO0TQPO,59xOOQO'#D|'#D|O0iQPO,59yOOQO'#D}'#D}O0qQPO,59zO`QPO1G/bO0yQPO1G/bOOQO'#EP'#EPO1UQPO1G/hOOQO1G/j1G/jO1fQPO'#DlO1nQPO7+$oOOQO-E7f-E7fOOQO-E7k-E7kO1|QPO7+$qOOQO1G0^1G0^O2eQPO1G0^OOQO-E7g-E7gOOQO'#Dj'#DjO3uQPO1G/SOOQO1G/S1G/SOOOO-E7m-E7mOOQO1G0c1G0cOOOO-E7n-E7nOOQO1G0g1G0gOOQO-E7u-E7uOOQO7+$z7+$zOOQO-E7w-E7wOOQO7+${7+${O5UQPO1G/dOOQO'#D{'#D{O5fQPO1G/dOOQO1G/d1G/dOOQO-E7z-E7zOOQO1G/e1G/eOOQO-E7{-E7{OOQO1G/f1G/fO5mQPO7+$|OOQO7+$|7+$|OOQO-E7}-E7}OOQO7+%S7+%SO5xQPO,5:WOOQO,5:W,5:WOOQO-E7j-E7jOOQO-E7h-E7hOOQO-E7y-E7yOOQO<<Hh<<Hh",
        stateData: "6^~OfOS!wOS~OSeOUiOVVOWWOXYOY[OZ_O]aO_cOaTOdgOjRO!xPO~O[oO!yqOj!_X!u!_X!x!_XU!_X~OjsO!u!VX!x!VXU!VX~OaTO!uuX!xuXUuX~OjxOmwO#QyO#UzO~OWWOjxOmwO~OXYOjxOmwO~OY[OjxOmwO~OZ_OjxOmwO!u{X!x{XU{X~O]aOj!]O~O_cOj!_O~OSeOj!aO~OdgOj!eOm!eO~OUiOVVOWWOXYOY[OZ_O]aO_cOaTOdgOjRO~O!xPO~P%aOSeO~P%aOP!sO[oOj!oOm!nO~OP!sOj!oOm!nO~O!{!uO!|!uO!}!vO#O!vOj!bXm!bX!u!bX!x!bX#Q!bX#U!bXU!bX~OQ!yOjlXmlX!ulX!xlX!{lX!|lX!}lX#OlXUlX~O#QlX#UlX~P'rO#R!{O#S!}O~O#V#OO#W#QO~OjxOmwO#QyO#UzO!uva!xvaUva~O!{!uO!|!uO!}!vO#O!vO!uxa!xxaUxa~O!{!uO!|!uO!}!vO#O!vO!uya!xyaUya~O!{!uO!|!uO!}!vO#O!vO!uza!xzaUza~O!{!uO!|!uO!}!vO#O!vO!u{a!x{aU{a~O`#SO~O^#UO~O[oOb#XOc#ZO~Oe#_O~O!xPOS!YaU!YaV!YaW!YaX!YaY!YaZ!Ya]!Ya_!Yaa!Yad!Yaj!Ya!u!Ya~O!{!uO!|!uO!}!vO#O!vOj![Xm![X!u![X!x![XU![X~Or#bO~P'uOj!_Xr!_X~P'rOjxOmwO!uii!xiiUii~OjsOr#bO~OP!sOjxOmwO#QyO#UzO~OjwOmwO~OQ!yOR#jOj#lOm#lO~O#R!{O#S#nO~O#V#OO#W#pO~O`#SOj#rO~O^#UOj#tO~OT#vO[oOjwOmwO#QyO#UzO~Ob#XOj#zO~Oc#ZOj#|O~OUiO!u!Oi!x!Oi~OSeOe#_O!u!Ui!x!Ui~P%aOjsOm$SO~Or#bO!uqq!xqqUqq~OjxOmwO#QyO#UzO!usq!xsqUsq~O!{!uO!|!uO!}!vO#O!vOj!zim!zi!u!zi!x!zi#Q!zi#U!ziV!ziW!ziX!ziY!ziZ!zi]!zi_!zia!zid!ziU!zi~OR#jOjpimpi!upi!xpi#Qpi#UpiUpi~OV!QiW!QiX!QiY!QiZ!Qi]!Qi_!Qia!Qid!Qij!Qi!x!Qi~O!{!uO!|!uO!}!vO#O!vO~P4aOT#vO~P4aOUiO!u!Oq!x!Oq~OjsOr!`a!u!`a!x!`aU!`a~Omj~",
        goto: ",z#UPPPPPPPPPPPPPPPPPPPPPPPP#V#_P#k#nP$`$j$t#_P#_%]#_#_#_%f%f%f#_#_#_%p%v%y%y%y%|#_#_&Y&f&x'P'Z'b'i'o(V(^(e(o(u({)Y)g)t*R*`*m*s+Q+W+a+g+m+s,Q,WPPPPP,cPPPP,sPPP,sUlOQmR$Q#`WkOQm#`X!gj!c!f#]RrRWvV}!t#fQ!OXQ!RZQ!U]Q!X`U!mpr!qQ#g!wQ#h!xR#u#Wa!wv!O!R!U!X!m#h#ua!xv!O!R!U!X!m#h#uW|V}!t#fQ!QXQ!TZQ!W]Q!Z`V!ppr!qW|V}!t#fR#x#Wa^OQjm!c!f#]#`XkOQm#`R!cfR!bfQ!ijQ#^!cQ#a!fR#}#]WkOQm#`Q$O#^R$W#}QQOWnQ!f!j#]Q!fjQ!jlR#]!cSmOQR!kmQpRS!lp#WR#W!aS!qprR#d!qS!zx!oR#i!zQ#k!zR$U#k`SOQjm!c!f#]#`UtS!r$RS!rprR$R#bS#c!n!rR$T#cS!tprR#e!tQ}VS#R}#fR#f!tQ!|yR#m!|Q#PzR#o#P`UOQjm!c!f#]#`RuU`XOQjm!c!f#]#`R!PX`ZOQjm!c!f#]#`R!SZ`]OQjm!c!f#]#`R!V]``OQjm!c!f#]#`R!Y``bOQjm!c!f#]#`R![bQ#T!]R#q#T`dOQjm!c!f#]#`R!^dQ#V!_R#s#VWfOQm#`R!`fQ#w#WR$V#wQ#Y!aR#y#YQ#[!aR#{#[`hOQjm!c!f#]#`R!dhQ#`!eR$P#`[jOQm#^#`#}R!hjmwVXZ]`pr}!q!t!w!x#W#fZ{V}!t#W#f",
        nodeNames: "\u26A0 ask at random if pressed else print forward turn color sleep is add from remove toList clear in not_in repeat times Comment Program Command Assign Text Op Expression Int Op Op ListAccess AssignList Comma Ask String Clear Print Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck IfLessCommand Repeat ErrorInvalid Else",
        maxTerm: 100,
        nodeProps: [
          ["group", 39, "turtle"]
        ],
        skippedNodes: [0, 22],
        repeatNodeCount: 28,
        tokenData: "*x~R!^OY$}YZ&UZp$}pq&Zqr$}rs&`st&etw$}wx&|xz$}z{'R{|'W|}']}!O'b!O!P$}!P!Q'g!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!_!`*s!`#Q$}#RBn$}BnBo']BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FV&FW']&FW;'S$};'S;=`&O<%l?Hb$}?Hb?Hc']?HcO$}~%S^j~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!_$}!`#Q$}#RBn$}Bo&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~&RP;=`<%l$}~&ZO!x~~&`O!w~~&eO#Q~~&jSf~OY&eZ;'S&e;'S;=`&v<%lO&e~&yP;=`<%l&e~'RO#U~~'WO!{~~']O!}~~'bOr~~'gO#O~~'lO!|~~'s!Om~j~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!`#Q$}#RBn$}BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~*xO!y~",
        tokenizers: [2, new lr_1.LocalTokenGroup("_~RQYZXwxX~^O#W~~", 14, 99), new lr_1.LocalTokenGroup("_~RQYZXrsX~^O#S~~", 14, 95)],
        topRules: { "Program": [0, 23] },
        dynamicPrecedences: { "53": -10 },
        specialized: [{ term: 26, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }, { term: 26, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 977
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level8-parser.js
  var require_level8_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level8-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "2xQYQPOOOOQO'#Dd'#DdQYQPOOO!TQPO'#DjO!fQPO'#DcOOQO'#Dp'#DpO!qQPO'#DRO!|QPO'#DSOOQO'#Dq'#DqO#[QPO'#DUOOQO'#Dr'#DrO#gQPO'#DVOOQO'#Ds'#DsO#rQPO'#DWOOQO'#DT'#DTOOQO'#Dt'#DtO#}QPO'#DXOOQO'#Du'#DuO$`QPO'#DYOOQO'#Dw'#DwO$hQPO'#DZOOQO'#Dy'#DyO$pQPO'#D[OOQO'#D}'#D}O$xQPO'#DaOOQO'#EO'#EOO%TQPO'#DbOOQO'#Ct'#CtQ!OQPO'#DeQ%`QPOOOOQO-E7b-E7bOOQO'#Df'#DfO&WQPO,59aOOQO'#Cw'#CwO&fQPO,59aOOQO'#Dj'#DjOOQO-E7h-E7hOOQO-E7n-E7nO&qQPO'#DmOOQO'#Cx'#CxO(QQPO'#CxO([OSO'#E[O(dOQO'#E`OOQO'#DQ'#DQOOQO'#Dm'#DmO(lQPO,59nO)QQPO,59pOOQO-E7o-E7oOOQO,59p,59pO)fQPO,59qOOQO-E7p-E7pOOQO,59q,59qO)zQPO,59rOOQO-E7q-E7qOOQO,59r,59rO*`QPO,59sOOQO-E7r-E7rOOQO,59s,59sOOQO-E7s-E7sO*tQPO,59tOOQO-E7u-E7uO*yQPO,59uOOQO-E7w-E7wO+OQPO'#D^OOQO'#D]'#D]OOQO,59v,59vOOQO-E7{-E7{OOQO-E7|-E7|O+ZQPO,59|O+`QPO,5:POOQO-E7c-E7cOOQO-E7d-E7dO,^QPO'#DgO,xQPO1G/TO-PQPO'#CxOOQO'#Dg'#DgO-ZQPO1G.{O-iQPO1G/TOOQO'#Dl'#DlO-qQPO1G/VOOQO'#Cz'#CzOOQO'#C{'#C{O.SQPO,5:qO.SQPO,5:qOOQO'#Dh'#DhO.[QPO,59hOOOO'#Dn'#DnO.jOSO,5:vOOQO,5:v,5:vOOOO'#Do'#DoO.rOQO,5:zOOQO,5:z,5:zOOQO-E7k-E7kOOQO'#Dv'#DvO.zQPO1G/`OOQO'#Dx'#DxO/SQPO1G/aO/[QPO,59xOOQO'#D{'#D{O/pQPO,59yOOQO'#D|'#D|O/xQPO,59zOOQO'#EP'#EPO0QQPO1G/hO0]QPO'#DkO0eQPO7+$oOOQO-E7e-E7eOOQO-E7j-E7jO0pQPO7+$qOOQO1G0]1G0]O1UQPO1G0]OOQO-E7f-E7fOOQO'#Di'#DiO1vQPO1G/SOOQO1G/S1G/SOOOO-E7l-E7lOOQO1G0b1G0bOOOO-E7m-E7mOOQO1G0f1G0fOOQO-E7t-E7tOOQO7+$z7+$zOOQO-E7v-E7vOOQO7+${7+${O2_QPO1G/dOOQO'#Dz'#DzO2sQPO1G/dOOQO1G/d1G/dOOQO-E7y-E7yOOQO1G/e1G/eOOQO-E7z-E7zOOQO1G/f1G/fOOQO-E7}-E7}O3OQPO,5:VOOQO,5:V,5:VOOQO-E7i-E7iOOQO-E7g-E7gOOQO-E7x-E7x",
        stateData: "3a~OfOS!vOS~OSeOUgOVVOWWOXYOY[OZ_O]aO_cOaTOdiOjRO!wPO~O[oO!xqOj!^X!t!^X!w!^X~OjsO!t!VX!w!VX~OaTO!tuX!wuX~OjxOmwO#PyO#TzO~OWWOjxOmwO~OXYOjxOmwO~OY[OjxOmwO~OZ_OjxOmwO!t{X!w{X~O]aOj!]O~O_cOj!_O~OSeOj!aO~OUgO!t!TX!w!TX~OdiOj!fOm!fO~OSeOUgOVVOWWOXYOY[OZ_O]aO_cOaTOdiOjRO~OP!pO[oOj!lOm!kO~OP!pOj!lOm!kO~O!z!rO!{!rO!|!sO!}!sOj!aXm!aX!t!aX!w!aX#P!aX#T!aX~OQ!vOjlXmlX!tlX!wlX!zlX!{lX!|lX!}lX~O#PlX#TlX~P'cO#Q!xO#R!zO~O#U!{O#V!}O~OjxOmwO#PyO#TzO!tva!wva~O!z!rO!{!rO!|!sO!}!sO!txa!wxa~O!z!rO!{!rO!|!sO!}!sO!tya!wya~O!z!rO!{!rO!|!sO!}!sO!tza!wza~O!z!rO!{!rO!|!sO!}!sO!t{a!w{a~O`#PO~O^#RO~O[oOb#UOc#WO~Oe#YO~O!wPOS!XaU!XaV!XaW!XaX!XaY!XaZ!Xa]!Xa_!Xaa!Xad!Xaj!Xa!t!Xa~O!z!rO!{!rO!|!sO!}!sOj!ZXm!ZX!t!ZX!w!ZX~Or#[O~P'fOj!^Xr!^X~P'cOjxOmwO!tii!wii~OjsOr#[O~OP!pOjxOmwO#PyO#TzO~OjwOmwO~OQ!vOR#dOj#fOm#fO~O#Q!xO#R#hO~O#U!{O#V#jO~O`#POj#lO~O^#ROj#nO~OT#pO[oOjwOmwO#PyO#TzO~Ob#UOj#tO~Oc#WOj#vO~Oe#YO!t!Ui!w!Ui~OjsOm#yO~Or#[O!tqq!wqq~OjxOmwO#PyO#TzO!tsq!wsq~O!z!rO!{!rO!|!sO!}!sOj!yim!yi!t!yi!w!yi#P!yi#T!yi~OR#dOjpimpi!tpi!wpi#Ppi#Tpi~O!z!rO!{!rO!|!sO!}!sO!t!Qi!w!Qi~OT#pO!t!Qi!w!Qi~OjsOr!_a!t!_a!w!_a~Omj~",
        goto: "*o#TPPPPPPPPPPPPPPPPPPPPPPPP#U#ZP#`#cP$T$_$i#ZP#Z%Q#Z#Z#Z%Z%Z%Z#Z#Z#Z#Z%`%c%c%c#Z#Z#Z%f%p%w&R&Y&a&g&x'P'W'b'h'n'v(O(W(`(h(p(v)O)U)^)d)j)p)x*QPPPPP*WPPPP*hPPP*hVlOQmVkOQmRrRWvV}!q#`Q!OXQ!RZQ!U]Q!X`U!jpr!nQ#a!tQ#b!uR#o#Ta!tv!O!R!U!X!j#b#oa!uv!O!R!U!X!j#b#oW|V}!q#`Q!QXQ!TZQ!W]Q!Z`V!mpr!nW|V}!q#`R#r#TV^OQmR!cfR!bfQQOSnQ!gR!glSmOQR!hmQpRS!ip#TR#T!aS!nprR#^!nS!wx!lR#c!wQ#e!wR#{#eUSOQmUtS!o#xS!oprR#x#[S#]!k!oR#z#]S!qprR#_!qQ}VS#O}#`R#`!qQ!yyR#g!yQ!|zR#i!|UUOQmRuUUXOQmR!PXUZOQmR!SZU]OQmR!V]U`OQmR!Y`UbOQmR![bQ#Q!]R#k#QUdOQmR!^dQ#S!_R#m#SUfOQmR!`fQ#q#TR#|#qQ#V!aR#s#VQ#X!aR#u#XUhOQmR!dhUjOQmR!ejQ#Z!fR#w#ZmwVXZ]`pr}!n!q!t!u#T#`Z{V}!q#T#`",
        nodeNames: "\u26A0 ask at random if pressed else print forward turn color sleep is add from remove toList clear in not_in repeat times Comment Program Command Assign Text Op Expression Int Op Op ListAccess AssignList Comma Ask String Clear Print Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck Else Repeat ErrorInvalid",
        maxTerm: 99,
        nodeProps: [
          ["group", 39, "turtle"]
        ],
        skippedNodes: [0, 22],
        repeatNodeCount: 28,
        tokenData: "*x~R!^OY$}YZ&UZp$}pq&Zqr$}rs&`st&etw$}wx&|xz$}z{'R{|'W|}']}!O'b!O!P$}!P!Q'g!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!_!`*s!`#Q$}#RBn$}BnBo']BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FV&FW']&FW;'S$};'S;=`&O<%l?Hb$}?Hb?Hc']?HcO$}~%S^j~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!_$}!`#Q$}#RBn$}Bo&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~&RP;=`<%l$}~&ZO!w~~&`O!v~~&eO#P~~&jSf~OY&eZ;'S&e;'S;=`&v<%lO&e~&yP;=`<%l&e~'RO#T~~'WO!z~~']O!|~~'bOr~~'gO!}~~'lO!{~~'s!Om~j~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!`#Q$}#RBn$}BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~*xO!x~",
        tokenizers: [2, new lr_1.LocalTokenGroup("_~RQYZXwxX~^O#V~~", 14, 98), new lr_1.LocalTokenGroup("_~RQYZXrsX~^O#R~~", 14, 94)],
        topRules: { "Program": [0, 23] },
        dynamicPrecedences: { "53": -10 },
        specialized: [{ term: 26, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }, { term: 26, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 842
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level9-parser.js
  var require_level9_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level9-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "2xQYQPOOOOQO'#Dd'#DdQYQPOOO!TQPO'#DjO!fQPO'#DcOOQO'#Dp'#DpO!qQPO'#DRO!|QPO'#DSOOQO'#Dq'#DqO#[QPO'#DUOOQO'#Dr'#DrO#gQPO'#DVOOQO'#Ds'#DsO#rQPO'#DWOOQO'#DT'#DTOOQO'#Dt'#DtO#}QPO'#DXOOQO'#Du'#DuO$`QPO'#DYOOQO'#Dw'#DwO$hQPO'#DZOOQO'#Dy'#DyO$pQPO'#D[OOQO'#D}'#D}O$xQPO'#DaOOQO'#EO'#EOO%TQPO'#DbOOQO'#Ct'#CtQ!OQPO'#DeQ%`QPOOOOQO-E7b-E7bOOQO'#Df'#DfO&WQPO,59aOOQO'#Cw'#CwO&fQPO,59aOOQO'#Dj'#DjOOQO-E7h-E7hOOQO-E7n-E7nO&qQPO'#DmOOQO'#Cx'#CxO(QQPO'#CxO([OSO'#E[O(dOQO'#E`OOQO'#DQ'#DQOOQO'#Dm'#DmO(lQPO,59nO)QQPO,59pOOQO-E7o-E7oOOQO,59p,59pO)fQPO,59qOOQO-E7p-E7pOOQO,59q,59qO)zQPO,59rOOQO-E7q-E7qOOQO,59r,59rO*`QPO,59sOOQO-E7r-E7rOOQO,59s,59sOOQO-E7s-E7sO*tQPO,59tOOQO-E7u-E7uO*yQPO,59uOOQO-E7w-E7wO+OQPO'#D^OOQO'#D]'#D]OOQO,59v,59vOOQO-E7{-E7{OOQO-E7|-E7|O+ZQPO,59|O+`QPO,5:POOQO-E7c-E7cOOQO-E7d-E7dO,^QPO'#DgO,xQPO1G/TO-PQPO'#CxOOQO'#Dg'#DgO-ZQPO1G.{O-iQPO1G/TOOQO'#Dl'#DlO-qQPO1G/VOOQO'#Cz'#CzOOQO'#C{'#C{O.SQPO,5:qO.SQPO,5:qOOQO'#Dh'#DhO.[QPO,59hOOOO'#Dn'#DnO.jOSO,5:vOOQO,5:v,5:vOOOO'#Do'#DoO.rOQO,5:zOOQO,5:z,5:zOOQO-E7k-E7kOOQO'#Dv'#DvO.zQPO1G/`OOQO'#Dx'#DxO/SQPO1G/aO/[QPO,59xOOQO'#D{'#D{O/pQPO,59yOOQO'#D|'#D|O/xQPO,59zOOQO'#EP'#EPO0QQPO1G/hO0]QPO'#DkO0eQPO7+$oOOQO-E7e-E7eOOQO-E7j-E7jO0pQPO7+$qOOQO1G0]1G0]O1UQPO1G0]OOQO-E7f-E7fOOQO'#Di'#DiO1vQPO1G/SOOQO1G/S1G/SOOOO-E7l-E7lOOQO1G0b1G0bOOOO-E7m-E7mOOQO1G0f1G0fOOQO-E7t-E7tOOQO7+$z7+$zOOQO-E7v-E7vOOQO7+${7+${O2_QPO1G/dOOQO'#Dz'#DzO2sQPO1G/dOOQO1G/d1G/dOOQO-E7y-E7yOOQO1G/e1G/eOOQO-E7z-E7zOOQO1G/f1G/fOOQO-E7}-E7}O3OQPO,5:VOOQO,5:V,5:VOOQO-E7i-E7iOOQO-E7g-E7gOOQO-E7x-E7x",
        stateData: "3a~OfOS!vOS~OSeOUgOVVOWWOXYOY[OZ_O]aO_cOaTOdiOjRO!wPO~O[oO!xqOj!^X!t!^X!w!^X~OjsO!t!VX!w!VX~OaTO!tuX!wuX~OjxOmwO#PyO#TzO~OWWOjxOmwO~OXYOjxOmwO~OY[OjxOmwO~OZ_OjxOmwO!t{X!w{X~O]aOj!]O~O_cOj!_O~OSeOj!aO~OUgO!t!TX!w!TX~OdiOj!fOm!fO~OSeOUgOVVOWWOXYOY[OZ_O]aO_cOaTOdiOjRO~OP!pO[oOj!lOm!kO~OP!pOj!lOm!kO~O!z!rO!{!rO!|!sO!}!sOj!aXm!aX!t!aX!w!aX#P!aX#T!aX~OQ!vOjlXmlX!tlX!wlX!zlX!{lX!|lX!}lX~O#PlX#TlX~P'cO#Q!xO#R!zO~O#U!{O#V!}O~OjxOmwO#PyO#TzO!tva!wva~O!z!rO!{!rO!|!sO!}!sO!txa!wxa~O!z!rO!{!rO!|!sO!}!sO!tya!wya~O!z!rO!{!rO!|!sO!}!sO!tza!wza~O!z!rO!{!rO!|!sO!}!sO!t{a!w{a~O`#PO~O^#RO~O[oOb#UOc#WO~Oe#YO~O!wPOS!XaU!XaV!XaW!XaX!XaY!XaZ!Xa]!Xa_!Xaa!Xad!Xaj!Xa!t!Xa~O!z!rO!{!rO!|!sO!}!sOj!ZXm!ZX!t!ZX!w!ZX~Or#[O~P'fOj!^Xr!^X~P'cOjxOmwO!tii!wii~OjsOr#[O~OP!pOjxOmwO#PyO#TzO~OjwOmwO~OQ!vOR#dOj#fOm#fO~O#Q!xO#R#hO~O#U!{O#V#jO~O`#POj#lO~O^#ROj#nO~OT#pO[oOjwOmwO#PyO#TzO~Ob#UOj#tO~Oc#WOj#vO~Oe#YO!t!Ui!w!Ui~OjsOm#yO~Or#[O!tqq!wqq~OjxOmwO#PyO#TzO!tsq!wsq~O!z!rO!{!rO!|!sO!}!sOj!yim!yi!t!yi!w!yi#P!yi#T!yi~OR#dOjpimpi!tpi!wpi#Ppi#Tpi~O!z!rO!{!rO!|!sO!}!sO!t!Qi!w!Qi~OT#pO!t!Qi!w!Qi~OjsOr!_a!t!_a!w!_a~Omj~",
        goto: "*o#TPPPPPPPPPPPPPPPPPPPPPPPP#U#ZP#`#cP$T$_$i#ZP#Z%Q#Z#Z#Z%Z%Z%Z#Z#Z#Z#Z%`%c%c%c#Z#Z#Z%f%p%w&R&Y&a&g&x'P'W'b'h'n'v(O(W(`(h(p(v)O)U)^)d)j)p)x*QPPPPP*WPPPP*hPPP*hVlOQmVkOQmRrRWvV}!q#`Q!OXQ!RZQ!U]Q!X`U!jpr!nQ#a!tQ#b!uR#o#Ta!tv!O!R!U!X!j#b#oa!uv!O!R!U!X!j#b#oW|V}!q#`Q!QXQ!TZQ!W]Q!Z`V!mpr!nW|V}!q#`R#r#TV^OQmR!cfR!bfQQOSnQ!gR!glSmOQR!hmQpRS!ip#TR#T!aS!nprR#^!nS!wx!lR#c!wQ#e!wR#{#eUSOQmUtS!o#xS!oprR#x#[S#]!k!oR#z#]S!qprR#_!qQ}VS#O}#`R#`!qQ!yyR#g!yQ!|zR#i!|UUOQmRuUUXOQmR!PXUZOQmR!SZU]OQmR!V]U`OQmR!Y`UbOQmR![bQ#Q!]R#k#QUdOQmR!^dQ#S!_R#m#SUfOQmR!`fQ#q#TR#|#qQ#V!aR#s#VQ#X!aR#u#XUhOQmR!dhUjOQmR!ejQ#Z!fR#w#ZmwVXZ]`pr}!n!q!t!u#T#`Z{V}!q#T#`",
        nodeNames: "\u26A0 ask at random if pressed else print forward turn color sleep is add from remove toList clear in not_in repeat times Comment Program Command Assign Text Op Expression Int Op Op ListAccess AssignList Comma Ask String Clear Print Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck Else Repeat ErrorInvalid",
        maxTerm: 99,
        nodeProps: [
          ["group", 39, "turtle"]
        ],
        skippedNodes: [0, 22],
        repeatNodeCount: 28,
        tokenData: "*x~R!^OY$}YZ&UZp$}pq&Zqr$}rs&`st&etw$}wx&|xz$}z{'R{|'W|}']}!O'b!O!P$}!P!Q'g!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!_!`*s!`#Q$}#RBn$}BnBo']BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FV&FW']&FW;'S$};'S;=`&O<%l?Hb$}?Hb?Hc']?HcO$}~%S^j~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!_$}!`#Q$}#RBn$}Bo&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~&RP;=`<%l$}~&ZO!w~~&`O!v~~&eO#P~~&jSf~OY&eZ;'S&e;'S;=`&v<%lO&e~&yP;=`<%l&e~'RO#T~~'WO!z~~']O!|~~'bOr~~'gO!}~~'lO!{~~'s!Om~j~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!`#Q$}#RBn$}BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~*xO!x~",
        tokenizers: [2, new lr_1.LocalTokenGroup("_~RQYZXwxX~^O#V~~", 14, 98), new lr_1.LocalTokenGroup("_~RQYZXrsX~^O#R~~", 14, 94)],
        topRules: { "Program": [0, 23] },
        dynamicPrecedences: { "53": -10 },
        specialized: [{ term: 26, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }, { term: 26, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 842
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level10-parser.js
  var require_level10_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level10-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "3nQYQPOOOOQO'#Df'#DfQYQPOOO!WQPO'#DlO!iQPO'#DeOOQO'#Dr'#DrO!tQPO'#DSO#PQPO'#DTOOQO'#Ds'#DsO#_QPO'#DVOOQO'#Dt'#DtO#jQPO'#DWOOQO'#Du'#DuO#uQPO'#DXOOQO'#DU'#DUOOQO'#Dv'#DvO$QQPO'#DYOOQO'#Dw'#DwO$cQPO'#DZOOQO'#Dy'#DyO$kQPO'#D[OOQO'#D{'#D{O$sQPO'#D]OOQO'#EP'#EPO${QPO'#DbOOQO'#EQ'#EQO%WQPO'#DcOOQO'#ES'#ESO%cQPO'#DdOOQO'#Cu'#CuQ!RQPO'#DgQ%kQPOOOOQO-E7d-E7dOOQO'#Dh'#DhO&fQPO,59bOOQO'#Cx'#CxO&tQPO,59bOOQO'#Dl'#DlOOQO-E7j-E7jOOQO-E7p-E7pO'PQPO'#DoOOQO'#Cy'#CyO(`QPO'#CyO(jOSO'#E_O(rOQO'#EcOOQO'#DR'#DROOQO'#Do'#DoO(zQPO,59oO)`QPO,59qOOQO-E7q-E7qOOQO,59q,59qO)tQPO,59rOOQO-E7r-E7rOOQO,59r,59rO*YQPO,59sOOQO-E7s-E7sOOQO,59s,59sO*nQPO,59tOOQO-E7t-E7tOOQO,59t,59tOOQO-E7u-E7uO+SQPO,59uOOQO-E7w-E7wO+XQPO,59vOOQO-E7y-E7yO+^QPO'#D_OOQO'#D^'#D^OOQO,59w,59wOOQO-E7}-E7}OOQO-E8O-E8OO+iQPO,59}OOQO-E8Q-E8QO+nQPO,5:OO+sQPO,5:ROOQO-E7e-E7eOOQO-E7f-E7fO,tQPO'#DiO-`QPO1G/UO-gQPO'#CyOOQO'#Di'#DiO-qQPO1G.|O.PQPO1G/UOOQO'#Dn'#DnO.XQPO1G/WOOQO'#C{'#C{OOQO'#C|'#C|O.jQPO,5:tO.jQPO,5:tOOQO'#Dj'#DjO.rQPO,59iOOOO'#Dp'#DpO/QOSO,5:yOOQO,5:y,5:yOOOO'#Dq'#DqO/YOQO,5:}OOQO,5:},5:}OOQO-E7m-E7mOOQO'#Dx'#DxO/bQPO1G/aOOQO'#Dz'#DzO/jQPO1G/bO/rQPO,59yOOQO'#D}'#D}O0WQPO,59zOOQO'#EO'#EOO0`QPO,59{OOQO'#ER'#ERO0hQPO1G/iO0sQPO1G/jO0{QPO'#DmO1TQPO7+$pOOQO-E7g-E7gOOQO-E7l-E7lO1`QPO7+$rOOQO1G0`1G0`O1tQPO1G0`OOQO-E7h-E7hOOQO'#Dk'#DkO2fQPO1G/TOOQO1G/T1G/TOOOO-E7n-E7nOOQO1G0e1G0eOOOO-E7o-E7oOOQO1G0i1G0iOOQO-E7v-E7vOOQO7+${7+${OOQO-E7x-E7xOOQO7+$|7+$|O2}QPO1G/eOOQO'#D|'#D|O3cQPO1G/eOOQO1G/e1G/eOOQO-E7{-E7{OOQO1G/f1G/fOOQO-E7|-E7|OOQO1G/g1G/gOOQO-E8P-E8POOQO7+%U7+%UO3nQPO,5:XOOQO,5:X,5:XOOQO-E7k-E7kOOQO-E7i-E7iOOQO-E7z-E7z",
        stateData: "4P~OgOS!yOS~OSeOUgOVVOWWOXYOY[OZ_O]aO_cOaTOdiOfkOkRO!zPO~O[qO!{sOk!`X!w!`X!z!`X~OkuO!w!XX!z!XX~OaTO!wvX!zvX~OkzOnyO#S{O#W|O~OWWOkzOnyO~OXYOkzOnyO~OY[OkzOnyO~OZ_OkzOnyO!w|X!z|X~O]aOk!_O~O_cOk!aO~OSeOk!cO~OUgO!w!UX!z!UX~OdiOk!hOn!hO~OfkOk!jO~OSeOUgOVVOWWOXYOY[OZ_O]aO_cOaTOdiOfkOkRO~OP!tO[qOk!pOn!oO~OP!tOk!pOn!oO~O!}!vO#O!vO#P!wO#Q!wOk!cXn!cX!w!cX!z!cX#S!cX#W!cX~OQ!zOkmXnmX!wmX!zmX!}mX#OmX#PmX#QmX~O#SmX#WmX~P'qO#T!|O#U#OO~O#X#PO#Y#RO~OkzOnyO#S{O#W|O!wwa!zwa~O!}!vO#O!vO#P!wO#Q!wO!wya!zya~O!}!vO#O!vO#P!wO#Q!wO!wza!zza~O!}!vO#O!vO#P!wO#Q!wO!w{a!z{a~O!}!vO#O!vO#P!wO#Q!wO!w|a!z|a~O`#TO~O^#VO~O[qOb#YOc#[O~Oe#^O~Ob#YO~O!zPOS!ZaU!ZaV!ZaW!ZaX!ZaY!ZaZ!Za]!Za_!Zaa!Zad!Zaf!Zak!Za!w!Za~O!}!vO#O!vO#P!wO#Q!wOk!]Xn!]X!w!]X!z!]X~Os#aO~P'tOk!`Xs!`X~P'qOkzOnyO!wji!zji~OkuOs#aO~OP!tOkzOnyO#S{O#W|O~OkyOnyO~OQ!zOR#iOk#kOn#kO~O#T!|O#U#mO~O#X#PO#Y#oO~O`#TOk#qO~O^#VOk#sO~OT#uO[qOkyOnyO#S{O#W|O~Ob#YOk#yO~Oc#[Ok#{O~Oe#^O!w!Vi!z!Vi~Ob#YOk#}O~OkuOn$PO~Os#aO!wrq!zrq~OkzOnyO#S{O#W|O!wtq!ztq~O!}!vO#O!vO#P!wO#Q!wOk!|in!|i!w!|i!z!|i#S!|i#W!|i~OR#iOkqinqi!wqi!zqi#Sqi#Wqi~O!}!vO#O!vO#P!wO#Q!wO!w!Ri!z!Ri~OT#uO!w!Ri!z!Ri~OkuOs!aa!w!aa!z!aa~Onk~",
        goto: "+O#WPPPPPPPPPPPPPPPPPPPPPPPPP#X#^P#c#fP$W$b$l#^P#^%T#^#^#^%^%^%^#^#^#^#^%c%f%f%f#^#^#^#^%i%s%z&U&]&d&j&{'S'Z'e'k'q'y(R(Z(c(k(s(y)R)X)a)g)q)w*P*X*_PPPPP*gPPPP*wPPP*wVnOQoVmOQoRtRWxV!P!u#eQ!QXQ!TZQ!W]Q!Z`U!nrt!rQ#f!xQ#g!yR#t#Xa!xx!Q!T!W!Z!n#g#ta!yx!Q!T!W!Z!n#g#tW!OV!P!u#eQ!SXQ!VZQ!Y]Q!]`V!qrt!rW!OV!P!u#eR#w#XV^OQoR!efR!dfQQOSpQ!kR!knSoOQR!loQrRS!mr#XR#X!cS!rrtR#c!rS!{z!pR#h!{Q#j!{R$R#jUSOQoUvS!s$OS!srtR$O#aS#b!o!sR$Q#bS!urtR#d!uQ!PVS#S!P#eR#e!uQ!}{R#l!}Q#Q|R#n#QUUOQoRwUUXOQoR!RXUZOQoR!UZU]OQoR!X]U`OQoR![`UbOQoR!^bQ#U!_R#p#UUdOQoR!`dQ#W!aR#r#WUfOQoR!bfQ#v#XR$S#vQ#Z!cQ#`!jT#x#Z#`Q#]!cR#z#]UhOQoR!fhUjOQoR!gjQ#_!hR#|#_UlOQoR!ilmyVXZ]`rt!P!r!u!x!y#X#eZ}V!P!u#X#e",
        nodeNames: "\u26A0 ask at random if pressed else print forward turn color sleep is add from remove toList clear in not_in repeat times for Comment Program Command Assign Text Op Expression Int Op Op ListAccess AssignList Comma Ask String Clear Print Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck Else Repeat For ErrorInvalid",
        maxTerm: 102,
        nodeProps: [
          ["group", 40, "turtle"]
        ],
        skippedNodes: [0, 23],
        repeatNodeCount: 29,
        tokenData: "*x~R!^OY$}YZ&UZp$}pq&Zqr$}rs&`st&etw$}wx&|xz$}z{'R{|'W|}']}!O'b!O!P$}!P!Q'g!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!_!`*s!`#Q$}#RBn$}BnBo']BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FV&FW']&FW;'S$};'S;=`&O<%l?Hb$}?Hb?Hc']?HcO$}~%S^k~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!_$}!`#Q$}#RBn$}Bo&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~&RP;=`<%l$}~&ZO!z~~&`O!y~~&eO#S~~&jSg~OY&eZ;'S&e;'S;=`&v<%lO&e~&yP;=`<%l&e~'RO#W~~'WO!}~~']O#P~~'bOs~~'gO#Q~~'lO#O~~'s!On~k~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!`#Q$}#RBn$}BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~*xO!{~",
        tokenizers: [2, new lr_1.LocalTokenGroup("_~RQYZXwxX~^O#Y~~", 14, 101), new lr_1.LocalTokenGroup("_~RQYZXrsX~^O#U~~", 14, 97)],
        topRules: { "Program": [0, 24] },
        dynamicPrecedences: { "55": -10 },
        specialized: [{ term: 27, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }, { term: 27, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 872
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level11-parser.js
  var require_level11_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level11-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "4|QYQPOOOOQO'#Dh'#DhQYQPOOO!WQPO'#DnO!iQPO'#DgOOQO'#Dt'#DtO!tQPO'#DUOOQO'#Du'#DuO#PQPO'#DVOOQO'#Dv'#DvO#bQPO'#DXOOQO'#Dw'#DwO#mQPO'#DYOOQO'#Dx'#DxO#xQPO'#DZOOQO'#DW'#DWOOQO'#Dy'#DyO$TQPO'#D[OOQO'#Dz'#DzO$fQPO'#D]OOQO'#D|'#D|O$nQPO'#D^OOQO'#EO'#EOO$vQPO'#D_OOQO'#ES'#ESO%OQPO'#DdOOQO'#ET'#ETO%ZQPO'#DeOOQO'#EV'#EVO%fQPO'#DfOOQO'#Cw'#CwQ!RQPO'#DiQ%nQPOOOOQO-E7f-E7fOOQO'#Dj'#DjO&iQPO,59dOOQO'#Cz'#CzO&wQPO,59dOOQO'#Dn'#DnOOQO-E7l-E7lOOQO-E7r-E7rO'SQPO'#DqOOQO'#C{'#C{O(cQPO'#C{O(mOSO'#EdO(uOQO'#EhOOQO'#DT'#DTOOQO'#Dq'#DqO(}QPO,59qOOQO-E7s-E7sO)cQPO,59sOOQO-E7t-E7tOOQO,59s,59sO)wQPO,59tOOQO-E7u-E7uOOQO,59t,59tO*]QPO,59uOOQO-E7v-E7vOOQO,59u,59uO*qQPO,59vOOQO-E7w-E7wOOQO,59v,59vOOQO-E7x-E7xO+VQPO,59wOOQO-E7z-E7zO+[QPO,59xOOQO-E7|-E7|O+aQPO'#DaOOQO'#D`'#D`OOQO,59y,59yOOQO-E8Q-E8QOOQO-E8R-E8RO+lQPO,5:POOQO-E8T-E8TO+qQPO,5:QO+vQPO,5:TOOQO-E7g-E7gOOQO-E7h-E7hO,wQPO'#DkO-cQPO1G/WO-jQPO'#C{OOQO'#Dk'#DkO-tQPO1G/OO.SQPO1G/WOOQO'#Dp'#DpO.[QPO1G/YOOQO'#C}'#C}OOQO'#DO'#DOO.mQPO,5:yO.mQPO,5:yOOQO'#Dl'#DlO.uQPO,59kOOOO'#Dr'#DrO/TOSO,5;OOOQO,5;O,5;OOOOO'#Ds'#DsO/]OQO,5;SOOQO,5;S,5;SOOQO-E7o-E7oOOQO'#D{'#D{O/eQPO1G/cOOQO'#D}'#D}O/mQPO1G/dO/uQPO,59{OOQO'#EQ'#EQO0ZQPO,59|OOQO'#ER'#ERO0cQPO,59}OOQO'#EU'#EUO0kQPO1G/kO0vQPO1G/lO1RQPO'#DoO1ZQPO7+$rOOQO-E7i-E7iOOQO-E7n-E7nO1fQPO7+$tOOQO1G0e1G0eO1zQPO1G0eOOQO-E7j-E7jOOQO'#Dm'#DmO2lQPO1G/VOOQO1G/V1G/VOOOO-E7p-E7pOOQO1G0j1G0jOOOO-E7q-E7qOOQO1G0n1G0nOOQO-E7y-E7yOOQO7+$}7+$}OOQO-E7{-E7{OOQO7+%O7+%OO3TQPO1G/gOOQO'#EP'#EPO3iQPO1G/gOOQO1G/g1G/gOOQO-E8O-E8OOOQO1G/h1G/hOOQO-E8P-E8POOQO1G/i1G/iOOQO-E8S-E8SOOQO'#EW'#EWO3tQPO7+%WOOQO7+%W7+%WO4PQPO,5:ZOOQO,5:Z,5:ZOOQO-E7m-E7mOOQO-E7k-E7kOOQO-E7}-E7}OOQO-E8U-E8UO4_QPO<<HrOOQO'#EX'#EXO4dQPOAN>^OOQO-E8V-E8VOOQOG23xG23x",
        stateData: "4r~OiOS#OOS~OSfOUhOVVOWXOXZOY]OZ`O]bO_dOaTOdjOflOmRO#PPO~O[rO#QtOm!bX!|!bX#P!bX~OmvO!|!ZX#P!ZX~OaTO!|xX#PxX~OVVOm{OpzO#X|O#]}O~OWXOm{OpzO~OXZOm{OpzO~OY]Om{OpzO~OZ`Om{OpzO!|!OX#P!OX~O]bOm!aO~O_dOm!cO~OSfOm!eO~OUhO!|!WX#P!WX~OdjOm!jOp!jO~OflOm!lO~OSfOUhOVVOWXOXZOY]OZ`O]bO_dOaTOdjOflOmRO~OP!vO[rOm!rOp!qO~OP!vOm!rOp!qO~O#S!xO#T!xO#U!yO#V!yOm!eXp!eX!|!eX#P!eX#X!eX#]!eX~OQ!|OmoXpoX!|oX#PoX#SoX#ToX#UoX#VoX~O#XoX#]oX~P'tO#Y#OO#Z#QO~O#^#RO#_#TO~Om{OpzO#X|O#]}O!|ya#Pya~O#S!xO#T!xO#U!yO#V!yO!|{a#P{a~O#S!xO#T!xO#U!yO#V!yO!||a#P|a~O#S!xO#T!xO#U!yO#V!yO!|}a#P}a~O#S!xO#T!xO#U!yO#V!yO!|!Oa#P!Oa~O`#VO~O^#XO~O[rOb#[Oc#^O~Oe#`O~Ob#[O~O#PPOS!]aU!]aV!]aW!]aX!]aY!]aZ!]a]!]a_!]aa!]ad!]af!]am!]a!|!]a~O#S!xO#T!xO#U!yO#V!yOm!_Xp!_X!|!_X#P!_X~Ou#cO~P'wOm!bXu!bX~P'tOm{OpzO!|li#Pli~OmvOu#cO~OP!vOm{OpzO#X|O#]}O~OmzOpzO~OQ!|OR#kOm#mOp#mO~O#Y#OO#Z#oO~O#^#RO#_#qO~O`#VOm#sO~O^#XOm#uO~OT#wO[rOmzOpzO#X|O#]}O~Ob#[Om#{O~Oc#^Om#}O~Oe#`O!|!Xi#P!Xi~Ob#[Oh$POm$RO~OmvOp$TO~Ou#cO!|tq#Ptq~Om{OpzO#X|O#]}O!|vq#Pvq~O#S!xO#T!xO#U!yO#V!yOm#Rip#Ri!|#Ri#P#Ri#X#Ri#]#Ri~OR#kOmsipsi!|si#Psi#Xsi#]si~O#S!xO#T!xO#U!yO#V!yO!|!Ti#P!Ti~OT#wO!|!Ti#P!Ti~Oh$POm$YOp$YO~OmvOu!ca!|!ca#P!ca~Og$ZO~Og$ZOm$^Op$^O~Opm~",
        goto: "+i#]PPPPPPPPPPPPPPPPPPPPPPPPPPP#^#cP#h#kP$]$g$q#cP#c%Y#c#c#c%c%c%c#c#c#c#c%h%k%k%k#c#c#c#c%n%x&P&Z&b&i&o'Q'X'`'j'p'v(O(W(`(h(p(x)Q)W)`)f)n)t*O*U*^*f*l*t*zPPPPP+QPPPP+bPPP+bVoOQpVnOQpRuRWyW!Q!w#gQ!SYQ!V[Q!Y^Q!]aU!psu!tQ#h!zQ#i!{R#v#Za!zy!S!V!Y!]!p#i#va!{y!S!V!Y!]!p#i#vW!PW!Q!w#gQ!UYQ!X[Q![^Q!_aV!ssu!tW!PW!Q!w#gR#y#ZV_OQpR!ggR!fgQQOSqQ!mR!moSpOQR!npQsRS!os#ZR#Z!eS!tsuR#e!tS!}{!rR#j!}Q#l!}R$V#lUSOQpUwS!u$SS!usuR$S#cS#d!q!uR$U#dS!wsuR#f!wQ!QWS#U!Q#gR#g!wQ#P|R#n#PQ#S}R#p#SUUOQpRxUUWOQpR!RWUYOQpR!TYU[OQpR!W[U^OQpR!Z^UaOQpR!^aUcOQpR!`cQ#W!aR#r#WUeOQpR!beQ#Y!cR#t#YUgOQpR!dgQ#x#ZR$W#xQ#]!eQ#b!lT#z#]#bQ#_!eR#|#_UiOQpR!hiUkOQpR!ikQ#a!jR$O#aUmOQpR!kmQ$Q#bR$X$QQ$[$YR$]$[mzWY[^asu!Q!t!w!z!{#Z#gZ!OW!Q!w#Z#g",
        nodeNames: "\u26A0 ask at random if pressed else print forward turn color sleep is add from remove toList clear in not_in repeat times for to range Comment Program Command Assign Text Op Expression Int Op Op ListAccess AssignList Comma Ask String Clear Print Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck Else Repeat For ErrorInvalid",
        maxTerm: 107,
        nodeProps: [
          ["group", 42, "turtle"]
        ],
        skippedNodes: [0, 25],
        repeatNodeCount: 32,
        tokenData: "*x~R!^OY$}YZ&UZp$}pq&Zqr$}rs&`st&etw$}wx&|xz$}z{'R{|'W|}']}!O'b!O!P$}!P!Q'g!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!_!`*s!`#Q$}#RBn$}BnBo']BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FV&FW']&FW;'S$};'S;=`&O<%l?Hb$}?Hb?Hc']?HcO$}~%S^m~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!_$}!`#Q$}#RBn$}Bo&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~&RP;=`<%l$}~&ZO#P~~&`O#O~~&eO#X~~&jSi~OY&eZ;'S&e;'S;=`&v<%lO&e~&yP;=`<%l&e~'RO#]~~'WO#S~~']O#U~~'bOu~~'gO#V~~'lO#T~~'s!Op~m~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!`#Q$}#RBn$}BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~*xO#Q~",
        tokenizers: [2, new lr_1.LocalTokenGroup("_~RQYZXwxX~^O#_~~", 14, 106), new lr_1.LocalTokenGroup("_~RQYZXrsX~^O#Z~~", 14, 102)],
        topRules: { "Program": [0, 26] },
        dynamicPrecedences: { "57": -10 },
        specialized: [{ term: 29, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }, { term: 29, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 905
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level12-parser.js
  var require_level12_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level12-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "9[QYQPOOOOQO'#Dp'#DpQYQPOOO!aQPO'#DxO!uQPO'#C|O!}QPO'#DoOOQO'#D|'#D|O#YQPO'#DYOOQO'#D}'#D}O#vQPO'#DZOOQO'#EP'#EPO#}QPO'#D[OOQO'#ES'#ESO$VQPO'#D_OOQO'#ET'#ETO$^QPO'#D`OOQO'#EU'#EUO$eQPO'#DaOOQO'#D^'#D^OOQO'#EV'#EVO$lQPO'#DbOOQO'#EW'#EWO%[QPO'#DcOOQO'#EY'#EYO%cQPO'#DdOOQO'#E['#E[O%jQPO'#DeOOQO'#E`'#E`O%rQPO'#DjOOQO'#Ea'#EaO%}QPO'#DkOOQO'#Ec'#EcO&YQPO'#DlOOQO'#Ef'#EfO&bQPO'#DmOOQO'#Eg'#EgO&jQPO'#DnOOQO'#C{'#C{Q![QPO'#DqQ&qQPOOOOQO-E7n-E7nOOQO'#Dr'#DrO'uQPO,59jOOQO'#Dt'#DtO(fQPO,59hOOQO'#DQ'#DQO(TQPO,59hO(mQPO,59hO#hQPO,59hOOQO'#Dx'#DxOOQO-E7v-E7vOOQO-E7z-E7zO)sQPO'#DRO*TOSO'#EmO*]OQO'#EqOOQO'#DS'#DSO*eQPO'#EOOOQO'#DR'#DROOQO-E7{-E7{OOQO'#EO'#EOO+YQPO,59uOOQO-E7}-E7}O+dQPO,59vO,UQPO,59yOOQO-E8Q-E8QOOQO,59y,59yO,jQPO,59zOOQO-E8R-E8ROOQO,59z,59zO-OQPO,59{OOQO-E8S-E8SOOQO,59{,59{O-dQPO,59|OOQO-E8T-E8TOOQO,59|,59|O-xQPO,59}OOQO-E8U-E8UO.ZQPO,59}O.`QPO,5:OOOQO-E8W-E8WO.qQPO,5:OOOQO-E8Y-E8YO.vQPO'#DgOOQO'#Df'#DfOOQO,5:P,5:POOQO-E8^-E8^OOQO-E8_-E8_O/UQPO,5:VOOQO-E8a-E8aO/ZQPO,5:WOOQO-E8d-E8dO/`QPO,5:XO/kQPO,5:YOOQO-E8e-E8eO/uQPO,5:]OOQO-E7o-E7oOOQO-E7p-E7pOOQO'#Ds'#DsO1PQPO1G/UOOQO1G/U1G/UO1zQPO'#DROOQO-E7r-E7rO2UQPO'#DuO2vQPO1G/]OOQO'#Du'#DuO3kQPO1G/SO4PQPO1G/]OOQO'#Dz'#DzO4XQPO1G/_OOOO'#Dv'#DvO4jOSO,5;XOOQO,5;X,5;XOOOO'#Dw'#DwO4rOQO,5;]OOQO,5;],5;]OOQO'#DT'#DTOOQO'#DU'#DUO$|QPO,5;aO$|QPO,5;aOOQO-E7|-E7|OOQO'#EQ'#EQO4zQPO1G/bOOQO'#EX'#EXO5]QPO1G/iOOQO'#EZ'#EZO5eQPO1G/jO6OQPO,5:RO5mQPO,5:ROOQO'#E^'#E^O6VQPO,5:SOOQO'#E_'#E_O6_QPO,5:TOOQO'#Eb'#EbO6gQPO1G/qO6rQPO1G/rO4zQPO1G/sOOQO-E7q-E7qO6}QPO'#DyO7VQPO7+$wOOQO-E7s-E7sO7bQPO'#D{OOQO-E7x-E7xOOQO'#D{'#D{O8SQPO7+$yOOOO-E7t-E7tOOQO1G0s1G0sOOOO-E7u-E7uOOQO1G0w1G0wOOQO1G0{1G0{O8hQPO1G0{O9fQPO'#EzOOQO-E8O-E8OOOQO'#Ez'#EzO:dQPO'#D]OOQO7+$|7+$|OOQO-E8V-E8VOOQO7+%T7+%TOOQO-E8X-E8XOOQO7+%U7+%UO;UQPO1G/mOOQO'#E]'#E]O;jQPO1G/mOOQO-E8[-E8[OOQO1G/n1G/nOOQO-E8]-E8]OOQO1G/o1G/oOOQO-E8`-E8`OOQO'#Ed'#EdO;uQPO7+%^OOQO7+%^7+%^OOQO7+%_7+%_O<QQPO,5:eOOQO,5:e,5:eOOQO-E7w-E7wOOQO-E7y-E7yO#hQPO'#ERO<`QPO,59wOOQO-E8Z-E8ZOOQO-E8b-E8bO=QQPO<<HxOOQO,5:m,5:mOOQO-E8P-E8POOQO'#Ee'#EeO=VQPOAN>dOOQO-E8c-E8cOOQOG24OG24O",
        stateData: "=e~OmOS#^OS~OSiOUkOVWOW[OX^OY`OZcO]eO_gOaUOdmOfoOiYOjqOksOqRO#_PO~OQyO[{O#`}Oq!lX#[!lX#_!lX~O[{O#`}O~Oq!RO#[!cX#_!cX~OaUO#[|X#_|X~OiYOq!UOs!ZO#b!VO#f!WO~OVWO~P#eOiYOq!`O~OW[O~P#eOX^O~P#eOY`O~P#eOZcO#[!UX#_!UX~P#eOiYOq!ZOs!ZO#b!VO#f!WO~O]eO~P$yO_gO~P$yOSiOq!tO~OUkO#[!^X#_!^X~OdmOq!yOs!yO~OfoOq!{O~OjqOq!}O~OksO~P#eOSiOUkOVWOW[OX^OY`OZcO]eO_gOaUOdmOfoOiYOjqOksOqRO~OQyOR#TOq#VOs#VO~OP#_Oq#WOs#ZO#b!VO#f!WO~O[{O~P(TO[{Oq!UOs!ZO#b!VO#f!WO~OQyOquXsuX#[uX#_uX#buX#fuX#juX#kuX#luX#muX~OiuXzuX`uX^uX~P)OO#c#aO#d#cO~O#g#dO#h#fO~O#j#gO#k#gO#l#hO#m#hOi!rXq!rXs!rX#[!rX#_!rX#b!rX#f!rX~O#[}a#_}a~P#eOl#lO#[!Oa#_!Oai!Oaq!Oas!Oa#b!Oa#f!Oa`!Oa^!Oa~O#j#gO#k#gO#l#hO#m#hO#[!Ra#_!Ra~O#j#gO#k#gO#l#hO#m#hO#[!Sa#_!Sa~O#j#gO#k#gO#l#hO#m#hO#[!Ta#_!Ta~O#j#gO#k#gO#l#hO#m#hO#[!Ua#_!Ua~O`#nO#j#gO#k#gO#l#hO#m#hO~O`#nO~O^#pO#j#gO#k#gO#l#hO#m#hO~O^#pO~O[{Ob#tOc#vO#`}O~Oe#xO~Ob#tO~Ol#lO#[!aa#_!aa~O#[!ba#_!ba~P#eO#_POS!eaU!eaV!eaW!eaX!eaY!eaZ!ea]!ea_!eaa!ead!eaf!eai!eaj!eak!eaq!ea#[!ea~OR#TO[ri#`riiriqrisri#[ri#_ri#bri#frizri`ri^ri~Oq!lXz!lX~P)OO#j#gO#k#gO#l#hO#m#hOq!iXs!iX#[!iX#_!iX#b!iX#f!iX~Oz#}OquXsuX#[uX#_uX#buX#fuX#juX#kuX#luX#muX~Oq!UOs!ZO#b!VO#f!WO#[pi#_pi~Oq!ROz#}O~OP#_Oq!UOs!ZO#b!VO#f!WO~O#c#aO#d$VO~O#g#dO#h$XO~Ol#lOq!UOs!ZO#b!VO#f!WO~O`#nOq$bO~O^#pOq$dO~OT$fOq!ZOs!ZO#b!VO#f!WO~O[{O~P5mOb#tOq$iO~Oc#vOq$kO~Oe#xO#[!_i#_!_i~Ob#tOh$mOq$oO~Oq!ROs$rO~Oz#}O#[yq#_yq~O#j#gO#k#gO#l#hO#m#hOq!oXs!oX#[!oX#_!oX#b!oX#f!oX~Oq!UOs!ZO#b!VO#f!WO#[{q#_{q~O#j#gO#k#gO#l#hO#m#hOi#iiq#iis#ii#[#ii#_#ii#b#ii#f#ii`#ii^#iiz#ii~O#j#gO#k#gO#l#hO#m#hOz#nX#[#nX#_#nXi#nXq#nXs#nX#b#nX#f#nX`#nX^#nX~Oz$uO#[!PX#_!PXi!PXq!PXs!PX#b!PX#f!PX`!PX^!PX~O#j#gO#k#gO#l#hO#m#hO#[!Zi#_!Zi~OT$fO#[!Zi#_!Zi~Oh$mOq$yOs$yO~Oq!ROz!ma#[!ma#_!ma~Oz$uO#[!Pa#_!Pai!Paq!Pas!Pa#b!Pa#f!Pa`!Pa^!Pa~Og$|O~Og$|Oq%POs%PO~Osq~",
        goto: "/s#oPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP#p#uP#zP$s$|&Q&l&z#uP#u#u#u'Y'w#u'}'}'}#u#u#u#u(S(V(V(V#u#u#u#u#u#u(Y(d(k(s(y)X)b)h)n*P*W*_*e*m*u+P+c+m+s+{,T,],e,m,t,|-T-]-d-n-t-|.U.[.d.j.p.xPPPPP/QPPP/QPPP&QPPPP/lVvOQwVuOQwUSOQwW!]Xt!^#OQ!c]Q!f_Q!iaQ!ldY#[|!O!P!Q#]S$S#`$TV$^#m#{$uQ!ORQ!QSR#s!tW!YXt!^#OQ!a]Q!d_Q!gaQ!jdQ!mfQ!phY#Y|!O!P!Q#]S$Q#`$TQ$Y#iQ$Z#jU$[#m#{$uT$e#r#s!R!ZX]_adfht|!O!P!Q!^#O#]#`#i#j#m#r#s#{$T$ui#i!Y!a!d!g!j!m!p#Y$Q$Z$[$ei#j!Y!a!d!g!j!m!p#Y$Q$Z$[$eUuOQwW!]Xt!^#OQ!c]Q!f_Q!iaQ!ldQ!ofR!rhQ$`#mR$p#{VbOQwR!vjR!ujQQOSxQ#QR#QvSwOQR#RwUzR!U#WR#SzQ#UzR#|#UQ|RQ!PSU#X|!P#rR#r!tW#]|!O!P!QR$P#]Q#b!VR$U#bQ#e!WR$W#eUTOQwU!ST#^$qS#^|!OR$q#}S$O#Z#^R$s$OS#`|!OR$R#`Q$T#`R$t$TUVOQwR!TVUXOQwR![XQ!^XQ#OtT#k!^#OjZOQX]_adfhtw!^#OR!_ZQ#m!`Q#{!}T$]#m#{Q$v$_R${$vU]OQwR!b]U_OQwR!e_UaOQwR!haUdOQwR!kdUfOQwR!nfS#o!m!oR$a#oUhOQwR!qhS#q!p!rR$c#qUjOQwR!sjS$g#r#sR$w$gQ#u!tQ#z!{T$h#u#zQ#w!tR$j#wUlOQwR!wlUnOQwR!xnQ#y!yR$l#yUpOQwR!zpQ$n#zR$x$nQ$}$yR%O$}UrOQwR!|rUtOQwR#Pt!R!XX]_adfht|!O!P!Q!^#O#]#`#i#j#m#r#s#{$T$uS$_#m#{R$z$u",
        nodeNames: "\u26A0 ask at random if pressed else print forward turn color sleep is add from remove toList clear in not_in repeat times for to range call define return with Comment Program Command Assign Text ListAccess Number Op Expression String Op Op AssignList Comma Ask Clear Print Call Arguments Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck Else Repeat For Define Return ErrorInvalid",
        maxTerm: 122,
        nodeProps: [
          ["group", 48, "turtle"]
        ],
        skippedNodes: [0, 29],
        repeatNodeCount: 38,
        tokenData: "1U~R!^OY$}YZ&UZp$}pq&Zqr$}rs&`st&etw$}wx&|xz$}z{'R{|'W|}']}!O'b!O!P$}!P!Q'g!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!_!`1P!`#Q$}#RBn$}BnBo']BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FV&FW']&FW;'S$};'S;=`&O<%l?Hb$}?Hb?Hc']?HcO$}~%S^q~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!_$}!`#Q$}#RBn$}Bo&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~&RP;=`<%l$}~&ZO#_~~&`O#^~~&eO#b~~&jSm~OY&eZ;'S&e;'S;=`&v<%lO&e~&yP;=`<%l&e~'RO#f~~'WO#j~~']O#l~~'bOz~~'gO#m~~'lO#k~~'s!Os~q~OY$}Zp$}qr$}tw$}xz$}!O!P*s!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!`#Q$}#RBn$}BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~*x!Oq~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R-x!R!S-x!S!T-x!T!U-x!U!V-x!V!W-x!W!X-x!X!Y-x!Y!Z-x!Z![-x![!_$}!`#Q$}#RBn$}BoDf$}DfDg-xDgDh-xDhDi-xDiDj-xDjDk-xDkDl-xDlDm-xDmDn-xDnDo-xDoDp-xDpGl$}GlGm-xGmGn-xGnGo-xGoGp-xGpGq-xGqGr-xGrGs-xGsGt-xGtGu-xGuGv-xGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~.P!Os~q~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R-x!R!S-x!S!T-x!T!U-x!U!V-x!V!W-x!W!X-x!X!Y-x!Y!Z-x!Z![-x![!_$}!`#Q$}#RBn$}BoDf$}DfDg-xDgDh-xDhDi-xDiDj-xDjDk-xDkDl-xDlDm-xDmDn-xDnDo-xDoDp-xDpGl$}GlGm-xGmGn-xGnGo-xGoGp-xGpGq-xGqGr-xGrGs-xGsGt-xGtGu-xGuGv-xGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~1UO#`~",
        tokenizers: [2, new lr_1.LocalTokenGroup("_~RQYZXwxX~^O#h~~", 14, 115), new lr_1.LocalTokenGroup("_~RQYZXrsX~^O#d~~", 14, 111)],
        topRules: { "Program": [0, 30] },
        dynamicPrecedences: { "65": -10 },
        specialized: [{ term: 33, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }, { term: 33, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 1306
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level13-parser.js
  var require_level13_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level13-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: ":dQYQPOOOOQO'#Dr'#DrQYQPOOO!aQPO'#DzO!uQPO'#DOO!}QPO'#DqOOQO'#EO'#EOO#YQPO'#D[OOQO'#EP'#EPO#vQPO'#D]OOQO'#ER'#ERO#}QPO'#D^OOQO'#EU'#EUO$VQPO'#DaOOQO'#EV'#EVO$^QPO'#DbOOQO'#EW'#EWO$eQPO'#DcOOQO'#D`'#D`OOQO'#EX'#EXO$lQPO'#DdOOQO'#EY'#EYO%[QPO'#DeOOQO'#E['#E[O%cQPO'#DfOOQO'#E^'#E^O%jQPO'#DgOOQO'#Ee'#EeO%rQPO'#DlOOQO'#Ef'#EfO%}QPO'#DmOOQO'#Eh'#EhO&YQPO'#DnOOQO'#Ek'#EkO&bQPO'#DoOOQO'#El'#ElO&jQPO'#DpOOQO'#C}'#C}Q![QPO'#DsQ&qQPOOOOQO-E7p-E7pOOQO'#Dt'#DtO'uQPO,59lOOQO'#Dv'#DvO(fQPO,59jOOQO'#DS'#DSO(TQPO,59jO(mQPO,59jO#hQPO,59jOOQO'#Dz'#DzOOQO-E7x-E7xOOQO-E7|-E7|O)sQPO'#DTO*TOSO'#ErO*]OQO'#EvOOQO'#DU'#DUO*eQPO'#EQOOQO'#DT'#DTOOQO-E7}-E7}OOQO'#EQ'#EQO+YQPO,59wOOQO-E8P-E8PO+dQPO,59xO,UQPO,59{OOQO-E8S-E8SOOQO,59{,59{O,jQPO,59|OOQO-E8T-E8TOOQO,59|,59|O-OQPO,59}OOQO-E8U-E8UOOQO,59},59}O-dQPO,5:OOOQO-E8V-E8VOOQO,5:O,5:OO-xQPO,5:POOQO-E8W-E8WO.ZQPO,5:PO.`QPO,5:QOOQO-E8Y-E8YO.qQPO,5:QOOQO-E8[-E8[O.vQPO'#DiOOQO'#Dh'#DhO/UQPO,5:ROOQO-E8c-E8cOOQO-E8d-E8dO/dQPO,5:XOOQO-E8f-E8fO/iQPO,5:YOOQO-E8i-E8iO/nQPO,5:ZO/yQPO,5:[OOQO-E8j-E8jO0TQPO,5:_OOQO-E7q-E7qOOQO-E7r-E7rOOQO'#Du'#DuO1_QPO1G/WOOQO1G/W1G/WO2YQPO'#DTOOQO-E7t-E7tO2dQPO'#DwO3UQPO1G/_OOQO'#Dw'#DwO3yQPO1G/UO4_QPO1G/_OOQO'#D|'#D|O4gQPO1G/aOOOO'#Dx'#DxO4xOSO,5;^OOQO,5;^,5;^OOOO'#Dy'#DyO5QOQO,5;bOOQO,5;b,5;bOOQO'#DV'#DVOOQO'#DW'#DWO$|QPO,5;fO$|QPO,5;fOOQO-E8O-E8OOOQO'#ES'#ESO5YQPO1G/dOOQO'#EZ'#EZO5kQPO1G/kOOQO'#E]'#E]O5sQPO1G/lO6^QPO,5:TO5{QPO,5:TOOQO'#E`'#E`O6eQPO,5:UOOQO'#Ea'#EaO6mQPO,5:VOOQO'#Ec'#EcO6uQPO'#EbOOQO'#Ed'#EdO6}QPO'#EbO7VQPO1G/mOOQO'#Eg'#EgO7eQPO1G/sO7pQPO1G/tO5YQPO1G/uOOQO-E7s-E7sO7{QPO'#D{O8TQPO7+$yOOQO-E7u-E7uO8`QPO'#D}OOQO-E7z-E7zOOQO'#D}'#D}O9QQPO7+${OOOO-E7v-E7vOOQO1G0x1G0xOOOO-E7w-E7wOOQO1G0|1G0|OOQO1G1Q1G1QO9fQPO1G1QO:jQPO'#FPOOQO-E8Q-E8QOOQO'#FP'#FPO;hQPO'#D_OOQO7+%O7+%OOOQO-E8X-E8XOOQO7+%V7+%VOOQO-E8Z-E8ZOOQO7+%W7+%WO<YQPO1G/oOOQO'#E_'#E_O<tQPO1G/oOOQO-E8^-E8^OOQO1G/p1G/pOOQO-E8_-E8_OOQO1G/q1G/qOOQO-E8a-E8aOOQO,5:|,5:|OOQO-E8b-E8bOOQO-E8`-E8`OOQO-E8e-E8eOOQO'#Ei'#EiO=VQPO7+%`OOQO7+%`7+%`OOQO7+%a7+%aO=bQPO,5:gOOQO,5:g,5:gOOQO-E7y-E7yOOQO-E7{-E7{O#hQPO'#ETO=pQPO,59yOOQO-E8]-E8]OOQO-E8g-E8gO>bQPO<<HzOOQO,5:o,5:oOOQO-E8R-E8ROOQO'#Ej'#EjO>gQPOAN>fOOQO-E8h-E8hOOQOG24QG24Q",
        stateData: ">u~OoOS#cOS~OSiOUkOXWOY[OZ^O[`O]cO_eOagOcUOfmOhoOkYOlqOmsOsRO#dPO~OQyO^{O#e}Os!nX#a!nX#d!nX~O^{O#e}O~Os!RO#a!eX#d!eX~OcUO#a!OX#d!OX~OkYOs!UOu!ZO#g!VO#k!WO~OXWO~P#eOkYOs!`O~OY[O~P#eOZ^O~P#eO[`O~P#eO]cO#a!WX#d!WX~P#eOkYOs!ZOu!ZO#g!VO#k!WO~O_eO~P$yOagO~P$yOSiOs!tO~OUkO#a!`X#d!`X~OfmOs!yOu!yO~OhoOs!{O~OlqOs!}O~OmsO~P#eOSiOUkOXWOY[OZ^O[`O]cO_eOagOcUOfmOhoOkYOlqOmsOsRO~OQyOR#TOs#VOu#VO~OP#_Os#WOu#ZO#g!VO#k!WO~O^{O~P(TO^{Os!UOu!ZO#g!VO#k!WO~OQyOswXuwX#awX#dwX#gwX#kwX#owX#pwX#qwX#rwX~OkwX|wXbwX`wX~P)OO#h#aO#i#cO~O#l#dO#m#fO~O#o#gO#p#gO#q#hO#r#hOk!tXs!tXu!tX#a!tX#d!tX#g!tX#k!tX~O#a!Pa#d!Pa~P#eOn#lO#a!Qa#d!Qak!Qas!Qau!Qa#g!Qa#k!Qab!Qa`!Qa~O#o#gO#p#gO#q#hO#r#hO#a!Ta#d!Ta~O#o#gO#p#gO#q#hO#r#hO#a!Ua#d!Ua~O#o#gO#p#gO#q#hO#r#hO#a!Va#d!Va~O#o#gO#p#gO#q#hO#r#hO#a!Wa#d!Wa~Ob#nO#o#gO#p#gO#q#hO#r#hO~Ob#nO~O`#pO#o#gO#p#gO#q#hO#r#hO~O`#pO~O^{Od#tOe#vO#e}O~OV#xOW#zO#a!Za#d!Za~Og#}O~Od#tO~On#lO#a!ca#d!ca~O#a!da#d!da~P#eO#dPOS!gaU!gaX!gaY!gaZ!ga[!ga]!ga_!gaa!gac!gaf!gah!gak!gal!gam!gas!ga#a!ga~OR#TO^ti#etiktistiuti#ati#dti#gti#kti|tibti`ti~Os!nX|!nX~P)OO#o#gO#p#gO#q#hO#r#hOs!kXu!kX#a!kX#d!kX#g!kX#k!kX~O|$SOswXuwX#awX#dwX#gwX#kwX#owX#pwX#qwX#rwX~Os!UOu!ZO#g!VO#k!WO#ari#dri~Os!RO|$SO~OP#_Os!UOu!ZO#g!VO#k!WO~O#h#aO#i$[O~O#l#dO#m$^O~On#lOs!UOu!ZO#g!VO#k!WO~Ob#nOs$gO~O`#pOs$iO~OT$kOs!ZOu!ZO#g!VO#k!WO~O^{O~P5{Od#tOs$nO~Oe#vOs$pO~OV#xOs!tO~OW#zOs!tO~OV#xOW#zO#a!Zi#d!Zi~Og#}O#a!ai#d!ai~Od#tOj$vOs$xO~Os!ROu${O~O|$SO#a{q#d{q~O#o#gO#p#gO#q#hO#r#hOs!qXu!qX#a!qX#d!qX#g!qX#k!qX~Os!UOu!ZO#g!VO#k!WO#a}q#d}q~O#o#gO#p#gO#q#hO#r#hOk#nis#niu#ni#a#ni#d#ni#g#ni#k#nib#ni`#ni|#niV#niW#ni~O#o#gO#p#gO#q#hO#r#hO|#sX#a#sX#d#sXk#sXs#sXu#sX#g#sX#k#sXb#sX`#sX~O|%OO#a!RX#d!RXk!RXs!RXu!RX#g!RX#k!RXb!RX`!RX~O#o#gO#p#gO#q#hO#r#hOV!]iW!]i#a!]i#d!]i~OT$kOV!]iW!]i#a!]i#d!]i~Oj$vOs%SOu%SO~Os!RO|!oa#a!oa#d!oa~O|%OO#a!Ra#d!Rak!Ras!Rau!Ra#g!Ra#k!Rab!Ra`!Ra~Oi%VO~Oi%VOs%YOu%YO~Ous~",
        goto: "0d#tPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP#u#zP$PP$x%R&V&q'P#zP#z#z#z'_'|#z(S(S(S#z#z#z#z(X(`(`(`#z#z#z#z#z#z(e(o(v)O)U)d)m)s)y*[*c*j*p*x+Q+[+n+x,O,W,`,h,p,x-P-X-`-h-o-y.P.V.^.e.m.u.{/T/Z/a/iPPPPP/qPPP/qPPP&VPPPP0]VvOQwVuOQwUSOQwW!]Xt!^#OQ!c]Q!f_Q!iaQ!ldY#[|!O!P!Q#]S$X#`$YV$c#m$Q%OQ!ORQ!QSR#s!tW!YXt!^#OQ!a]Q!d_Q!gaQ!jdQ!mfQ!phY#Y|!O!P!Q#]S$V#`$YQ$_#iQ$`#jU$a#m$Q%OT$j#r#s!R!ZX]_adfht|!O!P!Q!^#O#]#`#i#j#m#r#s$Q$Y%Oi#i!Y!a!d!g!j!m!p#Y$V$`$a$ji#j!Y!a!d!g!j!m!p#Y$V$`$a$jUuOQwW!]Xt!^#OQ!c]Q!f_Q!iaQ!ldQ!ofR!rhQ$e#mR$y$QVbOQwQ!vjT$r#y#{V!uj#y#{QQOSxQ#QR#QvSwOQR#RwUzR!U#WR#SzQ#UzR$R#UQ|RQ!PSU#X|!P#rR#r!tW#]|!O!P!QR$U#]Q#b!VR$Z#bQ#e!WR$]#eUTOQwU!ST#^$zS#^|!OR$z$SS$T#Z#^R$|$TS#`|!OR$W#`Q$Y#`R$}$YUVOQwR!TVUXOQwR![XQ!^XQ#OtT#k!^#OjZOQX]_adfhtw!^#OR!_ZQ#m!`Q$Q!}T$b#m$QQ%P$dR%U%PU]OQwR!b]U_OQwR!e_UaOQwR!haUdOQwR!kdUfOQwR!nfS#o!m!oR$f#oUhOQwR!qhS#q!p!rR$h#qUjOQwR!sjS$l#r#sR%Q$lQ#u!tQ$P!{T$m#u$PQ#w!tR$o#wQ#|!vR$t#|S#y!v#|R$q#yS#{!v#|R$s#{UlOQwR!wlUnOQwR!xnQ$O!yR$u$OUpOQwR!zpQ$w$PR%R$wQ%W%SR%X%WUrOQwR!|rUtOQwR#Pt!R!XX]_adfht|!O!P!Q!^#O#]#`#i#j#m#r#s$Q$Y%OS$d#m$QR%T%O",
        nodeNames: "\u26A0 ask at random if pressed else and or print forward turn color sleep is add from remove toList clear in not_in repeat times for to range call define return with Comment Program Command Assign Text ListAccess Number Op Expression String Op Op AssignList Comma Ask Clear Print Call Arguments Turtle Forward Turn Color Sleep Add Remove If Condition EqualityCheck InListCheck NotInListCheck Else Repeat For Define Return ErrorInvalid",
        maxTerm: 127,
        nodeProps: [
          ["group", 50, "turtle"]
        ],
        skippedNodes: [0, 31],
        repeatNodeCount: 41,
        tokenData: "1U~R!^OY$}YZ&UZp$}pq&Zqr$}rs&`st&etw$}wx&|xz$}z{'R{|'W|}']}!O'b!O!P$}!P!Q'g!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!_!`1P!`#Q$}#RBn$}BnBo']BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FV&FW']&FW;'S$};'S;=`&O<%l?Hb$}?Hb?Hc']?HcO$}~%S^s~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!_$}!`#Q$}#RBn$}Bo&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~&RP;=`<%l$}~&ZO#d~~&`O#c~~&eO#g~~&jSo~OY&eZ;'S&e;'S;=`&v<%lO&e~&yP;=`<%l&e~'RO#k~~'WO#o~~']O#q~~'bO|~~'gO#r~~'lO#p~~'s!Ou~s~OY$}Zp$}qr$}tw$}xz$}!O!P*s!Q!R'l!R!S'l!S!T'l!T!U'l!U!V'l!V!W'l!W!X'l!X!Y'l!Y!Z'l!Z!['l![!_$}!`#Q$}#RBn$}BoDf$}DfDg'lDgDh'lDhDi'lDiDj'lDjDk'lDkDl'lDlDm'lDmDn'lDnDo'lDoDp'lDpGl$}GlGm'lGmGn'lGnGo'lGoGp'lGpGq'lGqGr'lGrGs'lGsGt'lGtGu'lGuGv'lGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~*x!Os~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R-x!R!S-x!S!T-x!T!U-x!U!V-x!V!W-x!W!X-x!X!Y-x!Y!Z-x!Z![-x![!_$}!`#Q$}#RBn$}BoDf$}DfDg-xDgDh-xDhDi-xDiDj-xDjDk-xDkDl-xDlDm-xDmDn-xDnDo-xDoDp-xDpGl$}GlGm-xGmGn-xGnGo-xGoGp-xGpGq-xGqGr-xGrGs-xGsGt-xGtGu-xGuGv-xGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~.P!Ou~s~OY$}Zp$}qr$}tw$}xz$}!O!P$}!Q!R-x!R!S-x!S!T-x!T!U-x!U!V-x!V!W-x!W!X-x!X!Y-x!Y!Z-x!Z![-x![!_$}!`#Q$}#RBn$}BoDf$}DfDg-xDgDh-xDhDi-xDiDj-xDjDk-xDkDl-xDlDm-xDmDn-xDnDo-xDoDp-xDpGl$}GlGm-xGmGn-xGnGo-xGoGp-xGpGq-xGqGr-xGrGs-xGsGt-xGtGu-xGuGv-xGv&FV$}&FW;'S$};'S;=`&O<%l?Hb$}?HcO$}~1UO#e~",
        tokenizers: [2, new lr_1.LocalTokenGroup("_~RQYZXwxX~^O#m~~", 14, 120), new lr_1.LocalTokenGroup("_~RQYZXrsX~^O#i~~", 14, 116)],
        topRules: { "Program": [0, 32] },
        dynamicPrecedences: { "67": -10 },
        specialized: [{ term: 35, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }, { term: 35, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 1368
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level14-parser.js
  var require_level14_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level14-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "<zQYQPOOOOQO'#Dx'#DxQYQPOOO!aQPO'#EQO!uQPO'#DOO!}QPO'#DwOOQO'#EU'#EUO#YQPO'#D[OOQO'#EV'#EVO#vQPO'#D]OOQO'#EX'#EXO#}QPO'#D^OOQO'#E['#E[O$VQPO'#DaOOQO'#E]'#E]O$^QPO'#DbOOQO'#E^'#E^O$eQPO'#DcOOQO'#D`'#D`OOQO'#E_'#E_O$lQPO'#DdOOQO'#E`'#E`O%[QPO'#DeOOQO'#Eb'#EbO%cQPO'#DfOOQO'#Ed'#EdO%{QPO'#DgOOQO'#Ek'#EkO&SQPO'#DrOOQO'#El'#ElO&_QPO'#DsOOQO'#En'#EnO&jQPO'#DtOOQO'#Eq'#EqO&rQPO'#DuOOQO'#Er'#ErO&zQPO'#DvOOQO'#C}'#C}Q![QPO'#DyQ'RQPOOOOQO-E7v-E7vOOQO'#Dz'#DzO(VQPO,59lOOQO'#D|'#D|O(vQPO,59jOOQO'#DS'#DSO(eQPO,59jO(}QPO,59jO#hQPO,59jOOQO'#EQ'#EQOOQO-E8O-E8OOOQO-E8S-E8SO*TQPO'#DTO+QOSO'#ExO+YOQO'#E|OOQO'#DU'#DUO+bQPO'#EWOOQO'#DT'#DTOOQO-E8T-E8TOOQO'#EW'#EWO,VQPO,59wOOQO-E8V-E8VO,aQPO,59xO-nQPO,59{OOQO-E8Y-E8YOOQO,59{,59{O.SQPO,59|OOQO-E8Z-E8ZOOQO,59|,59|O.hQPO,59}OOQO-E8[-E8[OOQO,59},59}O.|QPO,5:OOOQO-E8]-E8]OOQO,5:O,5:OO/bQPO,5:POOQO-E8^-E8^O/sQPO,5:PO/xQPO,5:QOOQO-E8`-E8`O0ZQPO,5:QO0wQPO'#DjO1XQPO'#DTOOQO-E8b-E8bO0`QPO'#DjOOQO'#Dh'#DhO1`QPO,5:ROOQO-E8i-E8iOOQO-E8j-E8jO1nQPO,5:_OOQO-E8l-E8lO1sQPO,5:`OOQO-E8o-E8oO1xQPO,5:aO2TQPO,5:bOOQO-E8p-E8pO2_QPO,5:eOOQO-E7w-E7wOOQO-E7x-E7xOOQO'#D{'#D{O3iQPO1G/WOOQO1G/W1G/WO5kQPO'#DTOOQO-E7z-E7zO5xQPO'#D}O6jQPO1G/_OOQO'#D}'#D}O6qQPO1G/UO7VQPO1G/_OOQO'#ES'#ESO7_QPO1G/aOOOO'#EO'#EOO7pOSO,5;dOOQO,5;d,5;dOOOO'#EP'#EPO7xOQO,5;hOOQO,5;h,5;hOOQO'#DV'#DVOOQO'#DW'#DWO$|QPO,5;lO$|QPO,5;lOOQO-E8U-E8UOOQO'#EY'#EYO8QQPO1G/dOOQO'#Ea'#EaO8cQPO1G/kOOQO'#Ec'#EcO8kQPO1G/lO8sQPO,5:UO8zQPO,5:UOOQO'#Dl'#DlO$yQPO,5:VOOQO'#Dn'#DnOOQO'#Do'#DoO8zQPO,5:XOOQO'#Ef'#EfO9RQPO,5:[OOQO'#Eg'#EgO9ZQPO,5:]O9cQPO,5:TOOQO'#Ei'#EiO9kQPO'#EhOOQO'#Ej'#EjO9rQPO'#EhO9yQPO1G/mOOQO'#Em'#EmO:XQPO1G/yO:dQPO1G/zO8QQPO1G/{OOQO-E7y-E7yO:oQPO'#ERO:wQPO7+$yOOQO-E7{-E7{O;SQPO'#ETOOQO-E8Q-E8QOOQO'#ET'#ETO;tQPO7+${OOOO-E7|-E7|OOQO1G1O1G1OOOOO-E7}-E7}OOQO1G1S1G1SOOQO1G1W1G1WO<YQPO1G1WO=sQPO'#FVOOQO-E8W-E8WOOQO'#FV'#FVO?^QPO'#D_OOQO7+%O7+%OOOQO-E8_-E8_OOQO7+%V7+%VOOQO-E8a-E8aOOQO7+%W7+%WO@kQPO1G/pOOQO1G/p1G/pO$yQPO1G/pOAVQPO1G/qOOQO1G/q1G/qOAqQPO1G/sOOQO1G/s1G/sO$yQPO1G/sOOQO-E8d-E8dOOQO1G/v1G/vOOQO-E8e-E8eOOQO1G/w1G/wOOQO'#Ee'#EeOB]QPO1G/oOOQO-E8g-E8gOOQO,5;S,5;SOOQO-E8h-E8hOOQO-E8f-E8fOOQO-E8k-E8kOOQO'#Eo'#EoOBnQPO7+%fOOQO7+%f7+%fOOQO7+%g7+%gOByQPO,5:mOOQO,5:m,5:mOOQO-E8P-E8POOQO-E8R-E8RO#hQPO'#EZOCXQPO,59yODfQPO7+%[OOQO7+%[7+%[OEQQPO7+%_OOQO7+%_7+%_OOQO-E8c-E8cOOQO-E8m-E8mOElQPO<<IQOOQO,5:u,5:uOOQO-E8X-E8XOOQO'#Ep'#EpOEqQPOAN>lOOQO-E8n-E8nOOQOG24WG24W",
        stateData: "FP~OoOS#iOS~OSiOUkOYWOZ[O[^O]`O^cO_eOagOcUOfmOhoOkYOlqOmsOsRO#jPO~OQyOX{O#k}Os!tX#g!tX#j!tX~OX{O#k}O~Os!RO#g!kX#j!kX~OcUO#g!OX#j!OX~OkYOs!UOu!ZO#m!VO#q!WO~OYWO~P#eOkYOs!`O~OZ[O~P#eO[^O~P#eO]`O~P#eO^cO#g!WX#j!WX~P#eOkYOs!ZOu!ZO#m!VO#q!WO~O_eO~P$yOagO~P$yOkYOs!tOu!ZO#m!VO#q!WO~OSiO~P%jOUkO#g!fX#j!fX~OfmOs!{Ou!{O~OhoOs!}O~OlqOs#PO~OmsO~P#eOSiOUkOYWOZ[O[^O]`O^cO_eOagOcUOfmOhoOkYOlqOmsOsRO~OQyOR#VOs#XOu#XO~OP#aOs#YOu#]O#m!VO#q!WO~OX{O~P(eOX{Os!UOu!ZO#m!VO#q!WO~O#uwX#vwX#wwX#xwXXwXdwXewX#kwX#zwX#{wX#|wX~OQyOkwXswXuwX#gwX#jwX#mwX#qwX|wXbwX`wXVwXWwX~P)`O#n#cO#o#eO~O#r#fO#s#hO~O#u#iO#v#iO#w#jO#x#jOk!zXs!zXu!zX#g!zX#j!zX#m!zX#q!zX~O#g!Pa#j!Pa~P#eOn#nO#g!Qa#j!Qak!Qas!Qau!Qa#m!Qa#q!Qab!Qa`!QaX!Qad!Qae!Qa#k!Qa#z!Qa#{!Qa#|!QaV!QaW!Qa~O#u#iO#v#iO#w#jO#x#jO#g!Ta#j!Ta~O#u#iO#v#iO#w#jO#x#jO#g!Ua#j!Ua~O#u#iO#v#iO#w#jO#x#jO#g!Va#j!Va~O#u#iO#v#iO#w#jO#x#jO#g!Wa#j!Wa~Ob#pO#u#iO#v#iO#w#jO#x#jO~Ob#pO~O`#rO#u#iO#v#iO#w#jO#x#jO~O`#rO~OX{Od#{Oe#}O#k}O#z#vO#{#xO#|#yO~O#u#iO#v#iO#w#jO#x#jO~P0`OX{O~P)`OV$QOW$SO#g!Za#j!Za~Og$VO~Od#{O~On#nO#g!ia#j!ia~O#g!ja#j!ja~P#eO#jPOS!maU!maY!maZ!ma[!ma]!ma^!ma_!maa!mac!maf!mah!mak!mal!mam!mas!ma#g!ma~OR#VOXti#ktiktistiuti#gti#jti#mti#qti|tibti`tidtieti#zti#{ti#|tiVtiWti~OswXuwX#gwX#jwX#mwX#qwX#uwX#vwX#wwX#xwX~OQyOs!tX|!tX~P4yO#u#iO#v#iO#w#jO#x#jOs!qXu!qX#g!qX#j!qX#m!qX#q!qX~O|$[O~P4yOs!UOu!ZO#m!VO#q!WO#gri#jri~Os!RO|$[O~OP#aOs!UOu!ZO#m!VO#q!WO~O#n#cO#o$dO~O#r#fO#s$fO~On#nOs!UOu!ZO#m!VO#q!WO~Ob#pOs$oO~O`#rOs$qO~OX{O~P$yO#k}O~P$yOd#{Os${O~Oe#}Os$}O~OT%OOX{O~OV$QO~P%jOW$SO~P%jOV$QOW$SO#g!Zi#j!Zi~Og$VO#g!gi#j!gi~Od#{Oj%VOs%XO~Os!ROu%[O~O|$[O#g{q#j{q~O#u#iO#v#iO#w#jO#x#jOs!wXu!wX#g!wX#j!wX#m!wX#q!wX~Os!UOu!ZO#m!VO#q!WO#g}q#j}q~O#u#iO#v#iO#w#jO#x#jOk#tis#tiu#ti#g#ti#j#ti#m#ti#q#tib#ti`#tiX#tid#tie#ti#k#ti#z#ti#{#ti#|#ti|#tiV#tiW#ti~O#u#iO#v#iO#w#jO#x#jO|#yX#g#yX#j#yXk#yXs#yXu#yX#m#yX#q#yXb#yX`#yXX#yXd#yXe#yX#k#yX#z#yX#{#yX#|#yXV#yXW#yX~O|%_O#g!RX#j!RXk!RXs!RXu!RX#m!RX#q!RXb!RX`!RXX!RXd!RXe!RX#k!RX#z!RX#{!RX#|!RXV!RXW!RX~O#u#iO#v#iO#w#jO#x#jOV!^iW!^i#g!^i#j!^i~O#u#iO#v#iO#w#jO#x#jOV!_iW!_i#g!_i#j!_i~O#u#iO#v#iO#w#jO#x#jOV!aiW!ai#g!ai#j!ai~OT%OOV!]iW!]i#g!]i#j!]i~Oj%VOs%gOu%gO~Os!RO|!ua#g!ua#j!ua~O|%_O#g!Ra#j!Rak!Ras!Rau!Ra#m!Ra#q!Rab!Ra`!RaX!Rad!Rae!Ra#k!Ra#z!Ra#{!Ra#|!RaV!RaW!Ra~O#u#iO#v#iO#w#jO#x#jOV!^qW!^q#g!^q#j!^q~O#u#iO#v#iO#w#jO#x#jOV!aqW!aq#g!aq#j!aq~Oi%jO~Oi%jOs%mOu%mO~Ous~",
        goto: "2j#zPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP#{$QP$VP%O%`&u'h'{$QP$Q$Q$Q(`)d$Q)j)j)j$Q$Q$Q$Q)o)v)v)v){)v*P*P)v)v$Q$Q$Q$Q$Q$Q*T*_*f*n*t+X+b+h+n,P,W,_,e,m,u-P-l-v-|.U.^.f.n.v.}/V/^/f/l/w0O0U0]0d0l0t0z1S1Y1`1hPPPPP1pPPP1pPPP&uPPPP2cVvOQwVuOQwUSOQwW!]Xt!^#QQ!c]Q!f_Q!iaQ!ldY#^|!O!P!Q#_S$a#b$bV$k#o$Y%_Q!ORQ!QSS#u!s!vQ$t#uR$y#zW!YXt!^#QQ!a]Q!d_Q!gaQ!jdQ!mfQ!phU!sj$R$TY#[|!O!P!Q#_S$_#b$bQ$g#kQ$h#lU$i#o$Y%_S$r#t#uQ$u#wQ$w#zQ%a$tR%c$y!a!ZX]_adfhjt|!O!P!Q!^#Q#_#b#k#l#o#t#u#w#z$R$T$Y$b$t$y%_s#k!Y!a!d!g!j!m!p!s#[$_$h$i$r$u$w%a%cs#l!Y!a!d!g!j!m!p!s#[$_$h$i$r$u$w%a%cUuOQwW!]Xt!^#QQ!c]Q!f_Q!iaQ!ldQ!ofQ!rhU!vj$R$TS$s#t#uQ$v#wQ$x#zQ%b$tR%d$yQ$m#oR%Y$YVbOQwQ!xjT%R$R$TV!wj$R$TT#w!s!vT#z!s!vQQOSxQ#SR#SvSwOQR#TwUzR!U#YR#UzQ#WzR$Z#WQ|RQ!PSW#Z|!P#t$PS#t!s!vR$P!tW#_|!O!P!QR$^#_Q#d!VR$c#dQ#g!WR$e#gUTOQwU!ST#`%ZS#`|!OR%Z$[S$]#]#`R%]$]S#b|!OR$`#bQ$b#bR%^$bUVOQwR!TVUXOQwR![XQ!^XQ#QtT#m!^#Q|ZOQX]_adfhjtw!^#Q#t#u#w#z$R$T$t$yR!_ZQ#o!`Q$Y#PT$j#o$YQ%`$lR%i%`U]OQwR!b]U_OQwR!e_UaOQwR!haUdOQwR!kdUfOQwR!nfS#q!m!oR$n#qUhOQwR!qhS#s!p!rR$p#sUjOQwR!ujQ%P$PR%e%PS#|!s!vQ$X!}T$z#|$XS$O!s!vR$|$OQ$U!xR%T$US$R!x$UR%Q$RS$T!x$UR%S$TUlOQwR!ylUnOQwR!znQ$W!{R%U$WUpOQwR!|pQ%W$XR%f%WQ%k%gR%l%kUrOQwR#OrUtOQwR#Rt!a!XX]_adfhjt|!O!P!Q!^#Q#_#b#k#l#o#t#u#w#z$R$T$Y$b$t$y%_S$l#o$YR%h%_",
        nodeNames: "\u26A0 ask at random if pressed else and or is print forward turn color sleep add from remove toList clear in not_in repeat times for to range call define return with Comment Program Command Assign Text ListAccess Number Op Expression String Op Op AssignList Comma Ask Clear Print Call Arguments Turtle Forward Turn Color Sleep Add Remove If Condition PressedCheck EqualityCheck NotEqualCheck Op ComparisonCheck Op Op InListCheck NotInListCheck Else Repeat For Define Return ErrorInvalid",
        maxTerm: 136,
        nodeProps: [
          ["group", 50, "turtle"]
        ],
        skippedNodes: [0, 31],
        repeatNodeCount: 41,
        tokenData: "1e~R!`OY%TYZ&XZp%Tpq&^qr&crs&nst&stw%Twx'[xz%Tz{'a{|'f|}'k}!O'p!O!P%T!P!Q'u!Q!R'z!R!S'z!S!T'z!T!U'z!U!V'z!V!W'z!W!X'z!X!Y'z!Y!Z'z!Z!['z![!^%T!^!_1U!_!`1Z!`!a1`!a#Q%T#RBn%TBnBo'kBoDf%TDfDg'zDgDh'zDhDi'zDiDj'zDjDk'zDkDl'zDlDm'zDmDn'zDnDo'zDoDp'zDpGl%TGlGm'zGmGn'zGnGo'zGoGp'zGpGq'zGqGr'zGrGs'zGsGt'zGtGu'zGuGv'zGv&FV%T&FV&FW'k&FW;'S%T;'S;=`&R<%l?Hb%T?Hb?Hc'k?HcO%T~%Y]s~OY%TZp%Ttw%Txz%T!O!P%T!Q!^%T!a#Q%T#RBn%TBo&FV%T&FW;'S%T;'S;=`&R<%l?Hb%T?HcO%T~&UP;=`<%l%T~&^O#j~~&cO#i~~&fP!_!`&i~&nO#z~~&sO#m~~&xSo~OY&sZ;'S&s;'S;=`'U<%lO&s~'XP;=`<%l&s~'aO#q~~'fO#u~~'kO#w~~'pO|~~'uO#x~~'zO#v~~(R}u~s~OY%TZp%Ttw%Txz%T!O!P+O!Q!R'z!R!S'z!S!T'z!T!U'z!U!V'z!V!W'z!W!X'z!X!Y'z!Y!Z'z!Z!['z![!^%T!a#Q%T#RBn%TBoDf%TDfDg'zDgDh'zDhDi'zDiDj'zDjDk'zDkDl'zDlDm'zDmDn'zDnDo'zDoDp'zDpGl%TGlGm'zGmGn'zGnGo'zGoGp'zGpGq'zGqGr'zGrGs'zGsGt'zGtGu'zGuGv'zGv&FV%T&FW;'S%T;'S;=`&R<%l?Hb%T?HcO%T~+T}s~OY%TZp%Ttw%Txz%T!O!P%T!Q!R.Q!R!S.Q!S!T.Q!T!U.Q!U!V.Q!V!W.Q!W!X.Q!X!Y.Q!Y!Z.Q!Z![.Q![!^%T!a#Q%T#RBn%TBoDf%TDfDg.QDgDh.QDhDi.QDiDj.QDjDk.QDkDl.QDlDm.QDmDn.QDnDo.QDoDp.QDpGl%TGlGm.QGmGn.QGnGo.QGoGp.QGpGq.QGqGr.QGrGs.QGsGt.QGtGu.QGuGv.QGv&FV%T&FW;'S%T;'S;=`&R<%l?Hb%T?HcO%T~.X}u~s~OY%TZp%Ttw%Txz%T!O!P%T!Q!R.Q!R!S.Q!S!T.Q!T!U.Q!U!V.Q!V!W.Q!W!X.Q!X!Y.Q!Y!Z.Q!Z![.Q![!^%T!a#Q%T#RBn%TBoDf%TDfDg.QDgDh.QDhDi.QDiDj.QDjDk.QDkDl.QDlDm.QDmDn.QDnDo.QDoDp.QDpGl%TGlGm.QGmGn.QGnGo.QGoGp.QGpGq.QGqGr.QGrGs.QGsGt.QGtGu.QGuGv.QGv&FV%T&FW;'S%T;'S;=`&R<%l?Hb%T?HcO%T~1ZO#|~~1`O#k~~1eO#{~",
        tokenizers: [2, new lr_1.LocalTokenGroup("_~RQYZXwxX~^O#s~~", 14, 126), new lr_1.LocalTokenGroup("_~RQYZXrsX~^O#o~~", 14, 122)],
        topRules: { "Program": [0, 32] },
        dynamicPrecedences: { "73": -10 },
        specialized: [{ term: 35, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }, { term: 35, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 1700
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level15-parser.js
  var require_level15_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level15-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "=jQYQPOOOOQO'#Dz'#DzQYQPOOO!dQPO'#ESO!xQPO'#DPO#QQPO'#DyOOQO'#EW'#EWO#]QPO'#D]OOQO'#EX'#EXO#yQPO'#D^OOQO'#EZ'#EZO$QQPO'#D_OOQO'#E^'#E^O$YQPO'#DbOOQO'#E_'#E_O$aQPO'#DcOOQO'#E`'#E`O$hQPO'#DdOOQO'#Da'#DaOOQO'#Ea'#EaO$oQPO'#DeOOQO'#Eb'#EbO%_QPO'#DfOOQO'#Ed'#EdO%fQPO'#DgOOQO'#Ef'#EfO&OQPO'#DhOOQO'#Em'#EmO&VQPO'#DsOOQO'#En'#EnO&bQPO'#DtOOQO'#Ep'#EpO&mQPO'#DuOOQO'#Es'#EsO&uQPO'#DvOOQO'#Et'#EtO&}QPO'#DwOOQO'#Eu'#EuO'UQPO'#DxOOQO'#DO'#DOQ!_QPO'#D{Q']QPOOOOQO-E7x-E7xOOQO'#D|'#D|O(dQPO,59mOOQO'#EO'#EOO)TQPO,59kOOQO'#DT'#DTO(rQPO,59kO)[QPO,59kO#kQPO,59kOOQO'#ES'#ESOOQO-E8Q-E8QOOQO-E8U-E8UO*bQPO'#DUO+_OSO'#E{O+gOQO'#FPOOQO'#DV'#DVO+oQPO'#EYOOQO'#DU'#DUOOQO-E8V-E8VOOQO'#EY'#EYO,dQPO,59xOOQO-E8X-E8XO,nQPO,59yO-{QPO,59|OOQO-E8[-E8[OOQO,59|,59|O.aQPO,59}OOQO-E8]-E8]OOQO,59},59}O.uQPO,5:OOOQO-E8^-E8^OOQO,5:O,5:OO/ZQPO,5:POOQO-E8_-E8_OOQO,5:P,5:PO/oQPO,5:QOOQO-E8`-E8`O0QQPO,5:QO0VQPO,5:ROOQO-E8b-E8bO0hQPO,5:RO1UQPO'#DkO1fQPO'#DUOOQO-E8d-E8dO0mQPO'#DkOOQO'#Di'#DiO1mQPO,5:SOOQO-E8k-E8kOOQO-E8l-E8lO1{QPO,5:`OOQO-E8n-E8nO2QQPO,5:aOOQO-E8q-E8qO2VQPO,5:bO2bQPO,5:cOOQO-E8r-E8rOOQO-E8s-E8sO2lQPO,5:dO2zQPO,5:gOOQO-E7y-E7yOOQO-E7z-E7zOOQO'#D}'#D}O4XQPO1G/XOOQO1G/X1G/XO6ZQPO'#DUOOQO-E7|-E7|O6hQPO'#EPO7YQPO1G/`OOQO'#EP'#EPO7aQPO1G/VO7uQPO1G/`OOQO'#EU'#EUO7}QPO1G/bOOOO'#EQ'#EQO8`OSO,5;gOOQO,5;g,5;gOOOO'#ER'#ERO8hOQO,5;kOOQO,5;k,5;kOOQO'#DW'#DWOOQO'#DX'#DXO%PQPO,5;oO%PQPO,5;oOOQO-E8W-E8WOOQO'#E['#E[O8pQPO1G/eOOQO'#Ec'#EcO9RQPO1G/lOOQO'#Ee'#EeO9ZQPO1G/mO9cQPO,5:VO9jQPO,5:VOOQO'#Dm'#DmO$|QPO,5:WOOQO'#Do'#DoOOQO'#Dp'#DpO9jQPO,5:YOOQO'#Eh'#EhO9qQPO,5:]OOQO'#Ei'#EiO9yQPO,5:^O:RQPO,5:UOOQO'#Ek'#EkO:ZQPO'#EjOOQO'#El'#ElO:bQPO'#EjO:iQPO1G/nOOQO'#Eo'#EoO:wQPO1G/zO;SQPO1G/{O8pQPO1G/|O;_QPO1G0OOOQO-E7{-E7{O;mQPO'#ETO;uQPO7+$zOOQO-E7}-E7}O<QQPO'#EVOOQO-E8S-E8SOOQO'#EV'#EVO<rQPO7+$|OOOO-E8O-E8OOOQO1G1R1G1ROOOO-E8P-E8POOQO1G1V1G1VOOQO1G1Z1G1ZO=WQPO1G1ZO>qQPO'#FYOOQO-E8Y-E8YOOQO'#FY'#FYO@[QPO'#D`OOQO7+%P7+%POOQO-E8a-E8aOOQO7+%W7+%WOOQO-E8c-E8cOOQO7+%X7+%XOAiQPO1G/qOOQO1G/q1G/qO$|QPO1G/qOBTQPO1G/rOOQO1G/r1G/rOBoQPO1G/tOOQO1G/t1G/tO$|QPO1G/tOOQO-E8f-E8fOOQO1G/w1G/wOOQO-E8g-E8gOOQO1G/x1G/xOOQO'#Eg'#EgOCZQPO1G/pOOQO-E8i-E8iOOQO,5;U,5;UOOQO-E8j-E8jOOQO-E8h-E8hOOQO-E8m-E8mOOQO'#Eq'#EqOClQPO7+%gOOQO7+%g7+%gOOQO7+%h7+%hOCwQPO,5:oOOQO,5:o,5:oOOQO-E8R-E8ROOQO-E8T-E8TO#kQPO'#E]ODVQPO,59zOEdQPO7+%]OOQO7+%]7+%]OFOQPO7+%`OOQO7+%`7+%`OOQO-E8e-E8eOOQO-E8o-E8oOFjQPO<<IROOQO,5:w,5:wOOQO-E8Z-E8ZOOQO'#Er'#ErOFoQPOAN>mOOQO-E8p-E8pOOQOG24XG24X",
        stateData: "F}~OpOS#lOS~OSiOUkOYuOZWO[[O]^O^`O_cO`eObgOdUOgmOioOlYOmqOnsOtRO#mPO~OQ{OX}O#n!POt!vX#j!vX#m!vX~OX}O#n!PO~Ot!TO#j!mX#m!mX~OdUO#j!PX#m!PX~OlYOt!WOv!]O#p!XO#t!YO~OZWO~P#hOlYOt!bO~O[[O~P#hO]^O~P#hO^`O~P#hO_cO#j!XX#m!XX~P#hOlYOt!]Ov!]O#p!XO#t!YO~O`eO~P$|ObgO~P$|OlYOt!vOv!]O#p!XO#t!YO~OSiO~P%mOUkO#j!gX#m!gX~OgmOt!}Ov!}O~OioOt#PO~OmqOt#RO~OnsO~P#hOYuO~P%mOSiOUkOYuOZWO[[O]^O^`O_cO`eObgOdUOgmOioOlYOmqOnsOtRO~OQ{OR#ZOt#]Ov#]O~OP#eOt#^Ov#aO#p!XO#t!YO~OX}O~P(rOX}Ot!WOv!]O#p!XO#t!YO~O#xxX#yxX#zxX#{xXXxXexXfxX#nxX#}xX$OxX$PxX~OQ{OlxXtxXvxX#jxX#mxX#pxX#txX}xXcxXaxXVxXWxX~P)mO#q#gO#r#iO~O#u#jO#v#lO~O#x#mO#y#mO#z#nO#{#nOl!|Xt!|Xv!|X#j!|X#m!|X#p!|X#t!|X~O#j!Qa#m!Qa~P#hOo#rO#j!Ra#m!Ral!Rat!Rav!Ra#p!Ra#t!Rac!Raa!RaX!Rae!Raf!Ra#n!Ra#}!Ra$O!Ra$P!RaV!RaW!Ra~O#x#mO#y#mO#z#nO#{#nO#j!Ua#m!Ua~O#x#mO#y#mO#z#nO#{#nO#j!Va#m!Va~O#x#mO#y#mO#z#nO#{#nO#j!Wa#m!Wa~O#x#mO#y#mO#z#nO#{#nO#j!Xa#m!Xa~Oc#tO#x#mO#y#mO#z#nO#{#nO~Oc#tO~Oa#vO#x#mO#y#mO#z#nO#{#nO~Oa#vO~OX}Oe$POf$RO#n!PO#}#zO$O#|O$P#}O~O#x#mO#y#mO#z#nO#{#nO~P0mOX}O~P)mOV$UOW$WO#j![a#m![a~Oh$ZO~Oe$PO~Oo#rO#j!ja#m!ja~O#j!ka#m!ka~P#hOV$UOW$WO#j!la#m!la~O#mPOS!oaU!oaY!oaZ!oa[!oa]!oa^!oa_!oa`!oab!oad!oag!oai!oal!oam!oan!oat!oa#j!oa~OR#ZOXui#nuiluituivui#jui#mui#pui#tui}uicuiauieuifui#}ui$Oui$PuiVuiWui~OtxXvxX#jxX#mxX#pxX#txX#xxX#yxX#zxX#{xX~OQ{Ot!vX}!vX~P5iO#x#mO#y#mO#z#nO#{#nOt!sXv!sX#j!sX#m!sX#p!sX#t!sX~O}$aO~P5iOt!WOv!]O#p!XO#t!YO#jsi#msi~Ot!TO}$aO~OP#eOt!WOv!]O#p!XO#t!YO~O#q#gO#r$iO~O#u#jO#v$kO~Oo#rOt!WOv!]O#p!XO#t!YO~Oc#tOt$tO~Oa#vOt$vO~OX}O~P$|O#n!PO~P$|Oe$POt%QO~Of$ROt%SO~OT%TOX}O~OV$UO~P%mOW$WO~P%mOV$UOW$WO#j![i#m![i~Oh$ZO#j!hi#m!hi~Oe$POk%[Ot%^O~OV$UOW$WO#j!li#m!li~Ot!TOv%aO~O}$aO#j|q#m|q~O#x#mO#y#mO#z#nO#{#nOt!yXv!yX#j!yX#m!yX#p!yX#t!yX~Ot!WOv!]O#p!XO#t!YO#j!Oq#m!Oq~O#x#mO#y#mO#z#nO#{#nOl#wit#wiv#wi#j#wi#m#wi#p#wi#t#wic#wia#wiX#wie#wif#wi#n#wi#}#wi$O#wi$P#wi}#wiV#wiW#wi~O#x#mO#y#mO#z#nO#{#nO}#|X#j#|X#m#|Xl#|Xt#|Xv#|X#p#|X#t#|Xc#|Xa#|XX#|Xe#|Xf#|X#n#|X#}#|X$O#|X$P#|XV#|XW#|X~O}%dO#j!SX#m!SXl!SXt!SXv!SX#p!SX#t!SXc!SXa!SXX!SXe!SXf!SX#n!SX#}!SX$O!SX$P!SXV!SXW!SX~O#x#mO#y#mO#z#nO#{#nOV!_iW!_i#j!_i#m!_i~O#x#mO#y#mO#z#nO#{#nOV!`iW!`i#j!`i#m!`i~O#x#mO#y#mO#z#nO#{#nOV!biW!bi#j!bi#m!bi~OT%TOV!^iW!^i#j!^i#m!^i~Ok%[Ot%lOv%lO~Ot!TO}!wa#j!wa#m!wa~O}%dO#j!Sa#m!Sal!Sat!Sav!Sa#p!Sa#t!Sac!Saa!SaX!Sae!Saf!Sa#n!Sa#}!Sa$O!Sa$P!SaV!SaW!Sa~O#x#mO#y#mO#z#nO#{#nOV!_qW!_q#j!_q#m!_q~O#x#mO#y#mO#z#nO#{#nOV!bqW!bq#j!bq#m!bq~Oj%oO~Oj%oOt%rOv%rO~Ovt~",
        goto: "3W#}PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP$O$TP$YP%R%c&y'm(Q$TP$T$T$T(e)j$T)p)p)p$T$T$T$T)u*P*P*P*V*P*Z*Z*P*P$T$T$T$T$T$T$T*_*i*p*x+O+c+l+r+x,Z,b,i,o,w-P-Z-w.R.X.a.i.q.y/R/Y/b/i/q/w0S0Z0e0n0w1P1X1_1g1m1s1{2TPPPPP2]PPP2]PPP&yPPPP3PVxOQyVwOQyUSOQyW!_Xt!`#SQ!e]Q!h_Q!kaQ!ndY#b!O!Q!R!S#cS$f#f$gV$p#s$^%dQ!QRQ!SSS#y!u!xQ$y#yR%O$OW![Xt!`#SQ!c]Q!f_Q!iaQ!ldQ!ofQ!rhW!ujv$V$XY#`!O!Q!R!S#cS$d#f$gQ$l#oQ$m#pU$n#s$^%dS$w#x#yQ$z#{Q$|$OQ%f$yR%h%O!c!]X]_adfhjtv!O!Q!R!S!`#S#c#f#o#p#s#x#y#{$O$V$X$^$g$y%O%ds#o![!c!f!i!l!o!r!u#`$d$m$n$w$z$|%f%hs#p![!c!f!i!l!o!r!u#`$d$m$n$w$z$|%f%hUwOQyW!_Xt!`#SQ!e]Q!h_Q!kaQ!ndQ!qfQ!thW!xjv$V$XS$x#x#yQ${#{Q$}$OQ%g$yR%i%OQ$r#sR%_$^VbOQyQ!zjQ#VvT%W$V$XX!yjv$V$XT#{!u!xT$O!u!xQQOSzQ#WR#WxSyOQR#XyU|R!W#^R#Y|Q#[|R$`#[Q!ORQ!RSW#_!O!R#x$TS#x!u!xR$T!vW#c!O!Q!R!SR$c#cQ#h!XR$h#hQ#k!YR$j#kUTOQyU!UT#d%`S#d!O!QR%`$aS$b#a#dR%b$bS#f!O!QR$e#fQ$g#fR%c$gUVOQyR!VVUXOQyR!^XQ!`XQ#StT#q!`#S!OZOQX]_adfhjtvy!`#S#x#y#{$O$V$X$y%OR!aZQ#s!bQ$^#RT$o#s$^Q%e$qR%n%eU]OQyR!d]U_OQyR!g_UaOQyR!jaUdOQyR!mdUfOQyR!pfS#u!o!qR$s#uUhOQyR!shS#w!r!tR$u#wUjOQyR!wjQ%U$TR%j%US$Q!u!xQ$]#PT%P$Q$]S$S!u!xR%R$SQ$Y!zQ$_#VT%Y$Y$_W$V!z#V$Y$_R%V$VW$X!z#V$Y$_R%X$XUlOQyR!{lUnOQyR!|nQ$[!}R%Z$[UpOQyR#OpQ%]$]R%k%]Q%p%lR%q%pUrOQyR#QrUtOQyR#TtUvOQyR#Uv!c!ZX]_adfhjtv!O!Q!R!S!`#S#c#f#o#p#s#x#y#{$O$V$X$^$g$y%O%dS$q#s$^R%m%d",
        nodeNames: "\u26A0 ask at random if pressed else and or is while print forward turn color sleep add from remove toList clear in not_in repeat times for to range call define return with Comment Program Command Assign Text ListAccess Number Op Expression String Op Op AssignList Comma Ask Clear Print Call Arguments Turtle Forward Turn Color Sleep Add Remove If Condition PressedCheck EqualityCheck NotEqualCheck Op ComparisonCheck Op Op InListCheck NotInListCheck Else Repeat For Define Return While ErrorInvalid",
        maxTerm: 139,
        nodeProps: [
          ["group", 51, "turtle"]
        ],
        skippedNodes: [0, 32],
        repeatNodeCount: 42,
        tokenData: "1e~R!`OY%TYZ&XZp%Tpq&^qr&crs&nst&stw%Twx'[xz%Tz{'a{|'f|}'k}!O'p!O!P%T!P!Q'u!Q!R'z!R!S'z!S!T'z!T!U'z!U!V'z!V!W'z!W!X'z!X!Y'z!Y!Z'z!Z!['z![!^%T!^!_1U!_!`1Z!`!a1`!a#Q%T#RBn%TBnBo'kBoDf%TDfDg'zDgDh'zDhDi'zDiDj'zDjDk'zDkDl'zDlDm'zDmDn'zDnDo'zDoDp'zDpGl%TGlGm'zGmGn'zGnGo'zGoGp'zGpGq'zGqGr'zGrGs'zGsGt'zGtGu'zGuGv'zGv&FV%T&FV&FW'k&FW;'S%T;'S;=`&R<%l?Hb%T?Hb?Hc'k?HcO%T~%Y]t~OY%TZp%Ttw%Txz%T!O!P%T!Q!^%T!a#Q%T#RBn%TBo&FV%T&FW;'S%T;'S;=`&R<%l?Hb%T?HcO%T~&UP;=`<%l%T~&^O#m~~&cO#l~~&fP!_!`&i~&nO#}~~&sO#p~~&xSp~OY&sZ;'S&s;'S;=`'U<%lO&s~'XP;=`<%l&s~'aO#t~~'fO#x~~'kO#z~~'pO}~~'uO#{~~'zO#y~~(R}v~t~OY%TZp%Ttw%Txz%T!O!P+O!Q!R'z!R!S'z!S!T'z!T!U'z!U!V'z!V!W'z!W!X'z!X!Y'z!Y!Z'z!Z!['z![!^%T!a#Q%T#RBn%TBoDf%TDfDg'zDgDh'zDhDi'zDiDj'zDjDk'zDkDl'zDlDm'zDmDn'zDnDo'zDoDp'zDpGl%TGlGm'zGmGn'zGnGo'zGoGp'zGpGq'zGqGr'zGrGs'zGsGt'zGtGu'zGuGv'zGv&FV%T&FW;'S%T;'S;=`&R<%l?Hb%T?HcO%T~+T}t~OY%TZp%Ttw%Txz%T!O!P%T!Q!R.Q!R!S.Q!S!T.Q!T!U.Q!U!V.Q!V!W.Q!W!X.Q!X!Y.Q!Y!Z.Q!Z![.Q![!^%T!a#Q%T#RBn%TBoDf%TDfDg.QDgDh.QDhDi.QDiDj.QDjDk.QDkDl.QDlDm.QDmDn.QDnDo.QDoDp.QDpGl%TGlGm.QGmGn.QGnGo.QGoGp.QGpGq.QGqGr.QGrGs.QGsGt.QGtGu.QGuGv.QGv&FV%T&FW;'S%T;'S;=`&R<%l?Hb%T?HcO%T~.X}v~t~OY%TZp%Ttw%Txz%T!O!P%T!Q!R.Q!R!S.Q!S!T.Q!T!U.Q!U!V.Q!V!W.Q!W!X.Q!X!Y.Q!Y!Z.Q!Z![.Q![!^%T!a#Q%T#RBn%TBoDf%TDfDg.QDgDh.QDhDi.QDiDj.QDjDk.QDkDl.QDlDm.QDmDn.QDnDo.QDoDp.QDpGl%TGlGm.QGmGn.QGnGo.QGoGp.QGpGq.QGqGr.QGrGs.QGsGt.QGtGu.QGuGv.QGv&FV%T&FW;'S%T;'S;=`&R<%l?Hb%T?HcO%T~1ZO$P~~1`O#n~~1eO$O~",
        tokenizers: [2, new lr_1.LocalTokenGroup("_~RQYZXwxX~^O#v~~", 14, 129), new lr_1.LocalTokenGroup("_~RQYZXrsX~^O#r~~", 14, 125)],
        topRules: { "Program": [0, 33] },
        dynamicPrecedences: { "75": -10 },
        specialized: [{ term: 36, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }, { term: 36, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 1744
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level16-parser.js
  var require_level16_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level16-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "=QQYQPOOOOQO'#D{'#D{QYQPOOO!dQPO'#EuO!xQPO'#DOOOQO'#EV'#EVO#QQPO'#D^OOQO'#EW'#EWO#nQPO'#D_OOQO'#EY'#EYO#uQPO'#D`OOQO'#E]'#E]O#}QPO'#DcOOQO'#E^'#E^O$UQPO'#DdOOQO'#E_'#E_O$]QPO'#DeOOQO'#Db'#DbOOQO'#E`'#E`O$dQPO'#DfOOQO'#Ea'#EaO$qQPO'#DgOOQO'#Ec'#EcO$xQPO'#DhOOQO'#Ee'#EeO%bQPO'#DiOOQO'#El'#ElO%iQPO'#DtOOQO'#Em'#EmO%tQPO'#DuOOQO'#Eo'#EoO&PQPO'#DvOOQO'#Er'#ErO&XQPO'#DwOOQO'#Es'#EsO&aQPO'#DxOOQO'#Et'#EtO&hQPO'#DyO&oQPO'#DzOOQO'#C}'#C}Q!_QPO'#D|Q&zQPOOOOQO-E7y-E7yOOQO'#DR'#DRO(RQPO,59lOOQO'#EO'#EOO(rQPO,59jOOQO'#DU'#DUO(^QPO,59jO(yQPO,59jO#`QPO,59jOOQO-E8T-E8TO*SQPO'#DVO*|OSO'#E}O+UOQO'#FROOQO'#DW'#DWO+^QPO'#EXOOQO'#DV'#DVOOQO-E8U-E8UOOQO'#EX'#EXO,RQPO,59yOOQO-E8W-E8WO,]QPO,59zO-jQPO,59}OOQO-E8Z-E8ZOOQO,59},59}O.OQPO,5:OOOQO-E8[-E8[OOQO,5:O,5:OO.dQPO,5:POOQO-E8]-E8]OOQO,5:P,5:PO.xQPO,5:QOOQO-E8^-E8^OOQO,5:Q,5:QO/^QPO,5:ROOQO-E8_-E8_O/oQPO,5:RO/tQPO,5:SOOQO-E8a-E8aO0VQPO,5:SO0[QPO'#DVO0zQPO'#DlOOQO-E8c-E8cO0cQPO'#DlOOQO'#Dj'#DjO1[QPO,5:TOOQO-E8j-E8jOOQO-E8k-E8kO1jQPO,5:aOOQO-E8m-E8mO1oQPO,5:bOOQO-E8p-E8pO1tQPO,5:cO2PQPO,5:dOOQO-E8q-E8qOOQO-E8r-E8rO2ZQPO,5:eOOQO'#Eu'#EuOOQO-E8s-E8sO2iQPO,5:hOOQO-E7z-E7zOOQO'#D}'#D}O3vQPO1G/WO3yQPO1G/WOOQO-E7|-E7|O4OQPO'#EPO4pQPO1G/UO5UQPO1G/aOOQO'#ET'#ETO5aQPO1G/cOOOO'#EQ'#EQO5rOSO,5;iOOQO,5;i,5;iOOOO'#ER'#ERO5zOQO,5;mOOQO,5;m,5;mOOQO'#DX'#DXOOQO'#DY'#DYO#`QPO,5;qO#`QPO,5;qOOQO-E8V-E8VOOQO'#EZ'#EZO6SQPO1G/fOOQO'#Eb'#EbO6eQPO1G/mOOQO'#Ed'#EdO6mQPO1G/nO6uQPO,5:VO6}QPO,5:WO7UQPO,5:WOOQO'#Dn'#DnO#]QPO,5:XOOQO'#Dp'#DpOOQO'#Dq'#DqO7UQPO,5:ZOOQO'#Eg'#EgO7]QPO,5:^OOQO'#Eh'#EhO7eQPO,5:_OOQO'#Ej'#EjO7mQPO'#EiOOQO'#Ek'#EkO7tQPO'#EiO7{QPO1G/oOOQO'#En'#EnO8ZQPO1G/{O8fQPO1G/|O6SQPO1G/}O8qQPO1G0POOQO-E7{-E7{OOQO'#DT'#DTOOQO7+$r7+$rOOQO-E7}-E7}O9PQPO7+${O9UQPO'#EUOOQO-E8R-E8RO9vQPO7+$}OOOO-E8O-E8OOOQO1G1T1G1TOOOO-E8P-E8POOQO1G1X1G1XOOQO1G1]1G1]O:[QPO1G1]O;uQPO'#DaOOQO-E8X-E8XOOQO7+%Q7+%QOOQO-E8`-E8`OOQO7+%X7+%XOOQO-E8b-E8bOOQO7+%Y7+%YOOQO'#Ef'#EfO=`QPO1G/qO=qQPO1G/rOOQO1G/r1G/rO#]QPO1G/rO>]QPO1G/sOOQO1G/s1G/sO>wQPO1G/uOOQO1G/u1G/uO#]QPO1G/uOOQO-E8e-E8eOOQO1G/x1G/xOOQO-E8f-E8fOOQO1G/y1G/yOOQO-E8h-E8hOOQO,5;T,5;TOOQO-E8i-E8iOOQO-E8g-E8gOOQO-E8l-E8lOOQO'#Ep'#EpO?cQPO7+%hOOQO7+%h7+%hOOQO7+%i7+%iO?nQPO'#ESO?yQPO<<HgOOQO-E8S-E8SO@RQPO,59{O#`QPO'#E[OOQO-E8d-E8dOA`QPO7+%^OOQO7+%^7+%^OAzQPO7+%aOOQO7+%a7+%aOOQO-E8n-E8nOBfQPO<<ISOOQO,5:n,5:nOOQO-E8Q-E8QOOQOAN>RAN>ROOQO-E8Y-E8YOBkQPO,5:vOOQO'#Eq'#EqODUQPOAN>nOOQO-E8o-E8oOOQOG24YG24Y",
        stateData: "Dd~OoOS#lOS~ORhOTjOXtOYVOZZO[]O]_O^bO_dOafOcTOflOhnOkXOlpOmrOsRO#mPO~OW}O#n{O#p!POs#iX#j#iX#m#iX~OW}O#p!PO~OcTO#j!QX#m!QX~OkXOs!UOv!ZO#r!VO#v!WO~OYVO~P#]OkXOs!`O~OZZO~P#]O[]O~P#]O]_O~P#]O^bO#j!YX#m!YX~P#]O_dO~P#]OafO~P#]OkXOs!sOv!ZO#r!VO#v!WO~ORhO~P%POTjO#j!hX#m!hX~OflOs!{Ov!{O~OhnOs!}O~OlpOs#PO~OmrO~P#]OXtO~P%POs#UO#j!nX#m!nX~ORhOTjOXtOYVOZZO[]O]_O^bO_dOafOcTOflOhnOkXOlpOmrOsRO~OQ#YOs#[Ov#[O~OP#aOs!UOv!ZO#n{O#r!VO#v!WO~OW}O~P(^OW}Os!UOv!ZO#r!VO#v!WO~O#n{O#zyX#{yX#|yX#}yXWyXdyXeyX#pyX$OyX$PyX$QyX~OkyXsyXvyX#jyX#myX#ryX#vyXbyX`yX!OyXUyXVyX~P)[O#s#cO#t#eO~O#w#fO#x#hO~O#z#iO#{#iO#|#jO#}#jOk!{Xs!{Xv!{X#j!{X#m!{X#r!{X#v!{X~O#j!Ra#m!Ra~P#]On#nO#j!Sa#m!Sak!Sas!Sav!Sa#r!Sa#v!Sab!Sa`!SaW!Sad!Sae!Sa#p!Sa$O!Sa$P!Sa$Q!SaU!SaV!Sa~O#z#iO#{#iO#|#jO#}#jO#j!Va#m!Va~O#z#iO#{#iO#|#jO#}#jO#j!Wa#m!Wa~O#z#iO#{#iO#|#jO#}#jO#j!Xa#m!Xa~O#z#iO#{#iO#|#jO#}#jO#j!Ya#m!Ya~Ob#pO#z#iO#{#iO#|#jO#}#jO~Ob#pO~O`#rO#z#iO#{#iO#|#jO#}#jO~O`#rO~OW}O~P)[OW}Od#|Oe$OO#p!PO$O#wO$P#yO$Q#zO~O#z#iO#{#iO#|#jO#}#jO~P0cOU$QOV$SO#j!]a#m!]a~Og$VO~Od#|O~On#nO#j!ka#m!ka~O#j!la#m!la~P#]OU$QOV$SO#j!ma#m!ma~O#mPOR!paT!paX!paY!paZ!pa[!pa]!pa^!pa_!paa!pac!paf!pah!pak!pal!pam!pas!pa#j!pa~OQ#YO#o$]O~O#z#iO#{#iO#|#jO#}#jOs!sXv!sX#j!sX#m!sX#r!sX#v!sX~Os!UOv!ZO#r!VO#v!WO#jri#mri~Ov$`O#r!VO#v!WO~OP#aOs!UOv!ZO#r!VO#v!WO~O#s#cO#t$eO~O#w#fO#x$gO~On#nOs!UOv!ZO#r!VO#v!WO~Ob#pOs$nO~O`#rOs$pO~OS$qOW}O~OW}O~P#]O#p!PO~P#]Od#|Os$|O~Oe$OOs%OO~OU$QO~P%POV$SO~P%POU$QOV$SO#j!]i#m!]i~Og$VO#j!ii#m!ii~Od#|Oj%UOs%WO~OU$QOV$SO#j!mi#m!mi~O!O%YO~O#z#iO#{#iO#|#jO#}#jOs!xXv!xX#j!xX#m!xX#r!xX#v!xX~Os!UOv!ZO#r!VO#v!WO#j!Pq#m!Pq~O#z#iO#{#iO#|#jO#}#jOk#yis#yiv#yi#j#yi#m#yi#r#yi#v#yib#yi`#yiW#yid#yie#yi#p#yi$O#yi$P#yi$Q#yi!O#yiU#yiV#yi~O!O%^O#z#iO#{#iO#|#jO#}#jO#j!TX#m!TXk!TXs!TXv!TX#r!TX#v!TXb!TX`!TXW!TXd!TXe!TX#p!TX$O!TX$P!TX$Q!TXU!TXV!TX~OS$qOU!_iV!_i#j!_i#m!_i~O#z#iO#{#iO#|#jO#}#jOU!`iV!`i#j!`i#m!`i~O#z#iO#{#iO#|#jO#}#jOU!aiV!ai#j!ai#m!ai~O#z#iO#{#iO#|#jO#}#jOU!ciV!ci#j!ci#m!ci~Oj%UOs%eOv%eO~Ov%fO#r!VO#v!WO~O!O%YO#o$]O~O!O%^O#j!Ta#m!Tak!Tas!Tav!Ta#r!Ta#v!Tab!Ta`!TaW!Tad!Tae!Ta#p!Ta$O!Ta$P!Ta$Q!TaU!TaV!Ta~O#z#iO#{#iO#|#jO#}#jOU!`qV!`q#j!`q#m!`q~O#z#iO#{#iO#|#jO#}#jOU!cqV!cq#j!cq#m!cq~Oi%kO~O#z#iO#{#iO#|#jO#}#jO!O#Oa#j#Oa#m#Oak#Oas#Oav#Oa#r#Oa#v#Oab#Oa`#OaW#Oad#Oae#Oa#p#Oa$O#Oa$P#Oa$Q#OaU#OaV#Oa~Oi%kOs%nOv%nO~Ovs~",
        goto: "3W#zPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP#{$QP$V%OP%X%`%p'Y(S(h$QP$Q$Q$Q(|*R$Q*X*X*X$Q$Q$Q$Q*^*h*h*h*n*h*r*r*h*h$Q$Q$Q$Q$Q$Q$Q*v+Q+X+_+r+{,R,X,_,f,l,t,|-W-t.O.U.^.f.n.v/O/V/_/f/n/t0P0W0b0k0t0|1U1[1d1j1p1x2Q2YPPPPPPP2bPPP2bPPP$[VxOQyVwOQyUSOQy!c!ZW[^`cegisu!O!Q!R!S!^#Q#_#b#k#l#o#u#v#x#{$R$T$Y$c$u$z%^U|R!U!sT#`!O!QS$^#Z#[R%h%ZQ!QRQ!SSS#v!t!vQ$u#vR$z#{W!YWs!^#QQ!a[Q!d^Q!g`Q!jcQ!meQ!pgW!tiu$R$TY#^!O!Q!R!S#_S$a#b$cQ$h#kQ$i#lS$j#o$YS$s#u#vQ$v#xQ$x#{Q%`$uQ%b$zR%j%^!b!ZW[^`cegisu!O!Q!R!S!^#Q#_#b#k#l#o#u#v#x#{$R$T$Y$c$u$z%^Q$`#`R%f%Yu#k!Y!a!d!g!j!m!p!t#^$a$i$j$s$v$x%`%b%ju#l!Y!a!d!g!j!m!p!t#^$a$i$j$s$v$x%`%b%jUwOQyW!]Ws!^#QQ!c[Q!f^Q!i`Q!lcQ!oeQ!rgW!viu$R$TS$t#u#vQ$w#xQ$y#{Q%a$uR%c$zQ$l#oR%X$YVaOQyQ!xiQ#TuT%Q$R$TX!wiu$R$TT#x!t!vT#{!t!vQQOSzQ#WR#WxSyOQR#XyQ#Z|R$[#ZQ!ORQ!RSW#]!O!R#t#uQ#t!sT#u!t!vW#_!O!Q!R!SR$_#_Q#d!VR$d#dQ#g!WR$f#gQ%Z$`R%g%ZS#b!O!QR$b#bQ$c#bR%[$cUUOQyR!TUUWOQyR![WQ!^WQ#QsT#m!^#Q!OYOQW[^`cegisuy!^#Q#u#v#x#{$R$T$u$zR!_YQ#o!`Q$Y#PT$k#o$YQ%]$jR%i%]U[OQyR!b[U^OQyR!e^U`OQyR!h`UcOQyR!kcUeOQyR!neS#q!m!oR$m#qUgOQyR!qgS#s!p!rR$o#sUiOQyR!uiQ$r#tR%_$rS#}!t!vQ$X!}T${#}$XS$P!t!vR$}$PQ$U!xQ$Z#TT%S$U$ZW$R!x#T$U$ZR%P$RW$T!x#T$U$ZR%R$TUkOQyR!ykUmOQyR!zmQ$W!{R%T$WUoOQyR!|oQ%V$XR%d%VQ%l%eR%m%lUqOQyR#OqUsOQyR#RsUuOQyR#SuUvOQyR#Vv!g!XW[^`cegisu!O!Q!R!S!^#Q#_#`#b#k#l#o#u#v#x#{$R$T$Y$c$u$z%Y%^",
        nodeNames: "\u26A0 ask random if pressed else and or is while print forward turn color sleep add from remove toList clear in not_in repeat times for to range call define return with Comment Program Command Assign Text ListAccess Op Number Op Op Expression String Op Op AssignList Comma Ask Clear Print Call Arguments Turtle Forward Turn Color Sleep Add Remove If Condition PressedCheck EqualityCheck NotEqualCheck Op ComparisonCheck Op Op InListCheck NotInListCheck Else Repeat For Define Return While ErrorInvalid",
        maxTerm: 140,
        nodeProps: [
          ["group", 52, "turtle"]
        ],
        skippedNodes: [0, 31],
        repeatNodeCount: 41,
        tokenData: "2U~R!cOY%^YZ&eZp%^pq&jqr&ors&zst'Ptw%^wx'hxz%^z{'m{|'r|}'w}!O'|!O!P%^!P!Q(R!Q!R(W!R!S(W!S!T(W!T!U(W!U!V(W!V!W(W!W!X(W!X!Y(W!Y!Z(W!Z![(W![!^%^!^!_1k!_!`1p!`!a1u!a!}%^!}#O1z#O#P%^#P#Q2P#QBn%^BnBo'wBoDf%^DfDg(WDgDh(WDhDi(WDiDj(WDjDk(WDkDl(WDlDm(WDmDn(WDnDo(WDoDp(WDpGl%^GlGm(WGmGn(WGnGo(WGoGp(WGpGq(WGqGr(WGrGs(WGsGt(WGtGu(WGuGv(WGv&FV%^&FV&FW'w&FW;'S%^;'S;=`&_<%l?Hb%^?Hb?Hc'w?HcO%^~%c^s~OY%^Zp%^tw%^xz%^!O!P%^!Q!^%^!a!}%^#O#P%^#QBn%^Bo&FV%^&FW;'S%^;'S;=`&_<%l?Hb%^?HcO%^~&bP;=`<%l%^~&jO#m~~&oO#l~~&rP!_!`&u~&zO$O~~'PO#r~~'USo~OY'PZ;'S'P;'S;=`'b<%lO'P~'eP;=`<%l'P~'mO#v~~'rO#z~~'wO#|~~'|O!O~~(RO#}~~(WO#{~~(_!Ov~s~OY%^Zp%^tw%^xz%^!O!P+_!Q!R(W!R!S(W!S!T(W!T!U(W!U!V(W!V!W(W!W!X(W!X!Y(W!Y!Z(W!Z![(W![!^%^!a!}%^#O#P%^#QBn%^BoDf%^DfDg(WDgDh(WDhDi(WDiDj(WDjDk(WDkDl(WDlDm(WDmDn(WDnDo(WDoDp(WDpGl%^GlGm(WGmGn(WGnGo(WGoGp(WGpGq(WGqGr(WGrGs(WGsGt(WGtGu(WGuGv(WGv&FV%^&FW;'S%^;'S;=`&_<%l?Hb%^?HcO%^~+d!Os~OY%^Zp%^tw%^xz%^!O!P%^!Q!R.d!R!S.d!S!T.d!T!U.d!U!V.d!V!W.d!W!X.d!X!Y.d!Y!Z.d!Z![.d![!^%^!a!}%^#O#P%^#QBn%^BoDf%^DfDg.dDgDh.dDhDi.dDiDj.dDjDk.dDkDl.dDlDm.dDmDn.dDnDo.dDoDp.dDpGl%^GlGm.dGmGn.dGnGo.dGoGp.dGpGq.dGqGr.dGrGs.dGsGt.dGtGu.dGuGv.dGv&FV%^&FW;'S%^;'S;=`&_<%l?Hb%^?HcO%^~.k!Ov~s~OY%^Zp%^tw%^xz%^!O!P%^!Q!R.d!R!S.d!S!T.d!T!U.d!U!V.d!V!W.d!W!X.d!X!Y.d!Y!Z.d!Z![.d![!^%^!a!}%^#O#P%^#QBn%^BoDf%^DfDg.dDgDh.dDhDi.dDiDj.dDjDk.dDkDl.dDlDm.dDmDn.dDnDo.dDoDp.dDpGl%^GlGm.dGmGn.dGnGo.dGoGp.dGpGq.dGqGr.dGrGs.dGsGt.dGtGu.dGuGv.dGv&FV%^&FW;'S%^;'S;=`&_<%l?Hb%^?HcO%^~1pO$Q~~1uO#p~~1zO$P~~2PO#n~~2UO#o~",
        tokenizers: [2, new lr_1.LocalTokenGroup("_~RQYZXwxX~^O#x~~", 14, 131), new lr_1.LocalTokenGroup("_~RQYZXrsX~^O#t~~", 14, 127)],
        topRules: { "Program": [0, 32] },
        dynamicPrecedences: { "76": -10 },
        specialized: [{ term: 35, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }, { term: 35, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 1627
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level17-parser.js
  var require_level17_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level17-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "?[QYQPOOOOQO'#EO'#EOQYQPOOO!gQPO'#EyO!{QPO'#DPOOQO'#EY'#EYO#TQPO'#D_OOQO'#EZ'#EZO#qQPO'#D`OOQO'#E]'#E]O#xQPO'#DaOOQO'#E`'#E`O$QQPO'#DdOOQO'#Ea'#EaO$XQPO'#DeOOQO'#Eb'#EbO$`QPO'#DfOOQO'#Dc'#DcOOQO'#Ec'#EcO$gQPO'#DgOOQO'#Ed'#EdO$tQPO'#DhOOQO'#Ef'#EfO${QPO'#DiOOQO'#Eh'#EhO%eQPO'#DjOOQO'#Eo'#EoO%lQPO'#DvOOQO'#Ep'#EpO%tQPO'#DwOOQO'#Er'#ErO&PQPO'#DxOOQO'#Eu'#EuO&XQPO'#DyOOQO'#Ev'#EvO&aQPO'#DzOOQO'#Ew'#EwO&hQPO'#D{OOQO'#Ex'#ExO&oQPO'#D|O&vQPO'#D}OOQO'#DO'#DOQ!bQPO'#EPQ'RQPOOOOQO-E7|-E7|OOQO'#DS'#DSO(]QPO,59mOOQO'#ER'#ERO(|QPO,59kOOQO'#DV'#DVO(hQPO,59kO)TQPO,59kO#cQPO,59kOOQO-E8W-E8WO*^QPO'#DWO+ZOSO'#FRO+cOQO'#FVOOQO'#DX'#DXO+kQPO'#E[OOQO'#DW'#DWOOQO-E8X-E8XOOQO'#E['#E[O,`QPO,59zOOQO-E8Z-E8ZO,jQPO,59{O-zQPO,5:OOOQO-E8^-E8^OOQO,5:O,5:OO.`QPO,5:POOQO-E8_-E8_OOQO,5:P,5:PO.tQPO,5:QOOQO-E8`-E8`OOQO,5:Q,5:QO/YQPO,5:ROOQO-E8a-E8aOOQO,5:R,5:RO/nQPO,5:SOOQO-E8b-E8bO0PQPO,5:SO0UQPO,5:TOOQO-E8d-E8dO0gQPO,5:TO0lQPO'#DWO1[QPO'#DmOOQO-E8f-E8fO0sQPO'#DmOOQO'#Dk'#DkO1lQPO,5:UOOQO'#Du'#DuOOQO-E8m-E8mOOQO,5:b,5:bOOQO-E8n-E8nO1wQPO,5:cOOQO-E8p-E8pO1|QPO,5:dOOQO-E8s-E8sO2RQPO,5:eO2ZQPO,5:fOOQO-E8t-E8tOOQO-E8u-E8uO1lQPO,5:gOOQO-E8v-E8vO1lQPO,5:hOOQO'#Ey'#EyOOQO-E8w-E8wO2eQPO,5:kOOQO-E7}-E7}OOQO'#EQ'#EQO3uQPO1G/XO3xQPO1G/XOOQO-E8P-E8PO3}QPO'#ESO4oQPO1G/VO5TQPO1G/bOOQO'#EW'#EWO5`QPO1G/dOOOO'#ET'#ETO5qOSO,5;mOOQO,5;m,5;mOOOO'#EU'#EUO5yOQO,5;qOOQO,5;q,5;qOOQO'#DY'#DYOOQO'#DZ'#DZO#cQPO,5;uO#cQPO,5;uOOQO-E8Y-E8YOOQO'#E^'#E^O6RQPO1G/gOOQO'#Ee'#EeO6dQPO1G/nOOQO'#Eg'#EgO6lQPO1G/oO6tQPO,5:WO6|QPO,5:XO7TQPO,5:XOOQO'#Do'#DoO#`QPO,5:YOOQO'#Dq'#DqOOQO'#Dr'#DrO7TQPO,5:[OOQO'#Ej'#EjO7[QPO,5:_OOQO'#Ek'#EkO7dQPO,5:`OOQO'#Em'#EmO7lQPO'#ElOOQO'#En'#EnO7sQPO'#ElO1lQPO1G/pOOQO1G/p1G/pOOQO'#Eq'#EqO7zQPO1G/}O8VQPO1G0OO6RQPO1G0POOQO1G0P1G0PO1lQPO1G0ROOQO1G0R1G0RO1lQPO1G0SOOQO1G0S1G0SOOQO-E8O-E8OOOQO'#DU'#DUOOQO7+$s7+$sOOQO-E8Q-E8QO8bQPO7+$|O8gQPO'#EXOOQO-E8U-E8UO9XQPO7+%OOOOO-E8R-E8ROOQO1G1X1G1XOOOO-E8S-E8SOOQO1G1]1G1]OOQO1G1a1G1aO9mQPO1G1aO;ZQPO'#DbOOQO-E8[-E8[OOQO7+%R7+%ROOQO-E8c-E8cOOQO7+%Y7+%YOOQO-E8e-E8eOOQO7+%Z7+%ZOOQO'#Ei'#EiO<wQPO1G/rO=VQPO1G/sOOQO1G/s1G/sO#`QPO1G/sO=nQPO1G/tOOQO1G/t1G/tO>VQPO1G/vOOQO1G/v1G/vO#`QPO1G/vOOQO-E8h-E8hOOQO1G/y1G/yOOQO-E8i-E8iOOQO1G/z1G/zOOQO-E8k-E8kOOQO,5;W,5;WOOQO-E8l-E8lOOQO-E8j-E8jOOQO7+%[7+%[OOQO-E8o-E8oOOQO'#Es'#EsO>nQPO7+%jO%oQPO7+%jO%oQPO7+%kOOQO7+%m7+%mOOQO7+%n7+%nO>yQPO'#EVO?UQPO<<HhOOQO-E8V-E8VO?^QPO,59|O#cQPO'#E_OOQO-E8g-E8gO@nQPO7+%_OOQO7+%_7+%_OAVQPO7+%bOOQO7+%b7+%bOOQO-E8q-E8qOAnQPO<<IUOOQO<<IU<<IUOOQO<<IV<<IVOOQO,5:q,5:qOOQO-E8T-E8TOOQOAN>SAN>SOOQO-E8]-E8]OAsQPO,5:yOOQO'#Et'#EtOCaQPOAN>pOOQO-E8r-E8rO%oQPOG24[OOQOLD)vLD)v",
        stateData: "Co~OpOS#pOS~ORhOTjOXtOYvOZVO[ZO]]O^_O_bO`dObfOdTOglOinOlXOmpOnrOtRO#qPO~OW!PO#r}O#t!ROt#mX#n#mX#q#mX~OW!PO#t!RO~OdTO#n!RX#q!RX~OlXOt!WOw!]O#v!XO#z!YO~OZVO~P#`OlXOt!bO~O[ZO~P#`O]]O~P#`O^_O~P#`O_bO#n!ZX#q!ZX~P#`O`dO~P#`ObfO~P#`OlXOt!uOw!]O#v!XO#z!YO~ORhO~P%SOTjO$V!{O~OglOt#POw#PO~OinOt#RO~OmpOt#TO~OnrO~P#`OXtO~P%SOYvO~P%SOt#[O#n!qX#q!qX~ORhOTjOXtOYvOZVO[ZO]]O^_O_bO`dObfOdTOglOinOlXOmpOnrOtRO~OQ#`Ot#bOw#bO~OP#gOt!WOw!]O#r}O#v!XO#z!YO~OW!PO~P(hOW!POt!WOw!]O#v!XO#z!YO~O#r}O$OzX$PzX$QzX$RzXWzXezXfzX#tzX$SzX$TzX$UzX~OlzXtzXwzX#nzX#qzX#vzX#zzXczXazX!PzXUzXVzX$VzX~P)fO#w#iO#x#kO~O#{#lO#|#nO~O$O#oO$P#oO$Q#pO$R#pOl#OXt#OXw#OX#n#OX#q#OX#v#OX#z#OX~O#n!Sa#q!Sa~P#`Oo#tO#n!Ta#q!Tal!Tat!Taw!Ta#v!Ta#z!Tac!Taa!TaW!Tae!Taf!Ta#t!Ta$S!Ta$T!Ta$U!TaU!TaV!Ta$V!Ta~O$O#oO$P#oO$Q#pO$R#pO#n!Wa#q!Wa~O$O#oO$P#oO$Q#pO$R#pO#n!Xa#q!Xa~O$O#oO$P#oO$Q#pO$R#pO#n!Ya#q!Ya~O$O#oO$P#oO$Q#pO$R#pO#n!Za#q!Za~Oc#vO$O#oO$P#oO$Q#pO$R#pO~Oc#vO~Oa#xO$O#oO$P#oO$Q#pO$R#pO~Oa#xO~OW!PO~P)fOW!POe$SOf$UO#t!RO$S#}O$T$PO$U$QO~O$O#oO$P#oO$Q#pO$R#pO~P0sOU$WOV$YO$V!{O~Oh$^O~Oe$SO~Oo#tO$V!{O~O#n!na#q!na~P#`O#qPOR!saT!saX!saY!saZ!sa[!sa]!sa^!sa_!sa`!sab!sad!sag!sai!sal!sam!san!sat!sa#n!sa~OQ#`O#s$hO~O$O#oO$P#oO$Q#pO$R#pOt!vXw!vX#n!vX#q!vX#v!vX#z!vX~Ot!WOw!]O#v!XO#z!YO#nsi#qsi~Ow$kO#v!XO#z!YO~OP#gOt!WOw!]O#v!XO#z!YO~O#w#iO#x$pO~O#{#lO#|$rO~Oo#tOt!WOw!]O#v!XO#z!YO~Oc#vOt$yO~Oa#xOt${O~OS$|OW!PO~OW!PO~P#`O#t!RO~P#`Oe$SOt%XO~Of$UOt%ZO~OU$WO~P%SOV$YO~P%SOh$^O#n!ki#q!ki~Oe$SOk%bOt%dO~O!P%hO~O$O#oO$P#oO$Q#pO$R#pOt!{Xw!{X#n!{X#q!{X#v!{X#z!{X~Ot!WOw!]O#v!XO#z!YO#n!Qq#q!Qq~O$O#oO$P#oO$Q#pO$R#pOl#}it#}iw#}i#n#}i#q#}i#v#}i#z#}ic#}ia#}iW#}ie#}if#}i#t#}i$S#}i$T#}i$U#}i!P#}iU#}iV#}i$V#}i~O!P%lO$O#oO$P#oO$Q#pO$R#pO#n!UX#q!UX$V!UXl!UXt!UXw!UX#v!UX#z!UXc!UXa!UXW!UXe!UXf!UX#t!UX$S!UX$T!UX$U!UXU!UXV!UX~OS$|OU!`iV!`i$V!`i~O$O#oO$P#oO$Q#pO$R#pOU!aiV!ai$V!ai~O$O#oO$P#oO$Q#pO$R#pOU!biV!bi$V!bi~O$O#oO$P#oO$Q#pO$R#pOU!diV!di$V!di~Ok%bOt%sOw%sO~Ow%vO#v!XO#z!YO~O!P%hO#s$hO~O!P%lO#n!Ua#q!Ua$V!Ual!Uat!Uaw!Ua#v!Ua#z!Uac!Uaa!UaW!Uae!Uaf!Ua#t!Ua$S!Ua$T!Ua$U!UaU!UaV!Ua~O$O#oO$P#oO$Q#pO$R#pOU!aqV!aq$V!aq~O$O#oO$P#oO$Q#pO$R#pOU!dqV!dq$V!dq~Oj%{O~O$O#oO$P#oO$Q#pO$R#pO!P#Ra#n#Ra#q#Ra$V#Ral#Rat#Raw#Ra#v#Ra#z#Rac#Raa#RaW#Rae#Raf#Ra#t#Ra$S#Ra$T#Ra$U#RaU#RaV#Ra~Oj%{Ot&OOw&OO~Owt~",
        goto: "4i$OPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP$P$UP$Z%TP%^%e%u'`(Z(o$UP$U$U$U)T*Z$U*a*a*a$U$U$U$U*f*s*s*s*z*s+O+O*s*s+S$U$U$U$U$U$U$U$U+u,P,W,^,q,z-Q-W-^-e-k-s-{.V.t/O/U/^/f/n/v0O0V0_0f0n0t1P1W1f1q1|2U2^2d2l2r2x3Q3Y3b3jPPPPPPP3rPPP3rPPP$`VzOQ{VyOQ{USOQ{!e!]W[^`cegisuw!Q!S!T!U!`#U#e#h#q#r#u#{#|$O$R$X$Z$a$n%Q%V%lU!OR!W!uT#f!Q!SS$i#a#bR%x%iQ!SRQ!USS#|!v!xQ%Q#|R%V$RW![Ws!`#UQ!c[Q!f^Q!i`Q!lcQ!oeQ!rgY!viuw$X$ZY#d!Q!S!T!U#eS$l#h$nQ$s#qQ$t#rS$u#u$aS%O#{#|Q%R$OQ%T$RQ%n%QQ%p%VR%z%l!d!]W[^`cegisuw!Q!S!T!U!`#U#e#h#q#r#u#{#|$O$R$X$Z$a$n%Q%V%lQ$k#fR%v%hu#q![!c!f!i!l!o!r!v#d$l$t$u%O%R%T%n%p%zu#r![!c!f!i!l!o!r!v#d$l$t$u%O%R%T%n%p%zUyOQ{W!_Ws!`#UQ!e[Q!h^Q!k`Q!ncQ!qeQ!tgY!xiuw$X$ZS%P#{#|Q%S$OQ%U$RQ%o%QR%q%VQ$w#uR%e$aVaOQ{Q!ziQ#XuQ#ZwT%]$X$ZZ!yiuw$X$ZT$O!v!xT$R!v!xQ!}kQ$]!zQ$b#TQ$d#XQ$f#ZQ%`$[Q%f$cQ%g$eQ%t%dQ%u%eR&P&OQQOS|Q#^R#^zS{OQR#_{Q#a!OR$g#aQ!QRQ!TSW#c!Q!T#z#{Q#z!uT#{!v!xW#e!Q!S!T!UR$j#eQ#j!XR$o#jQ#m!YR$q#mQ%i$kR%w%iS#h!Q!SR$m#hQ$n#hR%j$nUUOQ{R!VUUWOQ{R!^WQ!`WQ#UsT#s!`#U!QYOQW[^`cegisuw{!`#U#{#|$O$R$X$Z%Q%VR!aYQ#u!bQ$a#TT$v#u$aQ%k$uR%y%kU[OQ{R!d[U^OQ{R!g^U`OQ{R!j`UcOQ{R!mcUeOQ{R!peS#w!o!qR$x#wUgOQ{R!sgS#y!r!tR$z#yUiOQ{R!wiQ$}#zR%m$}S$T!v!xQ$`#RT%W$T$`S$V!v!xR%Y$VQ$[!zQ$c#XQ$e#ZV%_$[$c$e[$X!z#X#Z$[$c$eR%[$X[$Z!z#X#Z$[$c$eR%^$ZUkOQ{R!|kUmOQ{R#OmQ$_#PR%a$_UoOQ{R#QoQ%c$`R%r%cQ%|%sR%}%|UqOQ{R#SqUsOQ{R#VsUuOQ{R#WuUwOQ{R#YwUxOQ{R#]x!i!ZW[^`cegisuw!Q!S!T!U!`#U#e#f#h#q#r#u#{#|$O$R$X$Z$a$n%Q%V%h%l",
        nodeNames: "\u26A0 ask random if pressed else and or is while elif print forward turn color sleep add from remove toList clear in not_in repeat times for to range call define return with Comment Program Command Assign Text ListAccess Op Number Op Op Expression String Op Op AssignList Comma Ask Clear Print Call Arguments Turtle Forward Turn Color Sleep Add Remove If Condition PressedCheck EqualityCheck NotEqualCheck Op ComparisonCheck Op Op InListCheck NotInListCheck Op Else Repeat For Define Return While Elif ErrorInvalid",
        maxTerm: 145,
        nodeProps: [
          ["group", 53, "turtle"]
        ],
        skippedNodes: [0, 32],
        repeatNodeCount: 42,
        tokenData: "2a~R!dOY%aYZ&kZp%apq&pqr&urs'Qst'Vtw%awx'nxz%az{'s{|'x|}'}}!O(S!O!P%a!P!Q(X!Q!R(^!R!S(^!S!T(^!T!U(^!U!V(^!V!W(^!W!X(^!X!Y(^!Y!Z(^!Z![(^![!]1q!]!^%a!^!_1v!_!`1{!`!a2Q!a!}%a!}#O2V#O#P%a#P#Q2[#QBn%aBnBo'}BoDf%aDfDg(^DgDh(^DhDi(^DiDj(^DjDk(^DkDl(^DlDm(^DmDn(^DnDo(^DoDp(^DpGl%aGlGm(^GmGn(^GnGo(^GoGp(^GpGq(^GqGr(^GrGs(^GsGt(^GtGu(^GuGv(^Gv&FV%a&FV&FW'}&FW;'S%a;'S;=`&e<%l?Hb%a?Hb?Hc'}?HcO%a~%f_t~OY%aZp%atw%axz%a!O!P%a!Q![%a!]!^%a!a!}%a#O#P%a#QBn%aBo&FV%a&FW;'S%a;'S;=`&e<%l?Hb%a?HcO%a~&hP;=`<%l%a~&pO#q~~&uO#p~~&xP!_!`&{~'QO$S~~'VO#v~~'[Sp~OY'VZ;'S'V;'S;=`'h<%lO'V~'kP;=`<%l'V~'sO#z~~'xO$O~~'}O$Q~~(SO!P~~(XO$R~~(^O$P~~(e!Ow~t~OY%aZp%atw%axz%a!O!P+e!Q!R(^!R!S(^!S!T(^!T!U(^!U!V(^!V!W(^!W!X(^!X!Y(^!Y!Z(^!Z![(^!]!^%a!a!}%a#O#P%a#QBn%aBoDf%aDfDg(^DgDh(^DhDi(^DiDj(^DjDk(^DkDl(^DlDm(^DmDn(^DnDo(^DoDp(^DpGl%aGlGm(^GmGn(^GnGo(^GoGp(^GpGq(^GqGr(^GrGs(^GsGt(^GtGu(^GuGv(^Gv&FV%a&FW;'S%a;'S;=`&e<%l?Hb%a?HcO%a~+j!Ot~OY%aZp%atw%axz%a!O!P%a!Q!R.j!R!S.j!S!T.j!T!U.j!U!V.j!V!W.j!W!X.j!X!Y.j!Y!Z.j!Z![.j!]!^%a!a!}%a#O#P%a#QBn%aBoDf%aDfDg.jDgDh.jDhDi.jDiDj.jDjDk.jDkDl.jDlDm.jDmDn.jDnDo.jDoDp.jDpGl%aGlGm.jGmGn.jGnGo.jGoGp.jGpGq.jGqGr.jGrGs.jGsGt.jGtGu.jGuGv.jGv&FV%a&FW;'S%a;'S;=`&e<%l?Hb%a?HcO%a~.q!Ow~t~OY%aZp%atw%axz%a!O!P%a!Q!R.j!R!S.j!S!T.j!T!U.j!U!V.j!V!W.j!W!X.j!X!Y.j!Y!Z.j!Z![.j!]!^%a!a!}%a#O#P%a#QBn%aBoDf%aDfDg.jDgDh.jDhDi.jDiDj.jDjDk.jDkDl.jDlDm.jDmDn.jDnDo.jDoDp.jDpGl%aGlGm.jGmGn.jGnGo.jGoGp.jGpGq.jGqGr.jGrGs.jGsGt.jGtGu.jGuGv.jGv&FV%a&FW;'S%a;'S;=`&e<%l?Hb%a?HcO%a~1vO$V~~1{O$U~~2QO#t~~2VO$T~~2[O#r~~2aO#s~",
        tokenizers: [2, new lr_1.LocalTokenGroup("_~RQYZXwxX~^O#|~~", 14, 135), new lr_1.LocalTokenGroup("_~RQYZXrsX~^O#x~~", 14, 131)],
        topRules: { "Program": [0, 33] },
        dynamicPrecedences: { "79": -10 },
        specialized: [{ term: 36, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }, { term: 36, get: (value, stack) => (0, tokens_1.extendKeyword)(value, stack) << 1 | 1, external: tokens_1.extendKeyword, extend: true }],
        tokenPrec: 1592
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/level18-parser.js
  var require_level18_parser = __commonJS({
    "__tmp__/static/js/lezer-parsers/level18-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parser = void 0;
      var lr_1 = require_dist9();
      var tokens_1 = require_tokens();
      exports.parser = lr_1.LRParser.deserialize({
        version: 14,
        states: "@dQYQPOOOOQO'#D|'#D|QYQPOOO!dQPO'#EsO!{QPO'#C|OOQO'#EW'#EWO#TQPO'#D`OOQO'#EX'#EXO#`QPO'#DaOOQO'#EY'#EYO#hQPO'#DcOOQO'#EZ'#EZO#yQPO'#DdOOQO'#E['#E[O$[QPO'#DeOOQO'#Db'#DbOOQO'#E]'#E]O$mQPO'#DfOOQO'#E^'#E^O%UQPO'#DgOOQO'#E`'#E`O%gQPO'#DhOOQO'#Eb'#EbO%xQPO'#DiOOQO'#Eh'#EhO&ZQPO'#DtOOQO'#Ei'#EiO&cQPO'#DuOOQO'#Ek'#EkO&nQPO'#DvOOQO'#En'#EnO&vQPO'#DwOOQO'#Eo'#EoO'OQPO'#DxOOQO'#Eq'#EqO'WQPO'#DyOOQO'#Er'#ErO'iQPO'#DzO'zQPO'#D{OOQO'#C{'#C{Q!_QPO'#D}Q(VQPOOOOQO-E7z-E7zOOQO'#DP'#DPO)^QPO,59jOOQO'#EP'#EPO)}QPO,59hOOQO'#DS'#DSO)iQPO,59hOOQO'#D['#D[O*UQPO,59xO*gQPO,59hO*jQPO,59hOOQO-E8U-E8UOOQO-E8V-E8VO*UQPO,59{O+vQPO'#DTO+}OSO'#E{O,VOQO'#FPOOQO'#DU'#DUO,_QPO,59}OOQO'#DT'#DTOOQO-E8W-E8WOOQO,59},59}O,sQPO,5:OOOQO-E8X-E8XOOQO,5:O,5:OO-XQPO,5:POOQO-E8Y-E8YOOQO,5:P,5:PO-mQPO,5:QOOQO-E8Z-E8ZOOQO,5:Q,5:QO.RQPO,5:ROOQO-E8[-E8[O.dQPO,5:RO.iQPO,5:SOOQO-E8^-E8^O.zQPO,5:SO/tQPO'#DTO0dQPO'#DlOOQO-E8`-E8`O0OQPO'#DlOOQO'#Dj'#DjO0tQPO,5:TOOQO'#Ds'#DsOOQO-E8f-E8fOOQO,5:`,5:`OOQO-E8g-E8gO1PQPO,5:aOOQO-E8i-E8iO1UQPO,5:bOOQO-E8l-E8lO#cQPO,5:cO#cQPO'#D^OOQO-E8m-E8mOOQO'#Ep'#EpO1ZQPO,5:dOOQO-E8o-E8oO0tQPO,5:eOOQO-E8p-E8pO0tQPO,5:fOOQO'#Es'#EsOOQO-E8q-E8qO1fQPO,5:iOOQO-E7{-E7{OOQO'#EO'#EOO2sQPO1G/UO2vQPO1G/UO2{QPO'#DTOOQO-E7}-E7}O3oQPO'#EQO4aQPO1G/SO4uQPO1G/_OOQO'#EU'#EUO5QQPO1G/aO5YQPO'#FZOOQO'#D_'#D_OOQO1G/d1G/dO*bQPO1G/dOOQO'#FZ'#FZO5nQPO'#D]OOQO1G/g1G/gO*bQPO1G/gOOOO'#ER'#ERO5vOSO,5;gOOQO,5;g,5;gOOOO'#ES'#ESO6OOQO,5;kOOQO,5;k,5;kOOQO'#DV'#DVOOQO'#DW'#DWO*jQPO,5;oO*jQPO,5;oOOQO'#E_'#E_O6WQPO1G/mOOQO'#Ea'#EaO6`QPO1G/nO6hQPO,5:VO6pQPO,5:WO7RQPO,5:WOOQO'#Dn'#DnO#kQPO,5:XOOQO'#Dp'#DpOOQO'#Dq'#DqO7RQPO,5:ZOOQO'#Ed'#EdO7dQPO,5:^OOQO'#Ef'#EfO7lQPO'#EeOOQO'#Eg'#EgO7}QPO'#EeO0tQPO1G/oOOQO1G/o1G/oOOQO'#Ej'#EjO8`QPO1G/{OOQO'#El'#ElO8kQPO1G/|O*UQPO1G/}OOQO-E8n-E8nO0tQPO1G0POOQO1G0P1G0PO0tQPO1G0QOOQO1G0Q1G0QOOQO-E7|-E7|OOQO'#DR'#DROOQO7+$p7+$pOOQO-E8O-E8OO8vQPO7+$yOOQO-E8S-E8SO*UQPO7+${OOQO7+%O7+%OO#kQPO'#EVO8{QPO,59wOOQO7+%R7+%ROOOO-E8P-E8POOQO1G1R1G1ROOOO-E8Q-E8QOOQO1G1V1G1VOOQO1G1Z1G1ZO9TQPO1G1ZOOQO-E8]-E8]OOQO7+%X7+%XOOQO-E8_-E8_OOQO7+%Y7+%YOOQO'#Ec'#EcO:nQPO1G/qO:|QPO1G/rOOQO1G/r1G/rO#kQPO1G/rO;eQPO1G/sOOQO1G/s1G/sO;|QPO1G/uOOQO1G/u1G/uO#kQPO1G/uOOQO-E8b-E8bOOQO1G/x1G/xOOQO-E8d-E8dOOQO,5;P,5;POOQO-E8e-E8eOOQO-E8c-E8cOOQO7+%Z7+%ZOOQO-E8h-E8hOOQO-E8j-E8jOOQO'#Em'#EmO<eQPO7+%hO&^QPO7+%hO&^QPO7+%iO*bQPO7+%iOOQO7+%k7+%kOOQO7+%l7+%lO<mQPO'#ETO<xQPO<<HeOOQO<<Hg<<HgO*bQPO<<HgOOQO,5:q,5:qOOQO-E8T-E8TOOQO-E8a-E8aO=QQPO7+%^OOQO7+%^7+%^O=iQPO7+%aOOQO7+%a7+%aOOQO-E8k-E8kO>QQPO<<ISOOQO<<IS<<ISOOQO<<IT<<ITO&^QPO<<ITOOQO,5:o,5:oOOQO-E8R-E8ROOQOAN>PAN>POOQOAN>RAN>RO>YQPOAN>nOOQOAN>oAN>oO>_QPOG24YO>gQPOLD)tO&^QPO!$'M`O>oQPO!$'M`OOQO!)9Bz!)9BzO*bQPO!)9BzO&^QPO!.K8fOOQO!4/.Q!4/.Q",
        stateData: ">z~OmOS#jOS~OPVOS`OUXOVZOW]OXbOYdO[TO]fO^hOdjOgrOhnOipOjlOltOqRO#kPO~OQ}O#l{O#n!PO#|!ROq#gX#h#gX#k#gX~OQ}O#n!PO~O[TO#h!SX#k!SX~OPVO#|!RO~OUXOq!YOt!_O#p!ZO#t![O~OVZOq!YOt!_O#p!ZO#t![O~OW]Oq!YOt!_O#p!ZO#t![O~OS`Oq!YOt!_O#p!ZO#t![O#h!YX#k!YX~OXbOq!YOt!_O#p!ZO#t![O~OYdOq!YOt!_O#p!ZO#t![O~O]fOq!qOt!_O#p!ZO#t![O~O^hO$S!wO~OdjOq!{Ot!{O~OjlOq!}O~OhnOq#PO~OipOq#QO~OgrOq!qOt!_O#p!ZO#t![O~OltOq!qOt!_O#p!ZO#t![O~Oq#YO#h!oX#k!oX~OPVOS`OUXOVZOW]OXbOYdO[TO]fO^hOdjOgrOhnOipOjlOltOqRO~OT#^Oq#`Ot#`O~OR#fOq#aOt!_O#l{O#p!ZO#t![O~OQ}O~P)iOq!YOt!_O#p!ZO#t![O$O#iO~OQ}Oq#aOt!_O#p!ZO#t![O~O#l{O#hwX#kwX#xwX#ywX#zwX#{wXkwXZwX|wX$OwX_wX`wX$SwX~O#|!RO~P*xO#q#pO#r#rO~O#u#sO#v#uO~O#x#vO#y#vO#z#wO#{#wO#h!Va#k!Va~O#x#vO#y#vO#z#wO#{#wO#h!Wa#k!Wa~O#x#vO#y#vO#z#wO#{#wO#h!Xa#k!Xa~O#x#vO#y#vO#z#wO#{#wO#h!Ya#k!Ya~Ok#zO#x#vO#y#vO#z#wO#{#wO~Ok#zO~OZ#|O#x#vO#y#vO#z#wO#{#wO~OZ#|O~O#l{OQwXbwX#nwX#xwX#ywX#zwX#{wX$PwX$QwX$RwX~OQ}O#|!RO~P/POQ}Ob$WO#n!PO$P$RO$Q$TO$R$UO~O#x#vO#y#vO#z#wO#{#wO~P0OO_$YO`$[O$S!wO~Oe$`O~Oc$bO~Oq#QO#h!la#k!la~O#kPOP!qaS!qaU!qaV!qaW!qaX!qaY!qa[!qa]!qa^!qad!qag!qah!qai!qaj!qal!qaq!qa#h!qa~OT#^O#m$kO~OqwXtwX#pwX#twXQwXbwX#nwX$PwX$QwX$RwX~P*xO#x#vO#y#vO#z#wO#{#wOq!tXt!tX#h!tX#k!tX#p!tX#t!tX~Oq#aOt!_O#p!ZO#t![O#hpi#kpi~Ot$nO#p!ZO#t![O~OR#fO#|!RO~O#x#vO#y#vO#z#wO#{#wO|#}X$O#}X~O|$rO$O!PX~O#q#pO#r$vO~O#u#sO#v$xO~Ok#zOq$|O~OZ#|Oq%OO~OQ}Oa%PO~OQ}Oq!YOt!_O#p!ZO#t![O~Oq!YOt!_O#n!PO#p!ZO#t![O~Ob$WOq%[O~O_$YOq!qOt!_O#p!ZO#t![O~O`$[Oq!qOt!_O#p!ZO#t![O~Oe$`O#h!ii#k!ii~Oc$bOf%dOq%fO~O|%kO~O|$rO$O!Pa~O#x#vO#y#vO#z#wO#{#wO#h#wi#k#wik#wiZ#wiQ#wib#wi#n#wi$P#wi$Q#wi$R#wiq#wit#wi#p#wi#t#wi|#wi$O#wi_#wi`#wi$S#wi~Oa%PO_!_i`!_i$S!_i~O#x#vO#y#vO#z#wO#{#wO_!`i`!`i$S!`i~O#x#vO#y#vO#z#wO#{#wO_!ai`!ai$S!ai~O#x#vO#y#vO#z#wO#{#wO_!ci`!ci$S!ci~Of%dO#|!RO~Ot%{O#p!ZO#t![O~O|%kO#m$kO~O#x#vO#y#vO#z#wO#{#wO_!`q`!`q$S!`q~O#x#vO#y#vO#z#wO#{#wO_!cq`!cq$S!cq~Oq&POt&PO~O|&RO~Oq&SOt&SO~O|&UO$O#iO~Oq&WOt&WO~Otq~",
        goto: "4X$OPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP$P$UP$Z%PP%Z%b%r'R'x(Z$UP$U(l)O)[*g$U$U$U+V+V+V$U$U$U$U+[+i+i+i+p+i+t+t+i+x$U$U$U$U$U$U$U$U,n,x-P-V-j-s-y.P.V.^.d.l.t.|/U/^/f/n/u/}0U0^0d0k0y1U1a1i1q1w2P2V2]2e2m2s2{3TPPPPPPP3]PPP3]PPP$`PPPPP4OVxOQyVwOQyUSOQy!]!_Y[^acegsu!O!Q!S!T!U!X#d#x#y$P$Q$S$V$Z$]$d$p$r%T%YW|R!Y!q#aT#e!O!QS$l#_#`R%}%lQ!QRQ!USS$Q!r!tQ%T$QR%Y$VQ!^YQ!b[Q!e^Q!haQ!kcQ!neY!rgsu$Z$]Y#c!O!Q!T!U#dY#h!S!X$d$p$rQ$y#xQ$z#yS%R$P$QQ%U$SQ%W$VQ%r%TR%t%Y![!_Y[^acegsu!O!Q!S!T!U!X#d#x#y$P$Q$S$V$Z$]$d$p$r%T%YQ$n#eR%{%ko#x!^!b!e!h!k!n!r#c#h$z%R%U%W%r%to#y!^!b!e!h!k!n!r#c#h$z%R%U%W%r%tW!SR!Y!q#QQ!XWQ$d#PQ$p#gR%w%eQ#k!SQ#o!XQ%h$dR%n$pUwOQyQ!aYQ!d[Q!g^Q!jaQ!mcQ!peY!tgsu$Z$]S#Sq#TY#l!S!X$d$p$rS%S$P$QQ%V$SQ%X$VQ%s%TR%u%YQ#j!SQ#n!XQ$q#kQ$t#oQ%g$dQ%m$pQ%z%hQ&O%nQ&T&SR&X&WV_OQyQ!vgQ#VsQ#XuT%^$Z$]Z!ugsu$Z$]T$S!r!tT$V!r!tQ!yiQ$_!vQ$g#VQ$i#XQ%a$^Q%i$fQ%j$hQ%x%fQ%y%gQ&Q%zQ&V&TR&Y&XQQOSzQ#[R#[xSyOQR#]yQ#_|R$j#_Q!ORQ!TSW#b!O!T$O$PQ$O!qT$P!r!tW#d!O!Q!T!UR$m#dQ#q!ZR$u#qQ#t![R$w#tQ%l$nR%|%lS#g!O!QR$o#gQ$s#mR%p$sUUOQyR!VUUWOQyR!WWUYOQyR!`YU[OQyR!c[U^OQyR!f^UaOQyR!iaUcOQyR!lcS#{!k!mR${#{UeOQyR!oeS#}!n!pR$}#}UgOQyR!sgQ%Q$OR%q%QS$X!r!tR%Z$XQ$^!vQ$f#VQ$h#XV%`$^$f$h[$Z!v#V#X$^$f$hR%]$Z[$]!v#V#X$^$f$hR%_$]UiOQyR!xiUkOQyR!zkQ$a!{R%b$aUmOQyR!|mQ$c!}R%c$cQ%e$cR%v%eUoOQyR#OoUqOQyR#RqQ#TqR$e#TUsOQyR#UsUuOQyR#WuUvOQyR#Zv!a!]Y[^acegsu!O!Q!S!T!U!X#d#e#x#y$P$Q$S$V$Z$]$d$p$r%T%Y%kW#m!S!X$d$pR%o$r",
        nodeNames: "\u26A0 print is input sleep random forward turn color add remove from clear if else and or pressed notIn in repeat times range while def return for toList elif Comment Program Command Assign Text ListAccess Op Number Op Op Expression String Op Op AssignList Comma Input Op Arguments Call Op Clear Print Turtle Forward Turn Color Sleep Add Remove If Condition PressedCheck EqualityCheck NotEqualCheck Op ComparisonCheck Op Op ListCheck Op Else Repeat For Define Return While Elif ErrorInvalid",
        maxTerm: 142,
        nodeProps: [
          ["group", 52, "turtle"]
        ],
        skippedNodes: [0, 29],
        repeatNodeCount: 38,
        tokenData: "2b~R!eOY%dYZ&kZp%dpq&pqr&urs'Qst'Vtw%dwx'nxy'syz'xz{'}{|(S|}(X}!O(^!O!P%d!P!Q(c!Q!R(h!R!S(h!S!T(h!T!U(h!U!V(h!V!W(h!W!X(h!X!Y(h!Y!Z(h!Z![(h![!]1r!]!^%d!^!_1w!_!`1|!`!a2R!a!}%d!}#O2W#O#P%d#P#Q2]#QBn%dBnBo(XBoDf%dDfDg(hDgDh(hDhDi(hDiDj(hDjDk(hDkDl(hDlDm(hDmDn(hDnDo(hDoDp(hDpGl%dGlGm(hGmGn(hGnGo(hGoGp(hGpGq(hGqGr(hGrGs(hGsGt(hGtGu(hGuGv(hGv&FV%d&FV&FW(X&FW;'S%d;'S;=`&e<%l?Hb%d?Hb?Hc(X?HcO%d~%i^q~OY%dZp%dtw%d!O!P%d!Q![%d!]!^%d!a!}%d#O#P%d#QBn%dBo&FV%d&FW;'S%d;'S;=`&e<%l?Hb%d?HcO%d~&hP;=`<%l%d~&pO#k~~&uO#j~~&xP!_!`&{~'QO$P~~'VO#p~~'[Sm~OY'VZ;'S'V;'S;=`'h<%lO'V~'kP;=`<%l'V~'sO#t~~'xO#|~~'}O$O~~(SO#x~~(XO#z~~(^O|~~(cO#{~~(hO#y~~(o}t~q~OY%dZp%dtw%d!O!P+l!Q!R(h!R!S(h!S!T(h!T!U(h!U!V(h!V!W(h!W!X(h!X!Y(h!Y!Z(h!Z![(h!]!^%d!a!}%d#O#P%d#QBn%dBoDf%dDfDg(hDgDh(hDhDi(hDiDj(hDjDk(hDkDl(hDlDm(hDmDn(hDnDo(hDoDp(hDpGl%dGlGm(hGmGn(hGnGo(hGoGp(hGpGq(hGqGr(hGrGs(hGsGt(hGtGu(hGuGv(hGv&FV%d&FW;'S%d;'S;=`&e<%l?Hb%d?HcO%d~+q}q~OY%dZp%dtw%d!O!P%d!Q!R.n!R!S.n!S!T.n!T!U.n!U!V.n!V!W.n!W!X.n!X!Y.n!Y!Z.n!Z![.n!]!^%d!a!}%d#O#P%d#QBn%dBoDf%dDfDg.nDgDh.nDhDi.nDiDj.nDjDk.nDkDl.nDlDm.nDmDn.nDnDo.nDoDp.nDpGl%dGlGm.nGmGn.nGnGo.nGoGp.nGpGq.nGqGr.nGrGs.nGsGt.nGtGu.nGuGv.nGv&FV%d&FW;'S%d;'S;=`&e<%l?Hb%d?HcO%d~.u}t~q~OY%dZp%dtw%d!O!P%d!Q!R.n!R!S.n!S!T.n!T!U.n!U!V.n!V!W.n!W!X.n!X!Y.n!Y!Z.n!Z![.n!]!^%d!a!}%d#O#P%d#QBn%dBoDf%dDfDg.nDgDh.nDhDi.nDiDj.nDjDk.nDkDl.nDlDm.nDmDn.nDnDo.nDoDp.nDpGl%dGlGm.nGmGn.nGnGo.nGoGp.nGpGq.nGqGr.nGrGs.nGsGt.nGtGu.nGuGv.nGv&FV%d&FW;'S%d;'S;=`&e<%l?Hb%d?HcO%d~1wO$S~~1|O$R~~2RO#n~~2WO$Q~~2]O#l~~2bO#m~",
        tokenizers: [2, new lr_1.LocalTokenGroup("_~RQYZXwxX~^O#v~~", 14, 129), new lr_1.LocalTokenGroup("_~RQYZXrsX~^O#r~~", 14, 125)],
        topRules: { "Program": [0, 30] },
        dynamicPrecedences: { "77": -10 },
        specialized: [{ term: 33, get: (value, stack) => (0, tokens_1.specializeKeyword)(value, stack) << 1, external: tokens_1.specializeKeyword }],
        tokenPrec: 1373
      });
    }
  });

  // __tmp__/static/js/lezer-parsers/language-packages.js
  var require_language_packages = __commonJS({
    "__tmp__/static/js/lezer-parsers/language-packages.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.languagePerLevel = void 0;
      var level1_parser_1 = require_level1_parser();
      var level2_parser_1 = require_level2_parser();
      var level3_parser_1 = require_level3_parser();
      var level4_parser_1 = require_level4_parser();
      var level5_parser_1 = require_level5_parser();
      var level6_parser_1 = require_level6_parser();
      var level7_parser_1 = require_level7_parser();
      var level8_parser_1 = require_level8_parser();
      var level9_parser_1 = require_level9_parser();
      var level10_parser_1 = require_level10_parser();
      var level11_parser_1 = require_level11_parser();
      var level12_parser_1 = require_level12_parser();
      var level13_parser_1 = require_level13_parser();
      var level14_parser_1 = require_level14_parser();
      var level15_parser_1 = require_level15_parser();
      var level16_parser_1 = require_level16_parser();
      var level17_parser_1 = require_level17_parser();
      var level18_parser_1 = require_level18_parser();
      exports.languagePerLevel = {
        1: level1_parser_1.parser,
        2: level2_parser_1.parser,
        3: level3_parser_1.parser,
        4: level4_parser_1.parser,
        5: level5_parser_1.parser,
        6: level6_parser_1.parser,
        7: level7_parser_1.parser,
        8: level8_parser_1.parser,
        9: level9_parser_1.parser,
        10: level10_parser_1.parser,
        11: level11_parser_1.parser,
        12: level12_parser_1.parser,
        13: level13_parser_1.parser,
        14: level14_parser_1.parser,
        15: level15_parser_1.parser,
        16: level16_parser_1.parser,
        17: level17_parser_1.parser,
        18: level18_parser_1.parser
      };
    }
  });

  // __tmp__/static/js/cm-monokai-theme.js
  var require_cm_monokai_theme = __commonJS({
    "__tmp__/static/js/cm-monokai-theme.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.monokai = exports.monokaiHighlightStyle = exports.monokaiTheme = exports.color = void 0;
      var view_1 = require_dist2();
      var language_1 = require_dist5();
      var highlight_1 = require_dist4();
      var strawberry = "#ff6188";
      var greenLizard = "#a6e22e";
      var whiskey = "#d19a66";
      var ivory = "#abb2bf";
      var darkSilver = "#75715e";
      var coral = "#e06c75";
      var invalid = "#ffffff";
      var stone = "#7d8799";
      var malibu = "#61afef";
      var violet = "#ae81ff";
      var background = "#272822";
      var highlightBackground = "#202020";
      var selection = "#90cdf463";
      var gutterBackground = "#2F3129";
      var gutterColor = "#8F908A";
      var activeLineGutter = "#272727";
      var skyBlue = "#66D9EF";
      var tooltipBackground = "#353a42";
      var darkBackground = "#21252b";
      exports.color = {
        coral,
        invalid,
        ivory,
        stone,
        malibu,
        violet,
        whiskey,
        greenLizard,
        strawberry,
        darkSilver,
        background,
        selection,
        gutterBackground,
        gutterColor,
        activeLineGutter
      };
      exports.monokaiTheme = view_1.EditorView.theme({
        "&": {
          color: ivory,
          backgroundColor: background
        },
        ".cm-content": {
          caretColor: "white"
        },
        ".cm-cursor, .cm-dropCursor": { borderLeftColor: "white" },
        "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection, borderRadius: "2px" },
        ".cm-panels": { backgroundColor: darkBackground, color: ivory },
        ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
        ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
        ".cm-searchMatch": {
          backgroundColor: "#72a1ff59",
          outline: "1px solid #457dff"
        },
        ".cm-searchMatch.cm-searchMatch-selected": {
          backgroundColor: "#6199ff2f"
        },
        ".cm-activeLine": { backgroundColor: "#706d6d15" },
        ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
        "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
          backgroundColor: "#bad0f847"
        },
        ".cm-gutters": {
          backgroundColor: gutterBackground,
          color: gutterColor,
          border: "none"
        },
        ".cm-activeLineGutter": {
          backgroundColor: "#85828215",
          color: "white"
        },
        ".cm-foldPlaceholder": {
          backgroundColor: "transparent",
          border: "none",
          color: "#ddd"
        },
        ".cm-tooltip": {
          border: "none",
          backgroundColor: tooltipBackground
        },
        ".cm-tooltip .cm-tooltip-arrow:before": {
          borderTopColor: "transparent",
          borderBottomColor: "transparent"
        },
        ".cm-tooltip .cm-tooltip-arrow:after": {
          borderTopColor: tooltipBackground,
          borderBottomColor: tooltipBackground
        },
        ".cm-tooltip-autocomplete": {
          "& > ul > li[aria-selected]": {
            backgroundColor: highlightBackground,
            color: ivory
          }
        }
      }, { dark: true });
      exports.monokaiHighlightStyle = language_1.HighlightStyle.define([
        {
          tag: highlight_1.tags.keyword,
          color: strawberry
        },
        {
          tag: [highlight_1.tags.name, highlight_1.tags.deleted, highlight_1.tags.character, highlight_1.tags.propertyName, highlight_1.tags.macroName],
          color: "white"
        },
        {
          tag: [highlight_1.tags.function(highlight_1.tags.variableName), highlight_1.tags.labelName],
          color: malibu
        },
        {
          tag: [highlight_1.tags.color, highlight_1.tags.constant(highlight_1.tags.name), highlight_1.tags.standard(highlight_1.tags.name)],
          color: whiskey
        },
        {
          tag: [highlight_1.tags.definition(highlight_1.tags.name), highlight_1.tags.separator],
          color: ivory
        },
        {
          tag: [highlight_1.tags.typeName, highlight_1.tags.className, highlight_1.tags.number, highlight_1.tags.changed, highlight_1.tags.annotation, highlight_1.tags.modifier, highlight_1.tags.self, highlight_1.tags.namespace],
          color: greenLizard
        },
        {
          tag: [highlight_1.tags.operator, highlight_1.tags.operatorKeyword, highlight_1.tags.url, highlight_1.tags.escape, highlight_1.tags.regexp, highlight_1.tags.link, highlight_1.tags.special(highlight_1.tags.string)],
          color: skyBlue
        },
        {
          tag: [highlight_1.tags.meta, highlight_1.tags.comment],
          color: darkSilver
        },
        {
          tag: highlight_1.tags.strong,
          fontWeight: "bold"
        },
        {
          tag: highlight_1.tags.emphasis,
          fontStyle: "italic"
        },
        {
          tag: highlight_1.tags.strikethrough,
          textDecoration: "line-through"
        },
        {
          tag: highlight_1.tags.link,
          color: stone,
          textDecoration: "underline"
        },
        {
          tag: highlight_1.tags.heading,
          fontWeight: "bold",
          color: coral
        },
        {
          tag: [highlight_1.tags.atom, highlight_1.tags.bool, highlight_1.tags.special(highlight_1.tags.variableName)],
          color: whiskey
        },
        {
          tag: [highlight_1.tags.processingInstruction, highlight_1.tags.string, highlight_1.tags.inserted],
          color: violet
        },
        {
          tag: highlight_1.tags.invalid,
          color: ivory
        }
      ]);
      exports.monokai = [exports.monokaiTheme, (0, language_1.syntaxHighlighting)(exports.monokaiHighlightStyle)];
    }
  });

  // __tmp__/static/js/cm-editor.js
  var require_cm_editor = __commonJS({
    "__tmp__/static/js/cm-editor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HedyCodeMirrorEditor = exports.HedyCodeMirrorEditorCreator = void 0;
      var editor_1 = require_editor();
      var view_1 = require_dist2();
      var state_1 = require_dist();
      var event_emitter_1 = require_event_emitter();
      var commands_1 = require_dist6();
      var commands_2 = require_dist6();
      var language_1 = require_dist5();
      var search_1 = require_dist8();
      var cm_decorations_1 = require_cm_decorations();
      var language_2 = require_dist5();
      var language_packages_1 = require_language_packages();
      var app_1 = require_app();
      var cm_monokai_theme_1 = require_cm_monokai_theme();
      var modal_1 = require_modal();
      var client_messages_1 = require_client_messages();
      var highlight_1 = require_dist4();
      var indentSize = " ".repeat(4);
      var HedyCodeMirrorEditorCreator = class {
        initializeEditorWithGutter($editor, editorType, dir = "ltr") {
          let editor = new HedyCodeMirrorEditor($editor.get(0), $editor.data("readonly"), editorType, dir);
          return editor;
        }
        initializeReadOnlyEditor(preview, dir = "ltr") {
          let editorType;
          if ($(preview).hasClass("common-mistakes")) {
            editorType = editor_1.EditorType.COMMON_MISTAKES;
          } else if ($(preview).hasClass("cheatsheet")) {
            editorType = editor_1.EditorType.CHEATSHEET;
          } else if ($(preview).hasClass("parsons")) {
            editorType = editor_1.EditorType.PARSONS;
          } else {
            editorType = editor_1.EditorType.EXAMPLE;
          }
          return new HedyCodeMirrorEditor(preview, true, editorType, dir);
        }
      };
      exports.HedyCodeMirrorEditorCreator = HedyCodeMirrorEditorCreator;
      var HedyCodeMirrorEditor = class {
        constructor(element, isReadOnly, editorType, __2 = "ltr") {
          this.readMode = new state_1.Compartment();
          this.editorEvent = new event_emitter_1.EventEmitter({
            change: true,
            guttermousedown: true,
            changeBreakpoint: true,
            click: true
          });
          this.incorrectLineMapping = {};
          let state;
          if (editorType === editor_1.EditorType.MAIN) {
            const mainEditorStyling = view_1.EditorView.theme({
              "&": {
                background: "#272822",
                fontSize: "15.2px",
                color: "white",
                borderRadius: "4px",
                marginRight: "5px"
              },
              ".cm-scroller": {
                overflow: "auto"
              },
              ".cm-gutters": {
                borderRadius: "4px"
              },
              ".cm-cursor, .cm-dropCursor": { borderLeftColor: "white", borderLeftWidth: "2px" }
            });
            state = state_1.EditorState.create({
              doc: "",
              extensions: [
                mainEditorStyling,
                cm_decorations_1.breakpointGutter,
                (0, view_1.lineNumbers)(),
                (0, view_1.highlightActiveLineGutter)(),
                (0, view_1.highlightSpecialChars)(),
                (0, commands_2.history)(),
                (0, view_1.drawSelection)(),
                (0, view_1.dropCursor)(),
                (0, language_1.indentOnInput)(),
                (0, language_1.syntaxHighlighting)(language_1.defaultHighlightStyle, { fallback: true }),
                (0, view_1.highlightActiveLine)(),
                (0, search_1.highlightSelectionMatches)(),
                view_1.keymap.of([
                  ...commands_1.defaultKeymap,
                  ...search_1.searchKeymap,
                  ...commands_1.historyKeymap,
                  commands_1.indentWithTab
                ]),
                language_1.indentUnit.of(indentSize),
                language_1.indentService.of(cm_decorations_1.basicIndent),
                cm_monokai_theme_1.monokai,
                this.readMode.of(state_1.EditorState.readOnly.of(isReadOnly)),
                cm_decorations_1.errorLineField,
                cm_decorations_1.debugLineField,
                cm_decorations_1.incorrectLineField,
                state_1.Prec.high(cm_decorations_1.decorationsTheme),
                cm_decorations_1.placeholders
              ]
            });
          } else {
            let theme = {
              ".cm-cursor, .cm-dropCursor": { border: "none" }
            };
            let extensions = [
              (0, view_1.highlightSpecialChars)(),
              (0, view_1.drawSelection)(),
              (0, language_1.syntaxHighlighting)(language_1.defaultHighlightStyle, { fallback: true }),
              cm_monokai_theme_1.monokai,
              this.readMode.of(state_1.EditorState.readOnly.of(isReadOnly)),
              cm_decorations_1.placeholders
            ];
            switch (editorType) {
              case editor_1.EditorType.CHEATSHEET:
              case editor_1.EditorType.EXAMPLE:
              case editor_1.EditorType.PARSONS:
                theme[".cm-scroller"] = { "overflow": "auto", "min-height": "3.5rem" };
                extensions.push(view_1.EditorView.theme(theme));
                break;
              case editor_1.EditorType.COMMON_MISTAKES:
                theme["&"] = {
                  background: "#272822",
                  fontSize: "15.2px",
                  color: "white",
                  borderRadius: "4px",
                  marginRight: "5px"
                };
                extensions.push([
                  view_1.EditorView.theme(theme),
                  (0, view_1.lineNumbers)(),
                  (0, view_1.highlightActiveLine)(),
                  (0, view_1.highlightActiveLineGutter)()
                ]);
                break;
            }
            state = state_1.EditorState.create({
              doc: "",
              extensions
            });
          }
          this.view = new view_1.EditorView({
            parent: element,
            state
          });
          if (app_1.theLevel) {
            this.setHighlighterForLevel(app_1.theLevel);
          }
        }
        setHighlighterForLevel(level) {
          const language = language_packages_1.languagePerLevel[level];
          const hedyStyleTags = {
            "print forward turn color ask is echo sleep Comma": highlight_1.tags.keyword,
            "at random remove from add to if else in not Op": highlight_1.tags.keyword,
            "repeat times for range with return and or while": highlight_1.tags.keyword,
            "elif def input toList": highlight_1.tags.keyword,
            Comment: highlight_1.tags.lineComment,
            "Text": highlight_1.tags.name,
            "String": highlight_1.tags.string,
            "clear pressed": highlight_1.tags.color,
            "Number Int": highlight_1.tags.number,
            "define call": highlight_1.tags.operatorKeyword,
            "Command/ErrorInvalid/Text": highlight_1.tags.invalid
          };
          const parserWithMetadata = language.configure({
            props: [
              (0, highlight_1.styleTags)(hedyStyleTags)
            ]
          });
          const langPackage = language_2.LRLanguage.define({
            parser: parserWithMetadata,
            languageData: {
              commentTokens: { line: "#" }
            }
          });
          function hedy() {
            return new language_1.LanguageSupport(langPackage);
          }
          const effect = state_1.StateEffect.appendConfig.of(hedy());
          this.view.dispatch({ effects: effect });
        }
        get contents() {
          return this.view.state.doc.toString();
        }
        set contents(content) {
          let transaction = this.view.state.update({ changes: { from: 0, to: this.view.state.doc.length, insert: content } });
          this.view.dispatch(transaction);
        }
        get isReadOnly() {
          return this.view.state.readOnly;
        }
        set isReadOnly(isReadMode) {
          this.view.dispatch({
            effects: this.readMode.reconfigure(state_1.EditorState.readOnly.of(isReadMode))
          });
        }
        resize(newHeightRem) {
          if (newHeightRem === void 0) {
            console.log("Error! When resizing a CodeMirror instance, you need to provide the new height");
            return;
          }
          console.warn("Oops! editor.resize() should not have been called anymore");
        }
        focus() {
          this.view.focus();
        }
        clearErrors() {
          let effect = cm_decorations_1.removeErrorMarkers.of();
          this.view.dispatch({ effects: effect });
        }
        moveCursorToEndOfFile() {
          const endPos = this.view.state.doc.length;
          this.view.dispatch(this.view.state.update({ selection: { anchor: endPos } }));
        }
        clearSelection() {
          const currentSelection = this.view.state.selection;
          const currentAnchor = currentSelection.ranges[0].anchor;
          this.view.dispatch(this.view.state.update({ selection: { anchor: currentAnchor } }));
        }
        clearBreakpoints() {
        }
        configureMainEditor() {
        }
        getHighlighter(level) {
          return `${level}`;
        }
        trimTrailingSpace() {
          (0, commands_1.deleteTrailingWhitespace)(this.view);
        }
        on(key, handler) {
          if (key === "change") {
            const transaction = this.view.state.update({
              effects: state_1.StateEffect.appendConfig.of(view_1.EditorView.updateListener.of((v) => {
                if (v.docChanged) {
                  handler();
                }
              }))
            });
            this.view.dispatch(transaction);
          } else if (key === "click") {
            const eventHandler = view_1.EditorView.domEventHandlers({
              click: handler
            });
            const effect = state_1.StateEffect.appendConfig.of(eventHandler);
            this.view.dispatch({ effects: effect });
          }
        }
        highlightError(row, col) {
          let effect;
          if (col === void 0) {
            effect = cm_decorations_1.addErrorLine.of({ row });
          } else {
            effect = cm_decorations_1.addErrorWord.of({ row, col });
          }
          this.view.dispatch({ effects: effect });
        }
        setDebuggerCurrentLine(line, startPos, finishPos) {
          if (this.currentDebugLine) {
            this.view.dispatch({ effects: cm_decorations_1.removeDebugLine.of() });
          }
          if (line === void 0) {
            this.currentDebugLine = void 0;
            return;
          }
          this.currentDebugLine = line;
          if (startPos !== void 0 && finishPos !== void 0) {
            let effect;
            const docLine = this.view.state.doc.line(line);
            const from = docLine.from + startPos - 1;
            const to2 = docLine.from + finishPos;
            effect = cm_decorations_1.addDebugWords.of({ from, to: to2 });
            this.view.dispatch({ effects: effect });
          } else {
            let effect;
            effect = cm_decorations_1.addDebugLine.of({ row: line });
            this.view.dispatch({ effects: effect });
          }
        }
        getActiveContents(debugLine) {
          const currentContent = this.view.state.doc.toString();
          if (currentContent === "") {
            return "";
          }
          const gutterMarkers = this.view.state.field(cm_decorations_1.breakpointGutterState);
          const deactivatedLines = [];
          let to2;
          let lines;
          if (debugLine === null) {
            to2 = this.view.state.doc.length;
            lines = currentContent.split("\n");
          } else {
            const currentDebugLine = parseInt(debugLine, 10) + 1;
            to2 = this.view.state.doc.line(currentDebugLine).to;
            lines = currentContent.split("\n").slice(0, currentDebugLine);
          }
          gutterMarkers.between(0, to2, (from) => {
            deactivatedLines.push(this.view.state.doc.lineAt(from).number);
          });
          const resultingLines = [];
          for (let i = 0; i < lines.length; i++) {
            if (deactivatedLines.includes(i + 1)) {
              resultingLines.push("");
            } else {
              resultingLines.push(lines[i]);
            }
          }
          const code = resultingLines.join("\n");
          return code;
        }
        setIncorrectLine(range, lineIndex) {
          const startLine = this.view.state.doc.line(range.startLine);
          const endLine = this.view.state.doc.line(range.endLine);
          const from = startLine.from + range.startColumn - 1;
          let to2 = endLine.from + range.endColumn - 1;
          to2 = to2 > endLine.to ? endLine.to : to2;
          this.incorrectLineMapping[`${from}-${to2}`] = lineIndex;
          let effect = cm_decorations_1.addIncorrectLineEffect.of({ from, to: to2 });
          this.view.dispatch({ effects: effect });
        }
        clearIncorrectLines() {
          this.incorrectLineMapping = {};
          const effect = cm_decorations_1.removeIncorrectLineEffect.of();
          this.view.dispatch({ effects: effect });
        }
        getPosFromCoord(x, y2) {
          return this.view.posAtCoords({ x, y: y2 });
        }
        indexOfErrorInPos(pos) {
          const incorrectLineSet = this.view.state.field(cm_decorations_1.incorrectLineField);
          let index = null;
          incorrectLineSet.between(pos, pos, (from, to2) => {
            index = this.incorrectLineMapping[`${from}-${to2}`];
          });
          return index;
        }
        hasIncorrectLinesDecorations() {
          const incorrectLineSet = this.view.state.field(cm_decorations_1.incorrectLineField);
          let hasIncorrectLines = false;
          incorrectLineSet.between(0, this.view.state.doc.length, () => {
            hasIncorrectLines = true;
          });
          return hasIncorrectLines;
        }
        skipFaultyHandler(event2) {
          if (!this.hasIncorrectLinesDecorations())
            return;
          const pos = this.getPosFromCoord(event2.x, event2.y);
          if (pos == null)
            return;
          const index = this.indexOfErrorInPos(pos);
          if (index == null) {
            modal_1.error.hide();
          } else {
            let mapError = app_1.theGlobalSourcemap[index];
            modal_1.error.hide();
            modal_1.error.show(client_messages_1.ClientMessages["Transpile_error"], mapError.error);
          }
        }
      };
      exports.HedyCodeMirrorEditor = HedyCodeMirrorEditor;
    }
  });

  // node_modules/sortablejs/Sortable.min.js
  var require_Sortable_min = __commonJS({
    "node_modules/sortablejs/Sortable.min.js"(exports, module) {
      !function(t, e) {
        typeof exports == "object" && typeof module != "undefined" ? module.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = t || self).Sortable = e();
      }(exports, function() {
        "use strict";
        function e(e2, t2) {
          var n2, o2 = Object.keys(e2);
          return Object.getOwnPropertySymbols && (n2 = Object.getOwnPropertySymbols(e2), t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), o2.push.apply(o2, n2)), o2;
        }
        function M2(o2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = arguments[t2] != null ? arguments[t2] : {};
            t2 % 2 ? e(Object(i2), true).forEach(function(t3) {
              var e2, n2;
              e2 = o2, t3 = i2[n2 = t3], n2 in e2 ? Object.defineProperty(e2, n2, { value: t3, enumerable: true, configurable: true, writable: true }) : e2[n2] = t3;
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o2, Object.getOwnPropertyDescriptors(i2)) : e(Object(i2)).forEach(function(t3) {
              Object.defineProperty(o2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return o2;
        }
        function o(t2) {
          return (o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          })(t2);
        }
        function a() {
          return (a = Object.assign || function(t2) {
            for (var e2 = 1; e2 < arguments.length; e2++) {
              var n2, o2 = arguments[e2];
              for (n2 in o2)
                Object.prototype.hasOwnProperty.call(o2, n2) && (t2[n2] = o2[n2]);
            }
            return t2;
          }).apply(this, arguments);
        }
        function i(t2, e2) {
          if (t2 == null)
            return {};
          var n2, o2 = function(t3, e3) {
            if (t3 == null)
              return {};
            for (var n3, o3 = {}, i3 = Object.keys(t3), r3 = 0; r3 < i3.length; r3++)
              n3 = i3[r3], 0 <= e3.indexOf(n3) || (o3[n3] = t3[n3]);
            return o3;
          }(t2, e2);
          if (Object.getOwnPropertySymbols)
            for (var i2 = Object.getOwnPropertySymbols(t2), r2 = 0; r2 < i2.length; r2++)
              n2 = i2[r2], 0 <= e2.indexOf(n2) || Object.prototype.propertyIsEnumerable.call(t2, n2) && (o2[n2] = t2[n2]);
          return o2;
        }
        function r(t2) {
          return function(t3) {
            if (Array.isArray(t3))
              return l(t3);
          }(t2) || function(t3) {
            if (typeof Symbol != "undefined" && t3[Symbol.iterator] != null || t3["@@iterator"] != null)
              return Array.from(t3);
          }(t2) || function(t3, e2) {
            if (t3) {
              if (typeof t3 == "string")
                return l(t3, e2);
              var n2 = Object.prototype.toString.call(t3).slice(8, -1);
              return (n2 = n2 === "Object" && t3.constructor ? t3.constructor.name : n2) === "Map" || n2 === "Set" ? Array.from(t3) : n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? l(t3, e2) : void 0;
            }
          }(t2) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function l(t2, e2) {
          (e2 == null || e2 > t2.length) && (e2 = t2.length);
          for (var n2 = 0, o2 = new Array(e2); n2 < e2; n2++)
            o2[n2] = t2[n2];
          return o2;
        }
        function t(t2) {
          if (typeof window != "undefined" && window.navigator)
            return !!navigator.userAgent.match(t2);
        }
        var y2 = t(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i), w = t(/Edge/i), s = t(/firefox/i), u = t(/safari/i) && !t(/chrome/i) && !t(/android/i), n = t(/iP(ad|od|hone)/i), c2 = t(/chrome/i) && t(/android/i), d2 = { capture: false, passive: false };
        function h2(t2, e2, n2) {
          t2.addEventListener(e2, n2, !y2 && d2);
        }
        function f(t2, e2, n2) {
          t2.removeEventListener(e2, n2, !y2 && d2);
        }
        function p(t2, e2) {
          if (e2 && (e2[0] === ">" && (e2 = e2.substring(1)), t2))
            try {
              if (t2.matches)
                return t2.matches(e2);
              if (t2.msMatchesSelector)
                return t2.msMatchesSelector(e2);
              if (t2.webkitMatchesSelector)
                return t2.webkitMatchesSelector(e2);
            } catch (t3) {
              return;
            }
        }
        function N(t2, e2, n2, o2) {
          if (t2) {
            n2 = n2 || document;
            do {
              if (e2 != null && (e2[0] !== ">" || t2.parentNode === n2) && p(t2, e2) || o2 && t2 === n2)
                return t2;
            } while (t2 !== n2 && (t2 = (i2 = t2).host && i2 !== document && i2.host.nodeType ? i2.host : i2.parentNode));
          }
          var i2;
          return null;
        }
        var g, m = /\s+/g;
        function I(t2, e2, n2) {
          var o2;
          t2 && e2 && (t2.classList ? t2.classList[n2 ? "add" : "remove"](e2) : (o2 = (" " + t2.className + " ").replace(m, " ").replace(" " + e2 + " ", " "), t2.className = (o2 + (n2 ? " " + e2 : "")).replace(m, " ")));
        }
        function P(t2, e2, n2) {
          var o2 = t2 && t2.style;
          if (o2) {
            if (n2 === void 0)
              return document.defaultView && document.defaultView.getComputedStyle ? n2 = document.defaultView.getComputedStyle(t2, "") : t2.currentStyle && (n2 = t2.currentStyle), e2 === void 0 ? n2 : n2[e2];
            o2[e2 = !(e2 in o2 || e2.indexOf("webkit") !== -1) ? "-webkit-" + e2 : e2] = n2 + (typeof n2 == "string" ? "" : "px");
          }
        }
        function v(t2, e2) {
          var n2 = "";
          if (typeof t2 == "string")
            n2 = t2;
          else
            do {
              var o2 = P(t2, "transform");
            } while (o2 && o2 !== "none" && (n2 = o2 + " " + n2), !e2 && (t2 = t2.parentNode));
          var i2 = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
          return i2 && new i2(n2);
        }
        function b(t2, e2, n2) {
          if (t2) {
            var o2 = t2.getElementsByTagName(e2), i2 = 0, r2 = o2.length;
            if (n2)
              for (; i2 < r2; i2++)
                n2(o2[i2], i2);
            return o2;
          }
          return [];
        }
        function O() {
          var t2 = document.scrollingElement;
          return t2 || document.documentElement;
        }
        function k(t2, e2, n2, o2, i2) {
          if (t2.getBoundingClientRect || t2 === window) {
            var r2, a2, l2, s2, c3, u2, d3 = t2 !== window && t2.parentNode && t2 !== O() ? (a2 = (r2 = t2.getBoundingClientRect()).top, l2 = r2.left, s2 = r2.bottom, c3 = r2.right, u2 = r2.height, r2.width) : (l2 = a2 = 0, s2 = window.innerHeight, c3 = window.innerWidth, u2 = window.innerHeight, window.innerWidth);
            if ((e2 || n2) && t2 !== window && (i2 = i2 || t2.parentNode, !y2))
              do {
                if (i2 && i2.getBoundingClientRect && (P(i2, "transform") !== "none" || n2 && P(i2, "position") !== "static")) {
                  var h3 = i2.getBoundingClientRect();
                  a2 -= h3.top + parseInt(P(i2, "border-top-width")), l2 -= h3.left + parseInt(P(i2, "border-left-width")), s2 = a2 + r2.height, c3 = l2 + r2.width;
                  break;
                }
              } while (i2 = i2.parentNode);
            return o2 && t2 !== window && (o2 = (e2 = v(i2 || t2)) && e2.a, t2 = e2 && e2.d, e2 && (s2 = (a2 /= t2) + (u2 /= t2), c3 = (l2 /= o2) + (d3 /= o2))), { top: a2, left: l2, bottom: s2, right: c3, width: d3, height: u2 };
          }
        }
        function R(t2, e2, n2) {
          for (var o2 = A(t2, true), i2 = k(t2)[e2]; o2; ) {
            var r2 = k(o2)[n2];
            if (!(n2 === "top" || n2 === "left" ? r2 <= i2 : i2 <= r2))
              return o2;
            if (o2 === O())
              break;
            o2 = A(o2, false);
          }
          return false;
        }
        function X2(t2, e2, n2, o2) {
          for (var i2 = 0, r2 = 0, a2 = t2.children; r2 < a2.length; ) {
            if (a2[r2].style.display !== "none" && a2[r2] !== Bt2.ghost && (o2 || a2[r2] !== Bt2.dragged) && N(a2[r2], n2.draggable, t2, false)) {
              if (i2 === e2)
                return a2[r2];
              i2++;
            }
            r2++;
          }
          return null;
        }
        function Y(t2, e2) {
          for (var n2 = t2.lastElementChild; n2 && (n2 === Bt2.ghost || P(n2, "display") === "none" || e2 && !p(n2, e2)); )
            n2 = n2.previousElementSibling;
          return n2 || null;
        }
        function B(t2, e2) {
          var n2 = 0;
          if (!t2 || !t2.parentNode)
            return -1;
          for (; t2 = t2.previousElementSibling; )
            t2.nodeName.toUpperCase() === "TEMPLATE" || t2 === Bt2.clone || e2 && !p(t2, e2) || n2++;
          return n2;
        }
        function E(t2) {
          var e2 = 0, n2 = 0, o2 = O();
          if (t2)
            do {
              var i2 = v(t2), r2 = i2.a, i2 = i2.d;
            } while (e2 += t2.scrollLeft * r2, n2 += t2.scrollTop * i2, t2 !== o2 && (t2 = t2.parentNode));
          return [e2, n2];
        }
        function A(t2, e2) {
          if (!t2 || !t2.getBoundingClientRect)
            return O();
          var n2 = t2, o2 = false;
          do {
            if (n2.clientWidth < n2.scrollWidth || n2.clientHeight < n2.scrollHeight) {
              var i2 = P(n2);
              if (n2.clientWidth < n2.scrollWidth && (i2.overflowX == "auto" || i2.overflowX == "scroll") || n2.clientHeight < n2.scrollHeight && (i2.overflowY == "auto" || i2.overflowY == "scroll")) {
                if (!n2.getBoundingClientRect || n2 === document.body)
                  return O();
                if (o2 || e2)
                  return n2;
                o2 = true;
              }
            }
          } while (n2 = n2.parentNode);
          return O();
        }
        function D2(t2, e2) {
          return Math.round(t2.top) === Math.round(e2.top) && Math.round(t2.left) === Math.round(e2.left) && Math.round(t2.height) === Math.round(e2.height) && Math.round(t2.width) === Math.round(e2.width);
        }
        function S(e2, n2) {
          return function() {
            var t2;
            g || ((t2 = arguments).length === 1 ? e2.call(this, t2[0]) : e2.apply(this, t2), g = setTimeout(function() {
              g = void 0;
            }, n2));
          };
        }
        function F2(t2, e2, n2) {
          t2.scrollLeft += e2, t2.scrollTop += n2;
        }
        function _(t2) {
          var e2 = window.Polymer, n2 = window.jQuery || window.Zepto;
          return e2 && e2.dom ? e2.dom(t2).cloneNode(true) : n2 ? n2(t2).clone(true)[0] : t2.cloneNode(true);
        }
        function C(t2, e2) {
          P(t2, "position", "absolute"), P(t2, "top", e2.top), P(t2, "left", e2.left), P(t2, "width", e2.width), P(t2, "height", e2.height);
        }
        function T(t2) {
          P(t2, "position", ""), P(t2, "top", ""), P(t2, "left", ""), P(t2, "width", ""), P(t2, "height", "");
        }
        var j2 = "Sortable" + new Date().getTime();
        function x() {
          var e2, o2 = [];
          return { captureAnimationState: function() {
            o2 = [], this.options.animation && [].slice.call(this.el.children).forEach(function(t2) {
              var e3, n2;
              P(t2, "display") !== "none" && t2 !== Bt2.ghost && (o2.push({ target: t2, rect: k(t2) }), e3 = M2({}, o2[o2.length - 1].rect), !t2.thisAnimationDuration || (n2 = v(t2, true)) && (e3.top -= n2.f, e3.left -= n2.e), t2.fromRect = e3);
            });
          }, addAnimationState: function(t2) {
            o2.push(t2);
          }, removeAnimationState: function(t2) {
            o2.splice(function(t3, e3) {
              for (var n2 in t3)
                if (t3.hasOwnProperty(n2)) {
                  for (var o3 in e3)
                    if (e3.hasOwnProperty(o3) && e3[o3] === t3[n2][o3])
                      return Number(n2);
                }
              return -1;
            }(o2, { target: t2 }), 1);
          }, animateAll: function(t2) {
            var c3 = this;
            if (!this.options.animation)
              return clearTimeout(e2), void (typeof t2 == "function" && t2());
            var u2 = false, d3 = 0;
            o2.forEach(function(t3) {
              var e3 = 0, n2 = t3.target, o3 = n2.fromRect, i2 = k(n2), r2 = n2.prevFromRect, a2 = n2.prevToRect, l2 = t3.rect, s2 = v(n2, true);
              s2 && (i2.top -= s2.f, i2.left -= s2.e), n2.toRect = i2, n2.thisAnimationDuration && D2(r2, i2) && !D2(o3, i2) && (l2.top - i2.top) / (l2.left - i2.left) == (o3.top - i2.top) / (o3.left - i2.left) && (t3 = l2, s2 = r2, r2 = a2, a2 = c3.options, e3 = Math.sqrt(Math.pow(s2.top - t3.top, 2) + Math.pow(s2.left - t3.left, 2)) / Math.sqrt(Math.pow(s2.top - r2.top, 2) + Math.pow(s2.left - r2.left, 2)) * a2.animation), D2(i2, o3) || (n2.prevFromRect = o3, n2.prevToRect = i2, e3 = e3 || c3.options.animation, c3.animate(n2, l2, i2, e3)), e3 && (u2 = true, d3 = Math.max(d3, e3), clearTimeout(n2.animationResetTimer), n2.animationResetTimer = setTimeout(function() {
                n2.animationTime = 0, n2.prevFromRect = null, n2.fromRect = null, n2.prevToRect = null, n2.thisAnimationDuration = null;
              }, e3), n2.thisAnimationDuration = e3);
            }), clearTimeout(e2), u2 ? e2 = setTimeout(function() {
              typeof t2 == "function" && t2();
            }, d3) : typeof t2 == "function" && t2(), o2 = [];
          }, animate: function(t2, e3, n2, o3) {
            var i2, r2;
            o3 && (P(t2, "transition", ""), P(t2, "transform", ""), i2 = (r2 = v(this.el)) && r2.a, r2 = r2 && r2.d, i2 = (e3.left - n2.left) / (i2 || 1), r2 = (e3.top - n2.top) / (r2 || 1), t2.animatingX = !!i2, t2.animatingY = !!r2, P(t2, "transform", "translate3d(" + i2 + "px," + r2 + "px,0)"), this.forRepaintDummy = t2.offsetWidth, P(t2, "transition", "transform " + o3 + "ms" + (this.options.easing ? " " + this.options.easing : "")), P(t2, "transform", "translate3d(0,0,0)"), typeof t2.animated == "number" && clearTimeout(t2.animated), t2.animated = setTimeout(function() {
              P(t2, "transition", ""), P(t2, "transform", ""), t2.animated = false, t2.animatingX = false, t2.animatingY = false;
            }, o3));
          } };
        }
        var H2 = [], L = { initializeByDefault: true }, K2 = { mount: function(e2) {
          for (var t2 in L)
            !L.hasOwnProperty(t2) || t2 in e2 || (e2[t2] = L[t2]);
          H2.forEach(function(t3) {
            if (t3.pluginName === e2.pluginName)
              throw "Sortable: Cannot mount plugin ".concat(e2.pluginName, " more than once");
          }), H2.push(e2);
        }, pluginEvent: function(e2, n2, o2) {
          var t2 = this;
          this.eventCanceled = false, o2.cancel = function() {
            t2.eventCanceled = true;
          };
          var i2 = e2 + "Global";
          H2.forEach(function(t3) {
            n2[t3.pluginName] && (n2[t3.pluginName][i2] && n2[t3.pluginName][i2](M2({ sortable: n2 }, o2)), n2.options[t3.pluginName] && n2[t3.pluginName][e2] && n2[t3.pluginName][e2](M2({ sortable: n2 }, o2)));
          });
        }, initializePlugins: function(n2, o2, i2, t2) {
          for (var e2 in H2.forEach(function(t3) {
            var e3 = t3.pluginName;
            (n2.options[e3] || t3.initializeByDefault) && ((t3 = new t3(n2, o2, n2.options)).sortable = n2, t3.options = n2.options, n2[e3] = t3, a(i2, t3.defaults));
          }), n2.options) {
            var r2;
            n2.options.hasOwnProperty(e2) && ((r2 = this.modifyOption(n2, e2, n2.options[e2])) !== void 0 && (n2.options[e2] = r2));
          }
        }, getEventProperties: function(e2, n2) {
          var o2 = {};
          return H2.forEach(function(t2) {
            typeof t2.eventProperties == "function" && a(o2, t2.eventProperties.call(n2[t2.pluginName], e2));
          }), o2;
        }, modifyOption: function(e2, n2, o2) {
          var i2;
          return H2.forEach(function(t2) {
            e2[t2.pluginName] && t2.optionListeners && typeof t2.optionListeners[n2] == "function" && (i2 = t2.optionListeners[n2].call(e2[t2.pluginName], o2));
          }), i2;
        } };
        function W2(t2) {
          var e2 = t2.sortable, n2 = t2.rootEl, o2 = t2.name, i2 = t2.targetEl, r2 = t2.cloneEl, a2 = t2.toEl, l2 = t2.fromEl, s2 = t2.oldIndex, c3 = t2.newIndex, u2 = t2.oldDraggableIndex, d3 = t2.newDraggableIndex, h3 = t2.originalEvent, f2 = t2.putSortable, p2 = t2.extraEventProperties;
          if (e2 = e2 || n2 && n2[j2]) {
            var g2, m2 = e2.options, t2 = "on" + o2.charAt(0).toUpperCase() + o2.substr(1);
            !window.CustomEvent || y2 || w ? (g2 = document.createEvent("Event")).initEvent(o2, true, true) : g2 = new CustomEvent(o2, { bubbles: true, cancelable: true }), g2.to = a2 || n2, g2.from = l2 || n2, g2.item = i2 || n2, g2.clone = r2, g2.oldIndex = s2, g2.newIndex = c3, g2.oldDraggableIndex = u2, g2.newDraggableIndex = d3, g2.originalEvent = h3, g2.pullMode = f2 ? f2.lastPutMode : void 0;
            var v2, b2 = M2(M2({}, p2), K2.getEventProperties(o2, e2));
            for (v2 in b2)
              g2[v2] = b2[v2];
            n2 && n2.dispatchEvent(g2), m2[t2] && m2[t2].call(e2, g2);
          }
        }
        function z2(t2, e2) {
          var n2 = (o2 = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : {}).evt, o2 = i(o2, G2);
          K2.pluginEvent.bind(Bt2)(t2, e2, M2({ dragEl: q2, parentEl: V2, ghostEl: Z, rootEl: $3, nextEl: Q2, lastDownEl: J2, cloneEl: tt, cloneHidden: et, dragStarted: pt2, putSortable: lt2, activeSortable: Bt2.active, originalEvent: n2, oldIndex: nt, oldDraggableIndex: it, newIndex: ot2, newDraggableIndex: rt2, hideGhostForTarget: kt2, unhideGhostForTarget: Rt2, cloneNowHidden: function() {
            et = true;
          }, cloneNowShown: function() {
            et = false;
          }, dispatchSortableEvent: function(t3) {
            U({ sortable: e2, name: t3, originalEvent: n2 });
          } }, o2));
        }
        var G2 = ["evt"];
        function U(t2) {
          W2(M2({ putSortable: lt2, cloneEl: tt, targetEl: q2, rootEl: $3, oldIndex: nt, oldDraggableIndex: it, newIndex: ot2, newDraggableIndex: rt2 }, t2));
        }
        var q2, V2, Z, $3, Q2, J2, tt, et, nt, ot2, it, rt2, at2, lt2, st2, ct2, ut2, dt2, ht2, ft2, pt2, gt2, mt2, vt, bt, yt = false, wt2 = false, Et = [], Dt = false, St2 = false, _t2 = [], Ct2 = false, Tt2 = [], xt = typeof document != "undefined", Ot2 = n, At2 = w || y2 ? "cssFloat" : "float", Mt2 = xt && !c2 && !n && "draggable" in document.createElement("div"), Nt2 = function() {
          if (xt) {
            if (y2)
              return false;
            var t2 = document.createElement("x");
            return t2.style.cssText = "pointer-events:auto", t2.style.pointerEvents === "auto";
          }
        }(), It = function(t2, e2) {
          var n2 = P(t2), o2 = parseInt(n2.width) - parseInt(n2.paddingLeft) - parseInt(n2.paddingRight) - parseInt(n2.borderLeftWidth) - parseInt(n2.borderRightWidth), i2 = X2(t2, 0, e2), r2 = X2(t2, 1, e2), a2 = i2 && P(i2), l2 = r2 && P(r2), s2 = a2 && parseInt(a2.marginLeft) + parseInt(a2.marginRight) + k(i2).width, t2 = l2 && parseInt(l2.marginLeft) + parseInt(l2.marginRight) + k(r2).width;
          if (n2.display === "flex")
            return n2.flexDirection === "column" || n2.flexDirection === "column-reverse" ? "vertical" : "horizontal";
          if (n2.display === "grid")
            return n2.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
          if (i2 && a2.float && a2.float !== "none") {
            e2 = a2.float === "left" ? "left" : "right";
            return !r2 || l2.clear !== "both" && l2.clear !== e2 ? "horizontal" : "vertical";
          }
          return i2 && (a2.display === "block" || a2.display === "flex" || a2.display === "table" || a2.display === "grid" || o2 <= s2 && n2[At2] === "none" || r2 && n2[At2] === "none" && o2 < s2 + t2) ? "vertical" : "horizontal";
        }, Pt2 = function(t2) {
          function l2(r2, a2) {
            return function(t3, e3, n3, o2) {
              var i2 = t3.options.group.name && e3.options.group.name && t3.options.group.name === e3.options.group.name;
              if (r2 == null && (a2 || i2))
                return true;
              if (r2 == null || r2 === false)
                return false;
              if (a2 && r2 === "clone")
                return r2;
              if (typeof r2 == "function")
                return l2(r2(t3, e3, n3, o2), a2)(t3, e3, n3, o2);
              e3 = (a2 ? t3 : e3).options.group.name;
              return r2 === true || typeof r2 == "string" && r2 === e3 || r2.join && -1 < r2.indexOf(e3);
            };
          }
          var e2 = {}, n2 = t2.group;
          n2 && o(n2) == "object" || (n2 = { name: n2 }), e2.name = n2.name, e2.checkPull = l2(n2.pull, true), e2.checkPut = l2(n2.put), e2.revertClone = n2.revertClone, t2.group = e2;
        }, kt2 = function() {
          !Nt2 && Z && P(Z, "display", "none");
        }, Rt2 = function() {
          !Nt2 && Z && P(Z, "display", "");
        };
        xt && !c2 && document.addEventListener("click", function(t2) {
          if (wt2)
            return t2.preventDefault(), t2.stopPropagation && t2.stopPropagation(), t2.stopImmediatePropagation && t2.stopImmediatePropagation(), wt2 = false;
        }, true);
        function Xt(t2) {
          if (q2) {
            t2 = t2.touches ? t2.touches[0] : t2;
            var e2 = (i2 = t2.clientX, r2 = t2.clientY, Et.some(function(t3) {
              var e3 = t3[j2].options.emptyInsertThreshold;
              if (e3 && !Y(t3)) {
                var n3 = k(t3), o3 = i2 >= n3.left - e3 && i2 <= n3.right + e3, e3 = r2 >= n3.top - e3 && r2 <= n3.bottom + e3;
                return o3 && e3 ? a2 = t3 : void 0;
              }
            }), a2);
            if (e2) {
              var n2, o2 = {};
              for (n2 in t2)
                t2.hasOwnProperty(n2) && (o2[n2] = t2[n2]);
              o2.target = o2.rootEl = e2, o2.preventDefault = void 0, o2.stopPropagation = void 0, e2[j2]._onDragOver(o2);
            }
          }
          var i2, r2, a2;
        }
        function Yt2(t2) {
          q2 && q2.parentNode[j2]._isOutsideThisEl(t2.target);
        }
        function Bt2(t2, e2) {
          if (!t2 || !t2.nodeType || t2.nodeType !== 1)
            throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(t2));
          this.el = t2, this.options = e2 = a({}, e2), t2[j2] = this;
          var n2, o2, i2 = { group: null, sort: true, disabled: false, store: null, handle: null, draggable: /^[uo]l$/i.test(t2.nodeName) ? ">li" : ">*", swapThreshold: 1, invertSwap: false, invertedSwapThreshold: null, removeCloneOnHide: true, direction: function() {
            return It(t2, this.options);
          }, ghostClass: "sortable-ghost", chosenClass: "sortable-chosen", dragClass: "sortable-drag", ignore: "a, img", filter: null, preventOnFilter: true, animation: 0, easing: null, setData: function(t3, e3) {
            t3.setData("Text", e3.textContent);
          }, dropBubble: false, dragoverBubble: false, dataIdAttr: "data-id", delay: 0, delayOnTouchOnly: false, touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1, forceFallback: false, fallbackClass: "sortable-fallback", fallbackOnBody: false, fallbackTolerance: 0, fallbackOffset: { x: 0, y: 0 }, supportPointer: Bt2.supportPointer !== false && "PointerEvent" in window && !u, emptyInsertThreshold: 5 };
          for (n2 in K2.initializePlugins(this, t2, i2), i2)
            n2 in e2 || (e2[n2] = i2[n2]);
          for (o2 in Pt2(e2), this)
            o2.charAt(0) === "_" && typeof this[o2] == "function" && (this[o2] = this[o2].bind(this));
          this.nativeDraggable = !e2.forceFallback && Mt2, this.nativeDraggable && (this.options.touchStartThreshold = 1), e2.supportPointer ? h2(t2, "pointerdown", this._onTapStart) : (h2(t2, "mousedown", this._onTapStart), h2(t2, "touchstart", this._onTapStart)), this.nativeDraggable && (h2(t2, "dragover", this), h2(t2, "dragenter", this)), Et.push(this.el), e2.store && e2.store.get && this.sort(e2.store.get(this) || []), a(this, x());
        }
        function Ft2(t2, e2, n2, o2, i2, r2, a2, l2) {
          var s2, c3, u2 = t2[j2], d3 = u2.options.onMove;
          return !window.CustomEvent || y2 || w ? (s2 = document.createEvent("Event")).initEvent("move", true, true) : s2 = new CustomEvent("move", { bubbles: true, cancelable: true }), s2.to = e2, s2.from = t2, s2.dragged = n2, s2.draggedRect = o2, s2.related = i2 || e2, s2.relatedRect = r2 || k(e2), s2.willInsertAfter = l2, s2.originalEvent = a2, t2.dispatchEvent(s2), c3 = d3 ? d3.call(u2, s2, a2) : c3;
        }
        function jt2(t2) {
          t2.draggable = false;
        }
        function Ht() {
          Ct2 = false;
        }
        function Lt2(t2) {
          return setTimeout(t2, 0);
        }
        function Kt2(t2) {
          return clearTimeout(t2);
        }
        Bt2.prototype = { constructor: Bt2, _isOutsideThisEl: function(t2) {
          this.el.contains(t2) || t2 === this.el || (gt2 = null);
        }, _getDirection: function(t2, e2) {
          return typeof this.options.direction == "function" ? this.options.direction.call(this, t2, e2, q2) : this.options.direction;
        }, _onTapStart: function(e2) {
          if (e2.cancelable) {
            var n2 = this, o2 = this.el, t2 = this.options, i2 = t2.preventOnFilter, r2 = e2.type, a2 = e2.touches && e2.touches[0] || e2.pointerType && e2.pointerType === "touch" && e2, l2 = (a2 || e2).target, s2 = e2.target.shadowRoot && (e2.path && e2.path[0] || e2.composedPath && e2.composedPath()[0]) || l2, c3 = t2.filter;
            if (!function(t3) {
              Tt2.length = 0;
              var e3 = t3.getElementsByTagName("input"), n3 = e3.length;
              for (; n3--; ) {
                var o3 = e3[n3];
                o3.checked && Tt2.push(o3);
              }
            }(o2), !q2 && !(/mousedown|pointerdown/.test(r2) && e2.button !== 0 || t2.disabled) && !s2.isContentEditable && (this.nativeDraggable || !u || !l2 || l2.tagName.toUpperCase() !== "SELECT") && !((l2 = N(l2, t2.draggable, o2, false)) && l2.animated || J2 === l2)) {
              if (nt = B(l2), it = B(l2, t2.draggable), typeof c3 == "function") {
                if (c3.call(this, e2, l2, this))
                  return U({ sortable: n2, rootEl: s2, name: "filter", targetEl: l2, toEl: o2, fromEl: o2 }), z2("filter", n2, { evt: e2 }), void (i2 && e2.cancelable && e2.preventDefault());
              } else if (c3 = c3 && c3.split(",").some(function(t3) {
                if (t3 = N(s2, t3.trim(), o2, false))
                  return U({ sortable: n2, rootEl: t3, name: "filter", targetEl: l2, fromEl: o2, toEl: o2 }), z2("filter", n2, { evt: e2 }), true;
              }))
                return void (i2 && e2.cancelable && e2.preventDefault());
              t2.handle && !N(s2, t2.handle, o2, false) || this._prepareDragStart(e2, a2, l2);
            }
          }
        }, _prepareDragStart: function(t2, e2, n2) {
          var o2, i2 = this, r2 = i2.el, a2 = i2.options, l2 = r2.ownerDocument;
          n2 && !q2 && n2.parentNode === r2 && (o2 = k(n2), $3 = r2, V2 = (q2 = n2).parentNode, Q2 = q2.nextSibling, J2 = n2, at2 = a2.group, st2 = { target: Bt2.dragged = q2, clientX: (e2 || t2).clientX, clientY: (e2 || t2).clientY }, ht2 = st2.clientX - o2.left, ft2 = st2.clientY - o2.top, this._lastX = (e2 || t2).clientX, this._lastY = (e2 || t2).clientY, q2.style["will-change"] = "all", o2 = function() {
            z2("delayEnded", i2, { evt: t2 }), Bt2.eventCanceled ? i2._onDrop() : (i2._disableDelayedDragEvents(), !s && i2.nativeDraggable && (q2.draggable = true), i2._triggerDragStart(t2, e2), U({ sortable: i2, name: "choose", originalEvent: t2 }), I(q2, a2.chosenClass, true));
          }, a2.ignore.split(",").forEach(function(t3) {
            b(q2, t3.trim(), jt2);
          }), h2(l2, "dragover", Xt), h2(l2, "mousemove", Xt), h2(l2, "touchmove", Xt), h2(l2, "mouseup", i2._onDrop), h2(l2, "touchend", i2._onDrop), h2(l2, "touchcancel", i2._onDrop), s && this.nativeDraggable && (this.options.touchStartThreshold = 4, q2.draggable = true), z2("delayStart", this, { evt: t2 }), !a2.delay || a2.delayOnTouchOnly && !e2 || this.nativeDraggable && (w || y2) ? o2() : Bt2.eventCanceled ? this._onDrop() : (h2(l2, "mouseup", i2._disableDelayedDrag), h2(l2, "touchend", i2._disableDelayedDrag), h2(l2, "touchcancel", i2._disableDelayedDrag), h2(l2, "mousemove", i2._delayedDragTouchMoveHandler), h2(l2, "touchmove", i2._delayedDragTouchMoveHandler), a2.supportPointer && h2(l2, "pointermove", i2._delayedDragTouchMoveHandler), i2._dragStartTimer = setTimeout(o2, a2.delay)));
        }, _delayedDragTouchMoveHandler: function(t2) {
          t2 = t2.touches ? t2.touches[0] : t2;
          Math.max(Math.abs(t2.clientX - this._lastX), Math.abs(t2.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();
        }, _disableDelayedDrag: function() {
          q2 && jt2(q2), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();
        }, _disableDelayedDragEvents: function() {
          var t2 = this.el.ownerDocument;
          f(t2, "mouseup", this._disableDelayedDrag), f(t2, "touchend", this._disableDelayedDrag), f(t2, "touchcancel", this._disableDelayedDrag), f(t2, "mousemove", this._delayedDragTouchMoveHandler), f(t2, "touchmove", this._delayedDragTouchMoveHandler), f(t2, "pointermove", this._delayedDragTouchMoveHandler);
        }, _triggerDragStart: function(t2, e2) {
          e2 = e2 || t2.pointerType == "touch" && t2, !this.nativeDraggable || e2 ? this.options.supportPointer ? h2(document, "pointermove", this._onTouchMove) : h2(document, e2 ? "touchmove" : "mousemove", this._onTouchMove) : (h2(q2, "dragend", this), h2($3, "dragstart", this._onDragStart));
          try {
            document.selection ? Lt2(function() {
              document.selection.empty();
            }) : window.getSelection().removeAllRanges();
          } catch (t3) {
          }
        }, _dragStarted: function(t2, e2) {
          var n2;
          yt = false, $3 && q2 ? (z2("dragStarted", this, { evt: e2 }), this.nativeDraggable && h2(document, "dragover", Yt2), n2 = this.options, t2 || I(q2, n2.dragClass, false), I(q2, n2.ghostClass, true), Bt2.active = this, t2 && this._appendGhost(), U({ sortable: this, name: "start", originalEvent: e2 })) : this._nulling();
        }, _emulateDragOver: function() {
          if (ct2) {
            this._lastX = ct2.clientX, this._lastY = ct2.clientY, kt2();
            for (var t2 = document.elementFromPoint(ct2.clientX, ct2.clientY), e2 = t2; t2 && t2.shadowRoot && (t2 = t2.shadowRoot.elementFromPoint(ct2.clientX, ct2.clientY)) !== e2; )
              e2 = t2;
            if (q2.parentNode[j2]._isOutsideThisEl(t2), e2)
              do {
                if (e2[j2]) {
                  if (e2[j2]._onDragOver({ clientX: ct2.clientX, clientY: ct2.clientY, target: t2, rootEl: e2 }) && !this.options.dragoverBubble)
                    break;
                }
              } while (e2 = (t2 = e2).parentNode);
            Rt2();
          }
        }, _onTouchMove: function(t2) {
          if (st2) {
            var e2 = this.options, n2 = e2.fallbackTolerance, o2 = e2.fallbackOffset, i2 = t2.touches ? t2.touches[0] : t2, r2 = Z && v(Z, true), a2 = Z && r2 && r2.a, l2 = Z && r2 && r2.d, e2 = Ot2 && bt && E(bt), a2 = (i2.clientX - st2.clientX + o2.x) / (a2 || 1) + (e2 ? e2[0] - _t2[0] : 0) / (a2 || 1), l2 = (i2.clientY - st2.clientY + o2.y) / (l2 || 1) + (e2 ? e2[1] - _t2[1] : 0) / (l2 || 1);
            if (!Bt2.active && !yt) {
              if (n2 && Math.max(Math.abs(i2.clientX - this._lastX), Math.abs(i2.clientY - this._lastY)) < n2)
                return;
              this._onDragStart(t2, true);
            }
            Z && (r2 ? (r2.e += a2 - (ut2 || 0), r2.f += l2 - (dt2 || 0)) : r2 = { a: 1, b: 0, c: 0, d: 1, e: a2, f: l2 }, r2 = "matrix(".concat(r2.a, ",").concat(r2.b, ",").concat(r2.c, ",").concat(r2.d, ",").concat(r2.e, ",").concat(r2.f, ")"), P(Z, "webkitTransform", r2), P(Z, "mozTransform", r2), P(Z, "msTransform", r2), P(Z, "transform", r2), ut2 = a2, dt2 = l2, ct2 = i2), t2.cancelable && t2.preventDefault();
          }
        }, _appendGhost: function() {
          if (!Z) {
            var t2 = this.options.fallbackOnBody ? document.body : $3, e2 = k(q2, true, Ot2, true, t2), n2 = this.options;
            if (Ot2) {
              for (bt = t2; P(bt, "position") === "static" && P(bt, "transform") === "none" && bt !== document; )
                bt = bt.parentNode;
              bt !== document.body && bt !== document.documentElement ? (bt === document && (bt = O()), e2.top += bt.scrollTop, e2.left += bt.scrollLeft) : bt = O(), _t2 = E(bt);
            }
            I(Z = q2.cloneNode(true), n2.ghostClass, false), I(Z, n2.fallbackClass, true), I(Z, n2.dragClass, true), P(Z, "transition", ""), P(Z, "transform", ""), P(Z, "box-sizing", "border-box"), P(Z, "margin", 0), P(Z, "top", e2.top), P(Z, "left", e2.left), P(Z, "width", e2.width), P(Z, "height", e2.height), P(Z, "opacity", "0.8"), P(Z, "position", Ot2 ? "absolute" : "fixed"), P(Z, "zIndex", "100000"), P(Z, "pointerEvents", "none"), Bt2.ghost = Z, t2.appendChild(Z), P(Z, "transform-origin", ht2 / parseInt(Z.style.width) * 100 + "% " + ft2 / parseInt(Z.style.height) * 100 + "%");
          }
        }, _onDragStart: function(t2, e2) {
          var n2 = this, o2 = t2.dataTransfer, i2 = n2.options;
          z2("dragStart", this, { evt: t2 }), Bt2.eventCanceled ? this._onDrop() : (z2("setupClone", this), Bt2.eventCanceled || ((tt = _(q2)).removeAttribute("id"), tt.draggable = false, tt.style["will-change"] = "", this._hideClone(), I(tt, this.options.chosenClass, false), Bt2.clone = tt), n2.cloneId = Lt2(function() {
            z2("clone", n2), Bt2.eventCanceled || (n2.options.removeCloneOnHide || $3.insertBefore(tt, q2), n2._hideClone(), U({ sortable: n2, name: "clone" }));
          }), e2 || I(q2, i2.dragClass, true), e2 ? (wt2 = true, n2._loopId = setInterval(n2._emulateDragOver, 50)) : (f(document, "mouseup", n2._onDrop), f(document, "touchend", n2._onDrop), f(document, "touchcancel", n2._onDrop), o2 && (o2.effectAllowed = "move", i2.setData && i2.setData.call(n2, o2, q2)), h2(document, "drop", n2), P(q2, "transform", "translateZ(0)")), yt = true, n2._dragStartId = Lt2(n2._dragStarted.bind(n2, e2, t2)), h2(document, "selectstart", n2), pt2 = true, u && P(document.body, "user-select", "none"));
        }, _onDragOver: function(n2) {
          var o2, i2, r2, t2, a2 = this.el, l2 = n2.target, e2 = this.options, s2 = e2.group, c3 = Bt2.active, u2 = at2 === s2, d3 = e2.sort, h3 = lt2 || c3, f2 = this, p2 = false;
          if (!Ct2) {
            if (n2.preventDefault !== void 0 && n2.cancelable && n2.preventDefault(), l2 = N(l2, e2.draggable, a2, true), T2("dragOver"), Bt2.eventCanceled)
              return p2;
            if (q2.contains(n2.target) || l2.animated && l2.animatingX && l2.animatingY || f2._ignoreWhileAnimating === l2)
              return O2(false);
            if (wt2 = false, c3 && !e2.disabled && (u2 ? d3 || (i2 = V2 !== $3) : lt2 === this || (this.lastPutMode = at2.checkPull(this, c3, q2, n2)) && s2.checkPut(this, c3, q2, n2))) {
              if (r2 = this._getDirection(n2, l2) === "vertical", o2 = k(q2), T2("dragOverValid"), Bt2.eventCanceled)
                return p2;
              if (i2)
                return V2 = $3, x2(), this._hideClone(), T2("revert"), Bt2.eventCanceled || (Q2 ? $3.insertBefore(q2, Q2) : $3.appendChild(q2)), O2(true);
              var g2 = Y(a2, e2.draggable);
              if (!g2 || function(t3, e3, n3) {
                n3 = k(Y(n3.el, n3.options.draggable));
                return e3 ? t3.clientX > n3.right + 10 || t3.clientX <= n3.right && t3.clientY > n3.bottom && t3.clientX >= n3.left : t3.clientX > n3.right && t3.clientY > n3.top || t3.clientX <= n3.right && t3.clientY > n3.bottom + 10;
              }(n2, r2, this) && !g2.animated) {
                if (g2 === q2)
                  return O2(false);
                if ((l2 = g2 && a2 === n2.target ? g2 : l2) && (w2 = k(l2)), Ft2($3, a2, q2, o2, l2, w2, n2, !!l2) !== false)
                  return x2(), g2 && g2.nextSibling ? a2.insertBefore(q2, g2.nextSibling) : a2.appendChild(q2), V2 = a2, A2(), O2(true);
              } else if (g2 && function(t3, e3, n3) {
                n3 = k(X2(n3.el, 0, n3.options, true));
                return e3 ? t3.clientX < n3.left - 10 || t3.clientY < n3.top && t3.clientX < n3.right : t3.clientY < n3.top - 10 || t3.clientY < n3.bottom && t3.clientX < n3.left;
              }(n2, r2, this)) {
                var m2 = X2(a2, 0, e2, true);
                if (m2 === q2)
                  return O2(false);
                if (w2 = k(l2 = m2), Ft2($3, a2, q2, o2, l2, w2, n2, false) !== false)
                  return x2(), a2.insertBefore(q2, m2), V2 = a2, A2(), O2(true);
              } else if (l2.parentNode === a2) {
                var v2, b2, y3, w2 = k(l2), E2 = q2.parentNode !== a2, D3 = (D3 = q2.animated && q2.toRect || o2, C2 = l2.animated && l2.toRect || w2, S2 = (t2 = r2) ? D3.left : D3.top, s2 = t2 ? D3.right : D3.bottom, g2 = t2 ? D3.width : D3.height, m2 = t2 ? C2.left : C2.top, D3 = t2 ? C2.right : C2.bottom, C2 = t2 ? C2.width : C2.height, !(S2 === m2 || s2 === D3 || S2 + g2 / 2 === m2 + C2 / 2)), S2 = r2 ? "top" : "left", g2 = R(l2, "top", "top") || R(q2, "top", "top"), m2 = g2 ? g2.scrollTop : void 0;
                if (gt2 !== l2 && (b2 = w2[S2], Dt = false, St2 = !D3 && e2.invertSwap || E2), (v2 = function(t3, e3, n3, o3, i3, r3, a3, l3) {
                  var s3 = o3 ? t3.clientY : t3.clientX, c4 = o3 ? n3.height : n3.width, t3 = o3 ? n3.top : n3.left, o3 = o3 ? n3.bottom : n3.right, n3 = false;
                  if (!a3) {
                    if (l3 && vt < c4 * i3) {
                      if (Dt = !Dt && (mt2 === 1 ? t3 + c4 * r3 / 2 < s3 : s3 < o3 - c4 * r3 / 2) ? true : Dt)
                        n3 = true;
                      else if (mt2 === 1 ? s3 < t3 + vt : o3 - vt < s3)
                        return -mt2;
                    } else if (t3 + c4 * (1 - i3) / 2 < s3 && s3 < o3 - c4 * (1 - i3) / 2)
                      return function(t4) {
                        return B(q2) < B(t4) ? 1 : -1;
                      }(e3);
                  }
                  if ((n3 = n3 || a3) && (s3 < t3 + c4 * r3 / 2 || o3 - c4 * r3 / 2 < s3))
                    return t3 + c4 / 2 < s3 ? 1 : -1;
                  return 0;
                }(n2, l2, w2, r2, D3 ? 1 : e2.swapThreshold, e2.invertedSwapThreshold == null ? e2.swapThreshold : e2.invertedSwapThreshold, St2, gt2 === l2)) !== 0)
                  for (var _2 = B(q2); (y3 = V2.children[_2 -= v2]) && (P(y3, "display") === "none" || y3 === Z); )
                    ;
                if (v2 === 0 || y3 === l2)
                  return O2(false);
                mt2 = v2;
                var C2 = (gt2 = l2).nextElementSibling, E2 = false, D3 = Ft2($3, a2, q2, o2, l2, w2, n2, E2 = v2 === 1);
                if (D3 !== false)
                  return D3 !== 1 && D3 !== -1 || (E2 = D3 === 1), Ct2 = true, setTimeout(Ht, 30), x2(), E2 && !C2 ? a2.appendChild(q2) : l2.parentNode.insertBefore(q2, E2 ? C2 : l2), g2 && F2(g2, 0, m2 - g2.scrollTop), V2 = q2.parentNode, b2 === void 0 || St2 || (vt = Math.abs(b2 - k(l2)[S2])), A2(), O2(true);
              }
              if (a2.contains(q2))
                return O2(false);
            }
            return false;
          }
          function T2(t3, e3) {
            z2(t3, f2, M2({ evt: n2, isOwner: u2, axis: r2 ? "vertical" : "horizontal", revert: i2, dragRect: o2, targetRect: w2, canSort: d3, fromSortable: h3, target: l2, completed: O2, onMove: function(t4, e4) {
              return Ft2($3, a2, q2, o2, t4, k(t4), n2, e4);
            }, changed: A2 }, e3));
          }
          function x2() {
            T2("dragOverAnimationCapture"), f2.captureAnimationState(), f2 !== h3 && h3.captureAnimationState();
          }
          function O2(t3) {
            return T2("dragOverCompleted", { insertion: t3 }), t3 && (u2 ? c3._hideClone() : c3._showClone(f2), f2 !== h3 && (I(q2, (lt2 || c3).options.ghostClass, false), I(q2, e2.ghostClass, true)), lt2 !== f2 && f2 !== Bt2.active ? lt2 = f2 : f2 === Bt2.active && lt2 && (lt2 = null), h3 === f2 && (f2._ignoreWhileAnimating = l2), f2.animateAll(function() {
              T2("dragOverAnimationComplete"), f2._ignoreWhileAnimating = null;
            }), f2 !== h3 && (h3.animateAll(), h3._ignoreWhileAnimating = null)), (l2 === q2 && !q2.animated || l2 === a2 && !l2.animated) && (gt2 = null), e2.dragoverBubble || n2.rootEl || l2 === document || (q2.parentNode[j2]._isOutsideThisEl(n2.target), t3 || Xt(n2)), !e2.dragoverBubble && n2.stopPropagation && n2.stopPropagation(), p2 = true;
          }
          function A2() {
            ot2 = B(q2), rt2 = B(q2, e2.draggable), U({ sortable: f2, name: "change", toEl: a2, newIndex: ot2, newDraggableIndex: rt2, originalEvent: n2 });
          }
        }, _ignoreWhileAnimating: null, _offMoveEvents: function() {
          f(document, "mousemove", this._onTouchMove), f(document, "touchmove", this._onTouchMove), f(document, "pointermove", this._onTouchMove), f(document, "dragover", Xt), f(document, "mousemove", Xt), f(document, "touchmove", Xt);
        }, _offUpEvents: function() {
          var t2 = this.el.ownerDocument;
          f(t2, "mouseup", this._onDrop), f(t2, "touchend", this._onDrop), f(t2, "pointerup", this._onDrop), f(t2, "touchcancel", this._onDrop), f(document, "selectstart", this);
        }, _onDrop: function(t2) {
          var e2 = this.el, n2 = this.options;
          ot2 = B(q2), rt2 = B(q2, n2.draggable), z2("drop", this, { evt: t2 }), V2 = q2 && q2.parentNode, ot2 = B(q2), rt2 = B(q2, n2.draggable), Bt2.eventCanceled || (Dt = St2 = yt = false, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), Kt2(this.cloneId), Kt2(this._dragStartId), this.nativeDraggable && (f(document, "drop", this), f(e2, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), u && P(document.body, "user-select", ""), P(q2, "transform", ""), t2 && (pt2 && (t2.cancelable && t2.preventDefault(), n2.dropBubble || t2.stopPropagation()), Z && Z.parentNode && Z.parentNode.removeChild(Z), ($3 === V2 || lt2 && lt2.lastPutMode !== "clone") && tt && tt.parentNode && tt.parentNode.removeChild(tt), q2 && (this.nativeDraggable && f(q2, "dragend", this), jt2(q2), q2.style["will-change"] = "", pt2 && !yt && I(q2, (lt2 || this).options.ghostClass, false), I(q2, this.options.chosenClass, false), U({ sortable: this, name: "unchoose", toEl: V2, newIndex: null, newDraggableIndex: null, originalEvent: t2 }), $3 !== V2 ? (0 <= ot2 && (U({ rootEl: V2, name: "add", toEl: V2, fromEl: $3, originalEvent: t2 }), U({ sortable: this, name: "remove", toEl: V2, originalEvent: t2 }), U({ rootEl: V2, name: "sort", toEl: V2, fromEl: $3, originalEvent: t2 }), U({ sortable: this, name: "sort", toEl: V2, originalEvent: t2 })), lt2 && lt2.save()) : ot2 !== nt && 0 <= ot2 && (U({ sortable: this, name: "update", toEl: V2, originalEvent: t2 }), U({ sortable: this, name: "sort", toEl: V2, originalEvent: t2 })), Bt2.active && (ot2 != null && ot2 !== -1 || (ot2 = nt, rt2 = it), U({ sortable: this, name: "end", toEl: V2, originalEvent: t2 }), this.save())))), this._nulling();
        }, _nulling: function() {
          z2("nulling", this), $3 = q2 = V2 = Z = Q2 = tt = J2 = et = st2 = ct2 = pt2 = ot2 = rt2 = nt = it = gt2 = mt2 = lt2 = at2 = Bt2.dragged = Bt2.ghost = Bt2.clone = Bt2.active = null, Tt2.forEach(function(t2) {
            t2.checked = true;
          }), Tt2.length = ut2 = dt2 = 0;
        }, handleEvent: function(t2) {
          switch (t2.type) {
            case "drop":
            case "dragend":
              this._onDrop(t2);
              break;
            case "dragenter":
            case "dragover":
              q2 && (this._onDragOver(t2), function(t3) {
                t3.dataTransfer && (t3.dataTransfer.dropEffect = "move");
                t3.cancelable && t3.preventDefault();
              }(t2));
              break;
            case "selectstart":
              t2.preventDefault();
          }
        }, toArray: function() {
          for (var t2, e2 = [], n2 = this.el.children, o2 = 0, i2 = n2.length, r2 = this.options; o2 < i2; o2++)
            N(t2 = n2[o2], r2.draggable, this.el, false) && e2.push(t2.getAttribute(r2.dataIdAttr) || function(t3) {
              var e3 = t3.tagName + t3.className + t3.src + t3.href + t3.textContent, n3 = e3.length, o3 = 0;
              for (; n3--; )
                o3 += e3.charCodeAt(n3);
              return o3.toString(36);
            }(t2));
          return e2;
        }, sort: function(t2, e2) {
          var n2 = {}, o2 = this.el;
          this.toArray().forEach(function(t3, e3) {
            e3 = o2.children[e3];
            N(e3, this.options.draggable, o2, false) && (n2[t3] = e3);
          }, this), e2 && this.captureAnimationState(), t2.forEach(function(t3) {
            n2[t3] && (o2.removeChild(n2[t3]), o2.appendChild(n2[t3]));
          }), e2 && this.animateAll();
        }, save: function() {
          var t2 = this.options.store;
          t2 && t2.set && t2.set(this);
        }, closest: function(t2, e2) {
          return N(t2, e2 || this.options.draggable, this.el, false);
        }, option: function(t2, e2) {
          var n2 = this.options;
          if (e2 === void 0)
            return n2[t2];
          var o2 = K2.modifyOption(this, t2, e2);
          n2[t2] = o2 !== void 0 ? o2 : e2, t2 === "group" && Pt2(n2);
        }, destroy: function() {
          z2("destroy", this);
          var t2 = this.el;
          t2[j2] = null, f(t2, "mousedown", this._onTapStart), f(t2, "touchstart", this._onTapStart), f(t2, "pointerdown", this._onTapStart), this.nativeDraggable && (f(t2, "dragover", this), f(t2, "dragenter", this)), Array.prototype.forEach.call(t2.querySelectorAll("[draggable]"), function(t3) {
            t3.removeAttribute("draggable");
          }), this._onDrop(), this._disableDelayedDragEvents(), Et.splice(Et.indexOf(this.el), 1), this.el = t2 = null;
        }, _hideClone: function() {
          et || (z2("hideClone", this), Bt2.eventCanceled || (P(tt, "display", "none"), this.options.removeCloneOnHide && tt.parentNode && tt.parentNode.removeChild(tt), et = true));
        }, _showClone: function(t2) {
          t2.lastPutMode === "clone" ? et && (z2("showClone", this), Bt2.eventCanceled || (q2.parentNode != $3 || this.options.group.revertClone ? Q2 ? $3.insertBefore(tt, Q2) : $3.appendChild(tt) : $3.insertBefore(tt, q2), this.options.group.revertClone && this.animate(q2, tt), P(tt, "display", ""), et = false)) : this._hideClone();
        } }, xt && h2(document, "touchmove", function(t2) {
          (Bt2.active || yt) && t2.cancelable && t2.preventDefault();
        }), Bt2.utils = { on: h2, off: f, css: P, find: b, is: function(t2, e2) {
          return !!N(t2, e2, t2, false);
        }, extend: function(t2, e2) {
          if (t2 && e2)
            for (var n2 in e2)
              e2.hasOwnProperty(n2) && (t2[n2] = e2[n2]);
          return t2;
        }, throttle: S, closest: N, toggleClass: I, clone: _, index: B, nextTick: Lt2, cancelNextTick: Kt2, detectDirection: It, getChild: X2 }, Bt2.get = function(t2) {
          return t2[j2];
        }, Bt2.mount = function() {
          for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++)
            e2[n2] = arguments[n2];
          (e2 = e2[0].constructor === Array ? e2[0] : e2).forEach(function(t3) {
            if (!t3.prototype || !t3.prototype.constructor)
              throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(t3));
            t3.utils && (Bt2.utils = M2(M2({}, Bt2.utils), t3.utils)), K2.mount(t3);
          });
        }, Bt2.create = function(t2, e2) {
          return new Bt2(t2, e2);
        };
        var Wt, zt2, Gt, Ut, qt2, Vt2, Zt = [], $t = !(Bt2.version = "1.15.0");
        function Qt2() {
          Zt.forEach(function(t2) {
            clearInterval(t2.pid);
          }), Zt = [];
        }
        function Jt2() {
          clearInterval(Vt2);
        }
        var te2, ee2 = S(function(n2, t2, e2, o2) {
          if (t2.scroll) {
            var i2, r2 = (n2.touches ? n2.touches[0] : n2).clientX, a2 = (n2.touches ? n2.touches[0] : n2).clientY, l2 = t2.scrollSensitivity, s2 = t2.scrollSpeed, c3 = O(), u2 = false;
            zt2 !== e2 && (zt2 = e2, Qt2(), Wt = t2.scroll, i2 = t2.scrollFn, Wt === true && (Wt = A(e2, true)));
            var d3 = 0, h3 = Wt;
            do {
              var f2 = h3, p2 = k(f2), g2 = p2.top, m2 = p2.bottom, v2 = p2.left, b2 = p2.right, y3 = p2.width, w2 = p2.height, E2 = void 0, D3 = void 0, S2 = f2.scrollWidth, _2 = f2.scrollHeight, C2 = P(f2), T2 = f2.scrollLeft, p2 = f2.scrollTop, D3 = f2 === c3 ? (E2 = y3 < S2 && (C2.overflowX === "auto" || C2.overflowX === "scroll" || C2.overflowX === "visible"), w2 < _2 && (C2.overflowY === "auto" || C2.overflowY === "scroll" || C2.overflowY === "visible")) : (E2 = y3 < S2 && (C2.overflowX === "auto" || C2.overflowX === "scroll"), w2 < _2 && (C2.overflowY === "auto" || C2.overflowY === "scroll")), T2 = E2 && (Math.abs(b2 - r2) <= l2 && T2 + y3 < S2) - (Math.abs(v2 - r2) <= l2 && !!T2), p2 = D3 && (Math.abs(m2 - a2) <= l2 && p2 + w2 < _2) - (Math.abs(g2 - a2) <= l2 && !!p2);
              if (!Zt[d3])
                for (var x2 = 0; x2 <= d3; x2++)
                  Zt[x2] || (Zt[x2] = {});
              Zt[d3].vx == T2 && Zt[d3].vy == p2 && Zt[d3].el === f2 || (Zt[d3].el = f2, Zt[d3].vx = T2, Zt[d3].vy = p2, clearInterval(Zt[d3].pid), T2 == 0 && p2 == 0 || (u2 = true, Zt[d3].pid = setInterval(function() {
                o2 && this.layer === 0 && Bt2.active._onTouchMove(qt2);
                var t3 = Zt[this.layer].vy ? Zt[this.layer].vy * s2 : 0, e3 = Zt[this.layer].vx ? Zt[this.layer].vx * s2 : 0;
                typeof i2 == "function" && i2.call(Bt2.dragged.parentNode[j2], e3, t3, n2, qt2, Zt[this.layer].el) !== "continue" || F2(Zt[this.layer].el, e3, t3);
              }.bind({ layer: d3 }), 24))), d3++;
            } while (t2.bubbleScroll && h3 !== c3 && (h3 = A(h3, false)));
            $t = u2;
          }
        }, 30), c2 = function(t2) {
          var e2 = t2.originalEvent, n2 = t2.putSortable, o2 = t2.dragEl, i2 = t2.activeSortable, r2 = t2.dispatchSortableEvent, a2 = t2.hideGhostForTarget, t2 = t2.unhideGhostForTarget;
          e2 && (i2 = n2 || i2, a2(), e2 = e2.changedTouches && e2.changedTouches.length ? e2.changedTouches[0] : e2, e2 = document.elementFromPoint(e2.clientX, e2.clientY), t2(), i2 && !i2.el.contains(e2) && (r2("spill"), this.onSpill({ dragEl: o2, putSortable: n2 })));
        };
        function ne() {
        }
        function oe() {
        }
        ne.prototype = { startIndex: null, dragStart: function(t2) {
          t2 = t2.oldDraggableIndex;
          this.startIndex = t2;
        }, onSpill: function(t2) {
          var e2 = t2.dragEl, n2 = t2.putSortable;
          this.sortable.captureAnimationState(), n2 && n2.captureAnimationState();
          t2 = X2(this.sortable.el, this.startIndex, this.options);
          t2 ? this.sortable.el.insertBefore(e2, t2) : this.sortable.el.appendChild(e2), this.sortable.animateAll(), n2 && n2.animateAll();
        }, drop: c2 }, a(ne, { pluginName: "revertOnSpill" }), oe.prototype = { onSpill: function(t2) {
          var e2 = t2.dragEl, t2 = t2.putSortable || this.sortable;
          t2.captureAnimationState(), e2.parentNode && e2.parentNode.removeChild(e2), t2.animateAll();
        }, drop: c2 }, a(oe, { pluginName: "removeOnSpill" });
        var ie2, re, ae2, le, se, ce = [], ue2 = [], de2 = false, he = false, fe = false;
        function pe2(n2, o2) {
          ue2.forEach(function(t2, e2) {
            e2 = o2.children[t2.sortableIndex + (n2 ? Number(e2) : 0)];
            e2 ? o2.insertBefore(t2, e2) : o2.appendChild(t2);
          });
        }
        function ge2() {
          ce.forEach(function(t2) {
            t2 !== ae2 && t2.parentNode && t2.parentNode.removeChild(t2);
          });
        }
        return Bt2.mount(new function() {
          function t2() {
            for (var t3 in this.defaults = { scroll: true, forceAutoScrollFallback: false, scrollSensitivity: 30, scrollSpeed: 10, bubbleScroll: true }, this)
              t3.charAt(0) === "_" && typeof this[t3] == "function" && (this[t3] = this[t3].bind(this));
          }
          return t2.prototype = { dragStarted: function(t3) {
            t3 = t3.originalEvent;
            this.sortable.nativeDraggable ? h2(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? h2(document, "pointermove", this._handleFallbackAutoScroll) : t3.touches ? h2(document, "touchmove", this._handleFallbackAutoScroll) : h2(document, "mousemove", this._handleFallbackAutoScroll);
          }, dragOverCompleted: function(t3) {
            t3 = t3.originalEvent;
            this.options.dragOverBubble || t3.rootEl || this._handleAutoScroll(t3);
          }, drop: function() {
            this.sortable.nativeDraggable ? f(document, "dragover", this._handleAutoScroll) : (f(document, "pointermove", this._handleFallbackAutoScroll), f(document, "touchmove", this._handleFallbackAutoScroll), f(document, "mousemove", this._handleFallbackAutoScroll)), Jt2(), Qt2(), clearTimeout(g), g = void 0;
          }, nulling: function() {
            qt2 = zt2 = Wt = $t = Vt2 = Gt = Ut = null, Zt.length = 0;
          }, _handleFallbackAutoScroll: function(t3) {
            this._handleAutoScroll(t3, true);
          }, _handleAutoScroll: function(e2, n2) {
            var o2, i2 = this, r2 = (e2.touches ? e2.touches[0] : e2).clientX, a2 = (e2.touches ? e2.touches[0] : e2).clientY, t3 = document.elementFromPoint(r2, a2);
            qt2 = e2, n2 || this.options.forceAutoScrollFallback || w || y2 || u ? (ee2(e2, this.options, t3, n2), o2 = A(t3, true), !$t || Vt2 && r2 === Gt && a2 === Ut || (Vt2 && Jt2(), Vt2 = setInterval(function() {
              var t4 = A(document.elementFromPoint(r2, a2), true);
              t4 !== o2 && (o2 = t4, Qt2()), ee2(e2, i2.options, t4, n2);
            }, 10), Gt = r2, Ut = a2)) : this.options.bubbleScroll && A(t3, true) !== O() ? ee2(e2, this.options, A(t3, false), false) : Qt2();
          } }, a(t2, { pluginName: "scroll", initializeByDefault: true });
        }()), Bt2.mount(oe, ne), Bt2.mount(new function() {
          function t2() {
            this.defaults = { swapClass: "sortable-swap-highlight" };
          }
          return t2.prototype = { dragStart: function(t3) {
            t3 = t3.dragEl;
            te2 = t3;
          }, dragOverValid: function(t3) {
            var e2 = t3.completed, n2 = t3.target, o2 = t3.onMove, i2 = t3.activeSortable, r2 = t3.changed, a2 = t3.cancel;
            i2.options.swap && (t3 = this.sortable.el, i2 = this.options, n2 && n2 !== t3 && (t3 = te2, te2 = o2(n2) !== false ? (I(n2, i2.swapClass, true), n2) : null, t3 && t3 !== te2 && I(t3, i2.swapClass, false)), r2(), e2(true), a2());
          }, drop: function(t3) {
            var e2, n2, o2 = t3.activeSortable, i2 = t3.putSortable, r2 = t3.dragEl, a2 = i2 || this.sortable, l2 = this.options;
            te2 && I(te2, l2.swapClass, false), te2 && (l2.swap || i2 && i2.options.swap) && r2 !== te2 && (a2.captureAnimationState(), a2 !== o2 && o2.captureAnimationState(), n2 = te2, t3 = (e2 = r2).parentNode, l2 = n2.parentNode, t3 && l2 && !t3.isEqualNode(n2) && !l2.isEqualNode(e2) && (i2 = B(e2), r2 = B(n2), t3.isEqualNode(l2) && i2 < r2 && r2++, t3.insertBefore(n2, t3.children[i2]), l2.insertBefore(e2, l2.children[r2])), a2.animateAll(), a2 !== o2 && o2.animateAll());
          }, nulling: function() {
            te2 = null;
          } }, a(t2, { pluginName: "swap", eventProperties: function() {
            return { swapItem: te2 };
          } });
        }()), Bt2.mount(new function() {
          function t2(o2) {
            for (var t3 in this)
              t3.charAt(0) === "_" && typeof this[t3] == "function" && (this[t3] = this[t3].bind(this));
            o2.options.avoidImplicitDeselect || (o2.options.supportPointer ? h2(document, "pointerup", this._deselectMultiDrag) : (h2(document, "mouseup", this._deselectMultiDrag), h2(document, "touchend", this._deselectMultiDrag))), h2(document, "keydown", this._checkKeyDown), h2(document, "keyup", this._checkKeyUp), this.defaults = { selectedClass: "sortable-selected", multiDragKey: null, avoidImplicitDeselect: false, setData: function(t4, e2) {
              var n2 = "";
              ce.length && re === o2 ? ce.forEach(function(t5, e3) {
                n2 += (e3 ? ", " : "") + t5.textContent;
              }) : n2 = e2.textContent, t4.setData("Text", n2);
            } };
          }
          return t2.prototype = { multiDragKeyDown: false, isMultiDrag: false, delayStartGlobal: function(t3) {
            t3 = t3.dragEl;
            ae2 = t3;
          }, delayEnded: function() {
            this.isMultiDrag = ~ce.indexOf(ae2);
          }, setupClone: function(t3) {
            var e2 = t3.sortable, t3 = t3.cancel;
            if (this.isMultiDrag) {
              for (var n2 = 0; n2 < ce.length; n2++)
                ue2.push(_(ce[n2])), ue2[n2].sortableIndex = ce[n2].sortableIndex, ue2[n2].draggable = false, ue2[n2].style["will-change"] = "", I(ue2[n2], this.options.selectedClass, false), ce[n2] === ae2 && I(ue2[n2], this.options.chosenClass, false);
              e2._hideClone(), t3();
            }
          }, clone: function(t3) {
            var e2 = t3.sortable, n2 = t3.rootEl, o2 = t3.dispatchSortableEvent, t3 = t3.cancel;
            this.isMultiDrag && (this.options.removeCloneOnHide || ce.length && re === e2 && (pe2(true, n2), o2("clone"), t3()));
          }, showClone: function(t3) {
            var e2 = t3.cloneNowShown, n2 = t3.rootEl, t3 = t3.cancel;
            this.isMultiDrag && (pe2(false, n2), ue2.forEach(function(t4) {
              P(t4, "display", "");
            }), e2(), se = false, t3());
          }, hideClone: function(t3) {
            var e2 = this, n2 = (t3.sortable, t3.cloneNowHidden), t3 = t3.cancel;
            this.isMultiDrag && (ue2.forEach(function(t4) {
              P(t4, "display", "none"), e2.options.removeCloneOnHide && t4.parentNode && t4.parentNode.removeChild(t4);
            }), n2(), se = true, t3());
          }, dragStartGlobal: function(t3) {
            t3.sortable;
            !this.isMultiDrag && re && re.multiDrag._deselectMultiDrag(), ce.forEach(function(t4) {
              t4.sortableIndex = B(t4);
            }), ce = ce.sort(function(t4, e2) {
              return t4.sortableIndex - e2.sortableIndex;
            }), fe = true;
          }, dragStarted: function(t3) {
            var e2, n2 = this, t3 = t3.sortable;
            this.isMultiDrag && (this.options.sort && (t3.captureAnimationState(), this.options.animation && (ce.forEach(function(t4) {
              t4 !== ae2 && P(t4, "position", "absolute");
            }), e2 = k(ae2, false, true, true), ce.forEach(function(t4) {
              t4 !== ae2 && C(t4, e2);
            }), de2 = he = true)), t3.animateAll(function() {
              de2 = he = false, n2.options.animation && ce.forEach(function(t4) {
                T(t4);
              }), n2.options.sort && ge2();
            }));
          }, dragOver: function(t3) {
            var e2 = t3.target, n2 = t3.completed, t3 = t3.cancel;
            he && ~ce.indexOf(e2) && (n2(false), t3());
          }, revert: function(t3) {
            var n2, o2, e2 = t3.fromSortable, i2 = t3.rootEl, r2 = t3.sortable, a2 = t3.dragRect;
            1 < ce.length && (ce.forEach(function(t4) {
              r2.addAnimationState({ target: t4, rect: he ? k(t4) : a2 }), T(t4), t4.fromRect = a2, e2.removeAnimationState(t4);
            }), he = false, n2 = !this.options.removeCloneOnHide, o2 = i2, ce.forEach(function(t4, e3) {
              e3 = o2.children[t4.sortableIndex + (n2 ? Number(e3) : 0)];
              e3 ? o2.insertBefore(t4, e3) : o2.appendChild(t4);
            }));
          }, dragOverCompleted: function(t3) {
            var e2, n2 = t3.sortable, o2 = t3.isOwner, i2 = t3.insertion, r2 = t3.activeSortable, a2 = t3.parentEl, l2 = t3.putSortable, t3 = this.options;
            i2 && (o2 && r2._hideClone(), de2 = false, t3.animation && 1 < ce.length && (he || !o2 && !r2.options.sort && !l2) && (e2 = k(ae2, false, true, true), ce.forEach(function(t4) {
              t4 !== ae2 && (C(t4, e2), a2.appendChild(t4));
            }), he = true), o2 || (he || ge2(), 1 < ce.length ? (o2 = se, r2._showClone(n2), r2.options.animation && !se && o2 && ue2.forEach(function(t4) {
              r2.addAnimationState({ target: t4, rect: le }), t4.fromRect = le, t4.thisAnimationDuration = null;
            })) : r2._showClone(n2)));
          }, dragOverAnimationCapture: function(t3) {
            var e2 = t3.dragRect, n2 = t3.isOwner, t3 = t3.activeSortable;
            ce.forEach(function(t4) {
              t4.thisAnimationDuration = null;
            }), t3.options.animation && !n2 && t3.multiDrag.isMultiDrag && (le = a({}, e2), e2 = v(ae2, true), le.top -= e2.f, le.left -= e2.e);
          }, dragOverAnimationComplete: function() {
            he && (he = false, ge2());
          }, drop: function(t3) {
            var e2 = t3.originalEvent, n2 = t3.rootEl, o2 = t3.parentEl, i2 = t3.sortable, r2 = t3.dispatchSortableEvent, a2 = t3.oldIndex, l2 = t3.putSortable, s2 = l2 || this.sortable;
            if (e2) {
              var c3, u2, d3, h3 = this.options, f2 = o2.children;
              if (!fe)
                if (h3.multiDragKey && !this.multiDragKeyDown && this._deselectMultiDrag(), I(ae2, h3.selectedClass, !~ce.indexOf(ae2)), ~ce.indexOf(ae2))
                  ce.splice(ce.indexOf(ae2), 1), ie2 = null, W2({ sortable: i2, rootEl: n2, name: "deselect", targetEl: ae2, originalEvent: e2 });
                else {
                  if (ce.push(ae2), W2({ sortable: i2, rootEl: n2, name: "select", targetEl: ae2, originalEvent: e2 }), e2.shiftKey && ie2 && i2.el.contains(ie2)) {
                    var p2 = B(ie2), t3 = B(ae2);
                    if (~p2 && ~t3 && p2 !== t3)
                      for (var g2, m2 = p2 < t3 ? (g2 = p2, t3) : (g2 = t3, p2 + 1); g2 < m2; g2++)
                        ~ce.indexOf(f2[g2]) || (I(f2[g2], h3.selectedClass, true), ce.push(f2[g2]), W2({ sortable: i2, rootEl: n2, name: "select", targetEl: f2[g2], originalEvent: e2 }));
                  } else
                    ie2 = ae2;
                  re = s2;
                }
              fe && this.isMultiDrag && (he = false, (o2[j2].options.sort || o2 !== n2) && 1 < ce.length && (c3 = k(ae2), u2 = B(ae2, ":not(." + this.options.selectedClass + ")"), !de2 && h3.animation && (ae2.thisAnimationDuration = null), s2.captureAnimationState(), de2 || (h3.animation && (ae2.fromRect = c3, ce.forEach(function(t4) {
                var e3;
                t4.thisAnimationDuration = null, t4 !== ae2 && (e3 = he ? k(t4) : c3, t4.fromRect = e3, s2.addAnimationState({ target: t4, rect: e3 }));
              })), ge2(), ce.forEach(function(t4) {
                f2[u2] ? o2.insertBefore(t4, f2[u2]) : o2.appendChild(t4), u2++;
              }), a2 === B(ae2) && (d3 = false, ce.forEach(function(t4) {
                t4.sortableIndex !== B(t4) && (d3 = true);
              }), d3 && r2("update"))), ce.forEach(function(t4) {
                T(t4);
              }), s2.animateAll()), re = s2), (n2 === o2 || l2 && l2.lastPutMode !== "clone") && ue2.forEach(function(t4) {
                t4.parentNode && t4.parentNode.removeChild(t4);
              });
            }
          }, nullingGlobal: function() {
            this.isMultiDrag = fe = false, ue2.length = 0;
          }, destroyGlobal: function() {
            this._deselectMultiDrag(), f(document, "pointerup", this._deselectMultiDrag), f(document, "mouseup", this._deselectMultiDrag), f(document, "touchend", this._deselectMultiDrag), f(document, "keydown", this._checkKeyDown), f(document, "keyup", this._checkKeyUp);
          }, _deselectMultiDrag: function(t3) {
            if (!(fe !== void 0 && fe || re !== this.sortable || t3 && N(t3.target, this.options.draggable, this.sortable.el, false) || t3 && t3.button !== 0))
              for (; ce.length; ) {
                var e2 = ce[0];
                I(e2, this.options.selectedClass, false), ce.shift(), W2({ sortable: this.sortable, rootEl: this.sortable.el, name: "deselect", targetEl: e2, originalEvent: t3 });
              }
          }, _checkKeyDown: function(t3) {
            t3.key === this.options.multiDragKey && (this.multiDragKeyDown = true);
          }, _checkKeyUp: function(t3) {
            t3.key === this.options.multiDragKey && (this.multiDragKeyDown = false);
          } }, a(t2, { pluginName: "multiDrag", utils: { select: function(t3) {
            var e2 = t3.parentNode[j2];
            e2 && e2.options.multiDrag && !~ce.indexOf(t3) && (re && re !== e2 && (re.multiDrag._deselectMultiDrag(), re = e2), I(t3, e2.options.selectedClass, true), ce.push(t3));
          }, deselect: function(t3) {
            var e2 = t3.parentNode[j2], n2 = ce.indexOf(t3);
            e2 && e2.options.multiDrag && ~n2 && (I(t3, e2.options.selectedClass, false), ce.splice(n2, 1));
          } }, eventProperties: function() {
            var n2 = this, o2 = [], i2 = [];
            return ce.forEach(function(t3) {
              var e2;
              o2.push({ multiDragElement: t3, index: t3.sortableIndex }), e2 = he && t3 !== ae2 ? -1 : he ? B(t3, ":not(." + n2.options.selectedClass + ")") : B(t3), i2.push({ multiDragElement: t3, index: e2 });
            }), { items: r(ce), clones: [].concat(ue2), oldIndicies: o2, newIndicies: i2 };
          }, optionListeners: { multiDragKey: function(t3) {
            return (t3 = t3.toLowerCase()) === "ctrl" ? t3 = "Control" : 1 < t3.length && (t3 = t3.charAt(0).toUpperCase() + t3.substr(1)), t3;
          } } });
        }()), Bt2;
      });
    }
  });

  // __tmp__/static/js/parsons.js
  var require_parsons = __commonJS({
    "__tmp__/static/js/parsons.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.initializeParsons = exports.get_parsons_code = exports.loadNextExercise = exports.loadParsonsExercise = void 0;
      var modal_1 = require_modal();
      var app_1 = require_app();
      var cm_editor_1 = require_cm_editor();
      var sortablejs_1 = __importDefault(require_Sortable_min());
      function loadParsonsExercise2(level, exercise) {
        $("#next_parson_button").hide();
        let parameters = new URLSearchParams(window.location.search);
        let url = "/parsons/get-exercise/" + level + "/" + exercise;
        if (parameters.has("keyword_language")) {
          url += "/" + parameters.get("keyword_language");
        }
        $.ajax({
          type: "GET",
          url,
          dataType: "json"
        }).done(function(response) {
          $("#parsons_container").show();
          $("#next_parson_button").attr("current_exercise", exercise);
          resetView();
          updateHeader(exercise);
          showExercise(response);
          updateNextExerciseButton(level, exercise);
        }).fail(function(err) {
          modal_1.modal.notifyError(err.responseText);
        });
      }
      exports.loadParsonsExercise = loadParsonsExercise2;
      function resetView() {
        (0, app_1.stopit)();
        if (Object.keys(editorDict).length === 0) {
          initializeParsons();
        }
        $("#output").empty();
        $(".parsons_goal_line_container").removeClass("border-green-500 border-red-500");
      }
      function updateHeader(exercise) {
        $(".parsons_header_text_container").hide();
        $(".step").removeClass("current");
        $("#parsons_header_text_" + exercise).show();
        $("#parsons_header_" + exercise).addClass("current");
      }
      var editorDict = {};
      function showExercise(response) {
        const code_lines = parse_code_string_into_dict(response.code);
        let keys = Object.keys(code_lines);
        $(".parsons_start_line_container").hide();
        $(".parsons_goal_line_container").hide();
        fisherYatesShuffle(keys);
        keys.forEach((key, i) => {
          const valueObj = code_lines[key];
          const counter = i + 1;
          const goalEditor = editorDict[i + 1];
          goalEditor.contents = valueObj;
          document.getElementById("parsons_line_data_" + counter).dataset["index"] = key;
          document.getElementById("parsons_line_data_" + counter).dataset["code"] = valueObj;
          $("#parsons_line_" + counter).show();
        });
        let parsons = document.getElementById("parsons_code_container");
        sortablejs_1.default.create(parsons, {
          animation: 150,
          onStart: () => {
            $(".parsons_goal_line_container").removeClass("border-green-500 border-red-500");
          }
        });
        $("#parsons_explanation_story").text(response.story);
      }
      function updateNextExerciseButton(level, exercise) {
        const max_exercise = $("#next_parson_button").attr("max_exercise") || 1;
        if (exercise < max_exercise) {
          $("#next_parson_button").on("click", () => loadParsonsExercise2(level, exercise + 1));
        } else {
          $("#next_parson_button").off("click");
        }
      }
      function loadNextExercise() {
      }
      exports.loadNextExercise = loadNextExercise;
      function parse_code_string_into_dict(code) {
        const splitted_code = code.split(/\r?\n/).filter((e) => String(e).trim());
        let code_lines = {};
        for (let index = 0; index < splitted_code.length; index++) {
          code_lines[index + 1] = splitted_code[index];
        }
        return code_lines;
      }
      function get_parsons_code() {
        let code = "";
        let order = new Array();
        let mistake = false;
        document.querySelectorAll("#parsons_code_container > div > div").forEach((element, key) => {
          if (!$(element).is(":visible")) {
            return;
          }
          const parent = element.parentElement;
          let text = element.dataset["code"] || "";
          if (text.length > 1) {
            code += text + "\n";
          }
          parent.classList.remove("border-green-500");
          parent.classList.remove("border-red-500");
          const index = element.dataset["index"] || 999;
          if (index == key + 1) {
            parent.classList.add("border-green-500");
          } else {
            mistake = true;
            parent.classList.add("border-red-500");
          }
          order.push(index);
        });
        (0, app_1.store_parsons_attempt)(order, !mistake);
        if (mistake) {
          return "";
        }
        return code.replace(/ +$/mg, "");
      }
      exports.get_parsons_code = get_parsons_code;
      function fisherYatesShuffle(xs) {
        for (let i = xs.length - 1; i >= 1; i--) {
          const j2 = Math.floor(Math.random() * i);
          const h2 = xs[j2];
          xs[j2] = xs[i];
          xs[i] = h2;
        }
      }
      function initializeParsons() {
        if (Object.keys(editorDict).length > 0) {
          return;
        }
        const editorCreator = new cm_editor_1.HedyCodeMirrorEditorCreator();
        const parsonCodeContainers = document.querySelectorAll("#parsons_code_container > div > pre");
        parsonCodeContainers.forEach((container, i) => {
          const editor = editorCreator.initializeReadOnlyEditor(container, "ltr");
          editorDict[i + 1] = editor;
        });
      }
      exports.initializeParsons = initializeParsons;
    }
  });

  // __tmp__/static/js/browser-helpers/on-element-becomes-visible.js
  var require_on_element_becomes_visible = __commonJS({
    "__tmp__/static/js/browser-helpers/on-element-becomes-visible.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.onElementBecomesVisible = exports.checkNow = void 0;
      var SCROLL_HANDLERS = new Array();
      function isInView(elem) {
        var docViewTop = $(window).scrollTop();
        var docViewBottom = docViewTop + $(window).height();
        var elemTop = $(elem).offset().top;
        return elemTop <= docViewBottom && elemTop >= docViewTop;
      }
      function checkNow() {
        for (let i = 0; i < SCROLL_HANDLERS.length; ) {
          const [element, handler] = SCROLL_HANDLERS[i];
          if (isInView(element)) {
            handler();
            SCROLL_HANDLERS.splice(i, 1);
          } else {
            i += 1;
          }
        }
      }
      exports.checkNow = checkNow;
      $(window).on("scroll", checkNow);
      function onElementBecomesVisible(element, handler) {
        if (isInView(element)) {
          handler();
        } else {
          SCROLL_HANDLERS.push([element, handler]);
        }
      }
      exports.onElementBecomesVisible = onElementBecomesVisible;
    }
  });

  // __tmp__/static/js/ace-editor.js
  var require_ace_editor = __commonJS({
    "__tmp__/static/js/ace-editor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HedyAceEditor = exports.HedyAceEditorCreator = void 0;
      var app_1 = require_app();
      var client_messages_1 = require_client_messages();
      var editor_1 = require_editor();
      var event_emitter_1 = require_event_emitter();
      var modal_1 = require_modal();
      var MOVE_CURSOR_TO_END = 1;
      var BP_DISABLED_LINE = "ace_breakpoint";
      var HedyAceEditorCreator = class {
        initializeEditorWithGutter($editor, editorType, dir = "ltr") {
          let editor = new HedyAceEditor($editor.get(0), $editor.data("readonly"), editorType, dir);
          return editor;
        }
        initializeReadOnlyEditor(preview, dir = "ltr") {
          let editorType;
          if ($(preview).hasClass("common-mistakes")) {
            editorType = editor_1.EditorType.COMMON_MISTAKES;
          } else if ($(preview).hasClass("cheatsheet")) {
            editorType = editor_1.EditorType.CHEATSHEET;
          } else if ($(preview).hasClass("parsons")) {
            editorType = editor_1.EditorType.PARSONS;
          } else {
            editorType = editor_1.EditorType.EXAMPLE;
          }
          return new HedyAceEditor(preview, true, editorType, dir);
        }
      };
      exports.HedyAceEditorCreator = HedyAceEditorCreator;
      var HedyAceEditor = class {
        constructor(element, isReadOnly, editorType, dir = "ltr") {
          this.editorEvent = new event_emitter_1.EventEmitter({
            change: true,
            guttermousedown: true,
            changeBreakpoint: true,
            click: true
          });
          this.markerClasses = new Map();
          this.strikeMarkers = new Map();
          this._editor = ace.edit(element);
          this.isReadOnly = isReadOnly;
          this._editor.setTheme("ace/theme/monokai");
          if (isReadOnly) {
            this._editor.setValue(this._editor.getValue().trimRight(), -1);
            this._editor.renderer.$cursorLayer.element.style.display = "none";
            this._editor.setOptions({
              readOnly: editorType === editor_1.EditorType.MAIN,
              showGutter: false,
              showPrintMargin: false,
              highlightActiveLine: false
            });
            this._editor.renderer.setScrollMargin(3, 3, 10, 20);
            this._editor.setOptions({ maxLines: Infinity });
            if (editorType === editor_1.EditorType.CHEATSHEET) {
              this._editor.setOptions({ minLines: 1 });
            } else if (editorType === editor_1.EditorType.COMMON_MISTAKES) {
              this._editor.setOptions({
                showGutter: true,
                showPrintMargin: true,
                highlightActiveLine: true,
                minLines: 5
              });
            } else if (editorType === editor_1.EditorType.PARSONS) {
              this._editor.setOptions({
                minLines: 1,
                showGutter: false,
                showPrintMargin: false,
                highlightActiveLine: false
              });
            } else if (editorType === editor_1.EditorType.EXAMPLE) {
              this._editor.setOptions({ minLines: 2 });
            }
          } else {
            if (editorType === editor_1.EditorType.MAIN) {
              this._editor.setShowPrintMargin(false);
              this._editor.renderer.setScrollMargin(0, 0, 0, 20);
            }
          }
          if (app_1.theLevel) {
            this.setHighlighterForLevel(app_1.theLevel);
          }
          if (dir === "rtl") {
            this._editor.setOptions({ rtl: true });
          }
        }
        setHighlighterForLevel(level) {
          const mode = this.getHighlighter(level);
          this._editor.session.setMode(mode);
        }
        get contents() {
          return this._editor.getValue();
        }
        set contents(content) {
          this._editor.setValue(content, MOVE_CURSOR_TO_END);
        }
        get isReadOnly() {
          return this._editor.getReadOnly();
        }
        set isReadOnly(isReadMode) {
          this._editor.setReadOnly(isReadMode);
        }
        resize() {
          console.warn("Oops! editor.resize() should not have been called anymore");
          this._editor.resize();
        }
        focus() {
          this._editor.focus();
        }
        clearErrors() {
          this._editor.session.clearAnnotations();
          for (const marker of this.findMarkers("editor-error")) {
            this.removeMarker(marker);
          }
        }
        moveCursorToEndOfFile() {
          this._editor.navigateFileEnd();
        }
        clearSelection() {
          this._editor.clearSelection();
        }
        clearBreakpoints() {
          this._editor.session.clearBreakpoints();
        }
        getDeactivatedLines() {
          return this._editor.session.getBreakpoints();
        }
        getHighlighter(level) {
          return `ace/mode/level${level}`;
        }
        trimTrailingSpace() {
          try {
            const whitespace = ace.require("ace/ext/whitespace");
            whitespace.trimTrailingSpace(this._editor.session, true);
          } catch (e) {
            console.error(e);
          }
        }
        on(key, handler) {
          const ret = this.editorEvent.on(key, handler);
          if (key == "changeBreakpoint") {
            this._editor.session.on(key, handler);
          } else {
            this._editor.addEventListener(key, handler);
          }
          return ret;
        }
        highlightError(row, col) {
          if (col === void 0) {
            this.addMarker(new ace.Range(row - 1, 1, row - 1, 2), "editor-error", "fullLine");
            return;
          }
          const length = this._editor.session.getLine(row - 1).slice(col - 1).split(/(\s+)/)[0].length;
          if (length > 0) {
            this.addMarker(new ace.Range(row - 1, col - 1, row - 1, col - 1 + length), "editor-error", "text");
          } else {
            this.addMarker(new ace.Range(row - 1, 1, row - 1, 2), "editor-error", "fullLine");
          }
        }
        setIncorrectLine(range, lineIndex) {
          const aceRange = new ace.Range(range.startLine - 1, range.startColumn - 1, range.endLine - 1, range.endColumn - 1);
          this.addMarker(aceRange, `ace_incorrect_hedy_code_${lineIndex}`, "text", true);
        }
        clearIncorrectLines() {
          const markers = this._editor.session.getMarkers(true);
          if (markers) {
            for (const index in markers) {
              let marker = markers[index];
              if (marker.clazz.includes("ace_incorrect_hedy_code")) {
                this.removeMarker(Number(index));
              }
            }
          }
        }
        setDebuggerCurrentLine(line, startPos, finishPos) {
          if (this.currentLineMarker) {
            this.removeMarker(this.currentLineMarker.id);
          }
          if (line === void 0) {
            this.currentLineMarker = void 0;
            return;
          }
          line = line - 1;
          let id;
          if (startPos === void 0 || finishPos === void 0) {
            id = this.addMarker(new ace.Range(line, 0, line, 999), "debugger-current-line", "fullLine");
          } else {
            id = this.addMarker(new ace.Range(line, startPos - 1, line, finishPos - 1), "debugger-current-line", "text");
          }
          this.currentLineMarker = { line, id };
        }
        strikethroughLines(lines) {
          const struckLines = new Set(lines);
          const noLongerStruck = Array.from(this.strikeMarkers.entries()).filter(([line, _]) => !struckLines.has(line));
          for (const [line, id] of noLongerStruck) {
            this.removeMarker(id);
            this.strikeMarkers.delete(line);
          }
          const newlyStruck = lines.filter((line) => !this.strikeMarkers.has(line));
          for (const line of newlyStruck) {
            const id = this.addMarker(new ace.Range(line, 0, line, 999), "disabled-line", "text", true);
            this.strikeMarkers.set(line, id);
          }
        }
        addMarker(range, klass, scope, inFront = false) {
          const id = this._editor.session.addMarker(range, klass, scope, inFront);
          this.markerClasses.set(id, klass);
          return id;
        }
        removeMarker(id) {
          this._editor.session.removeMarker(id);
          this.markerClasses.delete(id);
        }
        findMarkers(klass) {
          return Array.from(this.markerClasses.entries()).filter(([_, k]) => k === klass).map(([id, _]) => id);
        }
        getActiveContents(debugLine) {
          let code = this._editor.session.getValue();
          const breakpoints = this.getDeactivatedLines();
          if (code) {
            let lines = code.split("\n");
            if (debugLine != null) {
              lines = lines.slice(0, parseInt(debugLine) + 1);
            }
            for (let i = 0; i < lines.length; i++) {
              if (breakpoints[i] == BP_DISABLED_LINE) {
                lines[i] = "";
              }
            }
            code = lines.join("\n");
          }
          return code;
        }
        skipFaultyHandler() {
          $(document).on("click", "div[class*=ace_content], div[class*=ace_incorrect_hedy_code]", function(e) {
            let className = e.target.className;
            if ($("div[class*=ace_incorrect_hedy_code]")[0]) {
              if (className === "ace_content") {
                $("#okbox").hide();
                $("#warningbox").hide();
                $("#errorbox").hide();
              } else {
                let mapIndex = className;
                mapIndex = mapIndex.replace("ace_incorrect_hedy_code_", "");
                mapIndex = mapIndex.replace("ace_start ace_br15", "");
                let mapError = app_1.theGlobalSourcemap[Number(mapIndex)];
                $("#okbox").hide();
                $("#warningbox").hide();
                $("#errorbox").hide();
                modal_1.error.show(client_messages_1.ClientMessages["Transpile_error"], mapError.error);
              }
            }
          });
        }
      };
      exports.HedyAceEditor = HedyAceEditor;
    }
  });

  // __tmp__/static/js/debugging.js
  var require_debugging = __commonJS({
    "__tmp__/static/js/debugging.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.incrementDebugLine = exports.stopDebug = exports.resetDebug = exports.startDebug = exports.initializeDebugger = exports.load_variables = exports.show_variables = void 0;
      var ace_editor_1 = require_ace_editor();
      var app_1 = require_app();
      var highlighting_trad_json_1 = __importDefault(require_highlighting_trad());
      var syntaxModesRules_1 = require_syntaxModesRules();
      var theGlobalEditor;
      var theLevel;
      var theLanguage;
      var TRADUCTION;
      var variable_view = false;
      var step_debugger = false;
      var fullLineCommands = [
        "print",
        "echo",
        "assign",
        "sleep",
        "assign_list",
        "add",
        "remove",
        "ask",
        "command"
      ];
      var blockCommands = [
        "ifs",
        "ifelse",
        "ifpressed_else",
        "repeat",
        "ifpressed",
        "elses",
        "ifpressed_elses",
        "for_list",
        "for_loop",
        "while_loop",
        "elifs",
        "ifpressed_elifs"
      ];
      var ifRegex = "((__if__) *[^\n ]+ *((__is__)|(__in__)) *[^\n ]+) *.*";
      var repeatRegex = "((__repeat__) *[^\n ]+ *(__times__)) *[^\n ]+ *.+";
      var elseRegex = "^(__else__) *[^\n ]+.+$";
      function hide_if_no_variables() {
        if ($("#variables #variable-list li").length == 0) {
          $("#variable_button").hide();
        } else {
          $("#variable_button").show();
        }
      }
      function show_variables() {
        if (variable_view === true) {
          const variableList = $("#variable-list");
          if (variableList.hasClass("hidden")) {
            variableList.removeClass("hidden");
          }
        }
      }
      exports.show_variables = show_variables;
      function load_variables(variables) {
        if (variable_view === true) {
          variables = clean_variables(variables);
          const variableList = $("#variable-list");
          variableList.empty();
          for (const i in variables) {
            if (variables[i][1]) {
              variableList.append(`<li style=color:${variables[i][2]}>${variables[i][0]}: ${variables[i][1]}</li>`);
            }
          }
          hide_if_no_variables();
        }
      }
      exports.load_variables = load_variables;
      function special_style_for_variable(variable) {
        let result = "";
        let parsedVariable = parseInt(variable.v);
        if (typeof parsedVariable == "number" && !isNaN(parsedVariable)) {
          result = "#ffffff";
        }
        if (typeof variable.v == "string" && isNaN(parsedVariable)) {
          result = "#ffffff";
        }
        if (typeof variable.v == "boolean") {
          result = "#ffffff";
        }
        if (variable.tp$name == "list") {
          result = "#ffffff";
        }
        return result;
      }
      function clean_variables(variables) {
        const new_variables = [];
        const unwanted_variables = ["random", "time", "int_saver", "int_$rw$", "turtle", "t"];
        for (const variable in variables) {
          if (!variable.includes("__") && !unwanted_variables.includes(variable)) {
            let extraStyle = special_style_for_variable(variables[variable]);
            let name = unfixReserved(variable);
            let newTuple = [name, variables[variable].v, extraStyle];
            new_variables.push(newTuple);
          }
        }
        return new_variables;
      }
      function unfixReserved(name) {
        return name.replace(/_\$rw\$$/, "");
      }
      var BP_DISABLED_LINE = "ace_breakpoint";
      function initializeDebugger(options) {
        theGlobalEditor = options.editor;
        theLevel = options.level;
        theLanguage = options.language;
        let TRADUCTIONS = (0, syntaxModesRules_1.convert)(highlighting_trad_json_1.default);
        let lang = options.keywordLanguage;
        if (!TRADUCTIONS.has(lang)) {
          lang = "en";
        }
        TRADUCTION = TRADUCTIONS.get(lang);
        if (!variable_view) {
          $("#variables").hide();
          $("#variable_button").hide();
        }
        if (options.level > 0) {
          let level = options.level;
          step_debugger = level <= 700;
        }
        if (!step_debugger) {
          $("#debug_button").hide();
        }
        if (options.level != 0) {
          let level = options.level;
          variable_view = level >= 2;
          hide_if_no_variables();
        }
        initializeBreakpoints(options.editor);
      }
      exports.initializeDebugger = initializeDebugger;
      function initializeBreakpoints(editor) {
        editor.on("guttermousedown", function(e) {
          const target = e.domEvent.target;
          if (target.className.indexOf("ace_gutter-cell") == -1)
            return;
          if (e.clientX > 25 + target.getBoundingClientRect().left)
            return;
          const breakpoints = getBreakpoints(e.editor);
          let row = e.getDocumentPosition().row;
          if (breakpoints[row] === void 0 && row !== e.editor.getLastVisibleRow() + 1) {
            if (get_shift_key(event)) {
              let highest_key = row;
              for (const key in breakpoints) {
                const number_key = parseInt(key);
                if (number_key < row) {
                  highest_key = number_key;
                }
              }
              for (let i = highest_key; i <= row; i++) {
                e.editor.session.setBreakpoint(i, BP_DISABLED_LINE);
              }
            } else {
              e.editor.session.setBreakpoint(row, BP_DISABLED_LINE);
            }
          } else {
            e.editor.session.clearBreakpoint(row);
          }
          e.stop();
        });
        editor.on("changeBreakpoint", function() {
          if (theGlobalEditor instanceof ace_editor_1.HedyAceEditor) {
            const breakpoints = theGlobalEditor.getDeactivatedLines();
            const disabledLines = Object.entries(breakpoints).filter(([_, bpClass]) => bpClass === BP_DISABLED_LINE).map(([line, _]) => line).map((x) => parseInt(x, 10));
            theGlobalEditor.strikethroughLines(disabledLines);
          }
        });
      }
      function get_shift_key(event2) {
        if (event2.shiftKey) {
          return true;
        }
        return false;
      }
      function debugRun() {
        if (theLevel && theLanguage) {
          (0, app_1.runit)(theLevel, theLanguage, "", "run", function() {
            $("#output").focus();
          });
        }
      }
      function startDebug() {
        if (step_debugger === true) {
          var debugButton = $("#debug_button");
          debugButton.hide();
          var continueButton = $("#debug_continue");
          var stopButton = $("#debug_stop");
          var resetButton = $("#debug_restart");
          var runButtonContainer = $("#runButtonContainer");
          runButtonContainer.hide();
          continueButton.show();
          stopButton.show();
          resetButton.show();
        }
      }
      exports.startDebug = startDebug;
      function resetDebug() {
        if (step_debugger === true) {
          var storage = window.localStorage;
          var continueButton = $("#debug_continue");
          continueButton.show();
          storage.setItem("debugLine", "0");
          clearDebugVariables();
          markCurrentDebuggerLine();
          debugRun();
        }
      }
      exports.resetDebug = resetDebug;
      function stopDebug() {
        if (step_debugger === true) {
          var debugButton = $("#debug_button");
          debugButton.show();
          var continueButton = $("#debug_continue");
          var stopButton = $("#debug_stop");
          var resetButton = $("#debug_restart");
          var runButtonContainer = $("#runButtonContainer");
          $("#stopit").hide();
          $("#runit").show();
          runButtonContainer.show();
          continueButton.hide();
          stopButton.hide();
          resetButton.hide();
          var storage = window.localStorage;
          storage.removeItem("debugLine");
          clearDebugVariables();
          markCurrentDebuggerLine();
        }
      }
      exports.stopDebug = stopDebug;
      function clearDebugVariables() {
        var storage = window.localStorage;
        var keysToRemove = Object.assign({}, localStorage);
        for (var key in keysToRemove) {
          if (key.includes("prompt-")) {
            storage.removeItem(key);
          }
        }
      }
      function incrementDebugLine() {
        const active_suspension = app_1.theGlobalDebugger.getActiveSuspension();
        const suspension_info = app_1.theGlobalDebugger.getSuspensionInfo(active_suspension);
        const lineNumber = suspension_info.lineno;
        load_variables(suspension_info.variables);
        const ifRegexTranslated = ifRegex.replace("__if__", TRADUCTION.get("if")).replace("__is__", TRADUCTION.get("is")).replace("__in__", TRADUCTION.get("in"));
        const repeatRegexTranslated = repeatRegex.replace("__repeat__", TRADUCTION.get("repeat")).replace("__times__", TRADUCTION.get("times"));
        const elseRegexTranslated = elseRegex.replace("__else__", TRADUCTION.get("else"));
        const ifRe = new RegExp(ifRegexTranslated, "gu");
        const repeatRe = new RegExp(repeatRegexTranslated, "gu");
        const elseRe = new RegExp(elseRegexTranslated, "gu");
        if (!lineNumber)
          return;
        for (const [_, map] of Object.entries(app_1.theGlobalSourcemap)) {
          const startingLine = map.python_range.from_line + app_1.theGlobalDebugger.get_code_starting_line();
          const finishingLine = map.python_range.to_line + app_1.theGlobalDebugger.get_code_starting_line();
          if (lineNumber >= startingLine && lineNumber <= finishingLine) {
            if (fullLineCommands.includes(map.command)) {
              const lines = theGlobalEditor.contents.split("\n");
              const line = lines[map.hedy_range.from_line - 1];
              const ifMatches = ifRe.exec(line);
              const repeatMatches = repeatRe.exec(line);
              const elseMatches = elseRe.exec(line);
              if (ifMatches || repeatMatches || elseMatches) {
                theGlobalEditor.setDebuggerCurrentLine(map.hedy_range.from_line, map.hedy_range.from_column, map.hedy_range.to_column - 1);
              } else {
                theGlobalEditor.setDebuggerCurrentLine(map.hedy_range.from_line);
              }
              break;
            } else if (theLevel <= 7 && blockCommands.includes(map.command)) {
              const lines = theGlobalEditor.contents.split("\n");
              let line;
              if (map.hedy_range.from_line < map.hedy_range.to_line) {
                line = lines[map.hedy_range.from_line - 1];
              } else {
                const fullLine = lines[map.hedy_range.from_line - 1];
                line = fullLine.substring(map.hedy_range.from_column - 1, map.hedy_range.to_column - 1);
              }
              const activeLine = app_1.theGlobalDebugger.get_source_line(lineNumber - 1);
              if (activeLine.match(/ *if/)) {
                const ifMatches = ifRe.exec(line);
                if (ifMatches) {
                  const length = ifMatches[1].length;
                  theGlobalEditor.setDebuggerCurrentLine(map.hedy_range.from_line, map.hedy_range.from_column, map.hedy_range.from_column + length - 1);
                  break;
                }
              } else if (activeLine.match(/ *for/)) {
                const repeatMatches = repeatRe.exec(line);
                if (repeatMatches) {
                  const length = repeatMatches[1].length;
                  theGlobalEditor.setDebuggerCurrentLine(map.hedy_range.from_line, map.hedy_range.from_column, map.hedy_range.from_column + length - 1);
                  break;
                }
              }
            } else if (theLevel >= 8 && blockCommands.includes(map.command)) {
              theGlobalEditor.setDebuggerCurrentLine(map.hedy_range.from_line);
              break;
            }
          }
        }
      }
      exports.incrementDebugLine = incrementDebugLine;
      function markCurrentDebuggerLine() {
        if (!step_debugger) {
          return;
        }
        const storage = window.localStorage;
        var debugLine = storage === null || storage === void 0 ? void 0 : storage.getItem("debugLine");
        if (debugLine != null) {
          var debugLineNumber = parseInt(debugLine, 10);
          theGlobalEditor.setDebuggerCurrentLine(debugLineNumber);
        } else {
          theGlobalEditor.setDebuggerCurrentLine(void 0);
        }
      }
      function getBreakpoints(editor) {
        return editor.session.getBreakpoints();
      }
    }
  });

  // __tmp__/static/js/local.js
  var require_local = __commonJS({
    "__tmp__/static/js/local.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.localLoadOnce = exports.localLoad = exports.localDelete = exports.localSave = void 0;
      function localSave(key, data) {
        var _a2;
        (_a2 = window.localStorage) === null || _a2 === void 0 ? void 0 : _a2.setItem(key, JSON.stringify(data));
      }
      exports.localSave = localSave;
      function localDelete(key) {
        var _a2;
        (_a2 = window.localStorage) === null || _a2 === void 0 ? void 0 : _a2.removeItem(key);
      }
      exports.localDelete = localDelete;
      function localLoad(key) {
        var _a2;
        const value = (_a2 = window.localStorage) === null || _a2 === void 0 ? void 0 : _a2.getItem(key);
        try {
          return value ? JSON.parse(value) : void 0;
        } catch (e) {
          return void 0;
        }
      }
      exports.localLoad = localLoad;
      function localLoadOnce(key) {
        const ret = localLoad(key);
        if (ret !== void 0) {
          localDelete(key);
        }
        return ret;
      }
      exports.localLoadOnce = localLoadOnce;
    }
  });

  // node_modules/dompurify/dist/purify.js
  var require_purify = __commonJS({
    "node_modules/dompurify/dist/purify.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.DOMPurify = factory());
      })(exports, function() {
        "use strict";
        function _toConsumableArray(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          } else {
            return Array.from(arr);
          }
        }
        var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var freeze = Object.freeze, seal = Object.seal, create = Object.create;
        var _ref = typeof Reflect !== "undefined" && Reflect, apply = _ref.apply, construct = _ref.construct;
        if (!apply) {
          apply = function apply2(fun, thisValue, args) {
            return fun.apply(thisValue, args);
          };
        }
        if (!freeze) {
          freeze = function freeze2(x) {
            return x;
          };
        }
        if (!seal) {
          seal = function seal2(x) {
            return x;
          };
        }
        if (!construct) {
          construct = function construct2(Func, args) {
            return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
          };
        }
        var arrayForEach = unapply(Array.prototype.forEach);
        var arrayPop = unapply(Array.prototype.pop);
        var arrayPush = unapply(Array.prototype.push);
        var stringToLowerCase = unapply(String.prototype.toLowerCase);
        var stringMatch = unapply(String.prototype.match);
        var stringReplace = unapply(String.prototype.replace);
        var stringIndexOf = unapply(String.prototype.indexOf);
        var stringTrim = unapply(String.prototype.trim);
        var regExpTest = unapply(RegExp.prototype.test);
        var typeErrorCreate = unconstruct(TypeError);
        function unapply(func) {
          return function(thisArg) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return apply(func, thisArg, args);
          };
        }
        function unconstruct(func) {
          return function() {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            return construct(func, args);
          };
        }
        function addToSet(set, array) {
          if (setPrototypeOf) {
            setPrototypeOf(set, null);
          }
          var l = array.length;
          while (l--) {
            var element = array[l];
            if (typeof element === "string") {
              var lcElement = stringToLowerCase(element);
              if (lcElement !== element) {
                if (!isFrozen(array)) {
                  array[l] = lcElement;
                }
                element = lcElement;
              }
            }
            set[element] = true;
          }
          return set;
        }
        function clone(object) {
          var newObject = create(null);
          var property = void 0;
          for (property in object) {
            if (apply(hasOwnProperty, object, [property])) {
              newObject[property] = object[property];
            }
          }
          return newObject;
        }
        function lookupGetter(object, prop) {
          while (object !== null) {
            var desc = getOwnPropertyDescriptor(object, prop);
            if (desc) {
              if (desc.get) {
                return unapply(desc.get);
              }
              if (typeof desc.value === "function") {
                return unapply(desc.value);
              }
            }
            object = getPrototypeOf(object);
          }
          function fallbackValue(element) {
            console.warn("fallback value for", element);
            return null;
          }
          return fallbackValue;
        }
        var html = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
        var svg = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
        var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
        var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
        var mathMl = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
        var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
        var text = freeze(["#text"]);
        var html$1 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
        var svg$1 = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
        var mathMl$1 = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
        var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
        var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm);
        var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
        var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
        var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
        var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
        var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
        var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        function _toConsumableArray$1(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          } else {
            return Array.from(arr);
          }
        }
        var getGlobal = function getGlobal2() {
          return typeof window === "undefined" ? null : window;
        };
        var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
          if ((typeof trustedTypes === "undefined" ? "undefined" : _typeof(trustedTypes)) !== "object" || typeof trustedTypes.createPolicy !== "function") {
            return null;
          }
          var suffix = null;
          var ATTR_NAME = "data-tt-policy-suffix";
          if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
            suffix = document2.currentScript.getAttribute(ATTR_NAME);
          }
          var policyName = "dompurify" + (suffix ? "#" + suffix : "");
          try {
            return trustedTypes.createPolicy(policyName, {
              createHTML: function createHTML(html$$1) {
                return html$$1;
              }
            });
          } catch (_) {
            console.warn("TrustedTypes policy " + policyName + " could not be created.");
            return null;
          }
        };
        function createDOMPurify() {
          var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
          var DOMPurify = function DOMPurify2(root) {
            return createDOMPurify(root);
          };
          DOMPurify.version = "2.3.5";
          DOMPurify.removed = [];
          if (!window2 || !window2.document || window2.document.nodeType !== 9) {
            DOMPurify.isSupported = false;
            return DOMPurify;
          }
          var originalDocument = window2.document;
          var document2 = window2.document;
          var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node2 = window2.Node, Element2 = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser = window2.DOMParser, trustedTypes = window2.trustedTypes;
          var ElementPrototype = Element2.prototype;
          var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
          var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
          var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
          var getParentNode = lookupGetter(ElementPrototype, "parentNode");
          if (typeof HTMLTemplateElement === "function") {
            var template = document2.createElement("template");
            if (template.content && template.content.ownerDocument) {
              document2 = template.content.ownerDocument;
            }
          }
          var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
          var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
          var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
          var importNode = originalDocument.importNode;
          var documentMode = {};
          try {
            documentMode = clone(document2).documentMode ? document2.documentMode : {};
          } catch (_) {
          }
          var hooks = {};
          DOMPurify.isSupported = typeof getParentNode === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
          var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR, ERB_EXPR$$1 = ERB_EXPR, DATA_ATTR$$1 = DATA_ATTR, ARIA_ATTR$$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
          var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;
          var ALLOWED_TAGS = null;
          var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));
          var ALLOWED_ATTR = null;
          var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));
          var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
            tagNameCheck: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: null
            },
            attributeNameCheck: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: null
            },
            allowCustomizedBuiltInElements: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: false
            }
          }));
          var FORBID_TAGS = null;
          var FORBID_ATTR = null;
          var ALLOW_ARIA_ATTR = true;
          var ALLOW_DATA_ATTR = true;
          var ALLOW_UNKNOWN_PROTOCOLS = false;
          var SAFE_FOR_TEMPLATES = false;
          var WHOLE_DOCUMENT = false;
          var SET_CONFIG = false;
          var FORCE_BODY = false;
          var RETURN_DOM = false;
          var RETURN_DOM_FRAGMENT = false;
          var RETURN_TRUSTED_TYPE = false;
          var SANITIZE_DOM = true;
          var KEEP_CONTENT = true;
          var IN_PLACE = false;
          var USE_PROFILES = {};
          var FORBID_CONTENTS = null;
          var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
          var DATA_URI_TAGS = null;
          var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
          var URI_SAFE_ATTRIBUTES = null;
          var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
          var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
          var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
          var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
          var NAMESPACE = HTML_NAMESPACE;
          var IS_EMPTY_INPUT = false;
          var PARSER_MEDIA_TYPE = void 0;
          var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
          var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
          var transformCaseFunc = void 0;
          var CONFIG = null;
          var formElement = document2.createElement("form");
          var isRegexOrFunction = function isRegexOrFunction2(testValue) {
            return testValue instanceof RegExp || testValue instanceof Function;
          };
          var _parseConfig = function _parseConfig2(cfg) {
            if (CONFIG && CONFIG === cfg) {
              return;
            }
            if (!cfg || (typeof cfg === "undefined" ? "undefined" : _typeof(cfg)) !== "object") {
              cfg = {};
            }
            cfg = clone(cfg);
            ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
            ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
            URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
            DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
            FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
            FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
            FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
            USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
            ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
            ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
            ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
            SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
            WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
            RETURN_DOM = cfg.RETURN_DOM || false;
            RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
            RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
            FORCE_BODY = cfg.FORCE_BODY || false;
            SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
            KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
            IN_PLACE = cfg.IN_PLACE || false;
            IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
            NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
            if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
              CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
            }
            if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
              CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
            }
            if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
              CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
            }
            PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
            transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x) {
              return x;
            } : stringToLowerCase;
            if (SAFE_FOR_TEMPLATES) {
              ALLOW_DATA_ATTR = false;
            }
            if (RETURN_DOM_FRAGMENT) {
              RETURN_DOM = true;
            }
            if (USE_PROFILES) {
              ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
              ALLOWED_ATTR = [];
              if (USE_PROFILES.html === true) {
                addToSet(ALLOWED_TAGS, html);
                addToSet(ALLOWED_ATTR, html$1);
              }
              if (USE_PROFILES.svg === true) {
                addToSet(ALLOWED_TAGS, svg);
                addToSet(ALLOWED_ATTR, svg$1);
                addToSet(ALLOWED_ATTR, xml);
              }
              if (USE_PROFILES.svgFilters === true) {
                addToSet(ALLOWED_TAGS, svgFilters);
                addToSet(ALLOWED_ATTR, svg$1);
                addToSet(ALLOWED_ATTR, xml);
              }
              if (USE_PROFILES.mathMl === true) {
                addToSet(ALLOWED_TAGS, mathMl);
                addToSet(ALLOWED_ATTR, mathMl$1);
                addToSet(ALLOWED_ATTR, xml);
              }
            }
            if (cfg.ADD_TAGS) {
              if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
                ALLOWED_TAGS = clone(ALLOWED_TAGS);
              }
              addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
            }
            if (cfg.ADD_ATTR) {
              if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
                ALLOWED_ATTR = clone(ALLOWED_ATTR);
              }
              addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
            }
            if (cfg.ADD_URI_SAFE_ATTR) {
              addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
            }
            if (cfg.FORBID_CONTENTS) {
              if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
                FORBID_CONTENTS = clone(FORBID_CONTENTS);
              }
              addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
            }
            if (KEEP_CONTENT) {
              ALLOWED_TAGS["#text"] = true;
            }
            if (WHOLE_DOCUMENT) {
              addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
            }
            if (ALLOWED_TAGS.table) {
              addToSet(ALLOWED_TAGS, ["tbody"]);
              delete FORBID_TAGS.tbody;
            }
            if (freeze) {
              freeze(cfg);
            }
            CONFIG = cfg;
          };
          var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
          var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
          var ALL_SVG_TAGS = addToSet({}, svg);
          addToSet(ALL_SVG_TAGS, svgFilters);
          addToSet(ALL_SVG_TAGS, svgDisallowed);
          var ALL_MATHML_TAGS = addToSet({}, mathMl);
          addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
          var _checkValidNamespace = function _checkValidNamespace2(element) {
            var parent = getParentNode(element);
            if (!parent || !parent.tagName) {
              parent = {
                namespaceURI: HTML_NAMESPACE,
                tagName: "template"
              };
            }
            var tagName = stringToLowerCase(element.tagName);
            var parentTagName = stringToLowerCase(parent.tagName);
            if (element.namespaceURI === SVG_NAMESPACE) {
              if (parent.namespaceURI === HTML_NAMESPACE) {
                return tagName === "svg";
              }
              if (parent.namespaceURI === MATHML_NAMESPACE) {
                return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
              }
              return Boolean(ALL_SVG_TAGS[tagName]);
            }
            if (element.namespaceURI === MATHML_NAMESPACE) {
              if (parent.namespaceURI === HTML_NAMESPACE) {
                return tagName === "math";
              }
              if (parent.namespaceURI === SVG_NAMESPACE) {
                return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
              }
              return Boolean(ALL_MATHML_TAGS[tagName]);
            }
            if (element.namespaceURI === HTML_NAMESPACE) {
              if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
                return false;
              }
              if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
                return false;
              }
              var commonSvgAndHTMLElements = addToSet({}, ["title", "style", "font", "a", "script"]);
              return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
            }
            return false;
          };
          var _forceRemove = function _forceRemove2(node) {
            arrayPush(DOMPurify.removed, { element: node });
            try {
              node.parentNode.removeChild(node);
            } catch (_) {
              try {
                node.outerHTML = emptyHTML;
              } catch (_2) {
                node.remove();
              }
            }
          };
          var _removeAttribute = function _removeAttribute2(name, node) {
            try {
              arrayPush(DOMPurify.removed, {
                attribute: node.getAttributeNode(name),
                from: node
              });
            } catch (_) {
              arrayPush(DOMPurify.removed, {
                attribute: null,
                from: node
              });
            }
            node.removeAttribute(name);
            if (name === "is" && !ALLOWED_ATTR[name]) {
              if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
                try {
                  _forceRemove(node);
                } catch (_) {
                }
              } else {
                try {
                  node.setAttribute(name, "");
                } catch (_) {
                }
              }
            }
          };
          var _initDocument = function _initDocument2(dirty) {
            var doc = void 0;
            var leadingWhitespace = void 0;
            if (FORCE_BODY) {
              dirty = "<remove></remove>" + dirty;
            } else {
              var matches = stringMatch(dirty, /^[\r\n\t ]+/);
              leadingWhitespace = matches && matches[0];
            }
            if (PARSER_MEDIA_TYPE === "application/xhtml+xml") {
              dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
            }
            var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
            if (NAMESPACE === HTML_NAMESPACE) {
              try {
                doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
              } catch (_) {
              }
            }
            if (!doc || !doc.documentElement) {
              doc = implementation.createDocument(NAMESPACE, "template", null);
              try {
                doc.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
              } catch (_) {
              }
            }
            var body = doc.body || doc.documentElement;
            if (dirty && leadingWhitespace) {
              body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
            }
            if (NAMESPACE === HTML_NAMESPACE) {
              return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
            }
            return WHOLE_DOCUMENT ? doc.documentElement : body;
          };
          var _createIterator = function _createIterator2(root) {
            return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
          };
          var _isClobbered = function _isClobbered2(elm) {
            return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function");
          };
          var _isNode = function _isNode2(object) {
            return (typeof Node2 === "undefined" ? "undefined" : _typeof(Node2)) === "object" ? object instanceof Node2 : object && (typeof object === "undefined" ? "undefined" : _typeof(object)) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
          };
          var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
            if (!hooks[entryPoint]) {
              return;
            }
            arrayForEach(hooks[entryPoint], function(hook) {
              hook.call(DOMPurify, currentNode, data, CONFIG);
            });
          };
          var _sanitizeElements = function _sanitizeElements2(currentNode) {
            var content = void 0;
            _executeHook("beforeSanitizeElements", currentNode, null);
            if (_isClobbered(currentNode)) {
              _forceRemove(currentNode);
              return true;
            }
            if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
              _forceRemove(currentNode);
              return true;
            }
            var tagName = transformCaseFunc(currentNode.nodeName);
            _executeHook("uponSanitizeElement", currentNode, {
              tagName,
              allowedTags: ALLOWED_TAGS
            });
            if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
              _forceRemove(currentNode);
              return true;
            }
            if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
              _forceRemove(currentNode);
              return true;
            }
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
                var parentNode = getParentNode(currentNode) || currentNode.parentNode;
                var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
                if (childNodes && parentNode) {
                  var childCount = childNodes.length;
                  for (var i = childCount - 1; i >= 0; --i) {
                    parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
                  }
                }
              }
              if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
                  return false;
                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
                  return false;
              }
              _forceRemove(currentNode);
              return true;
            }
            if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
              _forceRemove(currentNode);
              return true;
            }
            if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
              _forceRemove(currentNode);
              return true;
            }
            if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
              content = currentNode.textContent;
              content = stringReplace(content, MUSTACHE_EXPR$$1, " ");
              content = stringReplace(content, ERB_EXPR$$1, " ");
              if (currentNode.textContent !== content) {
                arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
                currentNode.textContent = content;
              }
            }
            _executeHook("afterSanitizeElements", currentNode, null);
            return false;
          };
          var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
            if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
              return false;
            }
            if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName))
              ;
            else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName))
              ;
            else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
              if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)))
                ;
              else {
                return false;
              }
            } else if (URI_SAFE_ATTRIBUTES[lcName])
              ;
            else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, "")))
              ;
            else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
              ;
            else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, "")))
              ;
            else if (!value)
              ;
            else {
              return false;
            }
            return true;
          };
          var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
            return tagName.indexOf("-") > 0;
          };
          var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
            var attr = void 0;
            var value = void 0;
            var lcName = void 0;
            var l = void 0;
            _executeHook("beforeSanitizeAttributes", currentNode, null);
            var attributes = currentNode.attributes;
            if (!attributes) {
              return;
            }
            var hookEvent = {
              attrName: "",
              attrValue: "",
              keepAttr: true,
              allowedAttributes: ALLOWED_ATTR
            };
            l = attributes.length;
            while (l--) {
              attr = attributes[l];
              var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
              value = stringTrim(attr.value);
              lcName = transformCaseFunc(name);
              hookEvent.attrName = lcName;
              hookEvent.attrValue = value;
              hookEvent.keepAttr = true;
              hookEvent.forceKeepAttr = void 0;
              _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
              value = hookEvent.attrValue;
              if (hookEvent.forceKeepAttr) {
                continue;
              }
              _removeAttribute(name, currentNode);
              if (!hookEvent.keepAttr) {
                continue;
              }
              if (regExpTest(/\/>/i, value)) {
                _removeAttribute(name, currentNode);
                continue;
              }
              if (SAFE_FOR_TEMPLATES) {
                value = stringReplace(value, MUSTACHE_EXPR$$1, " ");
                value = stringReplace(value, ERB_EXPR$$1, " ");
              }
              var lcTag = transformCaseFunc(currentNode.nodeName);
              if (!_isValidAttribute(lcTag, lcName, value)) {
                continue;
              }
              try {
                if (namespaceURI) {
                  currentNode.setAttributeNS(namespaceURI, name, value);
                } else {
                  currentNode.setAttribute(name, value);
                }
                arrayPop(DOMPurify.removed);
              } catch (_) {
              }
            }
            _executeHook("afterSanitizeAttributes", currentNode, null);
          };
          var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
            var shadowNode = void 0;
            var shadowIterator = _createIterator(fragment);
            _executeHook("beforeSanitizeShadowDOM", fragment, null);
            while (shadowNode = shadowIterator.nextNode()) {
              _executeHook("uponSanitizeShadowNode", shadowNode, null);
              if (_sanitizeElements(shadowNode)) {
                continue;
              }
              if (shadowNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM2(shadowNode.content);
              }
              _sanitizeAttributes(shadowNode);
            }
            _executeHook("afterSanitizeShadowDOM", fragment, null);
          };
          DOMPurify.sanitize = function(dirty, cfg) {
            var body = void 0;
            var importedNode = void 0;
            var currentNode = void 0;
            var oldNode = void 0;
            var returnNode = void 0;
            IS_EMPTY_INPUT = !dirty;
            if (IS_EMPTY_INPUT) {
              dirty = "<!-->";
            }
            if (typeof dirty !== "string" && !_isNode(dirty)) {
              if (typeof dirty.toString !== "function") {
                throw typeErrorCreate("toString is not a function");
              } else {
                dirty = dirty.toString();
                if (typeof dirty !== "string") {
                  throw typeErrorCreate("dirty is not a string, aborting");
                }
              }
            }
            if (!DOMPurify.isSupported) {
              if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
                if (typeof dirty === "string") {
                  return window2.toStaticHTML(dirty);
                }
                if (_isNode(dirty)) {
                  return window2.toStaticHTML(dirty.outerHTML);
                }
              }
              return dirty;
            }
            if (!SET_CONFIG) {
              _parseConfig(cfg);
            }
            DOMPurify.removed = [];
            if (typeof dirty === "string") {
              IN_PLACE = false;
            }
            if (IN_PLACE) {
              if (dirty.nodeName) {
                var tagName = transformCaseFunc(dirty.nodeName);
                if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                  throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
                }
              }
            } else if (dirty instanceof Node2) {
              body = _initDocument("<!---->");
              importedNode = body.ownerDocument.importNode(dirty, true);
              if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
                body = importedNode;
              } else if (importedNode.nodeName === "HTML") {
                body = importedNode;
              } else {
                body.appendChild(importedNode);
              }
            } else {
              if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
                return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
              }
              body = _initDocument(dirty);
              if (!body) {
                return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
              }
            }
            if (body && FORCE_BODY) {
              _forceRemove(body.firstChild);
            }
            var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
            while (currentNode = nodeIterator.nextNode()) {
              if (currentNode.nodeType === 3 && currentNode === oldNode) {
                continue;
              }
              if (_sanitizeElements(currentNode)) {
                continue;
              }
              if (currentNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(currentNode.content);
              }
              _sanitizeAttributes(currentNode);
              oldNode = currentNode;
            }
            oldNode = null;
            if (IN_PLACE) {
              return dirty;
            }
            if (RETURN_DOM) {
              if (RETURN_DOM_FRAGMENT) {
                returnNode = createDocumentFragment.call(body.ownerDocument);
                while (body.firstChild) {
                  returnNode.appendChild(body.firstChild);
                }
              } else {
                returnNode = body;
              }
              if (ALLOWED_ATTR.shadowroot) {
                returnNode = importNode.call(originalDocument, returnNode, true);
              }
              return returnNode;
            }
            var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
            if (SAFE_FOR_TEMPLATES) {
              serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, " ");
              serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, " ");
            }
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
          };
          DOMPurify.setConfig = function(cfg) {
            _parseConfig(cfg);
            SET_CONFIG = true;
          };
          DOMPurify.clearConfig = function() {
            CONFIG = null;
            SET_CONFIG = false;
          };
          DOMPurify.isValidAttribute = function(tag, attr, value) {
            if (!CONFIG) {
              _parseConfig({});
            }
            var lcTag = transformCaseFunc(tag);
            var lcName = transformCaseFunc(attr);
            return _isValidAttribute(lcTag, lcName, value);
          };
          DOMPurify.addHook = function(entryPoint, hookFunction) {
            if (typeof hookFunction !== "function") {
              return;
            }
            hooks[entryPoint] = hooks[entryPoint] || [];
            arrayPush(hooks[entryPoint], hookFunction);
          };
          DOMPurify.removeHook = function(entryPoint) {
            if (hooks[entryPoint]) {
              arrayPop(hooks[entryPoint]);
            }
          };
          DOMPurify.removeHooks = function(entryPoint) {
            if (hooks[entryPoint]) {
              hooks[entryPoint] = [];
            }
          };
          DOMPurify.removeAllHooks = function() {
            hooks = {};
          };
          return DOMPurify;
        }
        var purify = createDOMPurify();
        return purify;
      });
    }
  });

  // __tmp__/static/js/teachers.js
  var require_teachers = __commonJS({
    "__tmp__/static/js/teachers.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.initializeClassOverviewPage = exports.initializeCustomizeClassPage = exports.initializeTeacherPage = exports.copy_join_link = exports.create_accounts = exports.append_classname = exports.generate_passwords = exports.add_account_placeholder = exports.setDateLevelInputColor = exports.enable_level = exports.restore_customization_to_default = exports.save_customizations = exports.show_doc_section = exports.change_password_student = exports.delete_adventure = exports.preview_adventure = exports.update_adventure = exports.remove_student = exports.remove_student_invite = exports.invite_student = exports.join_class = exports.delete_class = exports.duplicate_class = exports.rename_class = exports.create_class = void 0;
      var modal_1 = require_modal();
      var app_1 = require_app();
      var unsaved_changes_1 = require_unsaved_changes();
      var client_messages_1 = require_client_messages();
      var dompurify_1 = __importDefault(require_purify());
      var tutorial_1 = require_tutorial();
      var cm_editor_1 = require_cm_editor();
      var tokens_1 = require_tokens();
      var editorCreator = new cm_editor_1.HedyCodeMirrorEditorCreator();
      function create_class(class_name_prompt) {
        modal_1.modal.prompt(class_name_prompt, "", function(class_name) {
          $.ajax({
            type: "POST",
            url: "/class",
            data: JSON.stringify({
              name: class_name
            }),
            contentType: "application/json",
            dataType: "json"
          }).done(function(response) {
            if (response.achievement) {
              (0, app_1.showAchievements)(response.achievement, false, "/for-teachers/customize-class/" + response.id);
            } else {
              window.location.pathname = "/for-teachers/customize-class/" + response.id;
            }
          }).fail(function(err) {
            return modal_1.modal.notifyError(err.responseText);
          });
        });
      }
      exports.create_class = create_class;
      function rename_class(id, class_name_prompt) {
        modal_1.modal.prompt(class_name_prompt, "", function(class_name) {
          $.ajax({
            type: "PUT",
            url: "/class/" + id,
            data: JSON.stringify({
              name: class_name
            }),
            contentType: "application/json",
            dataType: "json"
          }).done(function(response) {
            if (response.achievement) {
              (0, app_1.showAchievements)(response.achievement, true, "");
            } else {
              location.reload();
            }
          }).fail(function(err) {
            return modal_1.modal.notifyError(err.responseText);
          });
        });
      }
      exports.rename_class = rename_class;
      function duplicate_class(id, teacher_classes, second_teacher_prompt, prompt, defaultValue = "") {
        if (teacher_classes) {
          modal_1.modal.confirm(second_teacher_prompt, function() {
            apiDuplicateClass(id, prompt, true, defaultValue);
          }, function() {
            apiDuplicateClass(id, prompt, false, defaultValue);
          });
        } else {
          apiDuplicateClass(id, prompt, false, defaultValue);
        }
      }
      exports.duplicate_class = duplicate_class;
      function apiDuplicateClass(id, prompt, second_teacher, defaultValue = "") {
        modal_1.modal.prompt(prompt, defaultValue, function(class_name) {
          $.ajax({
            type: "POST",
            url: "/duplicate_class",
            data: JSON.stringify({
              id,
              name: class_name,
              second_teacher
            }),
            contentType: "application/json",
            dataType: "json"
          }).done(function(response) {
            if (response.second_teachers && second_teacher == true) {
              for (const secondTeacher of response.second_teachers) {
                $.ajax({
                  type: "POST",
                  url: "/invite-second-teacher",
                  data: JSON.stringify({
                    username: secondTeacher.username,
                    class_id: response.id
                  }),
                  contentType: "application/json",
                  dataType: "json"
                }).fail(function(err) {
                  modal_1.modal.notifyError(err.responseText);
                });
              }
            }
            if (response.achievement) {
              (0, app_1.showAchievements)(response.achievement, true, "");
            } else {
              location.reload();
            }
          }).fail(function(err) {
            return modal_1.modal.notifyError(err.responseText);
          });
        });
      }
      function delete_class(id, prompt) {
        modal_1.modal.confirm(prompt, function() {
          $.ajax({
            type: "DELETE",
            url: "/class/" + id,
            contentType: "application/json",
            dataType: "json"
          }).done(function(response) {
            if (response.achievement) {
              (0, app_1.showAchievements)(response.achievement, true, "");
            } else {
              location.reload();
            }
          }).fail(function(err) {
            modal_1.modal.notifyError(err.responseText);
          });
        });
      }
      exports.delete_class = delete_class;
      function join_class(id, name) {
        $.ajax({
          type: "POST",
          url: "/class/join",
          contentType: "application/json",
          data: JSON.stringify({
            id,
            name
          }),
          dataType: "json"
        }).done(function(response) {
          if (response.achievement) {
            (0, app_1.showAchievements)(response.achievement, false, "/programs");
          } else {
            window.location.pathname = "/programs";
          }
        }).fail(function(err) {
          if (err.status == 403) {
            return modal_1.modal.confirm(err.responseText, function() {
              localStorage.setItem("hedy-join", JSON.stringify({ id, name }));
              window.location.pathname = "/login";
            });
          } else {
            modal_1.modal.notifyError(err.responseText || client_messages_1.ClientMessages["Connection_error"]);
          }
        });
      }
      exports.join_class = join_class;
      function invite_student(class_id, prompt, url = "/invite-student") {
        modal_1.modal.prompt(prompt, "", function(username) {
          $.ajax({
            type: "POST",
            url,
            data: JSON.stringify({
              username,
              class_id
            }),
            contentType: "application/json",
            dataType: "json"
          }).done(function() {
            location.reload();
          }).fail(function(err) {
            modal_1.modal.notifyError(err.responseText);
          });
        });
      }
      exports.invite_student = invite_student;
      function remove_student_invite(username, class_id, prompt) {
        return modal_1.modal.confirm(prompt, function() {
          $.ajax({
            type: "POST",
            url: "/remove_student_invite",
            data: JSON.stringify({
              username,
              class_id
            }),
            contentType: "application/json",
            dataType: "json"
          }).done(function() {
            location.reload();
          }).fail(function(err) {
            return modal_1.modal.notifyError(err.responseText);
          });
        });
      }
      exports.remove_student_invite = remove_student_invite;
      function remove_student(class_id, student_id, prompt) {
        modal_1.modal.confirm(prompt, function() {
          $.ajax({
            type: "DELETE",
            url: "/class/" + class_id + "/student/" + student_id,
            contentType: "application/json",
            dataType: "json"
          }).done(function(response) {
            if (response.achievement) {
              (0, app_1.showAchievements)(response.achievement, true, "");
            } else {
              location.reload();
            }
          }).fail(function(err) {
            modal_1.modal.notifyError(err.responseText);
          });
        });
      }
      exports.remove_student = remove_student;
      function update_db_adventure(adventure_id) {
        const adventure_name = $("#custom_adventure_name").val();
        const levels = $("#custom_adventure_levels").val();
        const content = dompurify_1.default.sanitize($("#custom_adventure_content").val());
        const agree_public = $("#agree_public").prop("checked");
        const language = $("#language").val();
        $.ajax({
          type: "POST",
          url: "/for-teachers/customize-adventure",
          data: JSON.stringify({
            id: adventure_id,
            name: adventure_name,
            content,
            public: agree_public,
            language,
            levels
          }),
          contentType: "application/json",
          dataType: "json"
        }).done(function(response) {
          modal_1.modal.notifySuccess(response.success);
        }).fail(function(err) {
          modal_1.modal.notifyError(err.responseText);
        });
      }
      function update_adventure(adventure_id, first_edit, prompt) {
        if (!first_edit) {
          modal_1.modal.confirm(prompt, function() {
            update_db_adventure(adventure_id);
          });
        } else {
          update_db_adventure(adventure_id);
        }
      }
      exports.update_adventure = update_adventure;
      function show_preview(content) {
        const name = $("#custom_adventure_name").val();
        if (typeof name !== "string") {
          throw new Error(`Expected name to be string, got '${name}'`);
        }
        const levels = $("#custom_adventure_levels").val();
        if (typeof levels !== "object") {
          throw new Error(`Expected level to be a list, got '${levels}'`);
        }
        let container = $("<div>");
        container.addClass("preview border border-black px-8 py-4 text-left rounded-lg bg-gray-200 text-black");
        container.css("white-space", "pre-wrap");
        container.css("width", "40em");
        container.html(content);
        modal_1.modal.preview(container, name);
        for (const preview of $(".preview pre").get()) {
          $(preview).addClass("text-lg rounded");
          const dir = $("body").attr("dir");
          const codeNode = preview.querySelector("code");
          let code;
          if (codeNode) {
            codeNode.hidden = true;
            code = codeNode.innerText;
          } else {
            code = preview.textContent || "";
            preview.textContent = "";
          }
          const exampleEditor = editorCreator.initializeReadOnlyEditor(preview, dir);
          exampleEditor.contents = code.trimEnd();
          for (const level of levels) {
            (0, tokens_1.initializeTranslation)({
              keywordLanguage: app_1.theKeywordLanguage,
              level: parseInt(level, 10)
            });
            exampleEditor.setHighlighterForLevel(parseInt(level, 10));
          }
        }
      }
      function preview_adventure() {
        let content = dompurify_1.default.sanitize($("#custom_adventure_content").val());
        $.ajax({
          type: "POST",
          url: "/for-teachers/preview-adventure",
          data: JSON.stringify({
            code: content
          }),
          contentType: "application/json",
          dataType: "json"
        }).done(function(response) {
          show_preview(response.code);
        }).fail(function(err) {
          modal_1.modal.notifyError(err.responseText);
        });
      }
      exports.preview_adventure = preview_adventure;
      function delete_adventure(adventure_id, prompt) {
        modal_1.modal.confirm(prompt, function() {
          $.ajax({
            type: "DELETE",
            url: "/for-teachers/customize-adventure/" + adventure_id,
            contentType: "application/json",
            dataType: "json"
          }).done(function() {
            window.location.href = "/for-teachers";
          }).fail(function(err) {
            modal_1.modal.notifyError(err.responseText);
          });
        });
      }
      exports.delete_adventure = delete_adventure;
      function change_password_student(username, enter_password, password_prompt) {
        modal_1.modal.prompt(enter_password + " " + username + ":", "", function(password) {
          modal_1.modal.confirm(password_prompt, function() {
            $.ajax({
              type: "POST",
              url: "/auth/change_student_password",
              data: JSON.stringify({
                username,
                password
              }),
              contentType: "application/json",
              dataType: "json"
            }).done(function(response) {
              modal_1.modal.notifySuccess(response.success);
            }).fail(function(err) {
              modal_1.modal.notifyError(err.responseText);
            });
          });
        });
      }
      exports.change_password_student = change_password_student;
      function show_doc_section(section_key) {
        $(".section-button").each(function() {
          if ($(this).hasClass("blue-btn")) {
            $(this).removeClass("blue-btn");
            $(this).addClass("green-btn");
          }
        });
        if ($("#section-" + section_key).is(":visible")) {
          $("#button-" + section_key).removeClass("blue-btn");
          $("#button-" + section_key).addClass("green-btn");
          $(".section").hide();
        } else {
          $("#button-" + section_key).removeClass("green-btn");
          $("#button-" + section_key).addClass("blue-btn");
          $(".section").hide();
          $(".common-mistakes-section").hide();
          $("#section-" + section_key).toggle();
        }
      }
      exports.show_doc_section = show_doc_section;
      function save_customizations(class_id) {
        let levels = [];
        $("[id^=enable_level_]").each(function() {
          if ($(this).is(":checked")) {
            levels.push($(this).attr("level"));
          }
        });
        let other_settings = [];
        $(".other_settings_checkbox").each(function() {
          if ($(this).prop("checked")) {
            other_settings.push($(this).attr("id"));
          }
        });
        let level_thresholds = {};
        $(".threshold_settings_value").each(function() {
          if ($(this).val() != "") {
            level_thresholds[$(this).attr("id")] = $(this).val();
          }
        });
        let opening_dates = {};
        $("[id^=opening_date_level_]").each(function() {
          opening_dates[$(this).attr("level")] = $(this).val();
        });
        $.ajax({
          type: "POST",
          url: "/for-teachers/customize-class/" + class_id,
          data: JSON.stringify({
            levels,
            opening_dates,
            other_settings,
            level_thresholds
          }),
          contentType: "application/json",
          dataType: "json"
        }).done(function(response) {
          if (response.achievement) {
            (0, app_1.showAchievements)(response.achievement, false, "");
          }
          modal_1.modal.notifySuccess(response.success);
          (0, unsaved_changes_1.clearUnsavedChanges)();
          $("#remove_customizations_button").removeClass("hidden");
        }).fail(function(err) {
          modal_1.modal.notifyError(err.responseText);
        });
      }
      exports.save_customizations = save_customizations;
      function restore_customization_to_default(prompt) {
        modal_1.modal.confirm(prompt, function() {
          let active_level_id = $("[id^=level-]")[0].id;
          let active_level = active_level_id.split("-")[1];
          htmx.ajax("POST", `/for-teachers/restore-customizations?level=${active_level}`, "#adventure-dragger").then(() => {
            $(".other_settings_checkbox").prop("checked", false);
            $(".opening_date_input").prop("type", "text").blur().val("").prop("disabled", false).attr("placeholder", client_messages_1.ClientMessages.directly_available).each(function() {
              if ($(this).hasClass("bg-green-300")) {
                $(this).removeClass("bg-green-300").addClass("bg-gray-200");
              }
            });
            $("[id^=enable_level_]").prop("checked", true);
            setLevelStateIndicator(active_level);
            modal_1.modal.notifySuccess(client_messages_1.ClientMessages.customization_deleted);
          });
        });
      }
      exports.restore_customization_to_default = restore_customization_to_default;
      function enable_level(level) {
        (0, unsaved_changes_1.markUnsavedChanges)();
        if ($("#enable_level_" + level).is(":checked")) {
          $("#opening_date_level_" + level).prop("disabled", false).attr("type", "text").attr("placeholder", client_messages_1.ClientMessages.directly_available).removeClass("bg-green-300").addClass("bg-gray-200");
        } else {
          $("#opening_date_level_" + level).prop("disabled", true).attr("type", "text").attr("placeholder", client_messages_1.ClientMessages.disabled).val("");
        }
        if ($("#level-" + level).is(":visible")) {
          setLevelStateIndicator(level);
        }
      }
      exports.enable_level = enable_level;
      function setDateLevelInputColor(level) {
        var date_string = $("#opening_date_level_" + level).val();
        var input_date = new Date(date_string);
        var today_date = new Date();
        if (input_date > today_date) {
          $("#opening_date_level_" + level).removeClass("bg-gray-200").addClass("bg-green-300");
        } else {
          $("#opening_date_level_" + level).removeClass("bg-green-300").addClass("bg-gray-200");
        }
        if ($("#level-" + level).is(":visible")) {
          setLevelStateIndicator(level);
        }
      }
      exports.setDateLevelInputColor = setDateLevelInputColor;
      function add_account_placeholder() {
        let row = $("#account_row_unique").clone();
        row.removeClass("hidden");
        row.attr("id", "");
        row.find(":input").each(function() {
          if ($(this).prop("id") != "classes") {
            $(this).prop("required", true);
          }
        });
        for (let x = 0; x < 5; x++) {
          row.clone().appendTo("#account_rows_container");
        }
      }
      exports.add_account_placeholder = add_account_placeholder;
      function generate_passwords() {
        if (!$("#passwords_toggle").is(":checked")) {
          $(".passwords_input").val("");
          $(".passwords_input").prop("disabled", false);
          return;
        }
        $(".account_row").each(function() {
          if ($(this).is(":visible")) {
            $(this).find(":input").each(function() {
              if ($(this).attr("id") == "password") {
                const random_password = generateRandomString(6);
                $(this).val(random_password);
              }
            });
          }
        });
        $(".passwords_input").prop("disabled", true);
      }
      exports.generate_passwords = generate_passwords;
      function append_classname() {
        const classname = $("#classes").val();
        $(".usernames_input").each(function() {
          $(this).val($(this).val() + "_" + classname);
        });
      }
      exports.append_classname = append_classname;
      function create_accounts(prompt) {
        modal_1.modal.confirm(prompt, function() {
          $("#account_rows_container").find(":input").each(function() {
            $(this).removeClass("border-2 border-red-500");
            $(this).removeAttr("required");
          });
          let accounts = [];
          $(".account_row").each(function() {
            if ($(this).is(":visible")) {
              let account = {};
              $(this).find(":input").each(function() {
                account[$(this).attr("name")] = $(this).val();
              });
              accounts.push(account);
            }
          });
          $.ajax({
            type: "POST",
            url: "/for-teachers/create-accounts",
            data: JSON.stringify({
              accounts
            }),
            contentType: "application/json",
            dataType: "json"
          }).done(function(response) {
            if (response.error) {
              modal_1.modal.notifyError(response.error);
              $("#account_rows_container").find(":input").each(function() {
                if ($(this).val() == response.value) {
                  $(this).addClass("border-2 border-red-500");
                }
              });
              return;
            } else {
              modal_1.modal.notifySuccess(response.success);
              if ($("input[name='download_credentials_checkbox']:checked").val() == "yes") {
                download_login_credentials(accounts);
              }
              $("#account_rows_container").find(":input").each(function() {
                $(this).val("");
              });
            }
          }).fail(function(err) {
            modal_1.modal.notifyError(err.responseText);
          });
        });
      }
      exports.create_accounts = create_accounts;
      function download_login_credentials(accounts) {
        let csvContent = "data:text/csv;charset=utf-8,";
        csvContent += "Username, Password\r\n";
        accounts.forEach(function(account) {
          let row = account.username + "," + account.password;
          csvContent += row + "\r\n";
        });
        var encodedUri = encodeURI(csvContent);
        var link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "accounts.csv");
        document.body.appendChild(link);
        link.click();
      }
      function copy_join_link(link, success) {
        var sampleTextarea = document.createElement("textarea");
        document.body.appendChild(sampleTextarea);
        sampleTextarea.value = link;
        sampleTextarea.select();
        document.execCommand("copy");
        document.body.removeChild(sampleTextarea);
        modal_1.modal.notifySuccess(success);
      }
      exports.copy_join_link = copy_join_link;
      function generateRandomString(length) {
        var text = "";
        var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        for (var i = 0; i < length; i++) {
          text += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        return text;
      }
      function initializeTeacherPage(options) {
        if (options.welcome_teacher) {
          modal_1.modal.notifySuccess(client_messages_1.ClientMessages.teacher_welcome, 3e4);
        }
        if (options.tutorial) {
          (0, tutorial_1.startTeacherTutorial)();
        }
      }
      exports.initializeTeacherPage = initializeTeacherPage;
      function setLevelStateIndicator(level) {
        $("[id^=state-]").addClass("hidden");
        if ($("#opening_date_level_" + level).is(":disabled")) {
          $("#state-disabled").removeClass("hidden");
        } else if ($("#opening_date_level_" + level).val() === "") {
          $("#state-accessible").removeClass("hidden");
        } else {
          var date_string = $("#opening_date_level_" + level).val();
          var input_date = new Date(date_string);
          var today_date = new Date();
          if (input_date > today_date) {
            $("#opening_date").text(date_string);
            $("#state-future").removeClass("hidden");
          } else {
            $("#state-accessible").removeClass("hidden");
          }
        }
      }
      function initializeCustomizeClassPage(options) {
        $(document).ready(function() {
          $("input").on("change", function() {
            (0, unsaved_changes_1.markUnsavedChanges)();
          });
          $("#back_to_class").on("click", () => {
            function backToClass() {
              window.location.href = `/for-teachers/class/${options.class_id}`;
            }
            if ((0, unsaved_changes_1.hasUnsavedChanges)()) {
              modal_1.modal.confirm(client_messages_1.ClientMessages.unsaved_class_changes, () => {
                (0, unsaved_changes_1.clearUnsavedChanges)();
                backToClass();
              });
            } else {
              backToClass();
            }
          });
          $("[id^=opening_date_level_]").each(function() {
            setDateLevelInputColor($(this).attr("level"));
          });
          $("#levels-dropdown").on("change", function() {
            var level = $(this).val();
            setLevelStateIndicator(level);
          });
        });
      }
      exports.initializeCustomizeClassPage = initializeCustomizeClassPage;
      function initializeClassOverviewPage(_options) {
        $(".attribute").change(function() {
          const attribute = $(this).attr("id");
          if (!this.checked) {
            $("#" + attribute + "_header").hide();
            $("." + attribute + "_cell").hide();
          } else {
            $("#" + attribute + "_header").show();
            $("." + attribute + "_cell").show();
          }
        });
      }
      exports.initializeClassOverviewPage = initializeClassOverviewPage;
    }
  });

  // __tmp__/static/js/comm.js
  var require_comm = __commonJS({
    "__tmp__/static/js/comm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.postNoResponse = exports.postJson = void 0;
      function postJson(url, data) {
        if (window.fetch !== void 0) {
          return postJsonUsingFetch(url, data);
        }
        return new Promise((ok, ko) => {
          $.ajax(Object.assign(Object.assign({ type: "POST", url }, data ? { data: JSON.stringify(data) } : {}), { contentType: "application/json; charset=utf-8", dataType: "json" })).done((response) => {
            ok(response);
          }).fail((err) => {
            ko(ajaxError(err));
          });
        });
      }
      exports.postJson = postJson;
      async function postJsonUsingFetch(url, data) {
        let response;
        try {
          response = await fetch(url, Object.assign(Object.assign({ method: "POST", credentials: "include", keepalive: true }, data ? { body: JSON.stringify(data) } : {}), { headers: {
            "Content-Type": "application/json; charset=utf-8",
            "Accept": "application/json"
          } }));
        } catch (err) {
          throw Object.assign(new Error(err.message), {
            internetError: true
          });
        }
        if (response.status !== 200) {
          let errorMessage = await response.text();
          try {
            const parsed = JSON.parse(errorMessage);
            if (parsed.error) {
              errorMessage = parsed.error;
            }
          } catch (_a2) {
            if (errorMessage.length > 500) {
              errorMessage = `the server responded with an error (${response.status} ${response.statusText})`;
            }
          }
          throw Object.assign(new Error(errorMessage), {
            responseText: errorMessage,
            status: response.status
          });
        }
        return response.json();
      }
      function postNoResponse(url, data) {
        return new Promise((ok, ko) => {
          $.ajax(Object.assign({ type: "POST", url, contentType: "application/json; charset=utf-8" }, data ? { data: JSON.stringify(data) } : {})).done(() => {
            ok();
          }).fail((err) => {
            ko(ajaxError(err));
          });
        });
      }
      exports.postNoResponse = postNoResponse;
      function ajaxError(err) {
        const error = new Error(err.responseText);
        return Object.assign(error, {
          responseText: err.responseText,
          status: err.status,
          internetError: err.readyState < 4
        });
      }
    }
  });

  // __tmp__/static/js/auth.js
  var require_auth = __commonJS({
    "__tmp__/static/js/auth.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.update_user_tags = exports.edit_user_tags = exports.changeUserEmail = exports.markAsTeacher = exports.initializeFormSubmits = exports.request_teacher_account = exports.destroy_public = exports.destroy = exports.logout = exports.comeBackHereAfterLogin = exports.initializeLoginLinks = void 0;
      var modal_1 = require_modal();
      var teachers_1 = require_teachers();
      var app_1 = require_app();
      var local_1 = require_local();
      var comm_1 = require_comm();
      var REDIRECT_AFTER_LOGIN_KEY = "login-redirect";
      function initializeLoginLinks() {
        $('a[href="/login"]').on("click", () => {
          comeBackHereAfterLogin();
        });
      }
      exports.initializeLoginLinks = initializeLoginLinks;
      function comeBackHereAfterLogin() {
        (0, local_1.localSave)(REDIRECT_AFTER_LOGIN_KEY, {
          url: window.location.toString()
        });
      }
      exports.comeBackHereAfterLogin = comeBackHereAfterLogin;
      function convertFormJSON(form) {
        let result = {};
        $.each($(form).serializeArray(), function() {
          if (result[this.name]) {
            if ($.isArray(result[this.name])) {
              result[this.name] = $.merge(result[this.name], Array(this.value));
            } else {
              result[this.name] = $.merge(Array(result[this.name]), Array(this.value));
            }
          } else {
            if (this.value) {
              result[this.name] = this.value;
            }
          }
        });
        return result;
      }
      function redirect(where) {
        where = "/" + where;
        window.location.pathname = where;
      }
      async function logout() {
        await (0, comm_1.postNoResponse)("/auth/logout");
        window.location.reload();
      }
      exports.logout = logout;
      function destroy(confirmation) {
        modal_1.modal.confirm(confirmation, async () => {
          await (0, comm_1.postNoResponse)("/auth/destroy");
          redirect("");
        });
      }
      exports.destroy = destroy;
      function destroy_public(confirmation) {
        modal_1.modal.confirm(confirmation, async () => {
          await (0, comm_1.postNoResponse)("/auth/destroy_public");
          location.reload();
        });
      }
      exports.destroy_public = destroy_public;
      async function request_teacher_account() {
        (0, modal_1.tryCatchPopup)(async () => {
          const response = await (0, comm_1.postJson)("/auth/request_teacher");
          modal_1.modal.notifySuccess(response.message);
          setTimeout(function() {
            location.reload();
          }, 2e3);
        });
      }
      exports.request_teacher_account = request_teacher_account;
      function initializeFormSubmits() {
        $("form#signup").on("submit", async function(e) {
          e.preventDefault();
          (0, modal_1.tryCatchPopup)(async () => {
            await (0, comm_1.postNoResponse)("/auth/signup", convertFormJSON($(this)));
            afterLogin({ "first_time": true });
          });
        });
        $("form#login").on("submit", function(e) {
          e.preventDefault();
          (0, modal_1.tryCatchPopup)(async () => {
            const response = await (0, comm_1.postJson)("/auth/login", convertFormJSON($(this)));
            if (response["first_time"]) {
              return afterLogin({ "first_time": true });
            }
            return afterLogin({ "admin": response["admin"] || false, "teacher": response["teacher"] });
          });
        });
        $("form#profile").on("submit", function(e) {
          e.preventDefault();
          (0, modal_1.tryCatchPopup)(async () => {
            const response = await (0, comm_1.postJson)("/profile", convertFormJSON($(this)));
            if (response.reload) {
              modal_1.modal.notifySuccess(response.message, 2e3);
              setTimeout(function() {
                location.reload();
              }, 2e3);
            } else {
              modal_1.modal.notifySuccess(response.message);
            }
          });
        });
        $("form#change_password").on("submit", function(e) {
          e.preventDefault();
          (0, modal_1.tryCatchPopup)(async () => {
            const response = await (0, comm_1.postJson)("/auth/change_password", convertFormJSON($(this)));
            modal_1.modal.notifySuccess(response.message);
          });
        });
        $("form#recover").on("submit", function(e) {
          e.preventDefault();
          (0, modal_1.tryCatchPopup)(async () => {
            const response = await (0, comm_1.postJson)("/auth/recover", convertFormJSON($(this)));
            modal_1.modal.notifySuccess(response.message);
            $("form#recover").trigger("reset");
          });
        });
        $("form#reset").on("submit", function(e) {
          e.preventDefault();
          (0, modal_1.tryCatchPopup)(async () => {
            const response = await (0, comm_1.postJson)("/auth/reset", convertFormJSON($(this)));
            modal_1.modal.notifySuccess(response.message, 2e3);
            $("form#reset").trigger("reset");
            setTimeout(function() {
              redirect("login");
            }, 2e3);
          });
        });
        $("form#public_profile").on("submit", function(e) {
          e.preventDefault();
          (0, modal_1.tryCatchPopup)(async () => {
            const response = await (0, comm_1.postJson)("/auth/public_profile", convertFormJSON($(this)));
            modal_1.modal.notifySuccess(response.message, 2e3);
            if (response.achievement) {
              (0, app_1.showAchievements)(response.achievement, true, "");
            } else {
              setTimeout(function() {
                location.reload();
              }, 2e3);
            }
          });
        });
        $("#language").on("change", function() {
          const lang = $(this).val();
          $("#keyword_language").val("en");
          if (lang == "en" || !$("#" + lang + "_option").length) {
            $("#keyword_lang_container").hide();
          } else {
            $(".keyword_lang_option").hide();
            $("#en_option").show();
            $("#" + lang + "_option").show();
            $("#keyword_lang_container").show();
          }
        });
      }
      exports.initializeFormSubmits = initializeFormSubmits;
      function markAsTeacher(checkbox, username, is_teacher, pending_request) {
        $(checkbox).prop("checked", false);
        let text = "Are you sure you want to remove " + username + " as a teacher?";
        if (is_teacher) {
          text = "Are you sure you want to make " + username + " a teacher?";
        }
        modal_1.modal.confirm(text, async () => {
          try {
            await (0, comm_1.postNoResponse)("/admin/markAsTeacher", {
              username,
              is_teacher
            });
            location.reload();
          } catch (e) {
            console.error(e);
            modal_1.modal.notifyError(["Error when", is_teacher ? "marking" : "unmarking", "user", username, "as teacher"].join(" "));
          }
        }, async () => {
          if (pending_request) {
            await (0, comm_1.postJson)("/admin/markAsTeacher", {
              username,
              is_teacher: false
            });
            location.reload();
          }
        });
      }
      exports.markAsTeacher = markAsTeacher;
      function changeUserEmail(username, email) {
        modal_1.modal.prompt("Please enter the corrected email", email, async function(correctedEmail) {
          if (correctedEmail === email)
            return;
          try {
            await (0, comm_1.postJson)("/admin/changeUserEmail", {
              username,
              email: correctedEmail
            });
            location.reload();
          } catch (_a2) {
            modal_1.modal.notifyError(["Error when changing the email for user", username].join(" "));
          }
        });
      }
      exports.changeUserEmail = changeUserEmail;
      function edit_user_tags(username) {
        (0, modal_1.tryCatchPopup)(async () => {
          const response = await (0, comm_1.postJson)("/admin/getUserTags", {
            username
          });
          console.log(response);
          $("#modal-mask").show();
          $("#tags_username").text(username);
          $(".tags-input").prop("checked", false);
          if (response.tags) {
            console.log(response.tags);
            if (jQuery.inArray("certified_teacher", response.tags) !== -1) {
              $("#certified-tag-input").prop("checked", true);
            }
            if (jQuery.inArray("distinguished_user", response.tags) !== -1) {
              $("#distinguished-tag-input").prop("checked", true);
            }
            if (jQuery.inArray("contributor", response.tags) !== -1) {
              $("#contributor-tag-input").prop("checked", true);
            }
          }
          $("#modal-tags").show();
        });
      }
      exports.edit_user_tags = edit_user_tags;
      function update_user_tags() {
        (0, modal_1.tryCatchPopup)(async () => {
          const username = $("#tags_username").text();
          const certified = $("#certified-tag-input").prop("checked");
          const distinguished = $("#distinguished-tag-input").prop("checked");
          const contributor = $("#contributor-tag-input").prop("checked");
          await (0, comm_1.postJson)("/admin/updateUserTags", {
            username,
            certified,
            distinguished,
            contributor
          });
          $("#modal-mask").hide();
          $("#modal-tags").hide();
          modal_1.modal.notifySuccess("Tags successfully updated");
        });
      }
      exports.update_user_tags = update_user_tags;
      async function afterLogin(loginData) {
        var _a2;
        const { url } = (_a2 = (0, local_1.localLoadOnce)(REDIRECT_AFTER_LOGIN_KEY)) !== null && _a2 !== void 0 ? _a2 : {};
        if (url) {
          window.location = url;
          return;
        }
        const joinClassString = localStorage.getItem("hedy-join");
        const joinClass = joinClassString ? JSON.parse(joinClassString) : void 0;
        if (joinClass) {
          localStorage.removeItem("hedy-join");
          return (0, teachers_1.join_class)(joinClass.id, joinClass.name);
        }
        if (loginData["first_time"]) {
          return redirect("landing-page/1");
        }
        if (loginData["admin"]) {
          return redirect("admin");
        }
        if (loginData["teacher"]) {
          return redirect("for-teachers");
        }
        redirect("landing-page");
      }
    }
  });

  // __tmp__/static/js/local-save-warning.js
  var require_local_save_warning = __commonJS({
    "__tmp__/static/js/local-save-warning.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LocalSaveWarning = void 0;
      var SHOW_AFTER_RUN_CLICKS = 10;
      var MIN_LINES_TO_WARN = 20;
      var SHOW_AFTER_MINUTES = 10;
      var LocalSaveWarning = class {
        constructor() {
          this.runCounter = 0;
          this.loggedIn = false;
          this.programLength = 0;
          this.reset();
        }
        setLoggedIn() {
          this.loggedIn = true;
        }
        clickRun() {
          this.runCounter += 1;
          if (this.runCounter >= SHOW_AFTER_RUN_CLICKS) {
            this.display(true);
          }
        }
        setProgramLength(lines) {
          this.programLength = lines;
        }
        switchTab() {
          this.reset();
          const startTime = Date.now();
          if (this.timer) {
            clearInterval(this.timer);
          }
          this.timer = setInterval(() => {
            if (this.programLength >= MIN_LINES_TO_WARN) {
              this.display(true);
            }
            if (Date.now() - startTime >= SHOW_AFTER_MINUTES * 6e4) {
              this.display(true);
            }
          }, 6e4);
        }
        reset() {
          this.runCounter = 0;
          this.programLength = 0;
          this.display(false);
        }
        display(show) {
          if (this.loggedIn) {
            return;
          }
          $("#not-logged-in-warning").toggle(show);
        }
      };
      exports.LocalSaveWarning = LocalSaveWarning;
    }
  });

  // __tmp__/static/js/app.js
  var require_app = __commonJS({
    "__tmp__/static/js/app.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.goToLevel = exports.share_program = exports.triggerAutomaticSave = exports.closeContainingModal = exports.downloadSlides = exports.show_editor = exports.hide_editor = exports.filter_admin = exports.select_profile_image = exports.change_language = exports.toggle_blur_code = exports.toggle_keyword_language = exports.tryCatchErrorBox = exports.toggleDevelopersMode = exports.modalStepOne = exports.confetti_cannon = exports.getEditorContents = exports.get_active_and_trimmed_code = exports.store_parsons_attempt = exports.showVariableView = exports.load_quiz = exports.runPythonProgram = exports.copy_to_clipboard = exports.report_program = exports.set_explore_favourite = exports.submit_program = exports.set_favourite_program = exports.delete_program = exports.viewProgramLink = exports.tryPaletteCode = exports.showAchievements = exports.closeAchievement = exports.pushAchievement = exports.saveMachineFiles = exports.runit = exports.stopit = exports.getHighlighter = exports.initializeHighlightedCodeBlocks = exports.initializeViewProgramPage = exports.initializeCodePage = exports.initializeApp = exports.theKeywordLanguage = exports.theLanguage = exports.theLevel = exports.theLocalSaveWarning = exports.theGlobalSourcemap = exports.theModalEditor = exports.theGlobalEditor = exports.theGlobalDebugger = void 0;
      var syntaxModesRules_1 = require_syntaxModesRules();
      var client_messages_1 = require_client_messages();
      var modal_1 = require_modal();
      var jszip_1 = __importDefault(require_jszip_min());
      var tabs_1 = require_tabs();
      var pythonPrefixes_1 = require_pythonPrefixes();
      var types_1 = require_types();
      var tutorial_1 = require_tutorial();
      var parsons_1 = require_parsons();
      var on_element_becomes_visible_1 = require_on_element_becomes_visible();
      var debugging_1 = require_debugging();
      var local_1 = require_local();
      var auth_1 = require_auth();
      var comm_1 = require_comm();
      var local_save_warning_1 = require_local_save_warning();
      var editor_1 = require_editor();
      var debugging_2 = require_debugging();
      var cm_editor_1 = require_cm_editor();
      var tokens_1 = require_tokens();
      exports.theLocalSaveWarning = new local_save_warning_1.LocalSaveWarning();
      var editorCreator = new cm_editor_1.HedyCodeMirrorEditorCreator();
      var last_code;
      var pygameRunning = false;
      var askPromptOpen = false;
      var theAdventures = {};
      exports.theLevel = 0;
      exports.theLanguage = "";
      exports.theKeywordLanguage = "en";
      var theStaticRoot = "";
      var currentTab;
      var theUserIsLoggedIn;
      var pygame_suffix = `# coding=utf8
pygame_end = True
pygame.quit()
`;
      var slides_template = `
<!DOCTYPE html>
<html class="sl-root decks export offline loaded">

<head>
	<meta name="viewport"
		content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<title>Slides Level - 1</title>
	<link rel="stylesheet" type="text/css" href="lib/offline-v2.css">
</head>

<body class="reveal-viewport theme-font-montserrat theme-color-white-blue">
	<div class="reveal">
		<div class="slides">
			{replace}
		</div>
	</div>

	<!-- Initialize the presentation -->
	<script>
		Reveal.initialize({
			width: 960,
			height: 700,
			margin: 0.05,


			hash: true,
			controls: true,
			progress: true,
			mouseWheel: false,
			showNotes: false,
			slideNumber: false,
			fragmentInURL: true,

			autoSlide: 0,
			autoSlideStoppable: true,

			autoAnimateMatcher: SL.deck.AutoAnimate.matcher,

			center: false,
			shuffle: false,
			loop: false,
			rtl: false,
			navigationMode: "default",

			transition: "slide",
			backgroundTransition: "slide",

			highlight: {
				escapeHTML: false
			},

			plugins: [RevealZoom, RevealNotes, RevealMarkdown, RevealHighlight]
		});
	<\/script>
</body>
</html>
`;
      function initializeApp(options) {
        var _a2;
        exports.theLevel = options.level;
        exports.theKeywordLanguage = options.keywordLanguage;
        theStaticRoot = (_a2 = options.staticRoot) !== null && _a2 !== void 0 ? _a2 : "";
        theStaticRoot = theStaticRoot === "/" ? "" : theStaticRoot;
        (0, syntaxModesRules_1.initializeSyntaxHighlighter)({
          keywordLanguage: options.keywordLanguage
        });
        initializeCopyToClipboard();
        $(document).on("click", function(event2) {
          if (!$(event2.target).closest(".dropdown").length) {
            $(".dropdown-menu").slideUp("medium");
            $(".cheatsheet-menu").slideUp("medium");
            return;
          }
          const allDropdowns = $(".dropdown-menu");
          for (const dd2 of allDropdowns) {
            const c2 = $(dd2).closest(".dropdown")[0];
            if (!$(event2.target).closest(c2).length) {
              $(dd2).slideUp("fast");
            }
          }
        });
        $("#search_language").on("keyup", function() {
          let search_query = $("#search_language").val().toLowerCase();
          $(".language").each(function() {
            if ($(this).html().toLowerCase().includes(search_query)) {
              $(this).show();
            } else {
              $(this).hide();
            }
          });
        });
        $('*[data-autosubmit="true"]').on("change", (ev) => {
          $(ev.target).closest("form").trigger("submit");
        });
        (0, auth_1.initializeLoginLinks)();
      }
      exports.initializeApp = initializeApp;
      function initializeCodePage(options) {
        var _a2;
        theUserIsLoggedIn = !!options.current_user_name;
        if (theUserIsLoggedIn) {
          exports.theLocalSaveWarning.setLoggedIn();
        }
        theAdventures = Object.fromEntries(((_a2 = options.adventures) !== null && _a2 !== void 0 ? _a2 : []).map((a) => [a.short_name, a]));
        if (exports.theLevel != options.level) {
          throw new Error(`initializeApp set level to ${JSON.stringify(exports.theLevel)} but initializeCodePage sets it to ${JSON.stringify(options.level)}`);
        }
        exports.theLanguage = options.lang;
        const $editor = $("#editor");
        if ($editor.length) {
          const dir = $("body").attr("dir");
          exports.theGlobalEditor = editorCreator.initializeEditorWithGutter($editor, editor_1.EditorType.MAIN, dir);
          (0, tokens_1.initializeTranslation)({ keywordLanguage: exports.theKeywordLanguage, level: exports.theLevel });
          attachMainEditorEvents(exports.theGlobalEditor);
          (0, debugging_1.initializeDebugger)({
            editor: exports.theGlobalEditor,
            level: exports.theLevel,
            language: exports.theLanguage,
            keywordLanguage: exports.theKeywordLanguage
          });
        }
        const anchor = window.location.hash.substring(1);
        const validAnchor = [...Object.keys(theAdventures), "parsons", "quiz"].includes(anchor) ? anchor : void 0;
        const tabs = new tabs_1.Tabs({
          initialTab: validAnchor !== null && validAnchor !== void 0 ? validAnchor : options.initial_tab
        });
        tabs.on("beforeSwitch", () => {
          saveIfNecessary();
        });
        tabs.on("afterSwitch", (ev) => {
          currentTab = ev.newTab;
          const adventure = theAdventures[currentTab];
          if (!options.suppress_save_and_load_for_slides) {
            const programFromLs = (0, local_1.localLoad)(currentTabLsKey());
            if (programFromLs && adventure) {
              adventure.start_code = programFromLs.code;
              adventure.save_name = programFromLs.saveName;
              adventure.save_info = "local-storage";
            }
          }
          reconfigurePageBasedOnTab();
          (0, on_element_becomes_visible_1.checkNow)();
          exports.theLocalSaveWarning.switchTab();
        });
        initializeSpeech();
        if (options.start_tutorial) {
          (0, tutorial_1.startIntroTutorial)();
        }
        $("#share_program_button").on("click", () => $("#share-modal").show());
        $("#hand_in_button").on("click", () => $("#hand-in-modal").show());
        initializeShareProgramButtons();
        initializeHandInButton();
        if (options.suppress_save_and_load_for_slides) {
          disableAutomaticSaving();
        }
        window.addEventListener("beforeunload", () => saveIfNecessary(), { capture: true });
        $("#program_name").on("blur", () => saveIfNecessary());
      }
      exports.initializeCodePage = initializeCodePage;
      function attachMainEditorEvents(editor) {
        editor.on("change", () => {
          exports.theLocalSaveWarning.setProgramLength(exports.theGlobalEditor.contents.split("\n").length);
        });
        editor.on("change", function() {
          if (askPromptOpen) {
            stopit();
            exports.theGlobalEditor.focus();
          }
          if ($("#ask-modal").is(":visible"))
            $("#inline-modal").hide();
          askPromptOpen = false;
          $("#runit").css("background-color", "");
          exports.theGlobalEditor.clearErrors();
          exports.theGlobalEditor.clearIncorrectLines();
          (0, debugging_2.stopDebug)();
        });
        editor.on("click", (event2) => {
          editor.skipFaultyHandler(event2);
        });
        let altPressed;
        window.addEventListener("keydown", function(ev) {
          const keyCode = ev.keyCode;
          if (keyCode === 18) {
            altPressed = true;
            return;
          }
          if (keyCode === 13 && altPressed) {
            if (!exports.theLevel || !exports.theLanguage) {
              throw new Error("Oh no");
            }
            runit(exports.theLevel, exports.theLanguage, "", "run", function() {
              $("#output").focus();
            });
          }
          if (keyCode === 37 && document.activeElement === document.getElementById("output")) {
            exports.theGlobalEditor.focus();
            exports.theGlobalEditor.moveCursorToEndOfFile();
          }
        });
        window.addEventListener("keyup", function(ev) {
          triggerAutomaticSave();
          const keyCode = ev.keyCode;
          if (keyCode === 18) {
            altPressed = false;
            return;
          }
        });
      }
      function initializeViewProgramPage(options) {
        exports.theLevel = options.level;
        exports.theLanguage = options.lang;
        const dir = $("body").attr("dir");
        exports.theGlobalEditor = editorCreator.initializeEditorWithGutter($("#editor"), editor_1.EditorType.MAIN, dir);
        (0, tokens_1.initializeTranslation)({
          keywordLanguage: options.lang,
          level: options.level
        });
        attachMainEditorEvents(exports.theGlobalEditor);
        exports.theGlobalEditor.contents = options.code;
        (0, debugging_1.initializeDebugger)({
          editor: exports.theGlobalEditor,
          level: exports.theLevel,
          language: exports.theLanguage,
          keywordLanguage: exports.theKeywordLanguage
        });
      }
      exports.initializeViewProgramPage = initializeViewProgramPage;
      function initializeHighlightedCodeBlocks(where) {
        const dir = $("body").attr("dir");
        (0, parsons_1.initializeParsons)();
        if (exports.theLevel) {
          (0, tokens_1.initializeTranslation)({
            keywordLanguage: exports.theKeywordLanguage,
            level: exports.theLevel
          });
        }
        for (const container of $(where).find(".turn-pre-into-ace").get()) {
          for (const preview of $(container).find("pre").get()) {
            $(preview).addClass("relative text-lg rounded overflow-x-hidden").attr("lang", exports.theKeywordLanguage);
            (0, on_element_becomes_visible_1.onElementBecomesVisible)(preview, () => {
              const codeNode = preview.querySelector("code");
              let code;
              if (codeNode) {
                codeNode.hidden = true;
                code = codeNode.innerText;
              } else {
                code = preview.textContent || "";
                preview.textContent = "";
              }
              const exampleEditor = editorCreator.initializeReadOnlyEditor(preview, dir);
              exampleEditor.contents = code;
              exampleEditor.contents = exampleEditor.contents.trimEnd();
              if ($(preview).hasClass("show-copy-button") || $(container).hasClass("show-copy-button")) {
                const buttonContainer = $("<div>").addClass("absolute ltr:right-0 rtl:left-0 top-0 mx-1 mt-1").appendTo(preview);
                let symbol = "\u21E5";
                if (dir === "rtl") {
                  symbol = "\u21E4";
                }
                $("<button>").css({ fontFamily: "sans-serif" }).addClass("yellow-btn").text(symbol).appendTo(buttonContainer).click(function() {
                  if (!(exports.theGlobalEditor === null || exports.theGlobalEditor === void 0 ? void 0 : exports.theGlobalEditor.isReadOnly)) {
                    exports.theGlobalEditor.contents = exampleEditor.contents + "\n";
                  }
                  update_view("main_editor_keyword_selector", $(preview).attr("lang"));
                  stopit();
                  clearOutput();
                });
              }
              const levelStr = $(preview).attr("level");
              const lang = $(preview).attr("lang");
              if (levelStr && lang) {
                (0, tokens_1.initializeTranslation)({
                  keywordLanguage: lang,
                  level: parseInt(levelStr, 10)
                });
                exampleEditor.setHighlighterForLevel(parseInt(levelStr, 10));
              }
            });
          }
        }
      }
      exports.initializeHighlightedCodeBlocks = initializeHighlightedCodeBlocks;
      function getHighlighter(level) {
        return `ace/mode/level${level}`;
      }
      exports.getHighlighter = getHighlighter;
      function stopit() {
        if (pygameRunning) {
          Sk.insertPyGameEvent("quit");
          Sk.unbindPygameListeners();
          pygameRunning = false;
          document.onkeydown = null;
          $("#pygame-modal").hide();
          $("#stopit").hide();
          $("#runit").show();
        } else {
          Sk.execLimit = 1;
          clearTimeouts();
          $("#stopit").hide();
          $("#runit").show();
          if ($("#ask-modal").is(":visible")) {
            $("#ask-modal form").submit();
            $("#ask-modal").hide();
          }
        }
        askPromptOpen = false;
      }
      exports.stopit = stopit;
      function clearOutput() {
        const outputDiv = $("#output");
        const variableButton = outputDiv.find("#variable_button");
        const variables = outputDiv.find("#variables");
        outputDiv.empty();
        outputDiv.addClass("overflow-auto");
        outputDiv.append(variableButton);
        outputDiv.append(variables);
        modal_1.error.hide();
        modal_1.success.hide();
        const buttonsDiv = $("#dynamic-buttons");
        buttonsDiv.empty();
        buttonsDiv.hide();
      }
      async function runit(level, lang, disabled_prompt, run_type, cb2) {
        const adventureName = currentTab;
        if (askPromptOpen) {
          if (disabled_prompt) {
            return modal_1.modal.notifyError(disabled_prompt);
          }
          return;
        }
        exports.theLocalSaveWarning.clickRun();
        if (typeof Sk.unbindPygameListeners === "function") {
          Sk.unbindPygameListeners();
        }
        Sk.execLimit = 1;
        $("#runit").hide();
        $("#stopit").show();
        $("#saveFilesContainer").hide();
        if (run_type !== "continue") {
          clearOutput();
        }
        try {
          var editor = exports.theGlobalEditor;
          var code = "";
          if ($("#parsons_container").is(":visible")) {
            code = (0, parsons_1.get_parsons_code)();
            if (!code) {
              editor.clearErrors();
              stopit();
              return;
            } else {
              if ($("#next_parson_button").attr("onclick")) {
                $("#next_parson_button").show();
              }
            }
          } else {
            code = get_active_and_trimmed_code();
            if (code.length == 0) {
              editor.clearErrors();
              stopit();
              return;
            }
          }
          editor.clearErrors();
          removeBulb();
          const adventure = theAdventures[adventureName];
          let program_data;
          if (run_type === "run" || run_type === "debug") {
            try {
              cancelPendingAutomaticSave();
              let data = {
                level: `${level}`,
                code,
                lang,
                skip_faulty: false,
                is_debug: run_type === "debug",
                tutorial: $("#code_output").hasClass("z-40"),
                read_aloud: !!$("#speak_dropdown").val(),
                adventure_name: adventureName,
                program_id: (0, types_1.isServerSaveInfo)(adventure === null || adventure === void 0 ? void 0 : adventure.save_info) ? adventure.save_info.id : void 0,
                save_name: saveNameFromInput()
              };
              let response = await postJsonWithAchievements("/parse", data);
              program_data = response;
              console.log("Response", response);
              if (response.Warning && $("#editor").is(":visible")) {
                modal_1.error.showWarning(client_messages_1.ClientMessages["Transpile_warning"], response.Warning);
              }
              showAchievements(response.achievements, false, "");
              if (adventure && response.save_info) {
                adventure.save_info = response.save_info;
                adventure.start_code = code;
              }
              if (response.Error) {
                modal_1.error.show(client_messages_1.ClientMessages["Transpile_error"], response.Error);
                if (response.Location && response.Location[0] != "?") {
                  exports.theGlobalEditor.highlightError(response.Location[0], response.Location[1]);
                }
                $("#stopit").hide();
                $("#runit").show();
                return;
              }
            } catch (e) {
              console.error(e);
              if (e.internetError) {
                modal_1.error.show(client_messages_1.ClientMessages["Connection_error"], client_messages_1.ClientMessages["CheckInternet"]);
              } else {
                modal_1.error.show(client_messages_1.ClientMessages["Other_error"], client_messages_1.ClientMessages["ServerError"]);
              }
            }
          } else {
            program_data = exports.theGlobalDebugger.get_program_data();
          }
          runPythonProgram(program_data.Code, program_data.source_map, program_data.has_turtle, program_data.has_pygame, program_data.has_sleep, program_data.has_clear, program_data.Warning, cb2, run_type).catch(function(err) {
            if (err != null) {
              modal_1.error.show(client_messages_1.ClientMessages["Execute_error"], err.message);
              reportClientError(level, code, err.message);
            }
          });
        } catch (e) {
          modal_1.modal.notifyError(e.responseText);
        }
      }
      exports.runit = runit;
      async function saveMachineFiles() {
        const response = await postJsonWithAchievements("/generate_machine_files", {
          level: exports.theLevel,
          code: get_active_and_trimmed_code(),
          lang: exports.theLanguage
        });
        if (response.filename) {
          window.location.replace("/download_machine_files/" + response.filename);
        }
      }
      exports.saveMachineFiles = saveMachineFiles;
      var ACHIEVEMENTS_PUSHED = {};
      async function pushAchievement(achievement) {
        if (ACHIEVEMENTS_PUSHED[achievement]) {
          return;
        }
        ACHIEVEMENTS_PUSHED[achievement] = true;
        try {
          const response = await (0, comm_1.postJson)("/achievements/push-achievement", { achievement });
          showAchievements(response.achievements, false, "");
        } catch (_a2) {
        }
      }
      exports.pushAchievement = pushAchievement;
      function closeAchievement() {
        $("#achievement_pop-up").hide();
        if ($("#achievement_pop-up").attr("reload")) {
          $("#achievement_pop-up").removeAttr("reload");
          $("#achievement_pop-up").removeAttr("redirect");
          return location.reload();
        }
        if ($("#achievement_pop-up").attr("redirect")) {
          const redirect = $("#achievement_pop-up").attr("redirect");
          $("#achievement_pop-up").removeAttr("reload");
          $("#achievement_pop-up").removeAttr("redirect");
          return window.location.pathname = redirect;
        }
        $("#achievement_pop-up").removeAttr("reload");
        $("#achievement_pop-up").removeAttr("redirect");
      }
      exports.closeAchievement = closeAchievement;
      async function showAchievements(achievements, reload, redirect) {
        if (!achievements || achievements.length === 0) {
          return;
        }
        for (const achievement of achievements) {
          await showAchievement(achievement);
        }
        if (reload) {
          $("#achievement_pop-up").attr("reload", "true");
          setTimeout(function() {
            $("#achievement_pop-up").removeAttr("reload");
            $("#achievement_pop-up").removeAttr("redirect");
            location.reload();
          }, achievements.length * 6e3);
        }
        if (redirect) {
          $("#achievement_pop-up").attr("redirect", redirect);
          setTimeout(function() {
            $("#achievement_pop-up").removeAttr("reload");
            $("#achievement_pop-up").removeAttr("redirect");
            window.location.pathname = redirect;
          }, achievements.length * 6e3);
        }
      }
      exports.showAchievements = showAchievements;
      function showAchievement(achievement) {
        return new Promise((resolve) => {
          $("#achievement_reached_title").text('"' + achievement[0] + '"');
          $("#achievement_reached_text").text(achievement[1]);
          $("#achievement_reached_statics").text(achievement[2]);
          $("#achievement_pop-up").fadeIn(1e3, function() {
            setTimeout(function() {
              $("#achievement_pop-up").fadeOut(1e3);
            }, 4e3);
          });
          setTimeout(() => {
            resolve();
            ;
          }, 6e3);
        });
      }
      function removeBulb() {
        const repair_button = $("#repair_button");
        repair_button.hide();
      }
      function tryPaletteCode(exampleCode) {
        if (exports.theGlobalEditor === null || exports.theGlobalEditor === void 0 ? void 0 : exports.theGlobalEditor.isReadOnly) {
          return;
        }
        exports.theGlobalEditor.contents = exampleCode + "\n";
        if (!($("#editor").attr("lang") == "en")) {
          $("#editor").attr("lang", "en");
          update_view("main_editor_keyword_selector", "en");
        }
      }
      exports.tryPaletteCode = tryPaletteCode;
      function viewProgramLink(programId) {
        return window.location.origin + "/hedy/" + programId + "/view";
      }
      exports.viewProgramLink = viewProgramLink;
      async function delete_program(id, index, prompt) {
        await modal_1.modal.confirmP(prompt);
        await (0, modal_1.tryCatchPopup)(async () => {
          const response = await postJsonWithAchievements("/programs/delete", { id });
          showAchievements(response.achievement, true, "");
          $("#program_" + index).remove();
          modal_1.modal.notifySuccess(response.message);
        });
      }
      exports.delete_program = delete_program;
      function set_favourite(index) {
        $(".favourite_program_container").removeClass("text-yellow-400");
        $(".favourite_program_container").addClass("text-white");
        $("#favourite_program_container_" + index).removeClass("text-white");
        $("#favourite_program_container_" + index).addClass("text-yellow-400");
      }
      async function set_favourite_program(id, index, prompt) {
        await modal_1.modal.confirmP(prompt);
        await (0, modal_1.tryCatchPopup)(async () => {
          const response = await postJsonWithAchievements("/programs/set_favourite", { id });
          set_favourite(index);
          modal_1.modal.notifySuccess(response.message);
        });
      }
      exports.set_favourite_program = set_favourite_program;
      function change_to_submitted(index) {
        $("#non_submitted_button_container_" + index).remove();
        $("#submitted_button_container_" + index).show();
        $("#submitted_header_" + index).show();
        $("#program_" + index).removeClass("border-orange-400");
        $("#program_" + index).addClass("border-gray-400 bg-gray-400");
      }
      function submit_program(id, index) {
        (0, modal_1.tryCatchPopup)(async () => {
          await postJsonWithAchievements("/programs/submit", { id });
          change_to_submitted(index);
        });
      }
      exports.submit_program = submit_program;
      async function set_explore_favourite(id, favourite) {
        let prompt = `Are you sure you want to remove this program as a "Hedy's choice" program?`;
        if (favourite) {
          prompt = `Are you sure you want to set this program as a "Hedy's choice" program?`;
        }
        await modal_1.modal.confirmP(prompt);
        await (0, modal_1.tryCatchPopup)(async () => {
          const response = await postJsonWithAchievements("/programs/set_hedy_choice", {
            id,
            favourite
          });
          modal_1.modal.notifySuccess(response.message);
          $("#" + id).toggleClass("text-white", favourite !== 1);
          $("#" + id).toggleClass("text-yellow-500", favourite === 1);
        });
      }
      exports.set_explore_favourite = set_explore_favourite;
      function report_program(prompt, id) {
        (0, modal_1.tryCatchPopup)(async () => {
          await modal_1.modal.confirmP(prompt);
          const response = await postJsonWithAchievements("/programs/report", { id });
          modal_1.modal.notifySuccess(response.message);
        });
      }
      exports.report_program = report_program;
      function copy_to_clipboard(string, prompt) {
        var _a2, _b;
        var el2 = document.createElement("textarea");
        el2.value = string;
        el2.setAttribute("readonly", "");
        el2.style.position = "absolute";
        el2.style.left = "-9999px";
        document.body.appendChild(el2);
        const selection = document.getSelection();
        const originalSelection = selection && selection.rangeCount > 0 ? selection.getRangeAt(0) : void 0;
        el2.select();
        document.execCommand("copy");
        document.body.removeChild(el2);
        if (originalSelection) {
          (_a2 = document.getSelection()) === null || _a2 === void 0 ? void 0 : _a2.removeAllRanges();
          (_b = document.getSelection()) === null || _b === void 0 ? void 0 : _b.addRange(originalSelection);
        }
        modal_1.modal.hide();
        modal_1.modal.notifySuccess(prompt, 3e3);
      }
      exports.copy_to_clipboard = copy_to_clipboard;
      function reportClientError(level, code, client_error) {
        postJsonWithAchievements("/report_error", {
          level: `${level}`,
          code,
          page: window.location.href,
          client_error
        });
      }
      window.onerror = function reportClientException(message, source, line_number, column_number, error) {
        postJsonWithAchievements("/client_exception", {
          message,
          source,
          line_number,
          column_number,
          error,
          url: window.location.href,
          user_agent: navigator.userAgent
        });
      };
      function runPythonProgram(code, sourceMap, hasTurtle, hasPygame, hasSleep, hasClear, hasWarnings, cb2, run_type) {
        let outputDiv = $("#output");
        let skip_faulty_found_errors = false;
        let warning_box_shown = false;
        if (sourceMap) {
          exports.theGlobalSourcemap = sourceMap;
          for (const index in sourceMap) {
            const map = sourceMap[index];
            const range = {
              startLine: map.hedy_range.from_line,
              startColumn: map.hedy_range.from_column,
              endLine: map.hedy_range.to_line,
              endColumn: map.hedy_range.to_column
            };
            if (map.error != null) {
              skip_faulty_found_errors = true;
              exports.theGlobalEditor.setIncorrectLine(range, Number(index));
            }
            if (skip_faulty_found_errors && !warning_box_shown) {
              modal_1.error.showFadingWarning(client_messages_1.ClientMessages["Execute_error"], client_messages_1.ClientMessages["Errors_found"]);
              warning_box_shown = true;
            }
          }
        }
        let skulptExternalLibraries = {
          "./extensions.js": {
            path: theStaticRoot + "/vendor/skulpt-stdlib-extensions.js"
          }
        };
        Sk.pre = "output";
        const turtleConfig = Sk.TurtleGraphics || (Sk.TurtleGraphics = {});
        turtleConfig.target = "turtlecanvas";
        if ($("#adventures-tab").is(":hidden")) {
          turtleConfig.height = 600;
          turtleConfig.worldHeight = 600;
        } else if ($("#turtlecanvas").attr("raw") == "yes") {
          turtleConfig.height = 150;
          turtleConfig.worldHeight = 250;
        } else {
          turtleConfig.height = 300;
          turtleConfig.worldHeight = 300;
        }
        turtleConfig.width = outputDiv.width();
        turtleConfig.worldWidth = outputDiv.width();
        let code_prefix = pythonPrefixes_1.normal_prefix;
        if (!hasTurtle && !hasPygame) {
          $("#turtlecanvas").empty();
        }
        if (hasTurtle) {
          code_prefix += pythonPrefixes_1.turtle_prefix;
          $("#turtlecanvas").show();
        }
        if (hasPygame) {
          skulptExternalLibraries = {
            "./extensions.js": {
              path: theStaticRoot + "/vendor/skulpt-stdlib-extensions.js"
            },
            "./pygame.js": {
              path: theStaticRoot + "/vendor/pygame_4_skulpt/init.js"
            },
            "./display.js": {
              path: theStaticRoot + "/vendor/pygame_4_skulpt/display.js"
            },
            "./draw.js": {
              path: theStaticRoot + "/vendor/pygame_4_skulpt/draw.js"
            },
            "./event.js": {
              path: theStaticRoot + "/vendor/pygame_4_skulpt/event.js"
            },
            "./font.js": {
              path: theStaticRoot + "/vendor/pygame_4_skulpt/font.js"
            },
            "./image.js": {
              path: theStaticRoot + "/vendor/pygame_4_skulpt/image.js"
            },
            "./key.js": {
              path: theStaticRoot + "/vendor/pygame_4_skulpt/key.js"
            },
            "./mouse.js": {
              path: theStaticRoot + "/vendor/pygame_4_skulpt/mouse.js"
            },
            "./transform.js": {
              path: theStaticRoot + "/vendor/pygame_4_skulpt/transform.js"
            },
            "./locals.js": {
              path: theStaticRoot + "/vendor/pygame_4_skulpt/locals.js"
            },
            "./time.js": {
              path: theStaticRoot + "/vendor/pygame_4_skulpt/time.js"
            },
            "./version.js": {
              path: theStaticRoot + "/vendor/pygame_4_skulpt/version.js"
            },
            "./buttons.js": {
              path: theStaticRoot + "/js/buttons.js"
            }
          };
          code_prefix += pythonPrefixes_1.pygame_prefix;
          initSkulpt4Pygame();
          initCanvas4PyGame();
          let pygameModal = $("#pygame-modal");
          const codeContainsInputFunctionBeforePygame = new RegExp("input\\([\\s\\S]*\\)[\\s\\S]*while not pygame_end", "gm").test(code);
          if (!codeContainsInputFunctionBeforePygame) {
            pygameModal.show();
          }
          if (hasTurtle) {
            pygameModal.addClass("absolute");
            pygameModal.addClass("bottom-0");
            pygameModal.addClass("w-full");
          } else {
            pygameModal.removeClass("absolute");
            pygameModal.removeClass("bottom-0");
            pygameModal.removeClass("w-full");
          }
          document.onkeydown = animateKeys;
          pygameRunning = true;
        }
        code = code_prefix + code;
        if (hasPygame)
          code += pygame_suffix;
        if (run_type === "run") {
          Sk.configure({
            output: outf,
            read: builtinRead,
            inputfun: inputFromInlineModal,
            inputfunTakesPrompt: true,
            setTimeout: timeout,
            __future__: Sk.python3,
            timeoutMsg: function() {
              $("#stopit").hide();
              $("#runit").show();
              if (Sk.execLimit != 1) {
                pushAchievement("hedy_hacking");
                return client_messages_1.ClientMessages["Program_too_long"];
              } else {
                return null;
              }
            },
            execLimit: function() {
              const level = exports.theLevel;
              if (hasTurtle || hasPygame) {
                return 6e6;
              }
              if (level < 7) {
                return 3e6;
              }
              return hasSleep ? 2e4 : 5e3;
            }()
          });
          return Sk.misceval.asyncToPromise(() => Sk.importMainWithBody("<stdin>", false, code, true), {
            "*": () => {
            }
          }).then(function(_mod) {
            console.log("Program executed");
            const pythonVariables = Sk.globals;
            (0, debugging_1.load_variables)(pythonVariables);
            $("#stopit").hide();
            $("#runit").show();
            if (hasPygame) {
              document.onkeydown = null;
              $("#pygame-modal").hide();
            }
            if (hasTurtle) {
              $("#saveFilesContainer").show();
            }
            if (!hasClear && $("#output").is(":empty") && $("#turtlecanvas").is(":empty")) {
              pushAchievement("error_or_empty");
              modal_1.error.showWarning(client_messages_1.ClientMessages["Transpile_warning"], client_messages_1.ClientMessages["Empty_output"]);
              return;
            }
            if (!hasWarnings && code !== last_code) {
              showSuccesMessage();
              last_code = code;
            }
            if (cb2)
              cb2();
          }).catch(function(err) {
            const errorMessage = errorMessageFromSkulptError(err) || null;
            if (!errorMessage) {
              throw null;
            }
            throw new Error(errorMessage);
          });
        } else if (run_type === "debug") {
          exports.theGlobalDebugger = new Sk.Debugger("<stdin>", debugging_1.incrementDebugLine, debugging_2.stopDebug);
          exports.theGlobalSourcemap = sourceMap;
          Sk.configure({
            output: outf,
            read: builtinRead,
            inputfun: inputFromInlineModal,
            inputfunTakesPrompt: true,
            __future__: Sk.python3,
            debugging: true,
            breakpoints: exports.theGlobalDebugger.check_breakpoints.bind(exports.theGlobalDebugger),
            execLimit: null
          });
          let lines = code.split("\n");
          for (let i = 0; i < lines.length; i++) {
            if (lines[i].includes("# __BREAKPOINT__") && !lines[i].includes("x__x__x__x")) {
              exports.theGlobalDebugger.add_breakpoint("<stdin>.py", i + 1, "0", false);
            }
          }
          if (!hasWarnings && code !== last_code && !skip_faulty_found_errors) {
            last_code = code;
          }
          exports.theGlobalDebugger.set_code_starting_line(code_prefix.split("\n").length - 1);
          exports.theGlobalDebugger.set_code_lines(code.split("\n"));
          exports.theGlobalDebugger.set_program_data({
            Code: code,
            source_map: sourceMap,
            has_turtle: hasTurtle,
            has_pygame: hasPygame,
            has_clear: hasClear,
            Warning: hasWarnings
          });
          (0, debugging_1.startDebug)();
          return exports.theGlobalDebugger.startDebugger(() => Sk.importMainWithBody("<stdin>", false, code, true), exports.theGlobalDebugger).then(function() {
            console.log("Program executed");
            $("#stopit").hide();
            $("#runit").show();
            (0, debugging_2.stopDebug)();
            if (hasPygame) {
              document.onkeydown = null;
              $("#pygame-modal").hide();
            }
            if (hasTurtle) {
              $("#saveFilesContainer").show();
            }
            if (cb2)
              cb2();
          }).catch(function(err) {
            const errorMessage = errorMessageFromSkulptError(err) || null;
            if (!errorMessage) {
              throw null;
            }
            throw new Error(errorMessage);
          });
        } else {
          return exports.theGlobalDebugger.continueForward().catch(function(err) {
            console.error(err);
            const errorMessage = errorMessageFromSkulptError(err) || null;
            if (!errorMessage) {
              throw null;
            }
            throw new Error(errorMessage);
          });
        }
        function errorMessageFromSkulptError(err) {
          const message = err.args && err.args.v && err.args.v[0] && err.args.v[0].v;
          return message;
        }
        function addToOutput(text, color) {
          $("<span>").text(text).css({ color }).appendTo(outputDiv);
          scrollOutputToBottom();
        }
        function outf(text) {
          addToOutput(text, "white");
          speak(text);
        }
        function builtinRead(x) {
          if (x in skulptExternalLibraries) {
            const tmpPath = skulptExternalLibraries[x]["path"];
            if (x === "./pygame.js") {
              return Sk.misceval.promiseToSuspension(fetch(tmpPath).then((r) => r.text()));
            } else {
              let request = new XMLHttpRequest();
              request.open("GET", tmpPath, false);
              request.send();
              if (request.status !== 200) {
                return void 0;
              }
              return request.responseText;
            }
          }
          if (Sk.builtinFiles === void 0 || Sk.builtinFiles["files"][x] === void 0)
            throw "File not found: '" + x + "'";
          return Sk.builtinFiles["files"][x];
        }
        function inputFromInlineModal(prompt) {
          var storage = window.localStorage;
          var debug = storage.getItem("debugLine");
          if (storage.getItem("prompt-" + prompt) == null) {
            Sk.execStart = new Date(new Date().getTime() + 1e3 * 60 * 60 * 24 * 365);
            $("#turtlecanvas").hide();
            if (pygameRunning) {
              Sk.unbindPygameListeners();
              document.onkeydown = null;
              $("#pygame-modal").hide();
            }
            return new Promise(function(ok) {
              askPromptOpen = true;
              const input = $('#ask-modal input[type="text"]');
              $("#ask-modal .caption").text(prompt);
              input.val("");
              input.attr("placeholder", prompt);
              speak(prompt);
              setTimeout(function() {
                input.focus();
              }, 0);
              $("#ask-modal form").one("submit", function(event2) {
                askPromptOpen = false;
                event2.preventDefault();
                $("#ask-modal").hide();
                if (hasTurtle) {
                  $("#turtlecanvas").show();
                }
                if (pygameRunning) {
                  Sk.bindPygameListeners();
                  document.onkeydown = animateKeys;
                  if (!hasTurtle) {
                    $("#pygame-modal").show();
                  }
                }
                Sk.execStart = new Date();
                setTimeout(function() {
                  ok(input.val());
                  if (debug != null) {
                    storage.setItem("prompt-" + prompt, input.val().toString());
                  }
                  $("#output").focus();
                }, 0);
                return false;
              });
              $("#ask-modal").show();
              scrollOutputToBottom();
            });
          } else {
            return new Promise(function(ok) {
              ok(storage.getItem("prompt-" + prompt));
            });
          }
        }
      }
      exports.runPythonProgram = runPythonProgram;
      function resetTurtleTarget() {
        if (Sk.TurtleGraphics !== void 0) {
          let selector = Sk.TurtleGraphics.target;
          let target = typeof selector === "string" ? document.getElementById(selector) : selector;
          if (target !== null && target !== void 0) {
            while (target.firstChild) {
              target.removeChild(target.firstChild);
            }
            return target;
          }
        }
        return null;
      }
      function animateKeys(event2) {
        const keyColors = ["#cbd5e0", "#bee3f8", "#4299e1", "#ff617b", "#ae81ea", "#68d391"];
        const output = $("#output");
        if (output !== null) {
          let keyElement = $("<div></div>");
          output.append(keyElement);
          keyElement.text(event2.key);
          keyElement.css("color", keyColors[Math.floor(Math.random() * keyColors.length)]);
          keyElement.addClass("animate-keys");
          setTimeout(function() {
            keyElement.remove();
          }, 1500);
        }
      }
      function initCanvas4PyGame() {
        let currentTarget = resetTurtleTarget();
        let div1 = document.createElement("div");
        if (currentTarget !== null) {
          currentTarget.appendChild(div1);
          $(div1).addClass("modal");
          $(div1).css("text-align", "center");
          $(div1).css("display", "none");
          let div2 = document.createElement("div");
          $(div2).addClass("modal-dialog modal-lg");
          $(div2).css("display", "inline-block");
          $(div2).width(void 0 + 42);
          $(div2).attr("role", "document");
          div1.appendChild(div2);
          let div3 = document.createElement("div");
          $(div3).addClass("modal-content");
          div2.appendChild(div3);
          let div4 = document.createElement("div");
          $(div4).addClass("modal-header d-flex justify-content-between");
          let div5 = document.createElement("div");
          $(div5).addClass("modal-body");
          let div6 = document.createElement("div");
          $(div6).addClass("modal-footer");
          let div7 = document.createElement("div");
          $(div7).addClass("col-md-8");
          let div8 = document.createElement("div");
          $(div8).addClass("col-md-4");
          div3.appendChild(div4);
          div3.appendChild(div5);
          div3.appendChild(div6);
          $(Sk.main_canvas).css("border", "none");
          $(Sk.main_canvas).css("display", "none");
          div5.appendChild(Sk.main_canvas);
        }
      }
      function initSkulpt4Pygame() {
        Sk.main_canvas = document.createElement("canvas");
        Sk.configure({
          killableWhile: true,
          killableFor: true,
          __future__: Sk.python3
        });
      }
      function speak(text) {
        var selectedURI = $("#speak_dropdown").val();
        if (!selectedURI) {
          return;
        }
        var voice = window.speechSynthesis.getVoices().filter((v) => v.voiceURI === selectedURI)[0];
        if (voice) {
          let utterance = new SpeechSynthesisUtterance(text);
          utterance.voice = voice;
          utterance.rate = 0.9;
          speechSynthesis.speak(utterance);
        }
        pushAchievement("make_some_noise");
      }
      function initializeSpeech() {
        const isBeingTested = !!window.Cypress;
        if (!window.speechSynthesis && !isBeingTested) {
          return;
        }
        if (!exports.theLanguage) {
          return;
        }
        let attempts = 0;
        const timer = setInterval(function() {
          attempts += 1;
          const voices = findVoices(exports.theLanguage);
          if (voices.length > 0 || isBeingTested) {
            for (const voice of voices) {
              $("#speak_dropdown").append($("<option>").attr("value", voice.voiceURI).text("\u{1F4E3} " + voice.name));
            }
            $("#speak_container").show();
            clearInterval(timer);
          }
          if (attempts >= 20) {
            clearInterval(timer);
          }
        }, 100);
        function findVoices(lang) {
          const m = lang.match(/^([a-z]+)/i);
          if (!m) {
            return [];
          }
          const simpleLang = m[1];
          if (!window.speechSynthesis) {
            return [];
          }
          return window.speechSynthesis.getVoices().filter((voice) => voice.lang.startsWith(simpleLang));
        }
      }
      function load_quiz(level) {
        $('*[data-tabtarget="quiz"]').html('<iframe id="quiz-iframe" class="w-full" title="Quiz" src="/quiz/start/' + level + '"></iframe>');
      }
      exports.load_quiz = load_quiz;
      function showVariableView() {
        const variables = $("#variables");
        if (variables.is(":hidden")) {
          variables.show();
          $("#variables").trigger("click");
        } else {
          variables.hide();
        }
      }
      exports.showVariableView = showVariableView;
      async function store_parsons_attempt(order, correct) {
        try {
          await postJsonWithAchievements("/store_parsons_order", {
            level: exports.theLevel,
            exercise: $("#next_parson_button").attr("current_exercise"),
            order,
            correct
          });
        } catch (e) {
          console.error(e);
        }
        ;
      }
      exports.store_parsons_attempt = store_parsons_attempt;
      function get_active_and_trimmed_code() {
        exports.theGlobalEditor.trimTrailingSpace();
        const storage = window.localStorage;
        const debugLine = storage.getItem("debugLine");
        return exports.theGlobalEditor.getActiveContents(debugLine);
      }
      exports.get_active_and_trimmed_code = get_active_and_trimmed_code;
      function getEditorContents() {
        return exports.theGlobalEditor.contents;
      }
      exports.getEditorContents = getEditorContents;
      function confetti_cannon() {
        const canvas = document.getElementById("confetti");
        if (canvas) {
          canvas.classList.remove("hidden");
          const jsConfetti = new JSConfetti({ canvas });
          setTimeout(function() {
            canvas.classList.add("hidden");
          }, 3e3);
          let adventures = $("#adventures");
          let currentAdventure = $(adventures).find(".tab-selected").attr("data-tab");
          let customLevels = ["turtle", "rock", "haunted", "restaurant", "fortune", "songs", "dice"];
          if (customLevels.includes(currentAdventure)) {
            let currentAdventureConfetti = getConfettiForAdventure(currentAdventure !== null && currentAdventure !== void 0 ? currentAdventure : "");
            jsConfetti.addConfetti({
              emojis: currentAdventureConfetti,
              emojiSize: 45,
              confettiNumber: 100
            });
          } else {
            jsConfetti.addConfetti();
          }
          const confettiButton = document.getElementById("confetti-button");
          if (confettiButton) {
            confettiButton.classList.add("hidden");
          }
        }
      }
      exports.confetti_cannon = confetti_cannon;
      function getConfettiForAdventure(adventure) {
        if (client_messages_1.ClientMessages[adventure]) {
          return Array.from(client_messages_1.ClientMessages[adventure]).filter((x) => x !== "," && x !== " ");
        }
        return [["\u{1F308}"], ["\u26A1\uFE0F"], ["\u{1F4A5}"], ["\u2728"], ["\u{1F4AB}"]];
      }
      function scrollOutputToBottom() {
        const outputDiv = $("#output");
        outputDiv.scrollTop(outputDiv.prop("scrollHeight"));
      }
      function modalStepOne(level) {
        createModal(level);
        let $modalEditor = $("#modal-editor");
        if ($modalEditor.length) {
          const dir = $("body").attr("dir");
          exports.theModalEditor = editorCreator.initializeEditorWithGutter($modalEditor, editor_1.EditorType.MODAL, dir);
        }
      }
      exports.modalStepOne = modalStepOne;
      function showSuccesMessage() {
        removeBulb();
        var allsuccessmessages = client_messages_1.ClientMessages["Transpile_success"].split("\n");
        var randomnum = Math.floor(Math.random() * allsuccessmessages.length);
        modal_1.success.show(allsuccessmessages[randomnum]);
      }
      function createModal(level) {
        let editor = `<div id='modal-editor' class="w-full flex-1 text-lg rounded" style='height:200px; width:50vw;'></div>`.replace("{level}", level.toString());
        let title = client_messages_1.ClientMessages["Program_repair"];
        modal_1.modal.repair(editor, 0, title);
      }
      function toggleDevelopersMode(event2 = "click", enforceDevMode) {
        let enable = false;
        switch (event2) {
          case "load":
            const lastSelection = window.localStorage.getItem("developer_mode") === "true";
            enable = enforceDevMode || lastSelection;
            $("#developers_toggle").prop("checked", enable);
            break;
          case "click":
            enable = $("#developers_toggle").prop("checked");
            window.localStorage.setItem("developer_mode", `${enable}`);
            if (enable) {
              pushAchievement("lets_focus");
            }
            break;
        }
        $("#adventures").toggle(!enable);
        if (currentTab === "parsons")
          return;
        $("[data-devmodeheight]").each((_, el2) => {
          const heights = $(el2).data("devmodeheight").split(",");
          $(el2).css("height", heights[enable ? 1 : 0]);
        });
      }
      exports.toggleDevelopersMode = toggleDevelopersMode;
      async function tryCatchErrorBox(cb2) {
        try {
          return await cb2();
        } catch (e) {
          console.log("Error", e);
          modal_1.error.show(client_messages_1.ClientMessages["Transpile_error"], e.message);
        }
      }
      exports.tryCatchErrorBox = tryCatchErrorBox;
      function toggle_keyword_language(current_lang, new_lang) {
        tryCatchErrorBox(async () => {
          const response = await postJsonWithAchievements("/translate_keywords", {
            code: exports.theGlobalEditor.contents,
            start_lang: current_lang,
            goal_lang: new_lang,
            level: exports.theLevel
          });
          if (response.success) {
            const code = response.code;
            exports.theGlobalEditor.contents = code;
            const saveName = saveNameFromInput();
            (0, local_1.localSave)(currentTabLsKey(), { saveName, code });
            $("#editor").attr("lang", new_lang);
            const hash = window.location.hash;
            const queryString = window.location.search;
            const urlParams = new URLSearchParams(queryString);
            urlParams.set("keyword_language", new_lang);
            window.location.search = urlParams.toString();
            window.open(hash, "_self");
          }
        });
      }
      exports.toggle_keyword_language = toggle_keyword_language;
      function toggle_blur_code() {
        $(".blur-toggle").toggle();
        if ($("#editor").attr("blurred") == "true") {
          $("#editor").css("filter", "");
          $("#editor").css("-webkit-filter", "");
          $("#editor").attr("blurred", "false");
        } else {
          $("#editor").css("filter", "blur(3px)");
          $("#editor").css("-webkit-filter", "blur(3px)");
          $("#editor").attr("blurred", "true");
        }
      }
      exports.toggle_blur_code = toggle_blur_code;
      async function change_language(lang) {
        await (0, modal_1.tryCatchPopup)(async () => {
          const response = await postJsonWithAchievements("/change_language", { lang });
          if (response.succes) {
            const queryString = window.location.search;
            const urlParams = new URLSearchParams(queryString);
            if (urlParams.get("keyword_language") !== null) {
              urlParams.set("keyword_language", "en");
            }
            if (urlParams.get("language") !== null) {
              urlParams.set("language", lang);
              window.location.search = urlParams.toString();
            } else {
              location.reload();
            }
          }
        });
      }
      exports.change_language = change_language;
      async function postJsonWithAchievements(url, data) {
        const response = await (0, comm_1.postJson)(url, data);
        showAchievements(response.achievement, true, "");
        return response;
      }
      function update_view(selector_container, new_lang) {
        $("#" + selector_container + " > div").map(function() {
          if ($(this).attr("lang") == new_lang) {
            $(this).show();
          } else {
            $(this).hide();
          }
        });
      }
      function select_profile_image(image) {
        $(".profile_image").removeClass("border-2 border-blue-600");
        $("#profile_image_" + image).addClass("border-2 border-blue-600");
        $("#image").val(image);
      }
      exports.select_profile_image = select_profile_image;
      function filter_admin() {
        const params = {};
        const filter = $("#admin_filter_category").val();
        params["filter"] = filter;
        if ($("#hidden-page-input").val()) {
          params["page"] = $("#hidden-page-input").val();
        }
        switch (filter) {
          case "email":
          case "username":
            params["substring"] = $("#email_filter_input").val();
            break;
          case "language":
            params["language"] = $("#language_filter_input").val();
            break;
          case "keyword_language":
            params["keyword_language"] = $("#keyword_language_filter_input").val();
            break;
          default:
            params["start"] = $("#admin_start_date").val();
            params["end"] = $("#admin_end_date").val();
            break;
        }
        const queryString = Object.entries(params).map(([k, v]) => k + "=" + encodeURIComponent(v)).join("&");
        window.open("?" + queryString, "_self");
      }
      exports.filter_admin = filter_admin;
      function hide_editor() {
        $("#fold_in_toggle_container").hide();
        $("#code_editor").toggle();
        $("#code_output").addClass("col-span-2");
        $("#fold_out_toggle_container").show();
      }
      exports.hide_editor = hide_editor;
      function show_editor() {
        $("#fold_out_toggle_container").hide();
        $("#code_editor").toggle();
        $("#code_output").removeClass("col-span-2");
        $("#fold_in_toggle_container").show();
      }
      exports.show_editor = show_editor;
      var timers = [];
      var timeout = (func, delay) => {
        let id;
        const wrapper = () => {
          let idx = timers.indexOf(id);
          if (idx > -1) {
            timers.splice(idx, 1);
          }
          func();
        };
        id = window.setTimeout(wrapper, delay);
        timers.push(id);
      };
      var clearTimeouts = () => {
        timers.forEach(clearTimeout);
        timers = [];
      };
      function downloadSlides(level) {
        var iframe = document.getElementById(`level-${level}-slides`);
        iframe.setAttribute("src", `/slides/${level}`);
        $(`#level-${level}-slides`).on("load", function() {
          var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
          var slides = innerDoc.getElementsByTagName("section");
          var slidesHTML = "";
          for (let i = 0; i < slides.length; i++) {
            var innerIframe = slides[i].getElementsByTagName("iframe");
            for (let j2 = 0; j2 < innerIframe.length; j2++) {
              var a = document.createElement("a");
              a.href = "https://www.hedy.org" + innerIframe[j2].getAttribute("src");
              a.appendChild(document.createTextNode(a.href));
              slides[i].appendChild(a);
              slides[i].removeChild(innerIframe[j2]);
            }
            slidesHTML += "\n" + slides[i].outerHTML;
          }
          var template = slides_template.replace("{replace}", slidesHTML);
          var zip = (0, jszip_1.default)();
          zip.file("index.html", template);
          zip.folder("lib");
          zip.folder(`hedy-level-${level}`);
          zip.generateAsync({ type: "blob" }).then(function(content) {
            download(content, `hedy-level-${level}.zip`, "zip");
          });
        });
      }
      exports.downloadSlides = downloadSlides;
      function download(data, filename, type) {
        var file = new Blob([data], { type });
        var a = document.createElement("a"), url = URL.createObjectURL(file);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(function() {
          document.body.removeChild(a);
          window.URL.revokeObjectURL(url);
        }, 0);
      }
      function resetWindow() {
        $("#warningbox").hide();
        $("#errorbox").hide();
        $("#okbox").hide();
        $("#repair_button").hide();
        const output = $("#output");
        const variable_button = $(output).find("#variable_button");
        const variables = $(output).find("#variables");
        output.empty();
        $("#turtlecanvas").empty();
        output.append(variable_button);
        output.append(variables);
        exports.theGlobalEditor === null || exports.theGlobalEditor === void 0 ? void 0 : exports.theGlobalEditor.clearSelection();
        exports.theGlobalEditor === null || exports.theGlobalEditor === void 0 ? void 0 : exports.theGlobalEditor.clearBreakpoints();
      }
      function updatePageElements() {
        var _a2;
        const isCodeTab = !(currentTab === "quiz" || currentTab === "parsons");
        $("#adventures-tab").toggle(!(isCodeTab && $("#developers_toggle").is(":checked")));
        $("#developers_toggle_container").toggle(isCodeTab);
        $("#level-header input").toggle(isCodeTab);
        $("#parsons_code_container").toggle(currentTab === "parsons");
        $("#editor-area").toggle(isCodeTab || currentTab === "parsons");
        $("#editor").toggle(isCodeTab);
        $("#debug_container").toggle(isCodeTab);
        $("#program_name_container").toggle(isCodeTab);
        exports.theGlobalEditor.isReadOnly = false;
        const adventure = theAdventures[currentTab];
        if (adventure) {
          const saveInfo = (0, types_1.isServerSaveInfo)(adventure.save_info) ? adventure.save_info : { id: "*dummy*" };
          const isPublic = !!saveInfo.public;
          $("#share_program_button").toggleClass("active-bluebar-btn", isPublic);
          $(`#share-${isPublic ? "public" : "private"}`).prop("checked", true);
          $('[data-view="if-public"]').toggle(isPublic);
          $('[data-view="if-public-url"]').toggle(!!saveInfo.public_url);
          $('input[data-view="public-url"]').val((_a2 = saveInfo.public_url) !== null && _a2 !== void 0 ? _a2 : "");
          const isSubmitted = !!saveInfo.submitted;
          $("#hand_in_button").toggleClass("active-bluebar-btn", isSubmitted);
          $('[data-view="if-submitted"]').toggle(isSubmitted);
          $('[data-view="if-not-submitted"]').toggle(!isSubmitted);
          exports.theGlobalEditor.isReadOnly = isSubmitted;
        }
      }
      function reconfigurePageBasedOnTab() {
        resetWindow();
        updatePageElements();
        if (currentTab === "parsons") {
          (0, parsons_1.loadParsonsExercise)(exports.theLevel, 1);
          document.getElementById("code_editor").style.height = "100%";
          document.getElementById("code_output").style.height = "100%";
          return;
        } else {
          $("[data-devmodeheight]").each((_, el2) => {
            const heights = $(el2).data("devmodeheight").split(",");
            $(el2).css("height", heights[0]);
          });
        }
        const adventure = theAdventures[currentTab];
        if (adventure) {
          $("#program_name").val(adventure.save_name);
          exports.theGlobalEditor.contents = adventure.start_code;
        }
      }
      function closeContainingModal(target) {
        $(target).closest('[data-modal="true"]').hide();
      }
      exports.closeContainingModal = closeContainingModal;
      function initializeShareProgramButtons() {
        $('input[type="radio"][name="public"]').on("change", (ev) => {
          if (ev.target.checked) {
            const isPublic = $(ev.target).val() === "1" ? true : false;
            const adventure = theAdventures[currentTab];
            (0, modal_1.tryCatchPopup)(async () => {
              await saveIfNecessary();
              const saveInfo = (0, types_1.isServerSaveInfo)(adventure === null || adventure === void 0 ? void 0 : adventure.save_info) ? adventure === null || adventure === void 0 ? void 0 : adventure.save_info : void 0;
              if (!saveInfo) {
                throw new Error("This program does not have an id");
              }
              const response = await postJsonWithAchievements("/programs/share", {
                id: saveInfo.id,
                public: isPublic
              });
              modal_1.modal.notifySuccess(response.message);
              if (response.save_info) {
                adventure.save_info = response.save_info;
              }
              updatePageElements();
            });
          }
        });
      }
      function initializeHandInButton() {
        $("#do_hand_in_button").on("click", () => {
          const adventure = theAdventures[currentTab];
          (0, modal_1.tryCatchPopup)(async () => {
            await saveIfNecessary();
            const saveInfo = (0, types_1.isServerSaveInfo)(adventure === null || adventure === void 0 ? void 0 : adventure.save_info) ? adventure.save_info : void 0;
            if (!saveInfo) {
              throw new Error("This program does not have an id");
            }
            const response = await postJsonWithAchievements("/programs/submit", {
              id: saveInfo.id
            });
            modal_1.modal.notifySuccess(response.message);
            if (response.save_info) {
              adventure.save_info = response.save_info;
            }
            updatePageElements();
          });
        });
      }
      function initializeCopyToClipboard() {
        $('[data-action="copy-to-clipboard"]').on("click", (ev) => {
          const text = $(ev.target).closest('[data-copy="container"]').find("input").val();
          if (typeof text === "string") {
            copy_to_clipboard(text, client_messages_1.ClientMessages.copy_link_to_share);
          }
        });
      }
      function saveNameFromInput() {
        return $("#program_name").val();
      }
      function programNeedsSaving(adventureName) {
        const adventure = theAdventures[adventureName];
        if (!adventure) {
          return false;
        }
        const programChanged = exports.theGlobalEditor.contents !== adventure.start_code;
        const nameChanged = $("#program_name").val() !== adventure.save_name;
        const localStorageCanBeSavedToServer = theUserIsLoggedIn && adventure.save_info === "local-storage";
        const isUnchangeable = (0, types_1.isServerSaveInfo)(adventure.save_info) ? adventure.save_info.submitted : false;
        const wasSavedBefore = adventure.save_info !== void 0;
        const suspiciouslySmallFraction = 0.5;
        const programSuspiciouslyShrunk = wasSavedBefore && exports.theGlobalEditor.contents.length < adventure.start_code.length * suspiciouslySmallFraction;
        return (programChanged || nameChanged || localStorageCanBeSavedToServer) && !isUnchangeable && !programSuspiciouslyShrunk;
      }
      var saveTimer;
      function triggerAutomaticSave() {
        const saveSeconds = 20;
        cancelPendingAutomaticSave();
        saveTimer = window.setTimeout(() => saveIfNecessary(), saveSeconds * 1e3);
      }
      exports.triggerAutomaticSave = triggerAutomaticSave;
      function cancelPendingAutomaticSave() {
        if (saveTimer) {
          window.clearTimeout(saveTimer);
        }
      }
      var autoSaveEnabled = true;
      function disableAutomaticSaving() {
        autoSaveEnabled = false;
      }
      async function saveIfNecessary() {
        if (!autoSaveEnabled) {
          return;
        }
        const adventureName = currentTab;
        const adventure = theAdventures[adventureName];
        if (!programNeedsSaving(adventureName) || !adventure) {
          return;
        }
        console.info("Saving program automatically...");
        const code = exports.theGlobalEditor.contents;
        const saveName = saveNameFromInput();
        if (theUserIsLoggedIn) {
          const saveInfo = (0, types_1.isServerSaveInfo)(adventure.save_info) ? adventure.save_info : void 0;
          const response = await postJsonWithAchievements("/programs", {
            level: exports.theLevel,
            lang: exports.theLanguage,
            name: saveName,
            code,
            adventure_name: adventureName,
            program_id: saveInfo === null || saveInfo === void 0 ? void 0 : saveInfo.id,
            share: saveInfo === null || saveInfo === void 0 ? void 0 : saveInfo.public
          });
          adventure.start_code = code;
          if (response.save_info) {
            adventure.save_info = response.save_info;
          }
          (0, local_1.localDelete)(currentTabLsKey());
        } else {
          (0, local_1.localSave)(currentTabLsKey(), { saveName, code });
          adventure.start_code = code;
        }
      }
      function currentTabLsKey() {
        return `save-${currentTab}-${exports.theLevel}`;
      }
      async function share_program(id, index, Public, prompt) {
        await modal_1.modal.confirmP(prompt);
        await (0, modal_1.tryCatchPopup)(async () => {
          const response = await postJsonWithAchievements("/programs/share", { id, public: Public });
          showAchievements(response.achievement, true, "");
          if (Public) {
            change_shared(true, index);
          } else {
            change_shared(false, index);
          }
          modal_1.modal.notifySuccess(response.message);
        });
      }
      exports.share_program = share_program;
      function change_shared(shared, index) {
        if (index == -1) {
          return;
        }
        if (shared) {
          $("#non_public_button_container_" + index).hide();
          $("#public_button_container_" + index).show();
          $("#favourite_program_container_" + index).show();
        } else {
          $("#modal-copy-button").hide();
          $("#public_button_container_" + index).hide();
          $("#non_public_button_container_" + index).show();
          $("#favourite_program_container_" + index).hide();
          $("#favourite_program_container_" + index).removeClass("text-yellow-400");
          $("#favourite_program_container_" + index).addClass("text-white");
        }
      }
      function goToLevel(level) {
        window.location.hash = "";
        let newPath = window.location.pathname.replace(/\d+/, level);
        if (!newPath.includes(level)) {
          newPath = window.location.pathname + `/${level}`;
        }
        window.location.pathname = newPath;
      }
      exports.goToLevel = goToLevel;
    }
  });

  // __tmp__/static/js/htmx-integration.js
  var require_htmx_integration = __commonJS({
    "__tmp__/static/js/htmx-integration.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var app_1 = require_app();
      var client_messages_1 = require_client_messages();
      var modal_1 = require_modal();
      var sortablejs_1 = __importDefault(require_Sortable_min());
      htmx.defineExtension("disable-element", {
        onEvent: function(name, evt) {
          var _a2;
          let elt = evt.detail.elt;
          if (!elt.getAttribute) {
            return;
          }
          let target = (_a2 = elt.getAttribute("hx-disable-element")) !== null && _a2 !== void 0 ? _a2 : "self";
          let targetElement = target == "self" ? elt : document.querySelector(target);
          if (name === "htmx:beforeRequest" && targetElement) {
            targetElement.disabled = true;
          } else if (name == "htmx:afterRequest" && targetElement) {
            targetElement.disabled = false;
          }
        }
      });
      htmx.onLoad((content) => {
        (0, app_1.initializeHighlightedCodeBlocks)(content);
        var sortables = content.querySelectorAll(".sortable");
        for (let i = 0; i < sortables.length; i++) {
          var sortable = sortables[i];
          new sortablejs_1.default(sortable, {
            animation: 150,
            ghostClass: "drop-adventures-active"
          });
        }
      });
      htmx.on("htmx:responseError", (ev) => {
        const event2 = ev;
        const xhr = event2.detail.xhr;
        const genericError = event2.detail.error;
        modal_1.modal.notifyError(xhr.responseText.length < 1e3 ? xhr.responseText : genericError);
      });
      htmx.on("htmx:sendError", () => {
        modal_1.modal.notifyError(`${client_messages_1.ClientMessages.Connection_error} ${client_messages_1.ClientMessages.CheckInternet}`);
      });
      htmx.on("displayAchievements", (ev) => {
        const payloads = ev.detail.value;
        for (const payload of payloads) {
          const achievement = payload["achievement"];
          (0, app_1.showAchievements)(achievement, payload["reload"], payload["redirect"]);
        }
      });
    }
  });

  // node_modules/chart.js/dist/chart.js
  var require_chart = __commonJS({
    "node_modules/chart.js/dist/chart.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Chart = factory());
      })(exports, function() {
        "use strict";
        function noop() {
        }
        const uid = function() {
          let id = 0;
          return function() {
            return id++;
          };
        }();
        function isNullOrUndef(value) {
          return value === null || typeof value === "undefined";
        }
        function isArray(value) {
          if (Array.isArray && Array.isArray(value)) {
            return true;
          }
          const type = Object.prototype.toString.call(value);
          if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
            return true;
          }
          return false;
        }
        function isObject(value) {
          return value !== null && Object.prototype.toString.call(value) === "[object Object]";
        }
        const isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
        function finiteOrDefault(value, defaultValue) {
          return isNumberFinite(value) ? value : defaultValue;
        }
        function valueOrDefault(value, defaultValue) {
          return typeof value === "undefined" ? defaultValue : value;
        }
        const toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
        const toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
        function callback(fn2, args, thisArg) {
          if (fn2 && typeof fn2.call === "function") {
            return fn2.apply(thisArg, args);
          }
        }
        function each(loopable, fn2, thisArg, reverse) {
          let i, len, keys;
          if (isArray(loopable)) {
            len = loopable.length;
            if (reverse) {
              for (i = len - 1; i >= 0; i--) {
                fn2.call(thisArg, loopable[i], i);
              }
            } else {
              for (i = 0; i < len; i++) {
                fn2.call(thisArg, loopable[i], i);
              }
            }
          } else if (isObject(loopable)) {
            keys = Object.keys(loopable);
            len = keys.length;
            for (i = 0; i < len; i++) {
              fn2.call(thisArg, loopable[keys[i]], keys[i]);
            }
          }
        }
        function _elementsEqual(a02, a1) {
          let i, ilen, v0, v1;
          if (!a02 || !a1 || a02.length !== a1.length) {
            return false;
          }
          for (i = 0, ilen = a02.length; i < ilen; ++i) {
            v0 = a02[i];
            v1 = a1[i];
            if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
              return false;
            }
          }
          return true;
        }
        function clone$1(source) {
          if (isArray(source)) {
            return source.map(clone$1);
          }
          if (isObject(source)) {
            const target = Object.create(null);
            const keys = Object.keys(source);
            const klen = keys.length;
            let k = 0;
            for (; k < klen; ++k) {
              target[keys[k]] = clone$1(source[keys[k]]);
            }
            return target;
          }
          return source;
        }
        function isValidKey(key) {
          return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
        }
        function _merger(key, target, source, options) {
          if (!isValidKey(key)) {
            return;
          }
          const tval = target[key];
          const sval = source[key];
          if (isObject(tval) && isObject(sval)) {
            merge(tval, sval, options);
          } else {
            target[key] = clone$1(sval);
          }
        }
        function merge(target, source, options) {
          const sources = isArray(source) ? source : [source];
          const ilen = sources.length;
          if (!isObject(target)) {
            return target;
          }
          options = options || {};
          const merger = options.merger || _merger;
          for (let i = 0; i < ilen; ++i) {
            source = sources[i];
            if (!isObject(source)) {
              continue;
            }
            const keys = Object.keys(source);
            for (let k = 0, klen = keys.length; k < klen; ++k) {
              merger(keys[k], target, source, options);
            }
          }
          return target;
        }
        function mergeIf(target, source) {
          return merge(target, source, { merger: _mergerIf });
        }
        function _mergerIf(key, target, source) {
          if (!isValidKey(key)) {
            return;
          }
          const tval = target[key];
          const sval = source[key];
          if (isObject(tval) && isObject(sval)) {
            mergeIf(tval, sval);
          } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
            target[key] = clone$1(sval);
          }
        }
        function _deprecated(scope, value, previous, current) {
          if (value !== void 0) {
            console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
          }
        }
        const keyResolvers = {
          "": (v) => v,
          x: (o) => o.x,
          y: (o) => o.y
        };
        function resolveObjectKey(obj, key) {
          const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
          return resolver(obj);
        }
        function _getKeyResolver(key) {
          const keys = _splitKey(key);
          return (obj) => {
            for (const k of keys) {
              if (k === "") {
                break;
              }
              obj = obj && obj[k];
            }
            return obj;
          };
        }
        function _splitKey(key) {
          const parts = key.split(".");
          const keys = [];
          let tmp = "";
          for (const part of parts) {
            tmp += part;
            if (tmp.endsWith("\\")) {
              tmp = tmp.slice(0, -1) + ".";
            } else {
              keys.push(tmp);
              tmp = "";
            }
          }
          return keys;
        }
        function _capitalize(str) {
          return str.charAt(0).toUpperCase() + str.slice(1);
        }
        const defined = (value) => typeof value !== "undefined";
        const isFunction = (value) => typeof value === "function";
        const setsEqual = (a, b) => {
          if (a.size !== b.size) {
            return false;
          }
          for (const item of a) {
            if (!b.has(item)) {
              return false;
            }
          }
          return true;
        };
        function _isClickEvent(e) {
          return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
        }
        const PI = Math.PI;
        const TAU = 2 * PI;
        const PITAU = TAU + PI;
        const INFINITY = Number.POSITIVE_INFINITY;
        const RAD_PER_DEG = PI / 180;
        const HALF_PI = PI / 2;
        const QUARTER_PI = PI / 4;
        const TWO_THIRDS_PI = PI * 2 / 3;
        const log10 = Math.log10;
        const sign = Math.sign;
        function niceNum(range) {
          const roundedRange = Math.round(range);
          range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
          const niceRange = Math.pow(10, Math.floor(log10(range)));
          const fraction = range / niceRange;
          const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
          return niceFraction * niceRange;
        }
        function _factorize(value) {
          const result = [];
          const sqrt = Math.sqrt(value);
          let i;
          for (i = 1; i < sqrt; i++) {
            if (value % i === 0) {
              result.push(i);
              result.push(value / i);
            }
          }
          if (sqrt === (sqrt | 0)) {
            result.push(sqrt);
          }
          result.sort((a, b) => a - b).pop();
          return result;
        }
        function isNumber(n) {
          return !isNaN(parseFloat(n)) && isFinite(n);
        }
        function almostEquals(x, y2, epsilon) {
          return Math.abs(x - y2) < epsilon;
        }
        function almostWhole(x, epsilon) {
          const rounded = Math.round(x);
          return rounded - epsilon <= x && rounded + epsilon >= x;
        }
        function _setMinAndMaxByKey(array, target, property) {
          let i, ilen, value;
          for (i = 0, ilen = array.length; i < ilen; i++) {
            value = array[i][property];
            if (!isNaN(value)) {
              target.min = Math.min(target.min, value);
              target.max = Math.max(target.max, value);
            }
          }
        }
        function toRadians(degrees) {
          return degrees * (PI / 180);
        }
        function toDegrees(radians) {
          return radians * (180 / PI);
        }
        function _decimalPlaces(x) {
          if (!isNumberFinite(x)) {
            return;
          }
          let e = 1;
          let p = 0;
          while (Math.round(x * e) / e !== x) {
            e *= 10;
            p++;
          }
          return p;
        }
        function getAngleFromPoint(centrePoint, anglePoint) {
          const distanceFromXCenter = anglePoint.x - centrePoint.x;
          const distanceFromYCenter = anglePoint.y - centrePoint.y;
          const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
          let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
          if (angle < -0.5 * PI) {
            angle += TAU;
          }
          return {
            angle,
            distance: radialDistanceFromCenter
          };
        }
        function distanceBetweenPoints(pt1, pt2) {
          return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
        }
        function _angleDiff(a, b) {
          return (a - b + PITAU) % TAU - PI;
        }
        function _normalizeAngle(a) {
          return (a % TAU + TAU) % TAU;
        }
        function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
          const a = _normalizeAngle(angle);
          const s = _normalizeAngle(start);
          const e = _normalizeAngle(end);
          const angleToStart = _normalizeAngle(s - a);
          const angleToEnd = _normalizeAngle(e - a);
          const startToAngle = _normalizeAngle(a - s);
          const endToAngle = _normalizeAngle(a - e);
          return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
        }
        function _limitValue(value, min, max) {
          return Math.max(min, Math.min(max, value));
        }
        function _int16Range(value) {
          return _limitValue(value, -32768, 32767);
        }
        function _isBetween(value, start, end, epsilon = 1e-6) {
          return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
        }
        function _lookup(table, value, cmp) {
          cmp = cmp || ((index2) => table[index2] < value);
          let hi2 = table.length - 1;
          let lo2 = 0;
          let mid;
          while (hi2 - lo2 > 1) {
            mid = lo2 + hi2 >> 1;
            if (cmp(mid)) {
              lo2 = mid;
            } else {
              hi2 = mid;
            }
          }
          return { lo: lo2, hi: hi2 };
        }
        const _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => table[index2][key] <= value : (index2) => table[index2][key] < value);
        const _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
        function _filterBetween(values, min, max) {
          let start = 0;
          let end = values.length;
          while (start < end && values[start] < min) {
            start++;
          }
          while (end > start && values[end - 1] > max) {
            end--;
          }
          return start > 0 || end < values.length ? values.slice(start, end) : values;
        }
        const arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
        function listenArrayEvents(array, listener) {
          if (array._chartjs) {
            array._chartjs.listeners.push(listener);
            return;
          }
          Object.defineProperty(array, "_chartjs", {
            configurable: true,
            enumerable: false,
            value: {
              listeners: [listener]
            }
          });
          arrayEvents.forEach((key) => {
            const method = "_onData" + _capitalize(key);
            const base = array[key];
            Object.defineProperty(array, key, {
              configurable: true,
              enumerable: false,
              value(...args) {
                const res = base.apply(this, args);
                array._chartjs.listeners.forEach((object) => {
                  if (typeof object[method] === "function") {
                    object[method](...args);
                  }
                });
                return res;
              }
            });
          });
        }
        function unlistenArrayEvents(array, listener) {
          const stub = array._chartjs;
          if (!stub) {
            return;
          }
          const listeners = stub.listeners;
          const index2 = listeners.indexOf(listener);
          if (index2 !== -1) {
            listeners.splice(index2, 1);
          }
          if (listeners.length > 0) {
            return;
          }
          arrayEvents.forEach((key) => {
            delete array[key];
          });
          delete array._chartjs;
        }
        function _arrayUnique(items) {
          const set2 = new Set();
          let i, ilen;
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            set2.add(items[i]);
          }
          if (set2.size === ilen) {
            return items;
          }
          return Array.from(set2);
        }
        function fontString(pixelSize, fontStyle, fontFamily) {
          return fontStyle + " " + pixelSize + "px " + fontFamily;
        }
        const requestAnimFrame = function() {
          if (typeof window === "undefined") {
            return function(callback2) {
              return callback2();
            };
          }
          return window.requestAnimationFrame;
        }();
        function throttled(fn2, thisArg, updateFn) {
          const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
          let ticking = false;
          let args = [];
          return function(...rest) {
            args = updateArgs(rest);
            if (!ticking) {
              ticking = true;
              requestAnimFrame.call(window, () => {
                ticking = false;
                fn2.apply(thisArg, args);
              });
            }
          };
        }
        function debounce(fn2, delay) {
          let timeout;
          return function(...args) {
            if (delay) {
              clearTimeout(timeout);
              timeout = setTimeout(fn2, delay, args);
            } else {
              fn2.apply(this, args);
            }
            return delay;
          };
        }
        const _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
        const _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
        const _textX = (align, left, right, rtl) => {
          const check = rtl ? "left" : "right";
          return align === check ? right : align === "center" ? (left + right) / 2 : left;
        };
        function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
          const pointCount = points.length;
          let start = 0;
          let count = pointCount;
          if (meta._sorted) {
            const { iScale, _parsed } = meta;
            const axis = iScale.axis;
            const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
            if (minDefined) {
              start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
            }
            if (maxDefined) {
              count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;
            } else {
              count = pointCount - start;
            }
          }
          return { start, count };
        }
        function _scaleRangesChanged(meta) {
          const { xScale, yScale, _scaleRanges } = meta;
          const newRanges = {
            xmin: xScale.min,
            xmax: xScale.max,
            ymin: yScale.min,
            ymax: yScale.max
          };
          if (!_scaleRanges) {
            meta._scaleRanges = newRanges;
            return true;
          }
          const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
          Object.assign(_scaleRanges, newRanges);
          return changed;
        }
        class Animator {
          constructor() {
            this._request = null;
            this._charts = new Map();
            this._running = false;
            this._lastDate = void 0;
          }
          _notify(chart, anims, date, type) {
            const callbacks = anims.listeners[type];
            const numSteps = anims.duration;
            callbacks.forEach((fn2) => fn2({
              chart,
              initial: anims.initial,
              numSteps,
              currentStep: Math.min(date - anims.start, numSteps)
            }));
          }
          _refresh() {
            if (this._request) {
              return;
            }
            this._running = true;
            this._request = requestAnimFrame.call(window, () => {
              this._update();
              this._request = null;
              if (this._running) {
                this._refresh();
              }
            });
          }
          _update(date = Date.now()) {
            let remaining = 0;
            this._charts.forEach((anims, chart) => {
              if (!anims.running || !anims.items.length) {
                return;
              }
              const items = anims.items;
              let i = items.length - 1;
              let draw2 = false;
              let item;
              for (; i >= 0; --i) {
                item = items[i];
                if (item._active) {
                  if (item._total > anims.duration) {
                    anims.duration = item._total;
                  }
                  item.tick(date);
                  draw2 = true;
                } else {
                  items[i] = items[items.length - 1];
                  items.pop();
                }
              }
              if (draw2) {
                chart.draw();
                this._notify(chart, anims, date, "progress");
              }
              if (!items.length) {
                anims.running = false;
                this._notify(chart, anims, date, "complete");
                anims.initial = false;
              }
              remaining += items.length;
            });
            this._lastDate = date;
            if (remaining === 0) {
              this._running = false;
            }
          }
          _getAnims(chart) {
            const charts = this._charts;
            let anims = charts.get(chart);
            if (!anims) {
              anims = {
                running: false,
                initial: true,
                items: [],
                listeners: {
                  complete: [],
                  progress: []
                }
              };
              charts.set(chart, anims);
            }
            return anims;
          }
          listen(chart, event2, cb2) {
            this._getAnims(chart).listeners[event2].push(cb2);
          }
          add(chart, items) {
            if (!items || !items.length) {
              return;
            }
            this._getAnims(chart).items.push(...items);
          }
          has(chart) {
            return this._getAnims(chart).items.length > 0;
          }
          start(chart) {
            const anims = this._charts.get(chart);
            if (!anims) {
              return;
            }
            anims.running = true;
            anims.start = Date.now();
            anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
            this._refresh();
          }
          running(chart) {
            if (!this._running) {
              return false;
            }
            const anims = this._charts.get(chart);
            if (!anims || !anims.running || !anims.items.length) {
              return false;
            }
            return true;
          }
          stop(chart) {
            const anims = this._charts.get(chart);
            if (!anims || !anims.items.length) {
              return;
            }
            const items = anims.items;
            let i = items.length - 1;
            for (; i >= 0; --i) {
              items[i].cancel();
            }
            anims.items = [];
            this._notify(chart, anims, Date.now(), "complete");
          }
          remove(chart) {
            return this._charts.delete(chart);
          }
        }
        var animator = new Animator();
        function round(v) {
          return v + 0.5 | 0;
        }
        const lim = (v, l, h3) => Math.max(Math.min(v, h3), l);
        function p2b(v) {
          return lim(round(v * 2.55), 0, 255);
        }
        function n2b(v) {
          return lim(round(v * 255), 0, 255);
        }
        function b2n(v) {
          return lim(round(v / 2.55) / 100, 0, 1);
        }
        function n2p(v) {
          return lim(round(v * 100), 0, 100);
        }
        const map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
        const hex = [..."0123456789ABCDEF"];
        const h1 = (b) => hex[b & 15];
        const h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
        const eq = (b) => (b & 240) >> 4 === (b & 15);
        const isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
        function hexParse(str) {
          var len = str.length;
          var ret;
          if (str[0] === "#") {
            if (len === 4 || len === 5) {
              ret = {
                r: 255 & map$1[str[1]] * 17,
                g: 255 & map$1[str[2]] * 17,
                b: 255 & map$1[str[3]] * 17,
                a: len === 5 ? map$1[str[4]] * 17 : 255
              };
            } else if (len === 7 || len === 9) {
              ret = {
                r: map$1[str[1]] << 4 | map$1[str[2]],
                g: map$1[str[3]] << 4 | map$1[str[4]],
                b: map$1[str[5]] << 4 | map$1[str[6]],
                a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
              };
            }
          }
          return ret;
        }
        const alpha = (a, f) => a < 255 ? f(a) : "";
        function hexString(v) {
          var f = isShort(v) ? h1 : h2;
          return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
        }
        const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
        function hsl2rgbn(h3, s, l) {
          const a = s * Math.min(l, 1 - l);
          const f = (n, k = (n + h3 / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return [f(0), f(8), f(4)];
        }
        function hsv2rgbn(h3, s, v) {
          const f = (n, k = (n + h3 / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
          return [f(5), f(3), f(1)];
        }
        function hwb2rgbn(h3, w, b) {
          const rgb = hsl2rgbn(h3, 1, 0.5);
          let i;
          if (w + b > 1) {
            i = 1 / (w + b);
            w *= i;
            b *= i;
          }
          for (i = 0; i < 3; i++) {
            rgb[i] *= 1 - w - b;
            rgb[i] += w;
          }
          return rgb;
        }
        function hueValue(r, g, b, d2, max) {
          if (r === max) {
            return (g - b) / d2 + (g < b ? 6 : 0);
          }
          if (g === max) {
            return (b - r) / d2 + 2;
          }
          return (r - g) / d2 + 4;
        }
        function rgb2hsl(v) {
          const range = 255;
          const r = v.r / range;
          const g = v.g / range;
          const b = v.b / range;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const l = (max + min) / 2;
          let h3, s, d2;
          if (max !== min) {
            d2 = max - min;
            s = l > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
            h3 = hueValue(r, g, b, d2, max);
            h3 = h3 * 60 + 0.5;
          }
          return [h3 | 0, s || 0, l];
        }
        function calln(f, a, b, c2) {
          return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c2)).map(n2b);
        }
        function hsl2rgb(h3, s, l) {
          return calln(hsl2rgbn, h3, s, l);
        }
        function hwb2rgb(h3, w, b) {
          return calln(hwb2rgbn, h3, w, b);
        }
        function hsv2rgb(h3, s, v) {
          return calln(hsv2rgbn, h3, s, v);
        }
        function hue(h3) {
          return (h3 % 360 + 360) % 360;
        }
        function hueParse(str) {
          const m = HUE_RE.exec(str);
          let a = 255;
          let v;
          if (!m) {
            return;
          }
          if (m[5] !== v) {
            a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
          }
          const h3 = hue(+m[2]);
          const p1 = +m[3] / 100;
          const p2 = +m[4] / 100;
          if (m[1] === "hwb") {
            v = hwb2rgb(h3, p1, p2);
          } else if (m[1] === "hsv") {
            v = hsv2rgb(h3, p1, p2);
          } else {
            v = hsl2rgb(h3, p1, p2);
          }
          return {
            r: v[0],
            g: v[1],
            b: v[2],
            a
          };
        }
        function rotate(v, deg) {
          var h3 = rgb2hsl(v);
          h3[0] = hue(h3[0] + deg);
          h3 = hsl2rgb(h3);
          v.r = h3[0];
          v.g = h3[1];
          v.b = h3[2];
        }
        function hslString(v) {
          if (!v) {
            return;
          }
          const a = rgb2hsl(v);
          const h3 = a[0];
          const s = n2p(a[1]);
          const l = n2p(a[2]);
          return v.a < 255 ? `hsla(${h3}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h3}, ${s}%, ${l}%)`;
        }
        const map$2 = {
          x: "dark",
          Z: "light",
          Y: "re",
          X: "blu",
          W: "gr",
          V: "medium",
          U: "slate",
          A: "ee",
          T: "ol",
          S: "or",
          B: "ra",
          C: "lateg",
          D: "ights",
          R: "in",
          Q: "turquois",
          E: "hi",
          P: "ro",
          O: "al",
          N: "le",
          M: "de",
          L: "yello",
          F: "en",
          K: "ch",
          G: "arks",
          H: "ea",
          I: "ightg",
          J: "wh"
        };
        const names$1 = {
          OiceXe: "f0f8ff",
          antiquewEte: "faebd7",
          aqua: "ffff",
          aquamarRe: "7fffd4",
          azuY: "f0ffff",
          beige: "f5f5dc",
          bisque: "ffe4c4",
          black: "0",
          blanKedOmond: "ffebcd",
          Xe: "ff",
          XeviTet: "8a2be2",
          bPwn: "a52a2a",
          burlywood: "deb887",
          caMtXe: "5f9ea0",
          KartYuse: "7fff00",
          KocTate: "d2691e",
          cSO: "ff7f50",
          cSnflowerXe: "6495ed",
          cSnsilk: "fff8dc",
          crimson: "dc143c",
          cyan: "ffff",
          xXe: "8b",
          xcyan: "8b8b",
          xgTMnPd: "b8860b",
          xWay: "a9a9a9",
          xgYF: "6400",
          xgYy: "a9a9a9",
          xkhaki: "bdb76b",
          xmagFta: "8b008b",
          xTivegYF: "556b2f",
          xSange: "ff8c00",
          xScEd: "9932cc",
          xYd: "8b0000",
          xsOmon: "e9967a",
          xsHgYF: "8fbc8f",
          xUXe: "483d8b",
          xUWay: "2f4f4f",
          xUgYy: "2f4f4f",
          xQe: "ced1",
          xviTet: "9400d3",
          dAppRk: "ff1493",
          dApskyXe: "bfff",
          dimWay: "696969",
          dimgYy: "696969",
          dodgerXe: "1e90ff",
          fiYbrick: "b22222",
          flSOwEte: "fffaf0",
          foYstWAn: "228b22",
          fuKsia: "ff00ff",
          gaRsbSo: "dcdcdc",
          ghostwEte: "f8f8ff",
          gTd: "ffd700",
          gTMnPd: "daa520",
          Way: "808080",
          gYF: "8000",
          gYFLw: "adff2f",
          gYy: "808080",
          honeyMw: "f0fff0",
          hotpRk: "ff69b4",
          RdianYd: "cd5c5c",
          Rdigo: "4b0082",
          ivSy: "fffff0",
          khaki: "f0e68c",
          lavFMr: "e6e6fa",
          lavFMrXsh: "fff0f5",
          lawngYF: "7cfc00",
          NmoncEffon: "fffacd",
          ZXe: "add8e6",
          ZcSO: "f08080",
          Zcyan: "e0ffff",
          ZgTMnPdLw: "fafad2",
          ZWay: "d3d3d3",
          ZgYF: "90ee90",
          ZgYy: "d3d3d3",
          ZpRk: "ffb6c1",
          ZsOmon: "ffa07a",
          ZsHgYF: "20b2aa",
          ZskyXe: "87cefa",
          ZUWay: "778899",
          ZUgYy: "778899",
          ZstAlXe: "b0c4de",
          ZLw: "ffffe0",
          lime: "ff00",
          limegYF: "32cd32",
          lRF: "faf0e6",
          magFta: "ff00ff",
          maPon: "800000",
          VaquamarRe: "66cdaa",
          VXe: "cd",
          VScEd: "ba55d3",
          VpurpN: "9370db",
          VsHgYF: "3cb371",
          VUXe: "7b68ee",
          VsprRggYF: "fa9a",
          VQe: "48d1cc",
          VviTetYd: "c71585",
          midnightXe: "191970",
          mRtcYam: "f5fffa",
          mistyPse: "ffe4e1",
          moccasR: "ffe4b5",
          navajowEte: "ffdead",
          navy: "80",
          Tdlace: "fdf5e6",
          Tive: "808000",
          TivedBb: "6b8e23",
          Sange: "ffa500",
          SangeYd: "ff4500",
          ScEd: "da70d6",
          pOegTMnPd: "eee8aa",
          pOegYF: "98fb98",
          pOeQe: "afeeee",
          pOeviTetYd: "db7093",
          papayawEp: "ffefd5",
          pHKpuff: "ffdab9",
          peru: "cd853f",
          pRk: "ffc0cb",
          plum: "dda0dd",
          powMrXe: "b0e0e6",
          purpN: "800080",
          YbeccapurpN: "663399",
          Yd: "ff0000",
          Psybrown: "bc8f8f",
          PyOXe: "4169e1",
          saddNbPwn: "8b4513",
          sOmon: "fa8072",
          sandybPwn: "f4a460",
          sHgYF: "2e8b57",
          sHshell: "fff5ee",
          siFna: "a0522d",
          silver: "c0c0c0",
          skyXe: "87ceeb",
          UXe: "6a5acd",
          UWay: "708090",
          UgYy: "708090",
          snow: "fffafa",
          sprRggYF: "ff7f",
          stAlXe: "4682b4",
          tan: "d2b48c",
          teO: "8080",
          tEstN: "d8bfd8",
          tomato: "ff6347",
          Qe: "40e0d0",
          viTet: "ee82ee",
          JHt: "f5deb3",
          wEte: "ffffff",
          wEtesmoke: "f5f5f5",
          Lw: "ffff00",
          LwgYF: "9acd32"
        };
        function unpack() {
          const unpacked = {};
          const keys = Object.keys(names$1);
          const tkeys = Object.keys(map$2);
          let i, j2, k, ok, nk;
          for (i = 0; i < keys.length; i++) {
            ok = nk = keys[i];
            for (j2 = 0; j2 < tkeys.length; j2++) {
              k = tkeys[j2];
              nk = nk.replace(k, map$2[k]);
            }
            k = parseInt(names$1[ok], 16);
            unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
          }
          return unpacked;
        }
        let names;
        function nameParse(str) {
          if (!names) {
            names = unpack();
            names.transparent = [0, 0, 0, 0];
          }
          const a = names[str.toLowerCase()];
          return a && {
            r: a[0],
            g: a[1],
            b: a[2],
            a: a.length === 4 ? a[3] : 255
          };
        }
        const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
        function rgbParse(str) {
          const m = RGB_RE.exec(str);
          let a = 255;
          let r, g, b;
          if (!m) {
            return;
          }
          if (m[7] !== r) {
            const v = +m[7];
            a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
          }
          r = +m[1];
          g = +m[3];
          b = +m[5];
          r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
          g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
          b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
          return {
            r,
            g,
            b,
            a
          };
        }
        function rgbString(v) {
          return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
        }
        const to2 = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
        const from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
        function interpolate$1(rgb1, rgb2, t) {
          const r = from(b2n(rgb1.r));
          const g = from(b2n(rgb1.g));
          const b = from(b2n(rgb1.b));
          return {
            r: n2b(to2(r + t * (from(b2n(rgb2.r)) - r))),
            g: n2b(to2(g + t * (from(b2n(rgb2.g)) - g))),
            b: n2b(to2(b + t * (from(b2n(rgb2.b)) - b))),
            a: rgb1.a + t * (rgb2.a - rgb1.a)
          };
        }
        function modHSL(v, i, ratio) {
          if (v) {
            let tmp = rgb2hsl(v);
            tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
            tmp = hsl2rgb(tmp);
            v.r = tmp[0];
            v.g = tmp[1];
            v.b = tmp[2];
          }
        }
        function clone(v, proto) {
          return v ? Object.assign(proto || {}, v) : v;
        }
        function fromObject(input) {
          var v = { r: 0, g: 0, b: 0, a: 255 };
          if (Array.isArray(input)) {
            if (input.length >= 3) {
              v = { r: input[0], g: input[1], b: input[2], a: 255 };
              if (input.length > 3) {
                v.a = n2b(input[3]);
              }
            }
          } else {
            v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
            v.a = n2b(v.a);
          }
          return v;
        }
        function functionParse(str) {
          if (str.charAt(0) === "r") {
            return rgbParse(str);
          }
          return hueParse(str);
        }
        class Color {
          constructor(input) {
            if (input instanceof Color) {
              return input;
            }
            const type = typeof input;
            let v;
            if (type === "object") {
              v = fromObject(input);
            } else if (type === "string") {
              v = hexParse(input) || nameParse(input) || functionParse(input);
            }
            this._rgb = v;
            this._valid = !!v;
          }
          get valid() {
            return this._valid;
          }
          get rgb() {
            var v = clone(this._rgb);
            if (v) {
              v.a = b2n(v.a);
            }
            return v;
          }
          set rgb(obj) {
            this._rgb = fromObject(obj);
          }
          rgbString() {
            return this._valid ? rgbString(this._rgb) : void 0;
          }
          hexString() {
            return this._valid ? hexString(this._rgb) : void 0;
          }
          hslString() {
            return this._valid ? hslString(this._rgb) : void 0;
          }
          mix(color2, weight) {
            if (color2) {
              const c1 = this.rgb;
              const c2 = color2.rgb;
              let w2;
              const p = weight === w2 ? 0.5 : weight;
              const w = 2 * p - 1;
              const a = c1.a - c2.a;
              const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
              w2 = 1 - w1;
              c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
              c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
              c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
              c1.a = p * c1.a + (1 - p) * c2.a;
              this.rgb = c1;
            }
            return this;
          }
          interpolate(color2, t) {
            if (color2) {
              this._rgb = interpolate$1(this._rgb, color2._rgb, t);
            }
            return this;
          }
          clone() {
            return new Color(this.rgb);
          }
          alpha(a) {
            this._rgb.a = n2b(a);
            return this;
          }
          clearer(ratio) {
            const rgb = this._rgb;
            rgb.a *= 1 - ratio;
            return this;
          }
          greyscale() {
            const rgb = this._rgb;
            const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
            rgb.r = rgb.g = rgb.b = val;
            return this;
          }
          opaquer(ratio) {
            const rgb = this._rgb;
            rgb.a *= 1 + ratio;
            return this;
          }
          negate() {
            const v = this._rgb;
            v.r = 255 - v.r;
            v.g = 255 - v.g;
            v.b = 255 - v.b;
            return this;
          }
          lighten(ratio) {
            modHSL(this._rgb, 2, ratio);
            return this;
          }
          darken(ratio) {
            modHSL(this._rgb, 2, -ratio);
            return this;
          }
          saturate(ratio) {
            modHSL(this._rgb, 1, ratio);
            return this;
          }
          desaturate(ratio) {
            modHSL(this._rgb, 1, -ratio);
            return this;
          }
          rotate(deg) {
            rotate(this._rgb, deg);
            return this;
          }
        }
        function index_esm(input) {
          return new Color(input);
        }
        function isPatternOrGradient(value) {
          if (value && typeof value === "object") {
            const type = value.toString();
            return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
          }
          return false;
        }
        function color(value) {
          return isPatternOrGradient(value) ? value : index_esm(value);
        }
        function getHoverColor(value) {
          return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
        }
        const overrides = Object.create(null);
        const descriptors = Object.create(null);
        function getScope$1(node, key) {
          if (!key) {
            return node;
          }
          const keys = key.split(".");
          for (let i = 0, n = keys.length; i < n; ++i) {
            const k = keys[i];
            node = node[k] || (node[k] = Object.create(null));
          }
          return node;
        }
        function set(root, scope, values) {
          if (typeof scope === "string") {
            return merge(getScope$1(root, scope), values);
          }
          return merge(getScope$1(root, ""), scope);
        }
        class Defaults {
          constructor(_descriptors2) {
            this.animation = void 0;
            this.backgroundColor = "rgba(0,0,0,0.1)";
            this.borderColor = "rgba(0,0,0,0.1)";
            this.color = "#666";
            this.datasets = {};
            this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
            this.elements = {};
            this.events = [
              "mousemove",
              "mouseout",
              "click",
              "touchstart",
              "touchmove"
            ];
            this.font = {
              family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
              size: 12,
              style: "normal",
              lineHeight: 1.2,
              weight: null
            };
            this.hover = {};
            this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
            this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
            this.hoverColor = (ctx, options) => getHoverColor(options.color);
            this.indexAxis = "x";
            this.interaction = {
              mode: "nearest",
              intersect: true,
              includeInvisible: false
            };
            this.maintainAspectRatio = true;
            this.onHover = null;
            this.onClick = null;
            this.parsing = true;
            this.plugins = {};
            this.responsive = true;
            this.scale = void 0;
            this.scales = {};
            this.showLine = true;
            this.drawActiveElementsOnTop = true;
            this.describe(_descriptors2);
          }
          set(scope, values) {
            return set(this, scope, values);
          }
          get(scope) {
            return getScope$1(this, scope);
          }
          describe(scope, values) {
            return set(descriptors, scope, values);
          }
          override(scope, values) {
            return set(overrides, scope, values);
          }
          route(scope, name, targetScope, targetName) {
            const scopeObject = getScope$1(this, scope);
            const targetScopeObject = getScope$1(this, targetScope);
            const privateName = "_" + name;
            Object.defineProperties(scopeObject, {
              [privateName]: {
                value: scopeObject[name],
                writable: true
              },
              [name]: {
                enumerable: true,
                get() {
                  const local = this[privateName];
                  const target = targetScopeObject[targetName];
                  if (isObject(local)) {
                    return Object.assign({}, target, local);
                  }
                  return valueOrDefault(local, target);
                },
                set(value) {
                  this[privateName] = value;
                }
              }
            });
          }
        }
        var defaults = new Defaults({
          _scriptable: (name) => !name.startsWith("on"),
          _indexable: (name) => name !== "events",
          hover: {
            _fallback: "interaction"
          },
          interaction: {
            _scriptable: false,
            _indexable: false
          }
        });
        function _isDomSupported() {
          return typeof window !== "undefined" && typeof document !== "undefined";
        }
        function _getParentNode(domNode) {
          let parent = domNode.parentNode;
          if (parent && parent.toString() === "[object ShadowRoot]") {
            parent = parent.host;
          }
          return parent;
        }
        function parseMaxStyle(styleValue, node, parentProperty) {
          let valueInPixels;
          if (typeof styleValue === "string") {
            valueInPixels = parseInt(styleValue, 10);
            if (styleValue.indexOf("%") !== -1) {
              valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
            }
          } else {
            valueInPixels = styleValue;
          }
          return valueInPixels;
        }
        const getComputedStyle2 = (element) => window.getComputedStyle(element, null);
        function getStyle(el2, property) {
          return getComputedStyle2(el2).getPropertyValue(property);
        }
        const positions = ["top", "right", "bottom", "left"];
        function getPositionedStyle(styles, style, suffix) {
          const result = {};
          suffix = suffix ? "-" + suffix : "";
          for (let i = 0; i < 4; i++) {
            const pos = positions[i];
            result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
          }
          result.width = result.left + result.right;
          result.height = result.top + result.bottom;
          return result;
        }
        const useOffsetPos = (x, y2, target) => (x > 0 || y2 > 0) && (!target || !target.shadowRoot);
        function getCanvasPosition(e, canvas) {
          const touches = e.touches;
          const source = touches && touches.length ? touches[0] : e;
          const { offsetX, offsetY } = source;
          let box = false;
          let x, y2;
          if (useOffsetPos(offsetX, offsetY, e.target)) {
            x = offsetX;
            y2 = offsetY;
          } else {
            const rect = canvas.getBoundingClientRect();
            x = source.clientX - rect.left;
            y2 = source.clientY - rect.top;
            box = true;
          }
          return { x, y: y2, box };
        }
        function getRelativePosition(evt, chart) {
          if ("native" in evt) {
            return evt;
          }
          const { canvas, currentDevicePixelRatio } = chart;
          const style = getComputedStyle2(canvas);
          const borderBox = style.boxSizing === "border-box";
          const paddings = getPositionedStyle(style, "padding");
          const borders = getPositionedStyle(style, "border", "width");
          const { x, y: y2, box } = getCanvasPosition(evt, canvas);
          const xOffset = paddings.left + (box && borders.left);
          const yOffset = paddings.top + (box && borders.top);
          let { width, height } = chart;
          if (borderBox) {
            width -= paddings.width + borders.width;
            height -= paddings.height + borders.height;
          }
          return {
            x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
            y: Math.round((y2 - yOffset) / height * canvas.height / currentDevicePixelRatio)
          };
        }
        function getContainerSize(canvas, width, height) {
          let maxWidth, maxHeight;
          if (width === void 0 || height === void 0) {
            const container = _getParentNode(canvas);
            if (!container) {
              width = canvas.clientWidth;
              height = canvas.clientHeight;
            } else {
              const rect = container.getBoundingClientRect();
              const containerStyle = getComputedStyle2(container);
              const containerBorder = getPositionedStyle(containerStyle, "border", "width");
              const containerPadding = getPositionedStyle(containerStyle, "padding");
              width = rect.width - containerPadding.width - containerBorder.width;
              height = rect.height - containerPadding.height - containerBorder.height;
              maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
              maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
            }
          }
          return {
            width,
            height,
            maxWidth: maxWidth || INFINITY,
            maxHeight: maxHeight || INFINITY
          };
        }
        const round1 = (v) => Math.round(v * 10) / 10;
        function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
          const style = getComputedStyle2(canvas);
          const margins = getPositionedStyle(style, "margin");
          const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
          const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
          const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
          let { width, height } = containerSize;
          if (style.boxSizing === "content-box") {
            const borders = getPositionedStyle(style, "border", "width");
            const paddings = getPositionedStyle(style, "padding");
            width -= paddings.width + borders.width;
            height -= paddings.height + borders.height;
          }
          width = Math.max(0, width - margins.width);
          height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
          width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
          height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
          if (width && !height) {
            height = round1(width / 2);
          }
          return {
            width,
            height
          };
        }
        function retinaScale(chart, forceRatio, forceStyle) {
          const pixelRatio = forceRatio || 1;
          const deviceHeight = Math.floor(chart.height * pixelRatio);
          const deviceWidth = Math.floor(chart.width * pixelRatio);
          chart.height = deviceHeight / pixelRatio;
          chart.width = deviceWidth / pixelRatio;
          const canvas = chart.canvas;
          if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
            canvas.style.height = `${chart.height}px`;
            canvas.style.width = `${chart.width}px`;
          }
          if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
            chart.currentDevicePixelRatio = pixelRatio;
            canvas.height = deviceHeight;
            canvas.width = deviceWidth;
            chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            return true;
          }
          return false;
        }
        const supportsEventListenerOptions = function() {
          let passiveSupported = false;
          try {
            const options = {
              get passive() {
                passiveSupported = true;
                return false;
              }
            };
            window.addEventListener("test", null, options);
            window.removeEventListener("test", null, options);
          } catch (e) {
          }
          return passiveSupported;
        }();
        function readUsedSize(element, property) {
          const value = getStyle(element, property);
          const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
          return matches ? +matches[1] : void 0;
        }
        function toFontString(font) {
          if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
            return null;
          }
          return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
        }
        function _measureText(ctx, data, gc2, longest, string) {
          let textWidth = data[string];
          if (!textWidth) {
            textWidth = data[string] = ctx.measureText(string).width;
            gc2.push(string);
          }
          if (textWidth > longest) {
            longest = textWidth;
          }
          return longest;
        }
        function _longestText(ctx, font, arrayOfThings, cache) {
          cache = cache || {};
          let data = cache.data = cache.data || {};
          let gc2 = cache.garbageCollect = cache.garbageCollect || [];
          if (cache.font !== font) {
            data = cache.data = {};
            gc2 = cache.garbageCollect = [];
            cache.font = font;
          }
          ctx.save();
          ctx.font = font;
          let longest = 0;
          const ilen = arrayOfThings.length;
          let i, j2, jlen, thing, nestedThing;
          for (i = 0; i < ilen; i++) {
            thing = arrayOfThings[i];
            if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
              longest = _measureText(ctx, data, gc2, longest, thing);
            } else if (isArray(thing)) {
              for (j2 = 0, jlen = thing.length; j2 < jlen; j2++) {
                nestedThing = thing[j2];
                if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
                  longest = _measureText(ctx, data, gc2, longest, nestedThing);
                }
              }
            }
          }
          ctx.restore();
          const gcLen = gc2.length / 2;
          if (gcLen > arrayOfThings.length) {
            for (i = 0; i < gcLen; i++) {
              delete data[gc2[i]];
            }
            gc2.splice(0, gcLen);
          }
          return longest;
        }
        function _alignPixel(chart, pixel, width) {
          const devicePixelRatio = chart.currentDevicePixelRatio;
          const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
          return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
        }
        function clearCanvas(canvas, ctx) {
          ctx = ctx || canvas.getContext("2d");
          ctx.save();
          ctx.resetTransform();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
        }
        function drawPoint(ctx, options, x, y2) {
          drawPointLegend(ctx, options, x, y2, null);
        }
        function drawPointLegend(ctx, options, x, y2, w) {
          let type, xOffset, yOffset, size, cornerRadius, width;
          const style = options.pointStyle;
          const rotation = options.rotation;
          const radius = options.radius;
          let rad = (rotation || 0) * RAD_PER_DEG;
          if (style && typeof style === "object") {
            type = style.toString();
            if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
              ctx.save();
              ctx.translate(x, y2);
              ctx.rotate(rad);
              ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
              ctx.restore();
              return;
            }
          }
          if (isNaN(radius) || radius <= 0) {
            return;
          }
          ctx.beginPath();
          switch (style) {
            default:
              if (w) {
                ctx.ellipse(x, y2, w / 2, radius, 0, 0, TAU);
              } else {
                ctx.arc(x, y2, radius, 0, TAU);
              }
              ctx.closePath();
              break;
            case "triangle":
              ctx.moveTo(x + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
              rad += TWO_THIRDS_PI;
              ctx.lineTo(x + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
              rad += TWO_THIRDS_PI;
              ctx.lineTo(x + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
              ctx.closePath();
              break;
            case "rectRounded":
              cornerRadius = radius * 0.516;
              size = radius - cornerRadius;
              xOffset = Math.cos(rad + QUARTER_PI) * size;
              yOffset = Math.sin(rad + QUARTER_PI) * size;
              ctx.arc(x - xOffset, y2 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
              ctx.arc(x + yOffset, y2 - xOffset, cornerRadius, rad - HALF_PI, rad);
              ctx.arc(x + xOffset, y2 + yOffset, cornerRadius, rad, rad + HALF_PI);
              ctx.arc(x - yOffset, y2 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
              ctx.closePath();
              break;
            case "rect":
              if (!rotation) {
                size = Math.SQRT1_2 * radius;
                width = w ? w / 2 : size;
                ctx.rect(x - width, y2 - size, 2 * width, 2 * size);
                break;
              }
              rad += QUARTER_PI;
            case "rectRot":
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y2 - yOffset);
              ctx.lineTo(x + yOffset, y2 - xOffset);
              ctx.lineTo(x + xOffset, y2 + yOffset);
              ctx.lineTo(x - yOffset, y2 + xOffset);
              ctx.closePath();
              break;
            case "crossRot":
              rad += QUARTER_PI;
            case "cross":
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y2 - yOffset);
              ctx.lineTo(x + xOffset, y2 + yOffset);
              ctx.moveTo(x + yOffset, y2 - xOffset);
              ctx.lineTo(x - yOffset, y2 + xOffset);
              break;
            case "star":
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y2 - yOffset);
              ctx.lineTo(x + xOffset, y2 + yOffset);
              ctx.moveTo(x + yOffset, y2 - xOffset);
              ctx.lineTo(x - yOffset, y2 + xOffset);
              rad += QUARTER_PI;
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y2 - yOffset);
              ctx.lineTo(x + xOffset, y2 + yOffset);
              ctx.moveTo(x + yOffset, y2 - xOffset);
              ctx.lineTo(x - yOffset, y2 + xOffset);
              break;
            case "line":
              xOffset = w ? w / 2 : Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y2 - yOffset);
              ctx.lineTo(x + xOffset, y2 + yOffset);
              break;
            case "dash":
              ctx.moveTo(x, y2);
              ctx.lineTo(x + Math.cos(rad) * radius, y2 + Math.sin(rad) * radius);
              break;
          }
          ctx.fill();
          if (options.borderWidth > 0) {
            ctx.stroke();
          }
        }
        function _isPointInArea(point, area, margin) {
          margin = margin || 0.5;
          return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
        }
        function clipArea(ctx, area) {
          ctx.save();
          ctx.beginPath();
          ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
          ctx.clip();
        }
        function unclipArea(ctx) {
          ctx.restore();
        }
        function _steppedLineTo(ctx, previous, target, flip, mode) {
          if (!previous) {
            return ctx.lineTo(target.x, target.y);
          }
          if (mode === "middle") {
            const midpoint = (previous.x + target.x) / 2;
            ctx.lineTo(midpoint, previous.y);
            ctx.lineTo(midpoint, target.y);
          } else if (mode === "after" !== !!flip) {
            ctx.lineTo(previous.x, target.y);
          } else {
            ctx.lineTo(target.x, previous.y);
          }
          ctx.lineTo(target.x, target.y);
        }
        function _bezierCurveTo(ctx, previous, target, flip) {
          if (!previous) {
            return ctx.lineTo(target.x, target.y);
          }
          ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
        }
        function renderText(ctx, text, x, y2, font, opts = {}) {
          const lines = isArray(text) ? text : [text];
          const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
          let i, line;
          ctx.save();
          ctx.font = font.string;
          setRenderOpts(ctx, opts);
          for (i = 0; i < lines.length; ++i) {
            line = lines[i];
            if (stroke) {
              if (opts.strokeColor) {
                ctx.strokeStyle = opts.strokeColor;
              }
              if (!isNullOrUndef(opts.strokeWidth)) {
                ctx.lineWidth = opts.strokeWidth;
              }
              ctx.strokeText(line, x, y2, opts.maxWidth);
            }
            ctx.fillText(line, x, y2, opts.maxWidth);
            decorateText(ctx, x, y2, line, opts);
            y2 += font.lineHeight;
          }
          ctx.restore();
        }
        function setRenderOpts(ctx, opts) {
          if (opts.translation) {
            ctx.translate(opts.translation[0], opts.translation[1]);
          }
          if (!isNullOrUndef(opts.rotation)) {
            ctx.rotate(opts.rotation);
          }
          if (opts.color) {
            ctx.fillStyle = opts.color;
          }
          if (opts.textAlign) {
            ctx.textAlign = opts.textAlign;
          }
          if (opts.textBaseline) {
            ctx.textBaseline = opts.textBaseline;
          }
        }
        function decorateText(ctx, x, y2, line, opts) {
          if (opts.strikethrough || opts.underline) {
            const metrics = ctx.measureText(line);
            const left = x - metrics.actualBoundingBoxLeft;
            const right = x + metrics.actualBoundingBoxRight;
            const top = y2 - metrics.actualBoundingBoxAscent;
            const bottom = y2 + metrics.actualBoundingBoxDescent;
            const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
            ctx.strokeStyle = ctx.fillStyle;
            ctx.beginPath();
            ctx.lineWidth = opts.decorationWidth || 2;
            ctx.moveTo(left, yDecoration);
            ctx.lineTo(right, yDecoration);
            ctx.stroke();
          }
        }
        function addRoundedRectPath(ctx, rect) {
          const { x, y: y2, w, h: h3, radius } = rect;
          ctx.arc(x + radius.topLeft, y2 + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
          ctx.lineTo(x, y2 + h3 - radius.bottomLeft);
          ctx.arc(x + radius.bottomLeft, y2 + h3 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
          ctx.lineTo(x + w - radius.bottomRight, y2 + h3);
          ctx.arc(x + w - radius.bottomRight, y2 + h3 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
          ctx.lineTo(x + w, y2 + radius.topRight);
          ctx.arc(x + w - radius.topRight, y2 + radius.topRight, radius.topRight, 0, -HALF_PI, true);
          ctx.lineTo(x + radius.topLeft, y2);
        }
        function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
          if (!defined(fallback)) {
            fallback = _resolve("_fallback", scopes);
          }
          const cache = {
            [Symbol.toStringTag]: "Object",
            _cacheable: true,
            _scopes: scopes,
            _rootScopes: rootScopes,
            _fallback: fallback,
            _getTarget: getTarget,
            override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
          };
          return new Proxy(cache, {
            deleteProperty(target, prop) {
              delete target[prop];
              delete target._keys;
              delete scopes[0][prop];
              return true;
            },
            get(target, prop) {
              return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
            },
            getOwnPropertyDescriptor(target, prop) {
              return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
            },
            getPrototypeOf() {
              return Reflect.getPrototypeOf(scopes[0]);
            },
            has(target, prop) {
              return getKeysFromAllScopes(target).includes(prop);
            },
            ownKeys(target) {
              return getKeysFromAllScopes(target);
            },
            set(target, prop, value) {
              const storage = target._storage || (target._storage = getTarget());
              target[prop] = storage[prop] = value;
              delete target._keys;
              return true;
            }
          });
        }
        function _attachContext(proxy, context, subProxy, descriptorDefaults) {
          const cache = {
            _cacheable: false,
            _proxy: proxy,
            _context: context,
            _subProxy: subProxy,
            _stack: new Set(),
            _descriptors: _descriptors(proxy, descriptorDefaults),
            setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
            override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
          };
          return new Proxy(cache, {
            deleteProperty(target, prop) {
              delete target[prop];
              delete proxy[prop];
              return true;
            },
            get(target, prop, receiver) {
              return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
            },
            getOwnPropertyDescriptor(target, prop) {
              return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
            },
            getPrototypeOf() {
              return Reflect.getPrototypeOf(proxy);
            },
            has(target, prop) {
              return Reflect.has(proxy, prop);
            },
            ownKeys() {
              return Reflect.ownKeys(proxy);
            },
            set(target, prop, value) {
              proxy[prop] = value;
              delete target[prop];
              return true;
            }
          });
        }
        function _descriptors(proxy, defaults2 = { scriptable: true, indexable: true }) {
          const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
          return {
            allKeys: _allKeys,
            scriptable: _scriptable,
            indexable: _indexable,
            isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
            isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
          };
        }
        const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
        const needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
        function _cached(target, prop, resolve2) {
          if (Object.prototype.hasOwnProperty.call(target, prop)) {
            return target[prop];
          }
          const value = resolve2();
          target[prop] = value;
          return value;
        }
        function _resolveWithContext(target, prop, receiver) {
          const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
          let value = _proxy[prop];
          if (isFunction(value) && descriptors2.isScriptable(prop)) {
            value = _resolveScriptable(prop, value, target, receiver);
          }
          if (isArray(value) && value.length) {
            value = _resolveArray(prop, value, target, descriptors2.isIndexable);
          }
          if (needsSubResolver(prop, value)) {
            value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
          }
          return value;
        }
        function _resolveScriptable(prop, value, target, receiver) {
          const { _proxy, _context, _subProxy, _stack } = target;
          if (_stack.has(prop)) {
            throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
          }
          _stack.add(prop);
          value = value(_context, _subProxy || receiver);
          _stack.delete(prop);
          if (needsSubResolver(prop, value)) {
            value = createSubResolver(_proxy._scopes, _proxy, prop, value);
          }
          return value;
        }
        function _resolveArray(prop, value, target, isIndexable) {
          const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
          if (defined(_context.index) && isIndexable(prop)) {
            value = value[_context.index % value.length];
          } else if (isObject(value[0])) {
            const arr = value;
            const scopes = _proxy._scopes.filter((s) => s !== arr);
            value = [];
            for (const item of arr) {
              const resolver = createSubResolver(scopes, _proxy, prop, item);
              value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
            }
          }
          return value;
        }
        function resolveFallback(fallback, prop, value) {
          return isFunction(fallback) ? fallback(prop, value) : fallback;
        }
        const getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
        function addScopes(set2, parentScopes, key, parentFallback, value) {
          for (const parent of parentScopes) {
            const scope = getScope(key, parent);
            if (scope) {
              set2.add(scope);
              const fallback = resolveFallback(scope._fallback, key, value);
              if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
                return fallback;
              }
            } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
              return null;
            }
          }
          return false;
        }
        function createSubResolver(parentScopes, resolver, prop, value) {
          const rootScopes = resolver._rootScopes;
          const fallback = resolveFallback(resolver._fallback, prop, value);
          const allScopes = [...parentScopes, ...rootScopes];
          const set2 = new Set();
          set2.add(value);
          let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
          if (key === null) {
            return false;
          }
          if (defined(fallback) && fallback !== prop) {
            key = addScopesFromKey(set2, allScopes, fallback, key, value);
            if (key === null) {
              return false;
            }
          }
          return _createResolver(Array.from(set2), [""], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
        }
        function addScopesFromKey(set2, allScopes, key, fallback, item) {
          while (key) {
            key = addScopes(set2, allScopes, key, fallback, item);
          }
          return key;
        }
        function subGetTarget(resolver, prop, value) {
          const parent = resolver._getTarget();
          if (!(prop in parent)) {
            parent[prop] = {};
          }
          const target = parent[prop];
          if (isArray(target) && isObject(value)) {
            return value;
          }
          return target;
        }
        function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
          let value;
          for (const prefix of prefixes) {
            value = _resolve(readKey(prefix, prop), scopes);
            if (defined(value)) {
              return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
            }
          }
        }
        function _resolve(key, scopes) {
          for (const scope of scopes) {
            if (!scope) {
              continue;
            }
            const value = scope[key];
            if (defined(value)) {
              return value;
            }
          }
        }
        function getKeysFromAllScopes(target) {
          let keys = target._keys;
          if (!keys) {
            keys = target._keys = resolveKeysFromAllScopes(target._scopes);
          }
          return keys;
        }
        function resolveKeysFromAllScopes(scopes) {
          const set2 = new Set();
          for (const scope of scopes) {
            for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
              set2.add(key);
            }
          }
          return Array.from(set2);
        }
        function _parseObjectDataRadialScale(meta, data, start, count) {
          const { iScale } = meta;
          const { key = "r" } = this._parsing;
          const parsed = new Array(count);
          let i, ilen, index2, item;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index2 = i + start;
            item = data[index2];
            parsed[i] = {
              r: iScale.parse(resolveObjectKey(item, key), index2)
            };
          }
          return parsed;
        }
        const EPSILON = Number.EPSILON || 1e-14;
        const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
        const getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
        function splineCurve(firstPoint, middlePoint, afterPoint, t) {
          const previous = firstPoint.skip ? middlePoint : firstPoint;
          const current = middlePoint;
          const next = afterPoint.skip ? middlePoint : afterPoint;
          const d01 = distanceBetweenPoints(current, previous);
          const d12 = distanceBetweenPoints(next, current);
          let s01 = d01 / (d01 + d12);
          let s12 = d12 / (d01 + d12);
          s01 = isNaN(s01) ? 0 : s01;
          s12 = isNaN(s12) ? 0 : s12;
          const fa = t * s01;
          const fb2 = t * s12;
          return {
            previous: {
              x: current.x - fa * (next.x - previous.x),
              y: current.y - fa * (next.y - previous.y)
            },
            next: {
              x: current.x + fb2 * (next.x - previous.x),
              y: current.y + fb2 * (next.y - previous.y)
            }
          };
        }
        function monotoneAdjust(points, deltaK, mK) {
          const pointsLen = points.length;
          let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (let i = 0; i < pointsLen - 1; ++i) {
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent || !pointAfter) {
              continue;
            }
            if (almostEquals(deltaK[i], 0, EPSILON)) {
              mK[i] = mK[i + 1] = 0;
              continue;
            }
            alphaK = mK[i] / deltaK[i];
            betaK = mK[i + 1] / deltaK[i];
            squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
            if (squaredMagnitude <= 9) {
              continue;
            }
            tauK = 3 / Math.sqrt(squaredMagnitude);
            mK[i] = alphaK * tauK * deltaK[i];
            mK[i + 1] = betaK * tauK * deltaK[i];
          }
        }
        function monotoneCompute(points, mK, indexAxis = "x") {
          const valueAxis = getValueAxis(indexAxis);
          const pointsLen = points.length;
          let delta, pointBefore, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (let i = 0; i < pointsLen; ++i) {
            pointBefore = pointCurrent;
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent) {
              continue;
            }
            const iPixel = pointCurrent[indexAxis];
            const vPixel = pointCurrent[valueAxis];
            if (pointBefore) {
              delta = (iPixel - pointBefore[indexAxis]) / 3;
              pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
              pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
            }
            if (pointAfter) {
              delta = (pointAfter[indexAxis] - iPixel) / 3;
              pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
              pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
            }
          }
        }
        function splineCurveMonotone(points, indexAxis = "x") {
          const valueAxis = getValueAxis(indexAxis);
          const pointsLen = points.length;
          const deltaK = Array(pointsLen).fill(0);
          const mK = Array(pointsLen);
          let i, pointBefore, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (i = 0; i < pointsLen; ++i) {
            pointBefore = pointCurrent;
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent) {
              continue;
            }
            if (pointAfter) {
              const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
              deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
            }
            mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
          }
          monotoneAdjust(points, deltaK, mK);
          monotoneCompute(points, mK, indexAxis);
        }
        function capControlPoint(pt2, min, max) {
          return Math.max(Math.min(pt2, max), min);
        }
        function capBezierPoints(points, area) {
          let i, ilen, point, inArea, inAreaPrev;
          let inAreaNext = _isPointInArea(points[0], area);
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            inAreaPrev = inArea;
            inArea = inAreaNext;
            inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
            if (!inArea) {
              continue;
            }
            point = points[i];
            if (inAreaPrev) {
              point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
              point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
            }
            if (inAreaNext) {
              point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
              point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
            }
          }
        }
        function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
          let i, ilen, point, controlPoints;
          if (options.spanGaps) {
            points = points.filter((pt2) => !pt2.skip);
          }
          if (options.cubicInterpolationMode === "monotone") {
            splineCurveMonotone(points, indexAxis);
          } else {
            let prev = loop ? points[points.length - 1] : points[0];
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              point = points[i];
              controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
              point.cp1x = controlPoints.previous.x;
              point.cp1y = controlPoints.previous.y;
              point.cp2x = controlPoints.next.x;
              point.cp2y = controlPoints.next.y;
              prev = point;
            }
          }
          if (options.capBezierPoints) {
            capBezierPoints(points, area);
          }
        }
        const atEdge = (t) => t === 0 || t === 1;
        const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
        const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
        const effects = {
          linear: (t) => t,
          easeInQuad: (t) => t * t,
          easeOutQuad: (t) => -t * (t - 2),
          easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
          easeInCubic: (t) => t * t * t,
          easeOutCubic: (t) => (t -= 1) * t * t + 1,
          easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
          easeInQuart: (t) => t * t * t * t,
          easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
          easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
          easeInQuint: (t) => t * t * t * t * t,
          easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
          easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
          easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
          easeOutSine: (t) => Math.sin(t * HALF_PI),
          easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
          easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
          easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
          easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
          easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
          easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
          easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
          easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
          easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
          easeInOutElastic(t) {
            const s = 0.1125;
            const p = 0.45;
            return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
          },
          easeInBack(t) {
            const s = 1.70158;
            return t * t * ((s + 1) * t - s);
          },
          easeOutBack(t) {
            const s = 1.70158;
            return (t -= 1) * t * ((s + 1) * t + s) + 1;
          },
          easeInOutBack(t) {
            let s = 1.70158;
            if ((t /= 0.5) < 1) {
              return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
            }
            return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
          },
          easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
          easeOutBounce(t) {
            const m = 7.5625;
            const d2 = 2.75;
            if (t < 1 / d2) {
              return m * t * t;
            }
            if (t < 2 / d2) {
              return m * (t -= 1.5 / d2) * t + 0.75;
            }
            if (t < 2.5 / d2) {
              return m * (t -= 2.25 / d2) * t + 0.9375;
            }
            return m * (t -= 2.625 / d2) * t + 0.984375;
          },
          easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
        };
        function _pointInLine(p1, p2, t, mode) {
          return {
            x: p1.x + t * (p2.x - p1.x),
            y: p1.y + t * (p2.y - p1.y)
          };
        }
        function _steppedInterpolation(p1, p2, t, mode) {
          return {
            x: p1.x + t * (p2.x - p1.x),
            y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
          };
        }
        function _bezierInterpolation(p1, p2, t, mode) {
          const cp1 = { x: p1.cp2x, y: p1.cp2y };
          const cp2 = { x: p2.cp1x, y: p2.cp1y };
          const a = _pointInLine(p1, cp1, t);
          const b = _pointInLine(cp1, cp2, t);
          const c2 = _pointInLine(cp2, p2, t);
          const d2 = _pointInLine(a, b, t);
          const e = _pointInLine(b, c2, t);
          return _pointInLine(d2, e, t);
        }
        const intlCache = new Map();
        function getNumberFormat(locale, options) {
          options = options || {};
          const cacheKey = locale + JSON.stringify(options);
          let formatter = intlCache.get(cacheKey);
          if (!formatter) {
            formatter = new Intl.NumberFormat(locale, options);
            intlCache.set(cacheKey, formatter);
          }
          return formatter;
        }
        function formatNumber(num, locale, options) {
          return getNumberFormat(locale, options).format(num);
        }
        const LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
        const FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
        function toLineHeight(value, size) {
          const matches = ("" + value).match(LINE_HEIGHT);
          if (!matches || matches[1] === "normal") {
            return size * 1.2;
          }
          value = +matches[2];
          switch (matches[3]) {
            case "px":
              return value;
            case "%":
              value /= 100;
              break;
          }
          return size * value;
        }
        const numberOrZero = (v) => +v || 0;
        function _readValueToProps(value, props) {
          const ret = {};
          const objProps = isObject(props);
          const keys = objProps ? Object.keys(props) : props;
          const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
          for (const prop of keys) {
            ret[prop] = numberOrZero(read(prop));
          }
          return ret;
        }
        function toTRBL(value) {
          return _readValueToProps(value, { top: "y", right: "x", bottom: "y", left: "x" });
        }
        function toTRBLCorners(value) {
          return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
        }
        function toPadding(value) {
          const obj = toTRBL(value);
          obj.width = obj.left + obj.right;
          obj.height = obj.top + obj.bottom;
          return obj;
        }
        function toFont(options, fallback) {
          options = options || {};
          fallback = fallback || defaults.font;
          let size = valueOrDefault(options.size, fallback.size);
          if (typeof size === "string") {
            size = parseInt(size, 10);
          }
          let style = valueOrDefault(options.style, fallback.style);
          if (style && !("" + style).match(FONT_STYLE)) {
            console.warn('Invalid font style specified: "' + style + '"');
            style = "";
          }
          const font = {
            family: valueOrDefault(options.family, fallback.family),
            lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
            size,
            style,
            weight: valueOrDefault(options.weight, fallback.weight),
            string: ""
          };
          font.string = toFontString(font);
          return font;
        }
        function resolve(inputs, context, index2, info) {
          let cacheable = true;
          let i, ilen, value;
          for (i = 0, ilen = inputs.length; i < ilen; ++i) {
            value = inputs[i];
            if (value === void 0) {
              continue;
            }
            if (context !== void 0 && typeof value === "function") {
              value = value(context);
              cacheable = false;
            }
            if (index2 !== void 0 && isArray(value)) {
              value = value[index2 % value.length];
              cacheable = false;
            }
            if (value !== void 0) {
              if (info && !cacheable) {
                info.cacheable = false;
              }
              return value;
            }
          }
        }
        function _addGrace(minmax, grace, beginAtZero) {
          const { min, max } = minmax;
          const change = toDimension(grace, (max - min) / 2);
          const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
          return {
            min: keepZero(min, -Math.abs(change)),
            max: keepZero(max, change)
          };
        }
        function createContext(parentContext, context) {
          return Object.assign(Object.create(parentContext), context);
        }
        const getRightToLeftAdapter = function(rectX, width) {
          return {
            x(x) {
              return rectX + rectX + width - x;
            },
            setWidth(w) {
              width = w;
            },
            textAlign(align) {
              if (align === "center") {
                return align;
              }
              return align === "right" ? "left" : "right";
            },
            xPlus(x, value) {
              return x - value;
            },
            leftForLtr(x, itemWidth) {
              return x - itemWidth;
            }
          };
        };
        const getLeftToRightAdapter = function() {
          return {
            x(x) {
              return x;
            },
            setWidth(w) {
            },
            textAlign(align) {
              return align;
            },
            xPlus(x, value) {
              return x + value;
            },
            leftForLtr(x, _itemWidth) {
              return x;
            }
          };
        };
        function getRtlAdapter(rtl, rectX, width) {
          return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
        }
        function overrideTextDirection(ctx, direction) {
          let style, original;
          if (direction === "ltr" || direction === "rtl") {
            style = ctx.canvas.style;
            original = [
              style.getPropertyValue("direction"),
              style.getPropertyPriority("direction")
            ];
            style.setProperty("direction", direction, "important");
            ctx.prevTextDirection = original;
          }
        }
        function restoreTextDirection(ctx, original) {
          if (original !== void 0) {
            delete ctx.prevTextDirection;
            ctx.canvas.style.setProperty("direction", original[0], original[1]);
          }
        }
        function propertyFn(property) {
          if (property === "angle") {
            return {
              between: _angleBetween,
              compare: _angleDiff,
              normalize: _normalizeAngle
            };
          }
          return {
            between: _isBetween,
            compare: (a, b) => a - b,
            normalize: (x) => x
          };
        }
        function normalizeSegment({ start, end, count, loop, style }) {
          return {
            start: start % count,
            end: end % count,
            loop: loop && (end - start + 1) % count === 0,
            style
          };
        }
        function getSegment(segment, points, bounds) {
          const { property, start: startBound, end: endBound } = bounds;
          const { between, normalize } = propertyFn(property);
          const count = points.length;
          let { start, end, loop } = segment;
          let i, ilen;
          if (loop) {
            start += count;
            end += count;
            for (i = 0, ilen = count; i < ilen; ++i) {
              if (!between(normalize(points[start % count][property]), startBound, endBound)) {
                break;
              }
              start--;
              end--;
            }
            start %= count;
            end %= count;
          }
          if (end < start) {
            end += count;
          }
          return { start, end, loop, style: segment.style };
        }
        function _boundSegment(segment, points, bounds) {
          if (!bounds) {
            return [segment];
          }
          const { property, start: startBound, end: endBound } = bounds;
          const count = points.length;
          const { compare, between, normalize } = propertyFn(property);
          const { start, end, loop, style } = getSegment(segment, points, bounds);
          const result = [];
          let inside = false;
          let subStart = null;
          let value, point, prevValue;
          const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
          const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
          const shouldStart = () => inside || startIsBefore();
          const shouldStop = () => !inside || endIsBefore();
          for (let i = start, prev = start; i <= end; ++i) {
            point = points[i % count];
            if (point.skip) {
              continue;
            }
            value = normalize(point[property]);
            if (value === prevValue) {
              continue;
            }
            inside = between(value, startBound, endBound);
            if (subStart === null && shouldStart()) {
              subStart = compare(value, startBound) === 0 ? i : prev;
            }
            if (subStart !== null && shouldStop()) {
              result.push(normalizeSegment({ start: subStart, end: i, loop, count, style }));
              subStart = null;
            }
            prev = i;
            prevValue = value;
          }
          if (subStart !== null) {
            result.push(normalizeSegment({ start: subStart, end, loop, count, style }));
          }
          return result;
        }
        function _boundSegments(line, bounds) {
          const result = [];
          const segments = line.segments;
          for (let i = 0; i < segments.length; i++) {
            const sub = _boundSegment(segments[i], line.points, bounds);
            if (sub.length) {
              result.push(...sub);
            }
          }
          return result;
        }
        function findStartAndEnd(points, count, loop, spanGaps) {
          let start = 0;
          let end = count - 1;
          if (loop && !spanGaps) {
            while (start < count && !points[start].skip) {
              start++;
            }
          }
          while (start < count && points[start].skip) {
            start++;
          }
          start %= count;
          if (loop) {
            end += start;
          }
          while (end > start && points[end % count].skip) {
            end--;
          }
          end %= count;
          return { start, end };
        }
        function solidSegments(points, start, max, loop) {
          const count = points.length;
          const result = [];
          let last = start;
          let prev = points[start];
          let end;
          for (end = start + 1; end <= max; ++end) {
            const cur = points[end % count];
            if (cur.skip || cur.stop) {
              if (!prev.skip) {
                loop = false;
                result.push({ start: start % count, end: (end - 1) % count, loop });
                start = last = cur.stop ? end : null;
              }
            } else {
              last = end;
              if (prev.skip) {
                start = end;
              }
            }
            prev = cur;
          }
          if (last !== null) {
            result.push({ start: start % count, end: last % count, loop });
          }
          return result;
        }
        function _computeSegments(line, segmentOptions) {
          const points = line.points;
          const spanGaps = line.options.spanGaps;
          const count = points.length;
          if (!count) {
            return [];
          }
          const loop = !!line._loop;
          const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
          if (spanGaps === true) {
            return splitByStyles(line, [{ start, end, loop }], points, segmentOptions);
          }
          const max = end < start ? end + count : end;
          const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
          return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
        }
        function splitByStyles(line, segments, points, segmentOptions) {
          if (!segmentOptions || !segmentOptions.setContext || !points) {
            return segments;
          }
          return doSplitByStyles(line, segments, points, segmentOptions);
        }
        function doSplitByStyles(line, segments, points, segmentOptions) {
          const chartContext = line._chart.getContext();
          const baseStyle = readStyle(line.options);
          const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
          const count = points.length;
          const result = [];
          let prevStyle = baseStyle;
          let start = segments[0].start;
          let i = start;
          function addStyle(s, e, l, st2) {
            const dir = spanGaps ? -1 : 1;
            if (s === e) {
              return;
            }
            s += count;
            while (points[s % count].skip) {
              s -= dir;
            }
            while (points[e % count].skip) {
              e += dir;
            }
            if (s % count !== e % count) {
              result.push({ start: s % count, end: e % count, loop: l, style: st2 });
              prevStyle = st2;
              start = e % count;
            }
          }
          for (const segment of segments) {
            start = spanGaps ? start : segment.start;
            let prev = points[start % count];
            let style;
            for (i = start + 1; i <= segment.end; i++) {
              const pt2 = points[i % count];
              style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                type: "segment",
                p0: prev,
                p1: pt2,
                p0DataIndex: (i - 1) % count,
                p1DataIndex: i % count,
                datasetIndex
              })));
              if (styleChanged(style, prevStyle)) {
                addStyle(start, i - 1, segment.loop, prevStyle);
              }
              prev = pt2;
              prevStyle = style;
            }
            if (start < i - 1) {
              addStyle(start, i - 1, segment.loop, prevStyle);
            }
          }
          return result;
        }
        function readStyle(options) {
          return {
            backgroundColor: options.backgroundColor,
            borderCapStyle: options.borderCapStyle,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderJoinStyle: options.borderJoinStyle,
            borderWidth: options.borderWidth,
            borderColor: options.borderColor
          };
        }
        function styleChanged(style, prevStyle) {
          return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
        }
        var helpers = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          easingEffects: effects,
          isPatternOrGradient,
          color,
          getHoverColor,
          noop,
          uid,
          isNullOrUndef,
          isArray,
          isObject,
          isFinite: isNumberFinite,
          finiteOrDefault,
          valueOrDefault,
          toPercentage,
          toDimension,
          callback,
          each,
          _elementsEqual,
          clone: clone$1,
          _merger,
          merge,
          mergeIf,
          _mergerIf,
          _deprecated,
          resolveObjectKey,
          _splitKey,
          _capitalize,
          defined,
          isFunction,
          setsEqual,
          _isClickEvent,
          toFontString,
          _measureText,
          _longestText,
          _alignPixel,
          clearCanvas,
          drawPoint,
          drawPointLegend,
          _isPointInArea,
          clipArea,
          unclipArea,
          _steppedLineTo,
          _bezierCurveTo,
          renderText,
          addRoundedRectPath,
          _lookup,
          _lookupByKey,
          _rlookupByKey,
          _filterBetween,
          listenArrayEvents,
          unlistenArrayEvents,
          _arrayUnique,
          _createResolver,
          _attachContext,
          _descriptors,
          _parseObjectDataRadialScale,
          splineCurve,
          splineCurveMonotone,
          _updateBezierControlPoints,
          _isDomSupported,
          _getParentNode,
          getStyle,
          getRelativePosition,
          getMaximumSize,
          retinaScale,
          supportsEventListenerOptions,
          readUsedSize,
          fontString,
          requestAnimFrame,
          throttled,
          debounce,
          _toLeftRightCenter,
          _alignStartEnd,
          _textX,
          _getStartAndCountOfVisiblePoints,
          _scaleRangesChanged,
          _pointInLine,
          _steppedInterpolation,
          _bezierInterpolation,
          formatNumber,
          toLineHeight,
          _readValueToProps,
          toTRBL,
          toTRBLCorners,
          toPadding,
          toFont,
          resolve,
          _addGrace,
          createContext,
          PI,
          TAU,
          PITAU,
          INFINITY,
          RAD_PER_DEG,
          HALF_PI,
          QUARTER_PI,
          TWO_THIRDS_PI,
          log10,
          sign,
          niceNum,
          _factorize,
          isNumber,
          almostEquals,
          almostWhole,
          _setMinAndMaxByKey,
          toRadians,
          toDegrees,
          _decimalPlaces,
          getAngleFromPoint,
          distanceBetweenPoints,
          _angleDiff,
          _normalizeAngle,
          _angleBetween,
          _limitValue,
          _int16Range,
          _isBetween,
          getRtlAdapter,
          overrideTextDirection,
          restoreTextDirection,
          _boundSegment,
          _boundSegments,
          _computeSegments
        });
        function binarySearch(metaset, axis, value, intersect) {
          const { controller, data, _sorted } = metaset;
          const iScale = controller._cachedMeta.iScale;
          if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
            const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
            if (!intersect) {
              return lookupMethod(data, axis, value);
            } else if (controller._sharedOptions) {
              const el2 = data[0];
              const range = typeof el2.getRange === "function" && el2.getRange(axis);
              if (range) {
                const start = lookupMethod(data, axis, value - range);
                const end = lookupMethod(data, axis, value + range);
                return { lo: start.lo, hi: end.hi };
              }
            }
          }
          return { lo: 0, hi: data.length - 1 };
        }
        function evaluateInteractionItems(chart, axis, position, handler, intersect) {
          const metasets = chart.getSortedVisibleDatasetMetas();
          const value = position[axis];
          for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
            const { index: index2, data } = metasets[i];
            const { lo: lo2, hi: hi2 } = binarySearch(metasets[i], axis, value, intersect);
            for (let j2 = lo2; j2 <= hi2; ++j2) {
              const element = data[j2];
              if (!element.skip) {
                handler(element, index2, j2);
              }
            }
          }
        }
        function getDistanceMetricForAxis(axis) {
          const useX = axis.indexOf("x") !== -1;
          const useY = axis.indexOf("y") !== -1;
          return function(pt1, pt2) {
            const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
            const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
          };
        }
        function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
          const items = [];
          if (!includeInvisible && !chart.isPointInArea(position)) {
            return items;
          }
          const evaluationFunc = function(element, datasetIndex, index2) {
            if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
              return;
            }
            if (element.inRange(position.x, position.y, useFinalPosition)) {
              items.push({ element, datasetIndex, index: index2 });
            }
          };
          evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
          return items;
        }
        function getNearestRadialItems(chart, position, axis, useFinalPosition) {
          let items = [];
          function evaluationFunc(element, datasetIndex, index2) {
            const { startAngle, endAngle } = element.getProps(["startAngle", "endAngle"], useFinalPosition);
            const { angle } = getAngleFromPoint(element, { x: position.x, y: position.y });
            if (_angleBetween(angle, startAngle, endAngle)) {
              items.push({ element, datasetIndex, index: index2 });
            }
          }
          evaluateInteractionItems(chart, axis, position, evaluationFunc);
          return items;
        }
        function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
          let items = [];
          const distanceMetric = getDistanceMetricForAxis(axis);
          let minDistance = Number.POSITIVE_INFINITY;
          function evaluationFunc(element, datasetIndex, index2) {
            const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
            if (intersect && !inRange2) {
              return;
            }
            const center = element.getCenterPoint(useFinalPosition);
            const pointInArea = !!includeInvisible || chart.isPointInArea(center);
            if (!pointInArea && !inRange2) {
              return;
            }
            const distance = distanceMetric(position, center);
            if (distance < minDistance) {
              items = [{ element, datasetIndex, index: index2 }];
              minDistance = distance;
            } else if (distance === minDistance) {
              items.push({ element, datasetIndex, index: index2 });
            }
          }
          evaluateInteractionItems(chart, axis, position, evaluationFunc);
          return items;
        }
        function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
          if (!includeInvisible && !chart.isPointInArea(position)) {
            return [];
          }
          return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
        }
        function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
          const items = [];
          const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
          let intersectsItem = false;
          evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
            if (element[rangeMethod](position[axis], useFinalPosition)) {
              items.push({ element, datasetIndex, index: index2 });
              intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
            }
          });
          if (intersect && !intersectsItem) {
            return [];
          }
          return items;
        }
        var Interaction = {
          evaluateInteractionItems,
          modes: {
            index(chart, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart);
              const axis = options.axis || "x";
              const includeInvisible = options.includeInvisible || false;
              const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
              const elements2 = [];
              if (!items.length) {
                return [];
              }
              chart.getSortedVisibleDatasetMetas().forEach((meta) => {
                const index2 = items[0].index;
                const element = meta.data[index2];
                if (element && !element.skip) {
                  elements2.push({ element, datasetIndex: meta.index, index: index2 });
                }
              });
              return elements2;
            },
            dataset(chart, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart);
              const axis = options.axis || "xy";
              const includeInvisible = options.includeInvisible || false;
              let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
              if (items.length > 0) {
                const datasetIndex = items[0].datasetIndex;
                const data = chart.getDatasetMeta(datasetIndex).data;
                items = [];
                for (let i = 0; i < data.length; ++i) {
                  items.push({ element: data[i], datasetIndex, index: i });
                }
              }
              return items;
            },
            point(chart, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart);
              const axis = options.axis || "xy";
              const includeInvisible = options.includeInvisible || false;
              return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
            },
            nearest(chart, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart);
              const axis = options.axis || "xy";
              const includeInvisible = options.includeInvisible || false;
              return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
            },
            x(chart, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart);
              return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
            },
            y(chart, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart);
              return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
            }
          }
        };
        const STATIC_POSITIONS = ["left", "top", "right", "bottom"];
        function filterByPosition(array, position) {
          return array.filter((v) => v.pos === position);
        }
        function filterDynamicPositionByAxis(array, axis) {
          return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
        }
        function sortByWeight(array, reverse) {
          return array.sort((a, b) => {
            const v0 = reverse ? b : a;
            const v1 = reverse ? a : b;
            return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
          });
        }
        function wrapBoxes(boxes) {
          const layoutBoxes = [];
          let i, ilen, box, pos, stack, stackWeight;
          for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
            box = boxes[i];
            ({ position: pos, options: { stack, stackWeight = 1 } } = box);
            layoutBoxes.push({
              index: i,
              box,
              pos,
              horizontal: box.isHorizontal(),
              weight: box.weight,
              stack: stack && pos + stack,
              stackWeight
            });
          }
          return layoutBoxes;
        }
        function buildStacks(layouts2) {
          const stacks = {};
          for (const wrap of layouts2) {
            const { stack, pos, stackWeight } = wrap;
            if (!stack || !STATIC_POSITIONS.includes(pos)) {
              continue;
            }
            const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
            _stack.count++;
            _stack.weight += stackWeight;
          }
          return stacks;
        }
        function setLayoutDims(layouts2, params) {
          const stacks = buildStacks(layouts2);
          const { vBoxMaxWidth, hBoxMaxHeight } = params;
          let i, ilen, layout;
          for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
            layout = layouts2[i];
            const { fullSize } = layout.box;
            const stack = stacks[layout.stack];
            const factor = stack && layout.stackWeight / stack.weight;
            if (layout.horizontal) {
              layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
              layout.height = hBoxMaxHeight;
            } else {
              layout.width = vBoxMaxWidth;
              layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
            }
          }
          return stacks;
        }
        function buildLayoutBoxes(boxes) {
          const layoutBoxes = wrapBoxes(boxes);
          const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
          const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
          const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
          const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
          const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
          const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
          const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
          return {
            fullSize,
            leftAndTop: left.concat(top),
            rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
            chartArea: filterByPosition(layoutBoxes, "chartArea"),
            vertical: left.concat(right).concat(centerVertical),
            horizontal: top.concat(bottom).concat(centerHorizontal)
          };
        }
        function getCombinedMax(maxPadding, chartArea, a, b) {
          return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
        }
        function updateMaxPadding(maxPadding, boxPadding) {
          maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
          maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
          maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
          maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
        }
        function updateDims(chartArea, params, layout, stacks) {
          const { pos, box } = layout;
          const maxPadding = chartArea.maxPadding;
          if (!isObject(pos)) {
            if (layout.size) {
              chartArea[pos] -= layout.size;
            }
            const stack = stacks[layout.stack] || { size: 0, count: 1 };
            stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
            layout.size = stack.size / stack.count;
            chartArea[pos] += layout.size;
          }
          if (box.getPadding) {
            updateMaxPadding(maxPadding, box.getPadding());
          }
          const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
          const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
          const widthChanged = newWidth !== chartArea.w;
          const heightChanged = newHeight !== chartArea.h;
          chartArea.w = newWidth;
          chartArea.h = newHeight;
          return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
        }
        function handleMaxPadding(chartArea) {
          const maxPadding = chartArea.maxPadding;
          function updatePos(pos) {
            const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
            chartArea[pos] += change;
            return change;
          }
          chartArea.y += updatePos("top");
          chartArea.x += updatePos("left");
          updatePos("right");
          updatePos("bottom");
        }
        function getMargins(horizontal, chartArea) {
          const maxPadding = chartArea.maxPadding;
          function marginForPositions(positions2) {
            const margin = { left: 0, top: 0, right: 0, bottom: 0 };
            positions2.forEach((pos) => {
              margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
            });
            return margin;
          }
          return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
        }
        function fitBoxes(boxes, chartArea, params, stacks) {
          const refitBoxes = [];
          let i, ilen, layout, box, refit, changed;
          for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
            layout = boxes[i];
            box = layout.box;
            box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
            const { same, other } = updateDims(chartArea, params, layout, stacks);
            refit |= same && refitBoxes.length;
            changed = changed || other;
            if (!box.fullSize) {
              refitBoxes.push(layout);
            }
          }
          return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
        }
        function setBoxDims(box, left, top, width, height) {
          box.top = top;
          box.left = left;
          box.right = left + width;
          box.bottom = top + height;
          box.width = width;
          box.height = height;
        }
        function placeBoxes(boxes, chartArea, params, stacks) {
          const userPadding = params.padding;
          let { x, y: y2 } = chartArea;
          for (const layout of boxes) {
            const box = layout.box;
            const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
            const weight = layout.stackWeight / stack.weight || 1;
            if (layout.horizontal) {
              const width = chartArea.w * weight;
              const height = stack.size || box.height;
              if (defined(stack.start)) {
                y2 = stack.start;
              }
              if (box.fullSize) {
                setBoxDims(box, userPadding.left, y2, params.outerWidth - userPadding.right - userPadding.left, height);
              } else {
                setBoxDims(box, chartArea.left + stack.placed, y2, width, height);
              }
              stack.start = y2;
              stack.placed += width;
              y2 = box.bottom;
            } else {
              const height = chartArea.h * weight;
              const width = stack.size || box.width;
              if (defined(stack.start)) {
                x = stack.start;
              }
              if (box.fullSize) {
                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
              } else {
                setBoxDims(box, x, chartArea.top + stack.placed, width, height);
              }
              stack.start = x;
              stack.placed += height;
              x = box.right;
            }
          }
          chartArea.x = x;
          chartArea.y = y2;
        }
        defaults.set("layout", {
          autoPadding: true,
          padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          }
        });
        var layouts = {
          addBox(chart, item) {
            if (!chart.boxes) {
              chart.boxes = [];
            }
            item.fullSize = item.fullSize || false;
            item.position = item.position || "top";
            item.weight = item.weight || 0;
            item._layers = item._layers || function() {
              return [{
                z: 0,
                draw(chartArea) {
                  item.draw(chartArea);
                }
              }];
            };
            chart.boxes.push(item);
          },
          removeBox(chart, layoutItem) {
            const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
            if (index2 !== -1) {
              chart.boxes.splice(index2, 1);
            }
          },
          configure(chart, item, options) {
            item.fullSize = options.fullSize;
            item.position = options.position;
            item.weight = options.weight;
          },
          update(chart, width, height, minPadding) {
            if (!chart) {
              return;
            }
            const padding = toPadding(chart.options.layout.padding);
            const availableWidth = Math.max(width - padding.width, 0);
            const availableHeight = Math.max(height - padding.height, 0);
            const boxes = buildLayoutBoxes(chart.boxes);
            const verticalBoxes = boxes.vertical;
            const horizontalBoxes = boxes.horizontal;
            each(chart.boxes, (box) => {
              if (typeof box.beforeLayout === "function") {
                box.beforeLayout();
              }
            });
            const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
            const params = Object.freeze({
              outerWidth: width,
              outerHeight: height,
              padding,
              availableWidth,
              availableHeight,
              vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
              hBoxMaxHeight: availableHeight / 2
            });
            const maxPadding = Object.assign({}, padding);
            updateMaxPadding(maxPadding, toPadding(minPadding));
            const chartArea = Object.assign({
              maxPadding,
              w: availableWidth,
              h: availableHeight,
              x: padding.left,
              y: padding.top
            }, padding);
            const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
            fitBoxes(boxes.fullSize, chartArea, params, stacks);
            fitBoxes(verticalBoxes, chartArea, params, stacks);
            if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
              fitBoxes(verticalBoxes, chartArea, params, stacks);
            }
            handleMaxPadding(chartArea);
            placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
            chartArea.x += chartArea.w;
            chartArea.y += chartArea.h;
            placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
            chart.chartArea = {
              left: chartArea.left,
              top: chartArea.top,
              right: chartArea.left + chartArea.w,
              bottom: chartArea.top + chartArea.h,
              height: chartArea.h,
              width: chartArea.w
            };
            each(boxes.chartArea, (layout) => {
              const box = layout.box;
              Object.assign(box, chart.chartArea);
              box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
            });
          }
        };
        class BasePlatform {
          acquireContext(canvas, aspectRatio) {
          }
          releaseContext(context) {
            return false;
          }
          addEventListener(chart, type, listener) {
          }
          removeEventListener(chart, type, listener) {
          }
          getDevicePixelRatio() {
            return 1;
          }
          getMaximumSize(element, width, height, aspectRatio) {
            width = Math.max(0, width || element.width);
            height = height || element.height;
            return {
              width,
              height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
            };
          }
          isAttached(canvas) {
            return true;
          }
          updateConfig(config) {
          }
        }
        class BasicPlatform extends BasePlatform {
          acquireContext(item) {
            return item && item.getContext && item.getContext("2d") || null;
          }
          updateConfig(config) {
            config.options.animation = false;
          }
        }
        const EXPANDO_KEY = "$chartjs";
        const EVENT_TYPES = {
          touchstart: "mousedown",
          touchmove: "mousemove",
          touchend: "mouseup",
          pointerenter: "mouseenter",
          pointerdown: "mousedown",
          pointermove: "mousemove",
          pointerup: "mouseup",
          pointerleave: "mouseout",
          pointerout: "mouseout"
        };
        const isNullOrEmpty = (value) => value === null || value === "";
        function initCanvas(canvas, aspectRatio) {
          const style = canvas.style;
          const renderHeight = canvas.getAttribute("height");
          const renderWidth = canvas.getAttribute("width");
          canvas[EXPANDO_KEY] = {
            initial: {
              height: renderHeight,
              width: renderWidth,
              style: {
                display: style.display,
                height: style.height,
                width: style.width
              }
            }
          };
          style.display = style.display || "block";
          style.boxSizing = style.boxSizing || "border-box";
          if (isNullOrEmpty(renderWidth)) {
            const displayWidth = readUsedSize(canvas, "width");
            if (displayWidth !== void 0) {
              canvas.width = displayWidth;
            }
          }
          if (isNullOrEmpty(renderHeight)) {
            if (canvas.style.height === "") {
              canvas.height = canvas.width / (aspectRatio || 2);
            } else {
              const displayHeight = readUsedSize(canvas, "height");
              if (displayHeight !== void 0) {
                canvas.height = displayHeight;
              }
            }
          }
          return canvas;
        }
        const eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
        function addListener(node, type, listener) {
          node.addEventListener(type, listener, eventListenerOptions);
        }
        function removeListener(chart, type, listener) {
          chart.canvas.removeEventListener(type, listener, eventListenerOptions);
        }
        function fromNativeEvent(event2, chart) {
          const type = EVENT_TYPES[event2.type] || event2.type;
          const { x, y: y2 } = getRelativePosition(event2, chart);
          return {
            type,
            chart,
            native: event2,
            x: x !== void 0 ? x : null,
            y: y2 !== void 0 ? y2 : null
          };
        }
        function nodeListContains(nodeList, canvas) {
          for (const node of nodeList) {
            if (node === canvas || node.contains(canvas)) {
              return true;
            }
          }
        }
        function createAttachObserver(chart, type, listener) {
          const canvas = chart.canvas;
          const observer = new MutationObserver((entries) => {
            let trigger = false;
            for (const entry of entries) {
              trigger = trigger || nodeListContains(entry.addedNodes, canvas);
              trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
            }
            if (trigger) {
              listener();
            }
          });
          observer.observe(document, { childList: true, subtree: true });
          return observer;
        }
        function createDetachObserver(chart, type, listener) {
          const canvas = chart.canvas;
          const observer = new MutationObserver((entries) => {
            let trigger = false;
            for (const entry of entries) {
              trigger = trigger || nodeListContains(entry.removedNodes, canvas);
              trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
            }
            if (trigger) {
              listener();
            }
          });
          observer.observe(document, { childList: true, subtree: true });
          return observer;
        }
        const drpListeningCharts = new Map();
        let oldDevicePixelRatio = 0;
        function onWindowResize() {
          const dpr = window.devicePixelRatio;
          if (dpr === oldDevicePixelRatio) {
            return;
          }
          oldDevicePixelRatio = dpr;
          drpListeningCharts.forEach((resize, chart) => {
            if (chart.currentDevicePixelRatio !== dpr) {
              resize();
            }
          });
        }
        function listenDevicePixelRatioChanges(chart, resize) {
          if (!drpListeningCharts.size) {
            window.addEventListener("resize", onWindowResize);
          }
          drpListeningCharts.set(chart, resize);
        }
        function unlistenDevicePixelRatioChanges(chart) {
          drpListeningCharts.delete(chart);
          if (!drpListeningCharts.size) {
            window.removeEventListener("resize", onWindowResize);
          }
        }
        function createResizeObserver(chart, type, listener) {
          const canvas = chart.canvas;
          const container = canvas && _getParentNode(canvas);
          if (!container) {
            return;
          }
          const resize = throttled((width, height) => {
            const w = container.clientWidth;
            listener(width, height);
            if (w < container.clientWidth) {
              listener();
            }
          }, window);
          const observer = new ResizeObserver((entries) => {
            const entry = entries[0];
            const width = entry.contentRect.width;
            const height = entry.contentRect.height;
            if (width === 0 && height === 0) {
              return;
            }
            resize(width, height);
          });
          observer.observe(container);
          listenDevicePixelRatioChanges(chart, resize);
          return observer;
        }
        function releaseObserver(chart, type, observer) {
          if (observer) {
            observer.disconnect();
          }
          if (type === "resize") {
            unlistenDevicePixelRatioChanges(chart);
          }
        }
        function createProxyAndListen(chart, type, listener) {
          const canvas = chart.canvas;
          const proxy = throttled((event2) => {
            if (chart.ctx !== null) {
              listener(fromNativeEvent(event2, chart));
            }
          }, chart, (args) => {
            const event2 = args[0];
            return [event2, event2.offsetX, event2.offsetY];
          });
          addListener(canvas, type, proxy);
          return proxy;
        }
        class DomPlatform extends BasePlatform {
          acquireContext(canvas, aspectRatio) {
            const context = canvas && canvas.getContext && canvas.getContext("2d");
            if (context && context.canvas === canvas) {
              initCanvas(canvas, aspectRatio);
              return context;
            }
            return null;
          }
          releaseContext(context) {
            const canvas = context.canvas;
            if (!canvas[EXPANDO_KEY]) {
              return false;
            }
            const initial = canvas[EXPANDO_KEY].initial;
            ["height", "width"].forEach((prop) => {
              const value = initial[prop];
              if (isNullOrUndef(value)) {
                canvas.removeAttribute(prop);
              } else {
                canvas.setAttribute(prop, value);
              }
            });
            const style = initial.style || {};
            Object.keys(style).forEach((key) => {
              canvas.style[key] = style[key];
            });
            canvas.width = canvas.width;
            delete canvas[EXPANDO_KEY];
            return true;
          }
          addEventListener(chart, type, listener) {
            this.removeEventListener(chart, type);
            const proxies = chart.$proxies || (chart.$proxies = {});
            const handlers = {
              attach: createAttachObserver,
              detach: createDetachObserver,
              resize: createResizeObserver
            };
            const handler = handlers[type] || createProxyAndListen;
            proxies[type] = handler(chart, type, listener);
          }
          removeEventListener(chart, type) {
            const proxies = chart.$proxies || (chart.$proxies = {});
            const proxy = proxies[type];
            if (!proxy) {
              return;
            }
            const handlers = {
              attach: releaseObserver,
              detach: releaseObserver,
              resize: releaseObserver
            };
            const handler = handlers[type] || removeListener;
            handler(chart, type, proxy);
            proxies[type] = void 0;
          }
          getDevicePixelRatio() {
            return window.devicePixelRatio;
          }
          getMaximumSize(canvas, width, height, aspectRatio) {
            return getMaximumSize(canvas, width, height, aspectRatio);
          }
          isAttached(canvas) {
            const container = _getParentNode(canvas);
            return !!(container && container.isConnected);
          }
        }
        function _detectPlatform(canvas) {
          if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
            return BasicPlatform;
          }
          return DomPlatform;
        }
        var platforms = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          _detectPlatform,
          BasePlatform,
          BasicPlatform,
          DomPlatform
        });
        const transparent = "transparent";
        const interpolators = {
          boolean(from2, to3, factor) {
            return factor > 0.5 ? to3 : from2;
          },
          color(from2, to3, factor) {
            const c0 = color(from2 || transparent);
            const c1 = c0.valid && color(to3 || transparent);
            return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to3;
          },
          number(from2, to3, factor) {
            return from2 + (to3 - from2) * factor;
          }
        };
        class Animation {
          constructor(cfg, target, prop, to3) {
            const currentValue = target[prop];
            to3 = resolve([cfg.to, to3, currentValue, cfg.from]);
            const from2 = resolve([cfg.from, currentValue, to3]);
            this._active = true;
            this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
            this._easing = effects[cfg.easing] || effects.linear;
            this._start = Math.floor(Date.now() + (cfg.delay || 0));
            this._duration = this._total = Math.floor(cfg.duration);
            this._loop = !!cfg.loop;
            this._target = target;
            this._prop = prop;
            this._from = from2;
            this._to = to3;
            this._promises = void 0;
          }
          active() {
            return this._active;
          }
          update(cfg, to3, date) {
            if (this._active) {
              this._notify(false);
              const currentValue = this._target[this._prop];
              const elapsed = date - this._start;
              const remain = this._duration - elapsed;
              this._start = date;
              this._duration = Math.floor(Math.max(remain, cfg.duration));
              this._total += elapsed;
              this._loop = !!cfg.loop;
              this._to = resolve([cfg.to, to3, currentValue, cfg.from]);
              this._from = resolve([cfg.from, currentValue, to3]);
            }
          }
          cancel() {
            if (this._active) {
              this.tick(Date.now());
              this._active = false;
              this._notify(false);
            }
          }
          tick(date) {
            const elapsed = date - this._start;
            const duration = this._duration;
            const prop = this._prop;
            const from2 = this._from;
            const loop = this._loop;
            const to3 = this._to;
            let factor;
            this._active = from2 !== to3 && (loop || elapsed < duration);
            if (!this._active) {
              this._target[prop] = to3;
              this._notify(true);
              return;
            }
            if (elapsed < 0) {
              this._target[prop] = from2;
              return;
            }
            factor = elapsed / duration % 2;
            factor = loop && factor > 1 ? 2 - factor : factor;
            factor = this._easing(Math.min(1, Math.max(0, factor)));
            this._target[prop] = this._fn(from2, to3, factor);
          }
          wait() {
            const promises = this._promises || (this._promises = []);
            return new Promise((res, rej) => {
              promises.push({ res, rej });
            });
          }
          _notify(resolved) {
            const method = resolved ? "res" : "rej";
            const promises = this._promises || [];
            for (let i = 0; i < promises.length; i++) {
              promises[i][method]();
            }
          }
        }
        const numbers = ["x", "y", "borderWidth", "radius", "tension"];
        const colors = ["color", "borderColor", "backgroundColor"];
        defaults.set("animation", {
          delay: void 0,
          duration: 1e3,
          easing: "easeOutQuart",
          fn: void 0,
          from: void 0,
          loop: void 0,
          to: void 0,
          type: void 0
        });
        const animationOptions = Object.keys(defaults.animation);
        defaults.describe("animation", {
          _fallback: false,
          _indexable: false,
          _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
        });
        defaults.set("animations", {
          colors: {
            type: "color",
            properties: colors
          },
          numbers: {
            type: "number",
            properties: numbers
          }
        });
        defaults.describe("animations", {
          _fallback: "animation"
        });
        defaults.set("transitions", {
          active: {
            animation: {
              duration: 400
            }
          },
          resize: {
            animation: {
              duration: 0
            }
          },
          show: {
            animations: {
              colors: {
                from: "transparent"
              },
              visible: {
                type: "boolean",
                duration: 0
              }
            }
          },
          hide: {
            animations: {
              colors: {
                to: "transparent"
              },
              visible: {
                type: "boolean",
                easing: "linear",
                fn: (v) => v | 0
              }
            }
          }
        });
        class Animations {
          constructor(chart, config) {
            this._chart = chart;
            this._properties = new Map();
            this.configure(config);
          }
          configure(config) {
            if (!isObject(config)) {
              return;
            }
            const animatedProps = this._properties;
            Object.getOwnPropertyNames(config).forEach((key) => {
              const cfg = config[key];
              if (!isObject(cfg)) {
                return;
              }
              const resolved = {};
              for (const option of animationOptions) {
                resolved[option] = cfg[option];
              }
              (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
                if (prop === key || !animatedProps.has(prop)) {
                  animatedProps.set(prop, resolved);
                }
              });
            });
          }
          _animateOptions(target, values) {
            const newOptions = values.options;
            const options = resolveTargetOptions(target, newOptions);
            if (!options) {
              return [];
            }
            const animations = this._createAnimations(options, newOptions);
            if (newOptions.$shared) {
              awaitAll(target.options.$animations, newOptions).then(() => {
                target.options = newOptions;
              }, () => {
              });
            }
            return animations;
          }
          _createAnimations(target, values) {
            const animatedProps = this._properties;
            const animations = [];
            const running = target.$animations || (target.$animations = {});
            const props = Object.keys(values);
            const date = Date.now();
            let i;
            for (i = props.length - 1; i >= 0; --i) {
              const prop = props[i];
              if (prop.charAt(0) === "$") {
                continue;
              }
              if (prop === "options") {
                animations.push(...this._animateOptions(target, values));
                continue;
              }
              const value = values[prop];
              let animation = running[prop];
              const cfg = animatedProps.get(prop);
              if (animation) {
                if (cfg && animation.active()) {
                  animation.update(cfg, value, date);
                  continue;
                } else {
                  animation.cancel();
                }
              }
              if (!cfg || !cfg.duration) {
                target[prop] = value;
                continue;
              }
              running[prop] = animation = new Animation(cfg, target, prop, value);
              animations.push(animation);
            }
            return animations;
          }
          update(target, values) {
            if (this._properties.size === 0) {
              Object.assign(target, values);
              return;
            }
            const animations = this._createAnimations(target, values);
            if (animations.length) {
              animator.add(this._chart, animations);
              return true;
            }
          }
        }
        function awaitAll(animations, properties) {
          const running = [];
          const keys = Object.keys(properties);
          for (let i = 0; i < keys.length; i++) {
            const anim = animations[keys[i]];
            if (anim && anim.active()) {
              running.push(anim.wait());
            }
          }
          return Promise.all(running);
        }
        function resolveTargetOptions(target, newOptions) {
          if (!newOptions) {
            return;
          }
          let options = target.options;
          if (!options) {
            target.options = newOptions;
            return;
          }
          if (options.$shared) {
            target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
          }
          return options;
        }
        function scaleClip(scale, allowedOverflow) {
          const opts = scale && scale.options || {};
          const reverse = opts.reverse;
          const min = opts.min === void 0 ? allowedOverflow : 0;
          const max = opts.max === void 0 ? allowedOverflow : 0;
          return {
            start: reverse ? max : min,
            end: reverse ? min : max
          };
        }
        function defaultClip(xScale, yScale, allowedOverflow) {
          if (allowedOverflow === false) {
            return false;
          }
          const x = scaleClip(xScale, allowedOverflow);
          const y2 = scaleClip(yScale, allowedOverflow);
          return {
            top: y2.end,
            right: x.end,
            bottom: y2.start,
            left: x.start
          };
        }
        function toClip(value) {
          let t, r, b, l;
          if (isObject(value)) {
            t = value.top;
            r = value.right;
            b = value.bottom;
            l = value.left;
          } else {
            t = r = b = l = value;
          }
          return {
            top: t,
            right: r,
            bottom: b,
            left: l,
            disabled: value === false
          };
        }
        function getSortedDatasetIndices(chart, filterVisible) {
          const keys = [];
          const metasets = chart._getSortedDatasetMetas(filterVisible);
          let i, ilen;
          for (i = 0, ilen = metasets.length; i < ilen; ++i) {
            keys.push(metasets[i].index);
          }
          return keys;
        }
        function applyStack(stack, value, dsIndex, options = {}) {
          const keys = stack.keys;
          const singleMode = options.mode === "single";
          let i, ilen, datasetIndex, otherValue;
          if (value === null) {
            return;
          }
          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            datasetIndex = +keys[i];
            if (datasetIndex === dsIndex) {
              if (options.all) {
                continue;
              }
              break;
            }
            otherValue = stack.values[datasetIndex];
            if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
              value += otherValue;
            }
          }
          return value;
        }
        function convertObjectDataToArray(data) {
          const keys = Object.keys(data);
          const adata = new Array(keys.length);
          let i, ilen, key;
          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            adata[i] = {
              x: key,
              y: data[key]
            };
          }
          return adata;
        }
        function isStacked(scale, meta) {
          const stacked = scale && scale.options.stacked;
          return stacked || stacked === void 0 && meta.stack !== void 0;
        }
        function getStackKey(indexScale, valueScale, meta) {
          return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
        }
        function getUserBounds(scale) {
          const { min, max, minDefined, maxDefined } = scale.getUserBounds();
          return {
            min: minDefined ? min : Number.NEGATIVE_INFINITY,
            max: maxDefined ? max : Number.POSITIVE_INFINITY
          };
        }
        function getOrCreateStack(stacks, stackKey, indexValue) {
          const subStack = stacks[stackKey] || (stacks[stackKey] = {});
          return subStack[indexValue] || (subStack[indexValue] = {});
        }
        function getLastIndexInStack(stack, vScale, positive, type) {
          for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
            const value = stack[meta.index];
            if (positive && value > 0 || !positive && value < 0) {
              return meta.index;
            }
          }
          return null;
        }
        function updateStacks(controller, parsed) {
          const { chart, _cachedMeta: meta } = controller;
          const stacks = chart._stacks || (chart._stacks = {});
          const { iScale, vScale, index: datasetIndex } = meta;
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const key = getStackKey(iScale, vScale, meta);
          const ilen = parsed.length;
          let stack;
          for (let i = 0; i < ilen; ++i) {
            const item = parsed[i];
            const { [iAxis]: index2, [vAxis]: value } = item;
            const itemStacks = item._stacks || (item._stacks = {});
            stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
            stack[datasetIndex] = value;
            stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
            stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
          }
        }
        function getFirstScaleId(chart, axis) {
          const scales2 = chart.scales;
          return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
        }
        function createDatasetContext(parent, index2) {
          return createContext(parent, {
            active: false,
            dataset: void 0,
            datasetIndex: index2,
            index: index2,
            mode: "default",
            type: "dataset"
          });
        }
        function createDataContext(parent, index2, element) {
          return createContext(parent, {
            active: false,
            dataIndex: index2,
            parsed: void 0,
            raw: void 0,
            element,
            index: index2,
            mode: "default",
            type: "data"
          });
        }
        function clearStacks(meta, items) {
          const datasetIndex = meta.controller.index;
          const axis = meta.vScale && meta.vScale.axis;
          if (!axis) {
            return;
          }
          items = items || meta._parsed;
          for (const parsed of items) {
            const stacks = parsed._stacks;
            if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
              return;
            }
            delete stacks[axis][datasetIndex];
          }
        }
        const isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
        const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
        const createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && { keys: getSortedDatasetIndices(chart, true), values: null };
        class DatasetController {
          constructor(chart, datasetIndex) {
            this.chart = chart;
            this._ctx = chart.ctx;
            this.index = datasetIndex;
            this._cachedDataOpts = {};
            this._cachedMeta = this.getMeta();
            this._type = this._cachedMeta.type;
            this.options = void 0;
            this._parsing = false;
            this._data = void 0;
            this._objectData = void 0;
            this._sharedOptions = void 0;
            this._drawStart = void 0;
            this._drawCount = void 0;
            this.enableOptionSharing = false;
            this.supportsDecimation = false;
            this.$context = void 0;
            this._syncList = [];
            this.initialize();
          }
          initialize() {
            const meta = this._cachedMeta;
            this.configure();
            this.linkScales();
            meta._stacked = isStacked(meta.vScale, meta);
            this.addElements();
          }
          updateIndex(datasetIndex) {
            if (this.index !== datasetIndex) {
              clearStacks(this._cachedMeta);
            }
            this.index = datasetIndex;
          }
          linkScales() {
            const chart = this.chart;
            const meta = this._cachedMeta;
            const dataset = this.getDataset();
            const chooseId = (axis, x, y2, r) => axis === "x" ? x : axis === "r" ? r : y2;
            const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
            const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
            const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
            const indexAxis = meta.indexAxis;
            const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
            const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
            meta.xScale = this.getScaleForId(xid);
            meta.yScale = this.getScaleForId(yid);
            meta.rScale = this.getScaleForId(rid);
            meta.iScale = this.getScaleForId(iid);
            meta.vScale = this.getScaleForId(vid);
          }
          getDataset() {
            return this.chart.data.datasets[this.index];
          }
          getMeta() {
            return this.chart.getDatasetMeta(this.index);
          }
          getScaleForId(scaleID) {
            return this.chart.scales[scaleID];
          }
          _getOtherScale(scale) {
            const meta = this._cachedMeta;
            return scale === meta.iScale ? meta.vScale : meta.iScale;
          }
          reset() {
            this._update("reset");
          }
          _destroy() {
            const meta = this._cachedMeta;
            if (this._data) {
              unlistenArrayEvents(this._data, this);
            }
            if (meta._stacked) {
              clearStacks(meta);
            }
          }
          _dataCheck() {
            const dataset = this.getDataset();
            const data = dataset.data || (dataset.data = []);
            const _data = this._data;
            if (isObject(data)) {
              this._data = convertObjectDataToArray(data);
            } else if (_data !== data) {
              if (_data) {
                unlistenArrayEvents(_data, this);
                const meta = this._cachedMeta;
                clearStacks(meta);
                meta._parsed = [];
              }
              if (data && Object.isExtensible(data)) {
                listenArrayEvents(data, this);
              }
              this._syncList = [];
              this._data = data;
            }
          }
          addElements() {
            const meta = this._cachedMeta;
            this._dataCheck();
            if (this.datasetElementType) {
              meta.dataset = new this.datasetElementType();
            }
          }
          buildOrUpdateElements(resetNewElements) {
            const meta = this._cachedMeta;
            const dataset = this.getDataset();
            let stackChanged = false;
            this._dataCheck();
            const oldStacked = meta._stacked;
            meta._stacked = isStacked(meta.vScale, meta);
            if (meta.stack !== dataset.stack) {
              stackChanged = true;
              clearStacks(meta);
              meta.stack = dataset.stack;
            }
            this._resyncElements(resetNewElements);
            if (stackChanged || oldStacked !== meta._stacked) {
              updateStacks(this, meta._parsed);
            }
          }
          configure() {
            const config = this.chart.config;
            const scopeKeys = config.datasetScopeKeys(this._type);
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
            this.options = config.createResolver(scopes, this.getContext());
            this._parsing = this.options.parsing;
            this._cachedDataOpts = {};
          }
          parse(start, count) {
            const { _cachedMeta: meta, _data: data } = this;
            const { iScale, _stacked } = meta;
            const iAxis = iScale.axis;
            let sorted = start === 0 && count === data.length ? true : meta._sorted;
            let prev = start > 0 && meta._parsed[start - 1];
            let i, cur, parsed;
            if (this._parsing === false) {
              meta._parsed = data;
              meta._sorted = true;
              parsed = data;
            } else {
              if (isArray(data[start])) {
                parsed = this.parseArrayData(meta, data, start, count);
              } else if (isObject(data[start])) {
                parsed = this.parseObjectData(meta, data, start, count);
              } else {
                parsed = this.parsePrimitiveData(meta, data, start, count);
              }
              const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
              for (i = 0; i < count; ++i) {
                meta._parsed[i + start] = cur = parsed[i];
                if (sorted) {
                  if (isNotInOrderComparedToPrev()) {
                    sorted = false;
                  }
                  prev = cur;
                }
              }
              meta._sorted = sorted;
            }
            if (_stacked) {
              updateStacks(this, parsed);
            }
          }
          parsePrimitiveData(meta, data, start, count) {
            const { iScale, vScale } = meta;
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const labels = iScale.getLabels();
            const singleScale = iScale === vScale;
            const parsed = new Array(count);
            let i, ilen, index2;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index2 = i + start;
              parsed[i] = {
                [iAxis]: singleScale || iScale.parse(labels[index2], index2),
                [vAxis]: vScale.parse(data[index2], index2)
              };
            }
            return parsed;
          }
          parseArrayData(meta, data, start, count) {
            const { xScale, yScale } = meta;
            const parsed = new Array(count);
            let i, ilen, index2, item;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index2 = i + start;
              item = data[index2];
              parsed[i] = {
                x: xScale.parse(item[0], index2),
                y: yScale.parse(item[1], index2)
              };
            }
            return parsed;
          }
          parseObjectData(meta, data, start, count) {
            const { xScale, yScale } = meta;
            const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
            const parsed = new Array(count);
            let i, ilen, index2, item;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index2 = i + start;
              item = data[index2];
              parsed[i] = {
                x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
                y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
              };
            }
            return parsed;
          }
          getParsed(index2) {
            return this._cachedMeta._parsed[index2];
          }
          getDataElement(index2) {
            return this._cachedMeta.data[index2];
          }
          applyStack(scale, parsed, mode) {
            const chart = this.chart;
            const meta = this._cachedMeta;
            const value = parsed[scale.axis];
            const stack = {
              keys: getSortedDatasetIndices(chart, true),
              values: parsed._stacks[scale.axis]
            };
            return applyStack(stack, value, meta.index, { mode });
          }
          updateRangeFromParsed(range, scale, parsed, stack) {
            const parsedValue = parsed[scale.axis];
            let value = parsedValue === null ? NaN : parsedValue;
            const values = stack && parsed._stacks[scale.axis];
            if (stack && values) {
              stack.values = values;
              value = applyStack(stack, parsedValue, this._cachedMeta.index);
            }
            range.min = Math.min(range.min, value);
            range.max = Math.max(range.max, value);
          }
          getMinMax(scale, canStack) {
            const meta = this._cachedMeta;
            const _parsed = meta._parsed;
            const sorted = meta._sorted && scale === meta.iScale;
            const ilen = _parsed.length;
            const otherScale = this._getOtherScale(scale);
            const stack = createStack(canStack, meta, this.chart);
            const range = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
            const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
            let i, parsed;
            function _skip() {
              parsed = _parsed[i];
              const otherValue = parsed[otherScale.axis];
              return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
            }
            for (i = 0; i < ilen; ++i) {
              if (_skip()) {
                continue;
              }
              this.updateRangeFromParsed(range, scale, parsed, stack);
              if (sorted) {
                break;
              }
            }
            if (sorted) {
              for (i = ilen - 1; i >= 0; --i) {
                if (_skip()) {
                  continue;
                }
                this.updateRangeFromParsed(range, scale, parsed, stack);
                break;
              }
            }
            return range;
          }
          getAllParsedValues(scale) {
            const parsed = this._cachedMeta._parsed;
            const values = [];
            let i, ilen, value;
            for (i = 0, ilen = parsed.length; i < ilen; ++i) {
              value = parsed[i][scale.axis];
              if (isNumberFinite(value)) {
                values.push(value);
              }
            }
            return values;
          }
          getMaxOverflow() {
            return false;
          }
          getLabelAndValue(index2) {
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const vScale = meta.vScale;
            const parsed = this.getParsed(index2);
            return {
              label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
              value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
            };
          }
          _update(mode) {
            const meta = this._cachedMeta;
            this.update(mode || "default");
            meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
          }
          update(mode) {
          }
          draw() {
            const ctx = this._ctx;
            const chart = this.chart;
            const meta = this._cachedMeta;
            const elements2 = meta.data || [];
            const area = chart.chartArea;
            const active = [];
            const start = this._drawStart || 0;
            const count = this._drawCount || elements2.length - start;
            const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
            let i;
            if (meta.dataset) {
              meta.dataset.draw(ctx, area, start, count);
            }
            for (i = start; i < start + count; ++i) {
              const element = elements2[i];
              if (element.hidden) {
                continue;
              }
              if (element.active && drawActiveElementsOnTop) {
                active.push(element);
              } else {
                element.draw(ctx, area);
              }
            }
            for (i = 0; i < active.length; ++i) {
              active[i].draw(ctx, area);
            }
          }
          getStyle(index2, active) {
            const mode = active ? "active" : "default";
            return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
          }
          getContext(index2, active, mode) {
            const dataset = this.getDataset();
            let context;
            if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
              const element = this._cachedMeta.data[index2];
              context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
              context.parsed = this.getParsed(index2);
              context.raw = dataset.data[index2];
              context.index = context.dataIndex = index2;
            } else {
              context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
              context.dataset = dataset;
              context.index = context.datasetIndex = this.index;
            }
            context.active = !!active;
            context.mode = mode;
            return context;
          }
          resolveDatasetElementOptions(mode) {
            return this._resolveElementOptions(this.datasetElementType.id, mode);
          }
          resolveDataElementOptions(index2, mode) {
            return this._resolveElementOptions(this.dataElementType.id, mode, index2);
          }
          _resolveElementOptions(elementType, mode = "default", index2) {
            const active = mode === "active";
            const cache = this._cachedDataOpts;
            const cacheKey = elementType + "-" + mode;
            const cached = cache[cacheKey];
            const sharing = this.enableOptionSharing && defined(index2);
            if (cached) {
              return cloneIfNotShared(cached, sharing);
            }
            const config = this.chart.config;
            const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
            const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            const names2 = Object.keys(defaults.elements[elementType]);
            const context = () => this.getContext(index2, active);
            const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
            if (values.$shared) {
              values.$shared = sharing;
              cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
            }
            return values;
          }
          _resolveAnimations(index2, transition, active) {
            const chart = this.chart;
            const cache = this._cachedDataOpts;
            const cacheKey = `animation-${transition}`;
            const cached = cache[cacheKey];
            if (cached) {
              return cached;
            }
            let options;
            if (chart.options.animation !== false) {
              const config = this.chart.config;
              const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
              const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
              options = config.createResolver(scopes, this.getContext(index2, active, transition));
            }
            const animations = new Animations(chart, options && options.animations);
            if (options && options._cacheable) {
              cache[cacheKey] = Object.freeze(animations);
            }
            return animations;
          }
          getSharedOptions(options) {
            if (!options.$shared) {
              return;
            }
            return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
          }
          includeOptions(mode, sharedOptions) {
            return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
          }
          _getSharedOptions(start, mode) {
            const firstOpts = this.resolveDataElementOptions(start, mode);
            const previouslySharedOptions = this._sharedOptions;
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
            return { sharedOptions, includeOptions };
          }
          updateElement(element, index2, properties, mode) {
            if (isDirectUpdateMode(mode)) {
              Object.assign(element, properties);
            } else {
              this._resolveAnimations(index2, mode).update(element, properties);
            }
          }
          updateSharedOptions(sharedOptions, mode, newOptions) {
            if (sharedOptions && !isDirectUpdateMode(mode)) {
              this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
            }
          }
          _setStyle(element, index2, mode, active) {
            element.active = active;
            const options = this.getStyle(index2, active);
            this._resolveAnimations(index2, mode, active).update(element, {
              options: !active && this.getSharedOptions(options) || options
            });
          }
          removeHoverStyle(element, datasetIndex, index2) {
            this._setStyle(element, index2, "active", false);
          }
          setHoverStyle(element, datasetIndex, index2) {
            this._setStyle(element, index2, "active", true);
          }
          _removeDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            if (element) {
              this._setStyle(element, void 0, "active", false);
            }
          }
          _setDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            if (element) {
              this._setStyle(element, void 0, "active", true);
            }
          }
          _resyncElements(resetNewElements) {
            const data = this._data;
            const elements2 = this._cachedMeta.data;
            for (const [method, arg1, arg2] of this._syncList) {
              this[method](arg1, arg2);
            }
            this._syncList = [];
            const numMeta = elements2.length;
            const numData = data.length;
            const count = Math.min(numData, numMeta);
            if (count) {
              this.parse(0, count);
            }
            if (numData > numMeta) {
              this._insertElements(numMeta, numData - numMeta, resetNewElements);
            } else if (numData < numMeta) {
              this._removeElements(numData, numMeta - numData);
            }
          }
          _insertElements(start, count, resetNewElements = true) {
            const meta = this._cachedMeta;
            const data = meta.data;
            const end = start + count;
            let i;
            const move = (arr) => {
              arr.length += count;
              for (i = arr.length - 1; i >= end; i--) {
                arr[i] = arr[i - count];
              }
            };
            move(data);
            for (i = start; i < end; ++i) {
              data[i] = new this.dataElementType();
            }
            if (this._parsing) {
              move(meta._parsed);
            }
            this.parse(start, count);
            if (resetNewElements) {
              this.updateElements(data, start, count, "reset");
            }
          }
          updateElements(element, start, count, mode) {
          }
          _removeElements(start, count) {
            const meta = this._cachedMeta;
            if (this._parsing) {
              const removed = meta._parsed.splice(start, count);
              if (meta._stacked) {
                clearStacks(meta, removed);
              }
            }
            meta.data.splice(start, count);
          }
          _sync(args) {
            if (this._parsing) {
              this._syncList.push(args);
            } else {
              const [method, arg1, arg2] = args;
              this[method](arg1, arg2);
            }
            this.chart._dataChanges.push([this.index, ...args]);
          }
          _onDataPush() {
            const count = arguments.length;
            this._sync(["_insertElements", this.getDataset().data.length - count, count]);
          }
          _onDataPop() {
            this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
          }
          _onDataShift() {
            this._sync(["_removeElements", 0, 1]);
          }
          _onDataSplice(start, count) {
            if (count) {
              this._sync(["_removeElements", start, count]);
            }
            const newCount = arguments.length - 2;
            if (newCount) {
              this._sync(["_insertElements", start, newCount]);
            }
          }
          _onDataUnshift() {
            this._sync(["_insertElements", 0, arguments.length]);
          }
        }
        DatasetController.defaults = {};
        DatasetController.prototype.datasetElementType = null;
        DatasetController.prototype.dataElementType = null;
        class Element2 {
          constructor() {
            this.x = void 0;
            this.y = void 0;
            this.active = false;
            this.options = void 0;
            this.$animations = void 0;
          }
          tooltipPosition(useFinalPosition) {
            const { x, y: y2 } = this.getProps(["x", "y"], useFinalPosition);
            return { x, y: y2 };
          }
          hasValue() {
            return isNumber(this.x) && isNumber(this.y);
          }
          getProps(props, final) {
            const anims = this.$animations;
            if (!final || !anims) {
              return this;
            }
            const ret = {};
            props.forEach((prop) => {
              ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
            });
            return ret;
          }
        }
        Element2.defaults = {};
        Element2.defaultRoutes = void 0;
        const formatters = {
          values(value) {
            return isArray(value) ? value : "" + value;
          },
          numeric(tickValue, index2, ticks) {
            if (tickValue === 0) {
              return "0";
            }
            const locale = this.chart.options.locale;
            let notation;
            let delta = tickValue;
            if (ticks.length > 1) {
              const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
              if (maxTick < 1e-4 || maxTick > 1e15) {
                notation = "scientific";
              }
              delta = calculateDelta(tickValue, ticks);
            }
            const logDelta = log10(Math.abs(delta));
            const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
            const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
            Object.assign(options, this.options.ticks.format);
            return formatNumber(tickValue, locale, options);
          },
          logarithmic(tickValue, index2, ticks) {
            if (tickValue === 0) {
              return "0";
            }
            const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
            if (remain === 1 || remain === 2 || remain === 5) {
              return formatters.numeric.call(this, tickValue, index2, ticks);
            }
            return "";
          }
        };
        function calculateDelta(tickValue, ticks) {
          let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
          if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
            delta = tickValue - Math.floor(tickValue);
          }
          return delta;
        }
        var Ticks = { formatters };
        defaults.set("scale", {
          display: true,
          offset: false,
          reverse: false,
          beginAtZero: false,
          bounds: "ticks",
          grace: 0,
          grid: {
            display: true,
            lineWidth: 1,
            drawBorder: true,
            drawOnChartArea: true,
            drawTicks: true,
            tickLength: 8,
            tickWidth: (_ctx, options) => options.lineWidth,
            tickColor: (_ctx, options) => options.color,
            offset: false,
            borderDash: [],
            borderDashOffset: 0,
            borderWidth: 1
          },
          title: {
            display: false,
            text: "",
            padding: {
              top: 4,
              bottom: 4
            }
          },
          ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: true,
            autoSkip: true,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: Ticks.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: false,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2
          }
        });
        defaults.route("scale.ticks", "color", "", "color");
        defaults.route("scale.grid", "color", "", "borderColor");
        defaults.route("scale.grid", "borderColor", "", "borderColor");
        defaults.route("scale.title", "color", "", "color");
        defaults.describe("scale", {
          _fallback: false,
          _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
          _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash"
        });
        defaults.describe("scales", {
          _fallback: "scale"
        });
        defaults.describe("scale.ticks", {
          _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
          _indexable: (name) => name !== "backdropPadding"
        });
        function autoSkip(scale, ticks) {
          const tickOpts = scale.options.ticks;
          const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
          const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
          const numMajorIndices = majorIndices.length;
          const first = majorIndices[0];
          const last = majorIndices[numMajorIndices - 1];
          const newTicks = [];
          if (numMajorIndices > ticksLimit) {
            skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
            return newTicks;
          }
          const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
          if (numMajorIndices > 0) {
            let i, ilen;
            const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
            skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
            for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
              skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
            }
            skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
            return newTicks;
          }
          skip(ticks, newTicks, spacing);
          return newTicks;
        }
        function determineMaxTicks(scale) {
          const offset = scale.options.offset;
          const tickLength = scale._tickSize();
          const maxScale = scale._length / tickLength + (offset ? 0 : 1);
          const maxChart = scale._maxLength / tickLength;
          return Math.floor(Math.min(maxScale, maxChart));
        }
        function calculateSpacing(majorIndices, ticks, ticksLimit) {
          const evenMajorSpacing = getEvenSpacing(majorIndices);
          const spacing = ticks.length / ticksLimit;
          if (!evenMajorSpacing) {
            return Math.max(spacing, 1);
          }
          const factors = _factorize(evenMajorSpacing);
          for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
            const factor = factors[i];
            if (factor > spacing) {
              return factor;
            }
          }
          return Math.max(spacing, 1);
        }
        function getMajorIndices(ticks) {
          const result = [];
          let i, ilen;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            if (ticks[i].major) {
              result.push(i);
            }
          }
          return result;
        }
        function skipMajors(ticks, newTicks, majorIndices, spacing) {
          let count = 0;
          let next = majorIndices[0];
          let i;
          spacing = Math.ceil(spacing);
          for (i = 0; i < ticks.length; i++) {
            if (i === next) {
              newTicks.push(ticks[i]);
              count++;
              next = majorIndices[count * spacing];
            }
          }
        }
        function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
          const start = valueOrDefault(majorStart, 0);
          const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
          let count = 0;
          let length, i, next;
          spacing = Math.ceil(spacing);
          if (majorEnd) {
            length = majorEnd - majorStart;
            spacing = length / Math.floor(length / spacing);
          }
          next = start;
          while (next < 0) {
            count++;
            next = Math.round(start + count * spacing);
          }
          for (i = Math.max(start, 0); i < end; i++) {
            if (i === next) {
              newTicks.push(ticks[i]);
              count++;
              next = Math.round(start + count * spacing);
            }
          }
        }
        function getEvenSpacing(arr) {
          const len = arr.length;
          let i, diff;
          if (len < 2) {
            return false;
          }
          for (diff = arr[0], i = 1; i < len; ++i) {
            if (arr[i] - arr[i - 1] !== diff) {
              return false;
            }
          }
          return diff;
        }
        const reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
        const offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
        function sample(arr, numItems) {
          const result = [];
          const increment = arr.length / numItems;
          const len = arr.length;
          let i = 0;
          for (; i < len; i += increment) {
            result.push(arr[Math.floor(i)]);
          }
          return result;
        }
        function getPixelForGridLine(scale, index2, offsetGridLines) {
          const length = scale.ticks.length;
          const validIndex2 = Math.min(index2, length - 1);
          const start = scale._startPixel;
          const end = scale._endPixel;
          const epsilon = 1e-6;
          let lineValue = scale.getPixelForTick(validIndex2);
          let offset;
          if (offsetGridLines) {
            if (length === 1) {
              offset = Math.max(lineValue - start, end - lineValue);
            } else if (index2 === 0) {
              offset = (scale.getPixelForTick(1) - lineValue) / 2;
            } else {
              offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
            }
            lineValue += validIndex2 < index2 ? offset : -offset;
            if (lineValue < start - epsilon || lineValue > end + epsilon) {
              return;
            }
          }
          return lineValue;
        }
        function garbageCollect(caches, length) {
          each(caches, (cache) => {
            const gc2 = cache.gc;
            const gcLen = gc2.length / 2;
            let i;
            if (gcLen > length) {
              for (i = 0; i < gcLen; ++i) {
                delete cache.data[gc2[i]];
              }
              gc2.splice(0, gcLen);
            }
          });
        }
        function getTickMarkLength(options) {
          return options.drawTicks ? options.tickLength : 0;
        }
        function getTitleHeight(options, fallback) {
          if (!options.display) {
            return 0;
          }
          const font = toFont(options.font, fallback);
          const padding = toPadding(options.padding);
          const lines = isArray(options.text) ? options.text.length : 1;
          return lines * font.lineHeight + padding.height;
        }
        function createScaleContext(parent, scale) {
          return createContext(parent, {
            scale,
            type: "scale"
          });
        }
        function createTickContext(parent, index2, tick) {
          return createContext(parent, {
            tick,
            index: index2,
            type: "tick"
          });
        }
        function titleAlign(align, position, reverse) {
          let ret = _toLeftRightCenter(align);
          if (reverse && position !== "right" || !reverse && position === "right") {
            ret = reverseAlign(ret);
          }
          return ret;
        }
        function titleArgs(scale, offset, position, align) {
          const { top, left, bottom, right, chart } = scale;
          const { chartArea, scales: scales2 } = chart;
          let rotation = 0;
          let maxWidth, titleX, titleY;
          const height = bottom - top;
          const width = right - left;
          if (scale.isHorizontal()) {
            titleX = _alignStartEnd(align, left, right);
            if (isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
            } else if (position === "center") {
              titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
            } else {
              titleY = offsetFromEdge(scale, position, offset);
            }
            maxWidth = right - left;
          } else {
            if (isObject(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
            } else if (position === "center") {
              titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
            } else {
              titleX = offsetFromEdge(scale, position, offset);
            }
            titleY = _alignStartEnd(align, bottom, top);
            rotation = position === "left" ? -HALF_PI : HALF_PI;
          }
          return { titleX, titleY, maxWidth, rotation };
        }
        class Scale extends Element2 {
          constructor(cfg) {
            super();
            this.id = cfg.id;
            this.type = cfg.type;
            this.options = void 0;
            this.ctx = cfg.ctx;
            this.chart = cfg.chart;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.width = void 0;
            this.height = void 0;
            this._margins = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            };
            this.maxWidth = void 0;
            this.maxHeight = void 0;
            this.paddingTop = void 0;
            this.paddingBottom = void 0;
            this.paddingLeft = void 0;
            this.paddingRight = void 0;
            this.axis = void 0;
            this.labelRotation = void 0;
            this.min = void 0;
            this.max = void 0;
            this._range = void 0;
            this.ticks = [];
            this._gridLineItems = null;
            this._labelItems = null;
            this._labelSizes = null;
            this._length = 0;
            this._maxLength = 0;
            this._longestTextCache = {};
            this._startPixel = void 0;
            this._endPixel = void 0;
            this._reversePixels = false;
            this._userMax = void 0;
            this._userMin = void 0;
            this._suggestedMax = void 0;
            this._suggestedMin = void 0;
            this._ticksLength = 0;
            this._borderValue = 0;
            this._cache = {};
            this._dataLimitsCached = false;
            this.$context = void 0;
          }
          init(options) {
            this.options = options.setContext(this.getContext());
            this.axis = options.axis;
            this._userMin = this.parse(options.min);
            this._userMax = this.parse(options.max);
            this._suggestedMin = this.parse(options.suggestedMin);
            this._suggestedMax = this.parse(options.suggestedMax);
          }
          parse(raw, index2) {
            return raw;
          }
          getUserBounds() {
            let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
            _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
            _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
            _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
            _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
            return {
              min: finiteOrDefault(_userMin, _suggestedMin),
              max: finiteOrDefault(_userMax, _suggestedMax),
              minDefined: isNumberFinite(_userMin),
              maxDefined: isNumberFinite(_userMax)
            };
          }
          getMinMax(canStack) {
            let { min, max, minDefined, maxDefined } = this.getUserBounds();
            let range;
            if (minDefined && maxDefined) {
              return { min, max };
            }
            const metas = this.getMatchingVisibleMetas();
            for (let i = 0, ilen = metas.length; i < ilen; ++i) {
              range = metas[i].controller.getMinMax(this, canStack);
              if (!minDefined) {
                min = Math.min(min, range.min);
              }
              if (!maxDefined) {
                max = Math.max(max, range.max);
              }
            }
            min = maxDefined && min > max ? max : min;
            max = minDefined && min > max ? min : max;
            return {
              min: finiteOrDefault(min, finiteOrDefault(max, min)),
              max: finiteOrDefault(max, finiteOrDefault(min, max))
            };
          }
          getPadding() {
            return {
              left: this.paddingLeft || 0,
              top: this.paddingTop || 0,
              right: this.paddingRight || 0,
              bottom: this.paddingBottom || 0
            };
          }
          getTicks() {
            return this.ticks;
          }
          getLabels() {
            const data = this.chart.data;
            return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
          }
          beforeLayout() {
            this._cache = {};
            this._dataLimitsCached = false;
          }
          beforeUpdate() {
            callback(this.options.beforeUpdate, [this]);
          }
          update(maxWidth, maxHeight, margins) {
            const { beginAtZero, grace, ticks: tickOpts } = this.options;
            const sampleSize = tickOpts.sampleSize;
            this.beforeUpdate();
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this._margins = margins = Object.assign({
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }, margins);
            this.ticks = null;
            this._labelSizes = null;
            this._gridLineItems = null;
            this._labelItems = null;
            this.beforeSetDimensions();
            this.setDimensions();
            this.afterSetDimensions();
            this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
            if (!this._dataLimitsCached) {
              this.beforeDataLimits();
              this.determineDataLimits();
              this.afterDataLimits();
              this._range = _addGrace(this, grace, beginAtZero);
              this._dataLimitsCached = true;
            }
            this.beforeBuildTicks();
            this.ticks = this.buildTicks() || [];
            this.afterBuildTicks();
            const samplingEnabled = sampleSize < this.ticks.length;
            this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
            this.configure();
            this.beforeCalculateLabelRotation();
            this.calculateLabelRotation();
            this.afterCalculateLabelRotation();
            if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
              this.ticks = autoSkip(this, this.ticks);
              this._labelSizes = null;
              this.afterAutoSkip();
            }
            if (samplingEnabled) {
              this._convertTicksToLabels(this.ticks);
            }
            this.beforeFit();
            this.fit();
            this.afterFit();
            this.afterUpdate();
          }
          configure() {
            let reversePixels = this.options.reverse;
            let startPixel, endPixel;
            if (this.isHorizontal()) {
              startPixel = this.left;
              endPixel = this.right;
            } else {
              startPixel = this.top;
              endPixel = this.bottom;
              reversePixels = !reversePixels;
            }
            this._startPixel = startPixel;
            this._endPixel = endPixel;
            this._reversePixels = reversePixels;
            this._length = endPixel - startPixel;
            this._alignToPixels = this.options.alignToPixels;
          }
          afterUpdate() {
            callback(this.options.afterUpdate, [this]);
          }
          beforeSetDimensions() {
            callback(this.options.beforeSetDimensions, [this]);
          }
          setDimensions() {
            if (this.isHorizontal()) {
              this.width = this.maxWidth;
              this.left = 0;
              this.right = this.width;
            } else {
              this.height = this.maxHeight;
              this.top = 0;
              this.bottom = this.height;
            }
            this.paddingLeft = 0;
            this.paddingTop = 0;
            this.paddingRight = 0;
            this.paddingBottom = 0;
          }
          afterSetDimensions() {
            callback(this.options.afterSetDimensions, [this]);
          }
          _callHooks(name) {
            this.chart.notifyPlugins(name, this.getContext());
            callback(this.options[name], [this]);
          }
          beforeDataLimits() {
            this._callHooks("beforeDataLimits");
          }
          determineDataLimits() {
          }
          afterDataLimits() {
            this._callHooks("afterDataLimits");
          }
          beforeBuildTicks() {
            this._callHooks("beforeBuildTicks");
          }
          buildTicks() {
            return [];
          }
          afterBuildTicks() {
            this._callHooks("afterBuildTicks");
          }
          beforeTickToLabelConversion() {
            callback(this.options.beforeTickToLabelConversion, [this]);
          }
          generateTickLabels(ticks) {
            const tickOpts = this.options.ticks;
            let i, ilen, tick;
            for (i = 0, ilen = ticks.length; i < ilen; i++) {
              tick = ticks[i];
              tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);
            }
          }
          afterTickToLabelConversion() {
            callback(this.options.afterTickToLabelConversion, [this]);
          }
          beforeCalculateLabelRotation() {
            callback(this.options.beforeCalculateLabelRotation, [this]);
          }
          calculateLabelRotation() {
            const options = this.options;
            const tickOpts = options.ticks;
            const numTicks = this.ticks.length;
            const minRotation = tickOpts.minRotation || 0;
            const maxRotation = tickOpts.maxRotation;
            let labelRotation = minRotation;
            let tickWidth, maxHeight, maxLabelDiagonal;
            if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
              this.labelRotation = minRotation;
              return;
            }
            const labelSizes = this._getLabelSizes();
            const maxLabelWidth = labelSizes.widest.width;
            const maxLabelHeight = labelSizes.highest.height;
            const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
            tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
            if (maxLabelWidth + 6 > tickWidth) {
              tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
              maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
              maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
              labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
              labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
            }
            this.labelRotation = labelRotation;
          }
          afterCalculateLabelRotation() {
            callback(this.options.afterCalculateLabelRotation, [this]);
          }
          afterAutoSkip() {
          }
          beforeFit() {
            callback(this.options.beforeFit, [this]);
          }
          fit() {
            const minSize = {
              width: 0,
              height: 0
            };
            const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
            const display = this._isVisible();
            const isHorizontal = this.isHorizontal();
            if (display) {
              const titleHeight = getTitleHeight(titleOpts, chart.options.font);
              if (isHorizontal) {
                minSize.width = this.maxWidth;
                minSize.height = getTickMarkLength(gridOpts) + titleHeight;
              } else {
                minSize.height = this.maxHeight;
                minSize.width = getTickMarkLength(gridOpts) + titleHeight;
              }
              if (tickOpts.display && this.ticks.length) {
                const { first, last, widest, highest } = this._getLabelSizes();
                const tickPadding = tickOpts.padding * 2;
                const angleRadians = toRadians(this.labelRotation);
                const cos = Math.cos(angleRadians);
                const sin = Math.sin(angleRadians);
                if (isHorizontal) {
                  const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                  minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
                } else {
                  const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                  minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
                }
                this._calculatePadding(first, last, sin, cos);
              }
            }
            this._handleMargins();
            if (isHorizontal) {
              this.width = this._length = chart.width - this._margins.left - this._margins.right;
              this.height = minSize.height;
            } else {
              this.width = minSize.width;
              this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
            }
          }
          _calculatePadding(first, last, sin, cos) {
            const { ticks: { align, padding }, position } = this.options;
            const isRotated = this.labelRotation !== 0;
            const labelsBelowTicks = position !== "top" && this.axis === "x";
            if (this.isHorizontal()) {
              const offsetLeft = this.getPixelForTick(0) - this.left;
              const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
              let paddingLeft = 0;
              let paddingRight = 0;
              if (isRotated) {
                if (labelsBelowTicks) {
                  paddingLeft = cos * first.width;
                  paddingRight = sin * last.height;
                } else {
                  paddingLeft = sin * first.height;
                  paddingRight = cos * last.width;
                }
              } else if (align === "start") {
                paddingRight = last.width;
              } else if (align === "end") {
                paddingLeft = first.width;
              } else if (align !== "inner") {
                paddingLeft = first.width / 2;
                paddingRight = last.width / 2;
              }
              this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
              this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
            } else {
              let paddingTop = last.height / 2;
              let paddingBottom = first.height / 2;
              if (align === "start") {
                paddingTop = 0;
                paddingBottom = first.height;
              } else if (align === "end") {
                paddingTop = last.height;
                paddingBottom = 0;
              }
              this.paddingTop = paddingTop + padding;
              this.paddingBottom = paddingBottom + padding;
            }
          }
          _handleMargins() {
            if (this._margins) {
              this._margins.left = Math.max(this.paddingLeft, this._margins.left);
              this._margins.top = Math.max(this.paddingTop, this._margins.top);
              this._margins.right = Math.max(this.paddingRight, this._margins.right);
              this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
            }
          }
          afterFit() {
            callback(this.options.afterFit, [this]);
          }
          isHorizontal() {
            const { axis, position } = this.options;
            return position === "top" || position === "bottom" || axis === "x";
          }
          isFullSize() {
            return this.options.fullSize;
          }
          _convertTicksToLabels(ticks) {
            this.beforeTickToLabelConversion();
            this.generateTickLabels(ticks);
            let i, ilen;
            for (i = 0, ilen = ticks.length; i < ilen; i++) {
              if (isNullOrUndef(ticks[i].label)) {
                ticks.splice(i, 1);
                ilen--;
                i--;
              }
            }
            this.afterTickToLabelConversion();
          }
          _getLabelSizes() {
            let labelSizes = this._labelSizes;
            if (!labelSizes) {
              const sampleSize = this.options.ticks.sampleSize;
              let ticks = this.ticks;
              if (sampleSize < ticks.length) {
                ticks = sample(ticks, sampleSize);
              }
              this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
            }
            return labelSizes;
          }
          _computeLabelSizes(ticks, length) {
            const { ctx, _longestTextCache: caches } = this;
            const widths = [];
            const heights = [];
            let widestLabelSize = 0;
            let highestLabelSize = 0;
            let i, j2, jlen, label, tickFont, fontString2, cache, lineHeight, width, height, nestedLabel;
            for (i = 0; i < length; ++i) {
              label = ticks[i].label;
              tickFont = this._resolveTickFontOptions(i);
              ctx.font = fontString2 = tickFont.string;
              cache = caches[fontString2] = caches[fontString2] || { data: {}, gc: [] };
              lineHeight = tickFont.lineHeight;
              width = height = 0;
              if (!isNullOrUndef(label) && !isArray(label)) {
                width = _measureText(ctx, cache.data, cache.gc, width, label);
                height = lineHeight;
              } else if (isArray(label)) {
                for (j2 = 0, jlen = label.length; j2 < jlen; ++j2) {
                  nestedLabel = label[j2];
                  if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                    width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                    height += lineHeight;
                  }
                }
              }
              widths.push(width);
              heights.push(height);
              widestLabelSize = Math.max(width, widestLabelSize);
              highestLabelSize = Math.max(height, highestLabelSize);
            }
            garbageCollect(caches, length);
            const widest = widths.indexOf(widestLabelSize);
            const highest = heights.indexOf(highestLabelSize);
            const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
            return {
              first: valueAt(0),
              last: valueAt(length - 1),
              widest: valueAt(widest),
              highest: valueAt(highest),
              widths,
              heights
            };
          }
          getLabelForValue(value) {
            return value;
          }
          getPixelForValue(value, index2) {
            return NaN;
          }
          getValueForPixel(pixel) {
          }
          getPixelForTick(index2) {
            const ticks = this.ticks;
            if (index2 < 0 || index2 > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index2].value);
          }
          getPixelForDecimal(decimal) {
            if (this._reversePixels) {
              decimal = 1 - decimal;
            }
            const pixel = this._startPixel + decimal * this._length;
            return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
          }
          getDecimalForPixel(pixel) {
            const decimal = (pixel - this._startPixel) / this._length;
            return this._reversePixels ? 1 - decimal : decimal;
          }
          getBasePixel() {
            return this.getPixelForValue(this.getBaseValue());
          }
          getBaseValue() {
            const { min, max } = this;
            return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
          }
          getContext(index2) {
            const ticks = this.ticks || [];
            if (index2 >= 0 && index2 < ticks.length) {
              const tick = ticks[index2];
              return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
            }
            return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
          }
          _tickSize() {
            const optionTicks = this.options.ticks;
            const rot = toRadians(this.labelRotation);
            const cos = Math.abs(Math.cos(rot));
            const sin = Math.abs(Math.sin(rot));
            const labelSizes = this._getLabelSizes();
            const padding = optionTicks.autoSkipPadding || 0;
            const w = labelSizes ? labelSizes.widest.width + padding : 0;
            const h3 = labelSizes ? labelSizes.highest.height + padding : 0;
            return this.isHorizontal() ? h3 * cos > w * sin ? w / cos : h3 / sin : h3 * sin < w * cos ? h3 / cos : w / sin;
          }
          _isVisible() {
            const display = this.options.display;
            if (display !== "auto") {
              return !!display;
            }
            return this.getMatchingVisibleMetas().length > 0;
          }
          _computeGridLineItems(chartArea) {
            const axis = this.axis;
            const chart = this.chart;
            const options = this.options;
            const { grid, position } = options;
            const offset = grid.offset;
            const isHorizontal = this.isHorizontal();
            const ticks = this.ticks;
            const ticksLength = ticks.length + (offset ? 1 : 0);
            const tl2 = getTickMarkLength(grid);
            const items = [];
            const borderOpts = grid.setContext(this.getContext());
            const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
            const axisHalfWidth = axisWidth / 2;
            const alignBorderValue = function(pixel) {
              return _alignPixel(chart, pixel, axisWidth);
            };
            let borderValue, i, lineValue, alignedLineValue;
            let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
            if (position === "top") {
              borderValue = alignBorderValue(this.bottom);
              ty1 = this.bottom - tl2;
              ty2 = borderValue - axisHalfWidth;
              y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
              y2 = chartArea.bottom;
            } else if (position === "bottom") {
              borderValue = alignBorderValue(this.top);
              y1 = chartArea.top;
              y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
              ty1 = borderValue + axisHalfWidth;
              ty2 = this.top + tl2;
            } else if (position === "left") {
              borderValue = alignBorderValue(this.right);
              tx1 = this.right - tl2;
              tx2 = borderValue - axisHalfWidth;
              x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
              x2 = chartArea.right;
            } else if (position === "right") {
              borderValue = alignBorderValue(this.left);
              x1 = chartArea.left;
              x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
              tx1 = borderValue + axisHalfWidth;
              tx2 = this.left + tl2;
            } else if (axis === "x") {
              if (position === "center") {
                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
              } else if (isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
              }
              y1 = chartArea.top;
              y2 = chartArea.bottom;
              ty1 = borderValue + axisHalfWidth;
              ty2 = ty1 + tl2;
            } else if (axis === "y") {
              if (position === "center") {
                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
              } else if (isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
              }
              tx1 = borderValue - axisHalfWidth;
              tx2 = tx1 - tl2;
              x1 = chartArea.left;
              x2 = chartArea.right;
            }
            const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
            const step = Math.max(1, Math.ceil(ticksLength / limit));
            for (i = 0; i < ticksLength; i += step) {
              const optsAtIndex = grid.setContext(this.getContext(i));
              const lineWidth = optsAtIndex.lineWidth;
              const lineColor = optsAtIndex.color;
              const borderDash = optsAtIndex.borderDash || [];
              const borderDashOffset = optsAtIndex.borderDashOffset;
              const tickWidth = optsAtIndex.tickWidth;
              const tickColor = optsAtIndex.tickColor;
              const tickBorderDash = optsAtIndex.tickBorderDash || [];
              const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
              lineValue = getPixelForGridLine(this, i, offset);
              if (lineValue === void 0) {
                continue;
              }
              alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
              if (isHorizontal) {
                tx1 = tx2 = x1 = x2 = alignedLineValue;
              } else {
                ty1 = ty2 = y1 = y2 = alignedLineValue;
              }
              items.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset,
                tickWidth,
                tickColor,
                tickBorderDash,
                tickBorderDashOffset
              });
            }
            this._ticksLength = ticksLength;
            this._borderValue = borderValue;
            return items;
          }
          _computeLabelItems(chartArea) {
            const axis = this.axis;
            const options = this.options;
            const { position, ticks: optionTicks } = options;
            const isHorizontal = this.isHorizontal();
            const ticks = this.ticks;
            const { align, crossAlign, padding, mirror } = optionTicks;
            const tl2 = getTickMarkLength(options.grid);
            const tickAndPadding = tl2 + padding;
            const hTickAndPadding = mirror ? -padding : tickAndPadding;
            const rotation = -toRadians(this.labelRotation);
            const items = [];
            let i, ilen, tick, label, x, y2, textAlign, pixel, font, lineHeight, lineCount, textOffset;
            let textBaseline = "middle";
            if (position === "top") {
              y2 = this.bottom - hTickAndPadding;
              textAlign = this._getXAxisLabelAlignment();
            } else if (position === "bottom") {
              y2 = this.top + hTickAndPadding;
              textAlign = this._getXAxisLabelAlignment();
            } else if (position === "left") {
              const ret = this._getYAxisLabelAlignment(tl2);
              textAlign = ret.textAlign;
              x = ret.x;
            } else if (position === "right") {
              const ret = this._getYAxisLabelAlignment(tl2);
              textAlign = ret.textAlign;
              x = ret.x;
            } else if (axis === "x") {
              if (position === "center") {
                y2 = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
              } else if (isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                y2 = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
              }
              textAlign = this._getXAxisLabelAlignment();
            } else if (axis === "y") {
              if (position === "center") {
                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
              } else if (isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                x = this.chart.scales[positionAxisID].getPixelForValue(value);
              }
              textAlign = this._getYAxisLabelAlignment(tl2).textAlign;
            }
            if (axis === "y") {
              if (align === "start") {
                textBaseline = "top";
              } else if (align === "end") {
                textBaseline = "bottom";
              }
            }
            const labelSizes = this._getLabelSizes();
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              tick = ticks[i];
              label = tick.label;
              const optsAtIndex = optionTicks.setContext(this.getContext(i));
              pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
              font = this._resolveTickFontOptions(i);
              lineHeight = font.lineHeight;
              lineCount = isArray(label) ? label.length : 1;
              const halfCount = lineCount / 2;
              const color2 = optsAtIndex.color;
              const strokeColor = optsAtIndex.textStrokeColor;
              const strokeWidth = optsAtIndex.textStrokeWidth;
              let tickTextAlign = textAlign;
              if (isHorizontal) {
                x = pixel;
                if (textAlign === "inner") {
                  if (i === ilen - 1) {
                    tickTextAlign = !this.options.reverse ? "right" : "left";
                  } else if (i === 0) {
                    tickTextAlign = !this.options.reverse ? "left" : "right";
                  } else {
                    tickTextAlign = "center";
                  }
                }
                if (position === "top") {
                  if (crossAlign === "near" || rotation !== 0) {
                    textOffset = -lineCount * lineHeight + lineHeight / 2;
                  } else if (crossAlign === "center") {
                    textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                  } else {
                    textOffset = -labelSizes.highest.height + lineHeight / 2;
                  }
                } else {
                  if (crossAlign === "near" || rotation !== 0) {
                    textOffset = lineHeight / 2;
                  } else if (crossAlign === "center") {
                    textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                  } else {
                    textOffset = labelSizes.highest.height - lineCount * lineHeight;
                  }
                }
                if (mirror) {
                  textOffset *= -1;
                }
              } else {
                y2 = pixel;
                textOffset = (1 - lineCount) * lineHeight / 2;
              }
              let backdrop;
              if (optsAtIndex.showLabelBackdrop) {
                const labelPadding = toPadding(optsAtIndex.backdropPadding);
                const height = labelSizes.heights[i];
                const width = labelSizes.widths[i];
                let top = y2 + textOffset - labelPadding.top;
                let left = x - labelPadding.left;
                switch (textBaseline) {
                  case "middle":
                    top -= height / 2;
                    break;
                  case "bottom":
                    top -= height;
                    break;
                }
                switch (textAlign) {
                  case "center":
                    left -= width / 2;
                    break;
                  case "right":
                    left -= width;
                    break;
                }
                backdrop = {
                  left,
                  top,
                  width: width + labelPadding.width,
                  height: height + labelPadding.height,
                  color: optsAtIndex.backdropColor
                };
              }
              items.push({
                rotation,
                label,
                font,
                color: color2,
                strokeColor,
                strokeWidth,
                textOffset,
                textAlign: tickTextAlign,
                textBaseline,
                translation: [x, y2],
                backdrop
              });
            }
            return items;
          }
          _getXAxisLabelAlignment() {
            const { position, ticks } = this.options;
            const rotation = -toRadians(this.labelRotation);
            if (rotation) {
              return position === "top" ? "left" : "right";
            }
            let align = "center";
            if (ticks.align === "start") {
              align = "left";
            } else if (ticks.align === "end") {
              align = "right";
            } else if (ticks.align === "inner") {
              align = "inner";
            }
            return align;
          }
          _getYAxisLabelAlignment(tl2) {
            const { position, ticks: { crossAlign, mirror, padding } } = this.options;
            const labelSizes = this._getLabelSizes();
            const tickAndPadding = tl2 + padding;
            const widest = labelSizes.widest.width;
            let textAlign;
            let x;
            if (position === "left") {
              if (mirror) {
                x = this.right + padding;
                if (crossAlign === "near") {
                  textAlign = "left";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x += widest / 2;
                } else {
                  textAlign = "right";
                  x += widest;
                }
              } else {
                x = this.right - tickAndPadding;
                if (crossAlign === "near") {
                  textAlign = "right";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x -= widest / 2;
                } else {
                  textAlign = "left";
                  x = this.left;
                }
              }
            } else if (position === "right") {
              if (mirror) {
                x = this.left + padding;
                if (crossAlign === "near") {
                  textAlign = "right";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x -= widest / 2;
                } else {
                  textAlign = "left";
                  x -= widest;
                }
              } else {
                x = this.left + tickAndPadding;
                if (crossAlign === "near") {
                  textAlign = "left";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x += widest / 2;
                } else {
                  textAlign = "right";
                  x = this.right;
                }
              }
            } else {
              textAlign = "right";
            }
            return { textAlign, x };
          }
          _computeLabelArea() {
            if (this.options.ticks.mirror) {
              return;
            }
            const chart = this.chart;
            const position = this.options.position;
            if (position === "left" || position === "right") {
              return { top: 0, left: this.left, bottom: chart.height, right: this.right };
            }
            if (position === "top" || position === "bottom") {
              return { top: this.top, left: 0, bottom: this.bottom, right: chart.width };
            }
          }
          drawBackground() {
            const { ctx, options: { backgroundColor }, left, top, width, height } = this;
            if (backgroundColor) {
              ctx.save();
              ctx.fillStyle = backgroundColor;
              ctx.fillRect(left, top, width, height);
              ctx.restore();
            }
          }
          getLineWidthForValue(value) {
            const grid = this.options.grid;
            if (!this._isVisible() || !grid.display) {
              return 0;
            }
            const ticks = this.ticks;
            const index2 = ticks.findIndex((t) => t.value === value);
            if (index2 >= 0) {
              const opts = grid.setContext(this.getContext(index2));
              return opts.lineWidth;
            }
            return 0;
          }
          drawGrid(chartArea) {
            const grid = this.options.grid;
            const ctx = this.ctx;
            const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
            let i, ilen;
            const drawLine = (p1, p2, style) => {
              if (!style.width || !style.color) {
                return;
              }
              ctx.save();
              ctx.lineWidth = style.width;
              ctx.strokeStyle = style.color;
              ctx.setLineDash(style.borderDash || []);
              ctx.lineDashOffset = style.borderDashOffset;
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
              ctx.restore();
            };
            if (grid.display) {
              for (i = 0, ilen = items.length; i < ilen; ++i) {
                const item = items[i];
                if (grid.drawOnChartArea) {
                  drawLine({ x: item.x1, y: item.y1 }, { x: item.x2, y: item.y2 }, item);
                }
                if (grid.drawTicks) {
                  drawLine({ x: item.tx1, y: item.ty1 }, { x: item.tx2, y: item.ty2 }, {
                    color: item.tickColor,
                    width: item.tickWidth,
                    borderDash: item.tickBorderDash,
                    borderDashOffset: item.tickBorderDashOffset
                  });
                }
              }
            }
          }
          drawBorder() {
            const { chart, ctx, options: { grid } } = this;
            const borderOpts = grid.setContext(this.getContext());
            const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
            if (!axisWidth) {
              return;
            }
            const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
            const borderValue = this._borderValue;
            let x1, x2, y1, y2;
            if (this.isHorizontal()) {
              x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
              x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
              y1 = y2 = borderValue;
            } else {
              y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
              y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
              x1 = x2 = borderValue;
            }
            ctx.save();
            ctx.lineWidth = borderOpts.borderWidth;
            ctx.strokeStyle = borderOpts.borderColor;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
          }
          drawLabels(chartArea) {
            const optionTicks = this.options.ticks;
            if (!optionTicks.display) {
              return;
            }
            const ctx = this.ctx;
            const area = this._computeLabelArea();
            if (area) {
              clipArea(ctx, area);
            }
            const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
            let i, ilen;
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              const item = items[i];
              const tickFont = item.font;
              const label = item.label;
              if (item.backdrop) {
                ctx.fillStyle = item.backdrop.color;
                ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
              }
              let y2 = item.textOffset;
              renderText(ctx, label, 0, y2, tickFont, item);
            }
            if (area) {
              unclipArea(ctx);
            }
          }
          drawTitle() {
            const { ctx, options: { position, title, reverse } } = this;
            if (!title.display) {
              return;
            }
            const font = toFont(title.font);
            const padding = toPadding(title.padding);
            const align = title.align;
            let offset = font.lineHeight / 2;
            if (position === "bottom" || position === "center" || isObject(position)) {
              offset += padding.bottom;
              if (isArray(title.text)) {
                offset += font.lineHeight * (title.text.length - 1);
              }
            } else {
              offset += padding.top;
            }
            const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
            renderText(ctx, title.text, 0, 0, font, {
              color: title.color,
              maxWidth,
              rotation,
              textAlign: titleAlign(align, position, reverse),
              textBaseline: "middle",
              translation: [titleX, titleY]
            });
          }
          draw(chartArea) {
            if (!this._isVisible()) {
              return;
            }
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawBorder();
            this.drawTitle();
            this.drawLabels(chartArea);
          }
          _layers() {
            const opts = this.options;
            const tz = opts.ticks && opts.ticks.z || 0;
            const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
            if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
              return [{
                z: tz,
                draw: (chartArea) => {
                  this.draw(chartArea);
                }
              }];
            }
            return [{
              z: gz,
              draw: (chartArea) => {
                this.drawBackground();
                this.drawGrid(chartArea);
                this.drawTitle();
              }
            }, {
              z: gz + 1,
              draw: () => {
                this.drawBorder();
              }
            }, {
              z: tz,
              draw: (chartArea) => {
                this.drawLabels(chartArea);
              }
            }];
          }
          getMatchingVisibleMetas(type) {
            const metas = this.chart.getSortedVisibleDatasetMetas();
            const axisID = this.axis + "AxisID";
            const result = [];
            let i, ilen;
            for (i = 0, ilen = metas.length; i < ilen; ++i) {
              const meta = metas[i];
              if (meta[axisID] === this.id && (!type || meta.type === type)) {
                result.push(meta);
              }
            }
            return result;
          }
          _resolveTickFontOptions(index2) {
            const opts = this.options.ticks.setContext(this.getContext(index2));
            return toFont(opts.font);
          }
          _maxDigits() {
            const fontSize = this._resolveTickFontOptions(0).lineHeight;
            return (this.isHorizontal() ? this.width : this.height) / fontSize;
          }
        }
        class TypedRegistry {
          constructor(type, scope, override) {
            this.type = type;
            this.scope = scope;
            this.override = override;
            this.items = Object.create(null);
          }
          isForType(type) {
            return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
          }
          register(item) {
            const proto = Object.getPrototypeOf(item);
            let parentScope;
            if (isIChartComponent(proto)) {
              parentScope = this.register(proto);
            }
            const items = this.items;
            const id = item.id;
            const scope = this.scope + "." + id;
            if (!id) {
              throw new Error("class does not have id: " + item);
            }
            if (id in items) {
              return scope;
            }
            items[id] = item;
            registerDefaults(item, scope, parentScope);
            if (this.override) {
              defaults.override(item.id, item.overrides);
            }
            return scope;
          }
          get(id) {
            return this.items[id];
          }
          unregister(item) {
            const items = this.items;
            const id = item.id;
            const scope = this.scope;
            if (id in items) {
              delete items[id];
            }
            if (scope && id in defaults[scope]) {
              delete defaults[scope][id];
              if (this.override) {
                delete overrides[id];
              }
            }
          }
        }
        function registerDefaults(item, scope, parentScope) {
          const itemDefaults = merge(Object.create(null), [
            parentScope ? defaults.get(parentScope) : {},
            defaults.get(scope),
            item.defaults
          ]);
          defaults.set(scope, itemDefaults);
          if (item.defaultRoutes) {
            routeDefaults(scope, item.defaultRoutes);
          }
          if (item.descriptors) {
            defaults.describe(scope, item.descriptors);
          }
        }
        function routeDefaults(scope, routes) {
          Object.keys(routes).forEach((property) => {
            const propertyParts = property.split(".");
            const sourceName = propertyParts.pop();
            const sourceScope = [scope].concat(propertyParts).join(".");
            const parts = routes[property].split(".");
            const targetName = parts.pop();
            const targetScope = parts.join(".");
            defaults.route(sourceScope, sourceName, targetScope, targetName);
          });
        }
        function isIChartComponent(proto) {
          return "id" in proto && "defaults" in proto;
        }
        class Registry {
          constructor() {
            this.controllers = new TypedRegistry(DatasetController, "datasets", true);
            this.elements = new TypedRegistry(Element2, "elements");
            this.plugins = new TypedRegistry(Object, "plugins");
            this.scales = new TypedRegistry(Scale, "scales");
            this._typedRegistries = [this.controllers, this.scales, this.elements];
          }
          add(...args) {
            this._each("register", args);
          }
          remove(...args) {
            this._each("unregister", args);
          }
          addControllers(...args) {
            this._each("register", args, this.controllers);
          }
          addElements(...args) {
            this._each("register", args, this.elements);
          }
          addPlugins(...args) {
            this._each("register", args, this.plugins);
          }
          addScales(...args) {
            this._each("register", args, this.scales);
          }
          getController(id) {
            return this._get(id, this.controllers, "controller");
          }
          getElement(id) {
            return this._get(id, this.elements, "element");
          }
          getPlugin(id) {
            return this._get(id, this.plugins, "plugin");
          }
          getScale(id) {
            return this._get(id, this.scales, "scale");
          }
          removeControllers(...args) {
            this._each("unregister", args, this.controllers);
          }
          removeElements(...args) {
            this._each("unregister", args, this.elements);
          }
          removePlugins(...args) {
            this._each("unregister", args, this.plugins);
          }
          removeScales(...args) {
            this._each("unregister", args, this.scales);
          }
          _each(method, args, typedRegistry) {
            [...args].forEach((arg) => {
              const reg = typedRegistry || this._getRegistryForType(arg);
              if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
                this._exec(method, reg, arg);
              } else {
                each(arg, (item) => {
                  const itemReg = typedRegistry || this._getRegistryForType(item);
                  this._exec(method, itemReg, item);
                });
              }
            });
          }
          _exec(method, registry2, component) {
            const camelMethod = _capitalize(method);
            callback(component["before" + camelMethod], [], component);
            registry2[method](component);
            callback(component["after" + camelMethod], [], component);
          }
          _getRegistryForType(type) {
            for (let i = 0; i < this._typedRegistries.length; i++) {
              const reg = this._typedRegistries[i];
              if (reg.isForType(type)) {
                return reg;
              }
            }
            return this.plugins;
          }
          _get(id, typedRegistry, type) {
            const item = typedRegistry.get(id);
            if (item === void 0) {
              throw new Error('"' + id + '" is not a registered ' + type + ".");
            }
            return item;
          }
        }
        var registry = new Registry();
        class PluginService {
          constructor() {
            this._init = [];
          }
          notify(chart, hook, args, filter) {
            if (hook === "beforeInit") {
              this._init = this._createDescriptors(chart, true);
              this._notify(this._init, chart, "install");
            }
            const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
            const result = this._notify(descriptors2, chart, hook, args);
            if (hook === "afterDestroy") {
              this._notify(descriptors2, chart, "stop");
              this._notify(this._init, chart, "uninstall");
            }
            return result;
          }
          _notify(descriptors2, chart, hook, args) {
            args = args || {};
            for (const descriptor of descriptors2) {
              const plugin = descriptor.plugin;
              const method = plugin[hook];
              const params = [chart, args, descriptor.options];
              if (callback(method, params, plugin) === false && args.cancelable) {
                return false;
              }
            }
            return true;
          }
          invalidate() {
            if (!isNullOrUndef(this._cache)) {
              this._oldCache = this._cache;
              this._cache = void 0;
            }
          }
          _descriptors(chart) {
            if (this._cache) {
              return this._cache;
            }
            const descriptors2 = this._cache = this._createDescriptors(chart);
            this._notifyStateChanges(chart);
            return descriptors2;
          }
          _createDescriptors(chart, all) {
            const config = chart && chart.config;
            const options = valueOrDefault(config.options && config.options.plugins, {});
            const plugins2 = allPlugins(config);
            return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
          }
          _notifyStateChanges(chart) {
            const previousDescriptors = this._oldCache || [];
            const descriptors2 = this._cache;
            const diff = (a, b) => a.filter((x) => !b.some((y2) => x.plugin.id === y2.plugin.id));
            this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
            this._notify(diff(descriptors2, previousDescriptors), chart, "start");
          }
        }
        function allPlugins(config) {
          const localIds = {};
          const plugins2 = [];
          const keys = Object.keys(registry.plugins.items);
          for (let i = 0; i < keys.length; i++) {
            plugins2.push(registry.getPlugin(keys[i]));
          }
          const local = config.plugins || [];
          for (let i = 0; i < local.length; i++) {
            const plugin = local[i];
            if (plugins2.indexOf(plugin) === -1) {
              plugins2.push(plugin);
              localIds[plugin.id] = true;
            }
          }
          return { plugins: plugins2, localIds };
        }
        function getOpts(options, all) {
          if (!all && options === false) {
            return null;
          }
          if (options === true) {
            return {};
          }
          return options;
        }
        function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
          const result = [];
          const context = chart.getContext();
          for (const plugin of plugins2) {
            const id = plugin.id;
            const opts = getOpts(options[id], all);
            if (opts === null) {
              continue;
            }
            result.push({
              plugin,
              options: pluginOpts(chart.config, { plugin, local: localIds[id] }, opts, context)
            });
          }
          return result;
        }
        function pluginOpts(config, { plugin, local }, opts, context) {
          const keys = config.pluginScopeKeys(plugin);
          const scopes = config.getOptionScopes(opts, keys);
          if (local && plugin.defaults) {
            scopes.push(plugin.defaults);
          }
          return config.createResolver(scopes, context, [""], {
            scriptable: false,
            indexable: false,
            allKeys: true
          });
        }
        function getIndexAxis(type, options) {
          const datasetDefaults = defaults.datasets[type] || {};
          const datasetOptions = (options.datasets || {})[type] || {};
          return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
        }
        function getAxisFromDefaultScaleID(id, indexAxis) {
          let axis = id;
          if (id === "_index_") {
            axis = indexAxis;
          } else if (id === "_value_") {
            axis = indexAxis === "x" ? "y" : "x";
          }
          return axis;
        }
        function getDefaultScaleIDFromAxis(axis, indexAxis) {
          return axis === indexAxis ? "_index_" : "_value_";
        }
        function axisFromPosition(position) {
          if (position === "top" || position === "bottom") {
            return "x";
          }
          if (position === "left" || position === "right") {
            return "y";
          }
        }
        function determineAxis(id, scaleOptions) {
          if (id === "x" || id === "y") {
            return id;
          }
          return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
        }
        function mergeScaleConfig(config, options) {
          const chartDefaults = overrides[config.type] || { scales: {} };
          const configScales = options.scales || {};
          const chartIndexAxis = getIndexAxis(config.type, options);
          const firstIDs = Object.create(null);
          const scales2 = Object.create(null);
          Object.keys(configScales).forEach((id) => {
            const scaleConf = configScales[id];
            if (!isObject(scaleConf)) {
              return console.error(`Invalid scale configuration for scale: ${id}`);
            }
            if (scaleConf._proxy) {
              return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
            }
            const axis = determineAxis(id, scaleConf);
            const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
            const defaultScaleOptions = chartDefaults.scales || {};
            firstIDs[axis] = firstIDs[axis] || id;
            scales2[id] = mergeIf(Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
          });
          config.data.datasets.forEach((dataset) => {
            const type = dataset.type || config.type;
            const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
            const datasetDefaults = overrides[type] || {};
            const defaultScaleOptions = datasetDefaults.scales || {};
            Object.keys(defaultScaleOptions).forEach((defaultID) => {
              const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
              const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
              scales2[id] = scales2[id] || Object.create(null);
              mergeIf(scales2[id], [{ axis }, configScales[id], defaultScaleOptions[defaultID]]);
            });
          });
          Object.keys(scales2).forEach((key) => {
            const scale = scales2[key];
            mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
          });
          return scales2;
        }
        function initOptions(config) {
          const options = config.options || (config.options = {});
          options.plugins = valueOrDefault(options.plugins, {});
          options.scales = mergeScaleConfig(config, options);
        }
        function initData(data) {
          data = data || {};
          data.datasets = data.datasets || [];
          data.labels = data.labels || [];
          return data;
        }
        function initConfig(config) {
          config = config || {};
          config.data = initData(config.data);
          initOptions(config);
          return config;
        }
        const keyCache = new Map();
        const keysCached = new Set();
        function cachedKeys(cacheKey, generate) {
          let keys = keyCache.get(cacheKey);
          if (!keys) {
            keys = generate();
            keyCache.set(cacheKey, keys);
            keysCached.add(keys);
          }
          return keys;
        }
        const addIfFound = (set2, obj, key) => {
          const opts = resolveObjectKey(obj, key);
          if (opts !== void 0) {
            set2.add(opts);
          }
        };
        class Config {
          constructor(config) {
            this._config = initConfig(config);
            this._scopeCache = new Map();
            this._resolverCache = new Map();
          }
          get platform() {
            return this._config.platform;
          }
          get type() {
            return this._config.type;
          }
          set type(type) {
            this._config.type = type;
          }
          get data() {
            return this._config.data;
          }
          set data(data) {
            this._config.data = initData(data);
          }
          get options() {
            return this._config.options;
          }
          set options(options) {
            this._config.options = options;
          }
          get plugins() {
            return this._config.plugins;
          }
          update() {
            const config = this._config;
            this.clearCache();
            initOptions(config);
          }
          clearCache() {
            this._scopeCache.clear();
            this._resolverCache.clear();
          }
          datasetScopeKeys(datasetType) {
            return cachedKeys(datasetType, () => [[
              `datasets.${datasetType}`,
              ""
            ]]);
          }
          datasetAnimationScopeKeys(datasetType, transition) {
            return cachedKeys(`${datasetType}.transition.${transition}`, () => [
              [
                `datasets.${datasetType}.transitions.${transition}`,
                `transitions.${transition}`
              ],
              [
                `datasets.${datasetType}`,
                ""
              ]
            ]);
          }
          datasetElementScopeKeys(datasetType, elementType) {
            return cachedKeys(`${datasetType}-${elementType}`, () => [[
              `datasets.${datasetType}.elements.${elementType}`,
              `datasets.${datasetType}`,
              `elements.${elementType}`,
              ""
            ]]);
          }
          pluginScopeKeys(plugin) {
            const id = plugin.id;
            const type = this.type;
            return cachedKeys(`${type}-plugin-${id}`, () => [[
              `plugins.${id}`,
              ...plugin.additionalOptionScopes || []
            ]]);
          }
          _cachedScopes(mainScope, resetCache) {
            const _scopeCache = this._scopeCache;
            let cache = _scopeCache.get(mainScope);
            if (!cache || resetCache) {
              cache = new Map();
              _scopeCache.set(mainScope, cache);
            }
            return cache;
          }
          getOptionScopes(mainScope, keyLists, resetCache) {
            const { options, type } = this;
            const cache = this._cachedScopes(mainScope, resetCache);
            const cached = cache.get(keyLists);
            if (cached) {
              return cached;
            }
            const scopes = new Set();
            keyLists.forEach((keys) => {
              if (mainScope) {
                scopes.add(mainScope);
                keys.forEach((key) => addIfFound(scopes, mainScope, key));
              }
              keys.forEach((key) => addIfFound(scopes, options, key));
              keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
              keys.forEach((key) => addIfFound(scopes, defaults, key));
              keys.forEach((key) => addIfFound(scopes, descriptors, key));
            });
            const array = Array.from(scopes);
            if (array.length === 0) {
              array.push(Object.create(null));
            }
            if (keysCached.has(keyLists)) {
              cache.set(keyLists, array);
            }
            return array;
          }
          chartOptionScopes() {
            const { options, type } = this;
            return [
              options,
              overrides[type] || {},
              defaults.datasets[type] || {},
              { type },
              defaults,
              descriptors
            ];
          }
          resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
            const result = { $shared: true };
            const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
            let options = resolver;
            if (needContext(resolver, names2)) {
              result.$shared = false;
              context = isFunction(context) ? context() : context;
              const subResolver = this.createResolver(scopes, context, subPrefixes);
              options = _attachContext(resolver, context, subResolver);
            }
            for (const prop of names2) {
              result[prop] = options[prop];
            }
            return result;
          }
          createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
            const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
            return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
          }
        }
        function getResolver(resolverCache, scopes, prefixes) {
          let cache = resolverCache.get(scopes);
          if (!cache) {
            cache = new Map();
            resolverCache.set(scopes, cache);
          }
          const cacheKey = prefixes.join();
          let cached = cache.get(cacheKey);
          if (!cached) {
            const resolver = _createResolver(scopes, prefixes);
            cached = {
              resolver,
              subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
            };
            cache.set(cacheKey, cached);
          }
          return cached;
        }
        const hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
        function needContext(proxy, names2) {
          const { isScriptable, isIndexable } = _descriptors(proxy);
          for (const prop of names2) {
            const scriptable = isScriptable(prop);
            const indexable = isIndexable(prop);
            const value = (indexable || scriptable) && proxy[prop];
            if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
              return true;
            }
          }
          return false;
        }
        var version = "3.9.1";
        const KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
        function positionIsHorizontal(position, axis) {
          return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
        }
        function compare2Level(l1, l2) {
          return function(a, b) {
            return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
          };
        }
        function onAnimationsComplete(context) {
          const chart = context.chart;
          const animationOptions2 = chart.options.animation;
          chart.notifyPlugins("afterRender");
          callback(animationOptions2 && animationOptions2.onComplete, [context], chart);
        }
        function onAnimationProgress(context) {
          const chart = context.chart;
          const animationOptions2 = chart.options.animation;
          callback(animationOptions2 && animationOptions2.onProgress, [context], chart);
        }
        function getCanvas(item) {
          if (_isDomSupported() && typeof item === "string") {
            item = document.getElementById(item);
          } else if (item && item.length) {
            item = item[0];
          }
          if (item && item.canvas) {
            item = item.canvas;
          }
          return item;
        }
        const instances = {};
        const getChart = (key) => {
          const canvas = getCanvas(key);
          return Object.values(instances).filter((c2) => c2.canvas === canvas).pop();
        };
        function moveNumericKeys(obj, start, move) {
          const keys = Object.keys(obj);
          for (const key of keys) {
            const intKey = +key;
            if (intKey >= start) {
              const value = obj[key];
              delete obj[key];
              if (move > 0 || intKey > start) {
                obj[intKey + move] = value;
              }
            }
          }
        }
        function determineLastEvent(e, lastEvent, inChartArea, isClick) {
          if (!inChartArea || e.type === "mouseout") {
            return null;
          }
          if (isClick) {
            return lastEvent;
          }
          return e;
        }
        class Chart {
          constructor(item, userConfig) {
            const config = this.config = new Config(userConfig);
            const initialCanvas = getCanvas(item);
            const existingChart = getChart(initialCanvas);
            if (existingChart) {
              throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
            }
            const options = config.createResolver(config.chartOptionScopes(), this.getContext());
            this.platform = new (config.platform || _detectPlatform(initialCanvas))();
            this.platform.updateConfig(config);
            const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
            const canvas = context && context.canvas;
            const height = canvas && canvas.height;
            const width = canvas && canvas.width;
            this.id = uid();
            this.ctx = context;
            this.canvas = canvas;
            this.width = width;
            this.height = height;
            this._options = options;
            this._aspectRatio = this.aspectRatio;
            this._layers = [];
            this._metasets = [];
            this._stacks = void 0;
            this.boxes = [];
            this.currentDevicePixelRatio = void 0;
            this.chartArea = void 0;
            this._active = [];
            this._lastEvent = void 0;
            this._listeners = {};
            this._responsiveListeners = void 0;
            this._sortedMetasets = [];
            this.scales = {};
            this._plugins = new PluginService();
            this.$proxies = {};
            this._hiddenIndices = {};
            this.attached = false;
            this._animationsDisabled = void 0;
            this.$context = void 0;
            this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
            this._dataChanges = [];
            instances[this.id] = this;
            if (!context || !canvas) {
              console.error("Failed to create chart: can't acquire context from the given item");
              return;
            }
            animator.listen(this, "complete", onAnimationsComplete);
            animator.listen(this, "progress", onAnimationProgress);
            this._initialize();
            if (this.attached) {
              this.update();
            }
          }
          get aspectRatio() {
            const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
            if (!isNullOrUndef(aspectRatio)) {
              return aspectRatio;
            }
            if (maintainAspectRatio && _aspectRatio) {
              return _aspectRatio;
            }
            return height ? width / height : null;
          }
          get data() {
            return this.config.data;
          }
          set data(data) {
            this.config.data = data;
          }
          get options() {
            return this._options;
          }
          set options(options) {
            this.config.options = options;
          }
          _initialize() {
            this.notifyPlugins("beforeInit");
            if (this.options.responsive) {
              this.resize();
            } else {
              retinaScale(this, this.options.devicePixelRatio);
            }
            this.bindEvents();
            this.notifyPlugins("afterInit");
            return this;
          }
          clear() {
            clearCanvas(this.canvas, this.ctx);
            return this;
          }
          stop() {
            animator.stop(this);
            return this;
          }
          resize(width, height) {
            if (!animator.running(this)) {
              this._resize(width, height);
            } else {
              this._resizeBeforeDraw = { width, height };
            }
          }
          _resize(width, height) {
            const options = this.options;
            const canvas = this.canvas;
            const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
            const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
            const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
            const mode = this.width ? "resize" : "attach";
            this.width = newSize.width;
            this.height = newSize.height;
            this._aspectRatio = this.aspectRatio;
            if (!retinaScale(this, newRatio, true)) {
              return;
            }
            this.notifyPlugins("resize", { size: newSize });
            callback(options.onResize, [this, newSize], this);
            if (this.attached) {
              if (this._doResize(mode)) {
                this.render();
              }
            }
          }
          ensureScalesHaveIDs() {
            const options = this.options;
            const scalesOptions = options.scales || {};
            each(scalesOptions, (axisOptions, axisID) => {
              axisOptions.id = axisID;
            });
          }
          buildOrUpdateScales() {
            const options = this.options;
            const scaleOpts = options.scales;
            const scales2 = this.scales;
            const updated = Object.keys(scales2).reduce((obj, id) => {
              obj[id] = false;
              return obj;
            }, {});
            let items = [];
            if (scaleOpts) {
              items = items.concat(Object.keys(scaleOpts).map((id) => {
                const scaleOptions = scaleOpts[id];
                const axis = determineAxis(id, scaleOptions);
                const isRadial = axis === "r";
                const isHorizontal = axis === "x";
                return {
                  options: scaleOptions,
                  dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
                  dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
                };
              }));
            }
            each(items, (item) => {
              const scaleOptions = item.options;
              const id = scaleOptions.id;
              const axis = determineAxis(id, scaleOptions);
              const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
              if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
                scaleOptions.position = item.dposition;
              }
              updated[id] = true;
              let scale = null;
              if (id in scales2 && scales2[id].type === scaleType) {
                scale = scales2[id];
              } else {
                const scaleClass = registry.getScale(scaleType);
                scale = new scaleClass({
                  id,
                  type: scaleType,
                  ctx: this.ctx,
                  chart: this
                });
                scales2[scale.id] = scale;
              }
              scale.init(scaleOptions, options);
            });
            each(updated, (hasUpdated, id) => {
              if (!hasUpdated) {
                delete scales2[id];
              }
            });
            each(scales2, (scale) => {
              layouts.configure(this, scale, scale.options);
              layouts.addBox(this, scale);
            });
          }
          _updateMetasets() {
            const metasets = this._metasets;
            const numData = this.data.datasets.length;
            const numMeta = metasets.length;
            metasets.sort((a, b) => a.index - b.index);
            if (numMeta > numData) {
              for (let i = numData; i < numMeta; ++i) {
                this._destroyDatasetMeta(i);
              }
              metasets.splice(numData, numMeta - numData);
            }
            this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
          }
          _removeUnreferencedMetasets() {
            const { _metasets: metasets, data: { datasets } } = this;
            if (metasets.length > datasets.length) {
              delete this._stacks;
            }
            metasets.forEach((meta, index2) => {
              if (datasets.filter((x) => x === meta._dataset).length === 0) {
                this._destroyDatasetMeta(index2);
              }
            });
          }
          buildOrUpdateControllers() {
            const newControllers = [];
            const datasets = this.data.datasets;
            let i, ilen;
            this._removeUnreferencedMetasets();
            for (i = 0, ilen = datasets.length; i < ilen; i++) {
              const dataset = datasets[i];
              let meta = this.getDatasetMeta(i);
              const type = dataset.type || this.config.type;
              if (meta.type && meta.type !== type) {
                this._destroyDatasetMeta(i);
                meta = this.getDatasetMeta(i);
              }
              meta.type = type;
              meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
              meta.order = dataset.order || 0;
              meta.index = i;
              meta.label = "" + dataset.label;
              meta.visible = this.isDatasetVisible(i);
              if (meta.controller) {
                meta.controller.updateIndex(i);
                meta.controller.linkScales();
              } else {
                const ControllerClass = registry.getController(type);
                const { datasetElementType, dataElementType } = defaults.datasets[type];
                Object.assign(ControllerClass.prototype, {
                  dataElementType: registry.getElement(dataElementType),
                  datasetElementType: datasetElementType && registry.getElement(datasetElementType)
                });
                meta.controller = new ControllerClass(this, i);
                newControllers.push(meta.controller);
              }
            }
            this._updateMetasets();
            return newControllers;
          }
          _resetElements() {
            each(this.data.datasets, (dataset, datasetIndex) => {
              this.getDatasetMeta(datasetIndex).controller.reset();
            }, this);
          }
          reset() {
            this._resetElements();
            this.notifyPlugins("reset");
          }
          update(mode) {
            const config = this.config;
            config.update();
            const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
            const animsDisabled = this._animationsDisabled = !options.animation;
            this._updateScales();
            this._checkEventBindings();
            this._updateHiddenIndices();
            this._plugins.invalidate();
            if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
              return;
            }
            const newControllers = this.buildOrUpdateControllers();
            this.notifyPlugins("beforeElementsUpdate");
            let minPadding = 0;
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
              const { controller } = this.getDatasetMeta(i);
              const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
              controller.buildOrUpdateElements(reset);
              minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
            }
            minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
            this._updateLayout(minPadding);
            if (!animsDisabled) {
              each(newControllers, (controller) => {
                controller.reset();
              });
            }
            this._updateDatasets(mode);
            this.notifyPlugins("afterUpdate", { mode });
            this._layers.sort(compare2Level("z", "_idx"));
            const { _active, _lastEvent } = this;
            if (_lastEvent) {
              this._eventHandler(_lastEvent, true);
            } else if (_active.length) {
              this._updateHoverStyles(_active, _active, true);
            }
            this.render();
          }
          _updateScales() {
            each(this.scales, (scale) => {
              layouts.removeBox(this, scale);
            });
            this.ensureScalesHaveIDs();
            this.buildOrUpdateScales();
          }
          _checkEventBindings() {
            const options = this.options;
            const existingEvents = new Set(Object.keys(this._listeners));
            const newEvents = new Set(options.events);
            if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
              this.unbindEvents();
              this.bindEvents();
            }
          }
          _updateHiddenIndices() {
            const { _hiddenIndices } = this;
            const changes = this._getUniformDataChanges() || [];
            for (const { method, start, count } of changes) {
              const move = method === "_removeElements" ? -count : count;
              moveNumericKeys(_hiddenIndices, start, move);
            }
          }
          _getUniformDataChanges() {
            const _dataChanges = this._dataChanges;
            if (!_dataChanges || !_dataChanges.length) {
              return;
            }
            this._dataChanges = [];
            const datasetCount = this.data.datasets.length;
            const makeSet = (idx) => new Set(_dataChanges.filter((c2) => c2[0] === idx).map((c2, i) => i + "," + c2.splice(1).join(",")));
            const changeSet = makeSet(0);
            for (let i = 1; i < datasetCount; i++) {
              if (!setsEqual(changeSet, makeSet(i))) {
                return;
              }
            }
            return Array.from(changeSet).map((c2) => c2.split(",")).map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
          }
          _updateLayout(minPadding) {
            if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
              return;
            }
            layouts.update(this, this.width, this.height, minPadding);
            const area = this.chartArea;
            const noArea = area.width <= 0 || area.height <= 0;
            this._layers = [];
            each(this.boxes, (box) => {
              if (noArea && box.position === "chartArea") {
                return;
              }
              if (box.configure) {
                box.configure();
              }
              this._layers.push(...box._layers());
            }, this);
            this._layers.forEach((item, index2) => {
              item._idx = index2;
            });
            this.notifyPlugins("afterLayout");
          }
          _updateDatasets(mode) {
            if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
              return;
            }
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this.getDatasetMeta(i).controller.configure();
            }
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this._updateDataset(i, isFunction(mode) ? mode({ datasetIndex: i }) : mode);
            }
            this.notifyPlugins("afterDatasetsUpdate", { mode });
          }
          _updateDataset(index2, mode) {
            const meta = this.getDatasetMeta(index2);
            const args = { meta, index: index2, mode, cancelable: true };
            if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
              return;
            }
            meta.controller._update(mode);
            args.cancelable = false;
            this.notifyPlugins("afterDatasetUpdate", args);
          }
          render() {
            if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
              return;
            }
            if (animator.has(this)) {
              if (this.attached && !animator.running(this)) {
                animator.start(this);
              }
            } else {
              this.draw();
              onAnimationsComplete({ chart: this });
            }
          }
          draw() {
            let i;
            if (this._resizeBeforeDraw) {
              const { width, height } = this._resizeBeforeDraw;
              this._resize(width, height);
              this._resizeBeforeDraw = null;
            }
            this.clear();
            if (this.width <= 0 || this.height <= 0) {
              return;
            }
            if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
              return;
            }
            const layers = this._layers;
            for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
              layers[i].draw(this.chartArea);
            }
            this._drawDatasets();
            for (; i < layers.length; ++i) {
              layers[i].draw(this.chartArea);
            }
            this.notifyPlugins("afterDraw");
          }
          _getSortedDatasetMetas(filterVisible) {
            const metasets = this._sortedMetasets;
            const result = [];
            let i, ilen;
            for (i = 0, ilen = metasets.length; i < ilen; ++i) {
              const meta = metasets[i];
              if (!filterVisible || meta.visible) {
                result.push(meta);
              }
            }
            return result;
          }
          getSortedVisibleDatasetMetas() {
            return this._getSortedDatasetMetas(true);
          }
          _drawDatasets() {
            if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
              return;
            }
            const metasets = this.getSortedVisibleDatasetMetas();
            for (let i = metasets.length - 1; i >= 0; --i) {
              this._drawDataset(metasets[i]);
            }
            this.notifyPlugins("afterDatasetsDraw");
          }
          _drawDataset(meta) {
            const ctx = this.ctx;
            const clip = meta._clip;
            const useClip = !clip.disabled;
            const area = this.chartArea;
            const args = {
              meta,
              index: meta.index,
              cancelable: true
            };
            if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
              return;
            }
            if (useClip) {
              clipArea(ctx, {
                left: clip.left === false ? 0 : area.left - clip.left,
                right: clip.right === false ? this.width : area.right + clip.right,
                top: clip.top === false ? 0 : area.top - clip.top,
                bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
              });
            }
            meta.controller.draw();
            if (useClip) {
              unclipArea(ctx);
            }
            args.cancelable = false;
            this.notifyPlugins("afterDatasetDraw", args);
          }
          isPointInArea(point) {
            return _isPointInArea(point, this.chartArea, this._minPadding);
          }
          getElementsAtEventForMode(e, mode, options, useFinalPosition) {
            const method = Interaction.modes[mode];
            if (typeof method === "function") {
              return method(this, e, options, useFinalPosition);
            }
            return [];
          }
          getDatasetMeta(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            const metasets = this._metasets;
            let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
            if (!meta) {
              meta = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: dataset && dataset.order || 0,
                index: datasetIndex,
                _dataset: dataset,
                _parsed: [],
                _sorted: false
              };
              metasets.push(meta);
            }
            return meta;
          }
          getContext() {
            return this.$context || (this.$context = createContext(null, { chart: this, type: "chart" }));
          }
          getVisibleDatasetCount() {
            return this.getSortedVisibleDatasetMetas().length;
          }
          isDatasetVisible(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            if (!dataset) {
              return false;
            }
            const meta = this.getDatasetMeta(datasetIndex);
            return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
          }
          setDatasetVisibility(datasetIndex, visible) {
            const meta = this.getDatasetMeta(datasetIndex);
            meta.hidden = !visible;
          }
          toggleDataVisibility(index2) {
            this._hiddenIndices[index2] = !this._hiddenIndices[index2];
          }
          getDataVisibility(index2) {
            return !this._hiddenIndices[index2];
          }
          _updateVisibility(datasetIndex, dataIndex, visible) {
            const mode = visible ? "show" : "hide";
            const meta = this.getDatasetMeta(datasetIndex);
            const anims = meta.controller._resolveAnimations(void 0, mode);
            if (defined(dataIndex)) {
              meta.data[dataIndex].hidden = !visible;
              this.update();
            } else {
              this.setDatasetVisibility(datasetIndex, visible);
              anims.update(meta, { visible });
              this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
            }
          }
          hide(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, false);
          }
          show(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, true);
          }
          _destroyDatasetMeta(datasetIndex) {
            const meta = this._metasets[datasetIndex];
            if (meta && meta.controller) {
              meta.controller._destroy();
            }
            delete this._metasets[datasetIndex];
          }
          _stop() {
            let i, ilen;
            this.stop();
            animator.remove(this);
            for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this._destroyDatasetMeta(i);
            }
          }
          destroy() {
            this.notifyPlugins("beforeDestroy");
            const { canvas, ctx } = this;
            this._stop();
            this.config.clearCache();
            if (canvas) {
              this.unbindEvents();
              clearCanvas(canvas, ctx);
              this.platform.releaseContext(ctx);
              this.canvas = null;
              this.ctx = null;
            }
            this.notifyPlugins("destroy");
            delete instances[this.id];
            this.notifyPlugins("afterDestroy");
          }
          toBase64Image(...args) {
            return this.canvas.toDataURL(...args);
          }
          bindEvents() {
            this.bindUserEvents();
            if (this.options.responsive) {
              this.bindResponsiveEvents();
            } else {
              this.attached = true;
            }
          }
          bindUserEvents() {
            const listeners = this._listeners;
            const platform = this.platform;
            const _add = (type, listener2) => {
              platform.addEventListener(this, type, listener2);
              listeners[type] = listener2;
            };
            const listener = (e, x, y2) => {
              e.offsetX = x;
              e.offsetY = y2;
              this._eventHandler(e);
            };
            each(this.options.events, (type) => _add(type, listener));
          }
          bindResponsiveEvents() {
            if (!this._responsiveListeners) {
              this._responsiveListeners = {};
            }
            const listeners = this._responsiveListeners;
            const platform = this.platform;
            const _add = (type, listener2) => {
              platform.addEventListener(this, type, listener2);
              listeners[type] = listener2;
            };
            const _remove = (type, listener2) => {
              if (listeners[type]) {
                platform.removeEventListener(this, type, listener2);
                delete listeners[type];
              }
            };
            const listener = (width, height) => {
              if (this.canvas) {
                this.resize(width, height);
              }
            };
            let detached;
            const attached = () => {
              _remove("attach", attached);
              this.attached = true;
              this.resize();
              _add("resize", listener);
              _add("detach", detached);
            };
            detached = () => {
              this.attached = false;
              _remove("resize", listener);
              this._stop();
              this._resize(0, 0);
              _add("attach", attached);
            };
            if (platform.isAttached(this.canvas)) {
              attached();
            } else {
              detached();
            }
          }
          unbindEvents() {
            each(this._listeners, (listener, type) => {
              this.platform.removeEventListener(this, type, listener);
            });
            this._listeners = {};
            each(this._responsiveListeners, (listener, type) => {
              this.platform.removeEventListener(this, type, listener);
            });
            this._responsiveListeners = void 0;
          }
          updateHoverStyle(items, mode, enabled) {
            const prefix = enabled ? "set" : "remove";
            let meta, item, i, ilen;
            if (mode === "dataset") {
              meta = this.getDatasetMeta(items[0].datasetIndex);
              meta.controller["_" + prefix + "DatasetHoverStyle"]();
            }
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              item = items[i];
              const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
              if (controller) {
                controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
              }
            }
          }
          getActiveElements() {
            return this._active || [];
          }
          setActiveElements(activeElements) {
            const lastActive = this._active || [];
            const active = activeElements.map(({ datasetIndex, index: index2 }) => {
              const meta = this.getDatasetMeta(datasetIndex);
              if (!meta) {
                throw new Error("No dataset found at index " + datasetIndex);
              }
              return {
                datasetIndex,
                element: meta.data[index2],
                index: index2
              };
            });
            const changed = !_elementsEqual(active, lastActive);
            if (changed) {
              this._active = active;
              this._lastEvent = null;
              this._updateHoverStyles(active, lastActive);
            }
          }
          notifyPlugins(hook, args, filter) {
            return this._plugins.notify(this, hook, args, filter);
          }
          _updateHoverStyles(active, lastActive, replay) {
            const hoverOptions = this.options.hover;
            const diff = (a, b) => a.filter((x) => !b.some((y2) => x.datasetIndex === y2.datasetIndex && x.index === y2.index));
            const deactivated = diff(lastActive, active);
            const activated = replay ? active : diff(active, lastActive);
            if (deactivated.length) {
              this.updateHoverStyle(deactivated, hoverOptions.mode, false);
            }
            if (activated.length && hoverOptions.mode) {
              this.updateHoverStyle(activated, hoverOptions.mode, true);
            }
          }
          _eventHandler(e, replay) {
            const args = {
              event: e,
              replay,
              cancelable: true,
              inChartArea: this.isPointInArea(e)
            };
            const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
            if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
              return;
            }
            const changed = this._handleEvent(e, replay, args.inChartArea);
            args.cancelable = false;
            this.notifyPlugins("afterEvent", args, eventFilter);
            if (changed || args.changed) {
              this.render();
            }
            return this;
          }
          _handleEvent(e, replay, inChartArea) {
            const { _active: lastActive = [], options } = this;
            const useFinalPosition = replay;
            const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
            const isClick = _isClickEvent(e);
            const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
            if (inChartArea) {
              this._lastEvent = null;
              callback(options.onHover, [e, active, this], this);
              if (isClick) {
                callback(options.onClick, [e, active, this], this);
              }
            }
            const changed = !_elementsEqual(active, lastActive);
            if (changed || replay) {
              this._active = active;
              this._updateHoverStyles(active, lastActive, replay);
            }
            this._lastEvent = lastEvent;
            return changed;
          }
          _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
            if (e.type === "mouseout") {
              return [];
            }
            if (!inChartArea) {
              return lastActive;
            }
            const hoverOptions = this.options.hover;
            return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
          }
        }
        const invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());
        const enumerable = true;
        Object.defineProperties(Chart, {
          defaults: {
            enumerable,
            value: defaults
          },
          instances: {
            enumerable,
            value: instances
          },
          overrides: {
            enumerable,
            value: overrides
          },
          registry: {
            enumerable,
            value: registry
          },
          version: {
            enumerable,
            value: version
          },
          getChart: {
            enumerable,
            value: getChart
          },
          register: {
            enumerable,
            value: (...items) => {
              registry.add(...items);
              invalidatePlugins();
            }
          },
          unregister: {
            enumerable,
            value: (...items) => {
              registry.remove(...items);
              invalidatePlugins();
            }
          }
        });
        function abstract() {
          throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
        }
        class DateAdapter {
          constructor(options) {
            this.options = options || {};
          }
          init(chartOptions) {
          }
          formats() {
            return abstract();
          }
          parse(value, format) {
            return abstract();
          }
          format(timestamp, format) {
            return abstract();
          }
          add(timestamp, amount, unit) {
            return abstract();
          }
          diff(a, b, unit) {
            return abstract();
          }
          startOf(timestamp, unit, weekday) {
            return abstract();
          }
          endOf(timestamp, unit) {
            return abstract();
          }
        }
        DateAdapter.override = function(members) {
          Object.assign(DateAdapter.prototype, members);
        };
        var _adapters = {
          _date: DateAdapter
        };
        function getAllScaleValues(scale, type) {
          if (!scale._cache.$bar) {
            const visibleMetas = scale.getMatchingVisibleMetas(type);
            let values = [];
            for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
              values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
            }
            scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
          }
          return scale._cache.$bar;
        }
        function computeMinSampleSize(meta) {
          const scale = meta.iScale;
          const values = getAllScaleValues(scale, meta.type);
          let min = scale._length;
          let i, ilen, curr, prev;
          const updateMinAndPrev = () => {
            if (curr === 32767 || curr === -32768) {
              return;
            }
            if (defined(prev)) {
              min = Math.min(min, Math.abs(curr - prev) || min);
            }
            prev = curr;
          };
          for (i = 0, ilen = values.length; i < ilen; ++i) {
            curr = scale.getPixelForValue(values[i]);
            updateMinAndPrev();
          }
          prev = void 0;
          for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
            curr = scale.getPixelForTick(i);
            updateMinAndPrev();
          }
          return min;
        }
        function computeFitCategoryTraits(index2, ruler, options, stackCount) {
          const thickness = options.barThickness;
          let size, ratio;
          if (isNullOrUndef(thickness)) {
            size = ruler.min * options.categoryPercentage;
            ratio = options.barPercentage;
          } else {
            size = thickness * stackCount;
            ratio = 1;
          }
          return {
            chunk: size / stackCount,
            ratio,
            start: ruler.pixels[index2] - size / 2
          };
        }
        function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
          const pixels = ruler.pixels;
          const curr = pixels[index2];
          let prev = index2 > 0 ? pixels[index2 - 1] : null;
          let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
          const percent = options.categoryPercentage;
          if (prev === null) {
            prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
          }
          if (next === null) {
            next = curr + curr - prev;
          }
          const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
          const size = Math.abs(next - prev) / 2 * percent;
          return {
            chunk: size / stackCount,
            ratio: options.barPercentage,
            start
          };
        }
        function parseFloatBar(entry, item, vScale, i) {
          const startValue = vScale.parse(entry[0], i);
          const endValue = vScale.parse(entry[1], i);
          const min = Math.min(startValue, endValue);
          const max = Math.max(startValue, endValue);
          let barStart = min;
          let barEnd = max;
          if (Math.abs(min) > Math.abs(max)) {
            barStart = max;
            barEnd = min;
          }
          item[vScale.axis] = barEnd;
          item._custom = {
            barStart,
            barEnd,
            start: startValue,
            end: endValue,
            min,
            max
          };
        }
        function parseValue(entry, item, vScale, i) {
          if (isArray(entry)) {
            parseFloatBar(entry, item, vScale, i);
          } else {
            item[vScale.axis] = vScale.parse(entry, i);
          }
          return item;
        }
        function parseArrayOrPrimitive(meta, data, start, count) {
          const iScale = meta.iScale;
          const vScale = meta.vScale;
          const labels = iScale.getLabels();
          const singleScale = iScale === vScale;
          const parsed = [];
          let i, ilen, item, entry;
          for (i = start, ilen = start + count; i < ilen; ++i) {
            entry = data[i];
            item = {};
            item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
            parsed.push(parseValue(entry, item, vScale, i));
          }
          return parsed;
        }
        function isFloatBar(custom) {
          return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
        }
        function barSign(size, vScale, actualBase) {
          if (size !== 0) {
            return sign(size);
          }
          return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
        }
        function borderProps(properties) {
          let reverse, start, end, top, bottom;
          if (properties.horizontal) {
            reverse = properties.base > properties.x;
            start = "left";
            end = "right";
          } else {
            reverse = properties.base < properties.y;
            start = "bottom";
            end = "top";
          }
          if (reverse) {
            top = "end";
            bottom = "start";
          } else {
            top = "start";
            bottom = "end";
          }
          return { start, end, reverse, top, bottom };
        }
        function setBorderSkipped(properties, options, stack, index2) {
          let edge = options.borderSkipped;
          const res = {};
          if (!edge) {
            properties.borderSkipped = res;
            return;
          }
          if (edge === true) {
            properties.borderSkipped = { top: true, right: true, bottom: true, left: true };
            return;
          }
          const { start, end, reverse, top, bottom } = borderProps(properties);
          if (edge === "middle" && stack) {
            properties.enableBorderRadius = true;
            if ((stack._top || 0) === index2) {
              edge = top;
            } else if ((stack._bottom || 0) === index2) {
              edge = bottom;
            } else {
              res[parseEdge(bottom, start, end, reverse)] = true;
              edge = top;
            }
          }
          res[parseEdge(edge, start, end, reverse)] = true;
          properties.borderSkipped = res;
        }
        function parseEdge(edge, a, b, reverse) {
          if (reverse) {
            edge = swap(edge, a, b);
            edge = startEnd(edge, b, a);
          } else {
            edge = startEnd(edge, a, b);
          }
          return edge;
        }
        function swap(orig, v1, v2) {
          return orig === v1 ? v2 : orig === v2 ? v1 : orig;
        }
        function startEnd(v, start, end) {
          return v === "start" ? start : v === "end" ? end : v;
        }
        function setInflateAmount(properties, { inflateAmount }, ratio) {
          properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
        }
        class BarController extends DatasetController {
          parsePrimitiveData(meta, data, start, count) {
            return parseArrayOrPrimitive(meta, data, start, count);
          }
          parseArrayData(meta, data, start, count) {
            return parseArrayOrPrimitive(meta, data, start, count);
          }
          parseObjectData(meta, data, start, count) {
            const { iScale, vScale } = meta;
            const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
            const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
            const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
            const parsed = [];
            let i, ilen, item, obj;
            for (i = start, ilen = start + count; i < ilen; ++i) {
              obj = data[i];
              item = {};
              item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
              parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
            }
            return parsed;
          }
          updateRangeFromParsed(range, scale, parsed, stack) {
            super.updateRangeFromParsed(range, scale, parsed, stack);
            const custom = parsed._custom;
            if (custom && scale === this._cachedMeta.vScale) {
              range.min = Math.min(range.min, custom.min);
              range.max = Math.max(range.max, custom.max);
            }
          }
          getMaxOverflow() {
            return 0;
          }
          getLabelAndValue(index2) {
            const meta = this._cachedMeta;
            const { iScale, vScale } = meta;
            const parsed = this.getParsed(index2);
            const custom = parsed._custom;
            const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
            return {
              label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
              value
            };
          }
          initialize() {
            this.enableOptionSharing = true;
            super.initialize();
            const meta = this._cachedMeta;
            meta.stack = this.getDataset().stack;
          }
          update(mode) {
            const meta = this._cachedMeta;
            this.updateElements(meta.data, 0, meta.data.length, mode);
          }
          updateElements(bars, start, count, mode) {
            const reset = mode === "reset";
            const { index: index2, _cachedMeta: { vScale } } = this;
            const base = vScale.getBasePixel();
            const horizontal = vScale.isHorizontal();
            const ruler = this._getRuler();
            const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
            for (let i = start; i < start + count; i++) {
              const parsed = this.getParsed(i);
              const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? { base, head: base } : this._calculateBarValuePixels(i);
              const ipixels = this._calculateBarIndexPixels(i, ruler);
              const stack = (parsed._stacks || {})[vScale.axis];
              const properties = {
                horizontal,
                base: vpixels.base,
                enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index2 === stack._top || index2 === stack._bottom),
                x: horizontal ? vpixels.head : ipixels.center,
                y: horizontal ? ipixels.center : vpixels.head,
                height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                width: horizontal ? Math.abs(vpixels.size) : ipixels.size
              };
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
              }
              const options = properties.options || bars[i].options;
              setBorderSkipped(properties, options, stack, index2);
              setInflateAmount(properties, options, ruler.ratio);
              this.updateElement(bars[i], i, properties, mode);
            }
          }
          _getStacks(last, dataIndex) {
            const { iScale } = this._cachedMeta;
            const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
            const stacked = iScale.options.stacked;
            const stacks = [];
            const skipNull = (meta) => {
              const parsed = meta.controller.getParsed(dataIndex);
              const val = parsed && parsed[meta.vScale.axis];
              if (isNullOrUndef(val) || isNaN(val)) {
                return true;
              }
            };
            for (const meta of metasets) {
              if (dataIndex !== void 0 && skipNull(meta)) {
                continue;
              }
              if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
                stacks.push(meta.stack);
              }
              if (meta.index === last) {
                break;
              }
            }
            if (!stacks.length) {
              stacks.push(void 0);
            }
            return stacks;
          }
          _getStackCount(index2) {
            return this._getStacks(void 0, index2).length;
          }
          _getStackIndex(datasetIndex, name, dataIndex) {
            const stacks = this._getStacks(datasetIndex, dataIndex);
            const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
            return index2 === -1 ? stacks.length - 1 : index2;
          }
          _getRuler() {
            const opts = this.options;
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const pixels = [];
            let i, ilen;
            for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
              pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
            }
            const barThickness = opts.barThickness;
            const min = barThickness || computeMinSampleSize(meta);
            return {
              min,
              pixels,
              start: iScale._startPixel,
              end: iScale._endPixel,
              stackCount: this._getStackCount(),
              scale: iScale,
              grouped: opts.grouped,
              ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
            };
          }
          _calculateBarValuePixels(index2) {
            const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
            const actualBase = baseValue || 0;
            const parsed = this.getParsed(index2);
            const custom = parsed._custom;
            const floating = isFloatBar(custom);
            let value = parsed[vScale.axis];
            let start = 0;
            let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
            let head, size;
            if (length !== value) {
              start = length - value;
              length = value;
            }
            if (floating) {
              value = custom.barStart;
              length = custom.barEnd - custom.barStart;
              if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
                start = 0;
              }
              start += value;
            }
            const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
            let base = vScale.getPixelForValue(startValue);
            if (this.chart.getDataVisibility(index2)) {
              head = vScale.getPixelForValue(start + length);
            } else {
              head = base;
            }
            size = head - base;
            if (Math.abs(size) < minBarLength) {
              size = barSign(size, vScale, actualBase) * minBarLength;
              if (value === actualBase) {
                base -= size / 2;
              }
              const startPixel = vScale.getPixelForDecimal(0);
              const endPixel = vScale.getPixelForDecimal(1);
              const min = Math.min(startPixel, endPixel);
              const max = Math.max(startPixel, endPixel);
              base = Math.max(Math.min(base, max), min);
              head = base + size;
            }
            if (base === vScale.getPixelForValue(actualBase)) {
              const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
              base += halfGrid;
              size -= halfGrid;
            }
            return {
              size,
              base,
              head,
              center: head + size / 2
            };
          }
          _calculateBarIndexPixels(index2, ruler) {
            const scale = ruler.scale;
            const options = this.options;
            const skipNull = options.skipNull;
            const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
            let center, size;
            if (ruler.grouped) {
              const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
              const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
              const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
              center = range.start + range.chunk * stackIndex + range.chunk / 2;
              size = Math.min(maxBarThickness, range.chunk * range.ratio);
            } else {
              center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
              size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
            }
            return {
              base: center - size / 2,
              head: center + size / 2,
              center,
              size
            };
          }
          draw() {
            const meta = this._cachedMeta;
            const vScale = meta.vScale;
            const rects = meta.data;
            const ilen = rects.length;
            let i = 0;
            for (; i < ilen; ++i) {
              if (this.getParsed(i)[vScale.axis] !== null) {
                rects[i].draw(this._ctx);
              }
            }
          }
        }
        BarController.id = "bar";
        BarController.defaults = {
          datasetElementType: false,
          dataElementType: "bar",
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          grouped: true,
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "base", "width", "height"]
            }
          }
        };
        BarController.overrides = {
          scales: {
            _index_: {
              type: "category",
              offset: true,
              grid: {
                offset: true
              }
            },
            _value_: {
              type: "linear",
              beginAtZero: true
            }
          }
        };
        class BubbleController extends DatasetController {
          initialize() {
            this.enableOptionSharing = true;
            super.initialize();
          }
          parsePrimitiveData(meta, data, start, count) {
            const parsed = super.parsePrimitiveData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
            }
            return parsed;
          }
          parseArrayData(meta, data, start, count) {
            const parsed = super.parseArrayData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              const item = data[start + i];
              parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
            }
            return parsed;
          }
          parseObjectData(meta, data, start, count) {
            const parsed = super.parseObjectData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              const item = data[start + i];
              parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
            }
            return parsed;
          }
          getMaxOverflow() {
            const data = this._cachedMeta.data;
            let max = 0;
            for (let i = data.length - 1; i >= 0; --i) {
              max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
            }
            return max > 0 && max;
          }
          getLabelAndValue(index2) {
            const meta = this._cachedMeta;
            const { xScale, yScale } = meta;
            const parsed = this.getParsed(index2);
            const x = xScale.getLabelForValue(parsed.x);
            const y2 = yScale.getLabelForValue(parsed.y);
            const r = parsed._custom;
            return {
              label: meta.label,
              value: "(" + x + ", " + y2 + (r ? ", " + r : "") + ")"
            };
          }
          update(mode) {
            const points = this._cachedMeta.data;
            this.updateElements(points, 0, points.length, mode);
          }
          updateElements(points, start, count, mode) {
            const reset = mode === "reset";
            const { iScale, vScale } = this._cachedMeta;
            const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            for (let i = start; i < start + count; i++) {
              const point = points[i];
              const parsed = !reset && this.getParsed(i);
              const properties = {};
              const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
              const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
              properties.skip = isNaN(iPixel) || isNaN(vPixel);
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
                if (reset) {
                  properties.options.radius = 0;
                }
              }
              this.updateElement(point, i, properties, mode);
            }
          }
          resolveDataElementOptions(index2, mode) {
            const parsed = this.getParsed(index2);
            let values = super.resolveDataElementOptions(index2, mode);
            if (values.$shared) {
              values = Object.assign({}, values, { $shared: false });
            }
            const radius = values.radius;
            if (mode !== "active") {
              values.radius = 0;
            }
            values.radius += valueOrDefault(parsed && parsed._custom, radius);
            return values;
          }
        }
        BubbleController.id = "bubble";
        BubbleController.defaults = {
          datasetElementType: false,
          dataElementType: "point",
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "borderWidth", "radius"]
            }
          }
        };
        BubbleController.overrides = {
          scales: {
            x: {
              type: "linear"
            },
            y: {
              type: "linear"
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                title() {
                  return "";
                }
              }
            }
          }
        };
        function getRatioAndOffset(rotation, circumference, cutout) {
          let ratioX = 1;
          let ratioY = 1;
          let offsetX = 0;
          let offsetY = 0;
          if (circumference < TAU) {
            const startAngle = rotation;
            const endAngle = startAngle + circumference;
            const startX = Math.cos(startAngle);
            const startY = Math.sin(startAngle);
            const endX = Math.cos(endAngle);
            const endY = Math.sin(endAngle);
            const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
            const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
            const maxX = calcMax(0, startX, endX);
            const maxY = calcMax(HALF_PI, startY, endY);
            const minX = calcMin(PI, startX, endX);
            const minY = calcMin(PI + HALF_PI, startY, endY);
            ratioX = (maxX - minX) / 2;
            ratioY = (maxY - minY) / 2;
            offsetX = -(maxX + minX) / 2;
            offsetY = -(maxY + minY) / 2;
          }
          return { ratioX, ratioY, offsetX, offsetY };
        }
        class DoughnutController extends DatasetController {
          constructor(chart, datasetIndex) {
            super(chart, datasetIndex);
            this.enableOptionSharing = true;
            this.innerRadius = void 0;
            this.outerRadius = void 0;
            this.offsetX = void 0;
            this.offsetY = void 0;
          }
          linkScales() {
          }
          parse(start, count) {
            const data = this.getDataset().data;
            const meta = this._cachedMeta;
            if (this._parsing === false) {
              meta._parsed = data;
            } else {
              let getter = (i2) => +data[i2];
              if (isObject(data[start])) {
                const { key = "value" } = this._parsing;
                getter = (i2) => +resolveObjectKey(data[i2], key);
              }
              let i, ilen;
              for (i = start, ilen = start + count; i < ilen; ++i) {
                meta._parsed[i] = getter(i);
              }
            }
          }
          _getRotation() {
            return toRadians(this.options.rotation - 90);
          }
          _getCircumference() {
            return toRadians(this.options.circumference);
          }
          _getRotationExtents() {
            let min = TAU;
            let max = -TAU;
            for (let i = 0; i < this.chart.data.datasets.length; ++i) {
              if (this.chart.isDatasetVisible(i)) {
                const controller = this.chart.getDatasetMeta(i).controller;
                const rotation = controller._getRotation();
                const circumference = controller._getCircumference();
                min = Math.min(min, rotation);
                max = Math.max(max, rotation + circumference);
              }
            }
            return {
              rotation: min,
              circumference: max - min
            };
          }
          update(mode) {
            const chart = this.chart;
            const { chartArea } = chart;
            const meta = this._cachedMeta;
            const arcs = meta.data;
            const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
            const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
            const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
            const chartWeight = this._getRingWeight(this.index);
            const { circumference, rotation } = this._getRotationExtents();
            const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
            const maxWidth = (chartArea.width - spacing) / ratioX;
            const maxHeight = (chartArea.height - spacing) / ratioY;
            const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
            const outerRadius = toDimension(this.options.radius, maxRadius);
            const innerRadius = Math.max(outerRadius * cutout, 0);
            const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
            this.offsetX = offsetX * outerRadius;
            this.offsetY = offsetY * outerRadius;
            meta.total = this.calculateTotal();
            this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
            this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
            this.updateElements(arcs, 0, arcs.length, mode);
          }
          _circumference(i, reset) {
            const opts = this.options;
            const meta = this._cachedMeta;
            const circumference = this._getCircumference();
            if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
              return 0;
            }
            return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
          }
          updateElements(arcs, start, count, mode) {
            const reset = mode === "reset";
            const chart = this.chart;
            const chartArea = chart.chartArea;
            const opts = chart.options;
            const animationOpts = opts.animation;
            const centerX = (chartArea.left + chartArea.right) / 2;
            const centerY = (chartArea.top + chartArea.bottom) / 2;
            const animateScale = reset && animationOpts.animateScale;
            const innerRadius = animateScale ? 0 : this.innerRadius;
            const outerRadius = animateScale ? 0 : this.outerRadius;
            const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
            let startAngle = this._getRotation();
            let i;
            for (i = 0; i < start; ++i) {
              startAngle += this._circumference(i, reset);
            }
            for (i = start; i < start + count; ++i) {
              const circumference = this._circumference(i, reset);
              const arc = arcs[i];
              const properties = {
                x: centerX + this.offsetX,
                y: centerY + this.offsetY,
                startAngle,
                endAngle: startAngle + circumference,
                circumference,
                outerRadius,
                innerRadius
              };
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
              }
              startAngle += circumference;
              this.updateElement(arc, i, properties, mode);
            }
          }
          calculateTotal() {
            const meta = this._cachedMeta;
            const metaData = meta.data;
            let total = 0;
            let i;
            for (i = 0; i < metaData.length; i++) {
              const value = meta._parsed[i];
              if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
                total += Math.abs(value);
              }
            }
            return total;
          }
          calculateCircumference(value) {
            const total = this._cachedMeta.total;
            if (total > 0 && !isNaN(value)) {
              return TAU * (Math.abs(value) / total);
            }
            return 0;
          }
          getLabelAndValue(index2) {
            const meta = this._cachedMeta;
            const chart = this.chart;
            const labels = chart.data.labels || [];
            const value = formatNumber(meta._parsed[index2], chart.options.locale);
            return {
              label: labels[index2] || "",
              value
            };
          }
          getMaxBorderWidth(arcs) {
            let max = 0;
            const chart = this.chart;
            let i, ilen, meta, controller, options;
            if (!arcs) {
              for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
                if (chart.isDatasetVisible(i)) {
                  meta = chart.getDatasetMeta(i);
                  arcs = meta.data;
                  controller = meta.controller;
                  break;
                }
              }
            }
            if (!arcs) {
              return 0;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              options = controller.resolveDataElementOptions(i);
              if (options.borderAlign !== "inner") {
                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
              }
            }
            return max;
          }
          getMaxOffset(arcs) {
            let max = 0;
            for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
              const options = this.resolveDataElementOptions(i);
              max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
            }
            return max;
          }
          _getRingWeightOffset(datasetIndex) {
            let ringWeightOffset = 0;
            for (let i = 0; i < datasetIndex; ++i) {
              if (this.chart.isDatasetVisible(i)) {
                ringWeightOffset += this._getRingWeight(i);
              }
            }
            return ringWeightOffset;
          }
          _getRingWeight(datasetIndex) {
            return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
          }
          _getVisibleDatasetWeightTotal() {
            return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
          }
        }
        DoughnutController.id = "doughnut";
        DoughnutController.defaults = {
          datasetElementType: false,
          dataElementType: "arc",
          animation: {
            animateRotate: true,
            animateScale: false
          },
          animations: {
            numbers: {
              type: "number",
              properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
            }
          },
          cutout: "50%",
          rotation: 0,
          circumference: 360,
          radius: "100%",
          spacing: 0,
          indexAxis: "r"
        };
        DoughnutController.descriptors = {
          _scriptable: (name) => name !== "spacing",
          _indexable: (name) => name !== "spacing"
        };
        DoughnutController.overrides = {
          aspectRatio: 1,
          plugins: {
            legend: {
              labels: {
                generateLabels(chart) {
                  const data = chart.data;
                  if (data.labels.length && data.datasets.length) {
                    const { labels: { pointStyle } } = chart.legend.options;
                    return data.labels.map((label, i) => {
                      const meta = chart.getDatasetMeta(0);
                      const style = meta.controller.getStyle(i);
                      return {
                        text: label,
                        fillStyle: style.backgroundColor,
                        strokeStyle: style.borderColor,
                        lineWidth: style.borderWidth,
                        pointStyle,
                        hidden: !chart.getDataVisibility(i),
                        index: i
                      };
                    });
                  }
                  return [];
                }
              },
              onClick(e, legendItem, legend) {
                legend.chart.toggleDataVisibility(legendItem.index);
                legend.chart.update();
              }
            },
            tooltip: {
              callbacks: {
                title() {
                  return "";
                },
                label(tooltipItem) {
                  let dataLabel = tooltipItem.label;
                  const value = ": " + tooltipItem.formattedValue;
                  if (isArray(dataLabel)) {
                    dataLabel = dataLabel.slice();
                    dataLabel[0] += value;
                  } else {
                    dataLabel += value;
                  }
                  return dataLabel;
                }
              }
            }
          }
        };
        class LineController extends DatasetController {
          initialize() {
            this.enableOptionSharing = true;
            this.supportsDecimation = true;
            super.initialize();
          }
          update(mode) {
            const meta = this._cachedMeta;
            const { dataset: line, data: points = [], _dataset } = meta;
            const animationsDisabled = this.chart._animationsDisabled;
            let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
            this._drawStart = start;
            this._drawCount = count;
            if (_scaleRangesChanged(meta)) {
              start = 0;
              count = points.length;
            }
            line._chart = this.chart;
            line._datasetIndex = this.index;
            line._decimated = !!_dataset._decimated;
            line.points = points;
            const options = this.resolveDatasetElementOptions(mode);
            if (!this.options.showLine) {
              options.borderWidth = 0;
            }
            options.segment = this.options.segment;
            this.updateElement(line, void 0, {
              animated: !animationsDisabled,
              options
            }, mode);
            this.updateElements(points, start, count, mode);
          }
          updateElements(points, start, count, mode) {
            const reset = mode === "reset";
            const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
            const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const { spanGaps, segment } = this.options;
            const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
            const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
            let prevParsed = start > 0 && this.getParsed(start - 1);
            for (let i = start; i < start + count; ++i) {
              const point = points[i];
              const parsed = this.getParsed(i);
              const properties = directUpdate ? point : {};
              const nullData = isNullOrUndef(parsed[vAxis]);
              const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
              const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
              properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
              properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
              if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
              }
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
              }
              if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
              }
              prevParsed = parsed;
            }
          }
          getMaxOverflow() {
            const meta = this._cachedMeta;
            const dataset = meta.dataset;
            const border = dataset.options && dataset.options.borderWidth || 0;
            const data = meta.data || [];
            if (!data.length) {
              return border;
            }
            const firstPoint = data[0].size(this.resolveDataElementOptions(0));
            const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
            return Math.max(border, firstPoint, lastPoint) / 2;
          }
          draw() {
            const meta = this._cachedMeta;
            meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
            super.draw();
          }
        }
        LineController.id = "line";
        LineController.defaults = {
          datasetElementType: "line",
          dataElementType: "point",
          showLine: true,
          spanGaps: false
        };
        LineController.overrides = {
          scales: {
            _index_: {
              type: "category"
            },
            _value_: {
              type: "linear"
            }
          }
        };
        class PolarAreaController extends DatasetController {
          constructor(chart, datasetIndex) {
            super(chart, datasetIndex);
            this.innerRadius = void 0;
            this.outerRadius = void 0;
          }
          getLabelAndValue(index2) {
            const meta = this._cachedMeta;
            const chart = this.chart;
            const labels = chart.data.labels || [];
            const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
            return {
              label: labels[index2] || "",
              value
            };
          }
          parseObjectData(meta, data, start, count) {
            return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
          }
          update(mode) {
            const arcs = this._cachedMeta.data;
            this._updateRadius();
            this.updateElements(arcs, 0, arcs.length, mode);
          }
          getMinMax() {
            const meta = this._cachedMeta;
            const range = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
            meta.data.forEach((element, index2) => {
              const parsed = this.getParsed(index2).r;
              if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
                if (parsed < range.min) {
                  range.min = parsed;
                }
                if (parsed > range.max) {
                  range.max = parsed;
                }
              }
            });
            return range;
          }
          _updateRadius() {
            const chart = this.chart;
            const chartArea = chart.chartArea;
            const opts = chart.options;
            const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
            const outerRadius = Math.max(minSize / 2, 0);
            const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
            const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
            this.outerRadius = outerRadius - radiusLength * this.index;
            this.innerRadius = this.outerRadius - radiusLength;
          }
          updateElements(arcs, start, count, mode) {
            const reset = mode === "reset";
            const chart = this.chart;
            const opts = chart.options;
            const animationOpts = opts.animation;
            const scale = this._cachedMeta.rScale;
            const centerX = scale.xCenter;
            const centerY = scale.yCenter;
            const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
            let angle = datasetStartAngle;
            let i;
            const defaultAngle = 360 / this.countVisibleElements();
            for (i = 0; i < start; ++i) {
              angle += this._computeAngle(i, mode, defaultAngle);
            }
            for (i = start; i < start + count; i++) {
              const arc = arcs[i];
              let startAngle = angle;
              let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
              let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
              angle = endAngle;
              if (reset) {
                if (animationOpts.animateScale) {
                  outerRadius = 0;
                }
                if (animationOpts.animateRotate) {
                  startAngle = endAngle = datasetStartAngle;
                }
              }
              const properties = {
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius,
                startAngle,
                endAngle,
                options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
              };
              this.updateElement(arc, i, properties, mode);
            }
          }
          countVisibleElements() {
            const meta = this._cachedMeta;
            let count = 0;
            meta.data.forEach((element, index2) => {
              if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
                count++;
              }
            });
            return count;
          }
          _computeAngle(index2, mode, defaultAngle) {
            return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
          }
        }
        PolarAreaController.id = "polarArea";
        PolarAreaController.defaults = {
          dataElementType: "arc",
          animation: {
            animateRotate: true,
            animateScale: true
          },
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
            }
          },
          indexAxis: "r",
          startAngle: 0
        };
        PolarAreaController.overrides = {
          aspectRatio: 1,
          plugins: {
            legend: {
              labels: {
                generateLabels(chart) {
                  const data = chart.data;
                  if (data.labels.length && data.datasets.length) {
                    const { labels: { pointStyle } } = chart.legend.options;
                    return data.labels.map((label, i) => {
                      const meta = chart.getDatasetMeta(0);
                      const style = meta.controller.getStyle(i);
                      return {
                        text: label,
                        fillStyle: style.backgroundColor,
                        strokeStyle: style.borderColor,
                        lineWidth: style.borderWidth,
                        pointStyle,
                        hidden: !chart.getDataVisibility(i),
                        index: i
                      };
                    });
                  }
                  return [];
                }
              },
              onClick(e, legendItem, legend) {
                legend.chart.toggleDataVisibility(legendItem.index);
                legend.chart.update();
              }
            },
            tooltip: {
              callbacks: {
                title() {
                  return "";
                },
                label(context) {
                  return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
                }
              }
            }
          },
          scales: {
            r: {
              type: "radialLinear",
              angleLines: {
                display: false
              },
              beginAtZero: true,
              grid: {
                circular: true
              },
              pointLabels: {
                display: false
              },
              startAngle: 0
            }
          }
        };
        class PieController extends DoughnutController {
        }
        PieController.id = "pie";
        PieController.defaults = {
          cutout: 0,
          rotation: 0,
          circumference: 360,
          radius: "100%"
        };
        class RadarController extends DatasetController {
          getLabelAndValue(index2) {
            const vScale = this._cachedMeta.vScale;
            const parsed = this.getParsed(index2);
            return {
              label: vScale.getLabels()[index2],
              value: "" + vScale.getLabelForValue(parsed[vScale.axis])
            };
          }
          parseObjectData(meta, data, start, count) {
            return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
          }
          update(mode) {
            const meta = this._cachedMeta;
            const line = meta.dataset;
            const points = meta.data || [];
            const labels = meta.iScale.getLabels();
            line.points = points;
            if (mode !== "resize") {
              const options = this.resolveDatasetElementOptions(mode);
              if (!this.options.showLine) {
                options.borderWidth = 0;
              }
              const properties = {
                _loop: true,
                _fullLoop: labels.length === points.length,
                options
              };
              this.updateElement(line, void 0, properties, mode);
            }
            this.updateElements(points, 0, points.length, mode);
          }
          updateElements(points, start, count, mode) {
            const scale = this._cachedMeta.rScale;
            const reset = mode === "reset";
            for (let i = start; i < start + count; i++) {
              const point = points[i];
              const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
              const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
              const x = reset ? scale.xCenter : pointPosition.x;
              const y2 = reset ? scale.yCenter : pointPosition.y;
              const properties = {
                x,
                y: y2,
                angle: pointPosition.angle,
                skip: isNaN(x) || isNaN(y2),
                options
              };
              this.updateElement(point, i, properties, mode);
            }
          }
        }
        RadarController.id = "radar";
        RadarController.defaults = {
          datasetElementType: "line",
          dataElementType: "point",
          indexAxis: "r",
          showLine: true,
          elements: {
            line: {
              fill: "start"
            }
          }
        };
        RadarController.overrides = {
          aspectRatio: 1,
          scales: {
            r: {
              type: "radialLinear"
            }
          }
        };
        class ScatterController extends DatasetController {
          update(mode) {
            const meta = this._cachedMeta;
            const { data: points = [] } = meta;
            const animationsDisabled = this.chart._animationsDisabled;
            let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
            this._drawStart = start;
            this._drawCount = count;
            if (_scaleRangesChanged(meta)) {
              start = 0;
              count = points.length;
            }
            if (this.options.showLine) {
              const { dataset: line, _dataset } = meta;
              line._chart = this.chart;
              line._datasetIndex = this.index;
              line._decimated = !!_dataset._decimated;
              line.points = points;
              const options = this.resolveDatasetElementOptions(mode);
              options.segment = this.options.segment;
              this.updateElement(line, void 0, {
                animated: !animationsDisabled,
                options
              }, mode);
            }
            this.updateElements(points, start, count, mode);
          }
          addElements() {
            const { showLine } = this.options;
            if (!this.datasetElementType && showLine) {
              this.datasetElementType = registry.getElement("line");
            }
            super.addElements();
          }
          updateElements(points, start, count, mode) {
            const reset = mode === "reset";
            const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
            const firstOpts = this.resolveDataElementOptions(start, mode);
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions = this.includeOptions(mode, sharedOptions);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const { spanGaps, segment } = this.options;
            const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
            const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
            let prevParsed = start > 0 && this.getParsed(start - 1);
            for (let i = start; i < start + count; ++i) {
              const point = points[i];
              const parsed = this.getParsed(i);
              const properties = directUpdate ? point : {};
              const nullData = isNullOrUndef(parsed[vAxis]);
              const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
              const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
              properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
              properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
              if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
              }
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
              }
              if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
              }
              prevParsed = parsed;
            }
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
          }
          getMaxOverflow() {
            const meta = this._cachedMeta;
            const data = meta.data || [];
            if (!this.options.showLine) {
              let max = 0;
              for (let i = data.length - 1; i >= 0; --i) {
                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
              }
              return max > 0 && max;
            }
            const dataset = meta.dataset;
            const border = dataset.options && dataset.options.borderWidth || 0;
            if (!data.length) {
              return border;
            }
            const firstPoint = data[0].size(this.resolveDataElementOptions(0));
            const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
            return Math.max(border, firstPoint, lastPoint) / 2;
          }
        }
        ScatterController.id = "scatter";
        ScatterController.defaults = {
          datasetElementType: false,
          dataElementType: "point",
          showLine: false,
          fill: false
        };
        ScatterController.overrides = {
          interaction: {
            mode: "point"
          },
          plugins: {
            tooltip: {
              callbacks: {
                title() {
                  return "";
                },
                label(item) {
                  return "(" + item.label + ", " + item.formattedValue + ")";
                }
              }
            }
          },
          scales: {
            x: {
              type: "linear"
            },
            y: {
              type: "linear"
            }
          }
        };
        var controllers = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          BarController,
          BubbleController,
          DoughnutController,
          LineController,
          PolarAreaController,
          PieController,
          RadarController,
          ScatterController
        });
        function clipArc(ctx, element, endAngle) {
          const { startAngle, pixelMargin, x, y: y2, outerRadius, innerRadius } = element;
          let angleMargin = pixelMargin / outerRadius;
          ctx.beginPath();
          ctx.arc(x, y2, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
          if (innerRadius > pixelMargin) {
            angleMargin = pixelMargin / innerRadius;
            ctx.arc(x, y2, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
          } else {
            ctx.arc(x, y2, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
          }
          ctx.closePath();
          ctx.clip();
        }
        function toRadiusCorners(value) {
          return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
        }
        function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
          const o = toRadiusCorners(arc.options.borderRadius);
          const halfThickness = (outerRadius - innerRadius) / 2;
          const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
          const computeOuterLimit = (val) => {
            const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
            return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
          };
          return {
            outerStart: computeOuterLimit(o.outerStart),
            outerEnd: computeOuterLimit(o.outerEnd),
            innerStart: _limitValue(o.innerStart, 0, innerLimit),
            innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
          };
        }
        function rThetaToXY(r, theta, x, y2) {
          return {
            x: x + r * Math.cos(theta),
            y: y2 + r * Math.sin(theta)
          };
        }
        function pathArc(ctx, element, offset, spacing, end, circular) {
          const { x, y: y2, startAngle: start, pixelMargin, innerRadius: innerR } = element;
          const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
          const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
          let spacingOffset = 0;
          const alpha2 = end - start;
          if (spacing) {
            const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
            const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
            const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
            const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
            spacingOffset = (alpha2 - adjustedAngle) / 2;
          }
          const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
          const angleOffset = (alpha2 - beta) / 2;
          const startAngle = start + angleOffset + spacingOffset;
          const endAngle = end - angleOffset - spacingOffset;
          const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
          const outerStartAdjustedRadius = outerRadius - outerStart;
          const outerEndAdjustedRadius = outerRadius - outerEnd;
          const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
          const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
          const innerStartAdjustedRadius = innerRadius + innerStart;
          const innerEndAdjustedRadius = innerRadius + innerEnd;
          const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
          const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
          ctx.beginPath();
          if (circular) {
            ctx.arc(x, y2, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
            if (outerEnd > 0) {
              const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y2);
              ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
            }
            const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y2);
            ctx.lineTo(p4.x, p4.y);
            if (innerEnd > 0) {
              const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y2);
              ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
            }
            ctx.arc(x, y2, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
            if (innerStart > 0) {
              const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y2);
              ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
            }
            const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y2);
            ctx.lineTo(p8.x, p8.y);
            if (outerStart > 0) {
              const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y2);
              ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
            }
          } else {
            ctx.moveTo(x, y2);
            const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
            const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y2;
            ctx.lineTo(outerStartX, outerStartY);
            const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
            const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y2;
            ctx.lineTo(outerEndX, outerEndY);
          }
          ctx.closePath();
        }
        function drawArc(ctx, element, offset, spacing, circular) {
          const { fullCircles, startAngle, circumference } = element;
          let endAngle = element.endAngle;
          if (fullCircles) {
            pathArc(ctx, element, offset, spacing, startAngle + TAU, circular);
            for (let i = 0; i < fullCircles; ++i) {
              ctx.fill();
            }
            if (!isNaN(circumference)) {
              endAngle = startAngle + circumference % TAU;
              if (circumference % TAU === 0) {
                endAngle += TAU;
              }
            }
          }
          pathArc(ctx, element, offset, spacing, endAngle, circular);
          ctx.fill();
          return endAngle;
        }
        function drawFullCircleBorders(ctx, element, inner) {
          const { x, y: y2, startAngle, pixelMargin, fullCircles } = element;
          const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
          const innerRadius = element.innerRadius + pixelMargin;
          let i;
          if (inner) {
            clipArc(ctx, element, startAngle + TAU);
          }
          ctx.beginPath();
          ctx.arc(x, y2, innerRadius, startAngle + TAU, startAngle, true);
          for (i = 0; i < fullCircles; ++i) {
            ctx.stroke();
          }
          ctx.beginPath();
          ctx.arc(x, y2, outerRadius, startAngle, startAngle + TAU);
          for (i = 0; i < fullCircles; ++i) {
            ctx.stroke();
          }
        }
        function drawBorder(ctx, element, offset, spacing, endAngle, circular) {
          const { options } = element;
          const { borderWidth, borderJoinStyle } = options;
          const inner = options.borderAlign === "inner";
          if (!borderWidth) {
            return;
          }
          if (inner) {
            ctx.lineWidth = borderWidth * 2;
            ctx.lineJoin = borderJoinStyle || "round";
          } else {
            ctx.lineWidth = borderWidth;
            ctx.lineJoin = borderJoinStyle || "bevel";
          }
          if (element.fullCircles) {
            drawFullCircleBorders(ctx, element, inner);
          }
          if (inner) {
            clipArc(ctx, element, endAngle);
          }
          pathArc(ctx, element, offset, spacing, endAngle, circular);
          ctx.stroke();
        }
        class ArcElement extends Element2 {
          constructor(cfg) {
            super();
            this.options = void 0;
            this.circumference = void 0;
            this.startAngle = void 0;
            this.endAngle = void 0;
            this.innerRadius = void 0;
            this.outerRadius = void 0;
            this.pixelMargin = 0;
            this.fullCircles = 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          inRange(chartX, chartY, useFinalPosition) {
            const point = this.getProps(["x", "y"], useFinalPosition);
            const { angle, distance } = getAngleFromPoint(point, { x: chartX, y: chartY });
            const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
              "startAngle",
              "endAngle",
              "innerRadius",
              "outerRadius",
              "circumference"
            ], useFinalPosition);
            const rAdjust = this.options.spacing / 2;
            const _circumference = valueOrDefault(circumference, endAngle - startAngle);
            const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
            const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
            return betweenAngles && withinRadius;
          }
          getCenterPoint(useFinalPosition) {
            const { x, y: y2, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
              "x",
              "y",
              "startAngle",
              "endAngle",
              "innerRadius",
              "outerRadius",
              "circumference"
            ], useFinalPosition);
            const { offset, spacing } = this.options;
            const halfAngle = (startAngle + endAngle) / 2;
            const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
            return {
              x: x + Math.cos(halfAngle) * halfRadius,
              y: y2 + Math.sin(halfAngle) * halfRadius
            };
          }
          tooltipPosition(useFinalPosition) {
            return this.getCenterPoint(useFinalPosition);
          }
          draw(ctx) {
            const { options, circumference } = this;
            const offset = (options.offset || 0) / 2;
            const spacing = (options.spacing || 0) / 2;
            const circular = options.circular;
            this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
            this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
            if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
              return;
            }
            ctx.save();
            let radiusOffset = 0;
            if (offset) {
              radiusOffset = offset / 2;
              const halfAngle = (this.startAngle + this.endAngle) / 2;
              ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
              if (this.circumference >= PI) {
                radiusOffset = offset;
              }
            }
            ctx.fillStyle = options.backgroundColor;
            ctx.strokeStyle = options.borderColor;
            const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);
            drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);
            ctx.restore();
          }
        }
        ArcElement.id = "arc";
        ArcElement.defaults = {
          borderAlign: "center",
          borderColor: "#fff",
          borderJoinStyle: void 0,
          borderRadius: 0,
          borderWidth: 2,
          offset: 0,
          spacing: 0,
          angle: void 0,
          circular: true
        };
        ArcElement.defaultRoutes = {
          backgroundColor: "backgroundColor"
        };
        function setStyle(ctx, options, style = options) {
          ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
          ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
          ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
          ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
          ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
          ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
        }
        function lineTo(ctx, previous, target) {
          ctx.lineTo(target.x, target.y);
        }
        function getLineMethod(options) {
          if (options.stepped) {
            return _steppedLineTo;
          }
          if (options.tension || options.cubicInterpolationMode === "monotone") {
            return _bezierCurveTo;
          }
          return lineTo;
        }
        function pathVars(points, segment, params = {}) {
          const count = points.length;
          const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
          const { start: segmentStart, end: segmentEnd } = segment;
          const start = Math.max(paramsStart, segmentStart);
          const end = Math.min(paramsEnd, segmentEnd);
          const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
          return {
            count,
            start,
            loop: segment.loop,
            ilen: end < start && !outside ? count + end - start : end - start
          };
        }
        function pathSegment(ctx, line, segment, params) {
          const { points, options } = line;
          const { count, start, loop, ilen } = pathVars(points, segment, params);
          const lineMethod = getLineMethod(options);
          let { move = true, reverse } = params || {};
          let i, point, prev;
          for (i = 0; i <= ilen; ++i) {
            point = points[(start + (reverse ? ilen - i : i)) % count];
            if (point.skip) {
              continue;
            } else if (move) {
              ctx.moveTo(point.x, point.y);
              move = false;
            } else {
              lineMethod(ctx, prev, point, reverse, options.stepped);
            }
            prev = point;
          }
          if (loop) {
            point = points[(start + (reverse ? ilen : 0)) % count];
            lineMethod(ctx, prev, point, reverse, options.stepped);
          }
          return !!loop;
        }
        function fastPathSegment(ctx, line, segment, params) {
          const points = line.points;
          const { count, start, ilen } = pathVars(points, segment, params);
          const { move = true, reverse } = params || {};
          let avgX = 0;
          let countX = 0;
          let i, point, prevX, minY, maxY, lastY;
          const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
          const drawX = () => {
            if (minY !== maxY) {
              ctx.lineTo(avgX, maxY);
              ctx.lineTo(avgX, minY);
              ctx.lineTo(avgX, lastY);
            }
          };
          if (move) {
            point = points[pointIndex(0)];
            ctx.moveTo(point.x, point.y);
          }
          for (i = 0; i <= ilen; ++i) {
            point = points[pointIndex(i)];
            if (point.skip) {
              continue;
            }
            const x = point.x;
            const y2 = point.y;
            const truncX = x | 0;
            if (truncX === prevX) {
              if (y2 < minY) {
                minY = y2;
              } else if (y2 > maxY) {
                maxY = y2;
              }
              avgX = (countX * avgX + x) / ++countX;
            } else {
              drawX();
              ctx.lineTo(x, y2);
              prevX = truncX;
              countX = 0;
              minY = maxY = y2;
            }
            lastY = y2;
          }
          drawX();
        }
        function _getSegmentMethod(line) {
          const opts = line.options;
          const borderDash = opts.borderDash && opts.borderDash.length;
          const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
          return useFastPath ? fastPathSegment : pathSegment;
        }
        function _getInterpolationMethod(options) {
          if (options.stepped) {
            return _steppedInterpolation;
          }
          if (options.tension || options.cubicInterpolationMode === "monotone") {
            return _bezierInterpolation;
          }
          return _pointInLine;
        }
        function strokePathWithCache(ctx, line, start, count) {
          let path = line._path;
          if (!path) {
            path = line._path = new Path2D();
            if (line.path(path, start, count)) {
              path.closePath();
            }
          }
          setStyle(ctx, line.options);
          ctx.stroke(path);
        }
        function strokePathDirect(ctx, line, start, count) {
          const { segments, options } = line;
          const segmentMethod = _getSegmentMethod(line);
          for (const segment of segments) {
            setStyle(ctx, options, segment.style);
            ctx.beginPath();
            if (segmentMethod(ctx, line, segment, { start, end: start + count - 1 })) {
              ctx.closePath();
            }
            ctx.stroke();
          }
        }
        const usePath2D = typeof Path2D === "function";
        function draw(ctx, line, start, count) {
          if (usePath2D && !line.options.segment) {
            strokePathWithCache(ctx, line, start, count);
          } else {
            strokePathDirect(ctx, line, start, count);
          }
        }
        class LineElement extends Element2 {
          constructor(cfg) {
            super();
            this.animated = true;
            this.options = void 0;
            this._chart = void 0;
            this._loop = void 0;
            this._fullLoop = void 0;
            this._path = void 0;
            this._points = void 0;
            this._segments = void 0;
            this._decimated = false;
            this._pointsUpdated = false;
            this._datasetIndex = void 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          updateControlPoints(chartArea, indexAxis) {
            const options = this.options;
            if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
              const loop = options.spanGaps ? this._loop : this._fullLoop;
              _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
              this._pointsUpdated = true;
            }
          }
          set points(points) {
            this._points = points;
            delete this._segments;
            delete this._path;
            this._pointsUpdated = false;
          }
          get points() {
            return this._points;
          }
          get segments() {
            return this._segments || (this._segments = _computeSegments(this, this.options.segment));
          }
          first() {
            const segments = this.segments;
            const points = this.points;
            return segments.length && points[segments[0].start];
          }
          last() {
            const segments = this.segments;
            const points = this.points;
            const count = segments.length;
            return count && points[segments[count - 1].end];
          }
          interpolate(point, property) {
            const options = this.options;
            const value = point[property];
            const points = this.points;
            const segments = _boundSegments(this, { property, start: value, end: value });
            if (!segments.length) {
              return;
            }
            const result = [];
            const _interpolate = _getInterpolationMethod(options);
            let i, ilen;
            for (i = 0, ilen = segments.length; i < ilen; ++i) {
              const { start, end } = segments[i];
              const p1 = points[start];
              const p2 = points[end];
              if (p1 === p2) {
                result.push(p1);
                continue;
              }
              const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
              const interpolated = _interpolate(p1, p2, t, options.stepped);
              interpolated[property] = point[property];
              result.push(interpolated);
            }
            return result.length === 1 ? result[0] : result;
          }
          pathSegment(ctx, segment, params) {
            const segmentMethod = _getSegmentMethod(this);
            return segmentMethod(ctx, this, segment, params);
          }
          path(ctx, start, count) {
            const segments = this.segments;
            const segmentMethod = _getSegmentMethod(this);
            let loop = this._loop;
            start = start || 0;
            count = count || this.points.length - start;
            for (const segment of segments) {
              loop &= segmentMethod(ctx, this, segment, { start, end: start + count - 1 });
            }
            return !!loop;
          }
          draw(ctx, chartArea, start, count) {
            const options = this.options || {};
            const points = this.points || [];
            if (points.length && options.borderWidth) {
              ctx.save();
              draw(ctx, this, start, count);
              ctx.restore();
            }
            if (this.animated) {
              this._pointsUpdated = false;
              this._path = void 0;
            }
          }
        }
        LineElement.id = "line";
        LineElement.defaults = {
          borderCapStyle: "butt",
          borderDash: [],
          borderDashOffset: 0,
          borderJoinStyle: "miter",
          borderWidth: 3,
          capBezierPoints: true,
          cubicInterpolationMode: "default",
          fill: false,
          spanGaps: false,
          stepped: false,
          tension: 0
        };
        LineElement.defaultRoutes = {
          backgroundColor: "backgroundColor",
          borderColor: "borderColor"
        };
        LineElement.descriptors = {
          _scriptable: true,
          _indexable: (name) => name !== "borderDash" && name !== "fill"
        };
        function inRange$1(el2, pos, axis, useFinalPosition) {
          const options = el2.options;
          const { [axis]: value } = el2.getProps([axis], useFinalPosition);
          return Math.abs(pos - value) < options.radius + options.hitRadius;
        }
        class PointElement extends Element2 {
          constructor(cfg) {
            super();
            this.options = void 0;
            this.parsed = void 0;
            this.skip = void 0;
            this.stop = void 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          inRange(mouseX, mouseY, useFinalPosition) {
            const options = this.options;
            const { x, y: y2 } = this.getProps(["x", "y"], useFinalPosition);
            return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y2, 2) < Math.pow(options.hitRadius + options.radius, 2);
          }
          inXRange(mouseX, useFinalPosition) {
            return inRange$1(this, mouseX, "x", useFinalPosition);
          }
          inYRange(mouseY, useFinalPosition) {
            return inRange$1(this, mouseY, "y", useFinalPosition);
          }
          getCenterPoint(useFinalPosition) {
            const { x, y: y2 } = this.getProps(["x", "y"], useFinalPosition);
            return { x, y: y2 };
          }
          size(options) {
            options = options || this.options || {};
            let radius = options.radius || 0;
            radius = Math.max(radius, radius && options.hoverRadius || 0);
            const borderWidth = radius && options.borderWidth || 0;
            return (radius + borderWidth) * 2;
          }
          draw(ctx, area) {
            const options = this.options;
            if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
              return;
            }
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.fillStyle = options.backgroundColor;
            drawPoint(ctx, options, this.x, this.y);
          }
          getRange() {
            const options = this.options || {};
            return options.radius + options.hitRadius;
          }
        }
        PointElement.id = "point";
        PointElement.defaults = {
          borderWidth: 1,
          hitRadius: 1,
          hoverBorderWidth: 1,
          hoverRadius: 4,
          pointStyle: "circle",
          radius: 3,
          rotation: 0
        };
        PointElement.defaultRoutes = {
          backgroundColor: "backgroundColor",
          borderColor: "borderColor"
        };
        function getBarBounds(bar, useFinalPosition) {
          const { x, y: y2, base, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
          let left, right, top, bottom, half;
          if (bar.horizontal) {
            half = height / 2;
            left = Math.min(x, base);
            right = Math.max(x, base);
            top = y2 - half;
            bottom = y2 + half;
          } else {
            half = width / 2;
            left = x - half;
            right = x + half;
            top = Math.min(y2, base);
            bottom = Math.max(y2, base);
          }
          return { left, top, right, bottom };
        }
        function skipOrLimit(skip2, value, min, max) {
          return skip2 ? 0 : _limitValue(value, min, max);
        }
        function parseBorderWidth(bar, maxW, maxH) {
          const value = bar.options.borderWidth;
          const skip2 = bar.borderSkipped;
          const o = toTRBL(value);
          return {
            t: skipOrLimit(skip2.top, o.top, 0, maxH),
            r: skipOrLimit(skip2.right, o.right, 0, maxW),
            b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
            l: skipOrLimit(skip2.left, o.left, 0, maxW)
          };
        }
        function parseBorderRadius(bar, maxW, maxH) {
          const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
          const value = bar.options.borderRadius;
          const o = toTRBLCorners(value);
          const maxR = Math.min(maxW, maxH);
          const skip2 = bar.borderSkipped;
          const enableBorder = enableBorderRadius || isObject(value);
          return {
            topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
            topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
            bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
            bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
          };
        }
        function boundingRects(bar) {
          const bounds = getBarBounds(bar);
          const width = bounds.right - bounds.left;
          const height = bounds.bottom - bounds.top;
          const border = parseBorderWidth(bar, width / 2, height / 2);
          const radius = parseBorderRadius(bar, width / 2, height / 2);
          return {
            outer: {
              x: bounds.left,
              y: bounds.top,
              w: width,
              h: height,
              radius
            },
            inner: {
              x: bounds.left + border.l,
              y: bounds.top + border.t,
              w: width - border.l - border.r,
              h: height - border.t - border.b,
              radius: {
                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
              }
            }
          };
        }
        function inRange(bar, x, y2, useFinalPosition) {
          const skipX = x === null;
          const skipY = y2 === null;
          const skipBoth = skipX && skipY;
          const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
          return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y2, bounds.top, bounds.bottom));
        }
        function hasRadius(radius) {
          return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
        }
        function addNormalRectPath(ctx, rect) {
          ctx.rect(rect.x, rect.y, rect.w, rect.h);
        }
        function inflateRect(rect, amount, refRect = {}) {
          const x = rect.x !== refRect.x ? -amount : 0;
          const y2 = rect.y !== refRect.y ? -amount : 0;
          const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
          const h3 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y2;
          return {
            x: rect.x + x,
            y: rect.y + y2,
            w: rect.w + w,
            h: rect.h + h3,
            radius: rect.radius
          };
        }
        class BarElement extends Element2 {
          constructor(cfg) {
            super();
            this.options = void 0;
            this.horizontal = void 0;
            this.base = void 0;
            this.width = void 0;
            this.height = void 0;
            this.inflateAmount = void 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          draw(ctx) {
            const { inflateAmount, options: { borderColor, backgroundColor } } = this;
            const { inner, outer } = boundingRects(this);
            const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
            ctx.save();
            if (outer.w !== inner.w || outer.h !== inner.h) {
              ctx.beginPath();
              addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
              ctx.clip();
              addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
              ctx.fillStyle = borderColor;
              ctx.fill("evenodd");
            }
            ctx.beginPath();
            addRectPath(ctx, inflateRect(inner, inflateAmount));
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
          }
          inRange(mouseX, mouseY, useFinalPosition) {
            return inRange(this, mouseX, mouseY, useFinalPosition);
          }
          inXRange(mouseX, useFinalPosition) {
            return inRange(this, mouseX, null, useFinalPosition);
          }
          inYRange(mouseY, useFinalPosition) {
            return inRange(this, null, mouseY, useFinalPosition);
          }
          getCenterPoint(useFinalPosition) {
            const { x, y: y2, base, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
            return {
              x: horizontal ? (x + base) / 2 : x,
              y: horizontal ? y2 : (y2 + base) / 2
            };
          }
          getRange(axis) {
            return axis === "x" ? this.width / 2 : this.height / 2;
          }
        }
        BarElement.id = "bar";
        BarElement.defaults = {
          borderSkipped: "start",
          borderWidth: 0,
          borderRadius: 0,
          inflateAmount: "auto",
          pointStyle: void 0
        };
        BarElement.defaultRoutes = {
          backgroundColor: "backgroundColor",
          borderColor: "borderColor"
        };
        var elements = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          ArcElement,
          LineElement,
          PointElement,
          BarElement
        });
        function lttbDecimation(data, start, count, availableWidth, options) {
          const samples = options.samples || availableWidth;
          if (samples >= count) {
            return data.slice(start, start + count);
          }
          const decimated = [];
          const bucketWidth = (count - 2) / (samples - 2);
          let sampledIndex = 0;
          const endIndex = start + count - 1;
          let a = start;
          let i, maxAreaPoint, maxArea, area, nextA;
          decimated[sampledIndex++] = data[a];
          for (i = 0; i < samples - 2; i++) {
            let avgX = 0;
            let avgY = 0;
            let j2;
            const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
            const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
            const avgRangeLength = avgRangeEnd - avgRangeStart;
            for (j2 = avgRangeStart; j2 < avgRangeEnd; j2++) {
              avgX += data[j2].x;
              avgY += data[j2].y;
            }
            avgX /= avgRangeLength;
            avgY /= avgRangeLength;
            const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
            const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
            const { x: pointAx, y: pointAy } = data[a];
            maxArea = area = -1;
            for (j2 = rangeOffs; j2 < rangeTo; j2++) {
              area = 0.5 * Math.abs((pointAx - avgX) * (data[j2].y - pointAy) - (pointAx - data[j2].x) * (avgY - pointAy));
              if (area > maxArea) {
                maxArea = area;
                maxAreaPoint = data[j2];
                nextA = j2;
              }
            }
            decimated[sampledIndex++] = maxAreaPoint;
            a = nextA;
          }
          decimated[sampledIndex++] = data[endIndex];
          return decimated;
        }
        function minMaxDecimation(data, start, count, availableWidth) {
          let avgX = 0;
          let countX = 0;
          let i, point, x, y2, prevX, minIndex, maxIndex, startIndex, minY, maxY;
          const decimated = [];
          const endIndex = start + count - 1;
          const xMin = data[start].x;
          const xMax = data[endIndex].x;
          const dx = xMax - xMin;
          for (i = start; i < start + count; ++i) {
            point = data[i];
            x = (point.x - xMin) / dx * availableWidth;
            y2 = point.y;
            const truncX = x | 0;
            if (truncX === prevX) {
              if (y2 < minY) {
                minY = y2;
                minIndex = i;
              } else if (y2 > maxY) {
                maxY = y2;
                maxIndex = i;
              }
              avgX = (countX * avgX + point.x) / ++countX;
            } else {
              const lastIndex = i - 1;
              if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
                const intermediateIndex1 = Math.min(minIndex, maxIndex);
                const intermediateIndex2 = Math.max(minIndex, maxIndex);
                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
                  decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex1]), {
                    x: avgX
                  }));
                }
                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
                  decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex2]), {
                    x: avgX
                  }));
                }
              }
              if (i > 0 && lastIndex !== startIndex) {
                decimated.push(data[lastIndex]);
              }
              decimated.push(point);
              prevX = truncX;
              countX = 0;
              minY = maxY = y2;
              minIndex = maxIndex = startIndex = i;
            }
          }
          return decimated;
        }
        function cleanDecimatedDataset(dataset) {
          if (dataset._decimated) {
            const data = dataset._data;
            delete dataset._decimated;
            delete dataset._data;
            Object.defineProperty(dataset, "data", { value: data });
          }
        }
        function cleanDecimatedData(chart) {
          chart.data.datasets.forEach((dataset) => {
            cleanDecimatedDataset(dataset);
          });
        }
        function getStartAndCountOfVisiblePointsSimplified(meta, points) {
          const pointCount = points.length;
          let start = 0;
          let count;
          const { iScale } = meta;
          const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
          if (minDefined) {
            start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
          }
          if (maxDefined) {
            count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
          } else {
            count = pointCount - start;
          }
          return { start, count };
        }
        var plugin_decimation = {
          id: "decimation",
          defaults: {
            algorithm: "min-max",
            enabled: false
          },
          beforeElementsUpdate: (chart, args, options) => {
            if (!options.enabled) {
              cleanDecimatedData(chart);
              return;
            }
            const availableWidth = chart.width;
            chart.data.datasets.forEach((dataset, datasetIndex) => {
              const { _data, indexAxis } = dataset;
              const meta = chart.getDatasetMeta(datasetIndex);
              const data = _data || dataset.data;
              if (resolve([indexAxis, chart.options.indexAxis]) === "y") {
                return;
              }
              if (!meta.controller.supportsDecimation) {
                return;
              }
              const xAxis = chart.scales[meta.xAxisID];
              if (xAxis.type !== "linear" && xAxis.type !== "time") {
                return;
              }
              if (chart.options.parsing) {
                return;
              }
              let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
              const threshold = options.threshold || 4 * availableWidth;
              if (count <= threshold) {
                cleanDecimatedDataset(dataset);
                return;
              }
              if (isNullOrUndef(_data)) {
                dataset._data = data;
                delete dataset.data;
                Object.defineProperty(dataset, "data", {
                  configurable: true,
                  enumerable: true,
                  get: function() {
                    return this._decimated;
                  },
                  set: function(d2) {
                    this._data = d2;
                  }
                });
              }
              let decimated;
              switch (options.algorithm) {
                case "lttb":
                  decimated = lttbDecimation(data, start, count, availableWidth, options);
                  break;
                case "min-max":
                  decimated = minMaxDecimation(data, start, count, availableWidth);
                  break;
                default:
                  throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
              }
              dataset._decimated = decimated;
            });
          },
          destroy(chart) {
            cleanDecimatedData(chart);
          }
        };
        function _segments(line, target, property) {
          const segments = line.segments;
          const points = line.points;
          const tpoints = target.points;
          const parts = [];
          for (const segment of segments) {
            let { start, end } = segment;
            end = _findSegmentEnd(start, end, points);
            const bounds = _getBounds(property, points[start], points[end], segment.loop);
            if (!target.segments) {
              parts.push({
                source: segment,
                target: bounds,
                start: points[start],
                end: points[end]
              });
              continue;
            }
            const targetSegments = _boundSegments(target, bounds);
            for (const tgt of targetSegments) {
              const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
              const fillSources = _boundSegment(segment, points, subBounds);
              for (const fillSource of fillSources) {
                parts.push({
                  source: fillSource,
                  target: tgt,
                  start: {
                    [property]: _getEdge(bounds, subBounds, "start", Math.max)
                  },
                  end: {
                    [property]: _getEdge(bounds, subBounds, "end", Math.min)
                  }
                });
              }
            }
          }
          return parts;
        }
        function _getBounds(property, first, last, loop) {
          if (loop) {
            return;
          }
          let start = first[property];
          let end = last[property];
          if (property === "angle") {
            start = _normalizeAngle(start);
            end = _normalizeAngle(end);
          }
          return { property, start, end };
        }
        function _pointsFromSegments(boundary, line) {
          const { x = null, y: y2 = null } = boundary || {};
          const linePoints = line.points;
          const points = [];
          line.segments.forEach(({ start, end }) => {
            end = _findSegmentEnd(start, end, linePoints);
            const first = linePoints[start];
            const last = linePoints[end];
            if (y2 !== null) {
              points.push({ x: first.x, y: y2 });
              points.push({ x: last.x, y: y2 });
            } else if (x !== null) {
              points.push({ x, y: first.y });
              points.push({ x, y: last.y });
            }
          });
          return points;
        }
        function _findSegmentEnd(start, end, points) {
          for (; end > start; end--) {
            const point = points[end];
            if (!isNaN(point.x) && !isNaN(point.y)) {
              break;
            }
          }
          return end;
        }
        function _getEdge(a, b, prop, fn2) {
          if (a && b) {
            return fn2(a[prop], b[prop]);
          }
          return a ? a[prop] : b ? b[prop] : 0;
        }
        function _createBoundaryLine(boundary, line) {
          let points = [];
          let _loop = false;
          if (isArray(boundary)) {
            _loop = true;
            points = boundary;
          } else {
            points = _pointsFromSegments(boundary, line);
          }
          return points.length ? new LineElement({
            points,
            options: { tension: 0 },
            _loop,
            _fullLoop: _loop
          }) : null;
        }
        function _shouldApplyFill(source) {
          return source && source.fill !== false;
        }
        function _resolveTarget(sources, index2, propagate) {
          const source = sources[index2];
          let fill2 = source.fill;
          const visited = [index2];
          let target;
          if (!propagate) {
            return fill2;
          }
          while (fill2 !== false && visited.indexOf(fill2) === -1) {
            if (!isNumberFinite(fill2)) {
              return fill2;
            }
            target = sources[fill2];
            if (!target) {
              return false;
            }
            if (target.visible) {
              return fill2;
            }
            visited.push(fill2);
            fill2 = target.fill;
          }
          return false;
        }
        function _decodeFill(line, index2, count) {
          const fill2 = parseFillOption(line);
          if (isObject(fill2)) {
            return isNaN(fill2.value) ? false : fill2;
          }
          let target = parseFloat(fill2);
          if (isNumberFinite(target) && Math.floor(target) === target) {
            return decodeTargetIndex(fill2[0], index2, target, count);
          }
          return ["origin", "start", "end", "stack", "shape"].indexOf(fill2) >= 0 && fill2;
        }
        function decodeTargetIndex(firstCh, index2, target, count) {
          if (firstCh === "-" || firstCh === "+") {
            target = index2 + target;
          }
          if (target === index2 || target < 0 || target >= count) {
            return false;
          }
          return target;
        }
        function _getTargetPixel(fill2, scale) {
          let pixel = null;
          if (fill2 === "start") {
            pixel = scale.bottom;
          } else if (fill2 === "end") {
            pixel = scale.top;
          } else if (isObject(fill2)) {
            pixel = scale.getPixelForValue(fill2.value);
          } else if (scale.getBasePixel) {
            pixel = scale.getBasePixel();
          }
          return pixel;
        }
        function _getTargetValue(fill2, scale, startValue) {
          let value;
          if (fill2 === "start") {
            value = startValue;
          } else if (fill2 === "end") {
            value = scale.options.reverse ? scale.min : scale.max;
          } else if (isObject(fill2)) {
            value = fill2.value;
          } else {
            value = scale.getBaseValue();
          }
          return value;
        }
        function parseFillOption(line) {
          const options = line.options;
          const fillOption = options.fill;
          let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
          if (fill2 === void 0) {
            fill2 = !!options.backgroundColor;
          }
          if (fill2 === false || fill2 === null) {
            return false;
          }
          if (fill2 === true) {
            return "origin";
          }
          return fill2;
        }
        function _buildStackLine(source) {
          const { scale, index: index2, line } = source;
          const points = [];
          const segments = line.segments;
          const sourcePoints = line.points;
          const linesBelow = getLinesBelow(scale, index2);
          linesBelow.push(_createBoundaryLine({ x: null, y: scale.bottom }, line));
          for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            for (let j2 = segment.start; j2 <= segment.end; j2++) {
              addPointsBelow(points, sourcePoints[j2], linesBelow);
            }
          }
          return new LineElement({ points, options: {} });
        }
        function getLinesBelow(scale, index2) {
          const below = [];
          const metas = scale.getMatchingVisibleMetas("line");
          for (let i = 0; i < metas.length; i++) {
            const meta = metas[i];
            if (meta.index === index2) {
              break;
            }
            if (!meta.hidden) {
              below.unshift(meta.dataset);
            }
          }
          return below;
        }
        function addPointsBelow(points, sourcePoint, linesBelow) {
          const postponed = [];
          for (let j2 = 0; j2 < linesBelow.length; j2++) {
            const line = linesBelow[j2];
            const { first, last, point } = findPoint(line, sourcePoint, "x");
            if (!point || first && last) {
              continue;
            }
            if (first) {
              postponed.unshift(point);
            } else {
              points.push(point);
              if (!last) {
                break;
              }
            }
          }
          points.push(...postponed);
        }
        function findPoint(line, sourcePoint, property) {
          const point = line.interpolate(sourcePoint, property);
          if (!point) {
            return {};
          }
          const pointValue = point[property];
          const segments = line.segments;
          const linePoints = line.points;
          let first = false;
          let last = false;
          for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            const firstValue = linePoints[segment.start][property];
            const lastValue = linePoints[segment.end][property];
            if (_isBetween(pointValue, firstValue, lastValue)) {
              first = pointValue === firstValue;
              last = pointValue === lastValue;
              break;
            }
          }
          return { first, last, point };
        }
        class simpleArc {
          constructor(opts) {
            this.x = opts.x;
            this.y = opts.y;
            this.radius = opts.radius;
          }
          pathSegment(ctx, bounds, opts) {
            const { x, y: y2, radius } = this;
            bounds = bounds || { start: 0, end: TAU };
            ctx.arc(x, y2, radius, bounds.end, bounds.start, true);
            return !opts.bounds;
          }
          interpolate(point) {
            const { x, y: y2, radius } = this;
            const angle = point.angle;
            return {
              x: x + Math.cos(angle) * radius,
              y: y2 + Math.sin(angle) * radius,
              angle
            };
          }
        }
        function _getTarget(source) {
          const { chart, fill: fill2, line } = source;
          if (isNumberFinite(fill2)) {
            return getLineByIndex(chart, fill2);
          }
          if (fill2 === "stack") {
            return _buildStackLine(source);
          }
          if (fill2 === "shape") {
            return true;
          }
          const boundary = computeBoundary(source);
          if (boundary instanceof simpleArc) {
            return boundary;
          }
          return _createBoundaryLine(boundary, line);
        }
        function getLineByIndex(chart, index2) {
          const meta = chart.getDatasetMeta(index2);
          const visible = meta && chart.isDatasetVisible(index2);
          return visible ? meta.dataset : null;
        }
        function computeBoundary(source) {
          const scale = source.scale || {};
          if (scale.getPointPositionForValue) {
            return computeCircularBoundary(source);
          }
          return computeLinearBoundary(source);
        }
        function computeLinearBoundary(source) {
          const { scale = {}, fill: fill2 } = source;
          const pixel = _getTargetPixel(fill2, scale);
          if (isNumberFinite(pixel)) {
            const horizontal = scale.isHorizontal();
            return {
              x: horizontal ? pixel : null,
              y: horizontal ? null : pixel
            };
          }
          return null;
        }
        function computeCircularBoundary(source) {
          const { scale, fill: fill2 } = source;
          const options = scale.options;
          const length = scale.getLabels().length;
          const start = options.reverse ? scale.max : scale.min;
          const value = _getTargetValue(fill2, scale, start);
          const target = [];
          if (options.grid.circular) {
            const center = scale.getPointPositionForValue(0, start);
            return new simpleArc({
              x: center.x,
              y: center.y,
              radius: scale.getDistanceFromCenterForValue(value)
            });
          }
          for (let i = 0; i < length; ++i) {
            target.push(scale.getPointPositionForValue(i, value));
          }
          return target;
        }
        function _drawfill(ctx, source, area) {
          const target = _getTarget(source);
          const { line, scale, axis } = source;
          const lineOpts = line.options;
          const fillOption = lineOpts.fill;
          const color2 = lineOpts.backgroundColor;
          const { above = color2, below = color2 } = fillOption || {};
          if (target && line.points.length) {
            clipArea(ctx, area);
            doFill(ctx, { line, target, above, below, area, scale, axis });
            unclipArea(ctx);
          }
        }
        function doFill(ctx, cfg) {
          const { line, target, above, below, area, scale } = cfg;
          const property = line._loop ? "angle" : cfg.axis;
          ctx.save();
          if (property === "x" && below !== above) {
            clipVertical(ctx, target, area.top);
            fill(ctx, { line, target, color: above, scale, property });
            ctx.restore();
            ctx.save();
            clipVertical(ctx, target, area.bottom);
          }
          fill(ctx, { line, target, color: below, scale, property });
          ctx.restore();
        }
        function clipVertical(ctx, target, clipY) {
          const { segments, points } = target;
          let first = true;
          let lineLoop = false;
          ctx.beginPath();
          for (const segment of segments) {
            const { start, end } = segment;
            const firstPoint = points[start];
            const lastPoint = points[_findSegmentEnd(start, end, points)];
            if (first) {
              ctx.moveTo(firstPoint.x, firstPoint.y);
              first = false;
            } else {
              ctx.lineTo(firstPoint.x, clipY);
              ctx.lineTo(firstPoint.x, firstPoint.y);
            }
            lineLoop = !!target.pathSegment(ctx, segment, { move: lineLoop });
            if (lineLoop) {
              ctx.closePath();
            } else {
              ctx.lineTo(lastPoint.x, clipY);
            }
          }
          ctx.lineTo(target.first().x, clipY);
          ctx.closePath();
          ctx.clip();
        }
        function fill(ctx, cfg) {
          const { line, target, property, color: color2, scale } = cfg;
          const segments = _segments(line, target, property);
          for (const { source: src, target: tgt, start, end } of segments) {
            const { style: { backgroundColor = color2 } = {} } = src;
            const notShape = target !== true;
            ctx.save();
            ctx.fillStyle = backgroundColor;
            clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
            ctx.beginPath();
            const lineLoop = !!line.pathSegment(ctx, src);
            let loop;
            if (notShape) {
              if (lineLoop) {
                ctx.closePath();
              } else {
                interpolatedLineTo(ctx, target, end, property);
              }
              const targetLoop = !!target.pathSegment(ctx, tgt, { move: lineLoop, reverse: true });
              loop = lineLoop && targetLoop;
              if (!loop) {
                interpolatedLineTo(ctx, target, start, property);
              }
            }
            ctx.closePath();
            ctx.fill(loop ? "evenodd" : "nonzero");
            ctx.restore();
          }
        }
        function clipBounds(ctx, scale, bounds) {
          const { top, bottom } = scale.chart.chartArea;
          const { property, start, end } = bounds || {};
          if (property === "x") {
            ctx.beginPath();
            ctx.rect(start, top, end - start, bottom - top);
            ctx.clip();
          }
        }
        function interpolatedLineTo(ctx, target, point, property) {
          const interpolatedPoint = target.interpolate(point, property);
          if (interpolatedPoint) {
            ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
          }
        }
        var index = {
          id: "filler",
          afterDatasetsUpdate(chart, _args, options) {
            const count = (chart.data.datasets || []).length;
            const sources = [];
            let meta, i, line, source;
            for (i = 0; i < count; ++i) {
              meta = chart.getDatasetMeta(i);
              line = meta.dataset;
              source = null;
              if (line && line.options && line instanceof LineElement) {
                source = {
                  visible: chart.isDatasetVisible(i),
                  index: i,
                  fill: _decodeFill(line, i, count),
                  chart,
                  axis: meta.controller.options.indexAxis,
                  scale: meta.vScale,
                  line
                };
              }
              meta.$filler = source;
              sources.push(source);
            }
            for (i = 0; i < count; ++i) {
              source = sources[i];
              if (!source || source.fill === false) {
                continue;
              }
              source.fill = _resolveTarget(sources, i, options.propagate);
            }
          },
          beforeDraw(chart, _args, options) {
            const draw2 = options.drawTime === "beforeDraw";
            const metasets = chart.getSortedVisibleDatasetMetas();
            const area = chart.chartArea;
            for (let i = metasets.length - 1; i >= 0; --i) {
              const source = metasets[i].$filler;
              if (!source) {
                continue;
              }
              source.line.updateControlPoints(area, source.axis);
              if (draw2 && source.fill) {
                _drawfill(chart.ctx, source, area);
              }
            }
          },
          beforeDatasetsDraw(chart, _args, options) {
            if (options.drawTime !== "beforeDatasetsDraw") {
              return;
            }
            const metasets = chart.getSortedVisibleDatasetMetas();
            for (let i = metasets.length - 1; i >= 0; --i) {
              const source = metasets[i].$filler;
              if (_shouldApplyFill(source)) {
                _drawfill(chart.ctx, source, chart.chartArea);
              }
            }
          },
          beforeDatasetDraw(chart, args, options) {
            const source = args.meta.$filler;
            if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
              return;
            }
            _drawfill(chart.ctx, source, chart.chartArea);
          },
          defaults: {
            propagate: true,
            drawTime: "beforeDatasetDraw"
          }
        };
        const getBoxSize = (labelOpts, fontSize) => {
          let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
          if (labelOpts.usePointStyle) {
            boxHeight = Math.min(boxHeight, fontSize);
            boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
          }
          return {
            boxWidth,
            boxHeight,
            itemHeight: Math.max(fontSize, boxHeight)
          };
        };
        const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
        class Legend extends Element2 {
          constructor(config) {
            super();
            this._added = false;
            this.legendHitBoxes = [];
            this._hoveredItem = null;
            this.doughnutMode = false;
            this.chart = config.chart;
            this.options = config.options;
            this.ctx = config.ctx;
            this.legendItems = void 0;
            this.columnSizes = void 0;
            this.lineWidths = void 0;
            this.maxHeight = void 0;
            this.maxWidth = void 0;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.height = void 0;
            this.width = void 0;
            this._margins = void 0;
            this.position = void 0;
            this.weight = void 0;
            this.fullSize = void 0;
          }
          update(maxWidth, maxHeight, margins) {
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this._margins = margins;
            this.setDimensions();
            this.buildLabels();
            this.fit();
          }
          setDimensions() {
            if (this.isHorizontal()) {
              this.width = this.maxWidth;
              this.left = this._margins.left;
              this.right = this.width;
            } else {
              this.height = this.maxHeight;
              this.top = this._margins.top;
              this.bottom = this.height;
            }
          }
          buildLabels() {
            const labelOpts = this.options.labels || {};
            let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
            if (labelOpts.filter) {
              legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
            }
            if (labelOpts.sort) {
              legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
            }
            if (this.options.reverse) {
              legendItems.reverse();
            }
            this.legendItems = legendItems;
          }
          fit() {
            const { options, ctx } = this;
            if (!options.display) {
              this.width = this.height = 0;
              return;
            }
            const labelOpts = options.labels;
            const labelFont = toFont(labelOpts.font);
            const fontSize = labelFont.size;
            const titleHeight = this._computeTitleHeight();
            const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
            let width, height;
            ctx.font = labelFont.string;
            if (this.isHorizontal()) {
              width = this.maxWidth;
              height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
            } else {
              height = this.maxHeight;
              width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
            }
            this.width = Math.min(width, options.maxWidth || this.maxWidth);
            this.height = Math.min(height, options.maxHeight || this.maxHeight);
          }
          _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
            const { ctx, maxWidth, options: { labels: { padding } } } = this;
            const hitboxes = this.legendHitBoxes = [];
            const lineWidths = this.lineWidths = [0];
            const lineHeight = itemHeight + padding;
            let totalHeight = titleHeight;
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            let row = -1;
            let top = -lineHeight;
            this.legendItems.forEach((legendItem, i) => {
              const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
              if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
                totalHeight += lineHeight;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                top += lineHeight;
                row++;
              }
              hitboxes[i] = { left: 0, top, row, width: itemWidth, height: itemHeight };
              lineWidths[lineWidths.length - 1] += itemWidth + padding;
            });
            return totalHeight;
          }
          _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
            const { ctx, maxHeight, options: { labels: { padding } } } = this;
            const hitboxes = this.legendHitBoxes = [];
            const columnSizes = this.columnSizes = [];
            const heightLimit = maxHeight - titleHeight;
            let totalWidth = padding;
            let currentColWidth = 0;
            let currentColHeight = 0;
            let left = 0;
            let col = 0;
            this.legendItems.forEach((legendItem, i) => {
              const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
              if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
                totalWidth += currentColWidth + padding;
                columnSizes.push({ width: currentColWidth, height: currentColHeight });
                left += currentColWidth + padding;
                col++;
                currentColWidth = currentColHeight = 0;
              }
              hitboxes[i] = { left, top: currentColHeight, col, width: itemWidth, height: itemHeight };
              currentColWidth = Math.max(currentColWidth, itemWidth);
              currentColHeight += itemHeight + padding;
            });
            totalWidth += currentColWidth;
            columnSizes.push({ width: currentColWidth, height: currentColHeight });
            return totalWidth;
          }
          adjustHitBoxes() {
            if (!this.options.display) {
              return;
            }
            const titleHeight = this._computeTitleHeight();
            const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
            const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
            if (this.isHorizontal()) {
              let row = 0;
              let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
              for (const hitbox of hitboxes) {
                if (row !== hitbox.row) {
                  row = hitbox.row;
                  left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
                }
                hitbox.top += this.top + titleHeight + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
                left += hitbox.width + padding;
              }
            } else {
              let col = 0;
              let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
              for (const hitbox of hitboxes) {
                if (hitbox.col !== col) {
                  col = hitbox.col;
                  top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                }
                hitbox.top = top;
                hitbox.left += this.left + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
                top += hitbox.height + padding;
              }
            }
          }
          isHorizontal() {
            return this.options.position === "top" || this.options.position === "bottom";
          }
          draw() {
            if (this.options.display) {
              const ctx = this.ctx;
              clipArea(ctx, this);
              this._draw();
              unclipArea(ctx);
            }
          }
          _draw() {
            const { options: opts, columnSizes, lineWidths, ctx } = this;
            const { align, labels: labelOpts } = opts;
            const defaultColor = defaults.color;
            const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
            const labelFont = toFont(labelOpts.font);
            const { color: fontColor, padding } = labelOpts;
            const fontSize = labelFont.size;
            const halfFontSize = fontSize / 2;
            let cursor;
            this.drawTitle();
            ctx.textAlign = rtlHelper.textAlign("left");
            ctx.textBaseline = "middle";
            ctx.lineWidth = 0.5;
            ctx.font = labelFont.string;
            const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
            const drawLegendBox = function(x, y2, legendItem) {
              if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
                return;
              }
              ctx.save();
              const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
              ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
              ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
              ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
              ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
              ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
              if (labelOpts.usePointStyle) {
                const drawOptions = {
                  radius: boxHeight * Math.SQRT2 / 2,
                  pointStyle: legendItem.pointStyle,
                  rotation: legendItem.rotation,
                  borderWidth: lineWidth
                };
                const centerX = rtlHelper.xPlus(x, boxWidth / 2);
                const centerY = y2 + halfFontSize;
                drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
              } else {
                const yBoxTop = y2 + Math.max((fontSize - boxHeight) / 2, 0);
                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                const borderRadius = toTRBLCorners(legendItem.borderRadius);
                ctx.beginPath();
                if (Object.values(borderRadius).some((v) => v !== 0)) {
                  addRoundedRectPath(ctx, {
                    x: xBoxLeft,
                    y: yBoxTop,
                    w: boxWidth,
                    h: boxHeight,
                    radius: borderRadius
                  });
                } else {
                  ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                }
                ctx.fill();
                if (lineWidth !== 0) {
                  ctx.stroke();
                }
              }
              ctx.restore();
            };
            const fillText = function(x, y2, legendItem) {
              renderText(ctx, legendItem.text, x, y2 + itemHeight / 2, labelFont, {
                strikethrough: legendItem.hidden,
                textAlign: rtlHelper.textAlign(legendItem.textAlign)
              });
            };
            const isHorizontal = this.isHorizontal();
            const titleHeight = this._computeTitleHeight();
            if (isHorizontal) {
              cursor = {
                x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
                y: this.top + padding + titleHeight,
                line: 0
              };
            } else {
              cursor = {
                x: this.left + padding,
                y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
                line: 0
              };
            }
            overrideTextDirection(this.ctx, opts.textDirection);
            const lineHeight = itemHeight + padding;
            this.legendItems.forEach((legendItem, i) => {
              ctx.strokeStyle = legendItem.fontColor || fontColor;
              ctx.fillStyle = legendItem.fontColor || fontColor;
              const textWidth = ctx.measureText(legendItem.text).width;
              const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
              const width = boxWidth + halfFontSize + textWidth;
              let x = cursor.x;
              let y2 = cursor.y;
              rtlHelper.setWidth(this.width);
              if (isHorizontal) {
                if (i > 0 && x + width + padding > this.right) {
                  y2 = cursor.y += lineHeight;
                  cursor.line++;
                  x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
                }
              } else if (i > 0 && y2 + lineHeight > this.bottom) {
                x = cursor.x = x + columnSizes[cursor.line].width + padding;
                cursor.line++;
                y2 = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
              }
              const realX = rtlHelper.x(x);
              drawLegendBox(realX, y2, legendItem);
              x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
              fillText(rtlHelper.x(x), y2, legendItem);
              if (isHorizontal) {
                cursor.x += width + padding;
              } else {
                cursor.y += lineHeight;
              }
            });
            restoreTextDirection(this.ctx, opts.textDirection);
          }
          drawTitle() {
            const opts = this.options;
            const titleOpts = opts.title;
            const titleFont = toFont(titleOpts.font);
            const titlePadding = toPadding(titleOpts.padding);
            if (!titleOpts.display) {
              return;
            }
            const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
            const ctx = this.ctx;
            const position = titleOpts.position;
            const halfFontSize = titleFont.size / 2;
            const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
            let y2;
            let left = this.left;
            let maxWidth = this.width;
            if (this.isHorizontal()) {
              maxWidth = Math.max(...this.lineWidths);
              y2 = this.top + topPaddingPlusHalfFontSize;
              left = _alignStartEnd(opts.align, left, this.right - maxWidth);
            } else {
              const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
              y2 = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
            }
            const x = _alignStartEnd(position, left, left + maxWidth);
            ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
            ctx.textBaseline = "middle";
            ctx.strokeStyle = titleOpts.color;
            ctx.fillStyle = titleOpts.color;
            ctx.font = titleFont.string;
            renderText(ctx, titleOpts.text, x, y2, titleFont);
          }
          _computeTitleHeight() {
            const titleOpts = this.options.title;
            const titleFont = toFont(titleOpts.font);
            const titlePadding = toPadding(titleOpts.padding);
            return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
          }
          _getLegendItemAt(x, y2) {
            let i, hitBox, lh2;
            if (_isBetween(x, this.left, this.right) && _isBetween(y2, this.top, this.bottom)) {
              lh2 = this.legendHitBoxes;
              for (i = 0; i < lh2.length; ++i) {
                hitBox = lh2[i];
                if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y2, hitBox.top, hitBox.top + hitBox.height)) {
                  return this.legendItems[i];
                }
              }
            }
            return null;
          }
          handleEvent(e) {
            const opts = this.options;
            if (!isListened(e.type, opts)) {
              return;
            }
            const hoveredItem = this._getLegendItemAt(e.x, e.y);
            if (e.type === "mousemove" || e.type === "mouseout") {
              const previous = this._hoveredItem;
              const sameItem = itemsEqual(previous, hoveredItem);
              if (previous && !sameItem) {
                callback(opts.onLeave, [e, previous, this], this);
              }
              this._hoveredItem = hoveredItem;
              if (hoveredItem && !sameItem) {
                callback(opts.onHover, [e, hoveredItem, this], this);
              }
            } else if (hoveredItem) {
              callback(opts.onClick, [e, hoveredItem, this], this);
            }
          }
        }
        function isListened(type, opts) {
          if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
            return true;
          }
          if (opts.onClick && (type === "click" || type === "mouseup")) {
            return true;
          }
          return false;
        }
        var plugin_legend = {
          id: "legend",
          _element: Legend,
          start(chart, _args, options) {
            const legend = chart.legend = new Legend({ ctx: chart.ctx, options, chart });
            layouts.configure(chart, legend, options);
            layouts.addBox(chart, legend);
          },
          stop(chart) {
            layouts.removeBox(chart, chart.legend);
            delete chart.legend;
          },
          beforeUpdate(chart, _args, options) {
            const legend = chart.legend;
            layouts.configure(chart, legend, options);
            legend.options = options;
          },
          afterUpdate(chart) {
            const legend = chart.legend;
            legend.buildLabels();
            legend.adjustHitBoxes();
          },
          afterEvent(chart, args) {
            if (!args.replay) {
              chart.legend.handleEvent(args.event);
            }
          },
          defaults: {
            display: true,
            position: "top",
            align: "center",
            fullSize: true,
            reverse: false,
            weight: 1e3,
            onClick(e, legendItem, legend) {
              const index2 = legendItem.datasetIndex;
              const ci2 = legend.chart;
              if (ci2.isDatasetVisible(index2)) {
                ci2.hide(index2);
                legendItem.hidden = true;
              } else {
                ci2.show(index2);
                legendItem.hidden = false;
              }
            },
            onHover: null,
            onLeave: null,
            labels: {
              color: (ctx) => ctx.chart.options.color,
              boxWidth: 40,
              padding: 10,
              generateLabels(chart) {
                const datasets = chart.data.datasets;
                const { labels: { usePointStyle, pointStyle, textAlign, color: color2 } } = chart.legend.options;
                return chart._getSortedDatasetMetas().map((meta) => {
                  const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                  const borderWidth = toPadding(style.borderWidth);
                  return {
                    text: datasets[meta.index].label,
                    fillStyle: style.backgroundColor,
                    fontColor: color2,
                    hidden: !meta.visible,
                    lineCap: style.borderCapStyle,
                    lineDash: style.borderDash,
                    lineDashOffset: style.borderDashOffset,
                    lineJoin: style.borderJoinStyle,
                    lineWidth: (borderWidth.width + borderWidth.height) / 4,
                    strokeStyle: style.borderColor,
                    pointStyle: pointStyle || style.pointStyle,
                    rotation: style.rotation,
                    textAlign: textAlign || style.textAlign,
                    borderRadius: 0,
                    datasetIndex: meta.index
                  };
                }, this);
              }
            },
            title: {
              color: (ctx) => ctx.chart.options.color,
              display: false,
              position: "center",
              text: ""
            }
          },
          descriptors: {
            _scriptable: (name) => !name.startsWith("on"),
            labels: {
              _scriptable: (name) => !["generateLabels", "filter", "sort"].includes(name)
            }
          }
        };
        class Title extends Element2 {
          constructor(config) {
            super();
            this.chart = config.chart;
            this.options = config.options;
            this.ctx = config.ctx;
            this._padding = void 0;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.width = void 0;
            this.height = void 0;
            this.position = void 0;
            this.weight = void 0;
            this.fullSize = void 0;
          }
          update(maxWidth, maxHeight) {
            const opts = this.options;
            this.left = 0;
            this.top = 0;
            if (!opts.display) {
              this.width = this.height = this.right = this.bottom = 0;
              return;
            }
            this.width = this.right = maxWidth;
            this.height = this.bottom = maxHeight;
            const lineCount = isArray(opts.text) ? opts.text.length : 1;
            this._padding = toPadding(opts.padding);
            const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
            if (this.isHorizontal()) {
              this.height = textSize;
            } else {
              this.width = textSize;
            }
          }
          isHorizontal() {
            const pos = this.options.position;
            return pos === "top" || pos === "bottom";
          }
          _drawArgs(offset) {
            const { top, left, bottom, right, options } = this;
            const align = options.align;
            let rotation = 0;
            let maxWidth, titleX, titleY;
            if (this.isHorizontal()) {
              titleX = _alignStartEnd(align, left, right);
              titleY = top + offset;
              maxWidth = right - left;
            } else {
              if (options.position === "left") {
                titleX = left + offset;
                titleY = _alignStartEnd(align, bottom, top);
                rotation = PI * -0.5;
              } else {
                titleX = right - offset;
                titleY = _alignStartEnd(align, top, bottom);
                rotation = PI * 0.5;
              }
              maxWidth = bottom - top;
            }
            return { titleX, titleY, maxWidth, rotation };
          }
          draw() {
            const ctx = this.ctx;
            const opts = this.options;
            if (!opts.display) {
              return;
            }
            const fontOpts = toFont(opts.font);
            const lineHeight = fontOpts.lineHeight;
            const offset = lineHeight / 2 + this._padding.top;
            const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
            renderText(ctx, opts.text, 0, 0, fontOpts, {
              color: opts.color,
              maxWidth,
              rotation,
              textAlign: _toLeftRightCenter(opts.align),
              textBaseline: "middle",
              translation: [titleX, titleY]
            });
          }
        }
        function createTitle(chart, titleOpts) {
          const title = new Title({
            ctx: chart.ctx,
            options: titleOpts,
            chart
          });
          layouts.configure(chart, title, titleOpts);
          layouts.addBox(chart, title);
          chart.titleBlock = title;
        }
        var plugin_title = {
          id: "title",
          _element: Title,
          start(chart, _args, options) {
            createTitle(chart, options);
          },
          stop(chart) {
            const titleBlock = chart.titleBlock;
            layouts.removeBox(chart, titleBlock);
            delete chart.titleBlock;
          },
          beforeUpdate(chart, _args, options) {
            const title = chart.titleBlock;
            layouts.configure(chart, title, options);
            title.options = options;
          },
          defaults: {
            align: "center",
            display: false,
            font: {
              weight: "bold"
            },
            fullSize: true,
            padding: 10,
            position: "top",
            text: "",
            weight: 2e3
          },
          defaultRoutes: {
            color: "color"
          },
          descriptors: {
            _scriptable: true,
            _indexable: false
          }
        };
        const map = new WeakMap();
        var plugin_subtitle = {
          id: "subtitle",
          start(chart, _args, options) {
            const title = new Title({
              ctx: chart.ctx,
              options,
              chart
            });
            layouts.configure(chart, title, options);
            layouts.addBox(chart, title);
            map.set(chart, title);
          },
          stop(chart) {
            layouts.removeBox(chart, map.get(chart));
            map.delete(chart);
          },
          beforeUpdate(chart, _args, options) {
            const title = map.get(chart);
            layouts.configure(chart, title, options);
            title.options = options;
          },
          defaults: {
            align: "center",
            display: false,
            font: {
              weight: "normal"
            },
            fullSize: true,
            padding: 0,
            position: "top",
            text: "",
            weight: 1500
          },
          defaultRoutes: {
            color: "color"
          },
          descriptors: {
            _scriptable: true,
            _indexable: false
          }
        };
        const positioners = {
          average(items) {
            if (!items.length) {
              return false;
            }
            let i, len;
            let x = 0;
            let y2 = 0;
            let count = 0;
            for (i = 0, len = items.length; i < len; ++i) {
              const el2 = items[i].element;
              if (el2 && el2.hasValue()) {
                const pos = el2.tooltipPosition();
                x += pos.x;
                y2 += pos.y;
                ++count;
              }
            }
            return {
              x: x / count,
              y: y2 / count
            };
          },
          nearest(items, eventPosition) {
            if (!items.length) {
              return false;
            }
            let x = eventPosition.x;
            let y2 = eventPosition.y;
            let minDistance = Number.POSITIVE_INFINITY;
            let i, len, nearestElement;
            for (i = 0, len = items.length; i < len; ++i) {
              const el2 = items[i].element;
              if (el2 && el2.hasValue()) {
                const center = el2.getCenterPoint();
                const d2 = distanceBetweenPoints(eventPosition, center);
                if (d2 < minDistance) {
                  minDistance = d2;
                  nearestElement = el2;
                }
              }
            }
            if (nearestElement) {
              const tp = nearestElement.tooltipPosition();
              x = tp.x;
              y2 = tp.y;
            }
            return {
              x,
              y: y2
            };
          }
        };
        function pushOrConcat(base, toPush) {
          if (toPush) {
            if (isArray(toPush)) {
              Array.prototype.push.apply(base, toPush);
            } else {
              base.push(toPush);
            }
          }
          return base;
        }
        function splitNewlines(str) {
          if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
            return str.split("\n");
          }
          return str;
        }
        function createTooltipItem(chart, item) {
          const { element, datasetIndex, index: index2 } = item;
          const controller = chart.getDatasetMeta(datasetIndex).controller;
          const { label, value } = controller.getLabelAndValue(index2);
          return {
            chart,
            label,
            parsed: controller.getParsed(index2),
            raw: chart.data.datasets[datasetIndex].data[index2],
            formattedValue: value,
            dataset: controller.getDataset(),
            dataIndex: index2,
            datasetIndex,
            element
          };
        }
        function getTooltipSize(tooltip, options) {
          const ctx = tooltip.chart.ctx;
          const { body, footer, title } = tooltip;
          const { boxWidth, boxHeight } = options;
          const bodyFont = toFont(options.bodyFont);
          const titleFont = toFont(options.titleFont);
          const footerFont = toFont(options.footerFont);
          const titleLineCount = title.length;
          const footerLineCount = footer.length;
          const bodyLineItemCount = body.length;
          const padding = toPadding(options.padding);
          let height = padding.height;
          let width = 0;
          let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
          combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
          if (titleLineCount) {
            height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
          }
          if (combinedBodyLength) {
            const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
            height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
          }
          if (footerLineCount) {
            height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
          }
          let widthPadding = 0;
          const maxLineWidth = function(line) {
            width = Math.max(width, ctx.measureText(line).width + widthPadding);
          };
          ctx.save();
          ctx.font = titleFont.string;
          each(tooltip.title, maxLineWidth);
          ctx.font = bodyFont.string;
          each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
          widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
          each(body, (bodyItem) => {
            each(bodyItem.before, maxLineWidth);
            each(bodyItem.lines, maxLineWidth);
            each(bodyItem.after, maxLineWidth);
          });
          widthPadding = 0;
          ctx.font = footerFont.string;
          each(tooltip.footer, maxLineWidth);
          ctx.restore();
          width += padding.width;
          return { width, height };
        }
        function determineYAlign(chart, size) {
          const { y: y2, height } = size;
          if (y2 < height / 2) {
            return "top";
          } else if (y2 > chart.height - height / 2) {
            return "bottom";
          }
          return "center";
        }
        function doesNotFitWithAlign(xAlign, chart, options, size) {
          const { x, width } = size;
          const caret = options.caretSize + options.caretPadding;
          if (xAlign === "left" && x + width + caret > chart.width) {
            return true;
          }
          if (xAlign === "right" && x - width - caret < 0) {
            return true;
          }
        }
        function determineXAlign(chart, options, size, yAlign) {
          const { x, width } = size;
          const { width: chartWidth, chartArea: { left, right } } = chart;
          let xAlign = "center";
          if (yAlign === "center") {
            xAlign = x <= (left + right) / 2 ? "left" : "right";
          } else if (x <= width / 2) {
            xAlign = "left";
          } else if (x >= chartWidth - width / 2) {
            xAlign = "right";
          }
          if (doesNotFitWithAlign(xAlign, chart, options, size)) {
            xAlign = "center";
          }
          return xAlign;
        }
        function determineAlignment(chart, options, size) {
          const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
          return {
            xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
            yAlign
          };
        }
        function alignX(size, xAlign) {
          let { x, width } = size;
          if (xAlign === "right") {
            x -= width;
          } else if (xAlign === "center") {
            x -= width / 2;
          }
          return x;
        }
        function alignY(size, yAlign, paddingAndSize) {
          let { y: y2, height } = size;
          if (yAlign === "top") {
            y2 += paddingAndSize;
          } else if (yAlign === "bottom") {
            y2 -= height + paddingAndSize;
          } else {
            y2 -= height / 2;
          }
          return y2;
        }
        function getBackgroundPoint(options, size, alignment, chart) {
          const { caretSize, caretPadding, cornerRadius } = options;
          const { xAlign, yAlign } = alignment;
          const paddingAndSize = caretSize + caretPadding;
          const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
          let x = alignX(size, xAlign);
          const y2 = alignY(size, yAlign, paddingAndSize);
          if (yAlign === "center") {
            if (xAlign === "left") {
              x += paddingAndSize;
            } else if (xAlign === "right") {
              x -= paddingAndSize;
            }
          } else if (xAlign === "left") {
            x -= Math.max(topLeft, bottomLeft) + caretSize;
          } else if (xAlign === "right") {
            x += Math.max(topRight, bottomRight) + caretSize;
          }
          return {
            x: _limitValue(x, 0, chart.width - size.width),
            y: _limitValue(y2, 0, chart.height - size.height)
          };
        }
        function getAlignedX(tooltip, align, options) {
          const padding = toPadding(options.padding);
          return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
        }
        function getBeforeAfterBodyLines(callback2) {
          return pushOrConcat([], splitNewlines(callback2));
        }
        function createTooltipContext(parent, tooltip, tooltipItems) {
          return createContext(parent, {
            tooltip,
            tooltipItems,
            type: "tooltip"
          });
        }
        function overrideCallbacks(callbacks, context) {
          const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
          return override ? callbacks.override(override) : callbacks;
        }
        class Tooltip extends Element2 {
          constructor(config) {
            super();
            this.opacity = 0;
            this._active = [];
            this._eventPosition = void 0;
            this._size = void 0;
            this._cachedAnimations = void 0;
            this._tooltipItems = [];
            this.$animations = void 0;
            this.$context = void 0;
            this.chart = config.chart || config._chart;
            this._chart = this.chart;
            this.options = config.options;
            this.dataPoints = void 0;
            this.title = void 0;
            this.beforeBody = void 0;
            this.body = void 0;
            this.afterBody = void 0;
            this.footer = void 0;
            this.xAlign = void 0;
            this.yAlign = void 0;
            this.x = void 0;
            this.y = void 0;
            this.height = void 0;
            this.width = void 0;
            this.caretX = void 0;
            this.caretY = void 0;
            this.labelColors = void 0;
            this.labelPointStyles = void 0;
            this.labelTextColors = void 0;
          }
          initialize(options) {
            this.options = options;
            this._cachedAnimations = void 0;
            this.$context = void 0;
          }
          _resolveAnimations() {
            const cached = this._cachedAnimations;
            if (cached) {
              return cached;
            }
            const chart = this.chart;
            const options = this.options.setContext(this.getContext());
            const opts = options.enabled && chart.options.animation && options.animations;
            const animations = new Animations(this.chart, opts);
            if (opts._cacheable) {
              this._cachedAnimations = Object.freeze(animations);
            }
            return animations;
          }
          getContext() {
            return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
          }
          getTitle(context, options) {
            const { callbacks } = options;
            const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
            const title = callbacks.title.apply(this, [context]);
            const afterTitle = callbacks.afterTitle.apply(this, [context]);
            let lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeTitle));
            lines = pushOrConcat(lines, splitNewlines(title));
            lines = pushOrConcat(lines, splitNewlines(afterTitle));
            return lines;
          }
          getBeforeBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
          }
          getBody(tooltipItems, options) {
            const { callbacks } = options;
            const bodyItems = [];
            each(tooltipItems, (context) => {
              const bodyItem = {
                before: [],
                lines: [],
                after: []
              };
              const scoped = overrideCallbacks(callbacks, context);
              pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
              pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
              pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
              bodyItems.push(bodyItem);
            });
            return bodyItems;
          }
          getAfterBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
          }
          getFooter(tooltipItems, options) {
            const { callbacks } = options;
            const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
            const footer = callbacks.footer.apply(this, [tooltipItems]);
            const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
            let lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeFooter));
            lines = pushOrConcat(lines, splitNewlines(footer));
            lines = pushOrConcat(lines, splitNewlines(afterFooter));
            return lines;
          }
          _createItems(options) {
            const active = this._active;
            const data = this.chart.data;
            const labelColors = [];
            const labelPointStyles = [];
            const labelTextColors = [];
            let tooltipItems = [];
            let i, len;
            for (i = 0, len = active.length; i < len; ++i) {
              tooltipItems.push(createTooltipItem(this.chart, active[i]));
            }
            if (options.filter) {
              tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
            }
            if (options.itemSort) {
              tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
            }
            each(tooltipItems, (context) => {
              const scoped = overrideCallbacks(options.callbacks, context);
              labelColors.push(scoped.labelColor.call(this, context));
              labelPointStyles.push(scoped.labelPointStyle.call(this, context));
              labelTextColors.push(scoped.labelTextColor.call(this, context));
            });
            this.labelColors = labelColors;
            this.labelPointStyles = labelPointStyles;
            this.labelTextColors = labelTextColors;
            this.dataPoints = tooltipItems;
            return tooltipItems;
          }
          update(changed, replay) {
            const options = this.options.setContext(this.getContext());
            const active = this._active;
            let properties;
            let tooltipItems = [];
            if (!active.length) {
              if (this.opacity !== 0) {
                properties = {
                  opacity: 0
                };
              }
            } else {
              const position = positioners[options.position].call(this, active, this._eventPosition);
              tooltipItems = this._createItems(options);
              this.title = this.getTitle(tooltipItems, options);
              this.beforeBody = this.getBeforeBody(tooltipItems, options);
              this.body = this.getBody(tooltipItems, options);
              this.afterBody = this.getAfterBody(tooltipItems, options);
              this.footer = this.getFooter(tooltipItems, options);
              const size = this._size = getTooltipSize(this, options);
              const positionAndSize = Object.assign({}, position, size);
              const alignment = determineAlignment(this.chart, options, positionAndSize);
              const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
              this.xAlign = alignment.xAlign;
              this.yAlign = alignment.yAlign;
              properties = {
                opacity: 1,
                x: backgroundPoint.x,
                y: backgroundPoint.y,
                width: size.width,
                height: size.height,
                caretX: position.x,
                caretY: position.y
              };
            }
            this._tooltipItems = tooltipItems;
            this.$context = void 0;
            if (properties) {
              this._resolveAnimations().update(this, properties);
            }
            if (changed && options.external) {
              options.external.call(this, { chart: this.chart, tooltip: this, replay });
            }
          }
          drawCaret(tooltipPoint, ctx, size, options) {
            const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
            ctx.lineTo(caretPosition.x1, caretPosition.y1);
            ctx.lineTo(caretPosition.x2, caretPosition.y2);
            ctx.lineTo(caretPosition.x3, caretPosition.y3);
          }
          getCaretPosition(tooltipPoint, size, options) {
            const { xAlign, yAlign } = this;
            const { caretSize, cornerRadius } = options;
            const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
            const { x: ptX, y: ptY } = tooltipPoint;
            const { width, height } = size;
            let x1, x2, x3, y1, y2, y3;
            if (yAlign === "center") {
              y2 = ptY + height / 2;
              if (xAlign === "left") {
                x1 = ptX;
                x2 = x1 - caretSize;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
              } else {
                x1 = ptX + width;
                x2 = x1 + caretSize;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
              }
              x3 = x1;
            } else {
              if (xAlign === "left") {
                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
              } else if (xAlign === "right") {
                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
              } else {
                x2 = this.caretX;
              }
              if (yAlign === "top") {
                y1 = ptY;
                y2 = y1 - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else {
                y1 = ptY + height;
                y2 = y1 + caretSize;
                x1 = x2 + caretSize;
                x3 = x2 - caretSize;
              }
              y3 = y1;
            }
            return { x1, x2, x3, y1, y2, y3 };
          }
          drawTitle(pt2, ctx, options) {
            const title = this.title;
            const length = title.length;
            let titleFont, titleSpacing, i;
            if (length) {
              const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
              pt2.x = getAlignedX(this, options.titleAlign, options);
              ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
              ctx.textBaseline = "middle";
              titleFont = toFont(options.titleFont);
              titleSpacing = options.titleSpacing;
              ctx.fillStyle = options.titleColor;
              ctx.font = titleFont.string;
              for (i = 0; i < length; ++i) {
                ctx.fillText(title[i], rtlHelper.x(pt2.x), pt2.y + titleFont.lineHeight / 2);
                pt2.y += titleFont.lineHeight + titleSpacing;
                if (i + 1 === length) {
                  pt2.y += options.titleMarginBottom - titleSpacing;
                }
              }
            }
          }
          _drawColorBox(ctx, pt2, i, rtlHelper, options) {
            const labelColors = this.labelColors[i];
            const labelPointStyle = this.labelPointStyles[i];
            const { boxHeight, boxWidth, boxPadding } = options;
            const bodyFont = toFont(options.bodyFont);
            const colorX = getAlignedX(this, "left", options);
            const rtlColorX = rtlHelper.x(colorX);
            const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
            const colorY = pt2.y + yOffSet;
            if (options.usePointStyle) {
              const drawOptions = {
                radius: Math.min(boxWidth, boxHeight) / 2,
                pointStyle: labelPointStyle.pointStyle,
                rotation: labelPointStyle.rotation,
                borderWidth: 1
              };
              const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
              const centerY = colorY + boxHeight / 2;
              ctx.strokeStyle = options.multiKeyBackground;
              ctx.fillStyle = options.multiKeyBackground;
              drawPoint(ctx, drawOptions, centerX, centerY);
              ctx.strokeStyle = labelColors.borderColor;
              ctx.fillStyle = labelColors.backgroundColor;
              drawPoint(ctx, drawOptions, centerX, centerY);
            } else {
              ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
              ctx.strokeStyle = labelColors.borderColor;
              ctx.setLineDash(labelColors.borderDash || []);
              ctx.lineDashOffset = labelColors.borderDashOffset || 0;
              const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
              const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
              const borderRadius = toTRBLCorners(labelColors.borderRadius);
              if (Object.values(borderRadius).some((v) => v !== 0)) {
                ctx.beginPath();
                ctx.fillStyle = options.multiKeyBackground;
                addRoundedRectPath(ctx, {
                  x: outerX,
                  y: colorY,
                  w: boxWidth,
                  h: boxHeight,
                  radius: borderRadius
                });
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = labelColors.backgroundColor;
                ctx.beginPath();
                addRoundedRectPath(ctx, {
                  x: innerX,
                  y: colorY + 1,
                  w: boxWidth - 2,
                  h: boxHeight - 2,
                  radius: borderRadius
                });
                ctx.fill();
              } else {
                ctx.fillStyle = options.multiKeyBackground;
                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                ctx.fillStyle = labelColors.backgroundColor;
                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
              }
            }
            ctx.fillStyle = this.labelTextColors[i];
          }
          drawBody(pt2, ctx, options) {
            const { body } = this;
            const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
            const bodyFont = toFont(options.bodyFont);
            let bodyLineHeight = bodyFont.lineHeight;
            let xLinePadding = 0;
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            const fillLineOfText = function(line) {
              ctx.fillText(line, rtlHelper.x(pt2.x + xLinePadding), pt2.y + bodyLineHeight / 2);
              pt2.y += bodyLineHeight + bodySpacing;
            };
            const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
            let bodyItem, textColor, lines, i, j2, ilen, jlen;
            ctx.textAlign = bodyAlign;
            ctx.textBaseline = "middle";
            ctx.font = bodyFont.string;
            pt2.x = getAlignedX(this, bodyAlignForCalculation, options);
            ctx.fillStyle = options.bodyColor;
            each(this.beforeBody, fillLineOfText);
            xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
            for (i = 0, ilen = body.length; i < ilen; ++i) {
              bodyItem = body[i];
              textColor = this.labelTextColors[i];
              ctx.fillStyle = textColor;
              each(bodyItem.before, fillLineOfText);
              lines = bodyItem.lines;
              if (displayColors && lines.length) {
                this._drawColorBox(ctx, pt2, i, rtlHelper, options);
                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
              }
              for (j2 = 0, jlen = lines.length; j2 < jlen; ++j2) {
                fillLineOfText(lines[j2]);
                bodyLineHeight = bodyFont.lineHeight;
              }
              each(bodyItem.after, fillLineOfText);
            }
            xLinePadding = 0;
            bodyLineHeight = bodyFont.lineHeight;
            each(this.afterBody, fillLineOfText);
            pt2.y -= bodySpacing;
          }
          drawFooter(pt2, ctx, options) {
            const footer = this.footer;
            const length = footer.length;
            let footerFont, i;
            if (length) {
              const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
              pt2.x = getAlignedX(this, options.footerAlign, options);
              pt2.y += options.footerMarginTop;
              ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
              ctx.textBaseline = "middle";
              footerFont = toFont(options.footerFont);
              ctx.fillStyle = options.footerColor;
              ctx.font = footerFont.string;
              for (i = 0; i < length; ++i) {
                ctx.fillText(footer[i], rtlHelper.x(pt2.x), pt2.y + footerFont.lineHeight / 2);
                pt2.y += footerFont.lineHeight + options.footerSpacing;
              }
            }
          }
          drawBackground(pt2, ctx, tooltipSize, options) {
            const { xAlign, yAlign } = this;
            const { x, y: y2 } = pt2;
            const { width, height } = tooltipSize;
            const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
            ctx.fillStyle = options.backgroundColor;
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.beginPath();
            ctx.moveTo(x + topLeft, y2);
            if (yAlign === "top") {
              this.drawCaret(pt2, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + width - topRight, y2);
            ctx.quadraticCurveTo(x + width, y2, x + width, y2 + topRight);
            if (yAlign === "center" && xAlign === "right") {
              this.drawCaret(pt2, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + width, y2 + height - bottomRight);
            ctx.quadraticCurveTo(x + width, y2 + height, x + width - bottomRight, y2 + height);
            if (yAlign === "bottom") {
              this.drawCaret(pt2, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + bottomLeft, y2 + height);
            ctx.quadraticCurveTo(x, y2 + height, x, y2 + height - bottomLeft);
            if (yAlign === "center" && xAlign === "left") {
              this.drawCaret(pt2, ctx, tooltipSize, options);
            }
            ctx.lineTo(x, y2 + topLeft);
            ctx.quadraticCurveTo(x, y2, x + topLeft, y2);
            ctx.closePath();
            ctx.fill();
            if (options.borderWidth > 0) {
              ctx.stroke();
            }
          }
          _updateAnimationTarget(options) {
            const chart = this.chart;
            const anims = this.$animations;
            const animX = anims && anims.x;
            const animY = anims && anims.y;
            if (animX || animY) {
              const position = positioners[options.position].call(this, this._active, this._eventPosition);
              if (!position) {
                return;
              }
              const size = this._size = getTooltipSize(this, options);
              const positionAndSize = Object.assign({}, position, this._size);
              const alignment = determineAlignment(chart, options, positionAndSize);
              const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
              if (animX._to !== point.x || animY._to !== point.y) {
                this.xAlign = alignment.xAlign;
                this.yAlign = alignment.yAlign;
                this.width = size.width;
                this.height = size.height;
                this.caretX = position.x;
                this.caretY = position.y;
                this._resolveAnimations().update(this, point);
              }
            }
          }
          _willRender() {
            return !!this.opacity;
          }
          draw(ctx) {
            const options = this.options.setContext(this.getContext());
            let opacity = this.opacity;
            if (!opacity) {
              return;
            }
            this._updateAnimationTarget(options);
            const tooltipSize = {
              width: this.width,
              height: this.height
            };
            const pt2 = {
              x: this.x,
              y: this.y
            };
            opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
            const padding = toPadding(options.padding);
            const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
            if (options.enabled && hasTooltipContent) {
              ctx.save();
              ctx.globalAlpha = opacity;
              this.drawBackground(pt2, ctx, tooltipSize, options);
              overrideTextDirection(ctx, options.textDirection);
              pt2.y += padding.top;
              this.drawTitle(pt2, ctx, options);
              this.drawBody(pt2, ctx, options);
              this.drawFooter(pt2, ctx, options);
              restoreTextDirection(ctx, options.textDirection);
              ctx.restore();
            }
          }
          getActiveElements() {
            return this._active || [];
          }
          setActiveElements(activeElements, eventPosition) {
            const lastActive = this._active;
            const active = activeElements.map(({ datasetIndex, index: index2 }) => {
              const meta = this.chart.getDatasetMeta(datasetIndex);
              if (!meta) {
                throw new Error("Cannot find a dataset at index " + datasetIndex);
              }
              return {
                datasetIndex,
                element: meta.data[index2],
                index: index2
              };
            });
            const changed = !_elementsEqual(lastActive, active);
            const positionChanged = this._positionChanged(active, eventPosition);
            if (changed || positionChanged) {
              this._active = active;
              this._eventPosition = eventPosition;
              this._ignoreReplayEvents = true;
              this.update(true);
            }
          }
          handleEvent(e, replay, inChartArea = true) {
            if (replay && this._ignoreReplayEvents) {
              return false;
            }
            this._ignoreReplayEvents = false;
            const options = this.options;
            const lastActive = this._active || [];
            const active = this._getActiveElements(e, lastActive, replay, inChartArea);
            const positionChanged = this._positionChanged(active, e);
            const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
            if (changed) {
              this._active = active;
              if (options.enabled || options.external) {
                this._eventPosition = {
                  x: e.x,
                  y: e.y
                };
                this.update(true, replay);
              }
            }
            return changed;
          }
          _getActiveElements(e, lastActive, replay, inChartArea) {
            const options = this.options;
            if (e.type === "mouseout") {
              return [];
            }
            if (!inChartArea) {
              return lastActive;
            }
            const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
            if (options.reverse) {
              active.reverse();
            }
            return active;
          }
          _positionChanged(active, e) {
            const { caretX, caretY, options } = this;
            const position = positioners[options.position].call(this, active, e);
            return position !== false && (caretX !== position.x || caretY !== position.y);
          }
        }
        Tooltip.positioners = positioners;
        var plugin_tooltip = {
          id: "tooltip",
          _element: Tooltip,
          positioners,
          afterInit(chart, _args, options) {
            if (options) {
              chart.tooltip = new Tooltip({ chart, options });
            }
          },
          beforeUpdate(chart, _args, options) {
            if (chart.tooltip) {
              chart.tooltip.initialize(options);
            }
          },
          reset(chart, _args, options) {
            if (chart.tooltip) {
              chart.tooltip.initialize(options);
            }
          },
          afterDraw(chart) {
            const tooltip = chart.tooltip;
            if (tooltip && tooltip._willRender()) {
              const args = {
                tooltip
              };
              if (chart.notifyPlugins("beforeTooltipDraw", args) === false) {
                return;
              }
              tooltip.draw(chart.ctx);
              chart.notifyPlugins("afterTooltipDraw", args);
            }
          },
          afterEvent(chart, args) {
            if (chart.tooltip) {
              const useFinalPosition = args.replay;
              if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
                args.changed = true;
              }
            }
          },
          defaults: {
            enabled: true,
            external: null,
            position: "average",
            backgroundColor: "rgba(0,0,0,0.8)",
            titleColor: "#fff",
            titleFont: {
              weight: "bold"
            },
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleAlign: "left",
            bodyColor: "#fff",
            bodySpacing: 2,
            bodyFont: {},
            bodyAlign: "left",
            footerColor: "#fff",
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFont: {
              weight: "bold"
            },
            footerAlign: "left",
            padding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            boxHeight: (ctx, opts) => opts.bodyFont.size,
            boxWidth: (ctx, opts) => opts.bodyFont.size,
            multiKeyBackground: "#fff",
            displayColors: true,
            boxPadding: 0,
            borderColor: "rgba(0,0,0,0)",
            borderWidth: 0,
            animation: {
              duration: 400,
              easing: "easeOutQuart"
            },
            animations: {
              numbers: {
                type: "number",
                properties: ["x", "y", "width", "height", "caretX", "caretY"]
              },
              opacity: {
                easing: "linear",
                duration: 200
              }
            },
            callbacks: {
              beforeTitle: noop,
              title(tooltipItems) {
                if (tooltipItems.length > 0) {
                  const item = tooltipItems[0];
                  const labels = item.chart.data.labels;
                  const labelCount = labels ? labels.length : 0;
                  if (this && this.options && this.options.mode === "dataset") {
                    return item.dataset.label || "";
                  } else if (item.label) {
                    return item.label;
                  } else if (labelCount > 0 && item.dataIndex < labelCount) {
                    return labels[item.dataIndex];
                  }
                }
                return "";
              },
              afterTitle: noop,
              beforeBody: noop,
              beforeLabel: noop,
              label(tooltipItem) {
                if (this && this.options && this.options.mode === "dataset") {
                  return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
                }
                let label = tooltipItem.dataset.label || "";
                if (label) {
                  label += ": ";
                }
                const value = tooltipItem.formattedValue;
                if (!isNullOrUndef(value)) {
                  label += value;
                }
                return label;
              },
              labelColor(tooltipItem) {
                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
                const options = meta.controller.getStyle(tooltipItem.dataIndex);
                return {
                  borderColor: options.borderColor,
                  backgroundColor: options.backgroundColor,
                  borderWidth: options.borderWidth,
                  borderDash: options.borderDash,
                  borderDashOffset: options.borderDashOffset,
                  borderRadius: 0
                };
              },
              labelTextColor() {
                return this.options.bodyColor;
              },
              labelPointStyle(tooltipItem) {
                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
                const options = meta.controller.getStyle(tooltipItem.dataIndex);
                return {
                  pointStyle: options.pointStyle,
                  rotation: options.rotation
                };
              },
              afterLabel: noop,
              afterBody: noop,
              beforeFooter: noop,
              footer: noop,
              afterFooter: noop
            }
          },
          defaultRoutes: {
            bodyFont: "font",
            footerFont: "font",
            titleFont: "font"
          },
          descriptors: {
            _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
            _indexable: false,
            callbacks: {
              _scriptable: false,
              _indexable: false
            },
            animation: {
              _fallback: false
            },
            animations: {
              _fallback: "animation"
            }
          },
          additionalOptionScopes: ["interaction"]
        };
        var plugins = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          Decimation: plugin_decimation,
          Filler: index,
          Legend: plugin_legend,
          SubTitle: plugin_subtitle,
          Title: plugin_title,
          Tooltip: plugin_tooltip
        });
        const addIfString = (labels, raw, index2, addedLabels) => {
          if (typeof raw === "string") {
            index2 = labels.push(raw) - 1;
            addedLabels.unshift({ index: index2, label: raw });
          } else if (isNaN(raw)) {
            index2 = null;
          }
          return index2;
        };
        function findOrAddLabel(labels, raw, index2, addedLabels) {
          const first = labels.indexOf(raw);
          if (first === -1) {
            return addIfString(labels, raw, index2, addedLabels);
          }
          const last = labels.lastIndexOf(raw);
          return first !== last ? index2 : first;
        }
        const validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
        class CategoryScale extends Scale {
          constructor(cfg) {
            super(cfg);
            this._startValue = void 0;
            this._valueRange = 0;
            this._addedLabels = [];
          }
          init(scaleOptions) {
            const added = this._addedLabels;
            if (added.length) {
              const labels = this.getLabels();
              for (const { index: index2, label } of added) {
                if (labels[index2] === label) {
                  labels.splice(index2, 1);
                }
              }
              this._addedLabels = [];
            }
            super.init(scaleOptions);
          }
          parse(raw, index2) {
            if (isNullOrUndef(raw)) {
              return null;
            }
            const labels = this.getLabels();
            index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
            return validIndex(index2, labels.length - 1);
          }
          determineDataLimits() {
            const { minDefined, maxDefined } = this.getUserBounds();
            let { min, max } = this.getMinMax(true);
            if (this.options.bounds === "ticks") {
              if (!minDefined) {
                min = 0;
              }
              if (!maxDefined) {
                max = this.getLabels().length - 1;
              }
            }
            this.min = min;
            this.max = max;
          }
          buildTicks() {
            const min = this.min;
            const max = this.max;
            const offset = this.options.offset;
            const ticks = [];
            let labels = this.getLabels();
            labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
            this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
            this._startValue = this.min - (offset ? 0.5 : 0);
            for (let value = min; value <= max; value++) {
              ticks.push({ value });
            }
            return ticks;
          }
          getLabelForValue(value) {
            const labels = this.getLabels();
            if (value >= 0 && value < labels.length) {
              return labels[value];
            }
            return value;
          }
          configure() {
            super.configure();
            if (!this.isHorizontal()) {
              this._reversePixels = !this._reversePixels;
            }
          }
          getPixelForValue(value) {
            if (typeof value !== "number") {
              value = this.parse(value);
            }
            return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
          }
          getPixelForTick(index2) {
            const ticks = this.ticks;
            if (index2 < 0 || index2 > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index2].value);
          }
          getValueForPixel(pixel) {
            return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
          }
          getBasePixel() {
            return this.bottom;
          }
        }
        CategoryScale.id = "category";
        CategoryScale.defaults = {
          ticks: {
            callback: CategoryScale.prototype.getLabelForValue
          }
        };
        function generateTicks$1(generationOptions, dataRange) {
          const ticks = [];
          const MIN_SPACING = 1e-14;
          const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
          const unit = step || 1;
          const maxSpaces = maxTicks - 1;
          const { min: rmin, max: rmax } = dataRange;
          const minDefined = !isNullOrUndef(min);
          const maxDefined = !isNullOrUndef(max);
          const countDefined = !isNullOrUndef(count);
          const minSpacing = (rmax - rmin) / (maxDigits + 1);
          let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
          let factor, niceMin, niceMax, numSpaces;
          if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
            return [{ value: rmin }, { value: rmax }];
          }
          numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
          if (numSpaces > maxSpaces) {
            spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
          }
          if (!isNullOrUndef(precision)) {
            factor = Math.pow(10, precision);
            spacing = Math.ceil(spacing * factor) / factor;
          }
          if (bounds === "ticks") {
            niceMin = Math.floor(rmin / spacing) * spacing;
            niceMax = Math.ceil(rmax / spacing) * spacing;
          } else {
            niceMin = rmin;
            niceMax = rmax;
          }
          if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
            numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
            spacing = (max - min) / numSpaces;
            niceMin = min;
            niceMax = max;
          } else if (countDefined) {
            niceMin = minDefined ? min : niceMin;
            niceMax = maxDefined ? max : niceMax;
            numSpaces = count - 1;
            spacing = (niceMax - niceMin) / numSpaces;
          } else {
            numSpaces = (niceMax - niceMin) / spacing;
            if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
              numSpaces = Math.round(numSpaces);
            } else {
              numSpaces = Math.ceil(numSpaces);
            }
          }
          const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
          factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
          niceMin = Math.round(niceMin * factor) / factor;
          niceMax = Math.round(niceMax * factor) / factor;
          let j2 = 0;
          if (minDefined) {
            if (includeBounds && niceMin !== min) {
              ticks.push({ value: min });
              if (niceMin < min) {
                j2++;
              }
              if (almostEquals(Math.round((niceMin + j2 * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
                j2++;
              }
            } else if (niceMin < min) {
              j2++;
            }
          }
          for (; j2 < numSpaces; ++j2) {
            ticks.push({ value: Math.round((niceMin + j2 * spacing) * factor) / factor });
          }
          if (maxDefined && includeBounds && niceMax !== max) {
            if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
              ticks[ticks.length - 1].value = max;
            } else {
              ticks.push({ value: max });
            }
          } else if (!maxDefined || niceMax === max) {
            ticks.push({ value: niceMax });
          }
          return ticks;
        }
        function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
          const rad = toRadians(minRotation);
          const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
          const length = 0.75 * minSpacing * ("" + value).length;
          return Math.min(minSpacing / ratio, length);
        }
        class LinearScaleBase extends Scale {
          constructor(cfg) {
            super(cfg);
            this.start = void 0;
            this.end = void 0;
            this._startValue = void 0;
            this._endValue = void 0;
            this._valueRange = 0;
          }
          parse(raw, index2) {
            if (isNullOrUndef(raw)) {
              return null;
            }
            if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
              return null;
            }
            return +raw;
          }
          handleTickRangeOptions() {
            const { beginAtZero } = this.options;
            const { minDefined, maxDefined } = this.getUserBounds();
            let { min, max } = this;
            const setMin = (v) => min = minDefined ? min : v;
            const setMax = (v) => max = maxDefined ? max : v;
            if (beginAtZero) {
              const minSign = sign(min);
              const maxSign = sign(max);
              if (minSign < 0 && maxSign < 0) {
                setMax(0);
              } else if (minSign > 0 && maxSign > 0) {
                setMin(0);
              }
            }
            if (min === max) {
              let offset = 1;
              if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
                offset = Math.abs(max * 0.05);
              }
              setMax(max + offset);
              if (!beginAtZero) {
                setMin(min - offset);
              }
            }
            this.min = min;
            this.max = max;
          }
          getTickLimit() {
            const tickOpts = this.options.ticks;
            let { maxTicksLimit, stepSize } = tickOpts;
            let maxTicks;
            if (stepSize) {
              maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
              if (maxTicks > 1e3) {
                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
                maxTicks = 1e3;
              }
            } else {
              maxTicks = this.computeTickLimit();
              maxTicksLimit = maxTicksLimit || 11;
            }
            if (maxTicksLimit) {
              maxTicks = Math.min(maxTicksLimit, maxTicks);
            }
            return maxTicks;
          }
          computeTickLimit() {
            return Number.POSITIVE_INFINITY;
          }
          buildTicks() {
            const opts = this.options;
            const tickOpts = opts.ticks;
            let maxTicks = this.getTickLimit();
            maxTicks = Math.max(2, maxTicks);
            const numericGeneratorOptions = {
              maxTicks,
              bounds: opts.bounds,
              min: opts.min,
              max: opts.max,
              precision: tickOpts.precision,
              step: tickOpts.stepSize,
              count: tickOpts.count,
              maxDigits: this._maxDigits(),
              horizontal: this.isHorizontal(),
              minRotation: tickOpts.minRotation || 0,
              includeBounds: tickOpts.includeBounds !== false
            };
            const dataRange = this._range || this;
            const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
            if (opts.bounds === "ticks") {
              _setMinAndMaxByKey(ticks, this, "value");
            }
            if (opts.reverse) {
              ticks.reverse();
              this.start = this.max;
              this.end = this.min;
            } else {
              this.start = this.min;
              this.end = this.max;
            }
            return ticks;
          }
          configure() {
            const ticks = this.ticks;
            let start = this.min;
            let end = this.max;
            super.configure();
            if (this.options.offset && ticks.length) {
              const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
              start -= offset;
              end += offset;
            }
            this._startValue = start;
            this._endValue = end;
            this._valueRange = end - start;
          }
          getLabelForValue(value) {
            return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
          }
        }
        class LinearScale extends LinearScaleBase {
          determineDataLimits() {
            const { min, max } = this.getMinMax(true);
            this.min = isNumberFinite(min) ? min : 0;
            this.max = isNumberFinite(max) ? max : 1;
            this.handleTickRangeOptions();
          }
          computeTickLimit() {
            const horizontal = this.isHorizontal();
            const length = horizontal ? this.width : this.height;
            const minRotation = toRadians(this.options.ticks.minRotation);
            const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
            const tickFont = this._resolveTickFontOptions(0);
            return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
          }
          getPixelForValue(value) {
            return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
          }
          getValueForPixel(pixel) {
            return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
          }
        }
        LinearScale.id = "linear";
        LinearScale.defaults = {
          ticks: {
            callback: Ticks.formatters.numeric
          }
        };
        function isMajor(tickVal) {
          const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
          return remain === 1;
        }
        function generateTicks(generationOptions, dataRange) {
          const endExp = Math.floor(log10(dataRange.max));
          const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
          const ticks = [];
          let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
          let exp = Math.floor(log10(tickVal));
          let significand = Math.floor(tickVal / Math.pow(10, exp));
          let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
          do {
            ticks.push({ value: tickVal, major: isMajor(tickVal) });
            ++significand;
            if (significand === 10) {
              significand = 1;
              ++exp;
              precision = exp >= 0 ? 1 : precision;
            }
            tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
          } while (exp < endExp || exp === endExp && significand < endSignificand);
          const lastTick = finiteOrDefault(generationOptions.max, tickVal);
          ticks.push({ value: lastTick, major: isMajor(tickVal) });
          return ticks;
        }
        class LogarithmicScale extends Scale {
          constructor(cfg) {
            super(cfg);
            this.start = void 0;
            this.end = void 0;
            this._startValue = void 0;
            this._valueRange = 0;
          }
          parse(raw, index2) {
            const value = LinearScaleBase.prototype.parse.apply(this, [raw, index2]);
            if (value === 0) {
              this._zero = true;
              return void 0;
            }
            return isNumberFinite(value) && value > 0 ? value : null;
          }
          determineDataLimits() {
            const { min, max } = this.getMinMax(true);
            this.min = isNumberFinite(min) ? Math.max(0, min) : null;
            this.max = isNumberFinite(max) ? Math.max(0, max) : null;
            if (this.options.beginAtZero) {
              this._zero = true;
            }
            this.handleTickRangeOptions();
          }
          handleTickRangeOptions() {
            const { minDefined, maxDefined } = this.getUserBounds();
            let min = this.min;
            let max = this.max;
            const setMin = (v) => min = minDefined ? min : v;
            const setMax = (v) => max = maxDefined ? max : v;
            const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
            if (min === max) {
              if (min <= 0) {
                setMin(1);
                setMax(10);
              } else {
                setMin(exp(min, -1));
                setMax(exp(max, 1));
              }
            }
            if (min <= 0) {
              setMin(exp(max, -1));
            }
            if (max <= 0) {
              setMax(exp(min, 1));
            }
            if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
              setMin(exp(min, -1));
            }
            this.min = min;
            this.max = max;
          }
          buildTicks() {
            const opts = this.options;
            const generationOptions = {
              min: this._userMin,
              max: this._userMax
            };
            const ticks = generateTicks(generationOptions, this);
            if (opts.bounds === "ticks") {
              _setMinAndMaxByKey(ticks, this, "value");
            }
            if (opts.reverse) {
              ticks.reverse();
              this.start = this.max;
              this.end = this.min;
            } else {
              this.start = this.min;
              this.end = this.max;
            }
            return ticks;
          }
          getLabelForValue(value) {
            return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
          }
          configure() {
            const start = this.min;
            super.configure();
            this._startValue = log10(start);
            this._valueRange = log10(this.max) - log10(start);
          }
          getPixelForValue(value) {
            if (value === void 0 || value === 0) {
              value = this.min;
            }
            if (value === null || isNaN(value)) {
              return NaN;
            }
            return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
          }
          getValueForPixel(pixel) {
            const decimal = this.getDecimalForPixel(pixel);
            return Math.pow(10, this._startValue + decimal * this._valueRange);
          }
        }
        LogarithmicScale.id = "logarithmic";
        LogarithmicScale.defaults = {
          ticks: {
            callback: Ticks.formatters.logarithmic,
            major: {
              enabled: true
            }
          }
        };
        function getTickBackdropHeight(opts) {
          const tickOpts = opts.ticks;
          if (tickOpts.display && opts.display) {
            const padding = toPadding(tickOpts.backdropPadding);
            return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
          }
          return 0;
        }
        function measureLabelSize(ctx, font, label) {
          label = isArray(label) ? label : [label];
          return {
            w: _longestText(ctx, font.string, label),
            h: label.length * font.lineHeight
          };
        }
        function determineLimits(angle, pos, size, min, max) {
          if (angle === min || angle === max) {
            return {
              start: pos - size / 2,
              end: pos + size / 2
            };
          } else if (angle < min || angle > max) {
            return {
              start: pos - size,
              end: pos
            };
          }
          return {
            start: pos,
            end: pos + size
          };
        }
        function fitWithPointLabels(scale) {
          const orig = {
            l: scale.left + scale._padding.left,
            r: scale.right - scale._padding.right,
            t: scale.top + scale._padding.top,
            b: scale.bottom - scale._padding.bottom
          };
          const limits = Object.assign({}, orig);
          const labelSizes = [];
          const padding = [];
          const valueCount = scale._pointLabels.length;
          const pointLabelOpts = scale.options.pointLabels;
          const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
          for (let i = 0; i < valueCount; i++) {
            const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
            padding[i] = opts.padding;
            const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
            const plFont = toFont(opts.font);
            const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
            labelSizes[i] = textSize;
            const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
            const angle = Math.round(toDegrees(angleRadians));
            const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
            const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
            updateLimits(limits, orig, angleRadians, hLimits, vLimits);
          }
          scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
          scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
        }
        function updateLimits(limits, orig, angle, hLimits, vLimits) {
          const sin = Math.abs(Math.sin(angle));
          const cos = Math.abs(Math.cos(angle));
          let x = 0;
          let y2 = 0;
          if (hLimits.start < orig.l) {
            x = (orig.l - hLimits.start) / sin;
            limits.l = Math.min(limits.l, orig.l - x);
          } else if (hLimits.end > orig.r) {
            x = (hLimits.end - orig.r) / sin;
            limits.r = Math.max(limits.r, orig.r + x);
          }
          if (vLimits.start < orig.t) {
            y2 = (orig.t - vLimits.start) / cos;
            limits.t = Math.min(limits.t, orig.t - y2);
          } else if (vLimits.end > orig.b) {
            y2 = (vLimits.end - orig.b) / cos;
            limits.b = Math.max(limits.b, orig.b + y2);
          }
        }
        function buildPointLabelItems(scale, labelSizes, padding) {
          const items = [];
          const valueCount = scale._pointLabels.length;
          const opts = scale.options;
          const extra = getTickBackdropHeight(opts) / 2;
          const outerDistance = scale.drawingArea;
          const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
          for (let i = 0; i < valueCount; i++) {
            const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
            const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
            const size = labelSizes[i];
            const y2 = yForAngle(pointLabelPosition.y, size.h, angle);
            const textAlign = getTextAlignForAngle(angle);
            const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
            items.push({
              x: pointLabelPosition.x,
              y: y2,
              textAlign,
              left,
              top: y2,
              right: left + size.w,
              bottom: y2 + size.h
            });
          }
          return items;
        }
        function getTextAlignForAngle(angle) {
          if (angle === 0 || angle === 180) {
            return "center";
          } else if (angle < 180) {
            return "left";
          }
          return "right";
        }
        function leftForTextAlign(x, w, align) {
          if (align === "right") {
            x -= w;
          } else if (align === "center") {
            x -= w / 2;
          }
          return x;
        }
        function yForAngle(y2, h3, angle) {
          if (angle === 90 || angle === 270) {
            y2 -= h3 / 2;
          } else if (angle > 270 || angle < 90) {
            y2 -= h3;
          }
          return y2;
        }
        function drawPointLabels(scale, labelCount) {
          const { ctx, options: { pointLabels } } = scale;
          for (let i = labelCount - 1; i >= 0; i--) {
            const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
            const plFont = toFont(optsAtIndex.font);
            const { x, y: y2, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];
            const { backdropColor } = optsAtIndex;
            if (!isNullOrUndef(backdropColor)) {
              const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
              const padding = toPadding(optsAtIndex.backdropPadding);
              ctx.fillStyle = backdropColor;
              const backdropLeft = left - padding.left;
              const backdropTop = top - padding.top;
              const backdropWidth = right - left + padding.width;
              const backdropHeight = bottom - top + padding.height;
              if (Object.values(borderRadius).some((v) => v !== 0)) {
                ctx.beginPath();
                addRoundedRectPath(ctx, {
                  x: backdropLeft,
                  y: backdropTop,
                  w: backdropWidth,
                  h: backdropHeight,
                  radius: borderRadius
                });
                ctx.fill();
              } else {
                ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
              }
            }
            renderText(ctx, scale._pointLabels[i], x, y2 + plFont.lineHeight / 2, plFont, {
              color: optsAtIndex.color,
              textAlign,
              textBaseline: "middle"
            });
          }
        }
        function pathRadiusLine(scale, radius, circular, labelCount) {
          const { ctx } = scale;
          if (circular) {
            ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
          } else {
            let pointPosition = scale.getPointPosition(0, radius);
            ctx.moveTo(pointPosition.x, pointPosition.y);
            for (let i = 1; i < labelCount; i++) {
              pointPosition = scale.getPointPosition(i, radius);
              ctx.lineTo(pointPosition.x, pointPosition.y);
            }
          }
        }
        function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
          const ctx = scale.ctx;
          const circular = gridLineOpts.circular;
          const { color: color2, lineWidth } = gridLineOpts;
          if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
            return;
          }
          ctx.save();
          ctx.strokeStyle = color2;
          ctx.lineWidth = lineWidth;
          ctx.setLineDash(gridLineOpts.borderDash);
          ctx.lineDashOffset = gridLineOpts.borderDashOffset;
          ctx.beginPath();
          pathRadiusLine(scale, radius, circular, labelCount);
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }
        function createPointLabelContext(parent, index2, label) {
          return createContext(parent, {
            label,
            index: index2,
            type: "pointLabel"
          });
        }
        class RadialLinearScale extends LinearScaleBase {
          constructor(cfg) {
            super(cfg);
            this.xCenter = void 0;
            this.yCenter = void 0;
            this.drawingArea = void 0;
            this._pointLabels = [];
            this._pointLabelItems = [];
          }
          setDimensions() {
            const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
            const w = this.width = this.maxWidth - padding.width;
            const h3 = this.height = this.maxHeight - padding.height;
            this.xCenter = Math.floor(this.left + w / 2 + padding.left);
            this.yCenter = Math.floor(this.top + h3 / 2 + padding.top);
            this.drawingArea = Math.floor(Math.min(w, h3) / 2);
          }
          determineDataLimits() {
            const { min, max } = this.getMinMax(false);
            this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
            this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
            this.handleTickRangeOptions();
          }
          computeTickLimit() {
            return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
          }
          generateTickLabels(ticks) {
            LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
            this._pointLabels = this.getLabels().map((value, index2) => {
              const label = callback(this.options.pointLabels.callback, [value, index2], this);
              return label || label === 0 ? label : "";
            }).filter((v, i) => this.chart.getDataVisibility(i));
          }
          fit() {
            const opts = this.options;
            if (opts.display && opts.pointLabels.display) {
              fitWithPointLabels(this);
            } else {
              this.setCenterPoint(0, 0, 0, 0);
            }
          }
          setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
            this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
            this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
            this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
          }
          getIndexAngle(index2) {
            const angleMultiplier = TAU / (this._pointLabels.length || 1);
            const startAngle = this.options.startAngle || 0;
            return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
          }
          getDistanceFromCenterForValue(value) {
            if (isNullOrUndef(value)) {
              return NaN;
            }
            const scalingFactor = this.drawingArea / (this.max - this.min);
            if (this.options.reverse) {
              return (this.max - value) * scalingFactor;
            }
            return (value - this.min) * scalingFactor;
          }
          getValueForDistanceFromCenter(distance) {
            if (isNullOrUndef(distance)) {
              return NaN;
            }
            const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
            return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
          }
          getPointLabelContext(index2) {
            const pointLabels = this._pointLabels || [];
            if (index2 >= 0 && index2 < pointLabels.length) {
              const pointLabel = pointLabels[index2];
              return createPointLabelContext(this.getContext(), index2, pointLabel);
            }
          }
          getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
            const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
            return {
              x: Math.cos(angle) * distanceFromCenter + this.xCenter,
              y: Math.sin(angle) * distanceFromCenter + this.yCenter,
              angle
            };
          }
          getPointPositionForValue(index2, value) {
            return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
          }
          getBasePosition(index2) {
            return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
          }
          getPointLabelPosition(index2) {
            const { left, top, right, bottom } = this._pointLabelItems[index2];
            return {
              left,
              top,
              right,
              bottom
            };
          }
          drawBackground() {
            const { backgroundColor, grid: { circular } } = this.options;
            if (backgroundColor) {
              const ctx = this.ctx;
              ctx.save();
              ctx.beginPath();
              pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
              ctx.closePath();
              ctx.fillStyle = backgroundColor;
              ctx.fill();
              ctx.restore();
            }
          }
          drawGrid() {
            const ctx = this.ctx;
            const opts = this.options;
            const { angleLines, grid } = opts;
            const labelCount = this._pointLabels.length;
            let i, offset, position;
            if (opts.pointLabels.display) {
              drawPointLabels(this, labelCount);
            }
            if (grid.display) {
              this.ticks.forEach((tick, index2) => {
                if (index2 !== 0) {
                  offset = this.getDistanceFromCenterForValue(tick.value);
                  const optsAtIndex = grid.setContext(this.getContext(index2 - 1));
                  drawRadiusLine(this, optsAtIndex, offset, labelCount);
                }
              });
            }
            if (angleLines.display) {
              ctx.save();
              for (i = labelCount - 1; i >= 0; i--) {
                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
                const { color: color2, lineWidth } = optsAtIndex;
                if (!lineWidth || !color2) {
                  continue;
                }
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = color2;
                ctx.setLineDash(optsAtIndex.borderDash);
                ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
                position = this.getPointPosition(i, offset);
                ctx.beginPath();
                ctx.moveTo(this.xCenter, this.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
              }
              ctx.restore();
            }
          }
          drawBorder() {
          }
          drawLabels() {
            const ctx = this.ctx;
            const opts = this.options;
            const tickOpts = opts.ticks;
            if (!tickOpts.display) {
              return;
            }
            const startAngle = this.getIndexAngle(0);
            let offset, width;
            ctx.save();
            ctx.translate(this.xCenter, this.yCenter);
            ctx.rotate(startAngle);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            this.ticks.forEach((tick, index2) => {
              if (index2 === 0 && !opts.reverse) {
                return;
              }
              const optsAtIndex = tickOpts.setContext(this.getContext(index2));
              const tickFont = toFont(optsAtIndex.font);
              offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
              if (optsAtIndex.showLabelBackdrop) {
                ctx.font = tickFont.string;
                width = ctx.measureText(tick.label).width;
                ctx.fillStyle = optsAtIndex.backdropColor;
                const padding = toPadding(optsAtIndex.backdropPadding);
                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
              }
              renderText(ctx, tick.label, 0, -offset, tickFont, {
                color: optsAtIndex.color
              });
            });
            ctx.restore();
          }
          drawTitle() {
          }
        }
        RadialLinearScale.id = "radialLinear";
        RadialLinearScale.defaults = {
          display: true,
          animate: true,
          position: "chartArea",
          angleLines: {
            display: true,
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0
          },
          grid: {
            circular: false
          },
          startAngle: 0,
          ticks: {
            showLabelBackdrop: true,
            callback: Ticks.formatters.numeric
          },
          pointLabels: {
            backdropColor: void 0,
            backdropPadding: 2,
            display: true,
            font: {
              size: 10
            },
            callback(label) {
              return label;
            },
            padding: 5,
            centerPointLabels: false
          }
        };
        RadialLinearScale.defaultRoutes = {
          "angleLines.color": "borderColor",
          "pointLabels.color": "color",
          "ticks.color": "color"
        };
        RadialLinearScale.descriptors = {
          angleLines: {
            _fallback: "grid"
          }
        };
        const INTERVALS = {
          millisecond: { common: true, size: 1, steps: 1e3 },
          second: { common: true, size: 1e3, steps: 60 },
          minute: { common: true, size: 6e4, steps: 60 },
          hour: { common: true, size: 36e5, steps: 24 },
          day: { common: true, size: 864e5, steps: 30 },
          week: { common: false, size: 6048e5, steps: 4 },
          month: { common: true, size: 2628e6, steps: 12 },
          quarter: { common: false, size: 7884e6, steps: 4 },
          year: { common: true, size: 3154e7 }
        };
        const UNITS = Object.keys(INTERVALS);
        function sorter(a, b) {
          return a - b;
        }
        function parse(scale, input) {
          if (isNullOrUndef(input)) {
            return null;
          }
          const adapter = scale._adapter;
          const { parser, round: round2, isoWeekday } = scale._parseOpts;
          let value = input;
          if (typeof parser === "function") {
            value = parser(value);
          }
          if (!isNumberFinite(value)) {
            value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
          }
          if (value === null) {
            return null;
          }
          if (round2) {
            value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
          }
          return +value;
        }
        function determineUnitForAutoTicks(minUnit, min, max, capacity) {
          const ilen = UNITS.length;
          for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
            const interval = INTERVALS[UNITS[i]];
            const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
            if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
              return UNITS[i];
            }
          }
          return UNITS[ilen - 1];
        }
        function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
          for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
            const unit = UNITS[i];
            if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
              return unit;
            }
          }
          return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
        }
        function determineMajorUnit(unit) {
          for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
            if (INTERVALS[UNITS[i]].common) {
              return UNITS[i];
            }
          }
        }
        function addTick(ticks, time, timestamps) {
          if (!timestamps) {
            ticks[time] = true;
          } else if (timestamps.length) {
            const { lo: lo2, hi: hi2 } = _lookup(timestamps, time);
            const timestamp = timestamps[lo2] >= time ? timestamps[lo2] : timestamps[hi2];
            ticks[timestamp] = true;
          }
        }
        function setMajorTicks(scale, ticks, map2, majorUnit) {
          const adapter = scale._adapter;
          const first = +adapter.startOf(ticks[0].value, majorUnit);
          const last = ticks[ticks.length - 1].value;
          let major, index2;
          for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
            index2 = map2[major];
            if (index2 >= 0) {
              ticks[index2].major = true;
            }
          }
          return ticks;
        }
        function ticksFromTimestamps(scale, values, majorUnit) {
          const ticks = [];
          const map2 = {};
          const ilen = values.length;
          let i, value;
          for (i = 0; i < ilen; ++i) {
            value = values[i];
            map2[value] = i;
            ticks.push({
              value,
              major: false
            });
          }
          return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
        }
        class TimeScale extends Scale {
          constructor(props) {
            super(props);
            this._cache = {
              data: [],
              labels: [],
              all: []
            };
            this._unit = "day";
            this._majorUnit = void 0;
            this._offsets = {};
            this._normalized = false;
            this._parseOpts = void 0;
          }
          init(scaleOpts, opts) {
            const time = scaleOpts.time || (scaleOpts.time = {});
            const adapter = this._adapter = new _adapters._date(scaleOpts.adapters.date);
            adapter.init(opts);
            mergeIf(time.displayFormats, adapter.formats());
            this._parseOpts = {
              parser: time.parser,
              round: time.round,
              isoWeekday: time.isoWeekday
            };
            super.init(scaleOpts);
            this._normalized = opts.normalized;
          }
          parse(raw, index2) {
            if (raw === void 0) {
              return null;
            }
            return parse(this, raw);
          }
          beforeLayout() {
            super.beforeLayout();
            this._cache = {
              data: [],
              labels: [],
              all: []
            };
          }
          determineDataLimits() {
            const options = this.options;
            const adapter = this._adapter;
            const unit = options.time.unit || "day";
            let { min, max, minDefined, maxDefined } = this.getUserBounds();
            function _applyBounds(bounds) {
              if (!minDefined && !isNaN(bounds.min)) {
                min = Math.min(min, bounds.min);
              }
              if (!maxDefined && !isNaN(bounds.max)) {
                max = Math.max(max, bounds.max);
              }
            }
            if (!minDefined || !maxDefined) {
              _applyBounds(this._getLabelBounds());
              if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
                _applyBounds(this.getMinMax(false));
              }
            }
            min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
            max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
            this.min = Math.min(min, max - 1);
            this.max = Math.max(min + 1, max);
          }
          _getLabelBounds() {
            const arr = this.getLabelTimestamps();
            let min = Number.POSITIVE_INFINITY;
            let max = Number.NEGATIVE_INFINITY;
            if (arr.length) {
              min = arr[0];
              max = arr[arr.length - 1];
            }
            return { min, max };
          }
          buildTicks() {
            const options = this.options;
            const timeOpts = options.time;
            const tickOpts = options.ticks;
            const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
            if (options.bounds === "ticks" && timestamps.length) {
              this.min = this._userMin || timestamps[0];
              this.max = this._userMax || timestamps[timestamps.length - 1];
            }
            const min = this.min;
            const max = this.max;
            const ticks = _filterBetween(timestamps, min, max);
            this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
            this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
            this.initOffsets(timestamps);
            if (options.reverse) {
              ticks.reverse();
            }
            return ticksFromTimestamps(this, ticks, this._majorUnit);
          }
          afterAutoSkip() {
            if (this.options.offsetAfterAutoskip) {
              this.initOffsets(this.ticks.map((tick) => +tick.value));
            }
          }
          initOffsets(timestamps) {
            let start = 0;
            let end = 0;
            let first, last;
            if (this.options.offset && timestamps.length) {
              first = this.getDecimalForValue(timestamps[0]);
              if (timestamps.length === 1) {
                start = 1 - first;
              } else {
                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
              }
              last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
              if (timestamps.length === 1) {
                end = last;
              } else {
                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
              }
            }
            const limit = timestamps.length < 3 ? 0.5 : 0.25;
            start = _limitValue(start, 0, limit);
            end = _limitValue(end, 0, limit);
            this._offsets = { start, end, factor: 1 / (start + 1 + end) };
          }
          _generate() {
            const adapter = this._adapter;
            const min = this.min;
            const max = this.max;
            const options = this.options;
            const timeOpts = options.time;
            const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
            const stepSize = valueOrDefault(timeOpts.stepSize, 1);
            const weekday = minor === "week" ? timeOpts.isoWeekday : false;
            const hasWeekday = isNumber(weekday) || weekday === true;
            const ticks = {};
            let first = min;
            let time, count;
            if (hasWeekday) {
              first = +adapter.startOf(first, "isoWeek", weekday);
            }
            first = +adapter.startOf(first, hasWeekday ? "day" : minor);
            if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
              throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
            }
            const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
            for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
              addTick(ticks, time, timestamps);
            }
            if (time === max || options.bounds === "ticks" || count === 1) {
              addTick(ticks, time, timestamps);
            }
            return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
          }
          getLabelForValue(value) {
            const adapter = this._adapter;
            const timeOpts = this.options.time;
            if (timeOpts.tooltipFormat) {
              return adapter.format(value, timeOpts.tooltipFormat);
            }
            return adapter.format(value, timeOpts.displayFormats.datetime);
          }
          _tickFormatFunction(time, index2, ticks, format) {
            const options = this.options;
            const formats = options.time.displayFormats;
            const unit = this._unit;
            const majorUnit = this._majorUnit;
            const minorFormat = unit && formats[unit];
            const majorFormat = majorUnit && formats[majorUnit];
            const tick = ticks[index2];
            const major = majorUnit && majorFormat && tick && tick.major;
            const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
            const formatter = options.ticks.callback;
            return formatter ? callback(formatter, [label, index2, ticks], this) : label;
          }
          generateTickLabels(ticks) {
            let i, ilen, tick;
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              tick = ticks[i];
              tick.label = this._tickFormatFunction(tick.value, i, ticks);
            }
          }
          getDecimalForValue(value) {
            return value === null ? NaN : (value - this.min) / (this.max - this.min);
          }
          getPixelForValue(value) {
            const offsets = this._offsets;
            const pos = this.getDecimalForValue(value);
            return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
          }
          getValueForPixel(pixel) {
            const offsets = this._offsets;
            const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return this.min + pos * (this.max - this.min);
          }
          _getLabelSize(label) {
            const ticksOpts = this.options.ticks;
            const tickLabelWidth = this.ctx.measureText(label).width;
            const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
            const cosRotation = Math.cos(angle);
            const sinRotation = Math.sin(angle);
            const tickFontSize = this._resolveTickFontOptions(0).size;
            return {
              w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
              h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
            };
          }
          _getLabelCapacity(exampleTime) {
            const timeOpts = this.options.time;
            const displayFormats = timeOpts.displayFormats;
            const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
            const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
            const size = this._getLabelSize(exampleLabel);
            const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
            return capacity > 0 ? capacity : 1;
          }
          getDataTimestamps() {
            let timestamps = this._cache.data || [];
            let i, ilen;
            if (timestamps.length) {
              return timestamps;
            }
            const metas = this.getMatchingVisibleMetas();
            if (this._normalized && metas.length) {
              return this._cache.data = metas[0].controller.getAllParsedValues(this);
            }
            for (i = 0, ilen = metas.length; i < ilen; ++i) {
              timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
            }
            return this._cache.data = this.normalize(timestamps);
          }
          getLabelTimestamps() {
            const timestamps = this._cache.labels || [];
            let i, ilen;
            if (timestamps.length) {
              return timestamps;
            }
            const labels = this.getLabels();
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
              timestamps.push(parse(this, labels[i]));
            }
            return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
          }
          normalize(values) {
            return _arrayUnique(values.sort(sorter));
          }
        }
        TimeScale.id = "time";
        TimeScale.defaults = {
          bounds: "data",
          adapters: {},
          time: {
            parser: false,
            unit: false,
            round: false,
            isoWeekday: false,
            minUnit: "millisecond",
            displayFormats: {}
          },
          ticks: {
            source: "auto",
            major: {
              enabled: false
            }
          }
        };
        function interpolate(table, val, reverse) {
          let lo2 = 0;
          let hi2 = table.length - 1;
          let prevSource, nextSource, prevTarget, nextTarget;
          if (reverse) {
            if (val >= table[lo2].pos && val <= table[hi2].pos) {
              ({ lo: lo2, hi: hi2 } = _lookupByKey(table, "pos", val));
            }
            ({ pos: prevSource, time: prevTarget } = table[lo2]);
            ({ pos: nextSource, time: nextTarget } = table[hi2]);
          } else {
            if (val >= table[lo2].time && val <= table[hi2].time) {
              ({ lo: lo2, hi: hi2 } = _lookupByKey(table, "time", val));
            }
            ({ time: prevSource, pos: prevTarget } = table[lo2]);
            ({ time: nextSource, pos: nextTarget } = table[hi2]);
          }
          const span = nextSource - prevSource;
          return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
        }
        class TimeSeriesScale extends TimeScale {
          constructor(props) {
            super(props);
            this._table = [];
            this._minPos = void 0;
            this._tableRange = void 0;
          }
          initOffsets() {
            const timestamps = this._getTimestampsForTable();
            const table = this._table = this.buildLookupTable(timestamps);
            this._minPos = interpolate(table, this.min);
            this._tableRange = interpolate(table, this.max) - this._minPos;
            super.initOffsets(timestamps);
          }
          buildLookupTable(timestamps) {
            const { min, max } = this;
            const items = [];
            const table = [];
            let i, ilen, prev, curr, next;
            for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
              curr = timestamps[i];
              if (curr >= min && curr <= max) {
                items.push(curr);
              }
            }
            if (items.length < 2) {
              return [
                { time: min, pos: 0 },
                { time: max, pos: 1 }
              ];
            }
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              next = items[i + 1];
              prev = items[i - 1];
              curr = items[i];
              if (Math.round((next + prev) / 2) !== curr) {
                table.push({ time: curr, pos: i / (ilen - 1) });
              }
            }
            return table;
          }
          _getTimestampsForTable() {
            let timestamps = this._cache.all || [];
            if (timestamps.length) {
              return timestamps;
            }
            const data = this.getDataTimestamps();
            const label = this.getLabelTimestamps();
            if (data.length && label.length) {
              timestamps = this.normalize(data.concat(label));
            } else {
              timestamps = data.length ? data : label;
            }
            timestamps = this._cache.all = timestamps;
            return timestamps;
          }
          getDecimalForValue(value) {
            return (interpolate(this._table, value) - this._minPos) / this._tableRange;
          }
          getValueForPixel(pixel) {
            const offsets = this._offsets;
            const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
          }
        }
        TimeSeriesScale.id = "timeseries";
        TimeSeriesScale.defaults = TimeScale.defaults;
        var scales = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          CategoryScale,
          LinearScale,
          LogarithmicScale,
          RadialLinearScale,
          TimeScale,
          TimeSeriesScale
        });
        Chart.register(controllers, scales, elements, plugins);
        Chart.helpers = __spreadValues({}, helpers);
        Chart._adapters = _adapters;
        Chart.Animation = Animation;
        Chart.Animations = Animations;
        Chart.animator = animator;
        Chart.controllers = registry.controllers.items;
        Chart.DatasetController = DatasetController;
        Chart.Element = Element2;
        Chart.elements = elements;
        Chart.Interaction = Interaction;
        Chart.layouts = layouts;
        Chart.platforms = platforms;
        Chart.Scale = Scale;
        Chart.Ticks = Ticks;
        Object.assign(Chart, controllers, scales, elements, plugins, platforms);
        Chart.Chart = Chart;
        if (typeof window !== "undefined") {
          window.Chart = Chart;
        }
        return Chart;
      });
    }
  });

  // __tmp__/static/js/statistics.js
  var require_statistics = __commonJS({
    "__tmp__/static/js/statistics.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sleep = exports.toggle_show_students_class_overview = exports.InitLineChart = exports.resolve_student = void 0;
      var chart_js_1 = require_chart();
      var modal_1 = require_modal();
      var app_1 = require_app();
      if (chart_js_1.registerables) {
        chart_js_1.Chart.register(...chart_js_1.registerables);
      }
      function resolve_student(class_id, error_id, prompt) {
        modal_1.modal.confirm(prompt, function() {
          $.ajax({
            type: "DELETE",
            url: "/live_stats/class/" + class_id + "/error/" + error_id,
            contentType: "application/json",
            dataType: "json"
          }).done(function(response) {
            if (response.achievement) {
              (0, app_1.showAchievements)(response.achievement, true, "");
            } else {
              location.reload();
            }
          }).fail(function(err) {
            modal_1.modal.notifyError(err.responseText);
          });
        });
      }
      exports.resolve_student = resolve_student;
      function InitLineChart(data, labels) {
        const ctx = document.getElementById("runsOverTime");
        new chart_js_1.Chart(ctx, {
          type: "line",
          data: {
            labels: labels.map(String),
            datasets: [{
              data,
              fill: false,
              pointBackgroundColor: function(context) {
                var index = context.dataIndex;
                var value = context.dataset.data[index];
                if (value === 0) {
                  return "red";
                } else if (value === 1) {
                  return "green";
                }
                return "blue";
              },
              borderColor: "rgba(0, 0, 255, 0.6)",
              borderWidth: 1
            }]
          },
          options: {
            scales: {
              y: {
                ticks: {
                  callback: function(index) {
                    if (index === 0) {
                      return "Fail";
                    } else if (index === 1) {
                      return "Success";
                    }
                    return "";
                  }
                }
              }
            },
            plugins: {
              legend: {
                display: false
              }
            }
          }
        });
      }
      exports.InitLineChart = InitLineChart;
      function toggle_show_students_class_overview(adventure) {
        var adventure_panel = "div[id='adventure_panel_" + adventure + "']";
        if ($(adventure_panel).hasClass("hidden")) {
          $(adventure_panel).removeClass("hidden");
          $(adventure_panel).addClass("block");
        } else {
          $(adventure_panel).removeClass("block");
          $(adventure_panel).addClass("hidden");
        }
      }
      exports.toggle_show_students_class_overview = toggle_show_students_class_overview;
      var sleep = (ms2) => new Promise((r) => setTimeout(r, ms2));
      exports.sleep = sleep;
    }
  });

  // __tmp__/static/js/logs.js
  var require_logs = __commonJS({
    "__tmp__/static/js/logs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.logs = void 0;
      exports.logs = {
        initialize: function() {
          $("#logs-spinner").hide();
          $("#search-logs-failed-msg").hide();
          $("#search-logs-empty-msg").hide();
          const today = new Date().toISOString().split("T")[0];
          $("#logs-start-date").val(today + " 00:00:00");
          $("#logs-end-date").val(today + " 23:59:59");
        },
        searchProgramLogs: function(classId) {
          var raw_data = $("#logs-search-form").serializeArray();
          var payload = {};
          $.map(raw_data, function(n) {
            payload[n["name"]] = n["value"];
          });
          payload["class_id"] = classId;
          $("#search-logs-empty-msg").hide();
          $("#search-logs-failed-msg").hide();
          $("#logs-spinner").show();
          $("#logs-load-more").hide();
          $("#search-logs-button").prop("disabled", true);
          $("#search-logs-table tbody").html("");
          const self2 = this;
          $.ajax({ type: "POST", url: "/logs/query", data: JSON.stringify(payload), contentType: "application/json; charset=utf-8" }).done(function(response) {
            if (response["query_status"] === "SUCCEEDED") {
              self2.logsExecutionQueryId = response["query_execution_id"];
              self2.logsNextToken = "";
              self2.fetchProgramLogsResults();
            } else {
              $("#search-logs-failed-msg").show();
            }
          }).fail(function(error) {
            $("#search-logs-failed-msg").show();
            console.log(error);
          }).always(function() {
            $("#logs-spinner").hide();
            $("#search-logs-button").prop("disabled", false);
          });
          return false;
        },
        logsExecutionQueryId: "",
        logsNextToken: "",
        fetchProgramLogsResults: function() {
          $("#logs-spinner").show();
          $("#search-logs-empty-msg").hide();
          $("#logs-load-more").hide();
          const data = {
            query_execution_id: this.logsExecutionQueryId,
            next_token: this.logsNextToken ? this.logsNextToken : void 0
          };
          const self2 = this;
          $.get("/logs/results", data).done(function(response) {
            const $logsTable = $("#search-logs-table tbody");
            response.data.forEach((e) => {
              $logsTable.append(`<tr>           <td class="border px-2">${e.date}</td>           <td class="border px-2">${e.level}</td>           <td class="border px-2">${e.lang || ""}</td>           <td class="border px-2 break-words">${e.username || ""}</td>           <td class="border px-2 break-words">${e.exception || ""}</td>           <td class="border px-2 max-w-md">             <button class="green-btn float-right top-2 right-2" onclick=hedyApp.logs.copyCode(this)>\u21E5</button>             <pre class="break-words">${e.code}</pre>           </td></tr>`);
            });
            if (response.data.length == 0) {
              $("#search-logs-empty-msg").show();
            }
            self2.logsNextToken = response.next_token;
          }).fail(function(error) {
            console.log(error);
          }).always(function() {
            $("#logs-spinner").hide();
            if (self2.logsNextToken) {
              $("#logs-load-more").show();
            }
          });
          return false;
        },
        copyCode: function(el2) {
          const copyButton = $(el2);
          if (navigator.clipboard === void 0) {
            updateCopyButtonText(copyButton, "Failed!");
          } else {
            navigator.clipboard.writeText(copyButton.next().text()).then(function() {
              updateCopyButtonText(copyButton, "Copied!");
            }, function() {
              updateCopyButtonText(copyButton, "Failed!");
            });
          }
          return false;
        }
      };
      function updateCopyButtonText(copyBtn, text) {
        copyBtn.text(text);
        setTimeout(function() {
          copyBtn.html("\u21E5");
        }, 2e3);
      }
    }
  });

  // __tmp__/static/js/admin.js
  var require_admin = __commonJS({
    "__tmp__/static/js/admin.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.initializeAdminUserPage = void 0;
      function initializeAdminUserPage(_options) {
        $(".attribute").change(function() {
          const attribute = $(this).attr("id");
          if (!this.checked) {
            $("#" + attribute + "_header").hide();
            $("." + attribute + "_cell").hide();
          } else {
            $("#" + attribute + "_header").show();
            $("." + attribute + "_cell").show();
          }
        });
        $("#admin_filter_category").change(function() {
          $(".filter_input").hide();
          if ($("#admin_filter_category").val() == "email" || $("#admin_filter_category").val() == "username") {
            $("#email_filter_input").show();
          } else if ($("#admin_filter_category").val() == "language") {
            $("#language_filter_input").show();
          } else if ($("#admin_filter_category").val() == "keyword_language") {
            $("#keyword_language_filter_input").show();
          } else {
            $("#date_filter_input").show();
          }
        });
        $("#next_page_btn").click(function() {
          var token = $("#next_page_btn").data("page_token");
          console.log(token);
          $("#hidden-page-input").attr("value", token);
          $("#filterform").submit();
        });
      }
      exports.initializeAdminUserPage = initializeAdminUserPage;
    }
  });

  // __tmp__/static/js/initialize.js
  var require_initialize = __commonJS({
    "__tmp__/static/js/initialize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.initialize = void 0;
      var admin_1 = require_admin();
      var app_1 = require_app();
      var auth_1 = require_auth();
      var client_messages_1 = require_client_messages();
      var logs_1 = require_logs();
      var teachers_1 = require_teachers();
      var tutorial_1 = require_tutorial();
      function initialize(options) {
        var _a2;
        (0, client_messages_1.setClientMessageLanguage)(options.lang);
        (0, app_1.initializeApp)({
          level: options.level,
          keywordLanguage: options.keyword_language,
          staticRoot: options.staticRoot
        });
        (0, auth_1.initializeFormSubmits)();
        (0, tutorial_1.initializeTutorial)();
        switch ((_a2 = options.javascriptPageOptions) === null || _a2 === void 0 ? void 0 : _a2.page) {
          case "code":
            (0, app_1.initializeCodePage)(options.javascriptPageOptions);
            break;
          case "customize-class":
            (0, teachers_1.initializeCustomizeClassPage)(options.javascriptPageOptions);
            break;
          case "for-teachers":
            (0, teachers_1.initializeTeacherPage)(options.javascriptPageOptions);
            break;
          case "class-overview":
            (0, teachers_1.initializeClassOverviewPage)(options.javascriptPageOptions);
            break;
          case "view-program":
            (0, app_1.initializeViewProgramPage)(options.javascriptPageOptions);
            break;
          case "admin-users":
            (0, admin_1.initializeAdminUserPage)(options.javascriptPageOptions);
            break;
        }
        if (options.logs) {
          logs_1.logs.initialize();
        }
      }
      exports.initialize = initialize;
    }
  });

  // __tmp__/static/js/public-adventures.js
  var require_public_adventures = __commonJS({
    "__tmp__/static/js/public-adventures.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.applyFilter = exports.cloned = void 0;
      var modal_1 = require_modal();
      function cloned(message, success = true) {
        if (success) {
          modal_1.modal.notifySuccess(message);
        } else {
          modal_1.modal.notifyError(message);
        }
      }
      exports.cloned = cloned;
      function applyFilter(term, type, filtered) {
        var _a2, _b;
        term = term.trim();
        filtered[type] = filtered[type] || { term, exclude: [] };
        const filterExist = document.querySelector("#search_adventure").value || document.querySelector("#language").value || document.querySelector("#tag").value;
        if (!term) {
          filtered[type] = { term, exclude: [] };
        }
        const adventures = document.querySelectorAll(".adventure");
        if (!filterExist) {
          for (const adv of adventures) {
            adv.classList.remove("hidden");
          }
          filtered = {};
          return;
        }
        for (const adv of adventures) {
          let toValidate;
          if (type === "search") {
            toValidate = (_a2 = adv.querySelector(".name")) === null || _a2 === void 0 ? void 0 : _a2.innerHTML;
          } else if (type === "lang") {
            toValidate = adv.getAttribute("data-lang");
          } else {
            const tags = ((_b = adv.querySelector("#tags-list")) === null || _b === void 0 ? void 0 : _b.children) || [];
            const tagNames = [];
            for (const t of tags) {
              tagNames.push(t.innerHTML);
            }
            toValidate = tagNames.join(" ");
          }
          if (term && (toValidate === null || toValidate === void 0 ? void 0 : toValidate.includes(term))) {
            if (filtered[type].exclude.some((a) => a === adv)) {
              filtered[type].exclude = filtered[type].exclude.filter((a) => a !== adv);
            }
          } else if (term) {
            if (filtered.term !== term && !filtered[type].exclude.some((a) => a === adv)) {
              filtered[type].exclude.push(adv);
            }
          }
        }
        for (const adv of adventures) {
          let allFiltersPassed = true;
          for (const t in filtered) {
            if (filtered[t].exclude.some((a) => a === adv)) {
              allFiltersPassed = false;
            }
          }
          if (allFiltersPassed) {
            adv.classList.remove("hidden");
          } else {
            adv.classList.add("hidden");
          }
        }
      }
      exports.applyFilter = applyFilter;
    }
  });

  // __tmp__/static/js/index.mjs
  var js_exports = {};
  __export(js_exports, {
    getPreviousAndNext: () => import_tabs.getPreviousAndNext,
    loadParsonsExercise: () => import_parsons.loadParsonsExercise
  });
  var import_htmx_integration = __toModule(require_htmx_integration());
  __reExport(js_exports, __toModule(require_modal()));
  __reExport(js_exports, __toModule(require_app()));
  __reExport(js_exports, __toModule(require_auth()));
  __reExport(js_exports, __toModule(require_statistics()));
  __reExport(js_exports, __toModule(require_logs()));
  __reExport(js_exports, __toModule(require_tutorial()));
  __reExport(js_exports, __toModule(require_teachers()));
  __reExport(js_exports, __toModule(require_unsaved_changes()));
  __reExport(js_exports, __toModule(require_initialize()));
  __reExport(js_exports, __toModule(require_debugging()));
  var import_tabs = __toModule(require_tabs());

  // node_modules/tw-elements/dist/js/tw-elements.es.min.js
  var Tn = (() => {
    const s = {};
    let t = 1;
    return {
      set(e, i, n) {
        typeof e[i] > "u" && (e[i] = {
          key: i,
          id: t
        }, t++), s[e[i].id] = n;
      },
      get(e, i) {
        if (!e || typeof e[i] > "u")
          return null;
        const n = e[i];
        return n.key === i ? s[n.id] : null;
      },
      delete(e, i) {
        if (typeof e[i] > "u")
          return;
        const n = e[i];
        n.key === i && (delete s[n.id], delete e[i]);
      }
    };
  })();
  var y = {
    setData(s, t, e) {
      Tn.set(s, t, e);
    },
    getData(s, t) {
      return Tn.get(s, t);
    },
    removeData(s, t) {
      Tn.delete(s, t);
    }
  };
  var Wh = 1e6;
  var Fh = 1e3;
  var xo = "transitionend";
  var Yh = (s) => s == null ? `${s}` : {}.toString.call(s).match(/\s([a-z]+)/i)[1].toLowerCase();
  var rt = (s) => {
    do
      s += Math.floor(Math.random() * Wh);
    while (document.getElementById(s));
    return s;
  };
  var Ul = (s) => {
    let t = s.getAttribute("data-te-target");
    if (!t || t === "#") {
      let e = s.getAttribute("href");
      if (!e || !e.includes("#") && !e.startsWith("."))
        return null;
      e.includes("#") && !e.startsWith("#") && (e = `#${e.split("#")[1]}`), t = e && e !== "#" ? e.trim() : null;
    }
    return t;
  };
  var qo = (s) => {
    const t = Ul(s);
    return t && document.querySelector(t) ? t : null;
  };
  var Jt = (s) => {
    const t = Ul(s);
    return t ? document.querySelector(t) : null;
  };
  var jh = (s) => {
    if (!s)
      return 0;
    let { transitionDuration: t, transitionDelay: e } = window.getComputedStyle(s);
    const i = Number.parseFloat(t), n = Number.parseFloat(e);
    return !i && !n ? 0 : (t = t.split(",")[0], e = e.split(",")[0], (Number.parseFloat(t) + Number.parseFloat(e)) * Fh);
  };
  var Xl = (s) => {
    s.dispatchEvent(new Event(xo));
  };
  var je = (s) => !s || typeof s != "object" ? false : (typeof s.jquery < "u" && (s = s[0]), typeof s.nodeType < "u");
  var te = (s) => je(s) ? s.jquery ? s[0] : s : typeof s == "string" && s.length > 0 ? document.querySelector(s) : null;
  var D = (s, t, e) => {
    Object.keys(e).forEach((i) => {
      const n = e[i], o = t[i], r = o && je(o) ? "element" : Yh(o);
      if (!new RegExp(n).test(r))
        throw new Error(`${s.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${n}".`);
    });
  };
  var Nt = (s) => {
    if (!s || s.getClientRects().length === 0)
      return false;
    if (s.style && s.parentNode && s.parentNode.style) {
      const t = getComputedStyle(s), e = getComputedStyle(s.parentNode);
      return getComputedStyle(s).getPropertyValue("visibility") === "visible" || t.display !== "none" && e.display !== "none" && t.visibility !== "hidden";
    }
    return false;
  };
  var ge = (s) => !s || s.nodeType !== Node.ELEMENT_NODE || s.classList.contains("disabled") ? true : typeof s.disabled < "u" ? s.disabled : s.hasAttribute("disabled") && s.getAttribute("disabled") !== "false";
  var Gl = (s) => {
    if (!document.documentElement.attachShadow)
      return null;
    if (typeof s.getRootNode == "function") {
      const t = s.getRootNode();
      return t instanceof ShadowRoot ? t : null;
    }
    return s instanceof ShadowRoot ? s : s.parentNode ? Gl(s.parentNode) : null;
  };
  var tn = () => function() {
  };
  var ql = () => {
    const { jQuery: s } = window;
    return s && !document.body.hasAttribute("data-te-no-jquery") ? s : null;
  };
  var En = [];
  var Zl = (s) => {
    document.readyState === "loading" ? (En.length || document.addEventListener("DOMContentLoaded", () => {
      En.forEach((t) => t());
    }), En.push(s)) : s();
  };
  var F = () => document.documentElement.dir === "rtl";
  var $2 = (s) => document.createElement(s);
  var me = (s) => {
    typeof s == "function" && s();
  };
  var Ql = (s, t, e = true) => {
    if (!e) {
      me(s);
      return;
    }
    const i = 5, n = jh(t) + i;
    let o = false;
    const r = ({ target: a }) => {
      a === t && (o = true, t.removeEventListener(xo, r), me(s));
    };
    t.addEventListener(xo, r), setTimeout(() => {
      o || Xl(t);
    }, n);
  };
  var zh = /[^.]*(?=\..*)\.|.*/;
  var Uh = /\..*/;
  var Xh = /::\d+$/;
  var Cn = {};
  var xr = 1;
  var Gh = {
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  };
  var qh = /^(mouseenter|mouseleave)/i;
  var tc = /* @__PURE__ */ new Set([
    "click",
    "dblclick",
    "mouseup",
    "mousedown",
    "contextmenu",
    "mousewheel",
    "DOMMouseScroll",
    "mouseover",
    "mouseout",
    "mousemove",
    "selectstart",
    "selectend",
    "keydown",
    "keypress",
    "keyup",
    "orientationchange",
    "touchstart",
    "touchmove",
    "touchend",
    "touchcancel",
    "pointerdown",
    "pointermove",
    "pointerup",
    "pointerleave",
    "pointercancel",
    "gesturestart",
    "gesturechange",
    "gestureend",
    "focus",
    "blur",
    "change",
    "reset",
    "select",
    "submit",
    "focusin",
    "focusout",
    "load",
    "unload",
    "beforeunload",
    "resize",
    "move",
    "DOMContentLoaded",
    "readystatechange",
    "error",
    "abort",
    "scroll"
  ]);
  function ec(s, t) {
    return t && `${t}::${xr++}` || s.uidEvent || xr++;
  }
  function ic(s) {
    const t = ec(s);
    return s.uidEvent = t, Cn[t] = Cn[t] || {}, Cn[t];
  }
  function Zh(s, t) {
    return function e(i) {
      return i.delegateTarget = s, e.oneOff && c.off(s, i.type, t), t.apply(s, [i]);
    };
  }
  function Qh(s, t, e) {
    return function i(n) {
      const o = s.querySelectorAll(t);
      for (let { target: r } = n; r && r !== this; r = r.parentNode)
        for (let a = o.length; a--; "")
          if (o[a] === r)
            return n.delegateTarget = r, i.oneOff && c.off(s, n.type, e), e.apply(r, [n]);
      return null;
    };
  }
  function sc(s, t, e = null) {
    const i = Object.keys(s);
    for (let n = 0, o = i.length; n < o; n++) {
      const r = s[i[n]];
      if (r.originalHandler === t && r.delegationSelector === e)
        return r;
    }
    return null;
  }
  function nc(s, t, e) {
    const i = typeof t == "string", n = i ? e : t;
    let o = oc(s);
    return tc.has(o) || (o = s), [i, n, o];
  }
  function Or(s, t, e, i, n) {
    if (typeof t != "string" || !s)
      return;
    if (e || (e = i, i = null), qh.test(t)) {
      const g = (m) => function(b) {
        if (!b.relatedTarget || b.relatedTarget !== b.delegateTarget && !b.delegateTarget.contains(b.relatedTarget))
          return m.call(this, b);
      };
      i ? i = g(i) : e = g(e);
    }
    const [o, r, a] = nc(t, e, i), l = ic(s), p = l[a] || (l[a] = {}), u = sc(p, r, o ? e : null);
    if (u) {
      u.oneOff = u.oneOff && n;
      return;
    }
    const _ = ec(r, t.replace(zh, "")), f = o ? Qh(s, e, i) : Zh(s, e);
    f.delegationSelector = o ? e : null, f.originalHandler = r, f.oneOff = n, f.uidEvent = _, p[_] = f, s.addEventListener(a, f, o);
  }
  function Oo(s, t, e, i, n) {
    const o = sc(t[e], i, n);
    o && (s.removeEventListener(e, o, !!n), delete t[e][o.uidEvent]);
  }
  function Jh(s, t, e, i) {
    const n = t[e] || {};
    Object.keys(n).forEach((o) => {
      if (o.includes(i)) {
        const r = n[o];
        Oo(s, t, e, r.originalHandler, r.delegationSelector);
      }
    });
  }
  function oc(s) {
    return s = s.replace(Uh, ""), Gh[s] || s;
  }
  var c = {
    on(s, t, e, i) {
      Or(s, t, e, i, false);
    },
    one(s, t, e, i) {
      Or(s, t, e, i, true);
    },
    off(s, t, e, i) {
      if (typeof t != "string" || !s)
        return;
      const [n, o, r] = nc(t, e, i), a = r !== t, l = ic(s), p = t.startsWith(".");
      if (typeof o < "u") {
        if (!l || !l[r])
          return;
        Oo(s, l, r, o, n ? e : null);
        return;
      }
      p && Object.keys(l).forEach((_) => {
        Jh(s, l, _, t.slice(1));
      });
      const u = l[r] || {};
      Object.keys(u).forEach((_) => {
        const f = _.replace(Xh, "");
        if (!a || t.includes(f)) {
          const g = u[_];
          Oo(s, l, r, g.originalHandler, g.delegationSelector);
        }
      });
    },
    trigger(s, t, e) {
      if (typeof t != "string" || !s)
        return null;
      const i = ql(), n = oc(t), o = t !== n, r = tc.has(n);
      let a, l = true, p = true, u = false, _ = null;
      return o && i && (a = i.Event(t, e), i(s).trigger(a), l = !a.isPropagationStopped(), p = !a.isImmediatePropagationStopped(), u = a.isDefaultPrevented()), r ? (_ = document.createEvent("HTMLEvents"), _.initEvent(n, l, true)) : _ = new CustomEvent(t, {
        bubbles: l,
        cancelable: true
      }), typeof e < "u" && Object.keys(e).forEach((f) => {
        Object.defineProperty(_, f, {
          get() {
            return e[f];
          }
        });
      }), u && _.preventDefault(), p && s.dispatchEvent(_), _.defaultPrevented && typeof a < "u" && a.preventDefault(), _;
    }
  };
  var td = "5.1.3";
  var gt = class {
    constructor(t) {
      t = te(t), t && (this._element = t, y.setData(this._element, this.constructor.DATA_KEY, this));
    }
    dispose() {
      y.removeData(this._element, this.constructor.DATA_KEY), c.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t) => {
        this[t] = null;
      });
    }
    _queueCallback(t, e, i = true) {
      Ql(t, e, i);
    }
    static getInstance(t) {
      return y.getData(te(t), this.DATA_KEY);
    }
    static getOrCreateInstance(t, e = {}) {
      return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
    }
    static get VERSION() {
      return td;
    }
    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }
    static get DATA_KEY() {
      return `te.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
  };
  var Q = "top";
  var dt = "bottom";
  var ut = "right";
  var J = "left";
  var Hi = "auto";
  var ti = [Q, dt, ut, J];
  var Te = "start";
  var Ke = "end";
  var ac = "clippingParents";
  var Zo = "viewport";
  var $e = "popper";
  var lc = "reference";
  var So = /* @__PURE__ */ ti.reduce(function(s, t) {
    return s.concat([t + "-" + Te, t + "-" + Ke]);
  }, []);
  var Qo = /* @__PURE__ */ [].concat(ti, [Hi]).reduce(function(s, t) {
    return s.concat([t, t + "-" + Te, t + "-" + Ke]);
  }, []);
  var cc = "beforeRead";
  var hc = "read";
  var dc = "afterRead";
  var uc = "beforeMain";
  var pc = "main";
  var _c = "afterMain";
  var fc = "beforeWrite";
  var mc = "write";
  var gc = "afterWrite";
  var en = [cc, hc, dc, uc, pc, _c, fc, mc, gc];
  function Mt(s) {
    return s ? (s.nodeName || "").toLowerCase() : null;
  }
  function pt(s) {
    if (s == null)
      return window;
    if (s.toString() !== "[object Window]") {
      var t = s.ownerDocument;
      return t && t.defaultView || window;
    }
    return s;
  }
  function Ee(s) {
    var t = pt(s).Element;
    return s instanceof t || s instanceof Element;
  }
  function ht(s) {
    var t = pt(s).HTMLElement;
    return s instanceof t || s instanceof HTMLElement;
  }
  function Jo(s) {
    if (typeof ShadowRoot > "u")
      return false;
    var t = pt(s).ShadowRoot;
    return s instanceof t || s instanceof ShadowRoot;
  }
  function sd(s) {
    var t = s.state;
    Object.keys(t.elements).forEach(function(e) {
      var i = t.styles[e] || {}, n = t.attributes[e] || {}, o = t.elements[e];
      !ht(o) || !Mt(o) || (Object.assign(o.style, i), Object.keys(n).forEach(function(r) {
        var a = n[r];
        a === false ? o.removeAttribute(r) : o.setAttribute(r, a === true ? "" : a);
      }));
    });
  }
  function nd(s) {
    var t = s.state, e = {
      popper: {
        position: t.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {
      Object.keys(t.elements).forEach(function(i) {
        var n = t.elements[i], o = t.attributes[i] || {}, r = Object.keys(t.styles.hasOwnProperty(i) ? t.styles[i] : e[i]), a = r.reduce(function(l, p) {
          return l[p] = "", l;
        }, {});
        !ht(n) || !Mt(n) || (Object.assign(n.style, a), Object.keys(o).forEach(function(l) {
          n.removeAttribute(l);
        }));
      });
    };
  }
  var tr = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: sd,
    effect: nd,
    requires: ["computeStyles"]
  };
  function Tt(s) {
    return s.split("-")[0];
  }
  var be = Math.max;
  var sn = Math.min;
  var ze = Math.round;
  function Io() {
    var s = navigator.userAgentData;
    return s != null && s.brands && Array.isArray(s.brands) ? s.brands.map(function(t) {
      return t.brand + "/" + t.version;
    }).join(" ") : navigator.userAgent;
  }
  function bc() {
    return !/^((?!chrome|android).)*safari/i.test(Io());
  }
  function Ue(s, t, e) {
    t === void 0 && (t = false), e === void 0 && (e = false);
    var i = s.getBoundingClientRect(), n = 1, o = 1;
    t && ht(s) && (n = s.offsetWidth > 0 && ze(i.width) / s.offsetWidth || 1, o = s.offsetHeight > 0 && ze(i.height) / s.offsetHeight || 1);
    var r = Ee(s) ? pt(s) : window, a = r.visualViewport, l = !bc() && e, p = (i.left + (l && a ? a.offsetLeft : 0)) / n, u = (i.top + (l && a ? a.offsetTop : 0)) / o, _ = i.width / n, f = i.height / o;
    return {
      width: _,
      height: f,
      top: u,
      right: p + _,
      bottom: u + f,
      left: p,
      x: p,
      y: u
    };
  }
  function er(s) {
    var t = Ue(s), e = s.offsetWidth, i = s.offsetHeight;
    return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - i) <= 1 && (i = t.height), {
      x: s.offsetLeft,
      y: s.offsetTop,
      width: e,
      height: i
    };
  }
  function vc(s, t) {
    var e = t.getRootNode && t.getRootNode();
    if (s.contains(t))
      return true;
    if (e && Jo(e)) {
      var i = t;
      do {
        if (i && s.isSameNode(i))
          return true;
        i = i.parentNode || i.host;
      } while (i);
    }
    return false;
  }
  function Ct(s) {
    return pt(s).getComputedStyle(s);
  }
  function od(s) {
    return ["table", "td", "th"].indexOf(Mt(s)) >= 0;
  }
  function ee(s) {
    return ((Ee(s) ? s.ownerDocument : s.document) || window.document).documentElement;
  }
  function rn(s) {
    return Mt(s) === "html" ? s : s.assignedSlot || s.parentNode || (Jo(s) ? s.host : null) || ee(s);
  }
  function Sr(s) {
    return !ht(s) || Ct(s).position === "fixed" ? null : s.offsetParent;
  }
  function rd(s) {
    var t = /firefox/i.test(Io()), e = /Trident/i.test(Io());
    if (e && ht(s)) {
      var i = Ct(s);
      if (i.position === "fixed")
        return null;
    }
    var n = rn(s);
    for (Jo(n) && (n = n.host); ht(n) && ["html", "body"].indexOf(Mt(n)) < 0; ) {
      var o = Ct(n);
      if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
        return n;
      n = n.parentNode;
    }
    return null;
  }
  function Vi(s) {
    for (var t = pt(s), e = Sr(s); e && od(e) && Ct(e).position === "static"; )
      e = Sr(e);
    return e && (Mt(e) === "html" || Mt(e) === "body" && Ct(e).position === "static") ? t : e || rd(s) || t;
  }
  function ir(s) {
    return ["top", "bottom"].indexOf(s) >= 0 ? "x" : "y";
  }
  function Si(s, t, e) {
    return be(s, sn(t, e));
  }
  function ad(s, t, e) {
    var i = Si(s, t, e);
    return i > e ? e : i;
  }
  function Tc() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  function Ec(s) {
    return Object.assign({}, Tc(), s);
  }
  function Cc(s, t) {
    return t.reduce(function(e, i) {
      return e[i] = s, e;
    }, {});
  }
  var ld = function(t, e) {
    return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
      placement: e.placement
    })) : t, Ec(typeof t != "number" ? t : Cc(t, ti));
  };
  function cd(s) {
    var t, e = s.state, i = s.name, n = s.options, o = e.elements.arrow, r = e.modifiersData.popperOffsets, a = Tt(e.placement), l = ir(a), p = [J, ut].indexOf(a) >= 0, u = p ? "height" : "width";
    if (!(!o || !r)) {
      var _ = ld(n.padding, e), f = er(o), g = l === "y" ? Q : J, m = l === "y" ? dt : ut, b = e.rects.reference[u] + e.rects.reference[l] - r[l] - e.rects.popper[u], v = r[l] - e.rects.reference[l], C = Vi(o), w = C ? l === "y" ? C.clientHeight || 0 : C.clientWidth || 0 : 0, E = b / 2 - v / 2, T = _[g], A = w - f[u] - _[m], k = w / 2 - f[u] / 2 + E, I = Si(T, k, A), O = l;
      e.modifiersData[i] = (t = {}, t[O] = I, t.centerOffset = I - k, t);
    }
  }
  function hd(s) {
    var t = s.state, e = s.options, i = e.element, n = i === void 0 ? "[data-popper-arrow]" : i;
    if (n != null && !(typeof n == "string" && (n = t.elements.popper.querySelector(n), !n))) {
      if ({}.NODE_ENV !== "production" && (ht(n) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !vc(t.elements.popper, n)) {
        ({}).NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
        return;
      }
      t.elements.arrow = n;
    }
  }
  var Ac = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: cd,
    effect: hd,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function Xe(s) {
    return s.split("-")[1];
  }
  var dd = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function ud(s, t) {
    var e = s.x, i = s.y, n = t.devicePixelRatio || 1;
    return {
      x: ze(e * n) / n || 0,
      y: ze(i * n) / n || 0
    };
  }
  function Ir(s) {
    var t, e = s.popper, i = s.popperRect, n = s.placement, o = s.variation, r = s.offsets, a = s.position, l = s.gpuAcceleration, p = s.adaptive, u = s.roundOffsets, _ = s.isFixed, f = r.x, g = f === void 0 ? 0 : f, m = r.y, b = m === void 0 ? 0 : m, v = typeof u == "function" ? u({
      x: g,
      y: b
    }) : {
      x: g,
      y: b
    };
    g = v.x, b = v.y;
    var C = r.hasOwnProperty("x"), w = r.hasOwnProperty("y"), E = J, T = Q, A = window;
    if (p) {
      var k = Vi(e), I = "clientHeight", O = "clientWidth";
      if (k === pt(e) && (k = ee(e), Ct(k).position !== "static" && a === "absolute" && (I = "scrollHeight", O = "scrollWidth")), k = k, n === Q || (n === J || n === ut) && o === Ke) {
        T = dt;
        var x = _ && k === A && A.visualViewport ? A.visualViewport.height : k[I];
        b -= x - i.height, b *= l ? 1 : -1;
      }
      if (n === J || (n === Q || n === dt) && o === Ke) {
        E = ut;
        var L = _ && k === A && A.visualViewport ? A.visualViewport.width : k[O];
        g -= L - i.width, g *= l ? 1 : -1;
      }
    }
    var S = Object.assign({
      position: a
    }, p && dd), N = u === true ? ud({
      x: g,
      y: b
    }, pt(e)) : {
      x: g,
      y: b
    };
    if (g = N.x, b = N.y, l) {
      var P;
      return Object.assign({}, S, (P = {}, P[T] = w ? "0" : "", P[E] = C ? "0" : "", P.transform = (A.devicePixelRatio || 1) <= 1 ? "translate(" + g + "px, " + b + "px)" : "translate3d(" + g + "px, " + b + "px, 0)", P));
    }
    return Object.assign({}, S, (t = {}, t[T] = w ? b + "px" : "", t[E] = C ? g + "px" : "", t.transform = "", t));
  }
  function pd(s) {
    var t = s.state, e = s.options, i = e.gpuAcceleration, n = i === void 0 ? true : i, o = e.adaptive, r = o === void 0 ? true : o, a = e.roundOffsets, l = a === void 0 ? true : a;
    if ({}.NODE_ENV !== "production") {
      var p = Ct(t.elements.popper).transitionProperty || "";
      r && ["transform", "top", "right", "bottom", "left"].some(function(_) {
        return p.indexOf(_) >= 0;
      }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
    var u = {
      placement: Tt(t.placement),
      variation: Xe(t.placement),
      popper: t.elements.popper,
      popperRect: t.rects.popper,
      gpuAcceleration: n,
      isFixed: t.options.strategy === "fixed"
    };
    t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Ir(Object.assign({}, u, {
      offsets: t.modifiersData.popperOffsets,
      position: t.options.strategy,
      adaptive: r,
      roundOffsets: l
    })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Ir(Object.assign({}, u, {
      offsets: t.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets: l
    })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
      "data-popper-placement": t.placement
    });
  }
  var sr = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: pd,
    data: {}
  };
  var ts = {
    passive: true
  };
  function _d(s) {
    var t = s.state, e = s.instance, i = s.options, n = i.scroll, o = n === void 0 ? true : n, r = i.resize, a = r === void 0 ? true : r, l = pt(t.elements.popper), p = [].concat(t.scrollParents.reference, t.scrollParents.popper);
    return o && p.forEach(function(u) {
      u.addEventListener("scroll", e.update, ts);
    }), a && l.addEventListener("resize", e.update, ts), function() {
      o && p.forEach(function(u) {
        u.removeEventListener("scroll", e.update, ts);
      }), a && l.removeEventListener("resize", e.update, ts);
    };
  }
  var nr = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function() {
    },
    effect: _d,
    data: {}
  };
  var fd = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function Ms(s) {
    return s.replace(/left|right|bottom|top/g, function(t) {
      return fd[t];
    });
  }
  var md = {
    start: "end",
    end: "start"
  };
  function Dr(s) {
    return s.replace(/start|end/g, function(t) {
      return md[t];
    });
  }
  function or(s) {
    var t = pt(s), e = t.pageXOffset, i = t.pageYOffset;
    return {
      scrollLeft: e,
      scrollTop: i
    };
  }
  function rr(s) {
    return Ue(ee(s)).left + or(s).scrollLeft;
  }
  function gd(s, t) {
    var e = pt(s), i = ee(s), n = e.visualViewport, o = i.clientWidth, r = i.clientHeight, a = 0, l = 0;
    if (n) {
      o = n.width, r = n.height;
      var p = bc();
      (p || !p && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
    }
    return {
      width: o,
      height: r,
      x: a + rr(s),
      y: l
    };
  }
  function bd(s) {
    var t, e = ee(s), i = or(s), n = (t = s.ownerDocument) == null ? void 0 : t.body, o = be(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), r = be(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -i.scrollLeft + rr(s), l = -i.scrollTop;
    return Ct(n || e).direction === "rtl" && (a += be(e.clientWidth, n ? n.clientWidth : 0) - o), {
      width: o,
      height: r,
      x: a,
      y: l
    };
  }
  function ar(s) {
    var t = Ct(s), e = t.overflow, i = t.overflowX, n = t.overflowY;
    return /auto|scroll|overlay|hidden/.test(e + n + i);
  }
  function yc(s) {
    return ["html", "body", "#document"].indexOf(Mt(s)) >= 0 ? s.ownerDocument.body : ht(s) && ar(s) ? s : yc(rn(s));
  }
  function Ii(s, t) {
    var e;
    t === void 0 && (t = []);
    var i = yc(s), n = i === ((e = s.ownerDocument) == null ? void 0 : e.body), o = pt(i), r = n ? [o].concat(o.visualViewport || [], ar(i) ? i : []) : i, a = t.concat(r);
    return n ? a : a.concat(Ii(rn(r)));
  }
  function Do(s) {
    return Object.assign({}, s, {
      left: s.x,
      top: s.y,
      right: s.x + s.width,
      bottom: s.y + s.height
    });
  }
  function vd(s, t) {
    var e = Ue(s, false, t === "fixed");
    return e.top = e.top + s.clientTop, e.left = e.left + s.clientLeft, e.bottom = e.top + s.clientHeight, e.right = e.left + s.clientWidth, e.width = s.clientWidth, e.height = s.clientHeight, e.x = e.left, e.y = e.top, e;
  }
  function $r(s, t, e) {
    return t === Zo ? Do(gd(s, e)) : Ee(t) ? vd(t, e) : Do(bd(ee(s)));
  }
  function Td(s) {
    var t = Ii(rn(s)), e = ["absolute", "fixed"].indexOf(Ct(s).position) >= 0, i = e && ht(s) ? Vi(s) : s;
    return Ee(i) ? t.filter(function(n) {
      return Ee(n) && vc(n, i) && Mt(n) !== "body";
    }) : [];
  }
  function Ed(s, t, e, i) {
    var n = t === "clippingParents" ? Td(s) : [].concat(t), o = [].concat(n, [e]), r = o[0], a = o.reduce(function(l, p) {
      var u = $r(s, p, i);
      return l.top = be(u.top, l.top), l.right = sn(u.right, l.right), l.bottom = sn(u.bottom, l.bottom), l.left = be(u.left, l.left), l;
    }, $r(s, r, i));
    return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
  }
  function wc(s) {
    var t = s.reference, e = s.element, i = s.placement, n = i ? Tt(i) : null, o = i ? Xe(i) : null, r = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, l;
    switch (n) {
      case Q:
        l = {
          x: r,
          y: t.y - e.height
        };
        break;
      case dt:
        l = {
          x: r,
          y: t.y + t.height
        };
        break;
      case ut:
        l = {
          x: t.x + t.width,
          y: a
        };
        break;
      case J:
        l = {
          x: t.x - e.width,
          y: a
        };
        break;
      default:
        l = {
          x: t.x,
          y: t.y
        };
    }
    var p = n ? ir(n) : null;
    if (p != null) {
      var u = p === "y" ? "height" : "width";
      switch (o) {
        case Te:
          l[p] = l[p] - (t[u] / 2 - e[u] / 2);
          break;
        case Ke:
          l[p] = l[p] + (t[u] / 2 - e[u] / 2);
          break;
      }
    }
    return l;
  }
  function Ge(s, t) {
    t === void 0 && (t = {});
    var e = t, i = e.placement, n = i === void 0 ? s.placement : i, o = e.strategy, r = o === void 0 ? s.strategy : o, a = e.boundary, l = a === void 0 ? ac : a, p = e.rootBoundary, u = p === void 0 ? Zo : p, _ = e.elementContext, f = _ === void 0 ? $e : _, g = e.altBoundary, m = g === void 0 ? false : g, b = e.padding, v = b === void 0 ? 0 : b, C = Ec(typeof v != "number" ? v : Cc(v, ti)), w = f === $e ? lc : $e, E = s.rects.popper, T = s.elements[m ? w : f], A = Ed(Ee(T) ? T : T.contextElement || ee(s.elements.popper), l, u, r), k = Ue(s.elements.reference), I = wc({
      reference: k,
      element: E,
      strategy: "absolute",
      placement: n
    }), O = Do(Object.assign({}, E, I)), x = f === $e ? O : k, L = {
      top: A.top - x.top + C.top,
      bottom: x.bottom - A.bottom + C.bottom,
      left: A.left - x.left + C.left,
      right: x.right - A.right + C.right
    }, S = s.modifiersData.offset;
    if (f === $e && S) {
      var N = S[n];
      Object.keys(L).forEach(function(P) {
        var tt = [ut, dt].indexOf(P) >= 0 ? 1 : -1, et = [Q, dt].indexOf(P) >= 0 ? "y" : "x";
        L[P] += N[et] * tt;
      });
    }
    return L;
  }
  function Cd(s, t) {
    t === void 0 && (t = {});
    var e = t, i = e.placement, n = e.boundary, o = e.rootBoundary, r = e.padding, a = e.flipVariations, l = e.allowedAutoPlacements, p = l === void 0 ? Qo : l, u = Xe(i), _ = u ? a ? So : So.filter(function(m) {
      return Xe(m) === u;
    }) : ti, f = _.filter(function(m) {
      return p.indexOf(m) >= 0;
    });
    f.length === 0 && (f = _, {}.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
    var g = f.reduce(function(m, b) {
      return m[b] = Ge(s, {
        placement: b,
        boundary: n,
        rootBoundary: o,
        padding: r
      })[Tt(b)], m;
    }, {});
    return Object.keys(g).sort(function(m, b) {
      return g[m] - g[b];
    });
  }
  function Ad(s) {
    if (Tt(s) === Hi)
      return [];
    var t = Ms(s);
    return [Dr(s), t, Dr(t)];
  }
  function yd(s) {
    var t = s.state, e = s.options, i = s.name;
    if (!t.modifiersData[i]._skip) {
      for (var n = e.mainAxis, o = n === void 0 ? true : n, r = e.altAxis, a = r === void 0 ? true : r, l = e.fallbackPlacements, p = e.padding, u = e.boundary, _ = e.rootBoundary, f = e.altBoundary, g = e.flipVariations, m = g === void 0 ? true : g, b = e.allowedAutoPlacements, v = t.options.placement, C = Tt(v), w = C === v, E = l || (w || !m ? [Ms(v)] : Ad(v)), T = [v].concat(E).reduce(function(ye, Ht) {
        return ye.concat(Tt(Ht) === Hi ? Cd(t, {
          placement: Ht,
          boundary: u,
          rootBoundary: _,
          padding: p,
          flipVariations: m,
          allowedAutoPlacements: b
        }) : Ht);
      }, []), A = t.rects.reference, k = t.rects.popper, I = /* @__PURE__ */ new Map(), O = true, x = T[0], L = 0; L < T.length; L++) {
        var S = T[L], N = Tt(S), P = Xe(S) === Te, tt = [Q, dt].indexOf(N) >= 0, et = tt ? "width" : "height", U = Ge(t, {
          placement: S,
          boundary: u,
          rootBoundary: _,
          altBoundary: f,
          padding: p
        }), bt = tt ? P ? ut : J : P ? dt : Q;
        A[et] > k[et] && (bt = Ms(bt));
        var Gi = Ms(bt), se = [];
        if (o && se.push(U[N] <= 0), a && se.push(U[bt] <= 0, U[Gi] <= 0), se.every(function(ye) {
          return ye;
        })) {
          x = S, O = false;
          break;
        }
        I.set(S, se);
      }
      if (O)
        for (var qi = m ? 3 : 1, mn = function(Ht) {
          var ri = T.find(function(Qi) {
            var ne = I.get(Qi);
            if (ne)
              return ne.slice(0, Ht).every(function(gn) {
                return gn;
              });
          });
          if (ri)
            return x = ri, "break";
        }, oi = qi; oi > 0; oi--) {
          var Zi = mn(oi);
          if (Zi === "break")
            break;
        }
      t.placement !== x && (t.modifiersData[i]._skip = true, t.placement = x, t.reset = true);
    }
  }
  var kc = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: yd,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };
  function Lr(s, t, e) {
    return e === void 0 && (e = {
      x: 0,
      y: 0
    }), {
      top: s.top - t.height - e.y,
      right: s.right - t.width + e.x,
      bottom: s.bottom - t.height + e.y,
      left: s.left - t.width - e.x
    };
  }
  function Nr(s) {
    return [Q, ut, dt, J].some(function(t) {
      return s[t] >= 0;
    });
  }
  function wd(s) {
    var t = s.state, e = s.name, i = t.rects.reference, n = t.rects.popper, o = t.modifiersData.preventOverflow, r = Ge(t, {
      elementContext: "reference"
    }), a = Ge(t, {
      altBoundary: true
    }), l = Lr(r, i), p = Lr(a, n, o), u = Nr(l), _ = Nr(p);
    t.modifiersData[e] = {
      referenceClippingOffsets: l,
      popperEscapeOffsets: p,
      isReferenceHidden: u,
      hasPopperEscaped: _
    }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
      "data-popper-reference-hidden": u,
      "data-popper-escaped": _
    });
  }
  var xc = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: wd
  };
  function kd(s, t, e) {
    var i = Tt(s), n = [J, Q].indexOf(i) >= 0 ? -1 : 1, o = typeof e == "function" ? e(Object.assign({}, t, {
      placement: s
    })) : e, r = o[0], a = o[1];
    return r = r || 0, a = (a || 0) * n, [J, ut].indexOf(i) >= 0 ? {
      x: a,
      y: r
    } : {
      x: r,
      y: a
    };
  }
  function xd(s) {
    var t = s.state, e = s.options, i = s.name, n = e.offset, o = n === void 0 ? [0, 0] : n, r = Qo.reduce(function(u, _) {
      return u[_] = kd(_, t.rects, o), u;
    }, {}), a = r[t.placement], l = a.x, p = a.y;
    t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += p), t.modifiersData[i] = r;
  }
  var Oc = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: xd
  };
  function Od(s) {
    var t = s.state, e = s.name;
    t.modifiersData[e] = wc({
      reference: t.rects.reference,
      element: t.rects.popper,
      strategy: "absolute",
      placement: t.placement
    });
  }
  var lr = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: Od,
    data: {}
  };
  function Sd(s) {
    return s === "x" ? "y" : "x";
  }
  function Id(s) {
    var t = s.state, e = s.options, i = s.name, n = e.mainAxis, o = n === void 0 ? true : n, r = e.altAxis, a = r === void 0 ? false : r, l = e.boundary, p = e.rootBoundary, u = e.altBoundary, _ = e.padding, f = e.tether, g = f === void 0 ? true : f, m = e.tetherOffset, b = m === void 0 ? 0 : m, v = Ge(t, {
      boundary: l,
      rootBoundary: p,
      padding: _,
      altBoundary: u
    }), C = Tt(t.placement), w = Xe(t.placement), E = !w, T = ir(C), A = Sd(T), k = t.modifiersData.popperOffsets, I = t.rects.reference, O = t.rects.popper, x = typeof b == "function" ? b(Object.assign({}, t.rects, {
      placement: t.placement
    })) : b, L = typeof x == "number" ? {
      mainAxis: x,
      altAxis: x
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, x), S = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, N = {
      x: 0,
      y: 0
    };
    if (k) {
      if (o) {
        var P, tt = T === "y" ? Q : J, et = T === "y" ? dt : ut, U = T === "y" ? "height" : "width", bt = k[T], Gi = bt + v[tt], se = bt - v[et], qi = g ? -O[U] / 2 : 0, mn = w === Te ? I[U] : O[U], oi = w === Te ? -O[U] : -I[U], Zi = t.elements.arrow, ye = g && Zi ? er(Zi) : {
          width: 0,
          height: 0
        }, Ht = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : Tc(), ri = Ht[tt], Qi = Ht[et], ne = Si(0, I[U], ye[U]), gn = E ? I[U] / 2 - qi - ne - ri - L.mainAxis : mn - ne - ri - L.mainAxis, Lh = E ? -I[U] / 2 + qi + ne + Qi + L.mainAxis : oi + ne + Qi + L.mainAxis, bn = t.elements.arrow && Vi(t.elements.arrow), Nh = bn ? T === "y" ? bn.clientTop || 0 : bn.clientLeft || 0 : 0, br = (P = S == null ? void 0 : S[T]) != null ? P : 0, Mh = bt + gn - br - Nh, Rh = bt + Lh - br, vr = Si(g ? sn(Gi, Mh) : Gi, bt, g ? be(se, Rh) : se);
        k[T] = vr, N[T] = vr - bt;
      }
      if (a) {
        var Tr, Ph = T === "x" ? Q : J, Bh = T === "x" ? dt : ut, oe = k[A], Ji = A === "y" ? "height" : "width", Er = oe + v[Ph], Cr = oe - v[Bh], vn = [Q, J].indexOf(C) !== -1, Ar = (Tr = S == null ? void 0 : S[A]) != null ? Tr : 0, yr = vn ? Er : oe - I[Ji] - O[Ji] - Ar + L.altAxis, wr = vn ? oe + I[Ji] + O[Ji] - Ar - L.altAxis : Cr, kr = g && vn ? ad(yr, oe, wr) : Si(g ? yr : Er, oe, g ? wr : Cr);
        k[A] = kr, N[A] = kr - oe;
      }
      t.modifiersData[i] = N;
    }
  }
  var Sc = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: Id,
    requiresIfExists: ["offset"]
  };
  function Dd(s) {
    return {
      scrollLeft: s.scrollLeft,
      scrollTop: s.scrollTop
    };
  }
  function $d(s) {
    return s === pt(s) || !ht(s) ? or(s) : Dd(s);
  }
  function Ld(s) {
    var t = s.getBoundingClientRect(), e = ze(t.width) / s.offsetWidth || 1, i = ze(t.height) / s.offsetHeight || 1;
    return e !== 1 || i !== 1;
  }
  function Nd(s, t, e) {
    e === void 0 && (e = false);
    var i = ht(t), n = ht(t) && Ld(t), o = ee(t), r = Ue(s, n, e), a = {
      scrollLeft: 0,
      scrollTop: 0
    }, l = {
      x: 0,
      y: 0
    };
    return (i || !i && !e) && ((Mt(t) !== "body" || ar(o)) && (a = $d(t)), ht(t) ? (l = Ue(t, true), l.x += t.clientLeft, l.y += t.clientTop) : o && (l.x = rr(o))), {
      x: r.left + a.scrollLeft - l.x,
      y: r.top + a.scrollTop - l.y,
      width: r.width,
      height: r.height
    };
  }
  function Md(s) {
    var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), i = [];
    s.forEach(function(o) {
      t.set(o.name, o);
    });
    function n(o) {
      e.add(o.name);
      var r = [].concat(o.requires || [], o.requiresIfExists || []);
      r.forEach(function(a) {
        if (!e.has(a)) {
          var l = t.get(a);
          l && n(l);
        }
      }), i.push(o);
    }
    return s.forEach(function(o) {
      e.has(o.name) || n(o);
    }), i;
  }
  function Rd(s) {
    var t = Md(s);
    return en.reduce(function(e, i) {
      return e.concat(t.filter(function(n) {
        return n.phase === i;
      }));
    }, []);
  }
  function Pd(s) {
    var t;
    return function() {
      return t || (t = new Promise(function(e) {
        Promise.resolve().then(function() {
          t = void 0, e(s());
        });
      })), t;
    };
  }
  function Vt(s) {
    for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      e[i - 1] = arguments[i];
    return [].concat(e).reduce(function(n, o) {
      return n.replace(/%s/, o);
    }, s);
  }
  var ae = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var Bd = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var Mr = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function Hd(s) {
    s.forEach(function(t) {
      [].concat(Object.keys(t), Mr).filter(function(e, i, n) {
        return n.indexOf(e) === i;
      }).forEach(function(e) {
        switch (e) {
          case "name":
            typeof t.name != "string" && console.error(Vt(ae, String(t.name), '"name"', '"string"', '"' + String(t.name) + '"'));
            break;
          case "enabled":
            typeof t.enabled != "boolean" && console.error(Vt(ae, t.name, '"enabled"', '"boolean"', '"' + String(t.enabled) + '"'));
            break;
          case "phase":
            en.indexOf(t.phase) < 0 && console.error(Vt(ae, t.name, '"phase"', "either " + en.join(", "), '"' + String(t.phase) + '"'));
            break;
          case "fn":
            typeof t.fn != "function" && console.error(Vt(ae, t.name, '"fn"', '"function"', '"' + String(t.fn) + '"'));
            break;
          case "effect":
            t.effect != null && typeof t.effect != "function" && console.error(Vt(ae, t.name, '"effect"', '"function"', '"' + String(t.fn) + '"'));
            break;
          case "requires":
            t.requires != null && !Array.isArray(t.requires) && console.error(Vt(ae, t.name, '"requires"', '"array"', '"' + String(t.requires) + '"'));
            break;
          case "requiresIfExists":
            Array.isArray(t.requiresIfExists) || console.error(Vt(ae, t.name, '"requiresIfExists"', '"array"', '"' + String(t.requiresIfExists) + '"'));
            break;
          case "options":
          case "data":
            break;
          default:
            console.error('PopperJS: an invalid property has been provided to the "' + t.name + '" modifier, valid properties are ' + Mr.map(function(i) {
              return '"' + i + '"';
            }).join(", ") + '; but "' + e + '" was provided.');
        }
        t.requires && t.requires.forEach(function(i) {
          s.find(function(n) {
            return n.name === i;
          }) == null && console.error(Vt(Bd, String(t.name), i, i));
        });
      });
    });
  }
  function Vd(s, t) {
    var e = /* @__PURE__ */ new Set();
    return s.filter(function(i) {
      var n = t(i);
      if (!e.has(n))
        return e.add(n), true;
    });
  }
  function Wd(s) {
    var t = s.reduce(function(e, i) {
      var n = e[i.name];
      return e[i.name] = n ? Object.assign({}, n, i, {
        options: Object.assign({}, n.options, i.options),
        data: Object.assign({}, n.data, i.data)
      }) : i, e;
    }, {});
    return Object.keys(t).map(function(e) {
      return t[e];
    });
  }
  var Rr = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
  var Fd = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
  var Pr = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function Br() {
    for (var s = arguments.length, t = new Array(s), e = 0; e < s; e++)
      t[e] = arguments[e];
    return !t.some(function(i) {
      return !(i && typeof i.getBoundingClientRect == "function");
    });
  }
  function an(s) {
    s === void 0 && (s = {});
    var t = s, e = t.defaultModifiers, i = e === void 0 ? [] : e, n = t.defaultOptions, o = n === void 0 ? Pr : n;
    return function(a, l, p) {
      p === void 0 && (p = o);
      var u = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, Pr, o),
        modifiersData: {},
        elements: {
          reference: a,
          popper: l
        },
        attributes: {},
        styles: {}
      }, _ = [], f = false, g = {
        state: u,
        setOptions: function(C) {
          var w = typeof C == "function" ? C(u.options) : C;
          b(), u.options = Object.assign({}, o, u.options, w), u.scrollParents = {
            reference: Ee(a) ? Ii(a) : a.contextElement ? Ii(a.contextElement) : [],
            popper: Ii(l)
          };
          var E = Rd(Wd([].concat(i, u.options.modifiers)));
          if (u.orderedModifiers = E.filter(function(S) {
            return S.enabled;
          }), {}.NODE_ENV !== "production") {
            var T = Vd([].concat(E, u.options.modifiers), function(S) {
              var N = S.name;
              return N;
            });
            if (Hd(T), Tt(u.options.placement) === Hi) {
              var A = u.orderedModifiers.find(function(S) {
                var N = S.name;
                return N === "flip";
              });
              A || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
            var k = Ct(l), I = k.marginTop, O = k.marginRight, x = k.marginBottom, L = k.marginLeft;
            [I, O, x, L].some(function(S) {
              return parseFloat(S);
            }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
          return m(), g.update();
        },
        forceUpdate: function() {
          if (!f) {
            var C = u.elements, w = C.reference, E = C.popper;
            if (!Br(w, E)) {
              ({}).NODE_ENV !== "production" && console.error(Rr);
              return;
            }
            u.rects = {
              reference: Nd(w, Vi(E), u.options.strategy === "fixed"),
              popper: er(E)
            }, u.reset = false, u.placement = u.options.placement, u.orderedModifiers.forEach(function(S) {
              return u.modifiersData[S.name] = Object.assign({}, S.data);
            });
            for (var T = 0, A = 0; A < u.orderedModifiers.length; A++) {
              if ({}.NODE_ENV !== "production" && (T += 1, T > 100)) {
                console.error(Fd);
                break;
              }
              if (u.reset === true) {
                u.reset = false, A = -1;
                continue;
              }
              var k = u.orderedModifiers[A], I = k.fn, O = k.options, x = O === void 0 ? {} : O, L = k.name;
              typeof I == "function" && (u = I({
                state: u,
                options: x,
                name: L,
                instance: g
              }) || u);
            }
          }
        },
        update: Pd(function() {
          return new Promise(function(v) {
            g.forceUpdate(), v(u);
          });
        }),
        destroy: function() {
          b(), f = true;
        }
      };
      if (!Br(a, l))
        return {}.NODE_ENV !== "production" && console.error(Rr), g;
      g.setOptions(p).then(function(v) {
        !f && p.onFirstUpdate && p.onFirstUpdate(v);
      });
      function m() {
        u.orderedModifiers.forEach(function(v) {
          var C = v.name, w = v.options, E = w === void 0 ? {} : w, T = v.effect;
          if (typeof T == "function") {
            var A = T({
              state: u,
              name: C,
              instance: g,
              options: E
            }), k = function() {
            };
            _.push(A || k);
          }
        });
      }
      function b() {
        _.forEach(function(v) {
          return v();
        }), _ = [];
      }
      return g;
    };
  }
  var Yd = /* @__PURE__ */ an();
  var jd = [nr, lr, sr, tr];
  var Kd = /* @__PURE__ */ an({
    defaultModifiers: jd
  });
  var zd = [nr, lr, sr, tr, Oc, kc, Sc, Ac, xc];
  var Ce = /* @__PURE__ */ an({
    defaultModifiers: zd
  });
  var Ic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    afterMain: _c,
    afterRead: dc,
    afterWrite: gc,
    applyStyles: tr,
    arrow: Ac,
    auto: Hi,
    basePlacements: ti,
    beforeMain: uc,
    beforeRead: cc,
    beforeWrite: fc,
    bottom: dt,
    clippingParents: ac,
    computeStyles: sr,
    createPopper: Ce,
    createPopperBase: Yd,
    createPopperLite: Kd,
    detectOverflow: Ge,
    end: Ke,
    eventListeners: nr,
    flip: kc,
    hide: xc,
    left: J,
    main: pc,
    modifierPhases: en,
    offset: Oc,
    placements: Qo,
    popper: $e,
    popperGenerator: an,
    popperOffsets: lr,
    preventOverflow: Sc,
    read: hc,
    reference: lc,
    right: ut,
    start: Te,
    top: Q,
    variationPlacements: So,
    viewport: Zo,
    write: mc
  }, Symbol.toStringTag, { value: "Module" }));
  function An(s) {
    return s === "true" ? true : s === "false" ? false : s === Number(s).toString() ? Number(s) : s === "" || s === "null" ? null : s;
  }
  function yn(s) {
    return s.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
  }
  var h = {
    setDataAttribute(s, t, e) {
      s.setAttribute(`data-te-${yn(t)}`, e);
    },
    removeDataAttribute(s, t) {
      s.removeAttribute(`data-te-${yn(t)}`);
    },
    getDataAttributes(s) {
      if (!s)
        return {};
      const t = {};
      return Object.keys(s.dataset).filter((e) => e.startsWith("te")).forEach((e) => {
        if (e.startsWith("teClass"))
          return;
        let i = e.replace(/^te/, "");
        i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = An(s.dataset[e]);
      }), t;
    },
    getDataClassAttributes(s) {
      if (!s)
        return {};
      const t = __spreadValues({}, s.dataset);
      return Object.keys(t).filter((e) => e.startsWith("teClass")).forEach((e) => {
        let i = e.replace(/^teClass/, "");
        i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = An(t[e]);
      }), t;
    },
    getDataAttribute(s, t) {
      return An(s.getAttribute(`data-te-${yn(t)}`));
    },
    offset(s) {
      const t = s.getBoundingClientRect();
      return {
        top: t.top + document.body.scrollTop,
        left: t.left + document.body.scrollLeft
      };
    },
    position(s) {
      return {
        top: s.offsetTop,
        left: s.offsetLeft
      };
    },
    style(s, t) {
      Object.assign(s.style, t);
    },
    toggleClass(s, t) {
      s && wn(t).forEach((e) => {
        s.classList.contains(e) ? s.classList.remove(e) : s.classList.add(e);
      });
    },
    addClass(s, t) {
      wn(t).forEach((e) => !s.classList.contains(e) && s.classList.add(e));
    },
    addStyle(s, t) {
      Object.keys(t).forEach((e) => {
        s.style[e] = t[e];
      });
    },
    removeClass(s, t) {
      wn(t).forEach((e) => s.classList.contains(e) && s.classList.remove(e));
    },
    hasClass(s, t) {
      return s.classList.contains(t);
    },
    maxOffset(s) {
      const t = s.getBoundingClientRect();
      return {
        top: t.top + Math.max(document.body.scrollTop, document.documentElement.scrollTop, window.scrollY),
        left: t.left + Math.max(document.body.scrollLeft, document.documentElement.scrollLeft, window.scrollX)
      };
    }
  };
  function wn(s) {
    return typeof s == "string" ? s.split(" ") : Array.isArray(s) ? s : false;
  }
  var Ud = 3;
  var d = {
    closest(s, t) {
      return s.closest(t);
    },
    matches(s, t) {
      return s.matches(t);
    },
    find(s, t = document.documentElement) {
      return [].concat(...Element.prototype.querySelectorAll.call(t, s));
    },
    findOne(s, t = document.documentElement) {
      return Element.prototype.querySelector.call(t, s);
    },
    children(s, t) {
      return [].concat(...s.children).filter((i) => i.matches(t));
    },
    parents(s, t) {
      const e = [];
      let i = s.parentNode;
      for (; i && i.nodeType === Node.ELEMENT_NODE && i.nodeType !== Ud; )
        this.matches(i, t) && e.push(i), i = i.parentNode;
      return e;
    },
    prev(s, t) {
      let e = s.previousElementSibling;
      for (; e; ) {
        if (e.matches(t))
          return [e];
        e = e.previousElementSibling;
      }
      return [];
    },
    next(s, t) {
      let e = s.nextElementSibling;
      for (; e; ) {
        if (this.matches(e, t))
          return [e];
        e = e.nextElementSibling;
      }
      return [];
    },
    focusableChildren(s) {
      const t = [
        "a",
        "button",
        "input",
        "textarea",
        "select",
        "details",
        "[tabindex]",
        '[contenteditable="true"]'
      ].map((e) => `${e}:not([tabindex^="-"])`).join(", ");
      return this.find(t, s).filter((e) => !ge(e) && Nt(e));
    }
  };
  var Xd = "te.dropdown";
  var Ae = `.${Xd}`;
  var cr = ".data-api";
  var Rs = "Escape";
  var $o = "ArrowUp";
  var Ps = "ArrowDown";
  var qd = new RegExp(`${$o}|${Ps}|${Rs}`);
  var Zd = `hide${Ae}`;
  var Qd = `hidden${Ae}`;
  var Jd = `show${Ae}`;
  var tu = `shown${Ae}`;
  var eu = `click${Ae}${cr}`;
  var Wr = `keydown${Ae}${cr}`;
  var iu = `keyup${Ae}${cr}`;
  var cu = F() ? "top-end" : "top-start";
  var hu = F() ? "top-start" : "top-end";
  var du = F() ? "bottom-end" : "bottom-start";
  var uu = F() ? "bottom-start" : "bottom-end";
  var pu = F() ? "left-start" : "right-start";
  var _u = F() ? "right-start" : "left-start";
  var Dc = "te.collapse";
  var ln = `.${Dc}`;
  var Tu = `show${ln}`;
  var Eu = `shown${ln}`;
  var Cu = `hide${ln}`;
  var Au = `hidden${ln}`;
  var Me = "data-te-collapse-item";
  var jr = `:scope [${Me}] [${Me}]`;
  var $c = "backdrop";
  var Xr = `mousedown.te.${$c}`;
  var $u = "te.offcanvas";
  var ei = `.${$u}`;
  var Lu = ".data-api";
  var Nu = `load${ei}${Lu}`;
  var Bu = `show${ei}`;
  var Hu = `shown${ei}`;
  var Vu = `hide${ei}`;
  var Wu = `hidden${ei}`;
  var Fu = `keydown.dismiss${ei}`;
  var Yu = "te.alert";
  var Lc = `.${Yu}`;
  var ju = `close${Lc}`;
  var Ku = `closed${Lc}`;
  var Gu = "te.carousel";
  var _t = `.${Gu}`;
  var Nc = ".data-api";
  var qu = "ArrowLeft";
  var Zu = "ArrowRight";
  var _e = "left";
  var mi = "right";
  var sp = {
    [qu]: mi,
    [Zu]: _e
  };
  var np = `slide${_t}`;
  var $n = `slid${_t}`;
  var op = `keydown${_t}`;
  var rp = `mouseenter${_t}`;
  var ap = `mouseleave${_t}`;
  var lp = `touchstart${_t}`;
  var cp = `touchmove${_t}`;
  var hp = `touchend${_t}`;
  var dp = `pointerdown${_t}`;
  var up = `pointerup${_t}`;
  var pp = `dragstart${_t}`;
  var _p = `load${_t}${Nc}`;
  var fp = `click${_t}${Nc}`;
  var Mc = "[data-te-carousel-active]";
  var dr = "[data-te-carousel-item]";
  var we = `${Mc}${dr}`;
  var Ep = `${dr} img`;
  var Op = "te.modal";
  var At = `.${Op}`;
  var $p = `hide${At}`;
  var Lp = `hidePrevented${At}`;
  var Np = `hidden${At}`;
  var Mp = `show${At}`;
  var Rp = `shown${At}`;
  var na = `resize${At}`;
  var oa = `click.dismiss${At}`;
  var ra = `keydown.dismiss${At}`;
  var Pp = `mouseup.dismiss${At}`;
  var aa = `mousedown.dismiss${At}`;
  var Hp = /* @__PURE__ */ new Set([
    "background",
    "cite",
    "href",
    "itemtype",
    "longdesc",
    "poster",
    "src",
    "xlink:href"
  ]);
  var Vp = /^aria-[\w-]*$/i;
  var Wp = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
  var Fp = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
  var Yp = (s, t) => {
    const e = s.nodeName.toLowerCase();
    if (t.includes(e))
      return Hp.has(e) ? !!(Wp.test(s.nodeValue) || Fp.test(s.nodeValue)) : true;
    const i = t.filter((n) => n instanceof RegExp);
    for (let n = 0, o = i.length; n < o; n++)
      if (i[n].test(e))
        return true;
    return false;
  };
  var jp = {
    "*": ["class", "dir", "id", "lang", "role", Vp],
    a: ["target", "href", "title", "rel"],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ["src", "srcset", "alt", "title", "width", "height"],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  };
  function ha(s, t, e) {
    if (!s.length)
      return s;
    if (e && typeof e == "function")
      return e(s);
    const n = new window.DOMParser().parseFromString(s, "text/html"), o = [].concat(...n.body.querySelectorAll("*"));
    for (let r = 0, a = o.length; r < a; r++) {
      const l = o[r], p = l.nodeName.toLowerCase();
      if (!Object.keys(t).includes(p)) {
        l.remove();
        continue;
      }
      const u = [].concat(...l.attributes), _ = [].concat(t["*"] || [], t[p] || []);
      u.forEach((f) => {
        Yp(f, _) || l.removeAttribute(f.nodeName);
      });
    }
    return n.body.innerHTML;
  }
  var da = "tooltip";
  var Kp = "te.tooltip";
  var wt = `.${Kp}`;
  var zp = "te-tooltip";
  var Up = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]);
  var Xp = {
    animation: "boolean",
    template: "string",
    title: "(string|element|function)",
    trigger: "string",
    delay: "(number|object)",
    html: "boolean",
    selector: "(string|boolean)",
    placement: "(string|function)",
    offset: "(array|string|function)",
    container: "(string|element|boolean)",
    fallbackPlacements: "array",
    boundary: "(string|element)",
    customClass: "(string|function)",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    allowList: "object",
    popperConfig: "(null|object|function)"
  };
  var Gp = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: F() ? "left" : "right",
    BOTTOM: "bottom",
    LEFT: F() ? "right" : "left"
  };
  var qp = {
    animation: true,
    template: '<div class="opacity-0 transition-opacity duration-300 ease-in-out absolute z-[1080] block m-0 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal" role="tooltip"><div data-te-tooltip-inner-ref class="tooltip-inner max-w-[200px] text-sm py-1.5 px-4 text-white text-center bg-[#6d6d6d] rounded"></div></div>',
    trigger: "hover focus",
    title: "",
    delay: 0,
    html: false,
    selector: false,
    placement: "top",
    offset: [0, 0],
    container: false,
    fallbackPlacements: ["top", "right", "bottom", "left"],
    boundary: "clippingParents",
    customClass: "",
    sanitize: true,
    sanitizeFn: null,
    allowList: jp,
    popperConfig: { hide: true }
  };
  var Zp = {
    HIDE: `hide${wt}`,
    HIDDEN: `hidden${wt}`,
    SHOW: `show${wt}`,
    SHOWN: `shown${wt}`,
    INSERTED: `inserted${wt}`,
    CLICK: `click${wt}`,
    FOCUSIN: `focusin${wt}`,
    FOCUSOUT: `focusout${wt}`,
    MOUSEENTER: `mouseenter${wt}`,
    MOUSELEAVE: `mouseleave${wt}`
  };
  var Qp = "fade";
  var Jp = "modal";
  var Mn = "show";
  var ci = "show";
  var Rn = "out";
  var ua = ".tooltip-inner";
  var pa = `.${Jp}`;
  var _a = "hide.te.modal";
  var hi = "hover";
  var Pn = "focus";
  var t_ = "click";
  var e_ = "manual";
  var ii = class extends gt {
    constructor(t, e) {
      if (typeof Ic > "u")
        throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
      super(t), this._isEnabled = true, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners();
    }
    static get Default() {
      return qp;
    }
    static get NAME() {
      return da;
    }
    static get Event() {
      return Zp;
    }
    static get DefaultType() {
      return Xp;
    }
    enable() {
      this._isEnabled = true;
    }
    disable() {
      this._isEnabled = false;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle(t) {
      if (this._isEnabled)
        if (t) {
          const e = this._initializeOnDelegatedTarget(t);
          e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);
        } else {
          if (this.getTipElement().classList.contains(Mn)) {
            this._leave(null, this);
            return;
          }
          this._enter(null, this);
        }
    }
    dispose() {
      clearTimeout(this._timeout), c.off(this._element.closest(pa), _a, this._hideModalHandler), this.tip && this.tip.remove(), this._disposePopper(), super.dispose();
    }
    show() {
      if (this._element.style.display === "none")
        throw new Error("Please use show on visible elements");
      if (!(this.isWithContent() && this._isEnabled))
        return;
      const t = c.trigger(this._element, this.constructor.Event.SHOW), e = Gl(this._element), i = e === null ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);
      if (t.defaultPrevented || !i)
        return;
      this.constructor.NAME === "tooltip" && this.tip && this.getTitle() !== this.tip.querySelector(ua).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null);
      const n = this.getTipElement(), o = rt(this.constructor.NAME);
      n.setAttribute("id", o), this._element.setAttribute("aria-describedby", o), this._config.animation && setTimeout(() => {
        this.tip.classList.add("opacity-100"), this.tip.classList.remove("opacity-0");
      }, 100);
      const r = typeof this._config.placement == "function" ? this._config.placement.call(this, n, this._element) : this._config.placement, a = this._getAttachment(r);
      this._addAttachmentClass(a);
      const { container: l } = this._config;
      if (y.setData(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l.append(n), c.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = Ce(this._element, n, this._getPopperConfig(a)), n.getAttribute("id").includes("tooltip"))
        switch (r) {
          case "bottom":
            n.classList.add("py-[0.4rem]");
            break;
          case "left":
            n.classList.add("px-[0.4rem]");
            break;
          case "right":
            n.classList.add("px-[0.4rem]");
            break;
          default:
            n.classList.add("py-[0.4rem]");
            break;
        }
      const u = this._resolvePossibleFunction(this._config.customClass);
      u && n.classList.add(...u.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((g) => {
        c.on(g, "mouseover", tn);
      });
      const _ = () => {
        const g = this._hoverState;
        this._hoverState = null, c.trigger(this._element, this.constructor.Event.SHOWN), g === Rn && this._leave(null, this);
      }, f = this.tip.classList.contains("transition-opacity");
      this._queueCallback(_, this.tip, f);
    }
    hide() {
      if (!this._popper)
        return;
      const t = this.getTipElement(), e = () => {
        this._isWithActiveTrigger() || (this._hoverState !== ci && t.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), c.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper());
      };
      if (c.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented)
        return;
      t.classList.add("opacity-0"), t.classList.remove("opacity-100"), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((o) => c.off(o, "mouseover", tn)), this._activeTrigger[t_] = false, this._activeTrigger[Pn] = false, this._activeTrigger[hi] = false;
      const n = this.tip.classList.contains("opacity-0");
      this._queueCallback(e, this.tip, n), this._hoverState = "";
    }
    update() {
      this._popper !== null && this._popper.update();
    }
    isWithContent() {
      return !!this.getTitle();
    }
    getTipElement() {
      if (this.tip)
        return this.tip;
      const t = document.createElement("div");
      t.innerHTML = this._config.template;
      const e = t.children[0];
      return this.setContent(e), e.classList.remove(Qp, Mn), this.tip = e, this.tip;
    }
    setContent(t) {
      this._sanitizeAndSetContent(t, this.getTitle(), ua);
    }
    _sanitizeAndSetContent(t, e, i) {
      const n = d.findOne(i, t);
      if (!e && n) {
        n.remove();
        return;
      }
      this.setElementContent(n, e);
    }
    setElementContent(t, e) {
      if (t !== null) {
        if (je(e)) {
          e = te(e), this._config.html ? e.parentNode !== t && (t.innerHTML = "", t.append(e)) : t.textContent = e.textContent;
          return;
        }
        this._config.html ? (this._config.sanitize && (e = ha(e, this._config.allowList, this._config.sanitizeFn)), t.innerHTML = e) : t.textContent = e;
      }
    }
    getTitle() {
      const t = this._element.getAttribute("data-te-original-title") || this._config.title;
      return this._resolvePossibleFunction(t);
    }
    updateAttachment(t) {
      return t === "right" ? "end" : t === "left" ? "start" : t;
    }
    _initializeOnDelegatedTarget(t, e) {
      return e || this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig());
    }
    _getOffset() {
      const { offset: t } = this._config;
      return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
    }
    _resolvePossibleFunction(t) {
      return typeof t == "function" ? t.call(this._element) : t;
    }
    _getPopperConfig(t) {
      const e = {
        placement: t,
        modifiers: [
          {
            name: "flip",
            options: {
              fallbackPlacements: this._config.fallbackPlacements
            }
          },
          {
            name: "offset",
            options: {
              offset: this._getOffset()
            }
          },
          {
            name: "preventOverflow",
            options: {
              boundary: this._config.boundary
            }
          },
          {
            name: "arrow",
            options: {
              element: `.${this.constructor.NAME}-arrow`
            }
          },
          {
            name: "onChange",
            enabled: true,
            phase: "afterWrite",
            fn: (i) => this._handlePopperPlacementChange(i)
          }
        ],
        onFirstUpdate: (i) => {
          i.options.placement !== i.placement && this._handlePopperPlacementChange(i);
        }
      };
      return __spreadValues(__spreadValues({}, e), typeof this._config.popperConfig == "function" ? this._config.popperConfig(e) : this._config.popperConfig);
    }
    _addAttachmentClass(t) {
      this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`);
    }
    _getAttachment(t) {
      return Gp[t.toUpperCase()];
    }
    _setListeners() {
      this._config.trigger.split(" ").forEach((e) => {
        if (e === "click")
          c.on(this._element, this.constructor.Event.CLICK, this._config.selector, (i) => this.toggle(i));
        else if (e !== e_) {
          const i = e === hi ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, n = e === hi ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
          c.on(this._element, i, this._config.selector, (o) => this._enter(o)), c.on(this._element, n, this._config.selector, (o) => this._leave(o));
        }
      }), this._hideModalHandler = () => {
        this._element && this.hide();
      }, c.on(this._element.closest(pa), _a, this._hideModalHandler), this._config.selector ? this._config = __spreadProps(__spreadValues({}, this._config), {
        trigger: "manual",
        selector: ""
      }) : this._fixTitle();
    }
    _fixTitle() {
      const t = this._element.getAttribute("title"), e = typeof this._element.getAttribute("data-te-original-title");
      (t || e !== "string") && (this._element.setAttribute("data-te-original-title", t || ""), t && !this._element.getAttribute("aria-label") && !this._element.textContent && this._element.setAttribute("aria-label", t), this._element.setAttribute("title", ""));
    }
    _enter(t, e) {
      if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusin" ? Pn : hi] = true), e.getTipElement().classList.contains(Mn) || e._hoverState === ci) {
        e._hoverState = ci;
        return;
      }
      if (clearTimeout(e._timeout), e._hoverState = ci, !e._config.delay || !e._config.delay.show) {
        e.show();
        return;
      }
      e._timeout = setTimeout(() => {
        e._hoverState === ci && e.show();
      }, e._config.delay.show);
    }
    _leave(t, e) {
      if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusout" ? Pn : hi] = e._element.contains(t.relatedTarget)), !e._isWithActiveTrigger()) {
        if (clearTimeout(e._timeout), e._hoverState = Rn, !e._config.delay || !e._config.delay.hide) {
          e.hide();
          return;
        }
        e._timeout = setTimeout(() => {
          e._hoverState === Rn && e.hide();
        }, e._config.delay.hide);
      }
    }
    _isWithActiveTrigger() {
      for (const t in this._activeTrigger)
        if (this._activeTrigger[t])
          return true;
      return false;
    }
    _getConfig(t) {
      const e = h.getDataAttributes(this._element);
      return Object.keys(e).forEach((i) => {
        Up.has(i) && delete e[i];
      }), t = __spreadValues(__spreadValues(__spreadValues({}, this.constructor.Default), e), typeof t == "object" && t ? t : {}), t.container = t.container === false ? document.body : te(t.container), typeof t.delay == "number" && (t.delay = {
        show: t.delay,
        hide: t.delay
      }), typeof t.title == "number" && (t.title = t.title.toString()), typeof t.content == "number" && (t.content = t.content.toString()), D(da, t, this.constructor.DefaultType), t.sanitize && (t.template = ha(t.template, t.allowList, t.sanitizeFn)), t;
    }
    _getDelegateConfig() {
      const t = {};
      for (const e in this._config)
        this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);
      return t;
    }
    _cleanTipClass() {
      const t = this.getTipElement(), e = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, "g"), i = t.getAttribute("class").match(e);
      i !== null && i.length > 0 && i.map((n) => n.trim()).forEach((n) => t.classList.remove(n));
    }
    _getBasicClassPrefix() {
      return zp;
    }
    _handlePopperPlacementChange(t) {
      const { state: e } = t;
      e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));
    }
    _disposePopper() {
      this._popper && (this._popper.destroy(), this._popper = null);
    }
    static jQueryInterface(t) {
      return this.each(function() {
        const e = ii.getOrCreateInstance(this, t);
        if (typeof t == "string") {
          if (typeof e[t] > "u")
            throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  };
  var s_ = "te.popover";
  var kt = `.${s_}`;
  var o_ = __spreadProps(__spreadValues({}, ii.Default), {
    placement: "right",
    offset: [0, 8],
    trigger: "click",
    content: "",
    template: '<div class="opacity-0 transition-opacity duration-150 ease-in-out absolute top-0 left-0 z-[1070] block max-w-[267px] break-words bg-white bg-clip-padding border border-neutral-100 rounded-lg shadow-[0_0px_3px_0_rgba(0,0,0,0.07),0_2px_2px_0_rgba(0,0,0,0.04)] text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal dark:bg-neutral-700 dark:border-0 dark:text-white data-[popper-reference-hidden]:hidden" role="tooltip"><h3 class="popover-header py-2 px-4 mb-0 border-b-2 border-neutral-100 rounded-t-lg font-medium empty:hidden dark:border-neutral-500"></h3><div class="popover-body p-4 text-[#212529] dark:text-white"></div></div>'
  });
  var r_ = __spreadProps(__spreadValues({}, ii.DefaultType), {
    content: "(string|element|function)"
  });
  var a_ = {
    HIDE: `hide${kt}`,
    HIDDEN: `hidden${kt}`,
    SHOW: `show${kt}`,
    SHOWN: `shown${kt}`,
    INSERTED: `inserted${kt}`,
    CLICK: `click${kt}`,
    FOCUSIN: `focusin${kt}`,
    FOCUSOUT: `focusout${kt}`,
    MOUSEENTER: `mouseenter${kt}`,
    MOUSELEAVE: `mouseleave${kt}`
  };
  var h_ = "te.scrollspy";
  var ur = `.${h_}`;
  var __ = `activate${ur}`;
  var f_ = `scroll${ur}`;
  var Pc = "[data-te-dropdown-item-ref]";
  var Mo = "[data-te-nav-link-ref]";
  var Bc = "[data-te-list-group-item-ref]";
  var Vn = `${Mo}, ${Bc}, ${Pc}`;
  var E_ = "te.tab";
  var hn = `.${E_}`;
  var C_ = `hide${hn}`;
  var A_ = `hidden${hn}`;
  var y_ = `show${hn}`;
  var w_ = `shown${hn}`;
  var Le = "data-te-tab-active";
  var Hs = "data-te-nav-active";
  var ba = `[${Le}]`;
  var S_ = `[${Hs}]`;
  var N_ = "te.toast";
  var ie = `.${N_}`;
  var M_ = `mouseover${ie}`;
  var R_ = `mouseout${ie}`;
  var P_ = `focusin${ie}`;
  var B_ = `focusout${ie}`;
  var H_ = `hide${ie}`;
  var V_ = `hidden${ie}`;
  var W_ = `show${ie}`;
  var F_ = `shown${ie}`;
  (() => {
    var s = { 454: (i, n, o) => {
      o.d(n, { Z: () => l });
      var r = o(645), a = o.n(r)()(function(p) {
        return p[1];
      });
      a.push([i.id, "INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}", ""]);
      const l = a;
    }, 645: (i) => {
      i.exports = function(n) {
        var o = [];
        return o.toString = function() {
          return this.map(function(r) {
            var a = n(r);
            return r[2] ? "@media ".concat(r[2], " {").concat(a, "}") : a;
          }).join("");
        }, o.i = function(r, a, l) {
          typeof r == "string" && (r = [[null, r, ""]]);
          var p = {};
          if (l)
            for (var u = 0; u < this.length; u++) {
              var _ = this[u][0];
              _ != null && (p[_] = true);
            }
          for (var f = 0; f < r.length; f++) {
            var g = [].concat(r[f]);
            l && p[g[0]] || (a && (g[2] ? g[2] = "".concat(a, " and ").concat(g[2]) : g[2] = a), o.push(g));
          }
        }, o;
      };
    }, 810: () => {
      (function() {
        if (typeof window < "u")
          try {
            var i = new window.CustomEvent("test", { cancelable: true });
            if (i.preventDefault(), i.defaultPrevented !== true)
              throw new Error("Could not prevent default");
          } catch (e2) {
            var n = function(r, a) {
              var l, p;
              return (a = a || {}).bubbles = !!a.bubbles, a.cancelable = !!a.cancelable, (l = document.createEvent("CustomEvent")).initCustomEvent(r, a.bubbles, a.cancelable, a.detail), p = l.preventDefault, l.preventDefault = function() {
                p.call(this);
                try {
                  Object.defineProperty(this, "defaultPrevented", { get: function() {
                    return true;
                  } });
                } catch (e3) {
                  this.defaultPrevented = true;
                }
              }, l;
            };
            n.prototype = window.Event.prototype, window.CustomEvent = n;
          }
      })();
    }, 379: (i, n, o) => {
      var r, a = function() {
        var E = {};
        return function(T) {
          if (E[T] === void 0) {
            var A = document.querySelector(T);
            if (window.HTMLIFrameElement && A instanceof window.HTMLIFrameElement)
              try {
                A = A.contentDocument.head;
              } catch (e2) {
                A = null;
              }
            E[T] = A;
          }
          return E[T];
        };
      }(), l = [];
      function p(E) {
        for (var T = -1, A = 0; A < l.length; A++)
          if (l[A].identifier === E) {
            T = A;
            break;
          }
        return T;
      }
      function u(E, T) {
        for (var A = {}, k = [], I = 0; I < E.length; I++) {
          var O = E[I], x = T.base ? O[0] + T.base : O[0], L = A[x] || 0, S = "".concat(x, " ").concat(L);
          A[x] = L + 1;
          var N = p(S), P = { css: O[1], media: O[2], sourceMap: O[3] };
          N !== -1 ? (l[N].references++, l[N].updater(P)) : l.push({ identifier: S, updater: w(P, T), references: 1 }), k.push(S);
        }
        return k;
      }
      function _(E) {
        var T = document.createElement("style"), A = E.attributes || {};
        if (A.nonce === void 0) {
          var k = o.nc;
          k && (A.nonce = k);
        }
        if (Object.keys(A).forEach(function(O) {
          T.setAttribute(O, A[O]);
        }), typeof E.insert == "function")
          E.insert(T);
        else {
          var I = a(E.insert || "head");
          if (!I)
            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
          I.appendChild(T);
        }
        return T;
      }
      var f, g = (f = [], function(E, T) {
        return f[E] = T, f.filter(Boolean).join(`
`);
      });
      function m(E, T, A, k) {
        var I = A ? "" : k.media ? "@media ".concat(k.media, " {").concat(k.css, "}") : k.css;
        if (E.styleSheet)
          E.styleSheet.cssText = g(T, I);
        else {
          var O = document.createTextNode(I), x = E.childNodes;
          x[T] && E.removeChild(x[T]), x.length ? E.insertBefore(O, x[T]) : E.appendChild(O);
        }
      }
      function b(E, T, A) {
        var k = A.css, I = A.media, O = A.sourceMap;
        if (I ? E.setAttribute("media", I) : E.removeAttribute("media"), O && typeof btoa < "u" && (k += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(O)))), " */")), E.styleSheet)
          E.styleSheet.cssText = k;
        else {
          for (; E.firstChild; )
            E.removeChild(E.firstChild);
          E.appendChild(document.createTextNode(k));
        }
      }
      var v = null, C = 0;
      function w(E, T) {
        var A, k, I;
        if (T.singleton) {
          var O = C++;
          A = v || (v = _(T)), k = m.bind(null, A, O, false), I = m.bind(null, A, O, true);
        } else
          A = _(T), k = b.bind(null, A, T), I = function() {
            (function(x) {
              if (x.parentNode === null)
                return false;
              x.parentNode.removeChild(x);
            })(A);
          };
        return k(E), function(x) {
          if (x) {
            if (x.css === E.css && x.media === E.media && x.sourceMap === E.sourceMap)
              return;
            k(E = x);
          } else
            I();
        };
      }
      i.exports = function(E, T) {
        (T = T || {}).singleton || typeof T.singleton == "boolean" || (T.singleton = (r === void 0 && (r = !!(window && document && document.all && !window.atob)), r));
        var A = u(E = E || [], T);
        return function(k) {
          if (k = k || [], Object.prototype.toString.call(k) === "[object Array]") {
            for (var I = 0; I < A.length; I++) {
              var O = p(A[I]);
              l[O].references--;
            }
            for (var x = u(k, T), L = 0; L < A.length; L++) {
              var S = p(A[L]);
              l[S].references === 0 && (l[S].updater(), l.splice(S, 1));
            }
            A = x;
          }
        };
      };
    } }, t = {};
    function e(i) {
      var n = t[i];
      if (n !== void 0)
        return n.exports;
      var o = t[i] = { id: i, exports: {} };
      return s[i](o, o.exports, e), o.exports;
    }
    e.n = (i) => {
      var n = i && i.__esModule ? () => i.default : () => i;
      return e.d(n, { a: n }), n;
    }, e.d = (i, n) => {
      for (var o in n)
        e.o(n, o) && !e.o(i, o) && Object.defineProperty(i, o, { enumerable: true, get: n[o] });
    }, e.o = (i, n) => Object.prototype.hasOwnProperty.call(i, n), (() => {
      var i = e(379), n = e.n(i), o = e(454);
      function r(l) {
        if (!l.hasAttribute("autocompleted")) {
          l.setAttribute("autocompleted", "");
          var p = new window.CustomEvent("onautocomplete", { bubbles: true, cancelable: true, detail: null });
          l.dispatchEvent(p) || (l.value = "");
        }
      }
      function a(l) {
        l.hasAttribute("autocompleted") && (l.removeAttribute("autocompleted"), l.dispatchEvent(new window.CustomEvent("onautocomplete", { bubbles: true, cancelable: false, detail: null })));
      }
      n()(o.Z, { insert: "head", singleton: false }), o.Z.locals, e(810), document.addEventListener("animationstart", function(l) {
        l.animationName === "onautofillstart" ? r(l.target) : a(l.target);
      }, true), document.addEventListener("input", function(l) {
        l.inputType !== "insertReplacementText" && "data" in l ? a(l.target) : r(l.target);
      }, true);
    })();
  })();
  var Yn = "input";
  var os = "te.input";
  var Wc = "data-te-input-wrapper-init";
  var Fc = "data-te-input-notch-ref";
  var Yc = "data-te-input-notch-leading-ref";
  var jc = "data-te-input-notch-middle-ref";
  var z_ = "data-te-input-notch-trailing-ref";
  var U_ = "data-te-input-helper-ref";
  var X_ = "data-te-input-placeholder-active";
  var Ft = "data-te-input-state-active";
  var Ca = "data-te-input-focused";
  var Aa = "data-te-input-form-counter";
  var de = `[${Wc}] input`;
  var ue = `[${Wc}] textarea`;
  var ke = `[${Fc}]`;
  var ya = `[${Yc}]`;
  var wa = `[${jc}]`;
  var G_ = `[${U_}]`;
  var q_ = {
    inputFormWhite: false
  };
  var Z_ = {
    inputFormWhite: "(boolean)"
  };
  var Kc = {
    notch: "group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none",
    notchLeading: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0",
    notchLeadingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
    notchLeadingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[-1px_0_0_#ffffff,_0_1px_0_0_#ffffff,_0_-1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
    notchMiddle: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent",
    notchMiddleNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
    notchMiddleWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
    notchTrailing: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0",
    notchTrailingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
    notchTrailingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[1px_0_0_#ffffff,_0_-1px_0_0_#ffffff,_0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
    counter: "text-right leading-[1.6]"
  };
  var Q_ = {
    notch: "string",
    notchLeading: "string",
    notchLeadingNormal: "string",
    notchLeadingWhite: "string",
    notchMiddle: "string",
    notchMiddleNormal: "string",
    notchMiddleWhite: "string",
    notchTrailing: "string",
    notchTrailingNormal: "string",
    notchTrailingWhite: "string",
    counter: "string"
  };
  var V = class {
    constructor(t, e, i) {
      this._config = this._getConfig(e, t), this._element = t, this._classes = this._getClasses(i), this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = false, this._helper = null, this._counter = false, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (y.setData(t, os, this), this.init());
    }
    static get NAME() {
      return Yn;
    }
    get input() {
      return d.findOne("input", this._element) || d.findOne("textarea", this._element);
    }
    init() {
      this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._getEvents(), this._initiated = true);
    }
    update() {
      this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter();
    }
    forceActive() {
      this.input.setAttribute(Ft, ""), d.findOne(ke, this.input.parentNode).setAttribute(Ft, "");
    }
    forceInactive() {
      this.input.removeAttribute(Ft), d.findOne(ke, this.input.parentNode).removeAttribute(Ft);
    }
    dispose() {
      this._removeBorder(), y.removeData(this._element, os), this._element = null;
    }
    _getConfig(t, e) {
      return t = __spreadValues(__spreadValues(__spreadValues({}, q_), h.getDataAttributes(e)), typeof t == "object" ? t : {}), D(Yn, t, Z_), t;
    }
    _getClasses(t) {
      const e = h.getDataClassAttributes(this._element);
      return t = __spreadValues(__spreadValues(__spreadValues({}, Kc), e), t), D(Yn, t, Q_), t;
    }
    _getLabelData() {
      this._label = d.findOne("label", this._element), this._label === null ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder());
    }
    _getHelper() {
      this._helper = d.findOne(G_, this._element);
    }
    _getCounter() {
      this._counter = h.getDataAttribute(this.input, "inputShowcounter"), this._counter && (this._maxLength = this.input.maxLength, this._showCounter());
    }
    _getEvents() {
      c.on(document, "focus", de, V.activate(new V())), c.on(document, "input", de, V.activate(new V())), c.on(document, "blur", de, V.deactivate(new V())), c.on(document, "focus", ue, V.activate(new V())), c.on(document, "input", ue, V.activate(new V())), c.on(document, "blur", ue, V.deactivate(new V())), c.on(window, "shown.te.modal", (t) => {
        d.find(de, t.target).forEach((e) => {
          const i = V.getInstance(e.parentNode);
          i && i.update();
        }), d.find(ue, t.target).forEach((e) => {
          const i = V.getInstance(e.parentNode);
          i && i.update();
        });
      }), c.on(window, "shown.te.dropdown", (t) => {
        const e = t.target.parentNode.querySelector("[data-te-dropdown-menu-ref]");
        e && (d.find(de, e).forEach((i) => {
          const n = V.getInstance(i.parentNode);
          n && n.update();
        }), d.find(ue, e).forEach((i) => {
          const n = V.getInstance(i.parentNode);
          n && n.update();
        }));
      }), c.on(window, "shown.te.tab", (t) => {
        let e;
        t.target.href ? e = t.target.href.split("#")[1] : e = h.getDataAttribute(t.target, "target").split("#")[1];
        const i = d.findOne(`#${e}`);
        d.find(de, i).forEach((n) => {
          const o = V.getInstance(n.parentNode);
          o && o.update();
        }), d.find(ue, i).forEach((n) => {
          const o = V.getInstance(n.parentNode);
          o && o.update();
        });
      }), c.on(window, "reset", (t) => {
        d.find(de, t.target).forEach((e) => {
          const i = V.getInstance(e.parentNode);
          i && i.forceInactive();
        }), d.find(ue, t.target).forEach((e) => {
          const i = V.getInstance(e.parentNode);
          i && i.forceInactive();
        });
      }), c.on(window, "onautocomplete", (t) => {
        const e = V.getInstance(t.target.parentNode);
        !e || !t.cancelable || e.forceActive();
      });
    }
    _showCounter() {
      if (d.find(`[${Aa}]`, this._element).length > 0)
        return;
      this._counterElement = document.createElement("div"), h.addClass(this._counterElement, this._classes.counter), this._counterElement.setAttribute(Aa, "");
      const e = this.input.value.length;
      this._counterElement.innerHTML = `${e} / ${this._maxLength}`, this._helper.appendChild(this._counterElement), this._bindCounter();
    }
    _bindCounter() {
      c.on(this.input, "input", () => {
        const t = this.input.value.length;
        this._counterElement.innerHTML = `${t} / ${this._maxLength}`;
      });
    }
    _toggleDefaultDatePlaceholder(t = this.input) {
      if (!(t.getAttribute("type") === "date"))
        return;
      !(document.activeElement === t) && !t.value ? t.style.opacity = 0 : t.style.opacity = 1;
    }
    _showPlaceholder() {
      this.input.setAttribute(X_, "");
    }
    _getNotchData() {
      this._notchMiddle = d.findOne(wa, this._element), this._notchLeading = d.findOne(ya, this._element);
    }
    _getLabelWidth() {
      this._labelWidth = this._label.clientWidth * 0.8 + 8;
    }
    _getLabelPositionInInputGroup() {
      if (this._labelMarginLeft = 0, !this._element.hasAttribute("data-te-input-group-ref"))
        return;
      const t = this.input, e = d.prev(t, "[data-te-input-group-text-ref]")[0];
      e === void 0 ? this._labelMarginLeft = 0 : this._labelMarginLeft = e.offsetWidth - 1;
    }
    _applyDivs() {
      const t = this._config.inputFormWhite ? this._classes.notchLeadingWhite : this._classes.notchLeadingNormal, e = this._config.inputFormWhite ? this._classes.notchMiddleWhite : this._classes.notchMiddleNormal, i = this._config.inputFormWhite ? this._classes.notchTrailingWhite : this._classes.notchTrailingNormal, n = d.find(ke, this._element), o = $2("div");
      h.addClass(o, this._classes.notch), o.setAttribute(Fc, ""), this._notchLeading = $2("div"), h.addClass(this._notchLeading, `${this._classes.notchLeading} ${t}`), this._notchLeading.setAttribute(Yc, ""), this._notchMiddle = $2("div"), h.addClass(this._notchMiddle, `${this._classes.notchMiddle} ${e}`), this._notchMiddle.setAttribute(jc, ""), this._notchTrailing = $2("div"), h.addClass(this._notchTrailing, `${this._classes.notchTrailing} ${i}`), this._notchTrailing.setAttribute(z_, ""), !(n.length >= 1) && (o.append(this._notchLeading), o.append(this._notchMiddle), o.append(this._notchTrailing), this._element.append(o));
    }
    _applyNotch() {
      this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);
    }
    _removeBorder() {
      const t = d.findOne(ke, this._element);
      t && t.remove();
    }
    _activate(t) {
      Zl(() => {
        this._getElements(t);
        const e = t ? t.target : this.input, i = d.findOne(ke, this._element);
        t && t.type === "focus" && i && i.setAttribute(Ca, ""), e.value !== "" && (e.setAttribute(Ft, ""), i && i.setAttribute(Ft, "")), this._toggleDefaultDatePlaceholder(e);
      });
    }
    _getElements(t) {
      if (t && (this._element = t.target.parentNode, this._label = d.findOne("label", this._element)), t && this._label) {
        const e = this._labelWidth;
        this._getLabelData(), e !== this._labelWidth && (this._notchMiddle = d.findOne(wa, t.target.parentNode), this._notchLeading = d.findOne(ya, t.target.parentNode), this._applyNotch());
      }
    }
    _deactivate(t) {
      const e = t ? t.target : this.input, i = d.findOne(ke, e.parentNode);
      i.removeAttribute(Ca), e.value === "" && (e.removeAttribute(Ft), i.removeAttribute(Ft)), this._toggleDefaultDatePlaceholder(e);
    }
    static activate(t) {
      return function(e) {
        t._activate(e);
      };
    }
    static deactivate(t) {
      return function(e) {
        t._deactivate(e);
      };
    }
    static jQueryInterface(t, e) {
      return this.each(function() {
        let i = y.getData(this, os);
        const n = typeof t == "object" && t;
        if (!(!i && /dispose/.test(t)) && (i || (i = new V(this, n)), typeof t == "string")) {
          if (typeof i[t] > "u")
            throw new TypeError(`No method named "${t}"`);
          i[t](e);
        }
      });
    }
    static getInstance(t) {
      return y.getData(t, os);
    }
    static getOrCreateInstance(t, e = {}) {
      return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
    }
  };
  var at = 38;
  var z = 40;
  var We = 36;
  var Fe = 35;
  var ct = 13;
  var Fi = 27;
  var Pi = 9;
  var zs = "te.datepicker";
  var dn = `.${zs}`;
  var Rf = ".data-api";
  var Pf = `close${dn}`;
  var Bf = `open${dn}`;
  var Hf = `dateChange${dn}`;
  var hs = `click${dn}${Rf}`;
  var Uc = "data-te-datepicker-modal-container-ref";
  var Xc = "data-te-datepicker-dropdown-container-ref";
  var Vf = `[${Uc}]`;
  var Wf = `[${Xc}]`;
  var $i = "timepicker";
  var M = `data-te-${$i}`;
  var Us = `te.${$i}`;
  var Rt = `.${Us}`;
  var Pt = ".data-api";
  var Ba = `click${Rt}${Pt}`;
  var _s = `keydown${Rt}${Pt}`;
  var Ha = `mousedown${Rt}${Pt}`;
  var Va = `mouseup${Rt}${Pt}`;
  var Wa = `mousemove${Rt}${Pt}`;
  var Fa = `mouseleave${Rt}${Pt}`;
  var Ya = `mouseover${Rt}${Pt}`;
  var ja = `touchmove${Rt}${Pt}`;
  var Ka = `touchend${Rt}${Pt}`;
  var za = `touchstart${Rt}${Pt}`;
  var Fm = `[${M}-am]`;
  var Ym = `[${M}-pm]`;
  var jm = `[${M}-format24]`;
  var fs = `[${M}-current]`;
  var ms = `[${M}-hour-mode]`;
  var Km = `[${M}-toggle-button]`;
  var Gn = `${M}-cancel`;
  var Ua = `${M}-clear`;
  var qn = `${M}-submit`;
  var zm = `${M}-icon`;
  var Zn = `${M}-icon-up`;
  var Qn = `${M}-icon-down`;
  var Um = `${M}-icon-inline-hour`;
  var Xm = `${M}-icon-inline-minute`;
  var Xa = `${M}-inline-hour-icons`;
  var Gm = `${M}-current-inline`;
  var Zm = `${M}-invalid-feedback`;
  var Jn = `${M}-is-invalid`;
  var Yt = `${M}-disabled`;
  var H = `${M}-active`;
  var Qm = `${M}-input`;
  var pe = `${M}-clock`;
  var di = `${M}-clock-inner`;
  var to = `${M}-wrapper`;
  var Ga = `${M}-clock-wrapper`;
  var gs = `${M}-hour`;
  var eo = `${M}-minute`;
  var bs = `${M}-tips-element`;
  var K = `${M}-tips-hours`;
  var X = `${M}-tips-minutes`;
  var lt = `${M}-tips-inner`;
  var vs = `${M}-tips-inner-element`;
  var qa = `${M}-middle-dot`;
  var io = `${M}-hand-pointer`;
  var so = `${M}-circle`;
  var Za = `${M}-modal`;
  var pg = F() ? 100 : -100;
  var _g = F() ? -100 : 100;
  var Ho = "stepper";
  var Xs = "te.stepper";
  var pn = `.${Xs}`;
  var Yi = `data-te-${Ho}`;
  var Ja = `mousedown${pn}`;
  var tl = `keydown${pn}`;
  var vg = `keyup${pn}`;
  var el = `resize${pn}`;
  var jt = `[${Yi}-step-ref]`;
  var G = `[${Yi}-head-ref]`;
  var il = `[${Yi}-head-text-ref]`;
  var Es = `[${Yi}-head-icon-ref]`;
  var st = `[${Yi}-content-ref]`;
  var sl = "data-te-input-state-active";
  var Cs = "data-te-input-selected";
  var nl = "data-te-input-multiple-active";
  var ol = "[data-te-form-check-input]";
  var rl = class {
    constructor(t, e, i, n, o, r, a, l, p, u, _) {
      this.id = t, this.nativeOption = e, this.multiple = i, this.value = n, this.label = o, this.selected = r, this.disabled = a, this.hidden = l, this.secondaryText = p, this.groupId = u, this.icon = _, this.node = null, this.active = false;
    }
    select() {
      this.multiple ? this._selectMultiple() : this._selectSingle();
    }
    _selectSingle() {
      this.selected || (this.node.setAttribute(Cs, ""), this.node.setAttribute("aria-selected", true), this.selected = true, this.nativeOption && (this.nativeOption.selected = true));
    }
    _selectMultiple() {
      if (!this.selected) {
        const t = d.findOne(ol, this.node);
        t.checked = true, this.node.setAttribute(Cs, ""), this.node.setAttribute("aria-selected", true), this.selected = true, this.nativeOption && (this.nativeOption.selected = true);
      }
    }
    deselect() {
      this.multiple ? this._deselectMultiple() : this._deselectSingle();
    }
    _deselectSingle() {
      this.selected && (this.node.removeAttribute(Cs), this.node.setAttribute("aria-selected", false), this.selected = false, this.nativeOption && (this.nativeOption.selected = false));
    }
    _deselectMultiple() {
      if (this.selected) {
        const t = d.findOne(ol, this.node);
        t.checked = false, this.node.removeAttribute(Cs), this.node.setAttribute("aria-selected", false), this.selected = false, this.nativeOption && (this.nativeOption.selected = false);
      }
    }
    setNode(t) {
      this.node = t;
    }
    setActiveStyles() {
      if (!this.active) {
        if (this.multiple) {
          this.node.setAttribute(nl, "");
          return;
        }
        this.active = true, this.node.setAttribute(sl, "");
      }
    }
    removeActiveStyles() {
      this.active && (this.active = false, this.node.removeAttribute(sl)), this.multiple && this.node.removeAttribute(nl);
    }
  };
  var Tg = class {
    constructor(t = false) {
      this._multiple = t, this._selections = [];
    }
    select(t) {
      this._multiple ? this._selections.push(t) : this._selections = [t];
    }
    deselect(t) {
      if (this._multiple) {
        const e = this._selections.findIndex((i) => t === i);
        this._selections.splice(e, 1);
      } else
        this._selections = [];
    }
    clear() {
      this._selections = [];
    }
    get selection() {
      return this._selections[0];
    }
    get selections() {
      return this._selections;
    }
    get label() {
      return this._selections[0] && this.selection.label;
    }
    get labels() {
      return this._selections.map((t) => t.label).join(", ");
    }
    get value() {
      return this.selections[0] && this.selection.value;
    }
    get values() {
      return this._selections.map((t) => t.value);
    }
  };
  function Vo(s) {
    return s.filter((t) => !t.disabled).every((t) => t.selected);
  }
  var Eg = "data-te-select-form-outline-ref";
  var Cg = "data-te-select-wrapper-ref";
  var Ag = "data-te-select-input-ref";
  var yg = "data-te-select-clear-btn-ref";
  var wg = "data-te-select-dropdown-container-ref";
  var kg = "data-te-select-dropdown-ref";
  var xg = "data-te-select-options-wrapper-ref";
  var Og = "data-te-select-options-list-ref";
  var Sg = "data-te-select-input-filter-ref";
  var Jc = "data-te-select-option-ref";
  var Ig = "data-te-select-option-all-ref";
  var Dg = "data-te-select-option-text-ref";
  var $g = "data-te-form-check-input";
  var Lg = "data-te-select-option-group-ref";
  var Ng = "data-te-select-option-group-label-ref";
  var th = "data-te-select-selected";
  var Mg = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
</svg>
`;
  var Rg = (s) => {
    s.code === "Tab" || s.code === "Esc" || s.preventDefault();
  };
  function As(s, t, e, i, n) {
    t.selectSize === "default" && h.addClass(s, e), t.selectSize === "sm" && h.addClass(s, i), t.selectSize === "lg" && h.addClass(s, n);
  }
  function Pg(s, t, e, i, n) {
    const o = document.createElement("div");
    o.setAttribute("id", s), o.setAttribute(Cg, "");
    const r = $2("div");
    r.setAttribute(Eg, ""), h.addClass(r, i.formOutline);
    const a = $2("input"), l = t.selectFilter ? "combobox" : "listbox", p = t.multiple ? "true" : "false", u = t.disabled ? "true" : "false";
    a.setAttribute(Ag, ""), h.addClass(a, i.selectInput), As(a, t, i.selectInputSizeDefault, i.selectInputSizeSm, i.selectInputSizeLg), t.selectFormWhite && h.addClass(a, i.selectInputWhite), a.setAttribute("type", "text"), a.setAttribute("role", l), a.setAttribute("aria-multiselectable", p), a.setAttribute("aria-disabled", u), a.setAttribute("aria-haspopup", "true"), a.setAttribute("aria-expanded", false), a.name = n, t.tabIndex && a.setAttribute("tabIndex", t.tabIndex), t.disabled && a.setAttribute("disabled", ""), t.selectPlaceholder !== "" && a.setAttribute("placeholder", t.selectPlaceholder), t.selectValidation ? (h.addStyle(a, {
      "pointer-events": "none",
      "caret-color": "transparent"
    }), h.addStyle(r, { cursor: "pointer" })) : a.setAttribute("readonly", "true"), t.selectValidation && (a.setAttribute("required", "true"), a.setAttribute("aria-required", "true"), a.addEventListener("keydown", Rg));
    const _ = $2("div");
    h.addClass(_, i.selectValidationValid);
    const f = document.createTextNode(`${t.selectValidFeedback}`);
    _.appendChild(f);
    const g = $2("div");
    h.addClass(g, i.selectValidationInvalid);
    const m = document.createTextNode(`${t.selectInvalidFeedback}`);
    g.appendChild(m);
    const b = $2("span");
    b.setAttribute(yg, ""), h.addClass(b, i.selectClearBtn), As(b, t, i.selectClearBtnDefault, i.selectClearBtnSm, i.selectClearBtnLg), t.selectFormWhite && h.addClass(b, i.selectClearBtnWhite);
    const v = document.createTextNode("\u2715");
    b.appendChild(v), b.setAttribute("tabindex", "0");
    const C = $2("span");
    return h.addClass(C, i.selectArrow), As(C, t, i.selectArrowDefault, i.selectArrowSm, i.selectArrowLg), t.selectFormWhite && h.addClass(C, i.selectArrowWhite), C.innerHTML = Mg, r.appendChild(a), e && (h.addClass(e, i.selectLabel), As(e, t, i.selectLabelSizeDefault, i.selectLabelSizeSm, i.selectLabelSizeLg), t.selectFormWhite && h.addClass(e, i.selectLabelWhite), r.appendChild(e)), t.selectValidation && (r.appendChild(_), r.appendChild(g)), t.selectClearButton && r.appendChild(b), r.appendChild(C), o.appendChild(r), o;
  }
  function al(s, t, e, i, n, o, r, a) {
    const l = document.createElement("div");
    l.setAttribute(wg, ""), h.addClass(l, a.selectDropdownContainer), l.setAttribute("id", `${s}`), l.style.width = `${e}px`;
    const p = document.createElement("div");
    p.setAttribute("tabindex", 0), p.setAttribute(kg, ""), h.addClass(p, a.dropdown);
    const u = $2("div");
    u.setAttribute(xg, ""), h.addClass(u, a.optionsWrapper), h.addClass(u, a.optionsWrapperScrollbar), u.style.maxHeight = `${i}px`;
    const _ = eh(o, n, t, a);
    return u.appendChild(_), t.selectFilter && p.appendChild(Bg(t.selectSearchPlaceholder, a)), p.appendChild(u), r && p.appendChild(r), l.appendChild(p), l;
  }
  function eh(s, t, e, i) {
    const n = $2("div");
    n.setAttribute(Og, ""), h.addClass(n, i.optionsList);
    let o;
    return e.multiple ? o = Vg(s, t, e, i) : o = Hg(s, e, i), o.forEach((r) => {
      n.appendChild(r);
    }), n;
  }
  function Bg(s, t) {
    const e = $2("div");
    h.addClass(e, t.inputGroup);
    const i = $2("input");
    return i.setAttribute(Sg, ""), h.addClass(i, t.selectFilterInput), i.placeholder = s, i.setAttribute("role", "searchbox"), i.setAttribute("type", "text"), e.appendChild(i), e;
  }
  function Hg(s, t, e) {
    return ih(s, t, e);
  }
  function Vg(s, t, e, i) {
    let n = null;
    e.selectAll && (n = Wg(t, s, e, i));
    const o = ih(s, e, i);
    return n ? [n, ...o] : o;
  }
  function ih(s, t, e) {
    const i = [];
    return s.forEach((n) => {
      if (Object.prototype.hasOwnProperty.call(n, "options")) {
        const r = Kg(n, t, e);
        i.push(r);
      } else
        i.push(sh(n, t, e));
    }), i;
  }
  function Wg(s, t, e, i) {
    const n = Vo(t), o = $2("div");
    return o.setAttribute(Jc, ""), h.addClass(o, i.selectOption), o.setAttribute(Ig, ""), h.addStyle(o, {
      height: `${e.selectOptionHeight}px`
    }), o.setAttribute("role", "option"), o.setAttribute("aria-selected", n), n && o.setAttribute(th, ""), o.appendChild(nh(s, e, i)), s.setNode(o), o;
  }
  function sh(s, t, e) {
    if (s.node)
      return s.node;
    const i = $2("div");
    return i.setAttribute(Jc, ""), h.addClass(i, e.selectOption), h.addStyle(i, {
      height: `${t.selectOptionHeight}px`
    }), h.setDataAttribute(i, "id", s.id), i.setAttribute("role", "option"), i.setAttribute("aria-selected", s.selected), i.setAttribute("aria-disabled", s.disabled), s.selected && i.setAttribute(th, ""), s.disabled && i.setAttribute("data-te-select-option-disabled", true), s.hidden && h.addClass(i, "hidden"), i.appendChild(nh(s, t, e)), s.icon && i.appendChild(jg(s, e)), s.setNode(i), i;
  }
  function nh(s, t, e) {
    const i = $2("span");
    i.setAttribute(Dg, ""), h.addClass(i, e.selectOptionText);
    const n = document.createTextNode(s.label);
    return t.multiple && i.appendChild(Yg(s, e)), i.appendChild(n), (s.secondaryText || typeof s.secondaryText == "number") && i.appendChild(Fg(s.secondaryText, e)), i;
  }
  function Fg(s, t) {
    const e = $2("span");
    h.addClass(e, t.selectOptionSecondaryText);
    const i = document.createTextNode(s);
    return e.appendChild(i), e;
  }
  function Yg(s, t) {
    const e = $2("input");
    e.setAttribute("type", "checkbox"), h.addClass(e, t.formCheckInput), e.setAttribute($g, "");
    const i = $2("label");
    return s.selected && e.setAttribute("checked", true), s.disabled && e.setAttribute("disabled", true), e.appendChild(i), e;
  }
  function jg(s, t) {
    const e = $2("span"), i = $2("img");
    return h.addClass(i, t.selectOptionIcon), i.src = s.icon, e.appendChild(i), e;
  }
  function Kg(s, t, e) {
    const i = $2("div");
    i.setAttribute(Lg, ""), h.addClass(i, e.selectOptionGroup), i.setAttribute("role", "group"), i.setAttribute("id", s.id), s.hidden && h.addClass(i, "hidden");
    const n = $2("label");
    return n.setAttribute(Ng, ""), h.addClass(n, e.selectOptionGroupLabel), h.addStyle(n, { height: `${t.selectOptionHeight}px` }), n.setAttribute("for", s.id), n.textContent = s.label, i.appendChild(n), s.options.forEach((o) => {
      i.appendChild(sh(o, t, e));
    }), i;
  }
  function zg(s, t) {
    const e = $2("div");
    return e.innerHTML = s, h.addClass(e, t.selectLabel), h.addClass(e, t.selectFakeValue), e;
  }
  var oo = "select";
  var vi = "te.select";
  var ji = `.${vi}`;
  var Ug = `close${ji}`;
  var Xg = `open${ji}`;
  var ll = `optionSelect${ji}`;
  var cl = `optionDeselect${ji}`;
  var Gg = `valueChange${ji}`;
  var qg = "change";
  var hl = "data-te-select-init";
  var oh = "data-te-select-no-results-ref";
  var dl = "data-te-select-open";
  var q = "data-te-input-state-active";
  var Kt = "data-te-input-focused";
  var ro = "data-te-input-disabled";
  var Zg = "data-te-select-option-group-label-ref";
  var Qg = "data-te-select-option-all-ref";
  var pi = "data-te-select-selected";
  var Jg = "[data-te-select-label-ref]";
  var ul = "[data-te-select-input-ref]";
  var tb = "[data-te-select-input-filter-ref]";
  var eb = "[data-te-select-dropdown-ref]";
  var ib = "[data-te-select-options-wrapper-ref]";
  var pl = "[data-te-select-options-list-ref]";
  var sb = "[data-te-select-option-ref]";
  var nb = "[data-te-select-clear-btn-ref]";
  var ob = "[data-te-select-custom-content-ref]";
  var rb = `[${oh}]`;
  var _l = "[data-te-select-form-outline-ref]";
  var ab = "[data-te-select-toggle]";
  var ao = "[data-te-input-notch-ref]";
  var lb = 200;
  var cb = {
    selectAutoSelect: false,
    selectContainer: "body",
    selectClearButton: false,
    disabled: false,
    selectDisplayedLabels: 5,
    selectFormWhite: false,
    multiple: false,
    selectOptionsSelectedLabel: "options selected",
    selectOptionHeight: 38,
    selectAll: true,
    selectAllLabel: "Select all",
    selectSearchPlaceholder: "Search...",
    selectSize: "default",
    selectVisibleOptions: 5,
    selectFilter: false,
    selectFilterDebounce: 300,
    selectNoResultText: "No results",
    selectValidation: false,
    selectValidFeedback: "Valid",
    selectInvalidFeedback: "Invalid",
    selectPlaceholder: ""
  };
  var hb = {
    selectAutoSelect: "boolean",
    selectContainer: "string",
    selectClearButton: "boolean",
    disabled: "boolean",
    selectDisplayedLabels: "number",
    selectFormWhite: "boolean",
    multiple: "boolean",
    selectOptionsSelectedLabel: "string",
    selectOptionHeight: "number",
    selectAll: "boolean",
    selectAllLabel: "string",
    selectSearchPlaceholder: "string",
    selectSize: "string",
    selectVisibleOptions: "number",
    selectFilter: "boolean",
    selectFilterDebounce: "number",
    selectNoResultText: "string",
    selectValidation: "boolean",
    selectValidFeedback: "string",
    selectInvalidFeedback: "string",
    selectPlaceholder: "string"
  };
  var db = {
    dropdown: "relative outline-none min-w-[100px] m-0 scale-[0.8] opacity-0 bg-white shadow-[0_2px_5px_0_rgba(0,0,0,0.16),_0_2px_10px_0_rgba(0,0,0,0.12)] transition duration-200 motion-reduce:transition-none data-[te-select-open]:scale-100 data-[te-select-open]:opacity-100 dark:bg-zinc-700",
    formCheckInput: "relative float-left mt-[0.15rem] mr-[8px] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 dark:border-neutral-600 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary dark:checked:border-primary checked:bg-primary dark:checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:ml-[0.25rem] checked:after:-mt-px checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-t-0 checked:after:border-l-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:ml-[0.25rem] checked:focus:after:-mt-px checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-t-0 checked:focus:after:border-l-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent",
    formOutline: "relative",
    initialized: "hidden",
    inputGroup: "flex items-center whitespace-nowrap p-2.5 text-center text-base font-normal leading-[1.6] text-gray-700 dark:bg-zinc-800 dark:text-gray-200 dark:placeholder:text-gray-200",
    noResult: "flex items-center px-4",
    optionsList: "list-none m-0 p-0",
    optionsWrapper: "overflow-y-auto",
    optionsWrapperScrollbar: "[&::-webkit-scrollbar]:w-1 [&::-webkit-scrollbar]:h-1 [&::-webkit-scrollbar-button]:block [&::-webkit-scrollbar-button]:h-0 [&::-webkit-scrollbar-button]:bg-transparent [&::-webkit-scrollbar-track-piece]:bg-transparent [&::-webkit-scrollbar-track-piece]:rounded-none [&::-webkit-scrollbar-track-piece]: [&::-webkit-scrollbar-track-piece]:rounded-l [&::-webkit-scrollbar-thumb]:h-[50px] [&::-webkit-scrollbar-thumb]:bg-[#999] [&::-webkit-scrollbar-thumb]:rounded",
    selectArrow: "absolute right-3 text-[0.8rem] cursor-pointer peer-focus:text-primary peer-data-[te-input-focused]:text-primary group-data-[te-was-validated]/validation:peer-valid:text-green-600 group-data-[te-was-validated]/validation:peer-invalid:text-[rgb(220,76,100)] w-5 h-5",
    selectArrowWhite: "text-gray-50 peer-focus:!text-white peer-data-[te-input-focused]:!text-white",
    selectArrowDefault: "top-2",
    selectArrowLg: "top-[13px]",
    selectArrowSm: "top-1",
    selectClearBtn: "absolute top-2 right-9 text-black cursor-pointer focus:text-primary outline-none dark:text-gray-200",
    selectClearBtnWhite: "!text-gray-50",
    selectClearBtnDefault: "top-2 text-base",
    selectClearBtnLg: "top-[11px] text-base",
    selectClearBtnSm: "top-1 text-[0.8rem]",
    selectDropdownContainer: "z-[1070]",
    selectFakeValue: "transform-none hidden data-[te-input-state-active]:block",
    selectFilterInput: "relative m-0 block w-full min-w-0 flex-auto rounded border border-solid border-gray-300 bg-transparent bg-clip-padding px-3 py-1.5 text-base font-normal text-gray-700 transition duration-300 ease-in-out motion-reduce:transition-none focus:border-primary focus:text-gray-700 focus:shadow-te-primary focus:outline-none dark:text-gray-200 dark:placeholder:text-gray-200",
    selectInput: "peer block min-h-[auto] w-full rounded border-0 bg-transparent outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0 cursor-pointer data-[te-input-disabled]:bg-[#e9ecef] data-[te-input-disabled]:cursor-default group-data-[te-was-validated]/validation:mb-4 dark:data-[te-input-disabled]:bg-zinc-600",
    selectInputWhite: "!text-gray-50",
    selectInputSizeDefault: "py-[0.32rem] px-3 leading-[1.6]",
    selectInputSizeLg: "py-[0.32rem] px-3 leading-[2.15]",
    selectInputSizeSm: "py-[0.33rem] px-3 text-xs leading-[1.5]",
    selectLabel: "pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate text-gray-500 transition-all duration-200 ease-out peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200 data-[te-input-state-active]:scale-[0.8] dark:peer-focus:text-primary",
    selectLabelWhite: "!text-gray-50",
    selectLabelSizeDefault: "pt-[0.37rem] leading-[1.6] peer-focus:-translate-y-[0.9rem] peer-data-[te-input-state-active]:-translate-y-[0.9rem] data-[te-input-state-active]:-translate-y-[0.9rem]",
    selectLabelSizeLg: "pt-[0.37rem] leading-[2.15] peer-focus:-translate-y-[1.15rem] peer-data-[te-input-state-active]:-translate-y-[1.15rem] data-[te-input-state-active]:-translate-y-[1.15rem]",
    selectLabelSizeSm: "pt-[0.37rem] text-xs leading-[1.5] peer-focus:-translate-y-[0.75rem] peer-data-[te-input-state-active]:-translate-y-[0.75rem] data-[te-input-state-active]:-translate-y-[0.75rem]",
    selectOption: "flex flex-row items-center justify-between w-full px-4 truncate text-gray-700 bg-transparent select-none cursor-pointer data-[te-input-multiple-active]:bg-black/5 hover:[&:not([data-te-select-option-disabled])]:bg-black/5 data-[te-input-state-active]:bg-black/5 data-[te-select-option-selected]:data-[te-input-state-active]:bg-black/5 data-[te-select-selected]:data-[te-select-option-disabled]:cursor-default data-[te-select-selected]:data-[te-select-option-disabled]:text-gray-400 data-[te-select-selected]:data-[te-select-option-disabled]:bg-transparent data-[te-select-option-selected]:bg-black/[0.02] data-[te-select-option-disabled]:text-gray-400 data-[te-select-option-disabled]:cursor-default group-data-[te-select-option-group-ref]/opt:pl-7 dark:text-gray-200 dark:hover:[&:not([data-te-select-option-disabled])]:bg-white/30 dark:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-selected]:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-disabled]:text-gray-400 dark:data-[te-input-multiple-active]:bg-white/30",
    selectOptionGroup: "group/opt",
    selectOptionGroupLabel: "flex flex-row items-center w-full px-4 truncate bg-transparent text-black/50 select-none dark:text-gray-300",
    selectOptionIcon: "w-7 h-7 rounded-full",
    selectOptionSecondaryText: "block text-[0.8rem] text-gray-500 dark:text-gray-300",
    selectOptionText: "group",
    selectValidationValid: "hidden absolute -mt-3 w-auto text-sm text-green-600 cursor-pointer group-data-[te-was-validated]/validation:peer-valid:block",
    selectValidationInvalid: "hidden absolute -mt-3 w-auto text-sm text-[rgb(220,76,100)] cursor-pointer group-data-[te-was-validated]/validation:peer-invalid:block"
  };
  var ub = {
    dropdown: "string",
    formCheckInput: "string",
    formOutline: "string",
    initialized: "string",
    inputGroup: "string",
    noResult: "string",
    optionsList: "string",
    optionsWrapper: "string",
    optionsWrapperScrollbar: "string",
    selectArrow: "string",
    selectArrowDefault: "string",
    selectArrowLg: "string",
    selectArrowSm: "string",
    selectClearBtn: "string",
    selectClearBtnDefault: "string",
    selectClearBtnLg: "string",
    selectClearBtnSm: "string",
    selectDropdownContainer: "string",
    selectFakeValue: "string",
    selectFilterInput: "string",
    selectInput: "string",
    selectInputSizeDefault: "string",
    selectInputSizeLg: "string",
    selectInputSizeSm: "string",
    selectLabel: "string",
    selectLabelSizeDefault: "string",
    selectLabelSizeLg: "string",
    selectLabelSizeSm: "string",
    selectOption: "string",
    selectOptionGroup: "string",
    selectOptionGroupLabel: "string",
    selectOptionIcon: "string",
    selectOptionSecondaryText: "string",
    selectOptionText: "string"
  };
  var _r = class {
    constructor(t, e, i) {
      this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._config.selectPlaceholder && !this._config.multiple && this._addPlaceholderOption(), this._optionsToRender = this._getOptionsToRender(t), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._filteredOptionsList = null, this._selectionModel = new Tg(this.multiple), this._activeOptionIndex = -1, this._activeOption = null, this._wrapperId = rt("select-wrapper-"), this._dropdownContainerId = rt("select-dropdown-container-"), this._selectAllId = rt("select-all-"), this._debounceTimeoutId = null, this._dropdownHeight = this._config.selectOptionHeight * this._config.selectVisibleOptions, this._popper = null, this._input = null, this._label = d.next(this._element, Jg)[0], this._notch = null, this._fakeValue = null, this._isFakeValueActive = false, this._customContent = d.next(t, ob)[0], this._toggleButton = null, this._elementToggle = null, this._wrapper = null, this._inputEl = null, this._dropdownContainer = null, this._container = null, this._selectAllOption = null, this._init(), this._mutationObserver = null, this._isOpen = false, this._addMutationObserver(), this._element && y.setData(t, vi, this);
    }
    static get NAME() {
      return oo;
    }
    get filterInput() {
      return d.findOne(tb, this._dropdownContainer);
    }
    get dropdown() {
      return d.findOne(eb, this._dropdownContainer);
    }
    get optionsList() {
      return d.findOne(pl, this._dropdownContainer);
    }
    get optionsWrapper() {
      return d.findOne(ib, this._dropdownContainer);
    }
    get clearButton() {
      return d.findOne(nb, this._wrapper);
    }
    get options() {
      return this._filteredOptionsList ? this._filteredOptionsList : this._plainOptions;
    }
    get value() {
      return this.multiple ? this._selectionModel.values : this._selectionModel.value;
    }
    get multiple() {
      return this._config.multiple;
    }
    get hasSelectAll() {
      return this.multiple && this._config.selectAll;
    }
    get hasSelection() {
      return this._selectionModel.selection || this._selectionModel.selections.length > 0;
    }
    _getConfig(t) {
      const e = h.getDataAttributes(this._element);
      return t = __spreadValues(__spreadValues(__spreadValues({}, cb), e), t), this._element.hasAttribute("multiple") && (t.multiple = true), this._element.hasAttribute("disabled") && (t.disabled = true), this._element.tabIndex && (t.tabIndex = this._element.getAttribute("tabIndex")), D(oo, t, hb), t;
    }
    _getClasses(t) {
      const e = h.getDataClassAttributes(this._element);
      return t = __spreadValues(__spreadValues(__spreadValues({}, db), e), t), D(oo, t, ub), t;
    }
    _addPlaceholderOption() {
      const t = new Option("", "", true, true);
      t.hidden = true, t.selected = true, this._element.prepend(t);
    }
    _getOptionsToRender(t) {
      const e = [];
      return t.childNodes.forEach((n) => {
        if (n.nodeName === "OPTGROUP") {
          const o = {
            id: rt("group-"),
            label: n.label,
            disabled: n.hasAttribute("disabled"),
            hidden: n.hasAttribute("hidden"),
            options: []
          };
          n.childNodes.forEach((a) => {
            a.nodeName === "OPTION" && o.options.push(this._createOptionObject(a, o));
          }), e.push(o);
        } else
          n.nodeName === "OPTION" && e.push(this._createOptionObject(n));
      }), e;
    }
    _getPlainOptions(t) {
      if (!d.findOne("optgroup", this._element))
        return t;
      const i = [];
      return t.forEach((n) => {
        Object.prototype.hasOwnProperty.call(n, "options") ? n.options.forEach((r) => {
          i.push(r);
        }) : i.push(n);
      }), i;
    }
    _createOptionObject(t, e = {}) {
      const i = rt("option-"), n = e.id ? e.id : null, o = e.disabled ? e.disabled : false, r = t.selected || t.hasAttribute(pi), a = t.hasAttribute("disabled") || o, l = t.hasAttribute("hidden") || e && e.hidden, p = this.multiple, u = t.value, _ = t.label, f = h.getDataAttribute(t, "selectSecondaryText"), g = h.getDataAttribute(t, "select-icon");
      return new rl(i, t, p, u, _, r, a, l, f, n, g);
    }
    _getNavigationOptions() {
      const t = this.options.filter((e) => !e.hidden);
      return this.hasSelectAll ? [this._selectAllOption, ...t] : t;
    }
    _init() {
      this._renderMaterialWrapper(), this._wrapper = d.findOne(`#${this._wrapperId}`), this._input = d.findOne(ul, this._wrapper), this._config.disabled && this._input.setAttribute(ro, "");
      const t = this._config.selectContainer;
      t === "body" ? this._container = document.body : this._container = d.findOne(t), this._initOutlineInput(), this._setDefaultSelections(), this._updateInputValue(), this._appendFakeValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._bindComponentEvents(), this.hasSelectAll && (this._selectAllOption = this._createSelectAllOption()), this._dropdownContainer = al(this._dropdownContainerId, this._config, this._input.offsetWidth, this._dropdownHeight, this._selectAllOption, this._optionsToRender, this._customContent, this._classes), this._setFirstActiveOption(), this._listenToFocusChange();
    }
    _renderMaterialWrapper() {
      const t = Pg(this._wrapperId, this._config, this._label, this._classes, this._element.name);
      this._element.parentNode.insertBefore(t, this._element), h.addClass(this._element, this._classes.initialized), t.appendChild(this._element);
    }
    _initOutlineInput() {
      const t = d.findOne(_l, this._wrapper);
      new V(t, {
        inputFormWhite: this._config.selectFormWhite
      }, this._classes).init(), this._notch = d.findOne(ao, this._wrapper);
    }
    _bindComponentEvents() {
      this._listenToComponentKeydown(), this._listenToWrapperClick(), this._listenToClearBtnClick(), this._listenToClearBtnKeydown();
    }
    _setDefaultSelections() {
      this.options.forEach((t) => {
        t.selected && this._selectionModel.select(t);
      });
    }
    _listenToComponentKeydown() {
      c.on(this._wrapper, "keydown", this._handleKeydown.bind(this));
    }
    _handleKeydown(t) {
      this._isOpen && !this._config.selectFilter ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t);
    }
    _handleOpenKeydown(t) {
      const e = t.keyCode, i = e === Fi || e === at && t.altKey || e === Pi;
      if (e === Pi && this._config.selectAutoSelect && !this.multiple && this._handleAutoSelection(this._activeOption), i) {
        this.close(), this._input.focus();
        return;
      }
      switch (e) {
        case z:
          this._setNextOptionActive(), this._scrollToOption(this._activeOption);
          break;
        case at:
          this._setPreviousOptionActive(), this._scrollToOption(this._activeOption);
          break;
        case We:
          this._setFirstOptionActive(), this._scrollToOption(this._activeOption);
          break;
        case Fe:
          this._setLastOptionActive(), this._scrollToOption(this._activeOption);
          break;
        case ct:
          t.preventDefault(), this._activeOption && (this.hasSelectAll && this._activeOptionIndex === 0 ? this._handleSelectAll() : this._handleSelection(this._activeOption));
          return;
        default:
          return;
      }
      t.preventDefault();
    }
    _handleClosedKeydown(t) {
      const e = t.keyCode;
      if (e === ct && t.preventDefault(), (e === ct || e === z && t.altKey || e === z && this.multiple) && this.open(), this.multiple)
        switch (e) {
          case z:
            this.open();
            break;
          case at:
            this.open();
            break;
          default:
            return;
        }
      else
        switch (e) {
          case z:
            this._setNextOptionActive(), this._handleSelection(this._activeOption);
            break;
          case at:
            this._setPreviousOptionActive(), this._handleSelection(this._activeOption);
            break;
          case We:
            this._setFirstOptionActive(), this._handleSelection(this._activeOption);
            break;
          case Fe:
            this._setLastOptionActive(), this._handleSelection(this._activeOption);
            break;
          default:
            return;
        }
      t.preventDefault();
    }
    _scrollToOption(t) {
      if (!t)
        return;
      let e;
      const i = this.options.filter((u) => !u.hidden);
      this.hasSelectAll ? e = i.indexOf(t) + 1 : e = i.indexOf(t);
      const n = this._getNumberOfGroupsBeforeOption(e), o = e + n, r = this.optionsWrapper, a = r.offsetHeight, l = this._config.selectOptionHeight, p = r.scrollTop;
      if (e > -1) {
        const u = o * l, _ = u + l > p + a;
        u < p ? r.scrollTop = u : _ ? r.scrollTop = u - a + l : r.scrollTop = p;
      }
    }
    _getNumberOfGroupsBeforeOption(t) {
      const e = this.options.filter((r) => !r.hidden), i = this._optionsToRender.filter((r) => !r.hidden), n = this.hasSelectAll ? t - 1 : t;
      let o = 0;
      for (let r = 0; r <= n; r++)
        e[r].groupId && i[o] && i[o].id && e[r].groupId === i[o].id && o++;
      return o;
    }
    _setNextOptionActive() {
      let t = this._activeOptionIndex + 1;
      const e = this._getNavigationOptions();
      if (e[t]) {
        for (; e[t].disabled; )
          if (t += 1, !e[t])
            return;
        this._updateActiveOption(e[t], t);
      }
    }
    _setPreviousOptionActive() {
      let t = this._activeOptionIndex - 1;
      const e = this._getNavigationOptions();
      if (e[t]) {
        for (; e[t].disabled; )
          if (t -= 1, !e[t])
            return;
        this._updateActiveOption(e[t], t);
      }
    }
    _setFirstOptionActive() {
      const e = this._getNavigationOptions();
      this._updateActiveOption(e[0], 0);
    }
    _setLastOptionActive() {
      const t = this._getNavigationOptions(), e = t.length - 1;
      this._updateActiveOption(t[e], e);
    }
    _updateActiveOption(t, e) {
      const i = this._activeOption;
      i && i.removeActiveStyles(), t.setActiveStyles(), this._activeOptionIndex = e, this._activeOption = t;
    }
    _listenToWrapperClick() {
      c.on(this._wrapper, "click", () => {
        this.toggle();
      });
    }
    _listenToClearBtnClick() {
      c.on(this.clearButton, "click", (t) => {
        t.preventDefault(), t.stopPropagation(), this._handleClear();
      });
    }
    _listenToClearBtnKeydown() {
      c.on(this.clearButton, "keydown", (t) => {
        t.keyCode === ct && (this._handleClear(), t.preventDefault(), t.stopPropagation());
      });
    }
    _handleClear() {
      if (this.multiple)
        this._selectionModel.clear(), this._deselectAllOptions(this.options), this.hasSelectAll && this._updateSelectAllState();
      else {
        const t = this._selectionModel.selection;
        this._selectionModel.clear(), t.deselect();
      }
      this._fakeValue.innerHTML = "", this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(null), this._emitNativeChangeEvent();
    }
    _listenToOptionsClick() {
      c.on(this.optionsWrapper, "click", (t) => {
        if (t.target.hasAttribute(Zg))
          return;
        const i = t.target.nodeName === "DIV" ? t.target : d.closest(t.target, sb);
        if (i.hasAttribute(Qg)) {
          this._handleSelectAll();
          return;
        }
        const o = i.dataset.teId, r = this.options.find((a) => a.id === o);
        r && !r.disabled && this._handleSelection(r);
      });
    }
    _handleSelectAll() {
      this._selectAllOption.selected ? (this._deselectAllOptions(this.options), this._selectAllOption.deselect()) : (this._selectAllOptions(this.options), this._selectAllOption.select()), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
    }
    _selectAllOptions(t) {
      t.forEach((e) => {
        !e.selected && !e.disabled && (this._selectionModel.select(e), e.select());
      });
    }
    _deselectAllOptions(t) {
      t.forEach((e) => {
        e.selected && !e.disabled && (this._selectionModel.deselect(e), e.deselect());
      });
    }
    _handleSelection(t) {
      this.multiple ? (this._handleMultiSelection(t), this.hasSelectAll && this._updateSelectAllState()) : this._handleSingleSelection(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
    }
    _handleAutoSelection(t) {
      this._singleOptionSelect(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
    }
    _handleSingleSelection(t) {
      this._singleOptionSelect(t), this.close(), this._input.focus();
    }
    _singleOptionSelect(t) {
      const e = this._selectionModel.selections[0];
      e && e !== t && (this._selectionModel.deselect(e), e.deselect(), e.node.setAttribute(pi, false), c.trigger(this._element, cl, {
        value: e.value
      })), (!e || e && t !== e) && (this._selectionModel.select(t), t.select(), t.node.setAttribute(pi, true), c.trigger(this._element, ll, {
        value: t.value
      }), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent());
    }
    _handleMultiSelection(t) {
      t.selected ? (this._selectionModel.deselect(t), t.deselect(), t.node.setAttribute(pi, false), c.trigger(this._element, cl, {
        value: t.value
      })) : (this._selectionModel.select(t), t.select(), t.node.setAttribute(pi, true), c.trigger(this._element, ll, {
        value: t.value
      })), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
    }
    _emitValueChangeEvent(t) {
      c.trigger(this._element, Gg, { value: t });
    }
    _emitNativeChangeEvent() {
      c.trigger(this._element, qg);
    }
    _updateInputValue() {
      const t = this.multiple ? this._selectionModel.labels : this._selectionModel.label;
      let e;
      this.multiple && this._config.selectDisplayedLabels !== -1 && this._selectionModel.selections.length > this._config.selectDisplayedLabels ? e = `${this._selectionModel.selections.length} ${this._config.selectOptionsSelectedLabel}` : e = t, !this.multiple && !this._isSelectionValid(this._selectionModel.selection) ? this._input.value = "" : this._isLabelEmpty(this._selectionModel.selection) ? this._input.value = " " : e ? this._input.value = e : this.multiple || !this._optionsToRender[0] ? this._input.value = "" : this._input.value = this._optionsToRender[0].label;
    }
    _isSelectionValid(t) {
      return !(t && (t.disabled || t.value === ""));
    }
    _isLabelEmpty(t) {
      return !!(t && t.label === "");
    }
    _appendFakeValue() {
      if (!this._selectionModel.selection || this._selectionModel._multiple)
        return;
      const t = this._selectionModel.selection.label;
      this._fakeValue = zg(t, this._classes), d.findOne(_l, this._wrapper).appendChild(this._fakeValue);
    }
    _updateLabelPosition() {
      const t = this._element.hasAttribute(hl), e = this._input.value !== "";
      this._label && (t && (e || this._isOpen || this._isFakeValueActive) ? (this._label.setAttribute(q, ""), this._notch.setAttribute(q, "")) : (this._label.removeAttribute(q), this._notch.removeAttribute(q, "")));
    }
    _updateLabelPositionWhileClosing() {
      this._label && (this._input.value !== "" || this._isFakeValueActive ? (this._label.setAttribute(q, ""), this._notch.setAttribute(q, "")) : (this._label.removeAttribute(q), this._notch.removeAttribute(q)));
    }
    _updateFakeLabelPosition() {
      this._fakeValue && (this._input.value === "" && this._fakeValue.innerHTML !== "" && !this._config.selectPlaceholder ? (this._isFakeValueActive = true, this._fakeValue.setAttribute(q, "")) : (this._isFakeValueActive = false, this._fakeValue.removeAttribute(q)));
    }
    _updateClearButtonVisibility() {
      if (!this.clearButton)
        return;
      this._selectionModel.selection || this._selectionModel.selections.length > 0 ? h.addStyle(this.clearButton, { display: "block" }) : h.addStyle(this.clearButton, { display: "none" });
    }
    _updateSelectAllState() {
      const t = this._selectAllOption.selected, e = Vo(this.options);
      !e && t ? this._selectAllOption.deselect() : e && !t && this._selectAllOption.select();
    }
    toggle() {
      this._isOpen ? this.close() : this.open();
    }
    open() {
      const t = this._config.disabled, e = c.trigger(this._element, Xg);
      this._isOpen || t || e.defaultPrevented || (this._openDropdown(), this._updateDropdownWidth(), this._setFirstActiveOption(), this._scrollToOption(this._activeOption), this._config.selectFilter && (setTimeout(() => {
        this.filterInput.focus();
      }, 0), this._listenToSelectSearch(), this._listenToDropdownKeydown()), this._listenToOptionsClick(), this._listenToOutsideClick(), this._listenToWindowResize(), this._isOpen = true, this._updateLabelPosition(), this._setInputActiveStyles());
    }
    _openDropdown() {
      this._popper = Ce(this._input, this._dropdownContainer, {
        placement: "bottom-start",
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [0, 1]
            }
          }
        ]
      }), this._container.appendChild(this._dropdownContainer), setTimeout(() => {
        this.dropdown.setAttribute(dl, "");
      }, 0);
    }
    _updateDropdownWidth() {
      const t = this._input.offsetWidth;
      h.addStyle(this._dropdownContainer, { width: `${t}px` });
    }
    _setFirstActiveOption() {
      const t = this._getNavigationOptions(), e = this._activeOption;
      e && e.removeActiveStyles();
      const i = this.multiple ? this._selectionModel.selections[0] : this._selectionModel.selection;
      i ? (this._activeOption = i, i.setActiveStyles(), this._activeOptionIndex = t.findIndex((n) => n === i)) : (this._activeOption = null, this._activeOptionIndex = -1);
    }
    _setInputActiveStyles() {
      this._input.setAttribute(Kt, ""), d.findOne(ao, this._wrapper).setAttribute(Kt, "");
    }
    _listenToWindowResize() {
      c.on(window, "resize", this._handleWindowResize.bind(this));
    }
    _handleWindowResize() {
      this._dropdownContainer && this._updateDropdownWidth();
    }
    _listenToSelectSearch() {
      this.filterInput.addEventListener("input", (t) => {
        const e = t.target.value, i = this._config.selectFilterDebounce;
        this._debounceFilter(e, i);
      });
    }
    _debounceFilter(t, e) {
      this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {
        this._filterOptions(t);
      }, e);
    }
    _filterOptions(t) {
      const e = [];
      this._optionsToRender.forEach((o) => {
        const r = Object.prototype.hasOwnProperty.call(o, "options"), a = !r && o.label.toLowerCase().includes(t.toLowerCase()), l = {};
        r && (l.label = o.label, l.options = this._filter(t, o.options), l.options.length > 0 && e.push(l)), a && e.push(o);
      });
      const i = this._config.selectNoResultText !== "", n = e.length !== 0;
      if (n)
        this._updateOptionsListTemplate(e), this._popper.forceUpdate(), this._filteredOptionsList = this._getPlainOptions(e), this.hasSelectAll && this._updateSelectAllState(), this._setFirstActiveOption();
      else if (!n && i) {
        const o = this._getNoResultTemplate();
        this.optionsWrapper.innerHTML = o;
      }
    }
    _updateOptionsListTemplate(t) {
      const e = d.findOne(pl, this._dropdownContainer) || d.findOne(rb, this._dropdownContainer), i = eh(t, this._selectAllOption, this._config, this._classes);
      this.optionsWrapper.removeChild(e), this.optionsWrapper.appendChild(i);
    }
    _getNoResultTemplate() {
      return `<div class="${this._classes.noResult}" ${oh} style="height: ${this._config.selectOptionHeight}px">${this._config.selectNoResultText}</div>`;
    }
    _filter(t, e) {
      const i = t.toLowerCase();
      return e.filter((n) => n.label.toLowerCase().includes(i));
    }
    _listenToDropdownKeydown() {
      c.on(this.dropdown, "keydown", this._handleOpenKeydown.bind(this));
    }
    _listenToOutsideClick() {
      this._outsideClick = this._handleOutSideClick.bind(this), c.on(document, "click", this._outsideClick);
    }
    _listenToFocusChange(t = true) {
      if (t === false) {
        c.off(this._input, "focus", () => this._notch.setAttribute(Kt, "")), c.off(this._input, "blur", () => this._notch.removeAttribute(Kt));
        return;
      }
      c.on(this._input, "focus", () => this._notch.setAttribute(Kt, "")), c.on(this._input, "blur", () => this._notch.removeAttribute(Kt));
    }
    _handleOutSideClick(t) {
      const e = this._wrapper && this._wrapper.contains(t.target), i = t.target === this._dropdownContainer, n = this._dropdownContainer && this._dropdownContainer.contains(t.target);
      let o;
      this._toggleButton || (this._elementToggle = d.find(ab)), this._elementToggle && this._elementToggle.forEach((r) => {
        const a = h.getDataAttribute(r, "select-toggle");
        (a === this._element.id || this._element.classList.contains(a)) && (this._toggleButton = r, o = this._toggleButton.contains(t.target));
      }), !e && !i && !n && !o && this.close();
    }
    close() {
      const t = c.trigger(this._element, Ug);
      !this._isOpen || t.defaultPrevented || (this._config.selectFilter && this.hasSelectAll && (this._resetFilterState(), this._updateOptionsListTemplate(this._optionsToRender), this._config.multiple && this._updateSelectAllState()), this._removeDropdownEvents(), this.dropdown.removeAttribute(dl), setTimeout(() => {
        this._input.removeAttribute(Kt), this._input.blur(), d.findOne(ao, this._wrapper).removeAttribute(Kt), this._label && !this.hasSelection && (this._label.removeAttribute(q), this._notch.setAttribute(q, ""), this._input.removeAttribute(q), this._notch.removeAttribute(q)), this._updateLabelPositionWhileClosing();
      }, 0), setTimeout(() => {
        this._container && this._dropdownContainer.parentNode === this._container && this._container.removeChild(this._dropdownContainer), this._popper.destroy(), this._isOpen = false, c.off(this.dropdown, "transitionend");
      }, lb));
    }
    _resetFilterState() {
      this.filterInput.value = "", this._filteredOptionsList = null;
    }
    _removeDropdownEvents() {
      c.off(document, "click", this._outsideClick), this._config.selectFilter && c.off(this.dropdown, "keydown"), c.off(this.optionsWrapper, "click");
    }
    _addMutationObserver() {
      this._mutationObserver = new MutationObserver(() => {
        this._wrapper && (this._updateSelections(), this._updateDisabledState());
      }), this._observeMutationObserver();
    }
    _updateSelections() {
      this._optionsToRender = this._getOptionsToRender(this._element), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._selectionModel.clear(), this._setDefaultSelections(), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this.hasSelectAll && this._updateSelectAllState();
      const t = this._config.filter && this.filterInput && this.filterInput.value;
      this._isOpen && !t ? (this._updateOptionsListTemplate(this._optionsToRender), this._setFirstActiveOption()) : this._isOpen && t ? (this._filterOptions(this.filterInput.value), this._setFirstActiveOption()) : this._dropdownContainer = al(this._dropdownContainerId, this._config, this._input.offsetWidth, this._dropdownHeight, this._selectAllOption, this._optionsToRender, this._customContent, this._classes);
    }
    _updateDisabledState() {
      const t = d.findOne(ul, this._wrapper);
      this._element.hasAttribute("disabled") ? (this._config.disabled = true, t.setAttribute("disabled", ""), t.setAttribute(ro, "")) : (this._config.disabled = false, t.removeAttribute("disabled"), t.removeAttribute(ro));
    }
    _observeMutationObserver() {
      this._mutationObserver && this._mutationObserver.observe(this._element, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    }
    _disconnectMutationObserver() {
      this.mutationObserver && (this._mutationObserver.disconnect(), this._mutationObserver = null);
    }
    _createSelectAllOption() {
      const t = this._selectAllId, e = null, i = true, n = "select-all", o = this._config.selectAllLabel, r = Vo(this.options), a = false, l = false, p = null, u = null, _ = null;
      return new rl(t, e, i, n, o, r, a, l, p, u, _);
    }
    dispose() {
      this._removeComponentEvents(), this._destroyMaterialSelect(), this._listenToFocusChange(false), y.removeData(this._element, vi);
    }
    _removeComponentEvents() {
      c.off(this.input, "click"), c.off(this.wrapper, this._handleKeydown.bind(this)), c.off(this.clearButton, "click"), c.off(this.clearButton, "keydown"), c.off(window, "resize", this._handleWindowResize.bind(this));
    }
    _destroyMaterialSelect() {
      this._isOpen && this.close(), this._destroyMaterialTemplate();
    }
    _destroyMaterialTemplate() {
      const t = this._wrapper.parentNode, e = d.find("label", this._wrapper);
      t.appendChild(this._element), e.forEach((i) => {
        t.appendChild(i);
      }), e.forEach((i) => {
        i.removeAttribute(q);
      }), h.removeClass(this._element, this._classes.initialized), this._element.removeAttribute(hl), t.removeChild(this._wrapper);
    }
    setValue(t) {
      this.options.filter((i) => i.selected).forEach((i) => i.nativeOption.selected = false), Array.isArray(t) ? t.forEach((i) => {
        this._selectByValue(i);
      }) : this._selectByValue(t), this._updateSelections();
    }
    _selectByValue(t) {
      const e = this.options.find((i) => i.value === t);
      return e ? (e.nativeOption.selected = true, true) : false;
    }
    static jQueryInterface(t, e) {
      return this.each(function() {
        let i = y.getData(this, vi);
        const n = typeof t == "object" && t;
        if (!(!i && /dispose/.test(t)) && (i || (i = new _r(this, n)), typeof t == "string")) {
          if (typeof i[t] > "u")
            throw new TypeError(`No method named "${t}"`);
          i[t](e);
        }
      });
    }
    static getInstance(t) {
      return y.getData(t, vi);
    }
    static getOrCreateInstance(t, e = {}) {
      return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
    }
  };
  var Gs = "chip";
  var fb = `te.${Gs}`;
  var rh = "data-te-chip-close";
  var lo = `[${rh}]`;
  var Li = "chips";
  var Ki = `data-te-${Li}`;
  var fl = `te.${Li}`;
  var Ab = `${Ki}-input-init`;
  var mt = `${Ki}-active`;
  var ml = `${Ki}-initial`;
  var ah = `${Ki}-placeholder`;
  var yb = `${Ki}-input-wrapper`;
  var Wo = "data-te-chip-init";
  var lh = "data-te-chip-close";
  var ch = "data-te-chip-text";
  var wb = `[${mt}]`;
  var Fo = `[${Wo}]`;
  var kb = `${Fo}${wb}`;
  var co = `[${lh}]`;
  var xb = `[${yb}]`;
  var Ob = `[${ch}]`;
  var Sb = `[${ah}]`;
  var Ib = "data-te-input-notch-leading-ref";
  var Db = "data-te-input-notch-middle-ref";
  var $b = `[${Ib}]`;
  var Lb = `[${Db}]`;
  var Vb = {
    inputID: rt("chips-input-"),
    parentSelector: "",
    initialValues: [{ tag: "init1" }, { tag: "init2" }],
    editable: false,
    labelText: "Example label",
    inputClasses: {},
    inputOptions: {}
  };
  var zt = {
    plugins: {
      legend: {
        labels: {
          color: "rgb(102,102,102)"
        }
      }
    }
  };
  var Ti = {
    line: {
      options: __spreadProps(__spreadValues({}, zt), {
        elements: {
          line: {
            backgroundColor: "rgba(59, 112, 202, 0.0)",
            borderColor: "rgb(59, 112, 202)",
            borderWidth: 2,
            tension: 0
          },
          point: {
            borderColor: "rgb(59, 112, 202)",
            backgroundColor: "rgb(59, 112, 202)"
          }
        },
        responsive: true,
        legend: {
          display: true
        },
        tooltips: {
          intersect: false,
          mode: "index"
        },
        datasets: {
          borderColor: "red"
        },
        scales: {
          x: {
            stacked: true,
            grid: {
              display: false
            },
            ticks: {
              fontColor: "rgba(0,0,0, 0.5)"
            }
          },
          y: {
            stacked: false,
            grid: {
              borderDash: [2],
              drawBorder: false,
              zeroLineColor: "rgba(0,0,0,0)",
              zeroLineBorderDash: [2],
              zeroLineBorderDashOffset: [2]
            },
            ticks: {
              fontColor: "rgba(0,0,0, 0.5)"
            }
          }
        }
      })
    },
    bar: {
      options: __spreadProps(__spreadValues({}, zt), {
        backgroundColor: "rgb(59, 112, 202)",
        borderWidth: 0,
        responsive: true,
        legend: {
          display: true
        },
        tooltips: {
          intersect: false,
          mode: "index"
        },
        scales: {
          x: {
            stacked: true,
            grid: {
              display: false
            },
            ticks: {
              fontColor: "rgba(0,0,0, 0.5)"
            }
          },
          y: {
            stacked: true,
            grid: {
              borderDash: [2],
              drawBorder: false,
              zeroLineColor: "rgba(0,0,0,0)",
              zeroLineBorderDash: [2],
              zeroLineBorderDashOffset: [2]
            },
            ticks: {
              fontColor: "rgba(0,0,0, 0.5)"
            }
          }
        }
      })
    },
    pie: {
      options: __spreadProps(__spreadValues({}, zt), {
        elements: {
          arc: { backgroundColor: "rgb(59, 112, 202)" }
        },
        responsive: true,
        legend: {
          display: true
        }
      })
    },
    doughnut: {
      options: __spreadProps(__spreadValues({}, zt), {
        elements: {
          arc: { backgroundColor: "rgb(59, 112, 202)" }
        },
        responsive: true,
        legend: {
          display: true
        }
      })
    },
    polarArea: {
      options: __spreadProps(__spreadValues({}, zt), {
        elements: {
          arc: { backgroundColor: "rgba(59, 112, 202, 0.5)" }
        },
        responsive: true,
        legend: {
          display: true
        }
      })
    },
    radar: {
      options: __spreadProps(__spreadValues({}, zt), {
        elements: {
          line: {
            backgroundColor: "rgba(59, 112, 202, 0.5)",
            borderColor: "rgb(59, 112, 202)",
            borderWidth: 2
          },
          point: {
            borderColor: "rgb(59, 112, 202)",
            backgroundColor: "rgb(59, 112, 202)"
          }
        },
        responsive: true,
        legend: {
          display: true
        }
      })
    },
    scatter: {
      options: __spreadProps(__spreadValues({}, zt), {
        elements: {
          line: {
            backgroundColor: "rgba(59, 112, 202, 0.5)",
            borderColor: "rgb(59, 112, 202)",
            borderWidth: 2,
            tension: 0
          },
          point: {
            borderColor: "rgb(59, 112, 202)",
            backgroundColor: "rgba(59, 112, 202, 0.5)"
          }
        },
        responsive: true,
        legend: {
          display: true
        },
        tooltips: {
          intersect: false,
          mode: "index"
        },
        datasets: {
          borderColor: "red"
        },
        scales: {
          x: {
            stacked: true,
            grid: {
              display: false
            },
            ticks: {
              fontColor: "rgba(0,0,0, 0.5)"
            }
          },
          y: {
            stacked: false,
            grid: {
              borderDash: [2],
              drawBorder: false,
              zeroLineColor: "rgba(0,0,0,0)",
              zeroLineBorderDash: [2],
              zeroLineBorderDashOffset: [2]
            },
            ticks: {
              fontColor: "rgba(0,0,0, 0.5)"
            }
          }
        }
      })
    },
    bubble: {
      options: __spreadProps(__spreadValues({}, zt), {
        elements: {
          point: {
            borderColor: "rgb(59, 112, 202)",
            backgroundColor: "rgba(59, 112, 202, 0.5)"
          }
        },
        responsive: true,
        legend: {
          display: true
        },
        scales: {
          x: {
            grid: {
              display: false
            },
            ticks: {
              fontColor: "rgba(0,0,0, 0.5)"
            }
          },
          y: {
            grid: {
              borderDash: [2],
              drawBorder: false,
              zeroLineColor: "rgba(0,0,0,0)",
              zeroLineBorderDash: [2],
              zeroLineBorderDashOffset: [2]
            },
            ticks: {
              fontColor: "rgba(0,0,0, 0.5)"
            }
          }
        }
      })
    }
  };
  var Yb = function(t) {
    return jb(t) && !Kb(t);
  };
  function jb(s) {
    return !!s && typeof s == "object";
  }
  function Kb(s) {
    var t = Object.prototype.toString.call(s);
    return t === "[object RegExp]" || t === "[object Date]" || Xb(s);
  }
  var zb = typeof Symbol == "function" && Symbol.for;
  var Ub = zb ? Symbol.for("react.element") : 60103;
  function Xb(s) {
    return s.$$typeof === Ub;
  }
  function Gb(s) {
    return Array.isArray(s) ? [] : {};
  }
  function Bi(s, t) {
    return t.clone !== false && t.isMergeableObject(s) ? Qe(Gb(s), s, t) : s;
  }
  function qb(s, t, e) {
    return s.concat(t).map(function(i) {
      return Bi(i, e);
    });
  }
  function Zb(s, t) {
    if (!t.customMerge)
      return Qe;
    var e = t.customMerge(s);
    return typeof e == "function" ? e : Qe;
  }
  function Qb(s) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(s).filter(function(t) {
      return Object.propertyIsEnumerable.call(s, t);
    }) : [];
  }
  function vl(s) {
    return Object.keys(s).concat(Qb(s));
  }
  function hh(s, t) {
    try {
      return t in s;
    } catch (e) {
      return false;
    }
  }
  function Jb(s, t) {
    return hh(s, t) && !(Object.hasOwnProperty.call(s, t) && Object.propertyIsEnumerable.call(s, t));
  }
  function tv(s, t, e) {
    var i = {};
    return e.isMergeableObject(s) && vl(s).forEach(function(n) {
      i[n] = Bi(s[n], e);
    }), vl(t).forEach(function(n) {
      Jb(s, n) || (hh(s, n) && e.isMergeableObject(t[n]) ? i[n] = Zb(n, e)(s[n], t[n], e) : i[n] = Bi(t[n], e));
    }), i;
  }
  function Qe(s, t, e) {
    e = e || {}, e.arrayMerge = e.arrayMerge || qb, e.isMergeableObject = e.isMergeableObject || Yb, e.cloneUnlessOtherwiseSpecified = Bi;
    var i = Array.isArray(t), n = Array.isArray(s), o = i === n;
    return o ? i ? e.arrayMerge(s, t, e) : tv(s, t, e) : Bi(t, e);
  }
  Qe.all = function(t, e) {
    if (!Array.isArray(t))
      throw new Error("first argument should be an array");
    return t.reduce(function(i, n) {
      return Qe(i, n, e);
    }, {});
  };
  function Lt(s) {
    return getComputedStyle(s);
  }
  function ot(s, t) {
    for (var e in t) {
      var i = t[e];
      typeof i == "number" && (i = i + "px"), s.style[e] = i;
    }
    return s;
  }
  function ws(s) {
    var t = document.createElement("div");
    return t.className = s, t;
  }
  var El = typeof Element < "u" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
  function Qt(s, t) {
    if (!El)
      throw new Error("No element matching method supported");
    return El.call(s, t);
  }
  function Pe(s) {
    s.remove ? s.remove() : s.parentNode && s.parentNode.removeChild(s);
  }
  function Cl(s, t) {
    return Array.prototype.filter.call(s.children, function(e) {
      return Qt(e, t);
    });
  }
  var j = {
    main: "ps",
    rtl: "ps__rtl",
    element: {
      thumb: function(s) {
        return "ps__thumb-" + s;
      },
      rail: function(s) {
        return "ps__rail-" + s;
      },
      consuming: "ps__child--consume"
    },
    state: {
      focus: "ps--focus",
      clicking: "ps--clicking",
      active: function(s) {
        return "ps--active-" + s;
      },
      scrolling: function(s) {
        return "ps--scrolling-" + s;
      }
    }
  };
  var uh = { x: null, y: null };
  function ph(s, t) {
    var e = s.element.classList, i = j.state.scrolling(t);
    e.contains(i) ? clearTimeout(uh[t]) : e.add(i);
  }
  function _h(s, t) {
    uh[t] = setTimeout(function() {
      return s.isAlive && s.element.classList.remove(j.state.scrolling(t));
    }, s.settings.scrollingThreshold);
  }
  function ov(s, t) {
    ph(s, t), _h(s, t);
  }
  var zi = function(t) {
    this.element = t, this.handlers = {};
  };
  var fh = { isEmpty: { configurable: true } };
  zi.prototype.bind = function(t, e) {
    typeof this.handlers[t] > "u" && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, false);
  };
  zi.prototype.unbind = function(t, e) {
    var i = this;
    this.handlers[t] = this.handlers[t].filter(function(n) {
      return e && n !== e ? true : (i.element.removeEventListener(t, n, false), false);
    });
  };
  zi.prototype.unbindAll = function() {
    for (var t in this.handlers)
      this.unbind(t);
  };
  fh.isEmpty.get = function() {
    var s = this;
    return Object.keys(this.handlers).every(function(t) {
      return s.handlers[t].length === 0;
    });
  };
  Object.defineProperties(zi.prototype, fh);
  var si = function() {
    this.eventElements = [];
  };
  si.prototype.eventElement = function(t) {
    var e = this.eventElements.filter(function(i) {
      return i.element === t;
    })[0];
    return e || (e = new zi(t), this.eventElements.push(e)), e;
  };
  si.prototype.bind = function(t, e, i) {
    this.eventElement(t).bind(e, i);
  };
  si.prototype.unbind = function(t, e, i) {
    var n = this.eventElement(t);
    n.unbind(e, i), n.isEmpty && this.eventElements.splice(this.eventElements.indexOf(n), 1);
  };
  si.prototype.unbindAll = function() {
    this.eventElements.forEach(function(t) {
      return t.unbindAll();
    }), this.eventElements = [];
  };
  si.prototype.once = function(t, e, i) {
    var n = this.eventElement(t), o = function(r) {
      n.unbind(e, o), i(r);
    };
    n.bind(e, o);
  };
  function ks(s) {
    if (typeof window.CustomEvent == "function")
      return new CustomEvent(s);
    var t = document.createEvent("CustomEvent");
    return t.initCustomEvent(s, false, false, void 0), t;
  }
  function on(s, t, e, i, n) {
    i === void 0 && (i = true), n === void 0 && (n = false);
    var o;
    if (t === "top")
      o = [
        "contentHeight",
        "containerHeight",
        "scrollTop",
        "y",
        "up",
        "down"
      ];
    else if (t === "left")
      o = [
        "contentWidth",
        "containerWidth",
        "scrollLeft",
        "x",
        "left",
        "right"
      ];
    else
      throw new Error("A proper axis should be provided");
    rv(s, e, o, i, n);
  }
  function rv(s, t, e, i, n) {
    var o = e[0], r = e[1], a = e[2], l = e[3], p = e[4], u = e[5];
    i === void 0 && (i = true), n === void 0 && (n = false);
    var _ = s.element;
    s.reach[l] = null, _[a] < 1 && (s.reach[l] = "start"), _[a] > s[o] - s[r] - 1 && (s.reach[l] = "end"), t && (_.dispatchEvent(ks("ps-scroll-" + l)), t < 0 ? _.dispatchEvent(ks("ps-scroll-" + p)) : t > 0 && _.dispatchEvent(ks("ps-scroll-" + u)), i && ov(s, l)), s.reach[l] && (t || n) && _.dispatchEvent(ks("ps-" + l + "-reach-" + s.reach[l]));
  }
  function W(s) {
    return parseInt(s, 10) || 0;
  }
  function av(s) {
    return Qt(s, "input,[contenteditable]") || Qt(s, "select,[contenteditable]") || Qt(s, "textarea,[contenteditable]") || Qt(s, "button,[contenteditable]");
  }
  function lv(s) {
    var t = Lt(s);
    return W(t.width) + W(t.paddingLeft) + W(t.paddingRight) + W(t.borderLeftWidth) + W(t.borderRightWidth);
  }
  var Ne = {
    isWebKit: typeof document < "u" && "WebkitAppearance" in document.documentElement.style,
    supportsTouch: typeof window < "u" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
    supportsIePointer: typeof navigator < "u" && navigator.msMaxTouchPoints,
    isChrome: typeof navigator < "u" && /Chrome/i.test(navigator && navigator.userAgent)
  };
  function Bt(s) {
    var t = s.element, e = Math.floor(t.scrollTop), i = t.getBoundingClientRect();
    s.containerWidth = Math.round(i.width), s.containerHeight = Math.round(i.height), s.contentWidth = t.scrollWidth, s.contentHeight = t.scrollHeight, t.contains(s.scrollbarXRail) || (Cl(t, j.element.rail("x")).forEach(function(n) {
      return Pe(n);
    }), t.appendChild(s.scrollbarXRail)), t.contains(s.scrollbarYRail) || (Cl(t, j.element.rail("y")).forEach(function(n) {
      return Pe(n);
    }), t.appendChild(s.scrollbarYRail)), !s.settings.suppressScrollX && s.containerWidth + s.settings.scrollXMarginOffset < s.contentWidth ? (s.scrollbarXActive = true, s.railXWidth = s.containerWidth - s.railXMarginWidth, s.railXRatio = s.containerWidth / s.railXWidth, s.scrollbarXWidth = Al(s, W(s.railXWidth * s.containerWidth / s.contentWidth)), s.scrollbarXLeft = W((s.negativeScrollAdjustment + t.scrollLeft) * (s.railXWidth - s.scrollbarXWidth) / (s.contentWidth - s.containerWidth))) : s.scrollbarXActive = false, !s.settings.suppressScrollY && s.containerHeight + s.settings.scrollYMarginOffset < s.contentHeight ? (s.scrollbarYActive = true, s.railYHeight = s.containerHeight - s.railYMarginHeight, s.railYRatio = s.containerHeight / s.railYHeight, s.scrollbarYHeight = Al(s, W(s.railYHeight * s.containerHeight / s.contentHeight)), s.scrollbarYTop = W(e * (s.railYHeight - s.scrollbarYHeight) / (s.contentHeight - s.containerHeight))) : s.scrollbarYActive = false, s.scrollbarXLeft >= s.railXWidth - s.scrollbarXWidth && (s.scrollbarXLeft = s.railXWidth - s.scrollbarXWidth), s.scrollbarYTop >= s.railYHeight - s.scrollbarYHeight && (s.scrollbarYTop = s.railYHeight - s.scrollbarYHeight), cv(t, s), s.scrollbarXActive ? t.classList.add(j.state.active("x")) : (t.classList.remove(j.state.active("x")), s.scrollbarXWidth = 0, s.scrollbarXLeft = 0, t.scrollLeft = s.isRtl === true ? s.contentWidth : 0), s.scrollbarYActive ? t.classList.add(j.state.active("y")) : (t.classList.remove(j.state.active("y")), s.scrollbarYHeight = 0, s.scrollbarYTop = 0, t.scrollTop = 0);
  }
  function Al(s, t) {
    return s.settings.minScrollbarLength && (t = Math.max(t, s.settings.minScrollbarLength)), s.settings.maxScrollbarLength && (t = Math.min(t, s.settings.maxScrollbarLength)), t;
  }
  function cv(s, t) {
    var e = { width: t.railXWidth }, i = Math.floor(s.scrollTop);
    t.isRtl ? e.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth - t.contentWidth : e.left = s.scrollLeft, t.isScrollbarXUsingBottom ? e.bottom = t.scrollbarXBottom - i : e.top = t.scrollbarXTop + i, ot(t.scrollbarXRail, e);
    var n = { top: i, height: t.railYHeight };
    t.isScrollbarYUsingRight ? t.isRtl ? n.right = t.contentWidth - (t.negativeScrollAdjustment + s.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : n.right = t.scrollbarYRight - s.scrollLeft : t.isRtl ? n.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth * 2 - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : n.left = t.scrollbarYLeft + s.scrollLeft, ot(t.scrollbarYRail, n), ot(t.scrollbarX, {
      left: t.scrollbarXLeft,
      width: t.scrollbarXWidth - t.railBorderXWidth
    }), ot(t.scrollbarY, {
      top: t.scrollbarYTop,
      height: t.scrollbarYHeight - t.railBorderYWidth
    });
  }
  function hv(s) {
    s.element, s.event.bind(s.scrollbarY, "mousedown", function(t) {
      return t.stopPropagation();
    }), s.event.bind(s.scrollbarYRail, "mousedown", function(t) {
      var e = t.pageY - window.pageYOffset - s.scrollbarYRail.getBoundingClientRect().top, i = e > s.scrollbarYTop ? 1 : -1;
      s.element.scrollTop += i * s.containerHeight, Bt(s), t.stopPropagation();
    }), s.event.bind(s.scrollbarX, "mousedown", function(t) {
      return t.stopPropagation();
    }), s.event.bind(s.scrollbarXRail, "mousedown", function(t) {
      var e = t.pageX - window.pageXOffset - s.scrollbarXRail.getBoundingClientRect().left, i = e > s.scrollbarXLeft ? 1 : -1;
      s.element.scrollLeft += i * s.containerWidth, Bt(s), t.stopPropagation();
    });
  }
  function dv(s) {
    yl(s, [
      "containerWidth",
      "contentWidth",
      "pageX",
      "railXWidth",
      "scrollbarX",
      "scrollbarXWidth",
      "scrollLeft",
      "x",
      "scrollbarXRail"
    ]), yl(s, [
      "containerHeight",
      "contentHeight",
      "pageY",
      "railYHeight",
      "scrollbarY",
      "scrollbarYHeight",
      "scrollTop",
      "y",
      "scrollbarYRail"
    ]);
  }
  function yl(s, t) {
    var e = t[0], i = t[1], n = t[2], o = t[3], r = t[4], a = t[5], l = t[6], p = t[7], u = t[8], _ = s.element, f = null, g = null, m = null;
    function b(w) {
      w.touches && w.touches[0] && (w[n] = w.touches[0].pageY), _[l] = f + m * (w[n] - g), ph(s, p), Bt(s), w.stopPropagation(), w.type.startsWith("touch") && w.changedTouches.length > 1 && w.preventDefault();
    }
    function v() {
      _h(s, p), s[u].classList.remove(j.state.clicking), s.event.unbind(s.ownerDocument, "mousemove", b);
    }
    function C(w, E) {
      f = _[l], E && w.touches && (w[n] = w.touches[0].pageY), g = w[n], m = (s[i] - s[e]) / (s[o] - s[a]), E ? s.event.bind(s.ownerDocument, "touchmove", b) : (s.event.bind(s.ownerDocument, "mousemove", b), s.event.once(s.ownerDocument, "mouseup", v), w.preventDefault()), s[u].classList.add(j.state.clicking), w.stopPropagation();
    }
    s.event.bind(s[r], "mousedown", function(w) {
      C(w);
    }), s.event.bind(s[r], "touchstart", function(w) {
      C(w, true);
    });
  }
  function uv(s) {
    var t = s.element, e = function() {
      return Qt(t, ":hover");
    }, i = function() {
      return Qt(s.scrollbarX, ":focus") || Qt(s.scrollbarY, ":focus");
    };
    function n(o, r) {
      var a = Math.floor(t.scrollTop);
      if (o === 0) {
        if (!s.scrollbarYActive)
          return false;
        if (a === 0 && r > 0 || a >= s.contentHeight - s.containerHeight && r < 0)
          return !s.settings.wheelPropagation;
      }
      var l = t.scrollLeft;
      if (r === 0) {
        if (!s.scrollbarXActive)
          return false;
        if (l === 0 && o < 0 || l >= s.contentWidth - s.containerWidth && o > 0)
          return !s.settings.wheelPropagation;
      }
      return true;
    }
    s.event.bind(s.ownerDocument, "keydown", function(o) {
      if (!(o.isDefaultPrevented && o.isDefaultPrevented() || o.defaultPrevented) && !(!e() && !i())) {
        var r = document.activeElement ? document.activeElement : s.ownerDocument.activeElement;
        if (r) {
          if (r.tagName === "IFRAME")
            r = r.contentDocument.activeElement;
          else
            for (; r.shadowRoot; )
              r = r.shadowRoot.activeElement;
          if (av(r))
            return;
        }
        var a = 0, l = 0;
        switch (o.which) {
          case 37:
            o.metaKey ? a = -s.contentWidth : o.altKey ? a = -s.containerWidth : a = -30;
            break;
          case 38:
            o.metaKey ? l = s.contentHeight : o.altKey ? l = s.containerHeight : l = 30;
            break;
          case 39:
            o.metaKey ? a = s.contentWidth : o.altKey ? a = s.containerWidth : a = 30;
            break;
          case 40:
            o.metaKey ? l = -s.contentHeight : o.altKey ? l = -s.containerHeight : l = -30;
            break;
          case 32:
            o.shiftKey ? l = s.containerHeight : l = -s.containerHeight;
            break;
          case 33:
            l = s.containerHeight;
            break;
          case 34:
            l = -s.containerHeight;
            break;
          case 36:
            l = s.contentHeight;
            break;
          case 35:
            l = -s.contentHeight;
            break;
          default:
            return;
        }
        s.settings.suppressScrollX && a !== 0 || s.settings.suppressScrollY && l !== 0 || (t.scrollTop -= l, t.scrollLeft += a, Bt(s), n(a, l) && o.preventDefault());
      }
    });
  }
  function pv(s) {
    var t = s.element;
    function e(r, a) {
      var l = Math.floor(t.scrollTop), p = t.scrollTop === 0, u = l + t.offsetHeight === t.scrollHeight, _ = t.scrollLeft === 0, f = t.scrollLeft + t.offsetWidth === t.scrollWidth, g;
      return Math.abs(a) > Math.abs(r) ? g = p || u : g = _ || f, g ? !s.settings.wheelPropagation : true;
    }
    function i(r) {
      var a = r.deltaX, l = -1 * r.deltaY;
      return (typeof a > "u" || typeof l > "u") && (a = -1 * r.wheelDeltaX / 6, l = r.wheelDeltaY / 6), r.deltaMode && r.deltaMode === 1 && (a *= 10, l *= 10), a !== a && l !== l && (a = 0, l = r.wheelDelta), r.shiftKey ? [-l, -a] : [a, l];
    }
    function n(r, a, l) {
      if (!Ne.isWebKit && t.querySelector("select:focus"))
        return true;
      if (!t.contains(r))
        return false;
      for (var p = r; p && p !== t; ) {
        if (p.classList.contains(j.element.consuming))
          return true;
        var u = Lt(p);
        if (l && u.overflowY.match(/(scroll|auto)/)) {
          var _ = p.scrollHeight - p.clientHeight;
          if (_ > 0 && (p.scrollTop > 0 && l < 0 || p.scrollTop < _ && l > 0))
            return true;
        }
        if (a && u.overflowX.match(/(scroll|auto)/)) {
          var f = p.scrollWidth - p.clientWidth;
          if (f > 0 && (p.scrollLeft > 0 && a < 0 || p.scrollLeft < f && a > 0))
            return true;
        }
        p = p.parentNode;
      }
      return false;
    }
    function o(r) {
      var a = i(r), l = a[0], p = a[1];
      if (!n(r.target, l, p)) {
        var u = false;
        s.settings.useBothWheelAxes ? s.scrollbarYActive && !s.scrollbarXActive ? (p ? t.scrollTop -= p * s.settings.wheelSpeed : t.scrollTop += l * s.settings.wheelSpeed, u = true) : s.scrollbarXActive && !s.scrollbarYActive && (l ? t.scrollLeft += l * s.settings.wheelSpeed : t.scrollLeft -= p * s.settings.wheelSpeed, u = true) : (t.scrollTop -= p * s.settings.wheelSpeed, t.scrollLeft += l * s.settings.wheelSpeed), Bt(s), u = u || e(l, p), u && !r.ctrlKey && (r.stopPropagation(), r.preventDefault());
      }
    }
    typeof window.onwheel < "u" ? s.event.bind(t, "wheel", o) : typeof window.onmousewheel < "u" && s.event.bind(t, "mousewheel", o);
  }
  function _v(s) {
    if (!Ne.supportsTouch && !Ne.supportsIePointer)
      return;
    var t = s.element;
    function e(m, b) {
      var v = Math.floor(t.scrollTop), C = t.scrollLeft, w = Math.abs(m), E = Math.abs(b);
      if (E > w) {
        if (b < 0 && v === s.contentHeight - s.containerHeight || b > 0 && v === 0)
          return window.scrollY === 0 && b > 0 && Ne.isChrome;
      } else if (w > E && (m < 0 && C === s.contentWidth - s.containerWidth || m > 0 && C === 0))
        return true;
      return true;
    }
    function i(m, b) {
      t.scrollTop -= b, t.scrollLeft -= m, Bt(s);
    }
    var n = {}, o = 0, r = {}, a = null;
    function l(m) {
      return m.targetTouches ? m.targetTouches[0] : m;
    }
    function p(m) {
      return m.pointerType && m.pointerType === "pen" && m.buttons === 0 ? false : !!(m.targetTouches && m.targetTouches.length === 1 || m.pointerType && m.pointerType !== "mouse" && m.pointerType !== m.MSPOINTER_TYPE_MOUSE);
    }
    function u(m) {
      if (p(m)) {
        var b = l(m);
        n.pageX = b.pageX, n.pageY = b.pageY, o = (/* @__PURE__ */ new Date()).getTime(), a !== null && clearInterval(a);
      }
    }
    function _(m, b, v) {
      if (!t.contains(m))
        return false;
      for (var C = m; C && C !== t; ) {
        if (C.classList.contains(j.element.consuming))
          return true;
        var w = Lt(C);
        if (v && w.overflowY.match(/(scroll|auto)/)) {
          var E = C.scrollHeight - C.clientHeight;
          if (E > 0 && (C.scrollTop > 0 && v < 0 || C.scrollTop < E && v > 0))
            return true;
        }
        if (b && w.overflowX.match(/(scroll|auto)/)) {
          var T = C.scrollWidth - C.clientWidth;
          if (T > 0 && (C.scrollLeft > 0 && b < 0 || C.scrollLeft < T && b > 0))
            return true;
        }
        C = C.parentNode;
      }
      return false;
    }
    function f(m) {
      if (p(m)) {
        var b = l(m), v = { pageX: b.pageX, pageY: b.pageY }, C = v.pageX - n.pageX, w = v.pageY - n.pageY;
        if (_(m.target, C, w))
          return;
        i(C, w), n = v;
        var E = (/* @__PURE__ */ new Date()).getTime(), T = E - o;
        T > 0 && (r.x = C / T, r.y = w / T, o = E), e(C, w) && m.preventDefault();
      }
    }
    function g() {
      s.settings.swipeEasing && (clearInterval(a), a = setInterval(function() {
        if (s.isInitialized) {
          clearInterval(a);
          return;
        }
        if (!r.x && !r.y) {
          clearInterval(a);
          return;
        }
        if (Math.abs(r.x) < 0.01 && Math.abs(r.y) < 0.01) {
          clearInterval(a);
          return;
        }
        if (!s.element) {
          clearInterval(a);
          return;
        }
        i(r.x * 30, r.y * 30), r.x *= 0.8, r.y *= 0.8;
      }, 10));
    }
    Ne.supportsTouch ? (s.event.bind(t, "touchstart", u), s.event.bind(t, "touchmove", f), s.event.bind(t, "touchend", g)) : Ne.supportsIePointer && (window.PointerEvent ? (s.event.bind(t, "pointerdown", u), s.event.bind(t, "pointermove", f), s.event.bind(t, "pointerup", g)) : window.MSPointerEvent && (s.event.bind(t, "MSPointerDown", u), s.event.bind(t, "MSPointerMove", f), s.event.bind(t, "MSPointerUp", g)));
  }
  var fv = function() {
    return {
      handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
      maxScrollbarLength: null,
      minScrollbarLength: null,
      scrollingThreshold: 1e3,
      scrollXMarginOffset: 0,
      scrollYMarginOffset: 0,
      suppressScrollX: false,
      suppressScrollY: false,
      swipeEasing: true,
      useBothWheelAxes: false,
      wheelPropagation: true,
      wheelSpeed: 1
    };
  };
  var mv = {
    "click-rail": hv,
    "drag-thumb": dv,
    keyboard: uv,
    wheel: pv,
    touch: _v
  };
  var Ui = function(t, e) {
    var i = this;
    if (e === void 0 && (e = {}), typeof t == "string" && (t = document.querySelector(t)), !t || !t.nodeName)
      throw new Error("no element is specified to initialize PerfectScrollbar");
    this.element = t, t.classList.add(j.main), this.settings = fv();
    for (var n in e)
      this.settings[n] = e[n];
    this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
    var o = function() {
      return t.classList.add(j.state.focus);
    }, r = function() {
      return t.classList.remove(j.state.focus);
    };
    this.isRtl = Lt(t).direction === "rtl", this.isRtl === true && t.classList.add(j.rtl), this.isNegativeScroll = function() {
      var p = t.scrollLeft, u = null;
      return t.scrollLeft = -1, u = t.scrollLeft < 0, t.scrollLeft = p, u;
    }(), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new si(), this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = ws(j.element.rail("x")), t.appendChild(this.scrollbarXRail), this.scrollbarX = ws(j.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", o), this.event.bind(this.scrollbarX, "blur", r), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
    var a = Lt(this.scrollbarXRail);
    this.scrollbarXBottom = parseInt(a.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = false, this.scrollbarXTop = W(a.top)) : this.isScrollbarXUsingBottom = true, this.railBorderXWidth = W(a.borderLeftWidth) + W(a.borderRightWidth), ot(this.scrollbarXRail, { display: "block" }), this.railXMarginWidth = W(a.marginLeft) + W(a.marginRight), ot(this.scrollbarXRail, { display: "" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = ws(j.element.rail("y")), t.appendChild(this.scrollbarYRail), this.scrollbarY = ws(j.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", o), this.event.bind(this.scrollbarY, "blur", r), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
    var l = Lt(this.scrollbarYRail);
    this.scrollbarYRight = parseInt(l.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = false, this.scrollbarYLeft = W(l.left)) : this.isScrollbarYUsingRight = true, this.scrollbarYOuterWidth = this.isRtl ? lv(this.scrollbarY) : null, this.railBorderYWidth = W(l.borderTopWidth) + W(l.borderBottomWidth), ot(this.scrollbarYRail, { display: "block" }), this.railYMarginHeight = W(l.marginTop) + W(l.marginBottom), ot(this.scrollbarYRail, { display: "" }), this.railYHeight = null, this.railYRatio = null, this.reach = {
      x: t.scrollLeft <= 0 ? "start" : t.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
      y: t.scrollTop <= 0 ? "start" : t.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
    }, this.isAlive = true, this.settings.handlers.forEach(function(p) {
      return mv[p](i);
    }), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, "scroll", function(p) {
      return i.onScroll(p);
    }), Bt(this);
  };
  Ui.prototype.update = function() {
    this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, ot(this.scrollbarXRail, { display: "block" }), ot(this.scrollbarYRail, { display: "block" }), this.railXMarginWidth = W(Lt(this.scrollbarXRail).marginLeft) + W(Lt(this.scrollbarXRail).marginRight), this.railYMarginHeight = W(Lt(this.scrollbarYRail).marginTop) + W(Lt(this.scrollbarYRail).marginBottom), ot(this.scrollbarXRail, { display: "none" }), ot(this.scrollbarYRail, { display: "none" }), Bt(this), on(this, "top", 0, false, true), on(this, "left", 0, false, true), ot(this.scrollbarXRail, { display: "" }), ot(this.scrollbarYRail, { display: "" }));
  };
  Ui.prototype.onScroll = function(t) {
    this.isAlive && (Bt(this), on(this, "top", this.element.scrollTop - this.lastScrollTop), on(this, "left", this.element.scrollLeft - this.lastScrollLeft), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);
  };
  Ui.prototype.destroy = function() {
    this.isAlive && (this.event.unbindAll(), Pe(this.scrollbarX), Pe(this.scrollbarY), Pe(this.scrollbarXRail), Pe(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = false);
  };
  Ui.prototype.removePsClasses = function() {
    this.element.className = this.element.className.split(" ").filter(function(t) {
      return !t.match(/^ps([-_].+|)$/);
    }).join(" ");
  };
  var Ot = "te";
  var St = "ps";
  var _o = [
    { te: `scrollX.${Ot}.${St}`, ps: "ps-scroll-x" },
    { te: `scrollY.${Ot}.${St}`, ps: "ps-scroll-y" },
    { te: `scrollUp.${Ot}.${St}`, ps: "ps-scroll-up" },
    { te: `scrollDown.${Ot}.${St}`, ps: "ps-scroll-down" },
    { te: `scrollLeft.${Ot}.${St}`, ps: "ps-scroll-left" },
    { te: `scrollRight.${Ot}.${St}`, ps: "ps-scroll-right" },
    { te: `scrollXEnd.${Ot}.${St}`, ps: "ps-x-reach-end" },
    { te: `scrollYEnd.${Ot}.${St}`, ps: "ps-y-reach-end" },
    { te: `scrollXStart.${Ot}.${St}`, ps: "ps-x-reach-start" },
    { te: `scrollYStart.${Ot}.${St}`, ps: "ps-y-reach-start" }
  ];
  var Ni = "datatable";
  var ft = `data-te-${Ni}`;
  var Ei = `te.${Ni}`;
  var _n = `.${Ei}`;
  var Vv = `[${ft}-inner-ref]`;
  var fo = `[${ft}-cell-ref]`;
  var Wv = `[${ft}-header-ref]`;
  var Fv = `[${ft}-header-checkbox-ref]`;
  var Yv = `[${ft}-pagination-right-ref]`;
  var jv = `[${ft}-pagination-left-ref]`;
  var Kv = `[${ft}-pagination-start-ref]`;
  var zv = `[${ft}-pagination-end-ref]`;
  var Uv = `[${ft}-pagination-nav-ref]`;
  var Xv = `[${ft}-select-ref]`;
  var mo = `[${ft}-sort-icon-ref]`;
  var fi = `[${ft}-row-ref]`;
  var go = `[${ft}-row-checkbox-ref]`;
  var Gv = `selectRows${_n}`;
  var xl = `render${_n}`;
  var qv = `rowClick${_n}`;
  var Zv = `update${_n}`;
  var qs = "te.rating";
  var ni = `.${qs}`;
  var Sl = `onSelect${ni}`;
  var rE = `onHover${ni}`;
  var Il = `keyup${ni}`;
  var Dl = `focusout${ni}`;
  var $l = `keydown${ni}`;
  var Ll = `mousedown${ni}`;
  var Ci = "te.popconfirm";
  var bh = `.${Ci}`;
  var aE = `cancel${bh}`;
  var lE = `confirm${bh}`;
  var Ai = "te.lightbox";
  var fE = `.${Ai}`;
  var mE = ".data-api";
  var Ie = `click${fE}${mE}`;
  var Th = "[data-te-lightbox-init]";
  var gE = `${Th} img:not([data-te-lightbox-disabled])`;
  var IE = {
    isRequired: "This is required",
    isEmail: "Please enter a valid email address",
    isLongerThan: "This field must be longer than {length} characters",
    isShorterThan: "This field must be shorter than {length} characters",
    isChecked: "This is required",
    isPhone: "Please enter a valid phone number",
    isNumber: "Expected value with type Number",
    isString: "Expected value with type String",
    isBoolean: "Expected value with type Boolean",
    isDate: "Please enter a valid date",
    is12hFormat: "Please enter a valid time in 12h format",
    is24hFormat: "Please enter a valid time in 24h format"
  };
  var DE = {
    isRequired: (s, t) => (s == null ? void 0 : s.trim()) ? true : t,
    isEmail: (s, t) => /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(s) ? true : t,
    isLongerThan: (s, t, e) => s.length > e ? true : t.replace("{length}", e),
    isShorterThan: (s, t, e) => s.length < e ? true : t.replace("{length}", e),
    isChecked: (s) => s ? true : "This is required",
    isPhone: (s, t) => s.length === 9 ? true : t,
    isNumber: (s, t) => s && !isNaN(Number(s)) ? true : t,
    isString: (s, t) => typeof s == "string" ? true : t,
    isBoolean: (s, t) => typeof s == "boolean" ? true : t,
    isDate: (s, t) => {
      const e = /^([0-9]{1,2})\/([0-9]{1,2})\/([0-9]{4})$/;
      return s.match(e) ? true : t;
    },
    is12hFormat: (s, t) => {
      const e = /^(0?[1-9]|1[0-2]):[0-5][0-9] [APap][mM]$/;
      return s.match(e) ? true : t;
    },
    is24hFormat: (s, t) => {
      const e = /^(?:[01]\d|2[0-3]):[0-5][0-9]$/;
      return s.match(e) ? true : t;
    }
  };
  var Eo = "validation";
  var jo = "te.validation";
  var fn = `.${jo}`;
  var Eh = "data-te-validate";
  var Os = "data-te-validated";
  var Ss = "data-te-validation-state";
  var Is = "data-te-validation-feedback";
  var Co = "data-te-valid-feedback";
  var Ds = "data-te-invalid-feedback";
  var Rl = "data-te-validation-ruleset";
  var $E = "data-te-submit-btn-ref";
  var LE = `[${Eh}]`;
  var NE = "[data-te-input-notch-ref] div";
  var ME = `[${$E}]`;
  var RE = `validated${fn}`;
  var PE = `valid${fn}`;
  var BE = `invalid${fn}`;
  var HE = `changed${fn}`;
  var VE = {
    validFeedback: "string",
    invalidFeedback: "string",
    disableFeedback: "boolean",
    customRules: "object",
    customErrorMessages: "object",
    activeValidation: "boolean",
    submitCallback: "(function|null)"
  };
  var Pl = {
    validFeedback: "Looks good!",
    invalidFeedback: "Something is wrong!",
    disableFeedback: false,
    customRules: {},
    customErrorMessages: {},
    activeValidation: false,
    submitCallback: null
  };
  var WE = {
    notchLeadingValid: "border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[-1px_0_0_#14a44d,_0_1px_0_0_#14a44d,_0_-1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]",
    notchMiddleValid: "border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[0_1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]",
    notchTrailingValid: "border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[1px_0_0_#14a44d,_0_-1px_0_0_#14a44d,_0_1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]",
    notchLeadingInvalid: "border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[-1px_0_0_#dc4c64,_0_1px_0_0_#dc4c64,_0_-1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]",
    notchMiddleInvalid: "border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[0_1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]",
    notchTrailingInvalid: "border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[1px_0_0_#dc4c64,_0_-1px_0_0_#dc4c64,_0_1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]",
    basicInputValid: "!border-[#14a44d] focus:!border-[#14a44d] focus:!shadow-[inset_0_0_0_1px_#14a44d]",
    basicInputInvalid: "!border-[#dc4c64] focus:!border-[#dc4c64] focus:!shadow-[inset_0_0_0_1px_#dc4c64]",
    checkboxValid: "checked:!border-[#14a44d] checked:!bg-[#14a44d] checked:after:!bg-[#14a44d]",
    checkboxInvalid: "checked:!border-[#dc4c64] checked:!bg-[#dc4c64] checked:after:!bg-[#dc4c64]",
    radioValid: "checked:!border-[#14a44d] checked:after:!bg-[#14a44d]",
    radioInvalid: "checked:!border-[#dc4c64] checked:after:!bg-[#dc4c64]",
    labelValid: "!text-[#14a44d]",
    labelInvalid: "!text-[#dc4c64]",
    validFeedback: "absolute top-full left-0 m-1 w-auto text-sm text-[#14a44d] animate-[fade-in_0.3s_both]",
    invalidFeedback: "absolute top-full left-0 m-1 w-auto text-sm text-[#dc4c64] animate-[fade-in_0.3s_both]",
    elementValidated: "mb-8"
  };
  var FE = {
    notchLeadingValid: "string",
    notchMiddleValid: "string",
    notchTrailingValid: "string",
    notchLeadingInvalid: "string",
    notchMiddleInvalid: "string",
    notchTrailingInvalid: "string",
    basicInputValid: "string",
    basicInputInvalid: "string",
    checkboxValid: "string",
    checkboxInvalid: "string",
    radioValid: "string",
    radioInvalid: "string",
    labelValid: "string",
    labelInvalid: "string",
    validFeedback: "string",
    invalidFeedback: "string",
    elementValidated: "string"
  };
  var Ch = class extends gt {
    constructor(t, e, i) {
      super(t), this._element = t, this._element && y.setData(t, jo, this), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._isValid = true, this._shouldApplyInputEvents = true, this._submitCallback = null, this._errorMessages = __spreadValues(__spreadValues({}, IE), this._config.customErrorMessages), this._validationElements = this._getValidationElements(), this._validationElements.forEach(({ element: n, input: o }) => {
        this._createFeedbackWrapper(n, o);
      }), this._validationObserver = this._watchForValidationChanges(), this._validationObserver.observe(this._element, { attributes: true }), this._submitButton = null, this._handleSubmitButton(), this._validationResult = [];
    }
    static get DefaultType() {
      return VE;
    }
    static get Default() {
      return Pl;
    }
    static get NAME() {
      return Eo;
    }
    dispose() {
      var t;
      (t = this._validationObserver) == null || t.disconnect(), this._validationObserver = null, this._submitCallback = null, this._element.removeAttribute(Os), this._removeValidationTraces(), this._validationResult = [], this._submitButton && c.off(this._submitButton, "click"), this._config.activeValidation && (this._validationElements.forEach((e) => {
        const { input: i } = e;
        c.off(i, "input");
      }), this._shouldApplyInputEvents = true);
    }
    _removeValidationTraces() {
      this._removeFeedbackWrapper(), this._validationElements.forEach(({ element: t, classes: e, initialHTML: i }) => {
        t.className = e, t.innerHTML = i, t.removeAttribute(Ss), t.removeAttribute(Ds), t.removeAttribute(Co);
      }), this._validationElements = [];
    }
    _getValidationElements() {
      return d.find(LE, this._element).map((e) => {
        const i = d.findOne("input", e) || d.findOne("textarea", e);
        return {
          id: i.name || i.id || rt("validation-"),
          element: e,
          type: e.getAttribute(Eh),
          input: i,
          validFeedback: e.getAttribute(Co),
          invalidFeedback: e.getAttribute(Ds),
          classes: e.className,
          initialHTML: e.innerHTML,
          ruleset: e.getAttribute(Rl)
        };
      });
    }
    _createFeedbackWrapper(t, e) {
      if (t.querySelectorAll(`[${Is}]`).length > 0)
        return;
      const i = document.createElement("span");
      i.setAttribute(Is, ""), e.parentNode.appendChild(i);
    }
    _removeFeedbackWrapper() {
      d.find(`[${Is}]`, this._element).forEach((e) => {
        e.remove();
      });
    }
    _watchForValidationChanges() {
      return new MutationObserver((e) => {
        e.forEach((i) => {
          const { attributeName: n } = i;
          n === Os && (this._handleValidation(), this._config.activeValidation && this._shouldApplyInputEvents && this._applyInputEvents());
        });
      });
    }
    _handleValidation() {
      this._element.getAttribute(Os) && (this._validationResult = [], this._isValid = true, this._validationElements.forEach((t) => this._validateSingleElement(t)), this._emitEvents(this._isValid), this._submitCallback && this._submitCallback(this._isValid));
    }
    _validateSingleElement(t) {
      var p;
      const { element: e, type: i, input: n, ruleset: o, id: r } = t;
      o && this._validateByRuleset(t);
      const a = e.getAttribute(Ss);
      if (a !== "valid" && a !== "invalid")
        return;
      const l = a.replace(a.charAt(0), a.charAt(0).toUpperCase());
      i === "input" && this._restyleNotches(e, l), i === "basic" && this._restyleBasicInputs(n, l), (i === "checkbox" || i === "radio") && this._restyleCheckboxes(n, l, i), this._restyleLabels(e, l), a === "invalid" && (this._isValid = false), this._config.disableFeedback || this._applyFeedback(e, a), c.trigger(this._element, HE, {
        value: {
          name: r,
          result: a,
          validation: (p = this._validationResult[r]) == null ? void 0 : p.validation
        }
      });
    }
    _validateByRuleset({ element: t, type: e, invalidFeedback: i, input: n, id: o }) {
      const r = this._getRuleset(t);
      if (!r.length)
        return;
      const a = e === "checkbox" || e === "radio" ? n.checked : n.value;
      let l = "", p = [];
      for (const u of r) {
        const _ = u.callback(a, this._errorMessages[u.name] || this._config.invalidFeedback, u.parameter);
        p.push({
          result: _ === true,
          name: u.name,
          fullName: u.fullName
        }), typeof _ == "string" && !l && (l = _);
      }
      if (this._validationResult[o] = { element: t, validation: p }, !l) {
        t.setAttribute(Ss, "valid");
        return;
      }
      t.setAttribute(Ss, "invalid"), i || t.setAttribute(Ds, l);
    }
    _handleInputChange(t) {
      this._validateSingleElement(t);
    }
    _getRuleset(t) {
      const i = t.getAttribute(Rl).split("|");
      let n = [];
      const o = __spreadValues(__spreadValues({}, DE), this._config.customRules);
      return i.forEach((r) => {
        const a = this._getRuleData(r, o);
        a.callback ? n.push(a) : console.warn(`Rule ${r} does not exist`);
      }), n;
    }
    _getRuleData(t, e) {
      const i = t.split("(");
      return {
        callback: e[i[0]],
        parameter: i[1] ? i[1].split(")")[0] : null,
        name: i[0],
        fullName: t
      };
    }
    _applyFeedback(t, e) {
      const i = d.findOne(`[${Is}]`, t), n = t.getAttribute(Co) || this._config.validFeedback, o = t.getAttribute(Ds) || this._config.invalidFeedback;
      h.addClass(t, this._classes.elementValidated), i.textContent = e === "valid" ? n : o, i.className = this._classes[e === "valid" ? "validFeedback" : "invalidFeedback"];
    }
    _restyleCheckboxes(t, e, i) {
      h.removeClass(t, this._classes.checkboxValid), h.removeClass(t, this._classes.checkboxInvalid), h.addClass(t, this._classes[`${i}${e}`]);
    }
    _restyleBasicInputs(t, e) {
      h.removeClass(t, this._classes.basicInputValid), h.removeClass(t, this._classes.basicInputInvalid), h.addClass(t, this._classes[`basicInput${e}`]);
    }
    _restyleNotches(t, e) {
      d.find(NE, t).forEach((n, o) => {
        let r = o === 0 ? "notchLeading" : o === 1 ? "notchMiddle" : "notchTrailing";
        n.className = "", h.addClass(n, Kc[r]), r += e, h.addClass(n, this._classes[r]);
      });
    }
    _restyleLabels(t, e) {
      const i = d.find("label", t);
      i.length && i.forEach((n) => {
        h.removeClass(n, this._classes.labelValid), h.removeClass(n, this._classes.labelInvalid), h.addClass(n, this._classes[`label${e}`]);
      });
    }
    _emitEvents(t) {
      if (c.trigger(this._element, RE), t) {
        c.trigger(this._element, PE, {
          value: this._validationResult
        });
        return;
      }
      c.trigger(this._element, BE, {
        value: this._validationResult
      });
    }
    _applyInputEvents() {
      this._validationElements.forEach((t) => {
        const { input: e } = t;
        c.on(e, "input", () => this._handleInputChange(t));
      }), this._shouldApplyInputEvents = false;
    }
    _handleSubmitButton() {
      this._submitButton = d.findOne(ME, this._element), this._submitButton && c.on(this._submitButton, "click", (t) => this._handleSubmitButtonClick(t));
    }
    _handleSubmitButtonClick(t) {
      if (this._element.setAttribute(Os, true), this._config.submitCallback) {
        this._submitCallback = (e) => this._config.submitCallback(t, e);
        return;
      }
    }
    _getConfig(t) {
      return t = __spreadValues(__spreadValues(__spreadValues({}, Pl), h.getDataAttributes(this._element)), typeof t == "object" && t ? t : {}), D(Eo, t, this.constructor.DefaultType), t;
    }
    _getClasses(t) {
      const e = h.getDataClassAttributes(this._element);
      return t = __spreadValues(__spreadValues(__spreadValues({}, WE), e), t), D(Eo, t, FE), t;
    }
    static getInstance(t) {
      return y.getData(t, jo);
    }
    static getOrCreateInstance(t, e = {}) {
      return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
    }
    static jQueryInterface(t) {
      return this.each(function() {
        const e = Ch.getOrCreateInstance(this);
        if (typeof t == "string") {
          if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
            throw new TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }
  };
  var qt = "pan";
  var ZE = `${qt}start`;
  var QE = `${qt}end`;
  var JE = `${qt}move`;
  var Ye = "pinch";
  var o0 = `${Ye}end`;
  var r0 = `${Ye}start`;
  var a0 = `${Ye}move`;
  var Mi = "rotate";
  var _0 = `${Mi}end`;
  var f0 = `${Mi}start`;
  var Ko = "touch";
  var wo = `te.${Ko}`;
  var zo = "smoothScroll";
  var yi = `te.${zo}`;
  var mr = `.${yi}`;
  var A0 = `scrollStart${mr}`;
  var y0 = `scrollEnd${mr}`;
  var w0 = `scrollCancel${mr}`;
  var wi = "te.clipboard";
  var D0 = `.${wi}`;
  var N0 = `copy${D0}`;
  var Xo = "infiniteScroll";
  var Ls = `te.${Xo}`;
  var Ri = "loadingManagement";
  var Ns = `te.${Ri}`;
  var V0 = `show.te.${Ri}`;
  var Qs = "datetimepicker";
  var ki = `te.${Qs}`;
  var gr = `.${ki}`;
  var Oh = "data-te-datepicker-init";
  var Sh = "data-te-timepicker-init";
  var oC = "data-te-date-timepicker-toggle-ref";
  var aC = "data-te-timepicker-toggle-button-ref";
  var lC = `[${Sh}]`;
  var cC = `[${Oh}]`;
  var hC = `[${oC}]`;
  var dC = `[${aC}]`;
  var mC = `open${gr}`;
  var gC = `close${gr}`;
  var bC = `datetimeChange${gr}`;
  var De = $2("div");
  var Js = "sticky";
  var xi = `te.${Js}`;
  var Dh = `.${xi}`;
  var CC = `active${Dh}`;
  var AC = `inactive${Dh}`;
  var OC = (s) => {
    Zl(() => {
      const t = ql();
      if (t) {
        const e = s.NAME, i = t.fn[e];
        t.fn[e] = s.jQueryInterface, t.fn[e].Constructor = s, t.fn[e].noConflict = () => (t.fn[e] = i, s.jQueryInterface);
      }
    });
  };
  var SC = (s, t) => {
    c.on(document, `click.te.${s.NAME}`, t, function(e) {
      e.preventDefault(), s.getOrCreateInstance(this).toggle();
    });
  };
  var IC = (s, t) => {
    c.on(document, `click.te.${s.NAME}.data-api`, t, function(e) {
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), ge(this))
        return;
      s.getOrCreateInstance(this).show();
    });
  };
  var DC = (s, t) => {
    c.on(document, `click.te.${s.NAME}.data-api`, t, function(e) {
      const i = Jt(this);
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), ge(this))
        return;
      c.one(i, s.EVENT_HIDDEN, () => {
        Nt(this) && this.focus();
      });
      const n = d.findOne(s.OPEN_SELECTOR);
      n && n !== i && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);
    });
  };
  var $C = (s, t) => {
    c.on(document, `click.te.${s.NAME}`, t, (e) => {
      e.preventDefault();
      const i = e.target.closest(t);
      s.getOrCreateInstance(i).toggle();
    });
  };
  var LC = (s, t) => {
    c.on(document, `click.te.${s.NAME}`, t, function(e) {
      const i = Jt(this);
      ["A", "AREA"].includes(this.tagName) && e.preventDefault(), c.one(i, s.EVENT_SHOW, (r) => {
        r.defaultPrevented || c.one(i, s.EVENT_HIDDEN, () => {
          Nt(this) && this.focus();
        });
      });
      const n = d.findOne(`[${s.OPEN_SELECTOR}="true"]`);
      n && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);
    });
  };
  var NC = (s, t) => {
    c.one(document, "mousedown", t, s.autoInitial(new s()));
  };
  var MC = (s, t) => {
    c.on(document, `click.te.${s.NAME}.data-api`, t, function(e) {
      (e.target.tagName === "A" || e.delegateTarget && e.delegateTarget.tagName === "A") && e.preventDefault();
      const i = qo(this);
      d.find(i).forEach((o) => {
        s.getOrCreateInstance(o, { toggle: false }).toggle();
      });
    });
  };
  var RC = (s, t) => {
    [].slice.call(document.querySelectorAll(t)).map(function(i) {
      return new s(i);
    });
  };
  var PC = (s, t) => {
    [].slice.call(document.querySelectorAll(t)).map(function(i) {
      return new s(i);
    });
  };
  var BC = (s, t) => {
    d.find(t).forEach((e) => {
      new s(e);
    }), c.on(document, `click.te.${s.NAME}.data-api`, `${t} img:not([data-te-lightbox-disabled])`, s.toggle());
  };
  var HC = (s, t) => {
    const e = (o) => o[0] === "{" && o[o.length - 1] === "}" || o[0] === "[" && o[o.length - 1] === "]", i = (o) => typeof o != "string" ? o : e(o) ? JSON.parse(o.replace(/'/g, '"')) : o, n = (o) => {
      const r = {};
      return Object.keys(o).forEach((a) => {
        if (a.match(/dataset.*/)) {
          const l = a.slice(7, 8).toLowerCase().concat(a.slice(8));
          r[l] = i(o[a]);
        }
      }), r;
    };
    d.find(t).forEach((o) => {
      if (h.getDataAttribute(o, "chart") !== "bubble" && h.getDataAttribute(o, "chart") !== "scatter") {
        const r = h.getDataAttributes(o), a = {
          data: {
            datasets: [n(r)]
          }
        };
        return r.chart && (a.type = r.chart), r.labels && (a.data.labels = JSON.parse(r.labels.replace(/'/g, '"'))), new s(o, __spreadValues(__spreadValues({}, a), Ti[a.type]));
      }
      return null;
    });
  };
  var VC = class {
    constructor() {
      this.inits = [];
    }
    get initialized() {
      return this.inits;
    }
    isInited(t) {
      return this.inits.includes(t);
    }
    add(t) {
      this.isInited(t) || this.inits.push(t);
    }
  };
  var Go = new VC();
  var Oi = {
    alert: {
      name: "Alert",
      selector: "[data-te-alert-init]",
      isToggler: false
    },
    animation: {
      name: "Animate",
      selector: "[data-te-animation-init]",
      isToggler: false
    },
    carousel: {
      name: "Carousel",
      selector: "[data-te-carousel-init]",
      isToggler: false
    },
    chips: {
      name: "ChipsInput",
      selector: "[data-te-chips-input-init]",
      isToggler: false
    },
    chip: {
      name: "Chip",
      selector: "[data-te-chip-init]",
      isToggler: false,
      onInit: "init"
    },
    datepicker: {
      name: "Datepicker",
      selector: "[data-te-datepicker-init]",
      isToggler: false
    },
    datetimepicker: {
      name: "Datetimepicker",
      selector: "[data-te-date-timepicker-init]",
      isToggler: false
    },
    input: {
      name: "Input",
      selector: "[data-te-input-wrapper-init]",
      isToggler: false
    },
    perfectScrollbar: {
      name: "PerfectScrollbar",
      selector: "[data-te-perfect-scrollbar-init]",
      isToggler: false
    },
    rating: {
      name: "Rating",
      selector: "[data-te-rating-init]",
      isToggler: false
    },
    scrollspy: {
      name: "ScrollSpy",
      selector: "[data-te-spy='scroll']",
      isToggler: false
    },
    select: {
      name: "Select",
      selector: "[data-te-select-init]",
      isToggler: false
    },
    sidenav: {
      name: "Sidenav",
      selector: "[data-te-sidenav-init]",
      isToggler: false
    },
    stepper: {
      name: "Stepper",
      selector: "[data-te-stepper-init]",
      isToggler: false
    },
    timepicker: {
      name: "Timepicker",
      selector: "[data-te-timepicker-init]",
      isToggler: false
    },
    toast: {
      name: "Toast",
      selector: "[data-te-toast-init]",
      isToggler: false
    },
    datatable: {
      name: "Datatable",
      selector: "[data-te-datatable-init]"
    },
    popconfirm: {
      name: "Popconfirm",
      selector: "[data-te-toggle='popconfirm']"
    },
    validation: {
      name: "Validation",
      selector: "[data-te-validation-init]"
    },
    smoothScroll: {
      name: "SmoothScroll",
      selector: "a[data-te-smooth-scroll-init]"
    },
    lazyLoad: {
      name: "LazyLoad",
      selector: "[data-te-lazy-load-init]"
    },
    clipboard: {
      name: "Clipboard",
      selector: "[data-te-clipboard-init]"
    },
    infiniteScroll: {
      name: "InfiniteScroll",
      selector: "[data-te-infinite-scroll-init]"
    },
    loadingManagement: {
      name: "LoadingManagement",
      selector: "[data-te-loading-management-init]"
    },
    sticky: {
      name: "Sticky",
      selector: "[data-te-sticky-init]"
    },
    chart: {
      name: "Chart",
      selector: "[data-te-chart]",
      isToggler: false,
      advanced: HC
    },
    button: {
      name: "Button",
      selector: "[data-te-toggle='button']",
      isToggler: true,
      callback: $C
    },
    collapse: {
      name: "Collapse",
      selector: "[data-te-collapse-init]",
      isToggler: true,
      callback: MC
    },
    dropdown: {
      name: "Dropdown",
      selector: "[data-te-dropdown-toggle-ref]",
      isToggler: true,
      callback: SC
    },
    modal: {
      name: "Modal",
      selector: "[data-te-toggle='modal']",
      isToggler: true,
      callback: LC
    },
    ripple: {
      name: "Ripple",
      selector: "[data-te-ripple-init]",
      isToggler: true,
      callback: NC
    },
    offcanvas: {
      name: "Offcanvas",
      selector: "[data-te-offcanvas-toggle]",
      isToggler: true,
      callback: DC
    },
    tab: {
      name: "Tab",
      selector: "[data-te-toggle='tab'], [data-te-toggle='pill'], [data-te-toggle='list']",
      isToggler: true,
      callback: IC
    },
    tooltip: {
      name: "Tooltip",
      selector: "[data-te-toggle='tooltip']",
      isToggler: false,
      callback: RC
    },
    popover: {
      name: "Popover",
      selector: "[data-te-toggle='popover']",
      isToggler: true,
      callback: PC
    },
    lightbox: {
      name: "Lightbox",
      selector: "[data-te-lightbox-init]",
      isToggler: true,
      callback: BC
    },
    touch: {
      name: "Touch",
      selector: "[data-te-touch-init]"
    }
  };
  var WC = (s) => Oi[s.NAME] || null;
  var FC = (s, t) => {
    if (!s || !t.allowReinits && Go.isInited(s.NAME))
      return;
    Go.add(s.NAME);
    const e = WC(s), i = (e == null ? void 0 : e.isToggler) || false;
    if (OC(s), e != null && e.advanced) {
      e == null || e.advanced(s, e == null ? void 0 : e.selector);
      return;
    }
    if (i) {
      e == null || e.callback(s, e == null ? void 0 : e.selector);
      return;
    }
    d.find(e == null ? void 0 : e.selector).forEach((n) => {
      let o = s.getInstance(n);
      o || (o = new s(n), e != null && e.onInit && o[e.onInit]());
    });
  };
  var YC = (s, t) => {
    s.forEach((e) => FC(e, t));
  };
  var jC = {
    allowReinits: false,
    checkOtherImports: false
  };
  var ZC = (s, t = {}) => {
    t = __spreadValues(__spreadValues({}, jC), t);
    const e = Object.keys(Oi).map((i) => {
      if (!!document.querySelector(Oi[i].selector)) {
        const o = s[Oi[i].name];
        return !o && !Go.isInited(i) && t.checkOtherImports && console.warn(`Please import ${Oi[i].name} from "tw-elements" package and add it to a object parameter inside "initTE" function`), o;
      }
    });
    YC(e, t);
  };

  // __tmp__/static/js/tailwind.mjs
  ZC({ Validation: Ch, Select: _r });

  // __tmp__/static/js/index.mjs
  __reExport(js_exports, __toModule(require_public_adventures()));
  var import_parsons = __toModule(require_parsons());
  return js_exports;
})();
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
/*!
 * @kurkle/color v0.2.1
 * https://github.com/kurkle/color#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v3.9.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
/*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
/*!
* Tailwind Elements 1.0.0
* 
* Tailwind Elements is an open-source UI kit of advanced components for TailwindCSS.
* Copyright © 2023 MDBootstrap.com
* 
* Unless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
* In addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.
* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
* 
*/
/*! @license DOMPurify 2.3.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.5/LICENSE */
/*! Sortable 1.15.0 - MIT | git://github.com/SortableJS/Sortable.git */
//# sourceMappingURL=appbundle.js.map
