@top Program { eol* (Command eol+)* Command? }

Command {
    Assign | AssignList | Ask | Clear |Print | Turtle | Sleep | Add | Remove | If | Else | Repeat | For | Define | Call | Return | ErrorInvalid
}

IfLessCommand {
    Assign | AssignList | Ask | Clear |Print | Turtle | Sleep | Add | Remove | Repeat | For | Define | Call | Return | ErrorInvalid
}

@local tokens {    
    stringEnd { "'" | "\n" }    
    @else stringContent
  }
  
  @skip {} {
    String { "'" (stringContent)* stringEnd }
}


Print { kw<"print"> ( ListAccess | Expression | Call )+ }

AssignList { Text (kw<"is"> | Op<"=">) (Text+ | Number ) ~ambig  (Op<","> (Text+ | Number ))+ } // Op<","> doesn't really parse well if it is not separated by spaces
Assign { Text (kw<"is"> | Op<"=">) (Expression ~ambig  | ListAccess)+ }
Ask { Text (kw<"is"> | Op<"=">) kw<"ask"> ( ListAccess | Expression )+ }
Sleep { kw<"sleep"> (Expression | ListAccess | Call)? }

ListAccess { Text kw<"at"> (kw<"random"> | Text) }

Turtle[@isGroup=turtle] {
    Forward { kw<"forward"> (Expression | ListAccess | Call) } |
    Turn { kw<"turn"> (Expression | ListAccess | Call) } |
    Color { kw<"color"> (Expression | ListAccess | Call)  }
}   

Add { kw<"add"> (Expression | Call ) kw<"to"> Text }
Remove { kw<"remove"> (Expression | Call) kw<"from"> Text }
Clear { kw<"clear"> }
ErrorInvalid[@dynamicPrecedence=-10] { Text+ }

If { kw<"if"> Condition ((kw<"and"> | kw<"or">) Condition)* IfLessCommand? Else? }
Else { kw<"else"> IfLessCommand? }

Condition {    
    PressedCheck { Text ~cond kw<"is"> kw<"pressed"> } |
    EqualityCheck { (Expression | Call) (kw<"is"> | Op<"="> Op<"=">? ) (Expression | Call) } |
    NotEqualCheck { (Expression | Call) (Op<"!=">) (Expression | Call) } |
    ComparisonCheck { (Expression | Call) (Op<">"> | Op<"<">) Op<"=">? (Expression | Call) } |
    ListCheck { (Expression ~cond | Call) kw<"not">? kw<"in">  Text }
}


Repeat { kw<"repeat"> (Number | Text) kw<"times"> IfLessCommand }

For { kw<"for"> Text kw<"in"> (Text | kw<"range"> (Text | Number) kw<"to"> (Text | Number)) }

Define { kw<"define"> Text (kw<"with">  Arguments)? }
Call { kw<"call"> Text (kw<"with"> Arguments) }
Return { kw<"return"> ( ListAccess | Expression | Call)+ }


Arguments { argument (Op<","> argument)* }
argument { Expression | ListAccess }


kw<term> { @specialize[@name={term}]<Text, term> }
skw<term> { @extend[@name={term}]<Text, term> }
Op<expr> { expr }


atom { Number | Text }

binaryExpression {
    Expression !times Op<"*" | "/"> Expression |
    Expression !plus Op<"+" | "-"> Expression
}

// I should add Call here, but it works for now
Expression {
    Number |
    Text |
    String |
    binaryExpression
}

@precedence {
    times @left,
    plus @right
}


@tokens {
    @precedence {
        Number,
        Text
    }
    Comment { "#" ![\n]* }
    eol { "\n" }
    Text { ![^\n,،，、 '+#/*\-=><!]+ } // a little bit of a hack not to parse commas never, but lezer adds them as error nodes, so it still
    space { " " }
    Number { @digit+ ("." @digit+)? }
}

@skip { Comment | space }